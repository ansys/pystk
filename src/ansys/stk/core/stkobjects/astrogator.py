################################################################################
#          Copyright 2020-2020, Analytical Graphics, Inc.
################################################################################ 

__all__ = ["AgEVAAccessCriterion", "AgEVAAscentType", "AgEVAAtmosDataSource", "AgEVAAttitudeControl", "AgEVAAttitudeUpdate", 
"AgEVABaseSelection", "AgEVABodyAxis", "AgEVABurnoutOptions", "AgEVABurnoutType", "AgEVACalcObjectAngleSign", "AgEVACalcObjectCentralBodyReference", 
"AgEVACalcObjectDirection", "AgEVACalcObjectElem", "AgEVACalcObjectLocationSource", "AgEVACalcObjectOrbitPlaneSource", "AgEVACalcObjectReference", 
"AgEVACalcObjectReferenceDirection", "AgEVACalcObjectReferenceEllipse", "AgEVACalcObjectRelativePosition", "AgEVACalcObjectSunPosition", 
"AgEVACbAttitude", "AgEVACbEphemeris", "AgEVACbGravityModel", "AgEVACbShape", "AgEVAClearEphemerisDirection", "AgEVACoeffRKV8th9th", 
"AgEVAComplexNumber", "AgEVAConstraintSign", "AgEVAControlAdvanced", "AgEVAControlEngineConstAcc", "AgEVAControlEngineConstant", 
"AgEVAControlEngineCustom", "AgEVAControlEngineIon", "AgEVAControlEngineModelPoly", "AgEVAControlEngineThrottleTable", "AgEVAControlFollow", 
"AgEVAControlInitState", "AgEVAControlLaunch", "AgEVAControlManeuver", "AgEVAControlOrbitStateValue", "AgEVAControlPowerInternal", 
"AgEVAControlPowerProcessed", "AgEVAControlPowerSolarArray", "AgEVAControlRepeatingGroundTrackErr", "AgEVAControlStoppingCondition", 
"AgEVAControlThrusters", "AgEVAControlUpdate", "AgEVAConvergenceCriteria", "AgEVACriteria", "AgEVACriterion", "AgEVACustomFunction", 
"AgEVADCScalingMethod", "AgEVADeriveCalcMethod", "AgEVADifferenceOrder", "AgEVADragModelType", "AgEVADrawPerturbation", 
"AgEVAEclipsingBodiesSource", "AgEVAElement", "AgEVAElementType", "AgEVAEngineModelFunction", "AgEVAEphemSource", "AgEVAErrorControl", 
"AgEVAFollowJoin", "AgEVAFollowSeparation", "AgEVAFollowSpacecraftAndFuelTank", "AgEVAFormulation", "AgEVAGeoMagneticFluxSource", 
"AgEVAGeoMagneticFluxUpdateRate", "AgEVAGoldenSectionDesiredOperation", "AgEVAGraphOption", "AgEVAGravCoeffCoefficientType", 
"AgEVAGravCoeffNormalizationType", "AgEVAGravParamSource", "AgEVAGravitationalParameterSource", "AgEVAGridSearchDesiredOperation", 
"AgEVAIPOPTGoal", "AgEVAImpDeltaVRep", "AgEVALambertDirectionOfMotionType", "AgEVALambertOrbitalEnergyType", "AgEVALambertSolutionOptionType", 
"AgEVALambertTargetCoordType", "AgEVALanguage", "AgEVALaunchDisplaySystem", "AgEVALightingCondition", "AgEVAManeuverType", 
"AgEVAMarsGRAMDensityType", "AgEVANumericalIntegrator", "AgEVAOptimalFiniteDiscretizationStrategy", "AgEVAOptimalFiniteExportNodesFormat", 
"AgEVAOptimalFiniteGuessMethod", "AgEVAOptimalFiniteRunMode", "AgEVAOptimalFiniteSNOPTObjective", "AgEVAOptimalFiniteSNOPTScaling", 
"AgEVAOptimalFiniteScalingOptions", "AgEVAOptimalFiniteSeedMethod", "AgEVAOptimalFiniteWorkingVariables", "AgEVAPredictorCorrector", 
"AgEVAPressureMode", "AgEVAProfile", "AgEVAProfileInsertDirection", "AgEVAProfileMode", "AgEVAProfilesFinish", "AgEVAPropulsionMethod", 
"AgEVAReferenceRadiusSource", "AgEVAReturnControl", "AgEVARootFindingAlgorithm", "AgEVARunCode", "AgEVASNOPTGoal", "AgEVASTMEigenNumber", 
"AgEVASTMPertVariables", "AgEVAScriptingParameterType", "AgEVASegmentDifferenceOrder", "AgEVASegmentState", "AgEVASegmentType", 
"AgEVASequenceStateToPass", "AgEVAShadowModel", "AgEVASmartRunMode", "AgEVASolarForceMethod", "AgEVASquaredType", "AgEVAState", 
"AgEVAStoppingCondition", "AgEVASunPosition", "AgEVATabVecInterpMethod", "AgEVATargetSeqAction", "AgEVAThirdBodyMode", "AgEVAThrottleTableOperationMode", 
"AgEVAThrustType", "AgEVAThrusterDirection", "AgEVAUpdateAction", "AgEVAUpdateParam", "AgEVAVenusGRAMDensityType", "IVAAccessStoppingCondition", 
"IVAAsTriggerCondition", "IVAAttitudeControl", "IVAAttitudeControlFinite", "IVAAttitudeControlFiniteAntiVelocityVector", 
"IVAAttitudeControlFiniteAttitude", "IVAAttitudeControlFiniteFile", "IVAAttitudeControlFinitePlugin", "IVAAttitudeControlFiniteThrustVector", 
"IVAAttitudeControlFiniteTimeVarying", "IVAAttitudeControlFiniteVelocityVector", "IVAAttitudeControlImpulsive", "IVAAttitudeControlImpulsiveAntiVelocityVector", 
"IVAAttitudeControlImpulsiveAttitude", "IVAAttitudeControlImpulsiveFile", "IVAAttitudeControlImpulsiveThrustVector", "IVAAttitudeControlImpulsiveVelocityVector", 
"IVAAttitudeControlOptimalFinite", "IVAAttitudeControlOptimalFiniteLagrange", "IVAAutomaticSequence", "IVAAutomaticSequenceCollection", 
"IVABDotRCalc", "IVABDotTCalc", "IVABMagCalc", "IVABPlaneCollection", "IVABThetaCalc", "IVABlendedDensity", "IVABulirschStoerIntegrator", 
"IVABurnout", "IVABurnoutCBFCartesian", "IVABurnoutGeocentric", "IVABurnoutGeodetic", "IVABurnoutLaunchAzAlt", "IVABurnoutLaunchAzRadius", 
"IVABurnoutVelocity", "IVACR3BPFunc", "IVACalcObjectCollection", "IVACalcObjectLinkEmbedControlCollection", "IVACalculationGraphCollection", 
"IVACbAttitude", "IVACbAttitudeIAU1994", "IVACbAttitudeRotationCoefficientsFile", "IVACbEphemeris", "IVACbEphemerisAnalyticOrbit", 
"IVACbEphemerisFile", "IVACbEphemerisJPLDE", "IVACbEphemerisJPLSpice", "IVACbEphemerisPlanetary", "IVACbGravityModel", "IVACbShape", 
"IVACbShapeOblateSpheroid", "IVACbShapeSphere", "IVACbShapeTriaxialEllipsoid", "IVACentralBody", "IVACentralBodyCollection", 
"IVACira72Function", "IVAConstraintCollection", "IVACustomFunctionScriptEngine", "IVADCControl", "IVADCControlCollection", 
"IVADCResult", "IVADCResultCollection", "IVADTM2012", "IVADTM2020", "IVADensityModelPlugin", "IVADisplaySystem", "IVADisplaySystemGeocentric", 
"IVADisplaySystemGeodetic", "IVADragModelPlugin", "IVADriverMCS", "IVAEOMFuncPluginFunction", "IVAElement", "IVAElementBPlane", 
"IVAElementCartesian", "IVAElementDelaunay", "IVAElementEquinoctial", "IVAElementGeodetic", "IVAElementKeplerian", "IVAElementMixedSpherical", 
"IVAElementSpherical", "IVAElementTargetVectorIncomingAsymptote", "IVAElementTargetVectorOutgoingAsymptote", "IVAEngineConstAcc", 
"IVAEngineConstant", "IVAEngineCustom", "IVAEngineDefinition", "IVAEngineIon", "IVAEngineModelIspCoefficients", "IVAEngineModelPoly", 
"IVAEngineModelThrustCoefficients", "IVAEnginePlugin", "IVAEngineThrottleTable", "IVAExponential", "IVAFuelTank", "IVAGaussJacksonIntegrator", 
"IVAGeneralRelativityFunction", "IVAGoldenSectionControl", "IVAGoldenSectionControlCollection", "IVAGoldenSectionResult", 
"IVAGoldenSectionResultCollection", "IVAGravityFieldFunction", "IVAGridSearchControl", "IVAGridSearchControlCollection", 
"IVAGridSearchResult", "IVAGridSearchResultCollection", "IVAHPOPPluginFunction", "IVAHarrisPriester", "IVAIPOPTControl", 
"IVAIPOPTControlCollection", "IVAIPOPTResult", "IVAIPOPTResultCollection", "IVAJacchiaBowman2008", "IVAJacchiaRoberts", 
"IVAJacchia_1960", "IVAJacchia_1970", "IVAJacchia_1971", "IVALightingStoppingCondition", "IVAMCSBackwardSequence", "IVAMCSEnd", 
"IVAMCSFollow", "IVAMCSHold", "IVAMCSInitialState", "IVAMCSLaunch", "IVAMCSManeuver", "IVAMCSOptions", "IVAMCSPropagate", 
"IVAMCSReturn", "IVAMCSSegment", "IVAMCSSegmentCollection", "IVAMCSSegmentProperties", "IVAMCSSequence", "IVAMCSStop", "IVAMCSTargetSequence", 
"IVAMCSUpdate", "IVAMSISE_1990", "IVAMSIS_1986", "IVAManeuver", "IVAManeuverFinite", "IVAManeuverFinitePropagator", "IVAManeuverImpulsive", 
"IVAManeuverOptimalFinite", "IVAManeuverOptimalFiniteBounds", "IVAManeuverOptimalFiniteFinalBoundaryConditions", "IVAManeuverOptimalFiniteInitialBoundaryConditions", 
"IVAManeuverOptimalFinitePathBoundaryConditions", "IVAManeuverOptimalFiniteSNOPTOptimizer", "IVAManeuverOptimalFiniteSteeringNodeCollection", 
"IVAManeuverOptimalFiniteSteeringNodeElement", "IVAMarsGRAM2000", "IVAMarsGRAM2001", "IVAMarsGRAM2005", "IVAMarsGRAM2010", 
"IVAMarsGRAM37", "IVANRLMSISE_2000", "IVANumericalIntegrator", "IVANumericalPropagatorWrapper", "IVANumericalPropagatorWrapperCR3BP", 
"IVAPluginProperties", "IVAPointMassFunction", "IVAPowerInternal", "IVAPowerProcessed", "IVAPowerSolarArray", "IVAProfile", 
"IVAProfileChangeManeuverType", "IVAProfileChangePropagator", "IVAProfileChangeReturnSegment", "IVAProfileChangeStopSegment", 
"IVAProfileChangeStoppingConditionState", "IVAProfileCollection", "IVAProfileDifferentialCorrector", "IVAProfileGoldenSection", 
"IVAProfileGridSearch", "IVAProfileIPOPTOptimizer", "IVAProfileLambertProfile", "IVAProfileLambertSearchProfile", "IVAProfileRunOnce", 
"IVAProfileSNOPTOptimizer", "IVAProfileScriptingTool", "IVAProfileSearchPlugin", "IVAProfileSeedFiniteManeuver", "IVAPropagatorFunctionCollection", 
"IVARK2nd3rd", "IVARK4th", "IVARK4th5th", "IVARK4thAdapt", "IVARKF7th8th", "IVARKV8th9th", "IVARadiationPressureFunction", 
"IVASNOPTControl", "IVASNOPTControlCollection", "IVASNOPTResult", "IVASNOPTResultCollection", "IVASRPAeroT20", "IVASRPAeroT30", 
"IVASRPGSPM04aIIA", "IVASRPGSPM04aIIR", "IVASRPGSPM04aeIIA", "IVASRPGSPM04aeIIR", "IVASRPNPlate", "IVASRPReflectionPlugin", 
"IVASRPSpherical", "IVASRPTabAreaVec", "IVASRPVariableArea", "IVAScriptingCalcObject", "IVAScriptingCalcObjectCollection", 
"IVAScriptingParameter", "IVAScriptingParameterCollection", "IVAScriptingParameterEnumerationChoice", "IVAScriptingParameterEnumerationChoiceCollection", 
"IVAScriptingSegment", "IVAScriptingSegmentCollection", "IVAScriptingTool", "IVASearchPluginControl", "IVASearchPluginControlCollection", 
"IVASearchPluginResult", "IVASearchPluginResultCollection", "IVASpacecraftParameters", "IVAState", "IVAStateCalcAbsoluteValue", 
"IVAStateCalcAltOfApoapsis", "IVAStateCalcAltOfPeriapsis", "IVAStateCalcAngle", "IVAStateCalcApparentSolarTime", "IVAStateCalcArgOfLat", 
"IVAStateCalcArgOfPeriapsis", "IVAStateCalcBetaAngle", "IVAStateCalcC3Energy", "IVAStateCalcCartSTMElem", "IVAStateCalcCartesianElem", 
"IVAStateCalcCd", "IVAStateCalcCloseApproachBearing", "IVAStateCalcCloseApproachCosBearing", "IVAStateCalcCloseApproachMag", 
"IVAStateCalcCloseApproachTheta", "IVAStateCalcCloseApproachX", "IVAStateCalcCloseApproachY", "IVAStateCalcCosOfVerticalFPA", 
"IVAStateCalcCr", "IVAStateCalcCrdnAngle", "IVAStateCalcCurvilinearRelMotion", "IVAStateCalcCustomFunction", "IVAStateCalcDamageFlux", 
"IVAStateCalcDamageMassFlux", "IVAStateCalcDec", "IVAStateCalcDecRate", "IVAStateCalcDeltaDec", "IVAStateCalcDeltaFromMaster", 
"IVAStateCalcDeltaRA", "IVAStateCalcDeltaV", "IVAStateCalcDeltaVSquared", "IVAStateCalcDensity", "IVAStateCalcDifference", 
"IVAStateCalcDifferenceAcrossSegmentsOtherSat", "IVAStateCalcDifferenceOtherSegment", "IVAStateCalcDotProduct", "IVAStateCalcDragArea", 
"IVAStateCalcDuration", "IVAStateCalcEarthMeanLocTimeAN", "IVAStateCalcEarthMeanSolarTime", "IVAStateCalcEccAnomaly", "IVAStateCalcEccentricity", 
"IVAStateCalcEnvironment", "IVAStateCalcEpoch", "IVAStateCalcEquinoctialElem", "IVAStateCalcFPA", "IVAStateCalcFuelMass", 
"IVAStateCalcGeodeticElem", "IVAStateCalcGravCoeff", "IVAStateCalcGravitationalParameter", "IVAStateCalcHeightAboveTerrain", 
"IVAStateCalcImpactFlux", "IVAStateCalcImpactMassFlux", "IVAStateCalcInAsympDec", "IVAStateCalcInAsympRA", "IVAStateCalcInVelAzAtPeriapsis", 
"IVAStateCalcInclination", "IVAStateCalcInertialDeltaVMag", "IVAStateCalcInertialDeltaVx", "IVAStateCalcInertialDeltaVy", 
"IVAStateCalcInertialDeltaVz", "IVAStateCalcJacobiConstant", "IVAStateCalcLocalApparentSolarLon", "IVAStateCalcLonDriftRate", 
"IVAStateCalcLonOfAscNode", "IVAStateCalcLonOfPeriapsis", "IVAStateCalcMCSDeltaV", "IVAStateCalcMCSDeltaVSquared", "IVAStateCalcMagFieldDipoleL", 
"IVAStateCalcManeuverSpecificImpulse", "IVAStateCalcManeuverTotalMassFlowRate", "IVAStateCalcMass", "IVAStateCalcMaxValue", 
"IVAStateCalcMeanAnomaly", "IVAStateCalcMeanEarthLon", "IVAStateCalcMeanMotion", "IVAStateCalcMeanValue", "IVAStateCalcMedianValue", 
"IVAStateCalcMinValue", "IVAStateCalcNegative", "IVAStateCalcNumRevs", "IVAStateCalcOnePtAccess", "IVAStateCalcOrbitDelaunayG", 
"IVAStateCalcOrbitDelaunayH", "IVAStateCalcOrbitDelaunayL", "IVAStateCalcOrbitPeriod", "IVAStateCalcOrbitSemiLatusRectum", 
"IVAStateCalcOrbitStateValue", "IVAStateCalcOutAsympDec", "IVAStateCalcOutAsympRA", "IVAStateCalcOutVelAzAtPeriapsis", "IVAStateCalcPi", 
"IVAStateCalcPosDifferenceOtherSegment", "IVAStateCalcPosVelDifferenceOtherSegment", "IVAStateCalcPower", "IVAStateCalcPressure", 
"IVAStateCalcRA", "IVAStateCalcRAAN", "IVAStateCalcRARate", "IVAStateCalcRMag", "IVAStateCalcRadOfApoapsis", "IVAStateCalcRadOfPeriapsis", 
"IVAStateCalcRadiationPressureArea", "IVAStateCalcRadiationPressureCoefficient", "IVAStateCalcRectifiedLon", "IVAStateCalcReferenceRadius", 
"IVAStateCalcRelAtAOLMaster", "IVAStateCalcRelGroundTrackError", "IVAStateCalcRelMotion", "IVAStateCalcRelPosDecAngle", 
"IVAStateCalcRelPosInPlaneAngle", "IVAStateCalcRelativeInclination", "IVAStateCalcRepeatingGroundTrackErr", "IVAStateCalcSEETMagFieldFieldLineSepAngle", 
"IVAStateCalcSEETSAAFlux", "IVAStateCalcSEETVehTemp", "IVAStateCalcSRPArea", "IVAStateCalcSTMEigenval", "IVAStateCalcSTMEigenvecElem", 
"IVAStateCalcScalar", "IVAStateCalcScript", "IVAStateCalcSemiMajorAxis", "IVAStateCalcSequenceDeltaV", "IVAStateCalcSequenceDeltaVSquared", 
"IVAStateCalcSignedEccentricity", "IVAStateCalcSolarBetaAngle", "IVAStateCalcSolarInPlaneAngle", "IVAStateCalcSpeedOfLight", 
"IVAStateCalcStandardDeviation", "IVAStateCalcTemperature", "IVAStateCalcTimePastAscNode", "IVAStateCalcTimePastPeriapsis", 
"IVAStateCalcTrueAnomaly", "IVAStateCalcTrueLon", "IVAStateCalcUserValue", "IVAStateCalcVMag", "IVAStateCalcValueAtSegment", 
"IVAStateCalcValueAtSegmentOtherSat", "IVAStateCalcVectorDec", "IVAStateCalcVectorMag", "IVAStateCalcVectorRA", "IVAStateCalcVectorX", 
"IVAStateCalcVectorY", "IVAStateCalcVectorZ", "IVAStateCalcVelAz", "IVAStateCalcVelDifferenceOtherSegment", "IVAStateTransFunction", 
"IVAStoppingCondition", "IVAStoppingConditionCollection", "IVAStoppingConditionComponent", "IVAStoppingConditionElement", 
"IVATargeterGraph", "IVATargeterGraphActiveControl", "IVATargeterGraphActiveControlCollection", "IVATargeterGraphCollection", 
"IVATargeterGraphResult", "IVATargeterGraphResultCollection", "IVAThirdBodyFunction", "IVAThruster", "IVAThrusterSet", "IVAThrusterSetCollection", 
"IVATwoBodyFunction", "IVAUS_Standard_Atmosphere", "IVAUserVariable", "IVAUserVariableCollection", "IVAUserVariableDefinition", 
"IVAUserVariableDefinitionCollection", "IVAUserVariableUpdate", "IVAUserVariableUpdateCollection", "IVAVenusGRAM2005", "IVAYarkovskyFunc", 
"VAAccessStoppingCondition", "VAAsTriggerCondition", "VAAttitudeControlFiniteAntiVelocityVector", "VAAttitudeControlFiniteAttitude", 
"VAAttitudeControlFiniteFile", "VAAttitudeControlFinitePlugin", "VAAttitudeControlFiniteThrustVector", "VAAttitudeControlFiniteTimeVarying", 
"VAAttitudeControlFiniteVelocityVector", "VAAttitudeControlImpulsiveAntiVelocityVector", "VAAttitudeControlImpulsiveAttitude", 
"VAAttitudeControlImpulsiveFile", "VAAttitudeControlImpulsiveThrustVector", "VAAttitudeControlImpulsiveVelocityVector", 
"VAAttitudeControlOptimalFiniteLagrange", "VAAutomaticSequence", "VAAutomaticSequenceCollection", "VABDotRCalc", "VABDotTCalc", 
"VABMagCalc", "VABPlaneCollection", "VABThetaCalc", "VABlendedDensity", "VABulirschStoerIntegrator", "VABurnoutCBFCartesian", 
"VABurnoutGeocentric", "VABurnoutGeodetic", "VABurnoutLaunchAzAlt", "VABurnoutLaunchAzRadius", "VABurnoutVelocity", "VACR3BPFunc", 
"VACalcObjectCollection", "VACalcObjectLinkEmbedControlCollection", "VACalculationGraphCollection", "VACbAttitudeIAU1994", 
"VACbAttitudeRotationCoefficientsFile", "VACbEphemerisAnalyticOrbit", "VACbEphemerisFile", "VACbEphemerisJPLDE", "VACbEphemerisJPLSpice", 
"VACbEphemerisPlanetary", "VACbGravityModel", "VACbShapeOblateSpheroid", "VACbShapeSphere", "VACbShapeTriaxialEllipsoid", 
"VACentralBody", "VACentralBodyCollection", "VACira72Function", "VAConstraintCollection", "VACustomFunctionScriptEngine", 
"VADCControl", "VADCControlCollection", "VADCResult", "VADCResultCollection", "VADTM2012", "VADTM2020", "VADensityModelPlugin", 
"VADisplaySystemGeocentric", "VADisplaySystemGeodetic", "VADragModelPlugin", "VADriverMCS", "VAEOMFuncPluginFunction", "VAElementBPlane", 
"VAElementCartesian", "VAElementDelaunay", "VAElementEquinoctial", "VAElementGeodetic", "VAElementKeplerian", "VAElementMixedSpherical", 
"VAElementSpherical", "VAElementTargetVectorIncomingAsymptote", "VAElementTargetVectorOutgoingAsymptote", "VAEngineConstAcc", 
"VAEngineConstant", "VAEngineCustom", "VAEngineDefinition", "VAEngineIon", "VAEngineModelIspCoefficients", "VAEngineModelPoly", 
"VAEngineModelThrustCoefficients", "VAEnginePlugin", "VAEngineThrottleTable", "VAExponential", "VAFuelTank", "VAGaussJacksonIntegrator", 
"VAGeneralRelativityFunction", "VAGoldenSectionControl", "VAGoldenSectionControlCollection", "VAGoldenSectionResult", "VAGoldenSectionResultCollection", 
"VAGravityFieldFunction", "VAGridSearchControl", "VAGridSearchControlCollection", "VAGridSearchResult", "VAGridSearchResultCollection", 
"VAHPOPPluginFunction", "VAHarrisPriester", "VAIPOPTControl", "VAIPOPTControlCollection", "VAIPOPTResult", "VAIPOPTResultCollection", 
"VAJacchiaBowman2008", "VAJacchiaRoberts", "VAJacchia_1960", "VAJacchia_1970", "VAJacchia_1971", "VALightingStoppingCondition", 
"VAMCSBackwardSequence", "VAMCSEnd", "VAMCSFollow", "VAMCSHold", "VAMCSInitialState", "VAMCSLaunch", "VAMCSManeuver", "VAMCSOptions", 
"VAMCSPropagate", "VAMCSReturn", "VAMCSSegmentCollection", "VAMCSSegmentProperties", "VAMCSSequence", "VAMCSStop", "VAMCSTargetSequence", 
"VAMCSUpdate", "VAMSISE_1990", "VAMSIS_1986", "VAManeuverFinite", "VAManeuverFinitePropagator", "VAManeuverImpulsive", "VAManeuverOptimalFinite", 
"VAManeuverOptimalFiniteBounds", "VAManeuverOptimalFiniteFinalBoundaryConditions", "VAManeuverOptimalFiniteInitialBoundaryConditions", 
"VAManeuverOptimalFinitePathBoundaryConditions", "VAManeuverOptimalFiniteSNOPTOptimizer", "VAManeuverOptimalFiniteSteeringNodeCollection", 
"VAManeuverOptimalFiniteSteeringNodeElement", "VAMarsGRAM2000", "VAMarsGRAM2001", "VAMarsGRAM2005", "VAMarsGRAM2010", "VAMarsGRAM37", 
"VANRLMSISE_2000", "VANumericalPropagatorWrapper", "VANumericalPropagatorWrapperCR3BP", "VAPluginProperties", "VAPointMassFunction", 
"VAPowerInternal", "VAPowerProcessed", "VAPowerSolarArray", "VAProfileChangeManeuverType", "VAProfileChangePropagator", 
"VAProfileChangeReturnSegment", "VAProfileChangeStopSegment", "VAProfileChangeStoppingConditionState", "VAProfileCollection", 
"VAProfileDifferentialCorrector", "VAProfileGoldenSection", "VAProfileGridSearch", "VAProfileIPOPTOptimizer", "VAProfileLambertProfile", 
"VAProfileLambertSearchProfile", "VAProfileRunOnce", "VAProfileSNOPTOptimizer", "VAProfileScriptingTool", "VAProfileSearchPlugin", 
"VAProfileSeedFiniteManeuver", "VAPropagatorFunctionCollection", "VARK2nd3rd", "VARK4th", "VARK4th5th", "VARK4thAdapt", 
"VARKF7th8th", "VARKV8th9th", "VARadiationPressureFunction", "VASNOPTControl", "VASNOPTControlCollection", "VASNOPTResult", 
"VASNOPTResultCollection", "VASRPAeroT20", "VASRPAeroT30", "VASRPGSPM04aIIA", "VASRPGSPM04aIIR", "VASRPGSPM04aeIIA", "VASRPGSPM04aeIIR", 
"VASRPNPlate", "VASRPReflectionPlugin", "VASRPSpherical", "VASRPTabAreaVec", "VASRPVariableArea", "VAScriptingCalcObject", 
"VAScriptingCalcObjectCollection", "VAScriptingParameter", "VAScriptingParameterCollection", "VAScriptingParameterEnumerationChoice", 
"VAScriptingParameterEnumerationChoiceCollection", "VAScriptingSegment", "VAScriptingSegmentCollection", "VAScriptingTool", 
"VASearchPluginControl", "VASearchPluginControlCollection", "VASearchPluginResult", "VASearchPluginResultCollection", "VASpacecraftParameters", 
"VAState", "VAStateCalcAbsoluteValue", "VAStateCalcAltOfApoapsis", "VAStateCalcAltOfPeriapsis", "VAStateCalcAngle", "VAStateCalcApparentSolarTime", 
"VAStateCalcArgOfLat", "VAStateCalcArgOfPeriapsis", "VAStateCalcBetaAngle", "VAStateCalcC3Energy", "VAStateCalcCartSTMElem", 
"VAStateCalcCartesianElem", "VAStateCalcCd", "VAStateCalcCloseApproachBearing", "VAStateCalcCloseApproachCosBearing", "VAStateCalcCloseApproachMag", 
"VAStateCalcCloseApproachTheta", "VAStateCalcCloseApproachX", "VAStateCalcCloseApproachY", "VAStateCalcCosOfVerticalFPA", 
"VAStateCalcCr", "VAStateCalcCrdnAngle", "VAStateCalcCurvilinearRelMotion", "VAStateCalcCustomFunction", "VAStateCalcDamageFlux", 
"VAStateCalcDamageMassFlux", "VAStateCalcDec", "VAStateCalcDecRate", "VAStateCalcDeltaDec", "VAStateCalcDeltaFromMaster", 
"VAStateCalcDeltaRA", "VAStateCalcDeltaV", "VAStateCalcDeltaVSquared", "VAStateCalcDensity", "VAStateCalcDifference", "VAStateCalcDifferenceAcrossSegmentsOtherSat", 
"VAStateCalcDifferenceOtherSegment", "VAStateCalcDotProduct", "VAStateCalcDragArea", "VAStateCalcDuration", "VAStateCalcEarthMeanLocTimeAN", 
"VAStateCalcEarthMeanSolarTime", "VAStateCalcEccAnomaly", "VAStateCalcEccentricity", "VAStateCalcEnvironment", "VAStateCalcEpoch", 
"VAStateCalcEquinoctialElem", "VAStateCalcFPA", "VAStateCalcFuelMass", "VAStateCalcGeodeticElem", "VAStateCalcGravCoeff", 
"VAStateCalcGravitationalParameter", "VAStateCalcHeightAboveTerrain", "VAStateCalcImpactFlux", "VAStateCalcImpactMassFlux", 
"VAStateCalcInAsympDec", "VAStateCalcInAsympRA", "VAStateCalcInVelAzAtPeriapsis", "VAStateCalcInclination", "VAStateCalcInertialDeltaVMag", 
"VAStateCalcInertialDeltaVx", "VAStateCalcInertialDeltaVy", "VAStateCalcInertialDeltaVz", "VAStateCalcJacobiConstant", "VAStateCalcLocalApparentSolarLon", 
"VAStateCalcLonDriftRate", "VAStateCalcLonOfAscNode", "VAStateCalcLonOfPeriapsis", "VAStateCalcMCSDeltaV", "VAStateCalcMCSDeltaVSquared", 
"VAStateCalcMagFieldDipoleL", "VAStateCalcManeuverSpecificImpulse", "VAStateCalcManeuverTotalMassFlowRate", "VAStateCalcMass", 
"VAStateCalcMaxValue", "VAStateCalcMeanAnomaly", "VAStateCalcMeanEarthLon", "VAStateCalcMeanMotion", "VAStateCalcMeanValue", 
"VAStateCalcMedianValue", "VAStateCalcMinValue", "VAStateCalcNegative", "VAStateCalcNumRevs", "VAStateCalcOnePtAccess", 
"VAStateCalcOrbitDelaunayG", "VAStateCalcOrbitDelaunayH", "VAStateCalcOrbitDelaunayL", "VAStateCalcOrbitPeriod", "VAStateCalcOrbitSemiLatusRectum", 
"VAStateCalcOrbitStateValue", "VAStateCalcOutAsympDec", "VAStateCalcOutAsympRA", "VAStateCalcOutVelAzAtPeriapsis", "VAStateCalcPi", 
"VAStateCalcPosDifferenceOtherSegment", "VAStateCalcPosVelDifferenceOtherSegment", "VAStateCalcPower", "VAStateCalcPressure", 
"VAStateCalcRA", "VAStateCalcRAAN", "VAStateCalcRARate", "VAStateCalcRMag", "VAStateCalcRadOfApoapsis", "VAStateCalcRadOfPeriapsis", 
"VAStateCalcRadiationPressureArea", "VAStateCalcRadiationPressureCoefficient", "VAStateCalcRectifiedLon", "VAStateCalcReferenceRadius", 
"VAStateCalcRelAtAOLMaster", "VAStateCalcRelGroundTrackError", "VAStateCalcRelMotion", "VAStateCalcRelPosDecAngle", "VAStateCalcRelPosInPlaneAngle", 
"VAStateCalcRelativeInclination", "VAStateCalcRepeatingGroundTrackErr", "VAStateCalcSEETMagFieldFieldLineSepAngle", "VAStateCalcSEETSAAFlux", 
"VAStateCalcSEETVehTemp", "VAStateCalcSRPArea", "VAStateCalcSTMEigenval", "VAStateCalcSTMEigenvecElem", "VAStateCalcScalar", 
"VAStateCalcScript", "VAStateCalcSemiMajorAxis", "VAStateCalcSequenceDeltaV", "VAStateCalcSequenceDeltaVSquared", "VAStateCalcSignedEccentricity", 
"VAStateCalcSolarBetaAngle", "VAStateCalcSolarInPlaneAngle", "VAStateCalcSpeedOfLight", "VAStateCalcStandardDeviation", 
"VAStateCalcTemperature", "VAStateCalcTimePastAscNode", "VAStateCalcTimePastPeriapsis", "VAStateCalcTrueAnomaly", "VAStateCalcTrueLon", 
"VAStateCalcUserValue", "VAStateCalcVMag", "VAStateCalcValueAtSegment", "VAStateCalcValueAtSegmentOtherSat", "VAStateCalcVectorDec", 
"VAStateCalcVectorMag", "VAStateCalcVectorRA", "VAStateCalcVectorX", "VAStateCalcVectorY", "VAStateCalcVectorZ", "VAStateCalcVelAz", 
"VAStateCalcVelDifferenceOtherSegment", "VAStateTransFunction", "VAStoppingCondition", "VAStoppingConditionCollection", 
"VAStoppingConditionElement", "VATargeterGraph", "VATargeterGraphActiveControl", "VATargeterGraphActiveControlCollection", 
"VATargeterGraphCollection", "VATargeterGraphResult", "VATargeterGraphResultCollection", "VAThirdBodyFunction", "VAThruster", 
"VAThrusterSet", "VAThrusterSetCollection", "VATwoBodyFunction", "VAUS_Standard_Atmosphere", "VAUserVariable", "VAUserVariableCollection", 
"VAUserVariableDefinition", "VAUserVariableDefinitionCollection", "VAUserVariableUpdate", "VAUserVariableUpdateCollection", 
"VAVenusGRAM2005", "VAYarkovskyFunc"]

import typing

from ctypes   import byref, POINTER
from datetime import datetime
from enum     import IntEnum, IntFlag

try:
    from numpy import ndarray
except ModuleNotFoundError:
    pass
    
try:
    from pandas import DataFrame
except ModuleNotFoundError:
    pass

from ..internal  import comutil          as agcom
from ..internal  import coclassutil      as agcls
from ..internal  import marshall         as agmarshall
from ..internal  import dataanalysisutil as agdata
from ..utilities import colors           as agcolor
from ..internal.comutil     import IUnknown, IDispatch, IPictureDisp, IAGFUNCTYPE, IEnumVARIANT
from ..internal.eventutil   import *
from ..utilities.exceptions import *

from ..stkutil import *
from ..stkobjects import *


def _raise_uninitialized_error(*args):
    raise STKRuntimeError("Valid STK object model classes are returned from STK methods and should not be created independently.")

class AgEVAGraphOption(IntEnum):
    """Mode that the mcs will run in."""
    # Don't graph.
    eVAGraphOptionNoGraph = 0
    # Graph the difference.
    eVAGraphOptionGraphDifference = 1
    # Graph the value.
    eVAGraphOptionGraphValue = 2

AgEVAGraphOption.eVAGraphOptionNoGraph.__doc__ = "Don't graph."
AgEVAGraphOption.eVAGraphOptionGraphDifference.__doc__ = "Graph the difference."
AgEVAGraphOption.eVAGraphOptionGraphValue.__doc__ = "Graph the value."

agcls.AgTypeNameMap["AgEVAGraphOption"] = AgEVAGraphOption

class AgEVASmartRunMode(IntEnum):
    """Mode that the mcs will run in."""
    # Run Entire Mission Control Sequence
    eVASmartRunModeEntireMCS = 0
    # Run Only Changed Segments
    eVASmartRunModeOnlyChanged = 1

AgEVASmartRunMode.eVASmartRunModeEntireMCS.__doc__ = "Run Entire Mission Control Sequence"
AgEVASmartRunMode.eVASmartRunModeOnlyChanged.__doc__ = "Run Only Changed Segments"

agcls.AgTypeNameMap["AgEVASmartRunMode"] = AgEVASmartRunMode

class AgEVAFormulation(IntEnum):
    """Equinoctial Formulation."""
    # Posigrade.
    eVAFormulationPosigrade = 0
    # Retrograde.
    eVAFormulationRetrograde = 1

AgEVAFormulation.eVAFormulationPosigrade.__doc__ = "Posigrade."
AgEVAFormulation.eVAFormulationRetrograde.__doc__ = "Retrograde."

agcls.AgTypeNameMap["AgEVAFormulation"] = AgEVAFormulation

class AgEVALightingCondition(IntEnum):
    """The criteria of a Lighting stopping condition."""
    # The Enter Direct Sun criterion.
    eVALightingCriterionEnterDirectSun = 0
    # The Exit Direct Sun criterion.
    eVALightingCriterionExitDirectSun = 1
    # The Enter Umbra criterion.
    eVALightingCriterionEnterUmbra = 2
    # The Exit Umbra criterion.
    eVALightingCriterionExitUmbra = 3

AgEVALightingCondition.eVALightingCriterionEnterDirectSun.__doc__ = "The Enter Direct Sun criterion."
AgEVALightingCondition.eVALightingCriterionExitDirectSun.__doc__ = "The Exit Direct Sun criterion."
AgEVALightingCondition.eVALightingCriterionEnterUmbra.__doc__ = "The Enter Umbra criterion."
AgEVALightingCondition.eVALightingCriterionExitUmbra.__doc__ = "The Exit Umbra criterion."

agcls.AgTypeNameMap["AgEVALightingCondition"] = AgEVALightingCondition

class AgEVAProfile(IntEnum):
    """Type of profile."""
    # Plugin search profile.
    eVAProfileSearchPlugin = 0
    # Differential corrector profile.
    eVAProfileDifferentialCorrector = 2
    # Change maneuver type profile.
    eVAProfileChangeManeuverType = 3
    # Scripting tool profile.
    eVAProfileScriptingTool = 4
    # Change return segment profile.
    eVAProfileChangeReturnSegment = 5
    # Change propagator profile.
    eVAProfileChangePropagator = 6
    # Change stop segment profile.
    eVAProfileChangeStopSegment = 7
    # Change stopping condition state profile.
    eVAProfileChangeStoppingConditionState = 8
    # Change seed finite maneuver profile.
    eVAProfileSeedFiniteManeuver = 9
    # Run once profile.
    eVAProfileRunOnce = 10
    # SNOPT Optimizer profile.
    eVAProfileSNOPTOptimizer = 11
    # IPOPT Optimizer profile.
    eVAProfileIPOPTOptimizer = 12
    # Lambert profile.
    eVAProfileLambertProfile = 13
    # Lambert Search profile.
    eVAProfileLambertSearchProfile = 14
    # Golden Section profile.
    eVAProfileGoldenSection = 15
    # grid Search profile.
    eVAProfileGridSearch = 16

AgEVAProfile.eVAProfileSearchPlugin.__doc__ = "Plugin search profile."
AgEVAProfile.eVAProfileDifferentialCorrector.__doc__ = "Differential corrector profile."
AgEVAProfile.eVAProfileChangeManeuverType.__doc__ = "Change maneuver type profile."
AgEVAProfile.eVAProfileScriptingTool.__doc__ = "Scripting tool profile."
AgEVAProfile.eVAProfileChangeReturnSegment.__doc__ = "Change return segment profile."
AgEVAProfile.eVAProfileChangePropagator.__doc__ = "Change propagator profile."
AgEVAProfile.eVAProfileChangeStopSegment.__doc__ = "Change stop segment profile."
AgEVAProfile.eVAProfileChangeStoppingConditionState.__doc__ = "Change stopping condition state profile."
AgEVAProfile.eVAProfileSeedFiniteManeuver.__doc__ = "Change seed finite maneuver profile."
AgEVAProfile.eVAProfileRunOnce.__doc__ = "Run once profile."
AgEVAProfile.eVAProfileSNOPTOptimizer.__doc__ = "SNOPT Optimizer profile."
AgEVAProfile.eVAProfileIPOPTOptimizer.__doc__ = "IPOPT Optimizer profile."
AgEVAProfile.eVAProfileLambertProfile.__doc__ = "Lambert profile."
AgEVAProfile.eVAProfileLambertSearchProfile.__doc__ = "Lambert Search profile."
AgEVAProfile.eVAProfileGoldenSection.__doc__ = "Golden Section profile."
AgEVAProfile.eVAProfileGridSearch.__doc__ = "grid Search profile."

agcls.AgTypeNameMap["AgEVAProfile"] = AgEVAProfile

class AgEVAAccessCriterion(IntEnum):
    """The criteria of an Access stopping condition."""
    # The Gain Access criterion.
    eVAAccessCriterionGain = 0
    # The Lose Access criterion.
    eVAAccessCriterionLose = 1
    # The Either criterion.
    eVAAccessCriterionEither = 2

AgEVAAccessCriterion.eVAAccessCriterionGain.__doc__ = "The Gain Access criterion."
AgEVAAccessCriterion.eVAAccessCriterionLose.__doc__ = "The Lose Access criterion."
AgEVAAccessCriterion.eVAAccessCriterionEither.__doc__ = "The Either criterion."

agcls.AgTypeNameMap["AgEVAAccessCriterion"] = AgEVAAccessCriterion

class AgEVAEclipsingBodiesSource(IntEnum):
    """The source types of the eclipsing bodies list."""
    # The eclipsing bodies list of the propagator's central body.
    eVAEclipsingBodiesPropagatorCb = 0
    # A user-defined eclipsing bodies list related to the propagator's central body.
    eVAEclipsingBodiesUserDefined = 1
    # The eclipsing bodies list of the vehicle's central body.
    eVAEclipsingBodiesVehicleCb = 2
    # A list of eclipsing bodies from the vehicle's Basic Properties->Eclipse Bodies list.
    eVAEclipsingBodiesVehicleUserDefined = 3

AgEVAEclipsingBodiesSource.eVAEclipsingBodiesPropagatorCb.__doc__ = "The eclipsing bodies list of the propagator's central body."
AgEVAEclipsingBodiesSource.eVAEclipsingBodiesUserDefined.__doc__ = "A user-defined eclipsing bodies list related to the propagator's central body."
AgEVAEclipsingBodiesSource.eVAEclipsingBodiesVehicleCb.__doc__ = "The eclipsing bodies list of the vehicle's central body."
AgEVAEclipsingBodiesSource.eVAEclipsingBodiesVehicleUserDefined.__doc__ = "A list of eclipsing bodies from the vehicle's Basic Properties->Eclipse Bodies list."

agcls.AgTypeNameMap["AgEVAEclipsingBodiesSource"] = AgEVAEclipsingBodiesSource

class AgEVACriterion(IntEnum):
    """The stopping condition criterion types."""
    # The Cross Decreasing criterion - the stopping condition is satisfied when the parameter reaches a value equal to the trip value while decreasing.
    eVACriterionCrossDecreasing = 0
    # The Cross Either criterion - the stopping condition is satisfied when either of the above situations occurs.
    eVACriterionCrossEither = 1
    # The Cross Increasing criterion - the stopping condition is satisfied when the parameter reaches a value equal to the trip value while increasing.
    eVACriterionCrossIncreasing = 2

AgEVACriterion.eVACriterionCrossDecreasing.__doc__ = "The Cross Decreasing criterion - the stopping condition is satisfied when the parameter reaches a value equal to the trip value while decreasing."
AgEVACriterion.eVACriterionCrossEither.__doc__ = "The Cross Either criterion - the stopping condition is satisfied when either of the above situations occurs."
AgEVACriterion.eVACriterionCrossIncreasing.__doc__ = "The Cross Increasing criterion - the stopping condition is satisfied when the parameter reaches a value equal to the trip value while increasing."

agcls.AgTypeNameMap["AgEVACriterion"] = AgEVACriterion

class AgEVACalcObjectReference(IntEnum):
    """The calculation object Reference Selection types."""
    # The Use Basic Reference type - uses the current satellite as the reference vehicle.
    eVACalcObjectReferenceBasic = 0
    # The UserSpecifiedReference type - uses a user specified vehicle object as the reference vehicle.
    eVACalcObjectReferenceSpecified = 1

AgEVACalcObjectReference.eVACalcObjectReferenceBasic.__doc__ = "The Use Basic Reference type - uses the current satellite as the reference vehicle."
AgEVACalcObjectReference.eVACalcObjectReferenceSpecified.__doc__ = "The UserSpecifiedReference type - uses a user specified vehicle object as the reference vehicle."

agcls.AgTypeNameMap["AgEVACalcObjectReference"] = AgEVACalcObjectReference

class AgEVACalcObjectCentralBodyReference(IntEnum):
    """The calculation object Central Body Reference Selection types."""
    # The Use Basic Reference type - uses the current satellite as the reference vehicle.
    eVACalcObjectCentralBodyReferenceSpecified = 0
    # The UserSpecifiedReference type - uses a user specified vehicle object as the reference vehicle.
    eVACalcObjectCentralBodyReferenceParent = 1

AgEVACalcObjectCentralBodyReference.eVACalcObjectCentralBodyReferenceSpecified.__doc__ = "The Use Basic Reference type - uses the current satellite as the reference vehicle."
AgEVACalcObjectCentralBodyReference.eVACalcObjectCentralBodyReferenceParent.__doc__ = "The UserSpecifiedReference type - uses a user specified vehicle object as the reference vehicle."

agcls.AgTypeNameMap["AgEVACalcObjectCentralBodyReference"] = AgEVACalcObjectCentralBodyReference

class AgEVACalcObjectElem(IntEnum):
    """The calculation object Element Types."""
    # Brouwer-Lyddane mean elements considering both the short and long period terms (i.e. resulting from averaging over the rotation of periapse). The perturbation terms are the J2, J3, J4 and J5 oblateness terms and it considers the term involving J2^2.
    eVACalcObjectElemBrouwerLyddaneMeanLong = 0
    # Brouwer-Lyddane Mean Short - Brouwer-Lyddane mean elements considering only the short period terms (i.e. those involving averaging over the period of the orbit) where the only perturbation force is the oblateness arising from the J2 gravity term.
    eVACalcObjectElemBrouwerLyddaneMeanShort = 1
    # Kozai-Izsak Mean - Kozai-Izsak mean elements for which only the short period terms (i.e. those involving averaging over the period of the orbit) are considered. The only perturbation force considered is the oblateness arising from the J2 gravity term.
    eVACalcObjectElemKozaiIzsakMean = 2
    # Osculating.
    eVACalcObjectElemOsculating = 3

AgEVACalcObjectElem.eVACalcObjectElemBrouwerLyddaneMeanLong.__doc__ = "Brouwer-Lyddane mean elements considering both the short and long period terms (i.e. resulting from averaging over the rotation of periapse). The perturbation terms are the J2, J3, J4 and J5 oblateness terms and it considers the term involving J2^2."
AgEVACalcObjectElem.eVACalcObjectElemBrouwerLyddaneMeanShort.__doc__ = "Brouwer-Lyddane Mean Short - Brouwer-Lyddane mean elements considering only the short period terms (i.e. those involving averaging over the period of the orbit) where the only perturbation force is the oblateness arising from the J2 gravity term."
AgEVACalcObjectElem.eVACalcObjectElemKozaiIzsakMean.__doc__ = "Kozai-Izsak Mean - Kozai-Izsak mean elements for which only the short period terms (i.e. those involving averaging over the period of the orbit) are considered. The only perturbation force considered is the oblateness arising from the J2 gravity term."
AgEVACalcObjectElem.eVACalcObjectElemOsculating.__doc__ = "Osculating."

agcls.AgTypeNameMap["AgEVACalcObjectElem"] = AgEVACalcObjectElem

class AgEVAProfileMode(IntEnum):
    """The Target Sequence profile modes."""
    # Iterate - the Target Sequence will run the profile as it is configured in an attempt to attain the desired solution.
    eVAProfileModeIterate = 0
    # Not Active - the Target Sequence will ignore the profile when running.
    eVAProfileModeNotActive = 1
    # Run Once - the Target Sequence will run the profile once according to its current configuration.
    eVAProfileModeRunOnce = 2
    # Active - the Target Sequence will apply the change that the profile passes when running.
    eVAProfileModeActive = 3

AgEVAProfileMode.eVAProfileModeIterate.__doc__ = "Iterate - the Target Sequence will run the profile as it is configured in an attempt to attain the desired solution."
AgEVAProfileMode.eVAProfileModeNotActive.__doc__ = "Not Active - the Target Sequence will ignore the profile when running."
AgEVAProfileMode.eVAProfileModeRunOnce.__doc__ = "Run Once - the Target Sequence will run the profile once according to its current configuration."
AgEVAProfileMode.eVAProfileModeActive.__doc__ = "Active - the Target Sequence will apply the change that the profile passes when running."

agcls.AgTypeNameMap["AgEVAProfileMode"] = AgEVAProfileMode

class AgEVAControlStoppingCondition(IntEnum):
    """The stopping condition control types."""
    # Trip - the value at which the stopping condition will be satisfied.
    eVAControlStoppingConditionTripValue = 0

AgEVAControlStoppingCondition.eVAControlStoppingConditionTripValue.__doc__ = "Trip - the value at which the stopping condition will be satisfied."

agcls.AgTypeNameMap["AgEVAControlStoppingCondition"] = AgEVAControlStoppingCondition

class AgEVAState(IntEnum):
    """The Stop segment state types."""
    # Enabled - the segment stops the run of the MCS.
    eVAStateEnabled = 0
    # Disabled - the MCS ignores this segment and continues to run.
    eVAStateDisabled = 1

AgEVAState.eVAStateEnabled.__doc__ = "Enabled - the segment stops the run of the MCS."
AgEVAState.eVAStateDisabled.__doc__ = "Disabled - the MCS ignores this segment and continues to run."

agcls.AgTypeNameMap["AgEVAState"] = AgEVAState

class AgEVAReturnControl(IntEnum):
    """The Return segment control types"""
    # Enable - returns control of the MCS run to the parent segment.
    eVAReturnControlEnable = 0
    # Disable - the MCS ignores this segment and continues to run.
    eVAReturnControlDisable = 1
    # Enable (except Profiles bypass)- functions as enabled except when run from a Target Sequence profile (e.g., a differential corrector), which will ignore it.
    eVAReturnControlEnableExceptProfilesBypass = 2

AgEVAReturnControl.eVAReturnControlEnable.__doc__ = "Enable - returns control of the MCS run to the parent segment."
AgEVAReturnControl.eVAReturnControlDisable.__doc__ = "Disable - the MCS ignores this segment and continues to run."
AgEVAReturnControl.eVAReturnControlEnableExceptProfilesBypass.__doc__ = "Enable (except Profiles bypass)- functions as enabled except when run from a Target Sequence profile (e.g., a differential corrector), which will ignore it."

agcls.AgTypeNameMap["AgEVAReturnControl"] = AgEVAReturnControl

class AgEVADrawPerturbation(IntEnum):
    """The Draw Perturbation types for a Differential Corrector profile."""
    # Segment Color - perturbations will be displayed in the trajectory color defined for the individual segments within the target sequence.
    eVADrawPerturbationSegmentColor = 0
    # Don't Draw - perturbations will not be drawn, which may decrease the run time of the target sequence.
    eVADrawPerturbationDontDraw = 1
    # Targeter Color - perturbations will be displayed in the trajectory color defined for the target sequence.
    eVADrawPerturbationTargeterColor = 2

AgEVADrawPerturbation.eVADrawPerturbationSegmentColor.__doc__ = "Segment Color - perturbations will be displayed in the trajectory color defined for the individual segments within the target sequence."
AgEVADrawPerturbation.eVADrawPerturbationDontDraw.__doc__ = "Don't Draw - perturbations will not be drawn, which may decrease the run time of the target sequence."
AgEVADrawPerturbation.eVADrawPerturbationTargeterColor.__doc__ = "Targeter Color - perturbations will be displayed in the trajectory color defined for the target sequence."

agcls.AgTypeNameMap["AgEVADrawPerturbation"] = AgEVADrawPerturbation

class AgEVADeriveCalcMethod(IntEnum):
    """The Derivative Calculation method types for a Differential Corrector profile."""
    # Forward Difference - (f(x + delta) - f(x))/ delta
    eVADeriveCalcMethodForward = 0
    # Central Difference - (f(x + delta) - f(x - delta)) / 2delta
    eVADeriveCalcMethodCentral = 1
    # Signed Difference - if x is positive, use the forward difference; if x is negative, use the backward difference.
    eVADeriveCalcMethodSigned = 2

AgEVADeriveCalcMethod.eVADeriveCalcMethodForward.__doc__ = "Forward Difference - (f(x + delta) - f(x))/ delta"
AgEVADeriveCalcMethod.eVADeriveCalcMethodCentral.__doc__ = "Central Difference - (f(x + delta) - f(x - delta)) / 2delta"
AgEVADeriveCalcMethod.eVADeriveCalcMethodSigned.__doc__ = "Signed Difference - if x is positive, use the forward difference; if x is negative, use the backward difference."

agcls.AgTypeNameMap["AgEVADeriveCalcMethod"] = AgEVADeriveCalcMethod

class AgEVAConvergenceCriteria(IntEnum):
    """The Convergence Criteria types for a Differential Corrector profile."""
    # Equality Constraints Satisfied - the differences between the achieved and desired equality constraint values must be within the specified tolerances for convergence.
    eVAConvergenceCriteriaEqualityConstraintWithinTolerance = 0
    # Equality Constraints Satisfied or Parameter Variations within Tolerance - the differences between the achieved and desired EC values must be within tolerances, or the last updates to the control parameters must be within tolerances for convergence.
    eVAConvervenceCriteriaEitherEqualityConstraintsOrControlParams = 1

AgEVAConvergenceCriteria.eVAConvergenceCriteriaEqualityConstraintWithinTolerance.__doc__ = "Equality Constraints Satisfied - the differences between the achieved and desired equality constraint values must be within the specified tolerances for convergence."
AgEVAConvergenceCriteria.eVAConvervenceCriteriaEitherEqualityConstraintsOrControlParams.__doc__ = "Equality Constraints Satisfied or Parameter Variations within Tolerance - the differences between the achieved and desired EC values must be within tolerances, or the last updates to the control parameters must be within tolerances for convergence."

agcls.AgTypeNameMap["AgEVAConvergenceCriteria"] = AgEVAConvergenceCriteria

class AgEVADCScalingMethod(IntEnum):
    """The Scaling Method types for a Differential Corrector profile."""
    # By initial value.
    eVADCScalingMethodInitialValue = 0
    # By one (no scaling).
    eVADCScalingMethodOneNoScaling = 1
    # By specified value.
    eVADCScalingMethodSpecifiedValue = 2
    # By tolerance.
    eVADCScalingMethodTolerance = 3

AgEVADCScalingMethod.eVADCScalingMethodInitialValue.__doc__ = "By initial value."
AgEVADCScalingMethod.eVADCScalingMethodOneNoScaling.__doc__ = "By one (no scaling)."
AgEVADCScalingMethod.eVADCScalingMethodSpecifiedValue.__doc__ = "By specified value."
AgEVADCScalingMethod.eVADCScalingMethodTolerance.__doc__ = "By tolerance."

agcls.AgTypeNameMap["AgEVADCScalingMethod"] = AgEVADCScalingMethod

class AgEVAControlUpdate(IntEnum):
    """Update segment properties that can be selected as control parameters for a Target Sequence."""
    # Drag Coefficient (Cd) - the dimensionless drag coefficient associated with the drag area.
    eVAControlUpdateCdVal = 100
    # Solar Radiation Pressure (Spherical) Coefficient (Cr) - the reflectivity of the spacecraft used for solar radiation pressure calculations, where 2.0 is fully reflective and 1.0 is not reflective at all.
    eVAControlUpdateCrVal = 101
    # Drag Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of motion, used for atmospheric drag calculations. Enter a value in the selected distance unit squared.
    eVAControlUpdateDragAreaVal = 102
    # Dry Mass - the mass of the spacecraft exclusive of propellant. Enter a value in the selected mass unit (e.g. kg).
    eVAControlUpdateDryMassVal = 103
    # Fuel Density - the density of the fuel tank. Enter a value in the selected mass unit per the selected distance unit cubed (e.g. kg/m^3).
    eVAControlUpdateFuelDensityVal = 104
    # Fuel Mass - the mass of the spacecraft propellant. Enter a value in the selected mass unit (e.g. kg).
    eVAControlUpdateFuelMassVal = 105
    # The cross-sectional area of the spacecraft assumed perpendicular to the direction of central body radiation, used for central body radiation (albedo / thermal pressure) calculations. Enter a value in the selected distance unit squared.
    eVAControlUpdateRadiationPressureAreaVal = 106
    # Radiation Pressure (Albedo/Thermal) Coefficient (Ck) - the reflectivity of the spacecraft used for central body radiation pressure (albedo / thermal pressure) calculations, where 2.0 is fully reflective and 1.0 is not reflective at all.
    eVAControlUpdateRadiationPressureCoefficientVal = 107
    # Solar Radiation Pressure (Spherical) Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of solar radiation, used for solar radiation calculations. Enter a value in the selected distance unit squared.
    eVAControlUpdateSRPAreaVal = 108
    # Tank Pressure - the fuel tank pressure. Enter a value in the selected pressure unit (e.g. Pa).
    eVAControlUpdateTankPressureVal = 109
    # Tank Temperature - the temperature of the fuel tank. Enter a value in the selected temperature unit.
    eVAControlUpdateTankTempVal = 110

AgEVAControlUpdate.eVAControlUpdateCdVal.__doc__ = "Drag Coefficient (Cd) - the dimensionless drag coefficient associated with the drag area."
AgEVAControlUpdate.eVAControlUpdateCrVal.__doc__ = "Solar Radiation Pressure (Spherical) Coefficient (Cr) - the reflectivity of the spacecraft used for solar radiation pressure calculations, where 2.0 is fully reflective and 1.0 is not reflective at all."
AgEVAControlUpdate.eVAControlUpdateDragAreaVal.__doc__ = "Drag Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of motion, used for atmospheric drag calculations. Enter a value in the selected distance unit squared."
AgEVAControlUpdate.eVAControlUpdateDryMassVal.__doc__ = "Dry Mass - the mass of the spacecraft exclusive of propellant. Enter a value in the selected mass unit (e.g. kg)."
AgEVAControlUpdate.eVAControlUpdateFuelDensityVal.__doc__ = "Fuel Density - the density of the fuel tank. Enter a value in the selected mass unit per the selected distance unit cubed (e.g. kg/m^3)."
AgEVAControlUpdate.eVAControlUpdateFuelMassVal.__doc__ = "Fuel Mass - the mass of the spacecraft propellant. Enter a value in the selected mass unit (e.g. kg)."
AgEVAControlUpdate.eVAControlUpdateRadiationPressureAreaVal.__doc__ = "The cross-sectional area of the spacecraft assumed perpendicular to the direction of central body radiation, used for central body radiation (albedo / thermal pressure) calculations. Enter a value in the selected distance unit squared."
AgEVAControlUpdate.eVAControlUpdateRadiationPressureCoefficientVal.__doc__ = "Radiation Pressure (Albedo/Thermal) Coefficient (Ck) - the reflectivity of the spacecraft used for central body radiation pressure (albedo / thermal pressure) calculations, where 2.0 is fully reflective and 1.0 is not reflective at all."
AgEVAControlUpdate.eVAControlUpdateSRPAreaVal.__doc__ = "Solar Radiation Pressure (Spherical) Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of solar radiation, used for solar radiation calculations. Enter a value in the selected distance unit squared."
AgEVAControlUpdate.eVAControlUpdateTankPressureVal.__doc__ = "Tank Pressure - the fuel tank pressure. Enter a value in the selected pressure unit (e.g. Pa)."
AgEVAControlUpdate.eVAControlUpdateTankTempVal.__doc__ = "Tank Temperature - the temperature of the fuel tank. Enter a value in the selected temperature unit."

agcls.AgTypeNameMap["AgEVAControlUpdate"] = AgEVAControlUpdate

class AgEVAControlFollow(IntEnum):
    """Follow segment properties that can be selected as control parameters for a Target Sequence."""
    # Fuel Mass - the mass of the spacecraft propellant. Enter a value in the selected mass unit (e.g. kg).
    eVAControlFollowFuelMass = 200
    # Drag Coefficient (Cd) - the dimensionless drag coefficient associated with the drag area.
    eVAControlFollowCd = 201
    # Solar Radiation Pressure (Spherical) Coefficient (Cr) - the reflectivity of the spacecraft used for solar radiation pressure calculations, where 2.0 is fully reflective and 1.0 is not reflective at all.
    eVAControlFollowCr = 202
    # Drag Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of motion, used for atmospheric drag calculations. Enter a value in the selected distance unit squared.
    eVAControlFollowDragArea = 203
    # Dry Mass - the mass of the spacecraft exclusive of propellant. Enter a value in the selected mass unit (e.g. kg).
    eVAControlFollowDryMass = 204
    # Fuel Density - the density of the fuel tank. Enter a value in the selected mass unit per the selected distance unit cubed (e.g. kg/m^3).
    eVAControlFollowFuelDensity = 205
    # GPS Solar Radiation Pressure K1 - if you are using a non-spherical SRP model, this field defines the model's K1 (scale) value.
    eVAControlFollowK1 = 206
    # GPS Solar Radiation Pressure K2 - if you are using a non-spherical SRP model, this field defines the model's K2 (Y bias) value.
    eVAControlFollowK2 = 207
    # The cross-sectional area of the spacecraft assumed perpendicular to the direction of central body radiation, used for central body radiation (albedo / thermal pressure) calculations. Enter a value in the selected distance unit squared.
    eVAControlFollowRadiationPressureArea = 208
    # Radiation Pressure (Albedo/Thermal) Coefficient (Ck) - the reflectivity of the spacecraft used for central body radiation pressure (albedo / thermal pressure) calculations, where 2.0 is fully reflective and 1.0 is not reflective at all.
    eVAControlFollowCk = 209
    # Solar Radiation Pressure (Spherical) Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of solar radiation, used for solar radiation calculations. Enter a value in the selected distance unit squared.
    eVAControlFollowSRPArea = 210
    # Tank Pressure - the fuel tank pressure. Enter a value in the selected pressure unit (e.g. Pa).
    eVAControlFollowTankPressure = 211
    # Tank Temperature - the temperature of the fuel tank. Enter a value in the selected temperature unit.
    eVAControlFollowTankTemp = 212
    # Maximum Fuel Mass - the maximum fuel mass of the spacecraft; this parameter specifically applies to Finite Maneuver segments that are being executed in Backward Sequences. Enter a value in the selected mass unit (e.g. kg).
    eVAControlFollowMaxFuelMass = 213
    # Tank Volume - the volume of the fuel tank. Enter a value in the selected distance unit cubed (e.g. m^3). The minimum value is 1e-019 m^3.
    eVAControlFollowTankVolume = 214
    # X Offset - the distance that the spacecraft will be offset from the leader's body frame along the X axis.
    eVAControlFollowXOffset = 215
    # Y Offset - the distance that the spacecraft will be offset from the leader's body frame along the Y axis.
    eVAControlFollowYOffset = 216
    # Z Offset - the distance that the spacecraft will be offset from the leader's body frame along the Z axis.
    eVAControlFollowZOffset = 217

AgEVAControlFollow.eVAControlFollowFuelMass.__doc__ = "Fuel Mass - the mass of the spacecraft propellant. Enter a value in the selected mass unit (e.g. kg)."
AgEVAControlFollow.eVAControlFollowCd.__doc__ = "Drag Coefficient (Cd) - the dimensionless drag coefficient associated with the drag area."
AgEVAControlFollow.eVAControlFollowCr.__doc__ = "Solar Radiation Pressure (Spherical) Coefficient (Cr) - the reflectivity of the spacecraft used for solar radiation pressure calculations, where 2.0 is fully reflective and 1.0 is not reflective at all."
AgEVAControlFollow.eVAControlFollowDragArea.__doc__ = "Drag Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of motion, used for atmospheric drag calculations. Enter a value in the selected distance unit squared."
AgEVAControlFollow.eVAControlFollowDryMass.__doc__ = "Dry Mass - the mass of the spacecraft exclusive of propellant. Enter a value in the selected mass unit (e.g. kg)."
AgEVAControlFollow.eVAControlFollowFuelDensity.__doc__ = "Fuel Density - the density of the fuel tank. Enter a value in the selected mass unit per the selected distance unit cubed (e.g. kg/m^3)."
AgEVAControlFollow.eVAControlFollowK1.__doc__ = "GPS Solar Radiation Pressure K1 - if you are using a non-spherical SRP model, this field defines the model's K1 (scale) value."
AgEVAControlFollow.eVAControlFollowK2.__doc__ = "GPS Solar Radiation Pressure K2 - if you are using a non-spherical SRP model, this field defines the model's K2 (Y bias) value."
AgEVAControlFollow.eVAControlFollowRadiationPressureArea.__doc__ = "The cross-sectional area of the spacecraft assumed perpendicular to the direction of central body radiation, used for central body radiation (albedo / thermal pressure) calculations. Enter a value in the selected distance unit squared."
AgEVAControlFollow.eVAControlFollowCk.__doc__ = "Radiation Pressure (Albedo/Thermal) Coefficient (Ck) - the reflectivity of the spacecraft used for central body radiation pressure (albedo / thermal pressure) calculations, where 2.0 is fully reflective and 1.0 is not reflective at all."
AgEVAControlFollow.eVAControlFollowSRPArea.__doc__ = "Solar Radiation Pressure (Spherical) Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of solar radiation, used for solar radiation calculations. Enter a value in the selected distance unit squared."
AgEVAControlFollow.eVAControlFollowTankPressure.__doc__ = "Tank Pressure - the fuel tank pressure. Enter a value in the selected pressure unit (e.g. Pa)."
AgEVAControlFollow.eVAControlFollowTankTemp.__doc__ = "Tank Temperature - the temperature of the fuel tank. Enter a value in the selected temperature unit."
AgEVAControlFollow.eVAControlFollowMaxFuelMass.__doc__ = "Maximum Fuel Mass - the maximum fuel mass of the spacecraft; this parameter specifically applies to Finite Maneuver segments that are being executed in Backward Sequences. Enter a value in the selected mass unit (e.g. kg)."
AgEVAControlFollow.eVAControlFollowTankVolume.__doc__ = "Tank Volume - the volume of the fuel tank. Enter a value in the selected distance unit cubed (e.g. m^3). The minimum value is 1e-019 m^3."
AgEVAControlFollow.eVAControlFollowXOffset.__doc__ = "X Offset - the distance that the spacecraft will be offset from the leader's body frame along the X axis."
AgEVAControlFollow.eVAControlFollowYOffset.__doc__ = "Y Offset - the distance that the spacecraft will be offset from the leader's body frame along the Y axis."
AgEVAControlFollow.eVAControlFollowZOffset.__doc__ = "Z Offset - the distance that the spacecraft will be offset from the leader's body frame along the Z axis."

agcls.AgTypeNameMap["AgEVAControlFollow"] = AgEVAControlFollow

class AgEVAControlInitState(IntEnum):
    """Initial State segment properties that can be selected as control parameters for a Target Sequence."""
    # Fuel Mass - the mass of the spacecraft propellant. Enter a value in the selected mass unit (e.g. kg).
    eVAControlInitStateFuelMass = 300
    # Vx Component - the X component of the spacecraft velocity vector.
    eVAControlInitStateCartesianVx = 301
    # Vy Component - the Y component of the spacecraft velocity vector.
    eVAControlInitStateCartesianVy = 302
    # Vz Component - the Z component of the spacecraft velocity vector.
    eVAControlInitStateCartesianVz = 303
    # X Component - the X component of the spacecraft position vector.
    eVAControlInitStateCartesianX = 304
    # Y Component - the Y component of the spacecraft position vector.
    eVAControlInitStateCartesianY = 305
    # Z Component - the Z component of the spacecraft position vector.
    eVAControlInitStateCartesianZ = 306
    # Drag Coefficient (Cd) - the dimensionless drag coefficient associated with the drag area.
    eVAControlInitStateCd = 307
    # Solar Radiation Pressure (Spherical) Coefficient (Cr) - the reflectivity of the spacecraft used for solar radiation pressure calculations, where 2.0 is fully reflective and 1.0 is not reflective at all.
    eVAControlInitStateCr = 308
    # Drag Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of motion, used for atmospheric drag calculations. Enter a value in the selected distance unit squared.
    eVAControlInitStateDragArea = 309
    # Dry Mass - the mass of the spacecraft exclusive of propellant. Enter a value in the selected mass unit (e.g. kg).
    eVAControlInitStateDryMass = 310
    # Epoch - the orbit epoch.
    eVAControlInitStateEpoch = 311
    # Fuel Density - the density of the fuel tank.
    eVAControlInitStateFuelDensity = 312
    # GPS Solar Radiation Pressure K1 - if you are using a non-spherical SRP model, this field defines the model's K1 (scale) value.
    eVAControlInitStateK1 = 313
    # GPS Solar Radiation Pressure K2 - if you are using a non-spherical SRP model, this field defines the model's K2 (Y bias) value.
    eVAControlInitStateK2 = 314
    # Eccentricity - the ratio of the distance between the foci to the major axis of the orbital ellipse. Dimensionless.
    eVAControlInitStateKeplerianEcc = 315
    # Inclination - the angle from the +Z axis of the coordinate system to the angular momentum vector of the spacecraft's orbit.
    eVAControlInitStateKeplerianInc = 316
    # Right Ascension of Ascending Node - the angle between the X direction of the coordinate system and the point where the orbit crosses the X-Y plane in the +Z direction.
    eVAControlInitStateKeplerianRAAN = 317
    # Semimajor Axis - half the length of the major (longest) axis of the orbital ellipse.
    eVAControlInitStateKeplerianSMA = 318
    # True Anomaly - the angle from the periapsis of the orbit to the spacecraft's position vector, measured in the direction of spacecraft motion.
    eVAControlInitStateKeplerianTA = 319
    # Argument of Periapsis - the angle measured in the direction of spacecraft motion, in the orbit plane, from the ascending node to the periapsis of the orbit.
    eVAControlInitStateKeplerianW = 320
    # Radiation Pressure (Albedo/Thermal) Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of central body radiation, used for central body radiation (albedo / thermal pressure) calculations.
    eVAControlInitStateRadiationPressureArea = 327
    # Radiation Pressure (Albedo/Thermal) Coefficient (Ck) - the reflectivity of the spacecraft used for central body radiation pressure (albedo / thermal pressure) calculations, where 2.0 is fully reflective and 1.0 is not reflective at all.
    eVAControlInitStateCk = 328
    # Velocity Azimuth - the angle in the spacecraft local horizontal plane between the projection of the velocity vector onto that plane and the local +Z direction measured as positive in the clockwise direction from north.
    eVAControlInitStateSphericalAz = 329
    # Declination - the angle from the X-Y plane of the coordinate system to the spacecraft position vector.
    eVAControlInitStateSphericalDec = 330
    # Horizontal Flight Path Angle - the complement of the angle between the spacecraft velocity vector and the radius vector (90 deg minus the vertical flight path angle).
    eVAControlInitStateSphericalHorizFPA = 331
    # Right Ascension - angle measured in the inertial equatorial plane from the inertial X axis in a right-handed sense about the inertial Z axis to the spacecraft position vector.
    eVAControlInitStateSphericalRA = 332
    # Radius Magnitude - the magnitude of the spacecraft position vector.
    eVAControlInitStateSphericalRMag = 333
    # Velocity Magnitude - the magnitude of the spacecraft velocity vector.
    eVAControlInitStateSphericalVMag = 334
    # Solar Radiation Pressure (Spherical) Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of solar radiation, used for solar radiation calculations.
    eVAControlInitStateSRPArea = 335
    # Tank Pressure - the fuel tank pressure.
    eVAControlInitStateTankPressure = 336
    # Tank Temperature - the temperature of the fuel tank.
    eVAControlInitStateTankTemp = 337
    # Declination of Incoming Asymptote - the declination of the incoming asymptote in the selected coordinate system.
    eVAControlInitStateTargetVecInAsympDec = 338
    # Right Ascension of Incoming Asymptote - the right ascension of the hyperbolic incoming asymptote in the selected coordinate system.
    eVAControlInitStateTargetVecInAsympRA = 339
    # Velocity Azimuth at Periapsis - the inertial flight path azimuth of the trajectory measured at periapsis.
    eVAControlInitStateTargetVecInVelAzAtPeriapsis = 340
    # C3 Energy - the energy of the orbit, computed as - mu / a, where mu is the gravity constant of the central body and a is the semimajor axis.
    eVAControlInitStateTargetVecInC3 = 341
    # Radius of Periapsis - distance from the center of mass of the central body to the periapsis of the hyperbolic orbit.
    eVAControlInitStateTargetVecInRadOfPeriapsis = 342
    # True Anomaly - the angle from the periapsis of the orbit to the spacecraft's position vector, measured in the direction of spacecraft motion.
    eVAControlInitStateTargetVecInTrueAnomaly = 343
    # Declination of Outgoing Asymptote - the declination of the outgoing asymptote in the selected coordinate system.
    eVAControlInitStateTargetVecOutAsympDec = 344
    # Right Ascension of Outgoing Asymptote - the right ascension of the hyperbolic outgoing asymptote in the selected coordinate system.
    eVAControlInitStateTargetVecOutAsympRA = 345
    # Velocity Azimuth at Periapsis - the inertial flight path azimuth of the trajectory measured at periapsis.
    eVAControlInitStateTargetVecOutVelAzAtPeriapsis = 346
    # C3 Energy - the energy of the orbit, computed as - mu / a, where mu is the gravity constant of the central body and a is the semimajor axis.
    eVAControlInitStateTargetVecOutC3 = 347
    # Radius of Periapsis - distance from the center of mass of the central body to the periapsis of the hyperbolic orbit.
    eVAControlInitStateTargetVecOutRadOfPeriapsis = 348
    # True Anomaly - the angle from the periapsis of the orbit to the spacecraft's position vector, measured in the direction of spacecraft motion.
    eVAControlInitStateTargetVecOutTrueAnomaly = 349
    # Maximum Fuel Mass - the maximum fuel mass of the spacecraft; this parameter specifically applies to Finite Maneuver segments that are being executed in Backward Sequences.
    eVAControlInitStateMaxFuelMass = 350
    # Tank Volume - the volume of the fuel tank.
    eVAControlInitStateTankVolume = 351
    # G - Magnitude of orbital angular momentum, sqrt(GM * p).
    eVAControlInitStateDelaunayG = 352
    # H - Z component of orbital angular momentum, G cos(inc).
    eVAControlInitStateDelaunayH = 353
    # Inclination - The angle between the angular momentum vector (perpendicular to the plane of the orbit) and the inertial Z axis.
    eVAControlInitStateDelaunayInc = 354
    # L - Related to two-body orbital energy, sqrt(GM * a)
    eVAControlInitStateDelaunayL = 355
    # Mean Anomaly - The angle from the eccentricity vector to a position vector where the satellite would be if it were always moving at its average angular rate.
    eVAControlInitStateDelaunayMeanAnomaly = 356
    # Right Ascension of Ascending Node - The angle from the inertial X axis to the ascending node measured in a right-handed sense about the inertial Z axis in the equatorial plane.
    eVAControlInitStateDelaunayRAAN = 357
    # Semi-latus Rectum - Distance from focus to orbit at true anomaly of 90 degrees
    eVAControlInitStateDelaunaySemiLatusRectum = 358
    # Semimajor Axis - Half the length of the major (longest) axis of the orbital ellipse.
    eVAControlInitStateDelaunaySMA = 359
    # Argument of Periapsis - The angle from the ascending node to the eccentricity vector measured in the direction of the satellite's motion and in the orbit plane.
    eVAControlInitStateDelaunayW = 360
    # H - With K, describe the shape and position of periapsis of the orbit, ecc * sin(RAAN + w)
    eVAControlInitStateEquinoctialH = 361
    # K - With H, describe the shape and position of periapsis of the orbit, ecc * cos(RAAN + w)
    eVAControlInitStateEquinoctialK = 362
    # Mean Longitude - RAAN + w + M
    eVAControlInitStateEquinoctialMeanLongitude = 363
    # Mean Motion - The number of orbits per day (86400 sec/period), based on assumed two-body motion.
    eVAControlInitStateEquinoctialMeanMotion = 364
    # P - With Q, describes the orientation of the orbit plane, tan(inc/2) * sin(RAAN)
    eVAControlInitStateEquinoctialP = 365
    # Q - With P, describes the orientation of the orbit plane, tan(inc/2) * cos(RAAN)
    eVAControlInitStateEquinoctialQ = 366
    # Semimajor Axis - Half the length of the major (longest) axis of the orbital ellipse.
    eVAControlInitStateEquinoctialSMA = 367
    # Altitude - The object's position above or below the reference ellipsoid. Altitude is measured along a normal to the surface of the reference ellipsoid.
    eVAControlInitStateMixedSphericalAltitude = 368
    # Azimuth - The angle in the satellite local horizontal plane between the projection of the inertial velocity vector onto this plane and the local north direction measured as positive in the clockwise direction.
    eVAControlInitStateMixedSphericalAzimuth = 369
    # Horizontal Flight Path Angle - The complement of the angle between the inertial velocity vector and the radius vector.
    eVAControlInitStateMixedSphericalHorizFPA = 370
    # Latitude - The geodetic latitude of a point is the angle between the normal to the reference ellipsoid that passes through the satellite position and the equatorial plane.
    eVAControlInitStateMixedSphericalLatitude = 371
    # Longitude
    eVAControlInitStateMixedSphericalLongitude = 372
    # Vertical Flight Path Angle -  The angle between the inertial velocity vector and the radius vector.
    eVAControlInitStateMixedSphericalVerticalFPA = 373
    # Velocity Magnitude - The magnitude of the inertial velocity vector.
    eVAControlInitStateMixedSphericalVMag = 374
    # Vertical Flight Path Angle -  The angle between the inertial velocity vector and the radius vector.
    eVAControlInitStateSphericalVerticalFPA = 375
    # Apoapsis Altitude - Shape Parameter - Distance from the surface of the central body to the point of maximum radius in the orbit.
    eVAControlInitStateKeplerianApoapsisAltShape = 376
    # Apoapsis Altitude - Size Parameter - Distance from the surface of the central body to the point of maximum radius in the orbit.
    eVAControlInitStateKeplerianApoapsisAltSize = 377
    # Apoapsis Radius - Shape Parameter - Distance from the center of the central body to the point of maximum radius in the orbit.
    eVAControlInitStateKeplerianApoapsisRadShape = 378
    # Apoapsis Radius - Size Parameter - Distance from the center of the central body to the point of maximum radius in the orbit.
    eVAControlInitStateKeplerianApoapsisRadSize = 379
    # Argument of Latitude - The sum of the True Anomaly and the Argument of Perigee.
    eVAControlInitStateKeplerianArgLat = 380
    # Eccentric Anomaly - Angle measured with an origin at the center of the ellipse from the direction of perigee to a point on a circumscribing circle from which a line perpendicular to the SMA intersects the position of the satellite on the ellipse.
    eVAControlInitStateKeplerianEccAnomaly = 381
    # Longitude of Ascending Node - Longitude of the Ascending Node is the Earth-fixed longitude where the satellite has crossed the inertial equator from south to north based on an assumption of two-body motion.
    eVAControlInitStateKeplerianLAN = 382
    # Mean Anomaly - The angle from the eccentricity vector to a position vector where the satellite would be if it were always moving at its average angular rate.
    eVAControlInitStateKeplerianMeanAnomaly = 383
    # Mean Motion - The number of orbits per day (86400 sec/period), based on assumed two-body motion.
    eVAControlInitStateKeplerianMeanMotion = 384
    # Periapsis Altitude - Shape Parameter - Distance from the surface of the central body to the point of minimum radius in the orbit.
    eVAControlInitStateKeplerianPeriapsisAltShape = 385
    # Periapsis Altitude - Size Parameter - Distance from the surface of the central body to the point of minimum radius in the orbit.
    eVAControlInitStateKeplerianPeriapsisAltSize = 386
    # Periapsis Radius - Shape Parameter - Distance from the center of the central body to the point of minimum radius in the orbit.
    eVAControlInitStateKeplerianPeriapsisRadShape = 387
    # Periapsis Radius - Size Parameter - Distance from the surface of the central body to the point of minimum radius in the orbit.
    eVAControlInitStateKeplerianPeriapsisRadSize = 388
    # Period - The duration of one orbit, based on assumed two-body motion.
    eVAControlInitStateKeplerianPeriod = 389
    # Time Past Ascending Node - The elapsed time since the last ascending node crossing based on assumed two-body motion.
    eVAControlInitStateKeplerianTimePastAN = 390
    # Time Past Periapsis - The elapsed time since the last perigee passage based on assumed two-body motion.
    eVAControlInitStateKeplerianTimePastPeriapsis = 391

AgEVAControlInitState.eVAControlInitStateFuelMass.__doc__ = "Fuel Mass - the mass of the spacecraft propellant. Enter a value in the selected mass unit (e.g. kg)."
AgEVAControlInitState.eVAControlInitStateCartesianVx.__doc__ = "Vx Component - the X component of the spacecraft velocity vector."
AgEVAControlInitState.eVAControlInitStateCartesianVy.__doc__ = "Vy Component - the Y component of the spacecraft velocity vector."
AgEVAControlInitState.eVAControlInitStateCartesianVz.__doc__ = "Vz Component - the Z component of the spacecraft velocity vector."
AgEVAControlInitState.eVAControlInitStateCartesianX.__doc__ = "X Component - the X component of the spacecraft position vector."
AgEVAControlInitState.eVAControlInitStateCartesianY.__doc__ = "Y Component - the Y component of the spacecraft position vector."
AgEVAControlInitState.eVAControlInitStateCartesianZ.__doc__ = "Z Component - the Z component of the spacecraft position vector."
AgEVAControlInitState.eVAControlInitStateCd.__doc__ = "Drag Coefficient (Cd) - the dimensionless drag coefficient associated with the drag area."
AgEVAControlInitState.eVAControlInitStateCr.__doc__ = "Solar Radiation Pressure (Spherical) Coefficient (Cr) - the reflectivity of the spacecraft used for solar radiation pressure calculations, where 2.0 is fully reflective and 1.0 is not reflective at all."
AgEVAControlInitState.eVAControlInitStateDragArea.__doc__ = "Drag Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of motion, used for atmospheric drag calculations. Enter a value in the selected distance unit squared."
AgEVAControlInitState.eVAControlInitStateDryMass.__doc__ = "Dry Mass - the mass of the spacecraft exclusive of propellant. Enter a value in the selected mass unit (e.g. kg)."
AgEVAControlInitState.eVAControlInitStateEpoch.__doc__ = "Epoch - the orbit epoch."
AgEVAControlInitState.eVAControlInitStateFuelDensity.__doc__ = "Fuel Density - the density of the fuel tank."
AgEVAControlInitState.eVAControlInitStateK1.__doc__ = "GPS Solar Radiation Pressure K1 - if you are using a non-spherical SRP model, this field defines the model's K1 (scale) value."
AgEVAControlInitState.eVAControlInitStateK2.__doc__ = "GPS Solar Radiation Pressure K2 - if you are using a non-spherical SRP model, this field defines the model's K2 (Y bias) value."
AgEVAControlInitState.eVAControlInitStateKeplerianEcc.__doc__ = "Eccentricity - the ratio of the distance between the foci to the major axis of the orbital ellipse. Dimensionless."
AgEVAControlInitState.eVAControlInitStateKeplerianInc.__doc__ = "Inclination - the angle from the +Z axis of the coordinate system to the angular momentum vector of the spacecraft's orbit."
AgEVAControlInitState.eVAControlInitStateKeplerianRAAN.__doc__ = "Right Ascension of Ascending Node - the angle between the X direction of the coordinate system and the point where the orbit crosses the X-Y plane in the +Z direction."
AgEVAControlInitState.eVAControlInitStateKeplerianSMA.__doc__ = "Semimajor Axis - half the length of the major (longest) axis of the orbital ellipse."
AgEVAControlInitState.eVAControlInitStateKeplerianTA.__doc__ = "True Anomaly - the angle from the periapsis of the orbit to the spacecraft's position vector, measured in the direction of spacecraft motion."
AgEVAControlInitState.eVAControlInitStateKeplerianW.__doc__ = "Argument of Periapsis - the angle measured in the direction of spacecraft motion, in the orbit plane, from the ascending node to the periapsis of the orbit."
AgEVAControlInitState.eVAControlInitStateRadiationPressureArea.__doc__ = "Radiation Pressure (Albedo/Thermal) Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of central body radiation, used for central body radiation (albedo / thermal pressure) calculations."
AgEVAControlInitState.eVAControlInitStateCk.__doc__ = "Radiation Pressure (Albedo/Thermal) Coefficient (Ck) - the reflectivity of the spacecraft used for central body radiation pressure (albedo / thermal pressure) calculations, where 2.0 is fully reflective and 1.0 is not reflective at all."
AgEVAControlInitState.eVAControlInitStateSphericalAz.__doc__ = "Velocity Azimuth - the angle in the spacecraft local horizontal plane between the projection of the velocity vector onto that plane and the local +Z direction measured as positive in the clockwise direction from north."
AgEVAControlInitState.eVAControlInitStateSphericalDec.__doc__ = "Declination - the angle from the X-Y plane of the coordinate system to the spacecraft position vector."
AgEVAControlInitState.eVAControlInitStateSphericalHorizFPA.__doc__ = "Horizontal Flight Path Angle - the complement of the angle between the spacecraft velocity vector and the radius vector (90 deg minus the vertical flight path angle)."
AgEVAControlInitState.eVAControlInitStateSphericalRA.__doc__ = "Right Ascension - angle measured in the inertial equatorial plane from the inertial X axis in a right-handed sense about the inertial Z axis to the spacecraft position vector."
AgEVAControlInitState.eVAControlInitStateSphericalRMag.__doc__ = "Radius Magnitude - the magnitude of the spacecraft position vector."
AgEVAControlInitState.eVAControlInitStateSphericalVMag.__doc__ = "Velocity Magnitude - the magnitude of the spacecraft velocity vector."
AgEVAControlInitState.eVAControlInitStateSRPArea.__doc__ = "Solar Radiation Pressure (Spherical) Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of solar radiation, used for solar radiation calculations."
AgEVAControlInitState.eVAControlInitStateTankPressure.__doc__ = "Tank Pressure - the fuel tank pressure."
AgEVAControlInitState.eVAControlInitStateTankTemp.__doc__ = "Tank Temperature - the temperature of the fuel tank."
AgEVAControlInitState.eVAControlInitStateTargetVecInAsympDec.__doc__ = "Declination of Incoming Asymptote - the declination of the incoming asymptote in the selected coordinate system."
AgEVAControlInitState.eVAControlInitStateTargetVecInAsympRA.__doc__ = "Right Ascension of Incoming Asymptote - the right ascension of the hyperbolic incoming asymptote in the selected coordinate system."
AgEVAControlInitState.eVAControlInitStateTargetVecInVelAzAtPeriapsis.__doc__ = "Velocity Azimuth at Periapsis - the inertial flight path azimuth of the trajectory measured at periapsis."
AgEVAControlInitState.eVAControlInitStateTargetVecInC3.__doc__ = "C3 Energy - the energy of the orbit, computed as - mu / a, where mu is the gravity constant of the central body and a is the semimajor axis."
AgEVAControlInitState.eVAControlInitStateTargetVecInRadOfPeriapsis.__doc__ = "Radius of Periapsis - distance from the center of mass of the central body to the periapsis of the hyperbolic orbit."
AgEVAControlInitState.eVAControlInitStateTargetVecInTrueAnomaly.__doc__ = "True Anomaly - the angle from the periapsis of the orbit to the spacecraft's position vector, measured in the direction of spacecraft motion."
AgEVAControlInitState.eVAControlInitStateTargetVecOutAsympDec.__doc__ = "Declination of Outgoing Asymptote - the declination of the outgoing asymptote in the selected coordinate system."
AgEVAControlInitState.eVAControlInitStateTargetVecOutAsympRA.__doc__ = "Right Ascension of Outgoing Asymptote - the right ascension of the hyperbolic outgoing asymptote in the selected coordinate system."
AgEVAControlInitState.eVAControlInitStateTargetVecOutVelAzAtPeriapsis.__doc__ = "Velocity Azimuth at Periapsis - the inertial flight path azimuth of the trajectory measured at periapsis."
AgEVAControlInitState.eVAControlInitStateTargetVecOutC3.__doc__ = "C3 Energy - the energy of the orbit, computed as - mu / a, where mu is the gravity constant of the central body and a is the semimajor axis."
AgEVAControlInitState.eVAControlInitStateTargetVecOutRadOfPeriapsis.__doc__ = "Radius of Periapsis - distance from the center of mass of the central body to the periapsis of the hyperbolic orbit."
AgEVAControlInitState.eVAControlInitStateTargetVecOutTrueAnomaly.__doc__ = "True Anomaly - the angle from the periapsis of the orbit to the spacecraft's position vector, measured in the direction of spacecraft motion."
AgEVAControlInitState.eVAControlInitStateMaxFuelMass.__doc__ = "Maximum Fuel Mass - the maximum fuel mass of the spacecraft; this parameter specifically applies to Finite Maneuver segments that are being executed in Backward Sequences."
AgEVAControlInitState.eVAControlInitStateTankVolume.__doc__ = "Tank Volume - the volume of the fuel tank."
AgEVAControlInitState.eVAControlInitStateDelaunayG.__doc__ = "G - Magnitude of orbital angular momentum, sqrt(GM * p)."
AgEVAControlInitState.eVAControlInitStateDelaunayH.__doc__ = "H - Z component of orbital angular momentum, G cos(inc)."
AgEVAControlInitState.eVAControlInitStateDelaunayInc.__doc__ = "Inclination - The angle between the angular momentum vector (perpendicular to the plane of the orbit) and the inertial Z axis."
AgEVAControlInitState.eVAControlInitStateDelaunayL.__doc__ = "L - Related to two-body orbital energy, sqrt(GM * a)"
AgEVAControlInitState.eVAControlInitStateDelaunayMeanAnomaly.__doc__ = "Mean Anomaly - The angle from the eccentricity vector to a position vector where the satellite would be if it were always moving at its average angular rate."
AgEVAControlInitState.eVAControlInitStateDelaunayRAAN.__doc__ = "Right Ascension of Ascending Node - The angle from the inertial X axis to the ascending node measured in a right-handed sense about the inertial Z axis in the equatorial plane."
AgEVAControlInitState.eVAControlInitStateDelaunaySemiLatusRectum.__doc__ = "Semi-latus Rectum - Distance from focus to orbit at true anomaly of 90 degrees"
AgEVAControlInitState.eVAControlInitStateDelaunaySMA.__doc__ = "Semimajor Axis - Half the length of the major (longest) axis of the orbital ellipse."
AgEVAControlInitState.eVAControlInitStateDelaunayW.__doc__ = "Argument of Periapsis - The angle from the ascending node to the eccentricity vector measured in the direction of the satellite's motion and in the orbit plane."
AgEVAControlInitState.eVAControlInitStateEquinoctialH.__doc__ = "H - With K, describe the shape and position of periapsis of the orbit, ecc * sin(RAAN + w)"
AgEVAControlInitState.eVAControlInitStateEquinoctialK.__doc__ = "K - With H, describe the shape and position of periapsis of the orbit, ecc * cos(RAAN + w)"
AgEVAControlInitState.eVAControlInitStateEquinoctialMeanLongitude.__doc__ = "Mean Longitude - RAAN + w + M"
AgEVAControlInitState.eVAControlInitStateEquinoctialMeanMotion.__doc__ = "Mean Motion - The number of orbits per day (86400 sec/period), based on assumed two-body motion."
AgEVAControlInitState.eVAControlInitStateEquinoctialP.__doc__ = "P - With Q, describes the orientation of the orbit plane, tan(inc/2) * sin(RAAN)"
AgEVAControlInitState.eVAControlInitStateEquinoctialQ.__doc__ = "Q - With P, describes the orientation of the orbit plane, tan(inc/2) * cos(RAAN)"
AgEVAControlInitState.eVAControlInitStateEquinoctialSMA.__doc__ = "Semimajor Axis - Half the length of the major (longest) axis of the orbital ellipse."
AgEVAControlInitState.eVAControlInitStateMixedSphericalAltitude.__doc__ = "Altitude - The object's position above or below the reference ellipsoid. Altitude is measured along a normal to the surface of the reference ellipsoid."
AgEVAControlInitState.eVAControlInitStateMixedSphericalAzimuth.__doc__ = "Azimuth - The angle in the satellite local horizontal plane between the projection of the inertial velocity vector onto this plane and the local north direction measured as positive in the clockwise direction."
AgEVAControlInitState.eVAControlInitStateMixedSphericalHorizFPA.__doc__ = "Horizontal Flight Path Angle - The complement of the angle between the inertial velocity vector and the radius vector."
AgEVAControlInitState.eVAControlInitStateMixedSphericalLatitude.__doc__ = "Latitude - The geodetic latitude of a point is the angle between the normal to the reference ellipsoid that passes through the satellite position and the equatorial plane."
AgEVAControlInitState.eVAControlInitStateMixedSphericalLongitude.__doc__ = "Longitude"
AgEVAControlInitState.eVAControlInitStateMixedSphericalVerticalFPA.__doc__ = "Vertical Flight Path Angle -  The angle between the inertial velocity vector and the radius vector."
AgEVAControlInitState.eVAControlInitStateMixedSphericalVMag.__doc__ = "Velocity Magnitude - The magnitude of the inertial velocity vector."
AgEVAControlInitState.eVAControlInitStateSphericalVerticalFPA.__doc__ = "Vertical Flight Path Angle -  The angle between the inertial velocity vector and the radius vector."
AgEVAControlInitState.eVAControlInitStateKeplerianApoapsisAltShape.__doc__ = "Apoapsis Altitude - Shape Parameter - Distance from the surface of the central body to the point of maximum radius in the orbit."
AgEVAControlInitState.eVAControlInitStateKeplerianApoapsisAltSize.__doc__ = "Apoapsis Altitude - Size Parameter - Distance from the surface of the central body to the point of maximum radius in the orbit."
AgEVAControlInitState.eVAControlInitStateKeplerianApoapsisRadShape.__doc__ = "Apoapsis Radius - Shape Parameter - Distance from the center of the central body to the point of maximum radius in the orbit."
AgEVAControlInitState.eVAControlInitStateKeplerianApoapsisRadSize.__doc__ = "Apoapsis Radius - Size Parameter - Distance from the center of the central body to the point of maximum radius in the orbit."
AgEVAControlInitState.eVAControlInitStateKeplerianArgLat.__doc__ = "Argument of Latitude - The sum of the True Anomaly and the Argument of Perigee."
AgEVAControlInitState.eVAControlInitStateKeplerianEccAnomaly.__doc__ = "Eccentric Anomaly - Angle measured with an origin at the center of the ellipse from the direction of perigee to a point on a circumscribing circle from which a line perpendicular to the SMA intersects the position of the satellite on the ellipse."
AgEVAControlInitState.eVAControlInitStateKeplerianLAN.__doc__ = "Longitude of Ascending Node - Longitude of the Ascending Node is the Earth-fixed longitude where the satellite has crossed the inertial equator from south to north based on an assumption of two-body motion."
AgEVAControlInitState.eVAControlInitStateKeplerianMeanAnomaly.__doc__ = "Mean Anomaly - The angle from the eccentricity vector to a position vector where the satellite would be if it were always moving at its average angular rate."
AgEVAControlInitState.eVAControlInitStateKeplerianMeanMotion.__doc__ = "Mean Motion - The number of orbits per day (86400 sec/period), based on assumed two-body motion."
AgEVAControlInitState.eVAControlInitStateKeplerianPeriapsisAltShape.__doc__ = "Periapsis Altitude - Shape Parameter - Distance from the surface of the central body to the point of minimum radius in the orbit."
AgEVAControlInitState.eVAControlInitStateKeplerianPeriapsisAltSize.__doc__ = "Periapsis Altitude - Size Parameter - Distance from the surface of the central body to the point of minimum radius in the orbit."
AgEVAControlInitState.eVAControlInitStateKeplerianPeriapsisRadShape.__doc__ = "Periapsis Radius - Shape Parameter - Distance from the center of the central body to the point of minimum radius in the orbit."
AgEVAControlInitState.eVAControlInitStateKeplerianPeriapsisRadSize.__doc__ = "Periapsis Radius - Size Parameter - Distance from the surface of the central body to the point of minimum radius in the orbit."
AgEVAControlInitState.eVAControlInitStateKeplerianPeriod.__doc__ = "Period - The duration of one orbit, based on assumed two-body motion."
AgEVAControlInitState.eVAControlInitStateKeplerianTimePastAN.__doc__ = "Time Past Ascending Node - The elapsed time since the last ascending node crossing based on assumed two-body motion."
AgEVAControlInitState.eVAControlInitStateKeplerianTimePastPeriapsis.__doc__ = "Time Past Periapsis - The elapsed time since the last perigee passage based on assumed two-body motion."

agcls.AgTypeNameMap["AgEVAControlInitState"] = AgEVAControlInitState

class AgEVAControlManeuver(IntEnum):
    """Maneuver segment properties that can be selected as control parameters for a Target Sequence."""
    # The Cartesian X component of the thrust vector.
    eVAControlManeuverFiniteCartesianX = 400
    # The Cartesian Y component of the thrust vector.
    eVAControlManeuverFiniteCartesianY = 401
    # The Cartesian Z component of the thrust vector.
    eVAControlManeuverFiniteCartesianZ = 402
    # The Euler A (Phi) component of the rotation from the reference axes to the body frame.
    eVAControlManeuverFiniteEulerAngles1 = 403
    # The Euler B (Theta) component of the rotation from the reference axes to the body frame.
    eVAControlManeuverFiniteEulerAngles2 = 404
    # The Euler C (Psi) component of the rotation from the reference axes to the body frame.
    eVAControlManeuverFiniteEulerAngles3 = 405
    # The spherical azimuth component of the thrust vector.
    eVAControlManeuverFiniteSphericalAz = 406
    # The spherical elevation component of the thrust vector.
    eVAControlManeuverFiniteSphericalElev = 407
    # The Cartesian X component of the thrust vector.
    eVAControlManeuverImpulsiveCartesianX = 408
    # The Cartesian Y component of the thrust vector.
    eVAControlManeuverImpulsiveCartesianY = 409
    # The Cartesian Z component of the thrust vector.
    eVAControlManeuverImpulsiveCartesianZ = 410
    # The Euler A (Phi) component of the rotation from the reference axes to the body frame.
    eVAControlManeuverImpulsiveEulerAngles1 = 411
    # The Euler B (Theta) component of the rotation from the reference axes to the body frame.
    eVAControlManeuverImpulsiveEulerAngles2 = 412
    # The Euler C (Psi) component of the rotation from the reference axes to the body frame.
    eVAControlManeuverImpulsiveEulerAngles3 = 413
    # The spherical azimuth component of the thrust vector.
    eVAControlManeuverImpulsiveSphericalAz = 414
    # The spherical elevation component of the thrust vector.
    eVAControlManeuverImpulsiveSphericalElev = 415
    # The spherical magnitude component of the thrust vector.
    eVAControlManeuverImpulsiveSphericalMag = 416
    # The burn center bias of the thrust.
    eVAControlManeuverFiniteBurnCenterBias = 417
    # The thrust efficiency value.
    eVAControlManeuverFiniteThrustEfficiency = 418
    # The time varying azimuth polynomial constant term.
    eVAControlManeuverFiniteAz0 = 419
    # The time varying azimuth polynomial linear term.
    eVAControlManeuverFiniteAz1 = 420
    # The time varying azimuth polynomial quadratic term.
    eVAControlManeuverFiniteAz2 = 421
    # The time varying azimuth polynomial cubic term.
    eVAControlManeuverFiniteAz3 = 422
    # The time varying azimuth polynomial quartic term.
    eVAControlManeuverFiniteAz4 = 423
    # The time varying azimuth sine amplitude term.
    eVAControlManeuverFiniteAzA = 424
    # The time varying azimuth sine frequency term.
    eVAControlManeuverFiniteAzF = 425
    # The time varying azimuth sine phase term.
    eVAControlManeuverFiniteAzP = 426
    # The time varying elevation polynomial constant term.
    eVAControlManeuverFiniteEl0 = 427
    # The time varying elevation polynomial linear term.
    eVAControlManeuverFiniteEl1 = 428
    # The time varying elevation polynomial quadratic term.
    eVAControlManeuverFiniteEl2 = 429
    # The time varying elevation polynomial cubic term.
    eVAControlManeuverFiniteEl3 = 430
    # The time varying elevation polynomial quartic term.
    eVAControlManeuverFiniteEl4 = 431
    # The time varying elevation sine amplitude term.
    eVAControlManeuverFiniteElA = 432
    # The time varying elevation sine frequency term.
    eVAControlManeuverFiniteElF = 433
    # The time varying elevation sine phase term.
    eVAControlManeuverFiniteElP = 434

AgEVAControlManeuver.eVAControlManeuverFiniteCartesianX.__doc__ = "The Cartesian X component of the thrust vector."
AgEVAControlManeuver.eVAControlManeuverFiniteCartesianY.__doc__ = "The Cartesian Y component of the thrust vector."
AgEVAControlManeuver.eVAControlManeuverFiniteCartesianZ.__doc__ = "The Cartesian Z component of the thrust vector."
AgEVAControlManeuver.eVAControlManeuverFiniteEulerAngles1.__doc__ = "The Euler A (Phi) component of the rotation from the reference axes to the body frame."
AgEVAControlManeuver.eVAControlManeuverFiniteEulerAngles2.__doc__ = "The Euler B (Theta) component of the rotation from the reference axes to the body frame."
AgEVAControlManeuver.eVAControlManeuverFiniteEulerAngles3.__doc__ = "The Euler C (Psi) component of the rotation from the reference axes to the body frame."
AgEVAControlManeuver.eVAControlManeuverFiniteSphericalAz.__doc__ = "The spherical azimuth component of the thrust vector."
AgEVAControlManeuver.eVAControlManeuverFiniteSphericalElev.__doc__ = "The spherical elevation component of the thrust vector."
AgEVAControlManeuver.eVAControlManeuverImpulsiveCartesianX.__doc__ = "The Cartesian X component of the thrust vector."
AgEVAControlManeuver.eVAControlManeuverImpulsiveCartesianY.__doc__ = "The Cartesian Y component of the thrust vector."
AgEVAControlManeuver.eVAControlManeuverImpulsiveCartesianZ.__doc__ = "The Cartesian Z component of the thrust vector."
AgEVAControlManeuver.eVAControlManeuverImpulsiveEulerAngles1.__doc__ = "The Euler A (Phi) component of the rotation from the reference axes to the body frame."
AgEVAControlManeuver.eVAControlManeuverImpulsiveEulerAngles2.__doc__ = "The Euler B (Theta) component of the rotation from the reference axes to the body frame."
AgEVAControlManeuver.eVAControlManeuverImpulsiveEulerAngles3.__doc__ = "The Euler C (Psi) component of the rotation from the reference axes to the body frame."
AgEVAControlManeuver.eVAControlManeuverImpulsiveSphericalAz.__doc__ = "The spherical azimuth component of the thrust vector."
AgEVAControlManeuver.eVAControlManeuverImpulsiveSphericalElev.__doc__ = "The spherical elevation component of the thrust vector."
AgEVAControlManeuver.eVAControlManeuverImpulsiveSphericalMag.__doc__ = "The spherical magnitude component of the thrust vector."
AgEVAControlManeuver.eVAControlManeuverFiniteBurnCenterBias.__doc__ = "The burn center bias of the thrust."
AgEVAControlManeuver.eVAControlManeuverFiniteThrustEfficiency.__doc__ = "The thrust efficiency value."
AgEVAControlManeuver.eVAControlManeuverFiniteAz0.__doc__ = "The time varying azimuth polynomial constant term."
AgEVAControlManeuver.eVAControlManeuverFiniteAz1.__doc__ = "The time varying azimuth polynomial linear term."
AgEVAControlManeuver.eVAControlManeuverFiniteAz2.__doc__ = "The time varying azimuth polynomial quadratic term."
AgEVAControlManeuver.eVAControlManeuverFiniteAz3.__doc__ = "The time varying azimuth polynomial cubic term."
AgEVAControlManeuver.eVAControlManeuverFiniteAz4.__doc__ = "The time varying azimuth polynomial quartic term."
AgEVAControlManeuver.eVAControlManeuverFiniteAzA.__doc__ = "The time varying azimuth sine amplitude term."
AgEVAControlManeuver.eVAControlManeuverFiniteAzF.__doc__ = "The time varying azimuth sine frequency term."
AgEVAControlManeuver.eVAControlManeuverFiniteAzP.__doc__ = "The time varying azimuth sine phase term."
AgEVAControlManeuver.eVAControlManeuverFiniteEl0.__doc__ = "The time varying elevation polynomial constant term."
AgEVAControlManeuver.eVAControlManeuverFiniteEl1.__doc__ = "The time varying elevation polynomial linear term."
AgEVAControlManeuver.eVAControlManeuverFiniteEl2.__doc__ = "The time varying elevation polynomial quadratic term."
AgEVAControlManeuver.eVAControlManeuverFiniteEl3.__doc__ = "The time varying elevation polynomial cubic term."
AgEVAControlManeuver.eVAControlManeuverFiniteEl4.__doc__ = "The time varying elevation polynomial quartic term."
AgEVAControlManeuver.eVAControlManeuverFiniteElA.__doc__ = "The time varying elevation sine amplitude term."
AgEVAControlManeuver.eVAControlManeuverFiniteElF.__doc__ = "The time varying elevation sine frequency term."
AgEVAControlManeuver.eVAControlManeuverFiniteElP.__doc__ = "The time varying elevation sine phase term."

agcls.AgTypeNameMap["AgEVAControlManeuver"] = AgEVAControlManeuver

class AgEVAControlLaunch(IntEnum):
    """Launch segment properties that can be selected as control parameters for a Target Sequence."""
    # The date and time of the launch.
    eVAControlLaunchEpoch = 500
    # The geodetic latitude of the launch location.
    eVAControlLaunchGeodeticLat = 501
    # The geodetic longitude of the launch location.
    eVAControlLaunchGeodeticLon = 502
    # The geodetic altitude of the launch location.
    eVAControlLaunchGeodeticAlt = 503
    # The geocentric latitude of the launch location.
    eVAControlLaunchGeocentricLat = 504
    # The geocentric longitude of the launch location.
    eVAControlLaunchGeocentricLon = 505
    # The geocentric radius of the launch location.
    eVAControlLaunchGeocentricRad = 506
    # The time of flight, from launch until burnout.
    eVAControlLaunchTimeOfFlight = 507
    # The geocentric latitude of the burnout point.
    eVAControlLaunchBurnoutGeocentricLat = 508
    # The geocentric longitude of the burnout point.
    eVAControlLaunchBurnoutGeocentricLon = 509
    # The geocentric radius of the burnout point.
    eVAControlLaunchBurnoutGeocentricRad = 510
    # The geodetic latitude of the burnout point.
    eVAControlLaunchBurnoutGeodeticLat = 511
    # The geodetic longitude of the burnout point.
    eVAControlLaunchBurnoutGeodeticLon = 512
    # The geodetic altitude of the burnout point.
    eVAControlLaunchBurnoutGeodeticAlt = 513
    # The geodetic azimuth of the launch trajectory.
    eVAControlLaunchBurnoutAzAltAz = 514
    # The geodetic downrange distance of the burnout point.
    eVAControlLaunchBurnoutAzAltDownrangeDist = 515
    # The geodetic altitude of the burnout point.
    eVAControlLaunchBurnoutAzAltAlt = 516
    # The geocentric azimuth of the launch trajectory.
    eVAControlLaunchBurnoutAzRadAz = 517
    # The geocentric downrange distance of the burnout point.
    eVAControlLaunchBurnoutAzRadDownrangeDist = 518
    # The geocentric radius of the burnout point.
    eVAControlLaunchBurnoutAzRadRad = 519
    # The burnout velocity in the fixed frame.
    eVAControlLaunchBurnoutFixedVelocity = 520
    # The burnout velocity in the inertial frame.
    eVAControlLaunchBurnoutInertialVelocity = 521
    # Inertial Velocity Azimuth - the angle from the projection of north in the local horizontal plane to the inertial velocity vector, right handed.
    eVAControlLaunchBurnoutInertialVelocityAzimuth = 522
    # Inertial Horizontal FPA - the angle from the local horizontal to the inertial velocity vector, positive towards radius. It is also 90 degrees minus vertical flight path angle.
    eVAControlLaunchBurnoutInertialHorizontalFPA = 523
    # Dry Mass - the mass of the spacecraft exclusive of propellant.
    eVAControlLaunchDryMass = 524
    # Drag Coefficient (Cd) - the dimensionless drag coefficient associated with the drag area.
    eVAControlLaunchCd = 525
    # Drag Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of motion, used for atmospheric drag calculations.
    eVAControlLaunchDragArea = 526
    # Solar Radiation Pressure (Spherical) Coefficient (Cr) - the reflectivity of the spacecraft used for solar radiation pressure calculations, where 2.0 is fully reflective and 1.0 is not reflective at all.
    eVAControlLaunchCr = 527
    # Solar Radiation Pressure (Spherical) Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of solar radiation, used for solar radiation calculations.
    eVAControlLaunchSRPArea = 528
    # Radiation Pressure (Albedo/Thermal) Coefficient (Ck) - the reflectivity of the spacecraft used for central body radiation pressure (albedo / thermal pressure) calculations, where 2.0 is fully reflective and 1.0 is not reflective at all.
    eVAControlLaunchCk = 529
    # Radiation Pressure (Albedo/Thermal) Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of central body radiation, used for central body radiation (albedo / thermal pressure) calculations.
    eVAControlLaunchRadiationPressureArea = 530
    # GPS Solar Radiation Pressure K1 - if you are using a non-spherical SRP model, this field defines the model's K1 (scale) value.
    eVAControlLaunchK1 = 531
    # GPS Solar Radiation Pressure K2 - if you are using a non-spherical SRP model, this field defines the model's K2 (scale) value.
    eVAControlLaunchK2 = 532
    # The fuel tank pressure.
    eVAControlLaunchTankPressure = 533
    # The volume of the fuel tank.
    eVAControlLaunchTankVolume = 534
    # The fuel tank temperature.
    eVAControlLaunchTankTemp = 535
    # The density of the fuel tank.
    eVAControlLaunchFuelDensity = 536
    # The mass of the spacecraft propellant.
    eVAControlLaunchFuelMass = 537
    # Maximum Fuel Mass - the maximum fuel mass of the spacecraft; this parameter specifically applies to Finite Maneuver segments that are being executed in Backward Sequences.
    eVAControlLaunchMaxFuelMass = 538

AgEVAControlLaunch.eVAControlLaunchEpoch.__doc__ = "The date and time of the launch."
AgEVAControlLaunch.eVAControlLaunchGeodeticLat.__doc__ = "The geodetic latitude of the launch location."
AgEVAControlLaunch.eVAControlLaunchGeodeticLon.__doc__ = "The geodetic longitude of the launch location."
AgEVAControlLaunch.eVAControlLaunchGeodeticAlt.__doc__ = "The geodetic altitude of the launch location."
AgEVAControlLaunch.eVAControlLaunchGeocentricLat.__doc__ = "The geocentric latitude of the launch location."
AgEVAControlLaunch.eVAControlLaunchGeocentricLon.__doc__ = "The geocentric longitude of the launch location."
AgEVAControlLaunch.eVAControlLaunchGeocentricRad.__doc__ = "The geocentric radius of the launch location."
AgEVAControlLaunch.eVAControlLaunchTimeOfFlight.__doc__ = "The time of flight, from launch until burnout."
AgEVAControlLaunch.eVAControlLaunchBurnoutGeocentricLat.__doc__ = "The geocentric latitude of the burnout point."
AgEVAControlLaunch.eVAControlLaunchBurnoutGeocentricLon.__doc__ = "The geocentric longitude of the burnout point."
AgEVAControlLaunch.eVAControlLaunchBurnoutGeocentricRad.__doc__ = "The geocentric radius of the burnout point."
AgEVAControlLaunch.eVAControlLaunchBurnoutGeodeticLat.__doc__ = "The geodetic latitude of the burnout point."
AgEVAControlLaunch.eVAControlLaunchBurnoutGeodeticLon.__doc__ = "The geodetic longitude of the burnout point."
AgEVAControlLaunch.eVAControlLaunchBurnoutGeodeticAlt.__doc__ = "The geodetic altitude of the burnout point."
AgEVAControlLaunch.eVAControlLaunchBurnoutAzAltAz.__doc__ = "The geodetic azimuth of the launch trajectory."
AgEVAControlLaunch.eVAControlLaunchBurnoutAzAltDownrangeDist.__doc__ = "The geodetic downrange distance of the burnout point."
AgEVAControlLaunch.eVAControlLaunchBurnoutAzAltAlt.__doc__ = "The geodetic altitude of the burnout point."
AgEVAControlLaunch.eVAControlLaunchBurnoutAzRadAz.__doc__ = "The geocentric azimuth of the launch trajectory."
AgEVAControlLaunch.eVAControlLaunchBurnoutAzRadDownrangeDist.__doc__ = "The geocentric downrange distance of the burnout point."
AgEVAControlLaunch.eVAControlLaunchBurnoutAzRadRad.__doc__ = "The geocentric radius of the burnout point."
AgEVAControlLaunch.eVAControlLaunchBurnoutFixedVelocity.__doc__ = "The burnout velocity in the fixed frame."
AgEVAControlLaunch.eVAControlLaunchBurnoutInertialVelocity.__doc__ = "The burnout velocity in the inertial frame."
AgEVAControlLaunch.eVAControlLaunchBurnoutInertialVelocityAzimuth.__doc__ = "Inertial Velocity Azimuth - the angle from the projection of north in the local horizontal plane to the inertial velocity vector, right handed."
AgEVAControlLaunch.eVAControlLaunchBurnoutInertialHorizontalFPA.__doc__ = "Inertial Horizontal FPA - the angle from the local horizontal to the inertial velocity vector, positive towards radius. It is also 90 degrees minus vertical flight path angle."
AgEVAControlLaunch.eVAControlLaunchDryMass.__doc__ = "Dry Mass - the mass of the spacecraft exclusive of propellant."
AgEVAControlLaunch.eVAControlLaunchCd.__doc__ = "Drag Coefficient (Cd) - the dimensionless drag coefficient associated with the drag area."
AgEVAControlLaunch.eVAControlLaunchDragArea.__doc__ = "Drag Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of motion, used for atmospheric drag calculations."
AgEVAControlLaunch.eVAControlLaunchCr.__doc__ = "Solar Radiation Pressure (Spherical) Coefficient (Cr) - the reflectivity of the spacecraft used for solar radiation pressure calculations, where 2.0 is fully reflective and 1.0 is not reflective at all."
AgEVAControlLaunch.eVAControlLaunchSRPArea.__doc__ = "Solar Radiation Pressure (Spherical) Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of solar radiation, used for solar radiation calculations."
AgEVAControlLaunch.eVAControlLaunchCk.__doc__ = "Radiation Pressure (Albedo/Thermal) Coefficient (Ck) - the reflectivity of the spacecraft used for central body radiation pressure (albedo / thermal pressure) calculations, where 2.0 is fully reflective and 1.0 is not reflective at all."
AgEVAControlLaunch.eVAControlLaunchRadiationPressureArea.__doc__ = "Radiation Pressure (Albedo/Thermal) Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of central body radiation, used for central body radiation (albedo / thermal pressure) calculations."
AgEVAControlLaunch.eVAControlLaunchK1.__doc__ = "GPS Solar Radiation Pressure K1 - if you are using a non-spherical SRP model, this field defines the model's K1 (scale) value."
AgEVAControlLaunch.eVAControlLaunchK2.__doc__ = "GPS Solar Radiation Pressure K2 - if you are using a non-spherical SRP model, this field defines the model's K2 (scale) value."
AgEVAControlLaunch.eVAControlLaunchTankPressure.__doc__ = "The fuel tank pressure."
AgEVAControlLaunch.eVAControlLaunchTankVolume.__doc__ = "The volume of the fuel tank."
AgEVAControlLaunch.eVAControlLaunchTankTemp.__doc__ = "The fuel tank temperature."
AgEVAControlLaunch.eVAControlLaunchFuelDensity.__doc__ = "The density of the fuel tank."
AgEVAControlLaunch.eVAControlLaunchFuelMass.__doc__ = "The mass of the spacecraft propellant."
AgEVAControlLaunch.eVAControlLaunchMaxFuelMass.__doc__ = "Maximum Fuel Mass - the maximum fuel mass of the spacecraft; this parameter specifically applies to Finite Maneuver segments that are being executed in Backward Sequences."

agcls.AgTypeNameMap["AgEVAControlLaunch"] = AgEVAControlLaunch

class AgEVAControlAdvanced(IntEnum):
    """Propagate segment properties that can be selected as control parameters for a Target Sequence."""
    # The maximum propagation time, after which the segment will end regardless of whether the stopping conditions have been satisfied.
    eVAControlPropagateMaxPropTime = 600
    # The minimum propagation time - minimum time that must elapse from the beginning of the segment until Astrogator will begin checking stopping conditions for satisfaction.
    eVAControlPropagateMinPropTime = 601

AgEVAControlAdvanced.eVAControlPropagateMaxPropTime.__doc__ = "The maximum propagation time, after which the segment will end regardless of whether the stopping conditions have been satisfied."
AgEVAControlAdvanced.eVAControlPropagateMinPropTime.__doc__ = "The minimum propagation time - minimum time that must elapse from the beginning of the segment until Astrogator will begin checking stopping conditions for satisfaction."

agcls.AgTypeNameMap["AgEVAControlAdvanced"] = AgEVAControlAdvanced

class AgEVATargetSeqAction(IntEnum):
    """Action options for Target Sequence profiles."""
    # Run Nominal Sequence - runs the mission control sequence.
    eVATargetSeqActionRunNominalSeq = 0
    # Run Active Profiles - runs the mission control sequence allowing the active profiles to operate.
    eVATargetSeqActionRunActiveProfiles = 1
    # Run Active Profiles Once - runs the profile with corrections applied to control parameters.
    eVATargetSeqActionRunActiveProfilesOnce = 2

AgEVATargetSeqAction.eVATargetSeqActionRunNominalSeq.__doc__ = "Run Nominal Sequence - runs the mission control sequence."
AgEVATargetSeqAction.eVATargetSeqActionRunActiveProfiles.__doc__ = "Run Active Profiles - runs the mission control sequence allowing the active profiles to operate."
AgEVATargetSeqAction.eVATargetSeqActionRunActiveProfilesOnce.__doc__ = "Run Active Profiles Once - runs the profile with corrections applied to control parameters."

agcls.AgTypeNameMap["AgEVATargetSeqAction"] = AgEVATargetSeqAction

class AgEVAProfilesFinish(IntEnum):
    """Action options for Target Sequence profiles convergence."""
    # Run To Return And Continue - run to the first Return segment in the sequence, then pass control to the next segment after this target sequence. Often, the only Return is at the end of the target sequence.
    eVAProfilesFinishRunToReturnAndContinue = 0
    # Run To Return And Stop - run the target sequence to the first Return segment, and then stop running the MCS altogether.
    eVAProfilesFinishRunToReturnAndStop = 1
    # Stop - stop the MCS as soon as the target sequence has converged.
    eVAProfilesFinishStop = 2

AgEVAProfilesFinish.eVAProfilesFinishRunToReturnAndContinue.__doc__ = "Run To Return And Continue - run to the first Return segment in the sequence, then pass control to the next segment after this target sequence. Often, the only Return is at the end of the target sequence."
AgEVAProfilesFinish.eVAProfilesFinishRunToReturnAndStop.__doc__ = "Run To Return And Stop - run the target sequence to the first Return segment, and then stop running the MCS altogether."
AgEVAProfilesFinish.eVAProfilesFinishStop.__doc__ = "Stop - stop the MCS as soon as the target sequence has converged."

agcls.AgTypeNameMap["AgEVAProfilesFinish"] = AgEVAProfilesFinish

class AgEVAUpdateParam(IntEnum):
    """Spacecraft parameters that can be modified by an Update segment."""
    # Drag Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of motion, used for atmospheric drag calculations.
    eVAUpdateParamDragArea = 0
    # Solar Radiation Pressure (Spherical) Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of solar radiation, used for solar radiation calculations.
    eVAUpdateParamSRPArea = 1
    # Dry Mass - the mass of the spacecraft exclusive of propellant.
    eVAUpdateParamDryMass = 2
    # The mass of the spacecraft propellant.
    eVAUpdateParamFuelMass = 3
    # The density of the fuel tank.
    eVAUpdateParamFuelDensity = 4
    # The fuel tank pressure.
    eVAUpdateParamTankPressure = 5
    # The temperature of the fuel tank.
    eVAUpdateParamTankTemp = 6
    # Solar Radiation Pressure (Spherical) Coefficient (Cr) - the reflectivity of the spacecraft used for solar radiation pressure calculations, where 2.0 is fully reflective and 1.0 is not reflective at all.
    eVAUpdateParamCr = 7
    # Drag Coefficient (Cd) - the dimensionless drag coefficient associated with the drag area.
    eVAUpdateParamCd = 8
    # Radiation Pressure (Albedo/Thermal) Coefficient (Ck) - the reflectivity of the spacecraft used for central body radiation pressure (albedo / thermal pressure) calculations, where 2.0 is fully reflective and 1.0 is not reflective at all.
    eVAUpdateParamCk = 9
    # Radiation Pressure (Albedo/Thermal) Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of central body radiation, used for central body radiation (albedo / thermal pressure) calculations.
    eVAUpdateParamRadiationPressureArea = 10

AgEVAUpdateParam.eVAUpdateParamDragArea.__doc__ = "Drag Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of motion, used for atmospheric drag calculations."
AgEVAUpdateParam.eVAUpdateParamSRPArea.__doc__ = "Solar Radiation Pressure (Spherical) Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of solar radiation, used for solar radiation calculations."
AgEVAUpdateParam.eVAUpdateParamDryMass.__doc__ = "Dry Mass - the mass of the spacecraft exclusive of propellant."
AgEVAUpdateParam.eVAUpdateParamFuelMass.__doc__ = "The mass of the spacecraft propellant."
AgEVAUpdateParam.eVAUpdateParamFuelDensity.__doc__ = "The density of the fuel tank."
AgEVAUpdateParam.eVAUpdateParamTankPressure.__doc__ = "The fuel tank pressure."
AgEVAUpdateParam.eVAUpdateParamTankTemp.__doc__ = "The temperature of the fuel tank."
AgEVAUpdateParam.eVAUpdateParamCr.__doc__ = "Solar Radiation Pressure (Spherical) Coefficient (Cr) - the reflectivity of the spacecraft used for solar radiation pressure calculations, where 2.0 is fully reflective and 1.0 is not reflective at all."
AgEVAUpdateParam.eVAUpdateParamCd.__doc__ = "Drag Coefficient (Cd) - the dimensionless drag coefficient associated with the drag area."
AgEVAUpdateParam.eVAUpdateParamCk.__doc__ = "Radiation Pressure (Albedo/Thermal) Coefficient (Ck) - the reflectivity of the spacecraft used for central body radiation pressure (albedo / thermal pressure) calculations, where 2.0 is fully reflective and 1.0 is not reflective at all."
AgEVAUpdateParam.eVAUpdateParamRadiationPressureArea.__doc__ = "Radiation Pressure (Albedo/Thermal) Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of central body radiation, used for central body radiation (albedo / thermal pressure) calculations."

agcls.AgTypeNameMap["AgEVAUpdateParam"] = AgEVAUpdateParam

class AgEVAUpdateAction(IntEnum):
    """Actions for the Update segment."""
    # No change in value - leave the current value for this parameter unchanged (ignoring any quantity that may appear in the Value column).
    eVAUpdateActionNoChange = 0
    # Add value - add the quantity entered in the Value column to the current value for this parameter.
    eVAUpdateActionAddValue = 1
    # Subtract value - subtract the quantity entered in the Value column from the current value for this parameter.
    eVAUpdateActionSubtractValue = 2
    # Set to new value - replace the current value for this parameter with the quantity entered in the Value column.
    eVAUpdateActionSetToNewValue = 3

AgEVAUpdateAction.eVAUpdateActionNoChange.__doc__ = "No change in value - leave the current value for this parameter unchanged (ignoring any quantity that may appear in the Value column)."
AgEVAUpdateAction.eVAUpdateActionAddValue.__doc__ = "Add value - add the quantity entered in the Value column to the current value for this parameter."
AgEVAUpdateAction.eVAUpdateActionSubtractValue.__doc__ = "Subtract value - subtract the quantity entered in the Value column from the current value for this parameter."
AgEVAUpdateAction.eVAUpdateActionSetToNewValue.__doc__ = "Set to new value - replace the current value for this parameter with the quantity entered in the Value column."

agcls.AgTypeNameMap["AgEVAUpdateAction"] = AgEVAUpdateAction

class AgEVAPressureMode(IntEnum):
    """Pressure Mode options."""
    # Blow-Down - pressure decreases as propellant is consumed and the volume occupied by the pressurant gas consequently increases. This is based on the ideal gas law.
    eVAPressureModeBlowDown = 0
    # Pressure-Regulated - constant pressure is maintained in the fuel tank through some pressurization mechanism as the propellant mass decreases.
    eVAPressureModePressureRegulated = 1

AgEVAPressureMode.eVAPressureModeBlowDown.__doc__ = "Blow-Down - pressure decreases as propellant is consumed and the volume occupied by the pressurant gas consequently increases. This is based on the ideal gas law."
AgEVAPressureMode.eVAPressureModePressureRegulated.__doc__ = "Pressure-Regulated - constant pressure is maintained in the fuel tank through some pressurization mechanism as the propellant mass decreases."

agcls.AgTypeNameMap["AgEVAPressureMode"] = AgEVAPressureMode

class AgEVAThrustType(IntEnum):
    """Thrust options."""
    # Affects Acceleration and Mass Flow Calculations - may represent an inefficiency in the propulsion tanks and feed lines.
    eVAThrustTypeAffectsAccelAndMassFlow = 0
    # Affects Acceleration Only - an efficiency of 0.98 means that only 98% of the fuel will be spent to get 98% thrust. For example, a thrust efficiency affecting acceleration only may represent some problem in the combustion chamber.
    eVAThrustTypeAffectsAccelOnly = 1

AgEVAThrustType.eVAThrustTypeAffectsAccelAndMassFlow.__doc__ = "Affects Acceleration and Mass Flow Calculations - may represent an inefficiency in the propulsion tanks and feed lines."
AgEVAThrustType.eVAThrustTypeAffectsAccelOnly.__doc__ = "Affects Acceleration Only - an efficiency of 0.98 means that only 98% of the fuel will be spent to get 98% thrust. For example, a thrust efficiency affecting acceleration only may represent some problem in the combustion chamber."

agcls.AgTypeNameMap["AgEVAThrustType"] = AgEVAThrustType

class AgEVAAttitudeUpdate(IntEnum):
    """Attitude Update."""
    # Update during burn - updated throughout the maneuver so as to maintain the required thrust direction. This forces the thrust vector to the specified direction at every instant throughout the burn.
    eVAAttitudeUpdateDuringBurn = 0
    # Inertial at ignition - specified by Attitude Control at ignition and remains the same throughout the maneuver. This fixes the thrust direction in the inertial direction calculated at the beginning of the burn and is used for inertially fixed spacecraft.
    eVAAttitudeUpdateInertialAtIgnition = 1
    # Inertial at start - specified by Attitude Control at the beginning of the maneuver segment and remains the same throughout the maneuver.
    eVAAttitudeUpdateInertialAtStart = 2

AgEVAAttitudeUpdate.eVAAttitudeUpdateDuringBurn.__doc__ = "Update during burn - updated throughout the maneuver so as to maintain the required thrust direction. This forces the thrust vector to the specified direction at every instant throughout the burn."
AgEVAAttitudeUpdate.eVAAttitudeUpdateInertialAtIgnition.__doc__ = "Inertial at ignition - specified by Attitude Control at ignition and remains the same throughout the maneuver. This fixes the thrust direction in the inertial direction calculated at the beginning of the burn and is used for inertially fixed spacecraft."
AgEVAAttitudeUpdate.eVAAttitudeUpdateInertialAtStart.__doc__ = "Inertial at start - specified by Attitude Control at the beginning of the maneuver segment and remains the same throughout the maneuver."

agcls.AgTypeNameMap["AgEVAAttitudeUpdate"] = AgEVAAttitudeUpdate

class AgEVAPropulsionMethod(IntEnum):
    """Propulsion method options."""
    # Engine Model - can be used to quickly model the firing of a single engine.
    eVAPropulsionMethodEngineModel = 0
    # Thruster Set - used to fire multiple engines simultaneously, and to simulate off-pulsing or complex engine pointing.
    eVAPropulsionMethodThrusterSet = 1

AgEVAPropulsionMethod.eVAPropulsionMethodEngineModel.__doc__ = "Engine Model - can be used to quickly model the firing of a single engine."
AgEVAPropulsionMethod.eVAPropulsionMethodThrusterSet.__doc__ = "Thruster Set - used to fire multiple engines simultaneously, and to simulate off-pulsing or complex engine pointing."

agcls.AgTypeNameMap["AgEVAPropulsionMethod"] = AgEVAPropulsionMethod

class AgEVACustomFunction(IntEnum):
    """Attitude definition options for other STK functions."""
    # Use attitude page definition for other STK functions - the actual attitude during the maneuver is ignored and the satellite is considered to always be in the attitude specified by the page for all other calculations in STK.
    eVAEnablePageDefinition = 0
    # Maneuver attitude will be used for the satellite during the time at the maneuver, and during the specified lead and trail times. This attitude will also show up in reports, graphs, sensor access calculations, and in the 3D Graphics window.
    eVAEnableManeuverAttitude = 1

AgEVACustomFunction.eVAEnablePageDefinition.__doc__ = "Use attitude page definition for other STK functions - the actual attitude during the maneuver is ignored and the satellite is considered to always be in the attitude specified by the page for all other calculations in STK."
AgEVACustomFunction.eVAEnableManeuverAttitude.__doc__ = "Maneuver attitude will be used for the satellite during the time at the maneuver, and during the specified lead and trail times. This attitude will also show up in reports, graphs, sensor access calculations, and in the 3D Graphics window."

agcls.AgTypeNameMap["AgEVACustomFunction"] = AgEVACustomFunction

class AgEVABodyAxis(IntEnum):
    """Attitude body axis options."""
    # The positive X engine acceleration direction.
    eVABodyAxisPlusX = 0
    # The positive Y engine acceleration direction.
    eVABodyAxisPlusY = 1
    # The positive Z engine acceleration direction.
    eVABodyAxisPlusZ = 2
    # The negative X engine acceleration direction.
    eVABodyAxisMinusX = 3
    # The negative Y engine acceleration direction.
    eVABodyAxisMinusY = 4
    # The negative Z engine acceleration direction.
    eVABodyAxisMinusZ = 5

AgEVABodyAxis.eVABodyAxisPlusX.__doc__ = "The positive X engine acceleration direction."
AgEVABodyAxis.eVABodyAxisPlusY.__doc__ = "The positive Y engine acceleration direction."
AgEVABodyAxis.eVABodyAxisPlusZ.__doc__ = "The positive Z engine acceleration direction."
AgEVABodyAxis.eVABodyAxisMinusX.__doc__ = "The negative X engine acceleration direction."
AgEVABodyAxis.eVABodyAxisMinusY.__doc__ = "The negative Y engine acceleration direction."
AgEVABodyAxis.eVABodyAxisMinusZ.__doc__ = "The negative Z engine acceleration direction."

agcls.AgTypeNameMap["AgEVABodyAxis"] = AgEVABodyAxis

class AgEVAConstraintSign(IntEnum):
    """Constraint vector sign options."""
    # Positive.
    eVAConstraintSignPlus = 0
    # Negative.
    eVAConstraintSignMinus = 1

AgEVAConstraintSign.eVAConstraintSignPlus.__doc__ = "Positive."
AgEVAConstraintSign.eVAConstraintSignMinus.__doc__ = "Negative."

agcls.AgTypeNameMap["AgEVAConstraintSign"] = AgEVAConstraintSign

class AgEVAAttitudeControl(IntEnum):
    """Attitude Control options."""
    # Along Velocity Vector (impulsive/finite) - the total thrust vector is aligned with the spacecraft's velocity vector.
    eVAAttitudeControlVelocityVector = 0
    # Anti-Velocity Vector (impulsive/finite) - the total thrust vector is opposite to the spacecraft's velocity vector.
    eVAAttitudeControlAntiVelocityVector = 1
    # Attitude (impulsive/finite) - the thrust vector direction is defined using Euler Angles or a Quaternion. 
    eVAAttitudeControlAttitude = 2
    # File (impulsive/finite) - uses an attitude file to set the thrust vector direction.
    eVAAttitudeControlFile = 3
    # Thrust Vector (impulsive/finite) - the total thrust vector is explicitly specified in Cartesian or spherical form with respect to the thrust axes.
    eVAAttitudeControlThrustVector = 4
    # Plugin (finite) - thrust vector direction is defined using a COM plugin.
    eVAAttitudeControlPlugin = 5
    # Time Varying (finite) - polynomial and sine representations for the azimuth and elevation of the thrust vector.
    eVAAttitudeControlTimeVarying = 6
    # Lagrange Interpolation (optimal finite, always set) - supports the 'Run current nodes' execution mode of the Optimal Finite Maneuver.
    eVAAttitudeControlLagrangeInterpolation = 7

AgEVAAttitudeControl.eVAAttitudeControlVelocityVector.__doc__ = "Along Velocity Vector (impulsive/finite) - the total thrust vector is aligned with the spacecraft's velocity vector."
AgEVAAttitudeControl.eVAAttitudeControlAntiVelocityVector.__doc__ = "Anti-Velocity Vector (impulsive/finite) - the total thrust vector is opposite to the spacecraft's velocity vector."
AgEVAAttitudeControl.eVAAttitudeControlAttitude.__doc__ = "Attitude (impulsive/finite) - the thrust vector direction is defined using Euler Angles or a Quaternion. "
AgEVAAttitudeControl.eVAAttitudeControlFile.__doc__ = "File (impulsive/finite) - uses an attitude file to set the thrust vector direction."
AgEVAAttitudeControl.eVAAttitudeControlThrustVector.__doc__ = "Thrust Vector (impulsive/finite) - the total thrust vector is explicitly specified in Cartesian or spherical form with respect to the thrust axes."
AgEVAAttitudeControl.eVAAttitudeControlPlugin.__doc__ = "Plugin (finite) - thrust vector direction is defined using a COM plugin."
AgEVAAttitudeControl.eVAAttitudeControlTimeVarying.__doc__ = "Time Varying (finite) - polynomial and sine representations for the azimuth and elevation of the thrust vector."
AgEVAAttitudeControl.eVAAttitudeControlLagrangeInterpolation.__doc__ = "Lagrange Interpolation (optimal finite, always set) - supports the 'Run current nodes' execution mode of the Optimal Finite Maneuver."

agcls.AgTypeNameMap["AgEVAAttitudeControl"] = AgEVAAttitudeControl

class AgEVAFollowJoin(IntEnum):
    """Joining options for the Follow segment."""
    # Specify Joining Conditions - specify joining conditions to define when the spacecraft will begin to follow the leader. Joining conditions will become apparent on a new tab - Joining.
    eVAFollowJoinSpecify = 0
    # Join at Beginning of Leader's Ephemeris - the spacecraft will follow the leader from the beginning of the leader's ephemeris.
    eVAFollowJoinAtBeginning = 1
    # Join at End of Leader's Ephemeris - the spacecraft will use the leader's final ephemeris point as the initial and final state of the Follow segment; the separation parameter will automatically be set to 'Separate at End of Leader's Ephemeris'.
    eVAFollowJoinAtEnd = 2
    # Join at Final Epoch of Previous Segment - the spacecraft will follow the leader from the final epoch at the end of the previous segment.
    eVAFollowJoinAtFinalEpochOfPreviousSeg = 3

AgEVAFollowJoin.eVAFollowJoinSpecify.__doc__ = "Specify Joining Conditions - specify joining conditions to define when the spacecraft will begin to follow the leader. Joining conditions will become apparent on a new tab - Joining."
AgEVAFollowJoin.eVAFollowJoinAtBeginning.__doc__ = "Join at Beginning of Leader's Ephemeris - the spacecraft will follow the leader from the beginning of the leader's ephemeris."
AgEVAFollowJoin.eVAFollowJoinAtEnd.__doc__ = "Join at End of Leader's Ephemeris - the spacecraft will use the leader's final ephemeris point as the initial and final state of the Follow segment; the separation parameter will automatically be set to 'Separate at End of Leader's Ephemeris'."
AgEVAFollowJoin.eVAFollowJoinAtFinalEpochOfPreviousSeg.__doc__ = "Join at Final Epoch of Previous Segment - the spacecraft will follow the leader from the final epoch at the end of the previous segment."

agcls.AgTypeNameMap["AgEVAFollowJoin"] = AgEVAFollowJoin

class AgEVAFollowSeparation(IntEnum):
    """Separation options for the Follow segment."""
    # Specify Separation Conditions - specify separation conditions to define when the spacecraft will stop following the leader. Separation conditions will become apparent on a new tab - Separation.
    eVAFollowSeparationSpecify = 0
    # Separate at End of Leader's Ephemeris - the spacecraft will follow the leader to the end of the leader's ephemeris and then separate.
    eVAFollowSeparationAtEndOfLeadersEphem = 1

AgEVAFollowSeparation.eVAFollowSeparationSpecify.__doc__ = "Specify Separation Conditions - specify separation conditions to define when the spacecraft will stop following the leader. Separation conditions will become apparent on a new tab - Separation."
AgEVAFollowSeparation.eVAFollowSeparationAtEndOfLeadersEphem.__doc__ = "Separate at End of Leader's Ephemeris - the spacecraft will follow the leader to the end of the leader's ephemeris and then separate."

agcls.AgTypeNameMap["AgEVAFollowSeparation"] = AgEVAFollowSeparation

class AgEVAFollowSpacecraftAndFuelTank(IntEnum):
    """Spacecraft parameter options for the Follow segment."""
    # Specify Spacecraft Configuration - manually define the spacecraft for this segment. Spacecraft physical parameters will become apparent on new tabs - Spacecraft Parameters and Fuel Tank.
    eVAFollowSpacecraftAndFuelTankSpecify = 0
    # Inherit Spacecraft Configuration From Previous Segment - the spacecraft will be defined by its configuration at the end of the previous segment. The configuration will not be changed by the Follow segment.
    eVAFollowSpacecraftAndFuelTankInherit = 1
    # Inherit Spacecraft Configuration From Leader - if leader is an Astrogator satellite, configuration will be defined by the leader's configuration.
    eVAFollowSpacecraftAndFuelTankLeader = 2

AgEVAFollowSpacecraftAndFuelTank.eVAFollowSpacecraftAndFuelTankSpecify.__doc__ = "Specify Spacecraft Configuration - manually define the spacecraft for this segment. Spacecraft physical parameters will become apparent on new tabs - Spacecraft Parameters and Fuel Tank."
AgEVAFollowSpacecraftAndFuelTank.eVAFollowSpacecraftAndFuelTankInherit.__doc__ = "Inherit Spacecraft Configuration From Previous Segment - the spacecraft will be defined by its configuration at the end of the previous segment. The configuration will not be changed by the Follow segment."
AgEVAFollowSpacecraftAndFuelTank.eVAFollowSpacecraftAndFuelTankLeader.__doc__ = "Inherit Spacecraft Configuration From Leader - if leader is an Astrogator satellite, configuration will be defined by the leader's configuration."

agcls.AgTypeNameMap["AgEVAFollowSpacecraftAndFuelTank"] = AgEVAFollowSpacecraftAndFuelTank

class AgEVABurnoutOptions(IntEnum):
    """Burnout options for the Launch segment."""
    # Use Fixed Velocity - the inclination of the final state of the launch segment is determined by the arc between the launch and insertion positions, and the horizontal flight path angle is set to zero.
    eVABurnoutOptionsFixedVelocity = 0
    # Use Inertial Velocity - the final state of the launch segment is solely and completely determined by the burnout position and velocity.
    eVABurnoutOptionsInertialVelocity = 1

AgEVABurnoutOptions.eVABurnoutOptionsFixedVelocity.__doc__ = "Use Fixed Velocity - the inclination of the final state of the launch segment is determined by the arc between the launch and insertion positions, and the horizontal flight path angle is set to zero."
AgEVABurnoutOptions.eVABurnoutOptionsInertialVelocity.__doc__ = "Use Inertial Velocity - the final state of the launch segment is solely and completely determined by the burnout position and velocity."

agcls.AgTypeNameMap["AgEVABurnoutOptions"] = AgEVABurnoutOptions

class AgEVABurnoutType(IntEnum):
    """Burnout point definition types for the Launch segment."""
    # Geocentric (Planetocentric) - the burnout point is measured from the center of mass of the Earth or other central body.
    eVABurnoutTypeGeocentric = 0
    # Geodetic (Planetodetic) - the burnout point is measured along the normal to the surface of an ellipsoid defined with reference to the Earth (or other central body).
    eVABurnoutTypeGeodetic = 1
    # Launch Az / Radius - the burnout point is defined in reference to distance downrange along an azimuth, measured from the center of mass of the Earth or other central body.
    eVABurnoutTypeLaunchAzRad = 2
    # Launch Az / Alt - the burnout point is defined in reference to distance downrange along an azimuth, measured from the surface of the Earth or other central body.
    eVABurnoutTypeLaunchAzAlt = 3
    # Central Body Fixed Cartesian - the burnout state is specified in the central-body-fixed Cartesian coordinate system.
    eVABurnoutTypeCBFCartesian = 4

AgEVABurnoutType.eVABurnoutTypeGeocentric.__doc__ = "Geocentric (Planetocentric) - the burnout point is measured from the center of mass of the Earth or other central body."
AgEVABurnoutType.eVABurnoutTypeGeodetic.__doc__ = "Geodetic (Planetodetic) - the burnout point is measured along the normal to the surface of an ellipsoid defined with reference to the Earth (or other central body)."
AgEVABurnoutType.eVABurnoutTypeLaunchAzRad.__doc__ = "Launch Az / Radius - the burnout point is defined in reference to distance downrange along an azimuth, measured from the center of mass of the Earth or other central body."
AgEVABurnoutType.eVABurnoutTypeLaunchAzAlt.__doc__ = "Launch Az / Alt - the burnout point is defined in reference to distance downrange along an azimuth, measured from the surface of the Earth or other central body."
AgEVABurnoutType.eVABurnoutTypeCBFCartesian.__doc__ = "Central Body Fixed Cartesian - the burnout state is specified in the central-body-fixed Cartesian coordinate system."

agcls.AgTypeNameMap["AgEVABurnoutType"] = AgEVABurnoutType

class AgEVAAscentType(IntEnum):
    """Ascent types for the Launch segment."""
    # Ellipse: Cubic Motion - the motion is computed on the basis of given positions and velocities.
    eVAAscentTypeEllipseCubicMotion = 0
    # Ellipse: Quartic Motion - the motion is computed on the basis of given positions and velocities and initial acceleration.
    eVAAscentTypeEllipseQuarticMotion = 1

AgEVAAscentType.eVAAscentTypeEllipseCubicMotion.__doc__ = "Ellipse: Cubic Motion - the motion is computed on the basis of given positions and velocities."
AgEVAAscentType.eVAAscentTypeEllipseQuarticMotion.__doc__ = "Ellipse: Quartic Motion - the motion is computed on the basis of given positions and velocities and initial acceleration."

agcls.AgTypeNameMap["AgEVAAscentType"] = AgEVAAscentType

class AgEVALaunchDisplaySystem(IntEnum):
    """Launch location coordinate types for the Launch segment."""
    # Geocentric (Planetocentric) - the location is measured from the center of mass of the Earth or other central body.
    eVADisplaySystemGeodetic = 0
    # Geodetic (Planetodetic) - the location is measured along the normal to the surface of an ellipsoid defined with reference to the Earth (or other central body).
    eVADisplaySystemGeocentric = 1

AgEVALaunchDisplaySystem.eVADisplaySystemGeodetic.__doc__ = "Geocentric (Planetocentric) - the location is measured from the center of mass of the Earth or other central body."
AgEVALaunchDisplaySystem.eVADisplaySystemGeocentric.__doc__ = "Geodetic (Planetodetic) - the location is measured along the normal to the surface of an ellipsoid defined with reference to the Earth (or other central body)."

agcls.AgTypeNameMap["AgEVALaunchDisplaySystem"] = AgEVALaunchDisplaySystem

class AgEVARunCode(IntEnum):
    """The run code returned after the MCS is run."""
    # Marching - a segment has run successfully.
    eVARunCodeMarching = 0
    # Profile Failure - a search profile failed to converge.
    eVARunCodeProfileFailure = 1
    # Error - encountered an error.
    eVARunCodeError = 2
    # Stopped - encountered a stop segment.
    eVARunCodeStopped = 3
    # Returned - encountered a return segment.
    eVARunCodeReturned = 4
    # Cancelled - cancelled by user.
    eVARunCodeCancelled = 5
    # Global Stop - hit a global stopping condition.
    eVARunCodeHitGlobalStop = 6

AgEVARunCode.eVARunCodeMarching.__doc__ = "Marching - a segment has run successfully."
AgEVARunCode.eVARunCodeProfileFailure.__doc__ = "Profile Failure - a search profile failed to converge."
AgEVARunCode.eVARunCodeError.__doc__ = "Error - encountered an error."
AgEVARunCode.eVARunCodeStopped.__doc__ = "Stopped - encountered a stop segment."
AgEVARunCode.eVARunCodeReturned.__doc__ = "Returned - encountered a return segment."
AgEVARunCode.eVARunCodeCancelled.__doc__ = "Cancelled - cancelled by user."
AgEVARunCode.eVARunCodeHitGlobalStop.__doc__ = "Global Stop - hit a global stopping condition."

agcls.AgTypeNameMap["AgEVARunCode"] = AgEVARunCode

class AgEVASequenceStateToPass(IntEnum):
    """State To Pass options for the Sequence segment."""
    # The initial state of the sequence.
    eVASequenceStateToPassInitial = 0
    # The final state of the sequence.
    eVASequenceStateToPassFinal = 1

AgEVASequenceStateToPass.eVASequenceStateToPassInitial.__doc__ = "The initial state of the sequence."
AgEVASequenceStateToPass.eVASequenceStateToPassFinal.__doc__ = "The final state of the sequence."

agcls.AgTypeNameMap["AgEVASequenceStateToPass"] = AgEVASequenceStateToPass

class AgEVAManeuverType(IntEnum):
    """Maneuver types for the maneuver segment."""
    # Impulsive - calculates a state by adding the defined delta-V vector to the velocity of the final state of the previous segment, adds this new state to the ephemeris, and passes it to the next segment.
    eVAManeuverTypeImpulsive = 0
    # Finite - effectively a Propagate segment with thrust. Like Propagate segments, each point calculated by the propagator is added to the ephemeris, and propagation continues until a stopping condition is met.
    eVAManeuverTypeFinite = 1
    # Optimal Finite
    eVAManeuverTypeOptimalFinite = 2

AgEVAManeuverType.eVAManeuverTypeImpulsive.__doc__ = "Impulsive - calculates a state by adding the defined delta-V vector to the velocity of the final state of the previous segment, adds this new state to the ephemeris, and passes it to the next segment."
AgEVAManeuverType.eVAManeuverTypeFinite.__doc__ = "Finite - effectively a Propagate segment with thrust. Like Propagate segments, each point calculated by the propagator is added to the ephemeris, and propagation continues until a stopping condition is met."
AgEVAManeuverType.eVAManeuverTypeOptimalFinite.__doc__ = "Optimal Finite"

agcls.AgTypeNameMap["AgEVAManeuverType"] = AgEVAManeuverType

class AgEVASegmentType(IntEnum):
    """Segment types."""
    # Initial State - can be used to define the initial conditions of your MCS, or of a subsequence within the MCS.
    eVASegmentTypeInitialState = 0
    # Launch - can be used to model a simple spacecraft launch from Earth or another central body.
    eVASegmentTypeLaunch = 1
    # Maneuver - can be used to model a spacecraft maneuver.
    eVASegmentTypeManeuver = 2
    # Follow - can be used to set the spacecraft to follow another vehicle (Satellite, Launch Vehicle, Missile, Aircraft, Ship, or Ground Vehicle) at a specified offset, and to separate from that vehicle upon meeting specified conditions.
    eVASegmentTypeFollow = 3
    # Hold - can be used to model landing or rendezvous operations by setting the spacecraft to maintain a fixed position in reference to another object or body, until meeting specified conditions.
    eVASegmentTypeHold = 4
    # Propagate - can be used to model the movement of the spacecraft along its current trajectory until meeting specified stopping conditions.
    eVASegmentTypePropagate = 5
    # Sequence - can be used to organize segments and define the nature of the results that are passed on to the next segment or sequence in the MCS.
    eVASegmentTypeSequence = 6
    # Return - can be used to control the execution of the Mission Control Sequence by returning control to its parent segment.
    eVASegmentTypeReturn = 7
    # Target Sequence - can be used to define maneuvers and propagations in terms of the goals they are intended to achieve.
    eVASegmentTypeTargetSequence = 8
    # Stop - can be used to control the execution of the Mission Control Sequence by halting execution of the MCS.
    eVASegmentTypeStop = 9
    # Update - can be used to modify some of the satellite properties to reflect changes that occur during the mission.
    eVASegmentTypeUpdate = 10
    # Backward Sequence - can be used to organize segments and define the nature of the results that are passed on to the next segment or sequence in the MCS.
    eVASegmentTypeBackwardSequence = 11
    # End - The End segment is a default segment of the MCS that functions similarly to a Return segment; it returns control to the beginning of the MCS. The End segment cannot be disabled or deleted, nor can any segments be inserted into the MCS after it.
    eVASegmentTypeEnd = 12

AgEVASegmentType.eVASegmentTypeInitialState.__doc__ = "Initial State - can be used to define the initial conditions of your MCS, or of a subsequence within the MCS."
AgEVASegmentType.eVASegmentTypeLaunch.__doc__ = "Launch - can be used to model a simple spacecraft launch from Earth or another central body."
AgEVASegmentType.eVASegmentTypeManeuver.__doc__ = "Maneuver - can be used to model a spacecraft maneuver."
AgEVASegmentType.eVASegmentTypeFollow.__doc__ = "Follow - can be used to set the spacecraft to follow another vehicle (Satellite, Launch Vehicle, Missile, Aircraft, Ship, or Ground Vehicle) at a specified offset, and to separate from that vehicle upon meeting specified conditions."
AgEVASegmentType.eVASegmentTypeHold.__doc__ = "Hold - can be used to model landing or rendezvous operations by setting the spacecraft to maintain a fixed position in reference to another object or body, until meeting specified conditions."
AgEVASegmentType.eVASegmentTypePropagate.__doc__ = "Propagate - can be used to model the movement of the spacecraft along its current trajectory until meeting specified stopping conditions."
AgEVASegmentType.eVASegmentTypeSequence.__doc__ = "Sequence - can be used to organize segments and define the nature of the results that are passed on to the next segment or sequence in the MCS."
AgEVASegmentType.eVASegmentTypeReturn.__doc__ = "Return - can be used to control the execution of the Mission Control Sequence by returning control to its parent segment."
AgEVASegmentType.eVASegmentTypeTargetSequence.__doc__ = "Target Sequence - can be used to define maneuvers and propagations in terms of the goals they are intended to achieve."
AgEVASegmentType.eVASegmentTypeStop.__doc__ = "Stop - can be used to control the execution of the Mission Control Sequence by halting execution of the MCS."
AgEVASegmentType.eVASegmentTypeUpdate.__doc__ = "Update - can be used to modify some of the satellite properties to reflect changes that occur during the mission."
AgEVASegmentType.eVASegmentTypeBackwardSequence.__doc__ = "Backward Sequence - can be used to organize segments and define the nature of the results that are passed on to the next segment or sequence in the MCS."
AgEVASegmentType.eVASegmentTypeEnd.__doc__ = "End - The End segment is a default segment of the MCS that functions similarly to a Return segment; it returns control to the beginning of the MCS. The End segment cannot be disabled or deleted, nor can any segments be inserted into the MCS after it."

agcls.AgTypeNameMap["AgEVASegmentType"] = AgEVASegmentType

class AgEVAElementType(IntEnum):
    """Types of orbit element sets."""
    # Cartesian - specifying an orbit by three position elements and three velocity elements in a rectangular coordinate system.
    eVAElementTypeCartesian = 0
    # Keplerian - the classical system, specifying an orbit by six elements describing its size, shape and three-dimensional orientation in space.
    eVAElementTypeKeplerian = 1
    # Spherical - a system in which positions are specified as a radial distance from the origin and two angles relative to a fundamental plane.
    eVAElementTypeSpherical = 3
    # Target Vector Incoming Asymptote - used for hyperbolic arrival trajectories.
    eVAElementTypeTargetVectorIncomingAsymptote = 4
    # Target Vector Outgoing Asymptote - used for hyperbolic departure trajectories.
    eVAElementTypeTargetVectorOutgoingAsymptote = 5
    # Mixed Spherical.
    eVAElementTypeMixedSpherical = 6
    # Delaunay.
    eVAElementTypeDelaunay = 7
    # Equinoctial.
    eVAElementTypeEquinoctial = 8
    # Geodetic.
    eVAElementTypeGeodetic = 9
    # BPlane.
    eVAElementTypeBPlane = 10

AgEVAElementType.eVAElementTypeCartesian.__doc__ = "Cartesian - specifying an orbit by three position elements and three velocity elements in a rectangular coordinate system."
AgEVAElementType.eVAElementTypeKeplerian.__doc__ = "Keplerian - the classical system, specifying an orbit by six elements describing its size, shape and three-dimensional orientation in space."
AgEVAElementType.eVAElementTypeSpherical.__doc__ = "Spherical - a system in which positions are specified as a radial distance from the origin and two angles relative to a fundamental plane."
AgEVAElementType.eVAElementTypeTargetVectorIncomingAsymptote.__doc__ = "Target Vector Incoming Asymptote - used for hyperbolic arrival trajectories."
AgEVAElementType.eVAElementTypeTargetVectorOutgoingAsymptote.__doc__ = "Target Vector Outgoing Asymptote - used for hyperbolic departure trajectories."
AgEVAElementType.eVAElementTypeMixedSpherical.__doc__ = "Mixed Spherical."
AgEVAElementType.eVAElementTypeDelaunay.__doc__ = "Delaunay."
AgEVAElementType.eVAElementTypeEquinoctial.__doc__ = "Equinoctial."
AgEVAElementType.eVAElementTypeGeodetic.__doc__ = "Geodetic."
AgEVAElementType.eVAElementTypeBPlane.__doc__ = "BPlane."

agcls.AgTypeNameMap["AgEVAElementType"] = AgEVAElementType

class AgEVALanguage(IntEnum):
    """Scripting language types for the Scripting Tool."""
    # VBScript.
    eVALanguageVBScript = 0
    # JScript.
    eVALanguageJScript = 1
    # MATLAB.
    eVALanguageMATLAB = 2

AgEVALanguage.eVALanguageVBScript.__doc__ = "VBScript."
AgEVALanguage.eVALanguageJScript.__doc__ = "JScript."
AgEVALanguage.eVALanguageMATLAB.__doc__ = "MATLAB."

agcls.AgTypeNameMap["AgEVALanguage"] = AgEVALanguage

class AgEVAStoppingCondition(IntEnum):
    """Type of stopping condition."""
    # Basic Stopping Condition.
    eVAStoppingConditionBasic = 0
    # Before Stopping Condition.
    eVAStoppingConditionBefore = 1
    # One Point Access Stopping Condition.
    eVAStoppingConditionOnePtAccess = 2
    # Lighting Stopping Condition.
    eVAStoppingConditionLighting = 3

AgEVAStoppingCondition.eVAStoppingConditionBasic.__doc__ = "Basic Stopping Condition."
AgEVAStoppingCondition.eVAStoppingConditionBefore.__doc__ = "Before Stopping Condition."
AgEVAStoppingCondition.eVAStoppingConditionOnePtAccess.__doc__ = "One Point Access Stopping Condition."
AgEVAStoppingCondition.eVAStoppingConditionLighting.__doc__ = "Lighting Stopping Condition."

agcls.AgTypeNameMap["AgEVAStoppingCondition"] = AgEVAStoppingCondition

class AgEVAClearEphemerisDirection(IntEnum):
    """Direction in which to clear ephemeris."""
    # Clear ephemeris before selected time or state.
    eVAClearEphemerisBefore = -1
    # Do not clear ephemeris.
    eVAClearEphemerisNoClear = 0
    # Clear ephemeris after selected time or state.
    eVAClearEphemerisAfter = 1

AgEVAClearEphemerisDirection.eVAClearEphemerisBefore.__doc__ = "Clear ephemeris before selected time or state."
AgEVAClearEphemerisDirection.eVAClearEphemerisNoClear.__doc__ = "Do not clear ephemeris."
AgEVAClearEphemerisDirection.eVAClearEphemerisAfter.__doc__ = "Clear ephemeris after selected time or state."

agcls.AgTypeNameMap["AgEVAClearEphemerisDirection"] = AgEVAClearEphemerisDirection

class AgEVAProfileInsertDirection(IntEnum):
    """Direction to insert profile."""
    # Insert profile before reference profile.
    eVAProfileInsertBefore = 0
    # Insert profile after reference profile.
    eVAProfileInsertAfter = 1

AgEVAProfileInsertDirection.eVAProfileInsertBefore.__doc__ = "Insert profile before reference profile."
AgEVAProfileInsertDirection.eVAProfileInsertAfter.__doc__ = "Insert profile after reference profile."

agcls.AgTypeNameMap["AgEVAProfileInsertDirection"] = AgEVAProfileInsertDirection

class AgEVARootFindingAlgorithm(IntEnum):
    """Root-finding algorithms."""
    # Secant method.
    eVASecantMethod = 0
    # Newton-Raphson method.
    eVANewtonRaphsonMethod = 1

AgEVARootFindingAlgorithm.eVASecantMethod.__doc__ = "Secant method."
AgEVARootFindingAlgorithm.eVANewtonRaphsonMethod.__doc__ = "Newton-Raphson method."

agcls.AgTypeNameMap["AgEVARootFindingAlgorithm"] = AgEVARootFindingAlgorithm

class AgEVAScriptingParameterType(IntEnum):
    """Scripting Tool parameter type."""
    # Double.
    eVAScriptingParameterTypeDouble = 0
    # Quantity.
    eVAScriptingParameterTypeQuantity = 1
    # Date.
    eVAScriptingParameterTypeDate = 2
    # String.
    eVAScriptingParameterTypeString = 3
    # Boolean.
    eVAScriptingParameterTypeBoolean = 4
    # Integer.
    eVAScriptingParameterTypeInteger = 5
    # Enumeration.
    eVAScriptingParameterTypeEnumeration = 6

AgEVAScriptingParameterType.eVAScriptingParameterTypeDouble.__doc__ = "Double."
AgEVAScriptingParameterType.eVAScriptingParameterTypeQuantity.__doc__ = "Quantity."
AgEVAScriptingParameterType.eVAScriptingParameterTypeDate.__doc__ = "Date."
AgEVAScriptingParameterType.eVAScriptingParameterTypeString.__doc__ = "String."
AgEVAScriptingParameterType.eVAScriptingParameterTypeBoolean.__doc__ = "Boolean."
AgEVAScriptingParameterType.eVAScriptingParameterTypeInteger.__doc__ = "Integer."
AgEVAScriptingParameterType.eVAScriptingParameterTypeEnumeration.__doc__ = "Enumeration."

agcls.AgTypeNameMap["AgEVAScriptingParameterType"] = AgEVAScriptingParameterType

class AgEVASNOPTGoal(IntEnum):
    """The Goal types for a SNOPT profile."""
    # Minimize
    eVASNOPTGoalMinimize = 0
    # Bound
    eVASNOPTGoalBound = 1

AgEVASNOPTGoal.eVASNOPTGoalMinimize.__doc__ = "Minimize"
AgEVASNOPTGoal.eVASNOPTGoalBound.__doc__ = "Bound"

agcls.AgTypeNameMap["AgEVASNOPTGoal"] = AgEVASNOPTGoal

class AgEVAIPOPTGoal(IntEnum):
    """The Goal types for a IPOPT profile."""
    # Minimize
    eVAIPOPTGoalMinimize = 0
    # Bound
    eVAIPOPTGoalBound = 1

AgEVAIPOPTGoal.eVAIPOPTGoalMinimize.__doc__ = "Minimize"
AgEVAIPOPTGoal.eVAIPOPTGoalBound.__doc__ = "Bound"

agcls.AgTypeNameMap["AgEVAIPOPTGoal"] = AgEVAIPOPTGoal

class AgEVAOptimalFiniteSeedMethod(IntEnum):
    """Seed methods."""
    # Seed initial guess from file.
    eVAOptimalFiniteSeedMethodInitialGuessFile = 0
    # Seed initial guess from finite maneuver.
    eVAOptimalFiniteSeedMethodFiniteManeuver = 1

AgEVAOptimalFiniteSeedMethod.eVAOptimalFiniteSeedMethodInitialGuessFile.__doc__ = "Seed initial guess from file."
AgEVAOptimalFiniteSeedMethod.eVAOptimalFiniteSeedMethodFiniteManeuver.__doc__ = "Seed initial guess from finite maneuver."

agcls.AgTypeNameMap["AgEVAOptimalFiniteSeedMethod"] = AgEVAOptimalFiniteSeedMethod

class AgEVAOptimalFiniteRunMode(IntEnum):
    """Run modes."""
    # Run current nodes.
    eVAOptimalFiniteRunModeRunCurrentNodes = 0
    # Optimize via direct transcription.
    eVAOptimalFiniteRunModeOptimizeViaDirectTranscription = 1

AgEVAOptimalFiniteRunMode.eVAOptimalFiniteRunModeRunCurrentNodes.__doc__ = "Run current nodes."
AgEVAOptimalFiniteRunMode.eVAOptimalFiniteRunModeOptimizeViaDirectTranscription.__doc__ = "Optimize via direct transcription."

agcls.AgTypeNameMap["AgEVAOptimalFiniteRunMode"] = AgEVAOptimalFiniteRunMode

class AgEVAOptimalFiniteDiscretizationStrategy(IntEnum):
    """Discretization Strategy."""
    # The Legendre-Gauss-Lobatto quadrature rule
    eVAOptimalFiniteDiscretizationStrategyLegendreGaussLobatto = 0
    # The Legendre-Gauss-Radau quadrature rule.
    eVAOptimalFiniteDiscretizationStrategyLegendreGaussRadau = 1

AgEVAOptimalFiniteDiscretizationStrategy.eVAOptimalFiniteDiscretizationStrategyLegendreGaussLobatto.__doc__ = "The Legendre-Gauss-Lobatto quadrature rule"
AgEVAOptimalFiniteDiscretizationStrategy.eVAOptimalFiniteDiscretizationStrategyLegendreGaussRadau.__doc__ = "The Legendre-Gauss-Radau quadrature rule."

agcls.AgTypeNameMap["AgEVAOptimalFiniteDiscretizationStrategy"] = AgEVAOptimalFiniteDiscretizationStrategy

class AgEVAOptimalFiniteWorkingVariables(IntEnum):
    """Working Variables."""
    # Standard inertial equinoctial coordinates.
    eVAOptimalFiniteWorkingVariablesEquinoctial = 0
    # Use semi-latus rectum instead of SMA and true longitude instead of mean longitude.
    eVAOptimalFiniteWorkingVariablesModifiedEquinoctial = 1

AgEVAOptimalFiniteWorkingVariables.eVAOptimalFiniteWorkingVariablesEquinoctial.__doc__ = "Standard inertial equinoctial coordinates."
AgEVAOptimalFiniteWorkingVariables.eVAOptimalFiniteWorkingVariablesModifiedEquinoctial.__doc__ = "Use semi-latus rectum instead of SMA and true longitude instead of mean longitude."

agcls.AgTypeNameMap["AgEVAOptimalFiniteWorkingVariables"] = AgEVAOptimalFiniteWorkingVariables

class AgEVAOptimalFiniteScalingOptions(IntEnum):
    """Scaling Options."""
    # No scaling.
    eVAOptimalFiniteScalingOptionsNoScaling = 0
    # Scale based on canonical units.
    eVAOptimalFiniteScalingOptionsCanonicalUnits = 1
    # Scale based on the initial state.
    eVAOptimalFiniteScalingOptionsInitialStateBased = 2

AgEVAOptimalFiniteScalingOptions.eVAOptimalFiniteScalingOptionsNoScaling.__doc__ = "No scaling."
AgEVAOptimalFiniteScalingOptions.eVAOptimalFiniteScalingOptionsCanonicalUnits.__doc__ = "Scale based on canonical units."
AgEVAOptimalFiniteScalingOptions.eVAOptimalFiniteScalingOptionsInitialStateBased.__doc__ = "Scale based on the initial state."

agcls.AgTypeNameMap["AgEVAOptimalFiniteScalingOptions"] = AgEVAOptimalFiniteScalingOptions

class AgEVAOptimalFiniteSNOPTObjective(IntEnum):
    """Optimal Finite SNOPT objective."""
    # Minimize the total TOF along the collocation arc.
    eVAOptimalFiniteSNOPTObjectiveMinimizeTOF = 0
    # Minimize the total calculated DeltaV along the collocation arc.
    eVAOptimalFiniteSNOPTObjectiveMaximizeFinalRad = 1
    # Maximize the final mass after the collocation arc.
    eVAOptimalFiniteSNOPTObjectiveMinimizePropellantUse = 2

AgEVAOptimalFiniteSNOPTObjective.eVAOptimalFiniteSNOPTObjectiveMinimizeTOF.__doc__ = "Minimize the total TOF along the collocation arc."
AgEVAOptimalFiniteSNOPTObjective.eVAOptimalFiniteSNOPTObjectiveMaximizeFinalRad.__doc__ = "Minimize the total calculated DeltaV along the collocation arc."
AgEVAOptimalFiniteSNOPTObjective.eVAOptimalFiniteSNOPTObjectiveMinimizePropellantUse.__doc__ = "Maximize the final mass after the collocation arc."

agcls.AgTypeNameMap["AgEVAOptimalFiniteSNOPTObjective"] = AgEVAOptimalFiniteSNOPTObjective

class AgEVAOptimalFiniteSNOPTScaling(IntEnum):
    """Optimal Finite SNOPT scaling option."""
    # No scaling.
    eVAOptimalFiniteSNOPTScalingNone = 0
    # Scale linear constraints and variables.
    eVAOptimalFiniteSNOPTScalingLinear = 1
    # Scale all constraints and variables.
    eVAOptimalFiniteSNOPTScalingAll = 2

AgEVAOptimalFiniteSNOPTScaling.eVAOptimalFiniteSNOPTScalingNone.__doc__ = "No scaling."
AgEVAOptimalFiniteSNOPTScaling.eVAOptimalFiniteSNOPTScalingLinear.__doc__ = "Scale linear constraints and variables."
AgEVAOptimalFiniteSNOPTScaling.eVAOptimalFiniteSNOPTScalingAll.__doc__ = "Scale all constraints and variables."

agcls.AgTypeNameMap["AgEVAOptimalFiniteSNOPTScaling"] = AgEVAOptimalFiniteSNOPTScaling

class AgEVAOptimalFiniteExportNodesFormat(IntEnum):
    """Steering nodes export format."""
    # Export controls as Az/El = Ra/Dec angles.
    eVAOptimalFiniteExportNodesFormatAzimuthElevation = 0
    # Export controls as unit vectors = direction cosines.
    eVAOptimalFiniteExportNodesFormatUnitVector = 1

AgEVAOptimalFiniteExportNodesFormat.eVAOptimalFiniteExportNodesFormatAzimuthElevation.__doc__ = "Export controls as Az/El = Ra/Dec angles."
AgEVAOptimalFiniteExportNodesFormat.eVAOptimalFiniteExportNodesFormatUnitVector.__doc__ = "Export controls as unit vectors = direction cosines."

agcls.AgTypeNameMap["AgEVAOptimalFiniteExportNodesFormat"] = AgEVAOptimalFiniteExportNodesFormat

class AgEVAOptimalFiniteGuessMethod(IntEnum):
    """Guess interpolation method."""
    # Lagrange polynomial method.
    eVAOptimalFiniteGuessMethodLagrangePolynomial = 0
    # Piecewise linear method.
    eVAOptimalFiniteGuessMethodPiecewiseLinear = 1

AgEVAOptimalFiniteGuessMethod.eVAOptimalFiniteGuessMethodLagrangePolynomial.__doc__ = "Lagrange polynomial method."
AgEVAOptimalFiniteGuessMethod.eVAOptimalFiniteGuessMethodPiecewiseLinear.__doc__ = "Piecewise linear method."

agcls.AgTypeNameMap["AgEVAOptimalFiniteGuessMethod"] = AgEVAOptimalFiniteGuessMethod

class AgEVAImpDeltaVRep(IntEnum):
    """Vector representations for impulsive DeltaV specification"""
    # Cartesian - specify the impulsive DeltaV in Cartesian coordinates (X, Y, Z).
    eVACartesianImpDeltaV = 0
    # Spherical - specify the impulsive DeltaV in spherical coordinates (Azimuth, Elevation, Magnitude).
    eVASphericalImpDeltaV = 1

AgEVAImpDeltaVRep.eVACartesianImpDeltaV.__doc__ = "Cartesian - specify the impulsive DeltaV in Cartesian coordinates (X, Y, Z)."
AgEVAImpDeltaVRep.eVASphericalImpDeltaV.__doc__ = "Spherical - specify the impulsive DeltaV in spherical coordinates (Azimuth, Elevation, Magnitude)."

agcls.AgTypeNameMap["AgEVAImpDeltaVRep"] = AgEVAImpDeltaVRep

class AgEVALambertTargetCoordType(IntEnum):
    """Lambert Target CoordType."""
    # Cartesian - specifying an orbit by three position elements and three velocity elements in a rectangular coordinate system.
    eVALambertTargetCoordTypeCartesian = 0
    # Keplerian - the classical system, specifying an orbit by six elements describing its size, shape and three-dimensional orientation in space.
    eVALambertTargetCoordTypeKeplerian = 1

AgEVALambertTargetCoordType.eVALambertTargetCoordTypeCartesian.__doc__ = "Cartesian - specifying an orbit by three position elements and three velocity elements in a rectangular coordinate system."
AgEVALambertTargetCoordType.eVALambertTargetCoordTypeKeplerian.__doc__ = "Keplerian - the classical system, specifying an orbit by six elements describing its size, shape and three-dimensional orientation in space."

agcls.AgTypeNameMap["AgEVALambertTargetCoordType"] = AgEVALambertTargetCoordType

class AgEVALambertSolutionOptionType(IntEnum):
    """Lambert Solution Option Type."""
    # Fixed time - The type of Lambert solution to calculate.
    eAgEVALambertSolutionOptionFixedTime = 0
    # Minimum Eccentricity - The type of Lambert solution to calculate.
    eAgEVALambertSolutionOptionMinEccentricity = 1
    # Minimum Energy - The type of Lambert solution to calculate.
    eAgEVALambertSolutionOptionMinEnergy = 2

AgEVALambertSolutionOptionType.eAgEVALambertSolutionOptionFixedTime.__doc__ = "Fixed time - The type of Lambert solution to calculate."
AgEVALambertSolutionOptionType.eAgEVALambertSolutionOptionMinEccentricity.__doc__ = "Minimum Eccentricity - The type of Lambert solution to calculate."
AgEVALambertSolutionOptionType.eAgEVALambertSolutionOptionMinEnergy.__doc__ = "Minimum Energy - The type of Lambert solution to calculate."

agcls.AgTypeNameMap["AgEVALambertSolutionOptionType"] = AgEVALambertSolutionOptionType

class AgEVALambertOrbitalEnergyType(IntEnum):
    """Lambert Orbital Energy Type."""
    # Low energy- This is the orbital energy for the Lambert solution that corresponds to the smaller semimajor axis solution.
    eAgEVALambertOrbitalEnergyLow = 0
    # High energy- This is the orbital energy for the Lambert solution that corresponds to the larger semimajor axis solution.
    eAgEVALambertOrbitalEnergyHigh = 1

AgEVALambertOrbitalEnergyType.eAgEVALambertOrbitalEnergyLow.__doc__ = "Low energy- This is the orbital energy for the Lambert solution that corresponds to the smaller semimajor axis solution."
AgEVALambertOrbitalEnergyType.eAgEVALambertOrbitalEnergyHigh.__doc__ = "High energy- This is the orbital energy for the Lambert solution that corresponds to the larger semimajor axis solution."

agcls.AgTypeNameMap["AgEVALambertOrbitalEnergyType"] = AgEVALambertOrbitalEnergyType

class AgEVALambertDirectionOfMotionType(IntEnum):
    """Lambert Direction Of Motion Type."""
    # The short direction of motion for the Lambert solution.
    eAgEVALambertDirectionOfMotionShort = 0
    # The long direction of motion for the Lambert solution.
    eAgEVALambertDirectionOfMotionLong = 1

AgEVALambertDirectionOfMotionType.eAgEVALambertDirectionOfMotionShort.__doc__ = "The short direction of motion for the Lambert solution."
AgEVALambertDirectionOfMotionType.eAgEVALambertDirectionOfMotionLong.__doc__ = "The long direction of motion for the Lambert solution."

agcls.AgTypeNameMap["AgEVALambertDirectionOfMotionType"] = AgEVALambertDirectionOfMotionType

class AgEVAGoldenSectionDesiredOperation(IntEnum):
    """The types for Desired Operation/Objective of golden section profile."""
    # Minimize value
    eVAGoldenSectionDesiredOpMinimizeValue = 0
    # Maximize value
    eVAGoldenSectionDesiredOpMaximizeValue = 1

AgEVAGoldenSectionDesiredOperation.eVAGoldenSectionDesiredOpMinimizeValue.__doc__ = "Minimize value"
AgEVAGoldenSectionDesiredOperation.eVAGoldenSectionDesiredOpMaximizeValue.__doc__ = "Maximize value"

agcls.AgTypeNameMap["AgEVAGoldenSectionDesiredOperation"] = AgEVAGoldenSectionDesiredOperation

class AgEVAGridSearchDesiredOperation(IntEnum):
    """The types for Desired Operation/Objective of Grid Search profile."""
    # Minimize value
    eVAGridSearchDesiredOpMinimizeValue = 0
    # Maximize value
    eVAGridSearchDesiredOpMaximizeValue = 1

AgEVAGridSearchDesiredOperation.eVAGridSearchDesiredOpMinimizeValue.__doc__ = "Minimize value"
AgEVAGridSearchDesiredOperation.eVAGridSearchDesiredOpMaximizeValue.__doc__ = "Maximize value"

agcls.AgTypeNameMap["AgEVAGridSearchDesiredOperation"] = AgEVAGridSearchDesiredOperation

class AgEVAElement(IntEnum):
    """Which type of elements (osculating or mean)"""
    # Osculating.
    eVAElementOsculating = 0
    # Kozai-Izsak Mean.
    eVAElementKozaiIzsakMean = 1
    # Brouwer-Lyddane Mean Long.
    eVAElementBrouwerLyddaneMeanLong = 2
    # Brouwer-Lyddane Mean Short.
    eVAElementBrouwerLyddaneMeanShort = 3

AgEVAElement.eVAElementOsculating.__doc__ = "Osculating."
AgEVAElement.eVAElementKozaiIzsakMean.__doc__ = "Kozai-Izsak Mean."
AgEVAElement.eVAElementBrouwerLyddaneMeanLong.__doc__ = "Brouwer-Lyddane Mean Long."
AgEVAElement.eVAElementBrouwerLyddaneMeanShort.__doc__ = "Brouwer-Lyddane Mean Short."

agcls.AgTypeNameMap["AgEVAElement"] = AgEVAElement

class AgEVABaseSelection(IntEnum):
    """Access base object selections types."""
    # An object in the current scenario.
    eVABaseSelectionSpecify = 0
    # The current satellite.
    eVABaseSelectionCurrentSatellite = 1

AgEVABaseSelection.eVABaseSelectionSpecify.__doc__ = "An object in the current scenario."
AgEVABaseSelection.eVABaseSelectionCurrentSatellite.__doc__ = "The current satellite."

agcls.AgTypeNameMap["AgEVABaseSelection"] = AgEVABaseSelection

class AgEVAControlOrbitStateValue(IntEnum):
    """Orbit State Value properties that can be selected as control parameters for a Target Sequence."""
    # The Vx velocity component of the orbit state.
    eVAControlOrbitStateValueVx = 0
    # The Vy velocity component of the orbit state.
    eVAControlOrbitStateValueVy = 1
    # The Vz velocity component of the orbit state.
    eVAControlOrbitStateValueVz = 2
    # The x position component of the orbit state.
    eVAControlOrbitStateValueX = 3
    # The y position component of the orbit state.
    eVAControlOrbitStateValueY = 4
    # The z position component of the orbit state.
    eVAControlOrbitStateValueZ = 5

AgEVAControlOrbitStateValue.eVAControlOrbitStateValueVx.__doc__ = "The Vx velocity component of the orbit state."
AgEVAControlOrbitStateValue.eVAControlOrbitStateValueVy.__doc__ = "The Vy velocity component of the orbit state."
AgEVAControlOrbitStateValue.eVAControlOrbitStateValueVz.__doc__ = "The Vz velocity component of the orbit state."
AgEVAControlOrbitStateValue.eVAControlOrbitStateValueX.__doc__ = "The x position component of the orbit state."
AgEVAControlOrbitStateValue.eVAControlOrbitStateValueY.__doc__ = "The y position component of the orbit state."
AgEVAControlOrbitStateValue.eVAControlOrbitStateValueZ.__doc__ = "The z position component of the orbit state."

agcls.AgTypeNameMap["AgEVAControlOrbitStateValue"] = AgEVAControlOrbitStateValue

class AgEVASegmentState(IntEnum):
    """Segment state to use types."""
    # The segment initial state.
    eVASegmentStateInitial = 0
    # The segment final state.
    eVASegmentStateFinal = 1

AgEVASegmentState.eVASegmentStateInitial.__doc__ = "The segment initial state."
AgEVASegmentState.eVASegmentStateFinal.__doc__ = "The segment final state."

agcls.AgTypeNameMap["AgEVASegmentState"] = AgEVASegmentState

class AgEVADifferenceOrder(IntEnum):
    """The Difference order types."""
    # The initial minus current difference.
    eVADifferenceOrderInitialMinusCurrent = 0
    # The current minus initial difference.
    eVADifferenceOrderCurrentMinusInitial = 1

AgEVADifferenceOrder.eVADifferenceOrderInitialMinusCurrent.__doc__ = "The initial minus current difference."
AgEVADifferenceOrder.eVADifferenceOrderCurrentMinusInitial.__doc__ = "The current minus initial difference."

agcls.AgTypeNameMap["AgEVADifferenceOrder"] = AgEVADifferenceOrder

class AgEVASegmentDifferenceOrder(IntEnum):
    """The Difference Across Segments order types."""
    # The current minus segment difference.
    eVASegmentDifferenceOrderCurrentMinusSegment = 0
    # The segment minus current difference.
    eVASegmentDifferenceOrderSegmentMinusCurrent = 1

AgEVASegmentDifferenceOrder.eVASegmentDifferenceOrderCurrentMinusSegment.__doc__ = "The current minus segment difference."
AgEVASegmentDifferenceOrder.eVASegmentDifferenceOrderSegmentMinusCurrent.__doc__ = "The segment minus current difference."

agcls.AgTypeNameMap["AgEVASegmentDifferenceOrder"] = AgEVASegmentDifferenceOrder

class AgEVAControlRepeatingGroundTrackErr(IntEnum):
    """Repeating Ground Track Equator Error properties that can be selected as control parameters for a Target Sequence."""
    # The reference longitude.
    eVAControlRepeatingGroundTrackErrRefLon = 0
    # The repeat count.
    eVAControlRepeatingGroundTrackErrRepeatCount = 1

AgEVAControlRepeatingGroundTrackErr.eVAControlRepeatingGroundTrackErrRefLon.__doc__ = "The reference longitude."
AgEVAControlRepeatingGroundTrackErr.eVAControlRepeatingGroundTrackErrRepeatCount.__doc__ = "The repeat count."

agcls.AgTypeNameMap["AgEVAControlRepeatingGroundTrackErr"] = AgEVAControlRepeatingGroundTrackErr

class AgEVACalcObjectDirection(IntEnum):
    """The direction to search for a desired value."""
    # Search in the direction of the next calculation object.
    eVACalcObjectDirectionNext = 0
    # Search in the direction of the previous calculation object.
    eVACalcObjectDirectionPrevious = 1

AgEVACalcObjectDirection.eVACalcObjectDirectionNext.__doc__ = "Search in the direction of the next calculation object."
AgEVACalcObjectDirection.eVACalcObjectDirectionPrevious.__doc__ = "Search in the direction of the previous calculation object."

agcls.AgTypeNameMap["AgEVACalcObjectDirection"] = AgEVACalcObjectDirection

class AgEVACalcObjectOrbitPlaneSource(IntEnum):
    """The calculation object orbit plane source Types."""
    # Use the reference satellite to generate the orbit plane.
    eAgEVACalcObjectOrbitPlaneSourceReferenceSatellite = 0
    # Use the satellite to generate the orbit plane.
    eAgEVACalcObjectOrbitPlaneSourceSatellite = 1

AgEVACalcObjectOrbitPlaneSource.eAgEVACalcObjectOrbitPlaneSourceReferenceSatellite.__doc__ = "Use the reference satellite to generate the orbit plane."
AgEVACalcObjectOrbitPlaneSource.eAgEVACalcObjectOrbitPlaneSourceSatellite.__doc__ = "Use the satellite to generate the orbit plane."

agcls.AgTypeNameMap["AgEVACalcObjectOrbitPlaneSource"] = AgEVACalcObjectOrbitPlaneSource

class AgEVACalcObjectSunPosition(IntEnum):
    """The calculation object sun location Types."""
    # Use the sun location apparent from satellite.
    eAgEVACalcObjectSunPositionApparentFromSatellite = 0
    # Use the sun location apparent from reference satellite.
    eAgEVACalcObjectSunPositionApparentFromRefSatellite = 1
    # Use the sun location true from satellite.
    eAgEVACalcObjectSunPositionTrueFromSatellite = 2
    # Use the sun location true from reference satellite.
    eAgEVACalcObjectSunPositionTrueFromRefSatellite = 3

AgEVACalcObjectSunPosition.eAgEVACalcObjectSunPositionApparentFromSatellite.__doc__ = "Use the sun location apparent from satellite."
AgEVACalcObjectSunPosition.eAgEVACalcObjectSunPositionApparentFromRefSatellite.__doc__ = "Use the sun location apparent from reference satellite."
AgEVACalcObjectSunPosition.eAgEVACalcObjectSunPositionTrueFromSatellite.__doc__ = "Use the sun location true from satellite."
AgEVACalcObjectSunPosition.eAgEVACalcObjectSunPositionTrueFromRefSatellite.__doc__ = "Use the sun location true from reference satellite."

agcls.AgTypeNameMap["AgEVACalcObjectSunPosition"] = AgEVACalcObjectSunPosition

class AgEVACalcObjectAngleSign(IntEnum):
    """The sign of the angle when the relative position has a component along the orbit normal."""
    # Use the positive sign for the angle when the relative position has a positive component along the orbit normal.
    eAgEVACalcObjectAngleSignPositive = 0
    # Use the negative sign for the angle when the relative position does not have a positive component along the orbit normal.
    eAgEVACalcObjectAngleSignNegative = 1

AgEVACalcObjectAngleSign.eAgEVACalcObjectAngleSignPositive.__doc__ = "Use the positive sign for the angle when the relative position has a positive component along the orbit normal."
AgEVACalcObjectAngleSign.eAgEVACalcObjectAngleSignNegative.__doc__ = "Use the negative sign for the angle when the relative position does not have a positive component along the orbit normal."

agcls.AgTypeNameMap["AgEVACalcObjectAngleSign"] = AgEVACalcObjectAngleSign

class AgEVACalcObjectReferenceDirection(IntEnum):
    """Direction that establishes the zero value when projected into the orbit plane."""
    # Use the reference satellite position when projected into the orbit plane.
    eAgEVACalcObjectReferenceDirectionReferenceSatellitePosition = 0
    # Use the satellite position when projected into the orbit plane.
    eAgEVACalcObjectReferenceDirectionSatellitePosition = 1
    # Use the reference satellite nadir (centric) when projected into the orbit plane.
    eAgEVACalcObjectReferenceDirectionReferenceSatelliteNadir = 2
    # Use the satellite nadir (centric) position when projected into the orbit plane.
    eAgEVACalcObjectReferenceDirectionSatelliteNadir = 3

AgEVACalcObjectReferenceDirection.eAgEVACalcObjectReferenceDirectionReferenceSatellitePosition.__doc__ = "Use the reference satellite position when projected into the orbit plane."
AgEVACalcObjectReferenceDirection.eAgEVACalcObjectReferenceDirectionSatellitePosition.__doc__ = "Use the satellite position when projected into the orbit plane."
AgEVACalcObjectReferenceDirection.eAgEVACalcObjectReferenceDirectionReferenceSatelliteNadir.__doc__ = "Use the reference satellite nadir (centric) when projected into the orbit plane."
AgEVACalcObjectReferenceDirection.eAgEVACalcObjectReferenceDirectionSatelliteNadir.__doc__ = "Use the satellite nadir (centric) position when projected into the orbit plane."

agcls.AgTypeNameMap["AgEVACalcObjectReferenceDirection"] = AgEVACalcObjectReferenceDirection

class AgEVACalcObjectRelativePosition(IntEnum):
    """The calculation object relative position Types."""
    # Use the relative position satellite to reference satellite.
    eAgEVACalcObjectRelativePositionSatelliteToRefSatellite = 0
    # Use the relative position reference satellite to satellite.
    eAgEVACalcObjectRelativePositionRefSatelliteToSatellite = 1

AgEVACalcObjectRelativePosition.eAgEVACalcObjectRelativePositionSatelliteToRefSatellite.__doc__ = "Use the relative position satellite to reference satellite."
AgEVACalcObjectRelativePosition.eAgEVACalcObjectRelativePositionRefSatelliteToSatellite.__doc__ = "Use the relative position reference satellite to satellite."

agcls.AgTypeNameMap["AgEVACalcObjectRelativePosition"] = AgEVACalcObjectRelativePosition

class AgEVACalcObjectReferenceEllipse(IntEnum):
    """The calculation object reference ellipse Types."""
    # Use the reference satellite orbit.
    eAgEVACalcObjectReferenceEllipseRefSatOrbit = 0
    # Use the satellite orbit.
    eAgEVACalcObjectReferenceEllipseSatelliteOrbit = 1

AgEVACalcObjectReferenceEllipse.eAgEVACalcObjectReferenceEllipseRefSatOrbit.__doc__ = "Use the reference satellite orbit."
AgEVACalcObjectReferenceEllipse.eAgEVACalcObjectReferenceEllipseSatelliteOrbit.__doc__ = "Use the satellite orbit."

agcls.AgTypeNameMap["AgEVACalcObjectReferenceEllipse"] = AgEVACalcObjectReferenceEllipse

class AgEVACalcObjectLocationSource(IntEnum):
    """The calculation object location source Types."""
    # Use the reference satellite.
    eAgEVACalcObjectLocationSourceRefSat = 0
    # Use the satellite.
    eAgEVACalcObjectLocationSourceSatellite = 1

AgEVACalcObjectLocationSource.eAgEVACalcObjectLocationSourceRefSat.__doc__ = "Use the reference satellite."
AgEVACalcObjectLocationSource.eAgEVACalcObjectLocationSourceSatellite.__doc__ = "Use the satellite."

agcls.AgTypeNameMap["AgEVACalcObjectLocationSource"] = AgEVACalcObjectLocationSource

class AgEVAGravitationalParameterSource(IntEnum):
    """The source of the gravitational parameter for a CAgVAStateCalcGravitationalParameter calculation object."""
    # Cb File.
    eVAGravitationalParameterSourceCbFile = 0
    # Cb File -  System.
    eVAGravitationalParameterSourceCbFileSystem = 1
    # DE File.
    eVAGravitationalParameterSourceDEFile = 2
    # Gravity File.
    eVAGravitationalParameterSourceGravityFile = 3

AgEVAGravitationalParameterSource.eVAGravitationalParameterSourceCbFile.__doc__ = "Cb File."
AgEVAGravitationalParameterSource.eVAGravitationalParameterSourceCbFileSystem.__doc__ = "Cb File -  System."
AgEVAGravitationalParameterSource.eVAGravitationalParameterSourceDEFile.__doc__ = "DE File."
AgEVAGravitationalParameterSource.eVAGravitationalParameterSourceGravityFile.__doc__ = "Gravity File."

agcls.AgTypeNameMap["AgEVAGravitationalParameterSource"] = AgEVAGravitationalParameterSource

class AgEVAReferenceRadiusSource(IntEnum):
    """The source of the reference radius for a CAgVAStateCalcReferenceRadius calculation object."""
    # Cb File.
    eVAReferenceRadiusSourceCbFile = 0
    # Gravity File.
    eVAReferenceRadiusSourceGravityFile = 1

AgEVAReferenceRadiusSource.eVAReferenceRadiusSourceCbFile.__doc__ = "Cb File."
AgEVAReferenceRadiusSource.eVAReferenceRadiusSourceGravityFile.__doc__ = "Gravity File."

agcls.AgTypeNameMap["AgEVAReferenceRadiusSource"] = AgEVAReferenceRadiusSource

class AgEVAGravCoeffNormalizationType(IntEnum):
    """The normalization type for the CAgVAStateCalcGravCoeff calculation object."""
    # Normalized.
    eVAGravCoeffNormalized = 0
    # Unnormalized.
    eVAGravCoeffUnnormalized = 1

AgEVAGravCoeffNormalizationType.eVAGravCoeffNormalized.__doc__ = "Normalized."
AgEVAGravCoeffNormalizationType.eVAGravCoeffUnnormalized.__doc__ = "Unnormalized."

agcls.AgTypeNameMap["AgEVAGravCoeffNormalizationType"] = AgEVAGravCoeffNormalizationType

class AgEVAGravCoeffCoefficientType(IntEnum):
    """The coefficient type for the CAgVAStateCalcGravCoeff calculation object."""
    # Zonal.
    eVAGravCoeffCoefficientTypeZonal = 0
    # Cosine.
    eVAGravCoeffCoefficientTypeCosine = 1
    # Sine.
    eVAGravCoeffCoefficientTypeSine = 2

AgEVAGravCoeffCoefficientType.eVAGravCoeffCoefficientTypeZonal.__doc__ = "Zonal."
AgEVAGravCoeffCoefficientType.eVAGravCoeffCoefficientTypeCosine.__doc__ = "Cosine."
AgEVAGravCoeffCoefficientType.eVAGravCoeffCoefficientTypeSine.__doc__ = "Sine."

agcls.AgTypeNameMap["AgEVAGravCoeffCoefficientType"] = AgEVAGravCoeffCoefficientType

class AgEVASTMPertVariables(IntEnum):
    """The initial and final Cartesian variational variables that describe an STM element."""
    # Designates the initial or final variation in the 'x' component of position.
    eVASTMPertVariablePosX = 0
    # Designates the initial or final variation in the 'y' component of position.
    eVASTMPertVariablePosY = 1
    # Designates the initial or final variation in the 'z' component of position.
    eVASTMPertVariablePosZ = 2
    # Designates the initial or final variation in the 'x' component of velocity.
    eVASTMPertVariableVelX = 3
    # Designates the initial or final variation in the 'y' component of velocity.
    eVASTMPertVariableVelY = 4
    # Designates the initial or final variation in the 'z' component of velocity.
    eVASTMPertVariableVelZ = 5

AgEVASTMPertVariables.eVASTMPertVariablePosX.__doc__ = "Designates the initial or final variation in the 'x' component of position."
AgEVASTMPertVariables.eVASTMPertVariablePosY.__doc__ = "Designates the initial or final variation in the 'y' component of position."
AgEVASTMPertVariables.eVASTMPertVariablePosZ.__doc__ = "Designates the initial or final variation in the 'z' component of position."
AgEVASTMPertVariables.eVASTMPertVariableVelX.__doc__ = "Designates the initial or final variation in the 'x' component of velocity."
AgEVASTMPertVariables.eVASTMPertVariableVelY.__doc__ = "Designates the initial or final variation in the 'y' component of velocity."
AgEVASTMPertVariables.eVASTMPertVariableVelZ.__doc__ = "Designates the initial or final variation in the 'z' component of velocity."

agcls.AgTypeNameMap["AgEVASTMPertVariables"] = AgEVASTMPertVariables

class AgEVASTMEigenNumber(IntEnum):
    """The number that describes one of the 6 STM Eigenvalues or Eigenvectors."""
    # Designates the first Eigenvalue or Eigenvector.
    eVASTMEigenNumber1 = 0
    # Designates the second Eigenvalue or Eigenvector.
    eVASTMEigenNumber2 = 1
    # Designates the third Eigenvalue or Eigenvector.
    eVASTMEigenNumber3 = 2
    # Designates the fourth Eigenvalue or Eigenvector.
    eVASTMEigenNumber4 = 3
    # Designates the fifth Eigenvalue or Eigenvector.
    eVASTMEigenNumber5 = 4
    # Designates the sixth Eigenvalue or Eigenvector.
    eVASTMEigenNumber6 = 5

AgEVASTMEigenNumber.eVASTMEigenNumber1.__doc__ = "Designates the first Eigenvalue or Eigenvector."
AgEVASTMEigenNumber.eVASTMEigenNumber2.__doc__ = "Designates the second Eigenvalue or Eigenvector."
AgEVASTMEigenNumber.eVASTMEigenNumber3.__doc__ = "Designates the third Eigenvalue or Eigenvector."
AgEVASTMEigenNumber.eVASTMEigenNumber4.__doc__ = "Designates the fourth Eigenvalue or Eigenvector."
AgEVASTMEigenNumber.eVASTMEigenNumber5.__doc__ = "Designates the fifth Eigenvalue or Eigenvector."
AgEVASTMEigenNumber.eVASTMEigenNumber6.__doc__ = "Designates the sixth Eigenvalue or Eigenvector."

agcls.AgTypeNameMap["AgEVASTMEigenNumber"] = AgEVASTMEigenNumber

class AgEVAComplexNumber(IntEnum):
    """Whether a value represents the real or imaginary portion of a number."""
    # Designates the value as the real part.
    eVAComplexNumberReal = 0
    # Designates the value as the imaginary part.
    eVAComplexNumberImaginary = 1

AgEVAComplexNumber.eVAComplexNumberReal.__doc__ = "Designates the value as the real part."
AgEVAComplexNumber.eVAComplexNumberImaginary.__doc__ = "Designates the value as the imaginary part."

agcls.AgTypeNameMap["AgEVAComplexNumber"] = AgEVAComplexNumber

class AgEVASquaredType(IntEnum):
    """Whether to calculate the value as the square of the sum of each component or the sum of the squares."""
    # Designates the calculation to be the sum of the squares.
    eVASumOfSquares = 0
    # Designates the calculation to be the square of the sum.
    eVASquareOfSum = 1

AgEVASquaredType.eVASumOfSquares.__doc__ = "Designates the calculation to be the sum of the squares."
AgEVASquaredType.eVASquareOfSum.__doc__ = "Designates the calculation to be the square of the sum."

agcls.AgTypeNameMap["AgEVASquaredType"] = AgEVASquaredType

class AgEVACbGravityModel(IntEnum):
    """The gravity model."""
    # ZonalsToJ4 - (various) Gravity model for all central bodies except Sun, Earth and Moon.
    eVACbGravityModelZonalsToJ4 = 0
    # Earth Simple gravity model.
    eVACbGravityModelEarthSimple = 1
    # WGS84 - (Earth) World Geodetic System 1984; WGS 84 was created by the Defense Mapping Agency (DMA).
    eVACbGravityModelWGS84 = 2
    # EGM96 - (Earth) Earth Gravity Model 1996, a geopotential model of the Earth consisting of spherical harmonic coefficients complete to degree and order 360. Developed jointly by NGA (formerly known as NIMA), NASA Goddard and Ohio State University.
    eVACbGravityModelEGM96 = 3
    # GEMT1 - (Earth) Goddard Earth Model T1.
    eVACbGravityModelGEMT1 = 4
    # JGM2 - (Earth) Joint Gravity Model version 2, a model that describes the Earth gravity field up to degree and order 70, developed by NASA/GSFC Space Geodesy Branch, the University of Texas Center for Space Research and CNES.
    eVACbGravityModelJGM2 = 5
    # JGM3 - (Earth) Joint Gravity Model version 3, a model that describes the Earth gravity field up to degree and order 70, developed by the University of Texas and NASA/GSFC.
    eVACbGravityModelJGM3 = 6
    # WGS84 EGM96 - (Earth) Uses the coefficients from EGM96 with the shape model of WGS84. This model is the recommended gravity model of the WGS84 definition document: NIMA TR8350.2, Third Edition, 4 July 1997.
    eVACbGravityModelWSG84EGM96 = 7
    # WGS84 old - (Earth) Old version of WGS84.
    eVACbGravityModelWGS84Old = 8
    # GLGM2 - (Moon) GM = 4.9028029535968e+12, reference distance = 1,738,000 m.
    eVACbGravityModelGLGM2 = 9
    # LP165P - (Moon) GM = 4.902801056E+12, reference distance = 1,738,000.0 m.
    eVACbGravityModelLP165P = 10
    # Icarus1987 - (Mercury) GM = 2.203209e+013, reference distance = 2,439,000 m. Reference: Anderson, J. J., Colombo, G., Esposito, P. B., Lau E. L., and Trager, G. B. 'The Mass, Gravity Field, and Ephemeris of Mercury', Icarus 71, 337-349, 1987.
    eVACbGravityModelIcarus1987 = 11
    # MGNP180U - (Venus) GM = 3.248585920790000E+14, reference distance = 6,051,000.0 m.
    eVACbGravityModelMGNP180U = 12
    # GMM1 - (Mars) GM = 4.28283579647735e+13, reference distance = 3,394,200.0 m.
    eVACbGravityModelGMM1 = 13
    # GMM2B - (Mars) GM = 4.28283719012840e+13, reference distance = 3,397,000 m. Reference: These numbers came from the GMM-2B model published at http://bowie.gsfc.nasa.gov/926/MARS/GMM2B.html and submitted to Journal of Geophysics Research, November 2000.
    eVACbGravityModelGMM2B = 14
    # Mars50c - (Mars) GM = 4.2828370371000e+13, reference distance = 3,394,200 m.
    eVACbGravityModelMars50c = 15
    # JUP230 - (Jupiter) GM = 1.26686535e+017, reference distance = 71,492,000 m. Reference: Jacobson, R. A. The JUP230 orbit solution, 2003.
    eVACbGravityModelJUP230 = 16
    # Astron2004 - (Saturn) GM = 3.7931284e+016, reference distance = 60,330,000 m.
    eVACbGravityModelAstron2004 = 17
    # AstronAstro1991 - (Neptune) GM = 6.835107e+015, reference distance = 25,225,000 m.
    eVACbGravityModelAstronAstro1991 = 18
    # Icarus2001 - (Callisto) GM = 7.179292e+12, reference distance = 2,410,300 m.
    eVACbGravityModelIcarus2001 = 19
    # Science1998 - (Europa) GM =3.20272e+012, reference distance = 1,565,000 m.
    eVACbGravityModelScience1998 = 20
    # Nature1996 - (Ganymede) GM = 9.8866e+12, reference distance = 2,634,000 m.
    eVACbGravityModelNature1996 = 21
    # JGeoRes2001 - (Io) GM = 5.96e+12, reference distance = 1,821,600 m.
    eVACbGravityModelJGeoRes2001 = 22
    # GGM01C - (Earth)
    eVACbGravityModelGGM01C = 23
    # GGM02C - (Earth)
    eVACbGravityModelGGM02C = 24
    # WGS72 ZonalsToJ4 - (Earth)
    eVACbGravityModelWGS72ZonalsToJ4 = 25
    # LP100J - (Moon)
    eVACbGravityModelLP100J = 26
    # LP100K - (Moon)
    eVACbGravityModelLP100K = 27
    # LP150Q - (Moon)
    eVACbGravityModelLP150Q = 28
    # LP75G - (Moon)
    eVACbGravityModelLP75G = 29

AgEVACbGravityModel.eVACbGravityModelZonalsToJ4.__doc__ = "ZonalsToJ4 - (various) Gravity model for all central bodies except Sun, Earth and Moon."
AgEVACbGravityModel.eVACbGravityModelEarthSimple.__doc__ = "Earth Simple gravity model."
AgEVACbGravityModel.eVACbGravityModelWGS84.__doc__ = "WGS84 - (Earth) World Geodetic System 1984; WGS 84 was created by the Defense Mapping Agency (DMA)."
AgEVACbGravityModel.eVACbGravityModelEGM96.__doc__ = "EGM96 - (Earth) Earth Gravity Model 1996, a geopotential model of the Earth consisting of spherical harmonic coefficients complete to degree and order 360. Developed jointly by NGA (formerly known as NIMA), NASA Goddard and Ohio State University."
AgEVACbGravityModel.eVACbGravityModelGEMT1.__doc__ = "GEMT1 - (Earth) Goddard Earth Model T1."
AgEVACbGravityModel.eVACbGravityModelJGM2.__doc__ = "JGM2 - (Earth) Joint Gravity Model version 2, a model that describes the Earth gravity field up to degree and order 70, developed by NASA/GSFC Space Geodesy Branch, the University of Texas Center for Space Research and CNES."
AgEVACbGravityModel.eVACbGravityModelJGM3.__doc__ = "JGM3 - (Earth) Joint Gravity Model version 3, a model that describes the Earth gravity field up to degree and order 70, developed by the University of Texas and NASA/GSFC."
AgEVACbGravityModel.eVACbGravityModelWSG84EGM96.__doc__ = "WGS84 EGM96 - (Earth) Uses the coefficients from EGM96 with the shape model of WGS84. This model is the recommended gravity model of the WGS84 definition document: NIMA TR8350.2, Third Edition, 4 July 1997."
AgEVACbGravityModel.eVACbGravityModelWGS84Old.__doc__ = "WGS84 old - (Earth) Old version of WGS84."
AgEVACbGravityModel.eVACbGravityModelGLGM2.__doc__ = "GLGM2 - (Moon) GM = 4.9028029535968e+12, reference distance = 1,738,000 m."
AgEVACbGravityModel.eVACbGravityModelLP165P.__doc__ = "LP165P - (Moon) GM = 4.902801056E+12, reference distance = 1,738,000.0 m."
AgEVACbGravityModel.eVACbGravityModelIcarus1987.__doc__ = "Icarus1987 - (Mercury) GM = 2.203209e+013, reference distance = 2,439,000 m. Reference: Anderson, J. J., Colombo, G., Esposito, P. B., Lau E. L., and Trager, G. B. 'The Mass, Gravity Field, and Ephemeris of Mercury', Icarus 71, 337-349, 1987."
AgEVACbGravityModel.eVACbGravityModelMGNP180U.__doc__ = "MGNP180U - (Venus) GM = 3.248585920790000E+14, reference distance = 6,051,000.0 m."
AgEVACbGravityModel.eVACbGravityModelGMM1.__doc__ = "GMM1 - (Mars) GM = 4.28283579647735e+13, reference distance = 3,394,200.0 m."
AgEVACbGravityModel.eVACbGravityModelGMM2B.__doc__ = "GMM2B - (Mars) GM = 4.28283719012840e+13, reference distance = 3,397,000 m. Reference: These numbers came from the GMM-2B model published at http://bowie.gsfc.nasa.gov/926/MARS/GMM2B.html and submitted to Journal of Geophysics Research, November 2000."
AgEVACbGravityModel.eVACbGravityModelMars50c.__doc__ = "Mars50c - (Mars) GM = 4.2828370371000e+13, reference distance = 3,394,200 m."
AgEVACbGravityModel.eVACbGravityModelJUP230.__doc__ = "JUP230 - (Jupiter) GM = 1.26686535e+017, reference distance = 71,492,000 m. Reference: Jacobson, R. A. The JUP230 orbit solution, 2003."
AgEVACbGravityModel.eVACbGravityModelAstron2004.__doc__ = "Astron2004 - (Saturn) GM = 3.7931284e+016, reference distance = 60,330,000 m."
AgEVACbGravityModel.eVACbGravityModelAstronAstro1991.__doc__ = "AstronAstro1991 - (Neptune) GM = 6.835107e+015, reference distance = 25,225,000 m."
AgEVACbGravityModel.eVACbGravityModelIcarus2001.__doc__ = "Icarus2001 - (Callisto) GM = 7.179292e+12, reference distance = 2,410,300 m."
AgEVACbGravityModel.eVACbGravityModelScience1998.__doc__ = "Science1998 - (Europa) GM =3.20272e+012, reference distance = 1,565,000 m."
AgEVACbGravityModel.eVACbGravityModelNature1996.__doc__ = "Nature1996 - (Ganymede) GM = 9.8866e+12, reference distance = 2,634,000 m."
AgEVACbGravityModel.eVACbGravityModelJGeoRes2001.__doc__ = "JGeoRes2001 - (Io) GM = 5.96e+12, reference distance = 1,821,600 m."
AgEVACbGravityModel.eVACbGravityModelGGM01C.__doc__ = "GGM01C - (Earth)"
AgEVACbGravityModel.eVACbGravityModelGGM02C.__doc__ = "GGM02C - (Earth)"
AgEVACbGravityModel.eVACbGravityModelWGS72ZonalsToJ4.__doc__ = "WGS72 ZonalsToJ4 - (Earth)"
AgEVACbGravityModel.eVACbGravityModelLP100J.__doc__ = "LP100J - (Moon)"
AgEVACbGravityModel.eVACbGravityModelLP100K.__doc__ = "LP100K - (Moon)"
AgEVACbGravityModel.eVACbGravityModelLP150Q.__doc__ = "LP150Q - (Moon)"
AgEVACbGravityModel.eVACbGravityModelLP75G.__doc__ = "LP75G - (Moon)"

agcls.AgTypeNameMap["AgEVACbGravityModel"] = AgEVACbGravityModel

class AgEVACbShape(IntEnum):
    """The central body shape types."""
    # A triaxial ellipsoid defined by a semi-major axis, semi-mid axis and semi-minor axis.
    eVACbShapeTriaxialEllipsoid = 0
    # An oblate spheroid defined by a minimum and maximum radii, and a derived flattening coefficient.
    eVACbShapeOblateSpheroid = 1
    # A sphere defined by a radius.
    eVACbShapeSphere = 2

AgEVACbShape.eVACbShapeTriaxialEllipsoid.__doc__ = "A triaxial ellipsoid defined by a semi-major axis, semi-mid axis and semi-minor axis."
AgEVACbShape.eVACbShapeOblateSpheroid.__doc__ = "An oblate spheroid defined by a minimum and maximum radii, and a derived flattening coefficient."
AgEVACbShape.eVACbShapeSphere.__doc__ = "A sphere defined by a radius."

agcls.AgTypeNameMap["AgEVACbShape"] = AgEVACbShape

class AgEVACbAttitude(IntEnum):
    """The central body attitude types."""
    # An IAU 1994 attitude definition.
    eVACbAttitudeIAU1994 = 0
    # A rotation coefficient file.
    eVACbAttitudeRotationCoefficientsFile = 1

AgEVACbAttitude.eVACbAttitudeIAU1994.__doc__ = "An IAU 1994 attitude definition."
AgEVACbAttitude.eVACbAttitudeRotationCoefficientsFile.__doc__ = "A rotation coefficient file."

agcls.AgTypeNameMap["AgEVACbAttitude"] = AgEVACbAttitude

class AgEVACbEphemeris(IntEnum):
    """The central body ephemeris types."""
    # Specified values and rates of change for the classical orbital elements.
    eVACbEphemerisAnalyticOrbit = 0
    # An external ephemeris (.e) file.
    eVACbEphemerisFile = 1
    # Ephemerides from the Jet Propulsion Laboratory's JPL DE set are used.
    eVACbEphemerisJPLDE = 2
    # The SPICE propagator reads ephemeris from binary files that are in a standard format produced by the Jet Propulsion Laboratory for ephemeris for celestial bodies but can be used for spacecraft.
    eVACbEphemerisJPLSPICE = 3
    # A planetary ephemeris (.pe) file.
    eVACbEphemerisPlanetary = 4

AgEVACbEphemeris.eVACbEphemerisAnalyticOrbit.__doc__ = "Specified values and rates of change for the classical orbital elements."
AgEVACbEphemeris.eVACbEphemerisFile.__doc__ = "An external ephemeris (.e) file."
AgEVACbEphemeris.eVACbEphemerisJPLDE.__doc__ = "Ephemerides from the Jet Propulsion Laboratory's JPL DE set are used."
AgEVACbEphemeris.eVACbEphemerisJPLSPICE.__doc__ = "The SPICE propagator reads ephemeris from binary files that are in a standard format produced by the Jet Propulsion Laboratory for ephemeris for celestial bodies but can be used for spacecraft."
AgEVACbEphemeris.eVACbEphemerisPlanetary.__doc__ = "A planetary ephemeris (.pe) file."

agcls.AgTypeNameMap["AgEVACbEphemeris"] = AgEVACbEphemeris

class AgEVAControlPowerInternal(IntEnum):
    """Internal Power properties that can be selected as control parameters for a Target Sequence."""
    # The power generated by the spacecraft from internal sources.
    eVAControlPowerInternalGeneratedPower = 0
    # The percent degradation per year; degradation factor is (1 - x%/yr)timeSinceRefEpoch.
    eVAControlPowerInternalPercentDegradation = 1
    # The date and time used as a reference epoch for degradation.
    eVAControlPowerInternalEpoch = 2

AgEVAControlPowerInternal.eVAControlPowerInternalGeneratedPower.__doc__ = "The power generated by the spacecraft from internal sources."
AgEVAControlPowerInternal.eVAControlPowerInternalPercentDegradation.__doc__ = "The percent degradation per year; degradation factor is (1 - x%/yr)timeSinceRefEpoch."
AgEVAControlPowerInternal.eVAControlPowerInternalEpoch.__doc__ = "The date and time used as a reference epoch for degradation."

agcls.AgTypeNameMap["AgEVAControlPowerInternal"] = AgEVAControlPowerInternal

class AgEVAControlPowerProcessed(IntEnum):
    """Processed Power properties that can be selected as control parameters for a Target Sequence."""
    # The efficiency of the power processing unit(PPU).
    eVAControlPowerProcessedEfficiency = 0
    # The power diverted from the power source and unavailable to the power processing unit(PPU).
    eVAControlPowerProcessedLoad = 1

AgEVAControlPowerProcessed.eVAControlPowerProcessedEfficiency.__doc__ = "The efficiency of the power processing unit(PPU)."
AgEVAControlPowerProcessed.eVAControlPowerProcessedLoad.__doc__ = "The power diverted from the power source and unavailable to the power processing unit(PPU)."

agcls.AgTypeNameMap["AgEVAControlPowerProcessed"] = AgEVAControlPowerProcessed

class AgEVAControlPowerSolarArray(IntEnum):
    """Solar Array Power properties that can be selected as control parameters for a Target Sequence."""
    # The ThermalModel.C0 coefficient.
    eVAControlPowerSolarArrayC0 = 0
    # The ThermalModel.C1 coefficient.
    eVAControlPowerSolarArrayC1 = 1
    # The ThermalModel.C2 coefficient.
    eVAControlPowerSolarArrayC2 = 2
    # The ThermalModel.C3 coefficient.
    eVAControlPowerSolarArrayC3 = 3
    # The ThermalModel.C4 coefficient.
    eVAControlPowerSolarArrayC4 = 4
    # The solar array panel area.
    eVAControlPowerSolarArrayArea = 5
    # The array efficiency in producing output power from a collection of cells.
    eVAControlPowerSolarArrayEfficiency = 6
    # The cell efficiency in producing output power from incident sunlight.
    eVAControlPowerSolarArrayCellEfficiency = 7
    # The solar array concentration factor.
    eVAControlPowerSolarArrayConcentration = 8
    # The angle from the panel normal vector to the apparent sun line.
    eVAControlPowerSolarArrayInclinationToSunLine = 9
    # The percent degradation per year; degradation factor is (1 - x%/yr)timeSinceRefEpoch.
    eVAControlPowerSolarArrayPercentDegradation = 10
    # The date and time used as a reference epoch for degradation.
    eVAControlPowerSolarArrayEpoch = 11

AgEVAControlPowerSolarArray.eVAControlPowerSolarArrayC0.__doc__ = "The ThermalModel.C0 coefficient."
AgEVAControlPowerSolarArray.eVAControlPowerSolarArrayC1.__doc__ = "The ThermalModel.C1 coefficient."
AgEVAControlPowerSolarArray.eVAControlPowerSolarArrayC2.__doc__ = "The ThermalModel.C2 coefficient."
AgEVAControlPowerSolarArray.eVAControlPowerSolarArrayC3.__doc__ = "The ThermalModel.C3 coefficient."
AgEVAControlPowerSolarArray.eVAControlPowerSolarArrayC4.__doc__ = "The ThermalModel.C4 coefficient."
AgEVAControlPowerSolarArray.eVAControlPowerSolarArrayArea.__doc__ = "The solar array panel area."
AgEVAControlPowerSolarArray.eVAControlPowerSolarArrayEfficiency.__doc__ = "The array efficiency in producing output power from a collection of cells."
AgEVAControlPowerSolarArray.eVAControlPowerSolarArrayCellEfficiency.__doc__ = "The cell efficiency in producing output power from incident sunlight."
AgEVAControlPowerSolarArray.eVAControlPowerSolarArrayConcentration.__doc__ = "The solar array concentration factor."
AgEVAControlPowerSolarArray.eVAControlPowerSolarArrayInclinationToSunLine.__doc__ = "The angle from the panel normal vector to the apparent sun line."
AgEVAControlPowerSolarArray.eVAControlPowerSolarArrayPercentDegradation.__doc__ = "The percent degradation per year; degradation factor is (1 - x%/yr)timeSinceRefEpoch."
AgEVAControlPowerSolarArray.eVAControlPowerSolarArrayEpoch.__doc__ = "The date and time used as a reference epoch for degradation."

agcls.AgTypeNameMap["AgEVAControlPowerSolarArray"] = AgEVAControlPowerSolarArray

class AgEVAThirdBodyMode(IntEnum):
    """The third body gravity mode."""
    # Defines the gravitational effect as a full Gravitational Force model
    eVAThirdBodyModeGravityField = 0
    # Defines the gravitational effect as a third body point mass effect.
    eVAThirdBodyModePointMass = 1

AgEVAThirdBodyMode.eVAThirdBodyModeGravityField.__doc__ = "Defines the gravitational effect as a full Gravitational Force model"
AgEVAThirdBodyMode.eVAThirdBodyModePointMass.__doc__ = "Defines the gravitational effect as a third body point mass effect."

agcls.AgTypeNameMap["AgEVAThirdBodyMode"] = AgEVAThirdBodyMode

class AgEVAGravParamSource(IntEnum):
    """The gravity parameter source."""
    # The Cb file provided with STK; uses the default, body centered gravity source for the central body.
    eVAGravParamSourceCbFile = 0
    # A DE file; body centered for the inner planets and barycentered for the outer planets.
    eVAGravParamSourceDEFile = 1
    # User defined; requires you to specify the mu value of the Gravitational Parameter.
    eVAGravParamSourceUser = 2
    # The Cb file provided with STK; uses the default, barycentered gravity source for the central body.
    eVAGravParamSourceCbFileSystem = 3

AgEVAGravParamSource.eVAGravParamSourceCbFile.__doc__ = "The Cb file provided with STK; uses the default, body centered gravity source for the central body."
AgEVAGravParamSource.eVAGravParamSourceDEFile.__doc__ = "A DE file; body centered for the inner planets and barycentered for the outer planets."
AgEVAGravParamSource.eVAGravParamSourceUser.__doc__ = "User defined; requires you to specify the mu value of the Gravitational Parameter."
AgEVAGravParamSource.eVAGravParamSourceCbFileSystem.__doc__ = "The Cb file provided with STK; uses the default, barycentered gravity source for the central body."

agcls.AgTypeNameMap["AgEVAGravParamSource"] = AgEVAGravParamSource

class AgEVAEphemSource(IntEnum):
    """The ephemeris source type."""
    # The Cb file provided with STK; uses the default ephemeris source for that central body.
    eVAEphemSourceCbFile = 0
    # A DE file; body centered for the inner planets and barycentered for the outer planets.
    eVAEphemSourceDEFile = 1
    # A SPICE file, barycentered; uses the entire planetary system as a single effect, with the system center as the point mass.
    eVAEphemSourceSPICEBary = 2
    # A SPICE file, body centered; uses only the planet as the effect, with the planet's center as the point mass.
    eVAEphemSourceSPICEBody = 3

AgEVAEphemSource.eVAEphemSourceCbFile.__doc__ = "The Cb file provided with STK; uses the default ephemeris source for that central body."
AgEVAEphemSource.eVAEphemSourceDEFile.__doc__ = "A DE file; body centered for the inner planets and barycentered for the outer planets."
AgEVAEphemSource.eVAEphemSourceSPICEBary.__doc__ = "A SPICE file, barycentered; uses the entire planetary system as a single effect, with the system center as the point mass."
AgEVAEphemSource.eVAEphemSourceSPICEBody.__doc__ = "A SPICE file, body centered; uses only the planet as the effect, with the planet's center as the point mass."

agcls.AgTypeNameMap["AgEVAEphemSource"] = AgEVAEphemSource

class AgEVASolarForceMethod(IntEnum):
    """The solar force method type for a spherical or N-plate SRP model."""
    # Luminosity - used as the value for solar flux at 1 AU in the Solar Radiation computation.
    eVASolarForceMethodLuminosity = 0
    # Mean Flux - used as the value for solar flux at 1 AU in the Solar Radiation computation.
    eVASolarForceMethodMeanFlux = 1

AgEVASolarForceMethod.eVASolarForceMethodLuminosity.__doc__ = "Luminosity - used as the value for solar flux at 1 AU in the Solar Radiation computation."
AgEVASolarForceMethod.eVASolarForceMethodMeanFlux.__doc__ = "Mean Flux - used as the value for solar flux at 1 AU in the Solar Radiation computation."

agcls.AgTypeNameMap["AgEVASolarForceMethod"] = AgEVASolarForceMethod

class AgEVAShadowModel(IntEnum):
    """The shadow model type."""
    # Cylindrical - assumes the Sun to be at infinite distance so that all light coming from the Sun moves in a direction parallel to the Sun to satellite vector.
    eVAShadowModelCylindrical = 0
    # Dual Cone - uses the actual size and distance of the Sun to model regions of full, partial (penumbra) and zero (umbra) sunlight. The visible fraction of the solar disk is used to compute the acceleration during penumbra.
    eVAShadowModelDualCone = 1
    # None - turns off all shadowing of the satellite.
    eVAShadowModelNone = 2

AgEVAShadowModel.eVAShadowModelCylindrical.__doc__ = "Cylindrical - assumes the Sun to be at infinite distance so that all light coming from the Sun moves in a direction parallel to the Sun to satellite vector."
AgEVAShadowModel.eVAShadowModelDualCone.__doc__ = "Dual Cone - uses the actual size and distance of the Sun to model regions of full, partial (penumbra) and zero (umbra) sunlight. The visible fraction of the solar disk is used to compute the acceleration during penumbra."
AgEVAShadowModel.eVAShadowModelNone.__doc__ = "None - turns off all shadowing of the satellite."

agcls.AgTypeNameMap["AgEVAShadowModel"] = AgEVAShadowModel

class AgEVASunPosition(IntEnum):
    """The sun position type."""
    # Apparent - takes into account the time required for light to travel from the sun to the position of the spacecraft.
    eVASunPositionApparent = 0
    # Apparent Sun to True Cb - takes into account the time required for light to travel from the sun to the central body.
    eVASunPositionApparentToTrueCb = 1
    # True - assumes that light from the sun reaches the spacecraft instantaneously.
    eVASunPositionTrue = 2

AgEVASunPosition.eVASunPositionApparent.__doc__ = "Apparent - takes into account the time required for light to travel from the sun to the position of the spacecraft."
AgEVASunPosition.eVASunPositionApparentToTrueCb.__doc__ = "Apparent Sun to True Cb - takes into account the time required for light to travel from the sun to the central body."
AgEVASunPosition.eVASunPositionTrue.__doc__ = "True - assumes that light from the sun reaches the spacecraft instantaneously."

agcls.AgTypeNameMap["AgEVASunPosition"] = AgEVASunPosition

class AgEVAAtmosDataSource(IntEnum):
    """The Atmospheric data source type."""
    # Constant Atmospheric data source.
    eVAAtmosDataSourceConstant = 0
    # Atmopsheric data source from file.
    eVAAtmosDataSourceFile = 1

AgEVAAtmosDataSource.eVAAtmosDataSourceConstant.__doc__ = "Constant Atmospheric data source."
AgEVAAtmosDataSource.eVAAtmosDataSourceFile.__doc__ = "Atmopsheric data source from file."

agcls.AgTypeNameMap["AgEVAAtmosDataSource"] = AgEVAAtmosDataSource

class AgEVAGeoMagneticFluxSource(IntEnum):
    """Whether to use Kp or Ap data from the flux file."""
    # Read Ap from file.
    eVAGeoMagneticFluxSourceAp = 0
    # Read Kp from file.
    eVAGeoMagneticFluxSourceKp = 1

AgEVAGeoMagneticFluxSource.eVAGeoMagneticFluxSourceAp.__doc__ = "Read Ap from file."
AgEVAGeoMagneticFluxSource.eVAGeoMagneticFluxSourceKp.__doc__ = "Read Kp from file."

agcls.AgTypeNameMap["AgEVAGeoMagneticFluxSource"] = AgEVAGeoMagneticFluxSource

class AgEVAGeoMagneticFluxUpdateRate(IntEnum):
    """Method for using geomagnetic flux values from the flux file."""
    # Three hourly
    eVAGeoMagneticFluxUpdateRate3Hourly = 0
    # Three hourly cubic spline
    eVAGeoMagneticFluxUpdateRate3HourlyCubicSpline = 1
    # Three hourly interpolated
    eVAGeoMagneticFluxUpdateRate3HourlyInterpolated = 2
    # Daily
    eVAGeoMagneticFluxUpdateRateDaily = 3

AgEVAGeoMagneticFluxUpdateRate.eVAGeoMagneticFluxUpdateRate3Hourly.__doc__ = "Three hourly"
AgEVAGeoMagneticFluxUpdateRate.eVAGeoMagneticFluxUpdateRate3HourlyCubicSpline.__doc__ = "Three hourly cubic spline"
AgEVAGeoMagneticFluxUpdateRate.eVAGeoMagneticFluxUpdateRate3HourlyInterpolated.__doc__ = "Three hourly interpolated"
AgEVAGeoMagneticFluxUpdateRate.eVAGeoMagneticFluxUpdateRateDaily.__doc__ = "Daily"

agcls.AgTypeNameMap["AgEVAGeoMagneticFluxUpdateRate"] = AgEVAGeoMagneticFluxUpdateRate

class AgEVADragModelType(IntEnum):
    """Type of Drag Model."""
    # Spherical
    eVADragModelTypeSpherical = 0
    # Plugin
    eVADragModelTypePlugin = 1
    # Variable Area
    eVADragModelTypeVariableArea = 2
    # N-Plate
    eVADragModelTypeNPlate = 3

AgEVADragModelType.eVADragModelTypeSpherical.__doc__ = "Spherical"
AgEVADragModelType.eVADragModelTypePlugin.__doc__ = "Plugin"
AgEVADragModelType.eVADragModelTypeVariableArea.__doc__ = "Variable Area"
AgEVADragModelType.eVADragModelTypeNPlate.__doc__ = "N-Plate"

agcls.AgTypeNameMap["AgEVADragModelType"] = AgEVADragModelType

class AgEVAMarsGRAMDensityType(IntEnum):
    """Density Type for MarsGRAM Density Models"""
    # Low density
    eVAMarsGRAMDensityTypeLow = 0
    # Mean density
    eVAMarsGRAMDensityTypeMean = 1
    # High density
    eVAMarsGRAMDensityTypeHigh = 2
    # Randomly perturbed density
    eVAMarsGRAMDensityTypeRandomlyPerturbed = 3

AgEVAMarsGRAMDensityType.eVAMarsGRAMDensityTypeLow.__doc__ = "Low density"
AgEVAMarsGRAMDensityType.eVAMarsGRAMDensityTypeMean.__doc__ = "Mean density"
AgEVAMarsGRAMDensityType.eVAMarsGRAMDensityTypeHigh.__doc__ = "High density"
AgEVAMarsGRAMDensityType.eVAMarsGRAMDensityTypeRandomlyPerturbed.__doc__ = "Randomly perturbed density"

agcls.AgTypeNameMap["AgEVAMarsGRAMDensityType"] = AgEVAMarsGRAMDensityType

class AgEVAVenusGRAMDensityType(IntEnum):
    """Density Type for VenusGRAM Density Models"""
    # Low density
    eVAVenusGRAMDensityTypeLow = 0
    # Mean density
    eVAVenusGRAMDensityTypeMean = 1
    # High density
    eVAVenusGRAMDensityTypeHigh = 2
    # Randomly perturbed density
    eVAVenusGRAMDensityTypeRandomlyPerturbed = 3

AgEVAVenusGRAMDensityType.eVAVenusGRAMDensityTypeLow.__doc__ = "Low density"
AgEVAVenusGRAMDensityType.eVAVenusGRAMDensityTypeMean.__doc__ = "Mean density"
AgEVAVenusGRAMDensityType.eVAVenusGRAMDensityTypeHigh.__doc__ = "High density"
AgEVAVenusGRAMDensityType.eVAVenusGRAMDensityTypeRandomlyPerturbed.__doc__ = "Randomly perturbed density"

agcls.AgTypeNameMap["AgEVAVenusGRAMDensityType"] = AgEVAVenusGRAMDensityType

class AgEVATabVecInterpMethod(IntEnum):
    """The interpolation method for tabulated area vector file."""
    # Bilinear interpolation on the Cartesian grid.
    eVATabVecCartesianInterpolation = 0
    # Bilinear interpolation in magnitude and direction space.
    eVATabVecMagDirInterpolation = 1

AgEVATabVecInterpMethod.eVATabVecCartesianInterpolation.__doc__ = "Bilinear interpolation on the Cartesian grid."
AgEVATabVecInterpMethod.eVATabVecMagDirInterpolation.__doc__ = "Bilinear interpolation in magnitude and direction space."

agcls.AgTypeNameMap["AgEVATabVecInterpMethod"] = AgEVATabVecInterpMethod

class AgEVAControlEngineConstAcc(IntEnum):
    """Constant Acceleration and Isp engine model properties that can be selected as control parameters for a Target Sequence."""
    # The gravitational acceleration constant at sea level on the Earth.
    eVAControlEngineConstAccGrav = 0
    # The acceleration for the engine.
    eVAControlEngineConstAccAcceleration = 1
    # The specific impulse for the engine.
    eVAControlEngineConstAccIsp = 2

AgEVAControlEngineConstAcc.eVAControlEngineConstAccGrav.__doc__ = "The gravitational acceleration constant at sea level on the Earth."
AgEVAControlEngineConstAcc.eVAControlEngineConstAccAcceleration.__doc__ = "The acceleration for the engine."
AgEVAControlEngineConstAcc.eVAControlEngineConstAccIsp.__doc__ = "The specific impulse for the engine."

agcls.AgTypeNameMap["AgEVAControlEngineConstAcc"] = AgEVAControlEngineConstAcc

class AgEVAControlEngineConstant(IntEnum):
    """Constant Thrust and Isp engine model properties that can be selected as control parameters for a Target Sequence."""
    # The gravitational acceleration constant at sea level on the Earth.
    eVAControlEngineConstantGrav = 0
    # The thrust for the engine.
    eVAControlEngineConstantThrust = 1
    # The specific impulse for the engine.
    eVAControlEngineConstantIsp = 2

AgEVAControlEngineConstant.eVAControlEngineConstantGrav.__doc__ = "The gravitational acceleration constant at sea level on the Earth."
AgEVAControlEngineConstant.eVAControlEngineConstantThrust.__doc__ = "The thrust for the engine."
AgEVAControlEngineConstant.eVAControlEngineConstantIsp.__doc__ = "The specific impulse for the engine."

agcls.AgTypeNameMap["AgEVAControlEngineConstant"] = AgEVAControlEngineConstant

class AgEVAControlEngineCustom(IntEnum):
    """Custom engine model properties that can be selected as control parameters for a Target Sequence."""
    # Earth surface gravity acceleration for Isp conversions.
    eVAControlEngineCustomGrav = 0

AgEVAControlEngineCustom.eVAControlEngineCustomGrav.__doc__ = "Earth surface gravity acceleration for Isp conversions."

agcls.AgTypeNameMap["AgEVAControlEngineCustom"] = AgEVAControlEngineCustom

class AgEVAControlEngineThrottleTable(IntEnum):
    """Throttle table engine model properties that can be selected as control parameters for a Target Sequence."""
    # Gravitational acceleration constant at sea level on the Earth.
    eVAControlEngineThrottleTableGrav = 0
    # The degradation factor is (1 - x)n, where n is the time since epoch in years, and x is the percent degradation per year.
    eVAControlEngineThrottleTablePercentDegradationPerYear = 1
    # The date and time used as a reference epoch for degradation.
    eVAControlEngineThrottleTableReferenceEpoch = 2

AgEVAControlEngineThrottleTable.eVAControlEngineThrottleTableGrav.__doc__ = "Gravitational acceleration constant at sea level on the Earth."
AgEVAControlEngineThrottleTable.eVAControlEngineThrottleTablePercentDegradationPerYear.__doc__ = "The degradation factor is (1 - x)n, where n is the time since epoch in years, and x is the percent degradation per year."
AgEVAControlEngineThrottleTable.eVAControlEngineThrottleTableReferenceEpoch.__doc__ = "The date and time used as a reference epoch for degradation."

agcls.AgTypeNameMap["AgEVAControlEngineThrottleTable"] = AgEVAControlEngineThrottleTable

class AgEVAControlEngineIon(IntEnum):
    """Ion engine model properties that can be selected as control parameters for a Target Sequence."""
    # FlowRateModel.C0 - the constant coefficient.
    eVAControlEngineIonFlowRateC0 = 0
    # FlowRateModel.C1 - the linear coefficient.
    eVAControlEngineIonFlowRateC1 = 1
    # FlowRateModel.C2 - the quadratic coefficient.
    eVAControlEngineIonFlowRateC2 = 2
    # FlowRateModel.C3 - the cubic coefficient.
    eVAControlEngineIonFlowRateC3 = 3
    # Gravitational acceleration constant at sea level on the Earth.
    eVAControlEngineIonGrav = 4
    # IspModel.C0 - the constant coefficient.
    eVAControlEngineIonIspC0 = 5
    # IspModel.C1 - the linear coefficient.
    eVAControlEngineIonIspC1 = 6
    # IspModel.C2 - the quadratic coefficient.
    eVAControlEngineIonIspC2 = 7
    # IspModel.C3 - the cubic coefficient.
    eVAControlEngineIonIspC3 = 8
    # MassFlowEfficiencyModel.C0 - the constant coefficient.
    eVAControlEngineIonMassFlowEfficiencyC0 = 9
    # MassFlowEfficiencyModel.C1 - the linear coefficient.
    eVAControlEngineIonMassFlowEfficiencyC1 = 10
    # MassFlowEfficiencyModel.C2 - the quadratic coefficient.
    eVAControlEngineIonMassFlowEfficiencyC2 = 11
    # MassFlowEfficiencyModel.C3 - the cubic coefficient.
    eVAControlEngineIonMassFlowEfficiencyC3 = 12
    # Minimum power required for the engine to produce thrust. 
    eVAControlEngineIonMaxInputPower = 13
    # Maximum power that can be used by the engine to produce thrust.
    eVAControlEngineIonMinRequiredPower = 14
    # The degradation factor is (1 - x)n, where n is the time since epoch in years, and x is the percent degradation per year.
    eVAControlEngineIonPercentDegradationPerYear = 15
    # Percentage of available thrust to use (100 is full on, 0 is off).
    eVAControlEngineIonPercentThrottle = 16
    # PowerEfficiencyModel.C0 - the constant coefficient.
    eVAControlEngineIonPowerEfficiencyC0 = 17
    # PowerEfficiencyModel.C1 - the linear coefficient.
    eVAControlEngineIonPowerEfficiencyC1 = 18
    # PowerEfficiencyModel.C2 - the quadratic coefficient.
    eVAControlEngineIonPowerEfficiencyC2 = 19
    # PowerEfficiencyModel.C3 - the cubic coefficient.
    eVAControlEngineIonPowerEfficiencyC3 = 20
    # The date and time used as a reference epoch for degradation.
    eVAControlEngineIonReferenceEpoch = 21

AgEVAControlEngineIon.eVAControlEngineIonFlowRateC0.__doc__ = "FlowRateModel.C0 - the constant coefficient."
AgEVAControlEngineIon.eVAControlEngineIonFlowRateC1.__doc__ = "FlowRateModel.C1 - the linear coefficient."
AgEVAControlEngineIon.eVAControlEngineIonFlowRateC2.__doc__ = "FlowRateModel.C2 - the quadratic coefficient."
AgEVAControlEngineIon.eVAControlEngineIonFlowRateC3.__doc__ = "FlowRateModel.C3 - the cubic coefficient."
AgEVAControlEngineIon.eVAControlEngineIonGrav.__doc__ = "Gravitational acceleration constant at sea level on the Earth."
AgEVAControlEngineIon.eVAControlEngineIonIspC0.__doc__ = "IspModel.C0 - the constant coefficient."
AgEVAControlEngineIon.eVAControlEngineIonIspC1.__doc__ = "IspModel.C1 - the linear coefficient."
AgEVAControlEngineIon.eVAControlEngineIonIspC2.__doc__ = "IspModel.C2 - the quadratic coefficient."
AgEVAControlEngineIon.eVAControlEngineIonIspC3.__doc__ = "IspModel.C3 - the cubic coefficient."
AgEVAControlEngineIon.eVAControlEngineIonMassFlowEfficiencyC0.__doc__ = "MassFlowEfficiencyModel.C0 - the constant coefficient."
AgEVAControlEngineIon.eVAControlEngineIonMassFlowEfficiencyC1.__doc__ = "MassFlowEfficiencyModel.C1 - the linear coefficient."
AgEVAControlEngineIon.eVAControlEngineIonMassFlowEfficiencyC2.__doc__ = "MassFlowEfficiencyModel.C2 - the quadratic coefficient."
AgEVAControlEngineIon.eVAControlEngineIonMassFlowEfficiencyC3.__doc__ = "MassFlowEfficiencyModel.C3 - the cubic coefficient."
AgEVAControlEngineIon.eVAControlEngineIonMaxInputPower.__doc__ = "Minimum power required for the engine to produce thrust. "
AgEVAControlEngineIon.eVAControlEngineIonMinRequiredPower.__doc__ = "Maximum power that can be used by the engine to produce thrust."
AgEVAControlEngineIon.eVAControlEngineIonPercentDegradationPerYear.__doc__ = "The degradation factor is (1 - x)n, where n is the time since epoch in years, and x is the percent degradation per year."
AgEVAControlEngineIon.eVAControlEngineIonPercentThrottle.__doc__ = "Percentage of available thrust to use (100 is full on, 0 is off)."
AgEVAControlEngineIon.eVAControlEngineIonPowerEfficiencyC0.__doc__ = "PowerEfficiencyModel.C0 - the constant coefficient."
AgEVAControlEngineIon.eVAControlEngineIonPowerEfficiencyC1.__doc__ = "PowerEfficiencyModel.C1 - the linear coefficient."
AgEVAControlEngineIon.eVAControlEngineIonPowerEfficiencyC2.__doc__ = "PowerEfficiencyModel.C2 - the quadratic coefficient."
AgEVAControlEngineIon.eVAControlEngineIonPowerEfficiencyC3.__doc__ = "PowerEfficiencyModel.C3 - the cubic coefficient."
AgEVAControlEngineIon.eVAControlEngineIonReferenceEpoch.__doc__ = "The date and time used as a reference epoch for degradation."

agcls.AgTypeNameMap["AgEVAControlEngineIon"] = AgEVAControlEngineIon

class AgEVAControlEngineModelPoly(IntEnum):
    """Polynomial Thrust and Isp engine model properties that can be selected as control parameters for a Target Sequence."""
    # The thrust C0 coefficient.
    eVAControlEngineModelPolyThrustC0 = 0
    # The thrust C1 coefficient.
    eVAControlEngineModelPolyThrustC1 = 1
    # The thrust C2 coefficient.
    eVAControlEngineModelPolyThrustC2 = 2
    # The thrust C3 coefficient.
    eVAControlEngineModelPolyThrustC3 = 3
    # The thrust C4 coefficient.
    eVAControlEngineModelPolyThrustC4 = 4
    # The thrust C5 coefficient.
    eVAControlEngineModelPolyThrustC5 = 5
    # The thrust C6 coefficient.
    eVAControlEngineModelPolyThrustC6 = 6
    # The thrust C7 coefficient.
    eVAControlEngineModelPolyThrustC7 = 7
    # The thrust B7 coefficient.
    eVAControlEngineModelPolyThrustB7 = 8
    # The thrust E4 coefficient.
    eVAControlEngineModelPolyThrustE4 = 9
    # The thrust E5 coefficient.
    eVAControlEngineModelPolyThrustE5 = 10
    # The thrust E6 coefficient.
    eVAControlEngineModelPolyThrustE6 = 11
    # The thrust E7 coefficient.
    eVAControlEngineModelPolyThrustE7 = 12
    # The thrust K0 coefficient.
    eVAControlEngineModelPolyThrustK0 = 13
    # The thrust K1 coefficient.
    eVAControlEngineModelPolyThrustK1 = 14
    # The thrust reference temperature, Tr.
    eVAControlEngineModelPolyThrustReferenceTemp = 15
    # The specific impulse C0 coefficient.
    eVAControlEngineModelPolyIspC0 = 16
    # The specific impulse C1 coefficient.
    eVAControlEngineModelPolyIspC1 = 17
    # The specific impulse C2 coefficient.
    eVAControlEngineModelPolyIspC2 = 18
    # The specific impulse C3 coefficient.
    eVAControlEngineModelPolyIspC3 = 19
    # The specific impulse C4 coefficient.
    eVAControlEngineModelPolyIspC4 = 20
    # The specific impulse C5 coefficient.
    eVAControlEngineModelPolyIspC5 = 21
    # The specific impulse C6 coefficient.
    eVAControlEngineModelPolyIspC6 = 22
    # The specific impulse C7 coefficient.
    eVAControlEngineModelPolyIspC7 = 23
    # The specific impulse B7 coefficient.
    eVAControlEngineModelPolyIspB7 = 24
    # The specific impulse E4 coefficient.
    eVAControlEngineModelPolyIspE4 = 25
    # The specific impulse E5 coefficient.
    eVAControlEngineModelPolyIspE5 = 26
    # The specific impulse E6 coefficient.
    eVAControlEngineModelPolyIspE6 = 27
    # The specific impulse E7 coefficient.
    eVAControlEngineModelPolyIspE7 = 28
    # The specific impulse K0 coefficient.
    eVAControlEngineModelPolyIspK0 = 29
    # The specific impulse K1 coefficient.
    eVAControlEngineModelPolyIspK1 = 30
    # The specific impulse reference temperature, Tr.
    eVAControlEngineModelPolyIspReferenceTemp = 31
    # The gravitational acceleration constant at sea level on the Earth.
    eVAControlEngineModelPolyGrav = 32

AgEVAControlEngineModelPoly.eVAControlEngineModelPolyThrustC0.__doc__ = "The thrust C0 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyThrustC1.__doc__ = "The thrust C1 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyThrustC2.__doc__ = "The thrust C2 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyThrustC3.__doc__ = "The thrust C3 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyThrustC4.__doc__ = "The thrust C4 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyThrustC5.__doc__ = "The thrust C5 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyThrustC6.__doc__ = "The thrust C6 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyThrustC7.__doc__ = "The thrust C7 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyThrustB7.__doc__ = "The thrust B7 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyThrustE4.__doc__ = "The thrust E4 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyThrustE5.__doc__ = "The thrust E5 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyThrustE6.__doc__ = "The thrust E6 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyThrustE7.__doc__ = "The thrust E7 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyThrustK0.__doc__ = "The thrust K0 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyThrustK1.__doc__ = "The thrust K1 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyThrustReferenceTemp.__doc__ = "The thrust reference temperature, Tr."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyIspC0.__doc__ = "The specific impulse C0 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyIspC1.__doc__ = "The specific impulse C1 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyIspC2.__doc__ = "The specific impulse C2 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyIspC3.__doc__ = "The specific impulse C3 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyIspC4.__doc__ = "The specific impulse C4 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyIspC5.__doc__ = "The specific impulse C5 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyIspC6.__doc__ = "The specific impulse C6 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyIspC7.__doc__ = "The specific impulse C7 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyIspB7.__doc__ = "The specific impulse B7 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyIspE4.__doc__ = "The specific impulse E4 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyIspE5.__doc__ = "The specific impulse E5 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyIspE6.__doc__ = "The specific impulse E6 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyIspE7.__doc__ = "The specific impulse E7 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyIspK0.__doc__ = "The specific impulse K0 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyIspK1.__doc__ = "The specific impulse K1 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyIspReferenceTemp.__doc__ = "The specific impulse reference temperature, Tr."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyGrav.__doc__ = "The gravitational acceleration constant at sea level on the Earth."

agcls.AgTypeNameMap["AgEVAControlEngineModelPoly"] = AgEVAControlEngineModelPoly

class AgEVAEngineModelFunction(IntEnum):
    """The engine model function types."""
    # Isp as an independent variable of an equation.
    eVAEngineModelFunctionIsp = 0
    # Power as an independent variable of an equation.
    eVAEngineModelFunctionPower = 1
    # Isp and Power as independent variables of an equation.
    eVAEngineModelFunctionIspAndPower = 2

AgEVAEngineModelFunction.eVAEngineModelFunctionIsp.__doc__ = "Isp as an independent variable of an equation."
AgEVAEngineModelFunction.eVAEngineModelFunctionPower.__doc__ = "Power as an independent variable of an equation."
AgEVAEngineModelFunction.eVAEngineModelFunctionIspAndPower.__doc__ = "Isp and Power as independent variables of an equation."

agcls.AgTypeNameMap["AgEVAEngineModelFunction"] = AgEVAEngineModelFunction

class AgEVAThrottleTableOperationMode(IntEnum):
    """Engine operation mode."""
    # Interpolation of engine performance data based on a regression polynomial model.
    eVAEngineOperationRegPoly = 0
    # Interpolation of engine performance data based on a piecewise linear model.
    eVAEngineOperationPiecewiseLinear = 1
    # Discrete engine operation: piecewise constant engine performance as a function of available power.
    eVAEngineOperationDiscrete = 2

AgEVAThrottleTableOperationMode.eVAEngineOperationRegPoly.__doc__ = "Interpolation of engine performance data based on a regression polynomial model."
AgEVAThrottleTableOperationMode.eVAEngineOperationPiecewiseLinear.__doc__ = "Interpolation of engine performance data based on a piecewise linear model."
AgEVAThrottleTableOperationMode.eVAEngineOperationDiscrete.__doc__ = "Discrete engine operation: piecewise constant engine performance as a function of available power."

agcls.AgTypeNameMap["AgEVAThrottleTableOperationMode"] = AgEVAThrottleTableOperationMode

class AgEVAControlThrusters(IntEnum):
    """Thruster properties that can be selected as control parameters for a Target Sequence."""
    # The equivalent on-time percentage is a factor multiplied by the thrust. The thrust is applied continuously throughout the maneuver and is reduced by the percentage. The mass flow rate is likewise reduced.
    eVAControlThrustersEquivOnTime = 0
    # The thruster efficiency.
    eVAControlThrustersThrustEfficiency = 1
    # Thruster direction defined as a vector in the body frame. Spherical azimuth value.
    eVAControlThrustersSphericalAzimuth = 2
    # Thruster direction defined as a vector in the body frame. Spherical elevation value.
    eVAControlThrustersSphericalElevation = 3
    # Thruster direction defined as a vector in the body frame. Cartesian X value.
    eVAControlThrustersCartesianX = 4
    # Thruster direction defined as a vector in the body frame. Cartesian Y value.
    eVAControlThrustersCartesianY = 5
    # Thruster direction defined as a vector in the body frame. Cartesian Z value.
    eVAControlThrustersCartesianZ = 6

AgEVAControlThrusters.eVAControlThrustersEquivOnTime.__doc__ = "The equivalent on-time percentage is a factor multiplied by the thrust. The thrust is applied continuously throughout the maneuver and is reduced by the percentage. The mass flow rate is likewise reduced."
AgEVAControlThrusters.eVAControlThrustersThrustEfficiency.__doc__ = "The thruster efficiency."
AgEVAControlThrusters.eVAControlThrustersSphericalAzimuth.__doc__ = "Thruster direction defined as a vector in the body frame. Spherical azimuth value."
AgEVAControlThrusters.eVAControlThrustersSphericalElevation.__doc__ = "Thruster direction defined as a vector in the body frame. Spherical elevation value."
AgEVAControlThrusters.eVAControlThrustersCartesianX.__doc__ = "Thruster direction defined as a vector in the body frame. Cartesian X value."
AgEVAControlThrusters.eVAControlThrustersCartesianY.__doc__ = "Thruster direction defined as a vector in the body frame. Cartesian Y value."
AgEVAControlThrusters.eVAControlThrustersCartesianZ.__doc__ = "Thruster direction defined as a vector in the body frame. Cartesian Z value."

agcls.AgTypeNameMap["AgEVAControlThrusters"] = AgEVAControlThrusters

class AgEVAThrusterDirection(IntEnum):
    """The thruster direction type."""
    # The direction that is opposite the direction of the exhaust.
    eVAThrusterDirectionAcceleration = 0
    # The direction of engine exhaust.
    eVAThrusterDirectionExhaust = 1

AgEVAThrusterDirection.eVAThrusterDirectionAcceleration.__doc__ = "The direction that is opposite the direction of the exhaust."
AgEVAThrusterDirection.eVAThrusterDirectionExhaust.__doc__ = "The direction of engine exhaust."

agcls.AgTypeNameMap["AgEVAThrusterDirection"] = AgEVAThrusterDirection

class AgEVACriteria(IntEnum):
    """The criteria type."""
    # The test parameter must be equal (within the specified tolerance) to the specified value.
    eVACriteriaEquals = 0
    # The test parameter must be greater than the specified value.
    eVACriteriaGreaterThan = 1
    # The current value for the calculation object is greater by the specified tolerance than the minimum reached by that object during the segment.
    eVACriteriaGreaterThanMinimum = 2
    # The test parameter must be less than the specified value.
    eVACriteriaLessThan = 3
    # The current value for the calculation object is less by the specified tolerance than the maximum reached by that object during the segment.
    eVACriteriaLessThanMaximum = 4
    # The test parameter must be not equal (within the specified tolerance) to the specified value.
    eVACriteriaNotEqualTo = 5

AgEVACriteria.eVACriteriaEquals.__doc__ = "The test parameter must be equal (within the specified tolerance) to the specified value."
AgEVACriteria.eVACriteriaGreaterThan.__doc__ = "The test parameter must be greater than the specified value."
AgEVACriteria.eVACriteriaGreaterThanMinimum.__doc__ = "The current value for the calculation object is greater by the specified tolerance than the minimum reached by that object during the segment."
AgEVACriteria.eVACriteriaLessThan.__doc__ = "The test parameter must be less than the specified value."
AgEVACriteria.eVACriteriaLessThanMaximum.__doc__ = "The current value for the calculation object is less by the specified tolerance than the maximum reached by that object during the segment."
AgEVACriteria.eVACriteriaNotEqualTo.__doc__ = "The test parameter must be not equal (within the specified tolerance) to the specified value."

agcls.AgTypeNameMap["AgEVACriteria"] = AgEVACriteria

class AgEVAErrorControl(IntEnum):
    """Error Control for the numerical integrator."""
    # The error estimate of each integrated component is compared to the absolute error tolerance. Error control with this method is based on absolute values, e.g. in meters for position, m/sec for velocity, etc.
    eVAErrorControlAbsolute = 0
    # The error estimate of each element being integrated relative to the element's value at the start of the step is compared to the relative error tolerance, and the absolute error estimate of each element is compared to the absolute error tolerance.
    eVAErrorControlRelativeByComponent = 1
    # Relative to State error control.
    eVAErrorControlRelativeToState = 2
    # Error estimate of each integrated component relative to the element's change in value over the step is compared to the relative error tolerance, and the absolute error estimate of each integrated component is compared to the absolute error tolerance.
    eVAErrorControlRelativeToStep = 3

AgEVAErrorControl.eVAErrorControlAbsolute.__doc__ = "The error estimate of each integrated component is compared to the absolute error tolerance. Error control with this method is based on absolute values, e.g. in meters for position, m/sec for velocity, etc."
AgEVAErrorControl.eVAErrorControlRelativeByComponent.__doc__ = "The error estimate of each element being integrated relative to the element's value at the start of the step is compared to the relative error tolerance, and the absolute error estimate of each element is compared to the absolute error tolerance."
AgEVAErrorControl.eVAErrorControlRelativeToState.__doc__ = "Relative to State error control."
AgEVAErrorControl.eVAErrorControlRelativeToStep.__doc__ = "Error estimate of each integrated component relative to the element's change in value over the step is compared to the relative error tolerance, and the absolute error estimate of each integrated component is compared to the absolute error tolerance."

agcls.AgTypeNameMap["AgEVAErrorControl"] = AgEVAErrorControl

class AgEVAPredictorCorrector(IntEnum):
    """Predictor corrector scheme for the numerical integrator."""
    # All force models are re-evaluated at each corrector step.
    eVAPredictorCorrectorFull = 0
    # Only the two-body acceleration is re-evaluated at each corrector step.
    eVAPredictorCorrectorPseudo = 1

AgEVAPredictorCorrector.eVAPredictorCorrectorFull.__doc__ = "All force models are re-evaluated at each corrector step."
AgEVAPredictorCorrector.eVAPredictorCorrectorPseudo.__doc__ = "Only the two-body acceleration is re-evaluated at each corrector step."

agcls.AgTypeNameMap["AgEVAPredictorCorrector"] = AgEVAPredictorCorrector

class AgEVANumericalIntegrator(IntEnum):
    """Numerical integrator type."""
    # A 4th order Runge-Kutta integrator, adapting step size by comparing one full step to two half steps. Although this technique can be quite slow compared to the other algorithms, it is very common and can be used for comparison.
    eVANumericalIntegratorRK4thAdapt = 0
    # A 7th order Runge-Kutta-Fehlberg integrator with 8th order error control. This is the default integrator used in the HPOP propagator.
    eVANumericalIntegratorRKF7th8th = 1
    # A 9th order Runge-Kutta-Verner integrator with 8th order error control.
    eVANumericalIntegratorRKV8th9th = 2
    # An integrator based on Richardson extrapolation with automatic step size control.
    eVANumericalIntegratorBulirschStoer = 3
    # A 12th order Gauss-Jackson integrator for second order ODEs. There is currently no error control implemented for this method, meaning that a fixed step size is used.
    eVANumericalIntegratorGaussJackson = 4
    # A 2nd order Runge-Kutta integrator with 3rd order error control, using Bogacki and Shampine coefficients.
    eVANumericalIntegratorRK2nd3rd = 5
    # A 4th order Runge-Kutta integrator with 5th order error control, using Cash-Karp coefficients.
    eVANumericalIntegratorRK4th5th = 6
    # A 4th order Runge-Kutta integrator that does not employ error control.
    eVANumericalIntegratorRK4th = 7

AgEVANumericalIntegrator.eVANumericalIntegratorRK4thAdapt.__doc__ = "A 4th order Runge-Kutta integrator, adapting step size by comparing one full step to two half steps. Although this technique can be quite slow compared to the other algorithms, it is very common and can be used for comparison."
AgEVANumericalIntegrator.eVANumericalIntegratorRKF7th8th.__doc__ = "A 7th order Runge-Kutta-Fehlberg integrator with 8th order error control. This is the default integrator used in the HPOP propagator."
AgEVANumericalIntegrator.eVANumericalIntegratorRKV8th9th.__doc__ = "A 9th order Runge-Kutta-Verner integrator with 8th order error control."
AgEVANumericalIntegrator.eVANumericalIntegratorBulirschStoer.__doc__ = "An integrator based on Richardson extrapolation with automatic step size control."
AgEVANumericalIntegrator.eVANumericalIntegratorGaussJackson.__doc__ = "A 12th order Gauss-Jackson integrator for second order ODEs. There is currently no error control implemented for this method, meaning that a fixed step size is used."
AgEVANumericalIntegrator.eVANumericalIntegratorRK2nd3rd.__doc__ = "A 2nd order Runge-Kutta integrator with 3rd order error control, using Bogacki and Shampine coefficients."
AgEVANumericalIntegrator.eVANumericalIntegratorRK4th5th.__doc__ = "A 4th order Runge-Kutta integrator with 5th order error control, using Cash-Karp coefficients."
AgEVANumericalIntegrator.eVANumericalIntegratorRK4th.__doc__ = "A 4th order Runge-Kutta integrator that does not employ error control."

agcls.AgTypeNameMap["AgEVANumericalIntegrator"] = AgEVANumericalIntegrator

class AgEVACoeffRKV8th9th(IntEnum):
    """Coefficient sets for RKV8th(9th) integrator."""
    # SIAM 1978.
    eVACoeffRKV8th9th1978 = 0
    # Efficient.
    eVACoeffRKV8th9thEfficient = 1

AgEVACoeffRKV8th9th.eVACoeffRKV8th9th1978.__doc__ = "SIAM 1978."
AgEVACoeffRKV8th9th.eVACoeffRKV8th9thEfficient.__doc__ = "Efficient."

agcls.AgTypeNameMap["AgEVACoeffRKV8th9th"] = AgEVACoeffRKV8th9th


class IVAUserVariableDefinitionCollection(object):
    """The list of User Variables accessed through the Driver."""
    _uuid = "{4D460A14-D8C8-4BEB-A4D0-D387079AF0BC}"
    _num_methods = 8
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Add"] = _raise_uninitialized_error
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_RemoveAll"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAUserVariableDefinitionCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAUserVariableDefinitionCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAUserVariableDefinitionCollection = agcom.GUID(IVAUserVariableDefinitionCollection._uuid)
        vtable_offset_local = IVAUserVariableDefinitionCollection._vtable_offset - 1
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariableDefinitionCollection, vtable_offset_local+1, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Add"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariableDefinitionCollection, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariableDefinitionCollection, vtable_offset_local+3, agcom.VARIANT)
        self.__dict__["_RemoveAll"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariableDefinitionCollection, vtable_offset_local+4, )
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariableDefinitionCollection, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariableDefinitionCollection, vtable_offset_local+6, POINTER(agcom.LONG))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariableDefinitionCollection, vtable_offset_local+7, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariableDefinitionCollection, vtable_offset_local+8, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAUserVariableDefinitionCollection.__dict__ and type(IVAUserVariableDefinitionCollection.__dict__[attrname]) == property:
            return IVAUserVariableDefinitionCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAUserVariableDefinitionCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVAUserVariableDefinition":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Item(self, indexOrName:typing.Any) -> "IVAUserVariableDefinition":
        """Allows you to iterate through the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppVAUserVariableDefinition:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppVAUserVariableDefinition.COM_val)))
            return arg_ppVAUserVariableDefinition.python_val

    def Add(self, parameterName:str) -> "IVAUserVariableDefinition":
        """Adds a user variable to the collection."""
        with agmarshall.BSTR_arg(parameterName) as arg_parameterName, \
             agmarshall.AgInterface_out_arg() as arg_ppVAUserVariableDefinition:
            agcls.evaluate_hresult(self.__dict__["_Add"](arg_parameterName.COM_val, byref(arg_ppVAUserVariableDefinition.COM_val)))
            return arg_ppVAUserVariableDefinition.python_val

    def Remove(self, indexOrName:typing.Any) -> None:
        """Removes a user variable."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_indexOrName.COM_val))

    def RemoveAll(self) -> None:
        """Removes all user variables."""
        agcls.evaluate_hresult(self.__dict__["_RemoveAll"]())

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def GetItemByIndex(self, index:int) -> "IVAUserVariableDefinition":
        """Retrieves a user variable definition in the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppVAUserVariableDefinition:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppVAUserVariableDefinition.COM_val)))
            return arg_ppVAUserVariableDefinition.python_val

    def GetItemByName(self, name:str) -> "IVAUserVariableDefinition":
        """Retrieves a user variable definition in the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppVAUserVariableDefinition:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppVAUserVariableDefinition.COM_val)))
            return arg_ppVAUserVariableDefinition.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{4D460A14-D8C8-4BEB-A4D0-D387079AF0BC}", IVAUserVariableDefinitionCollection)
agcls.AgTypeNameMap["IVAUserVariableDefinitionCollection"] = IVAUserVariableDefinitionCollection

class IVAUserVariableCollection(object):
    """The list of User Variables accessed through a segment that sets initial conditions."""
    _uuid = "{1BB5F3BC-51E2-4F2D-93E2-61322E3F65BE}"
    _num_methods = 5
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAUserVariableCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAUserVariableCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAUserVariableCollection = agcom.GUID(IVAUserVariableCollection._uuid)
        vtable_offset_local = IVAUserVariableCollection._vtable_offset - 1
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariableCollection, vtable_offset_local+1, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariableCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariableCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariableCollection, vtable_offset_local+4, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariableCollection, vtable_offset_local+5, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAUserVariableCollection.__dict__ and type(IVAUserVariableCollection.__dict__[attrname]) == property:
            return IVAUserVariableCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAUserVariableCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVAUserVariable":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Item(self, indexOrName:typing.Any) -> "IVAUserVariable":
        """Allows you to iterate through the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppVAUserVariable:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppVAUserVariable.COM_val)))
            return arg_ppVAUserVariable.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def GetItemByIndex(self, index:int) -> "IVAUserVariable":
        """Retrieves a user variable in the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppVAUserVariable:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppVAUserVariable.COM_val)))
            return arg_ppVAUserVariable.python_val

    def GetItemByName(self, name:str) -> "IVAUserVariable":
        """Retrieves a user variable in the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppVAUserVariable:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppVAUserVariable.COM_val)))
            return arg_ppVAUserVariable.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{1BB5F3BC-51E2-4F2D-93E2-61322E3F65BE}", IVAUserVariableCollection)
agcls.AgTypeNameMap["IVAUserVariableCollection"] = IVAUserVariableCollection

class IVAUserVariableUpdateCollection(object):
    """The list of User Variables accessed through an Update segment"""
    _uuid = "{7DC1728B-C032-4810-BE7B-7801C5CF906C}"
    _num_methods = 5
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAUserVariableUpdateCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAUserVariableUpdateCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAUserVariableUpdateCollection = agcom.GUID(IVAUserVariableUpdateCollection._uuid)
        vtable_offset_local = IVAUserVariableUpdateCollection._vtable_offset - 1
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariableUpdateCollection, vtable_offset_local+1, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariableUpdateCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariableUpdateCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariableUpdateCollection, vtable_offset_local+4, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariableUpdateCollection, vtable_offset_local+5, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAUserVariableUpdateCollection.__dict__ and type(IVAUserVariableUpdateCollection.__dict__[attrname]) == property:
            return IVAUserVariableUpdateCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAUserVariableUpdateCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVAUserVariableUpdate":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Item(self, indexOrName:typing.Any) -> "IVAUserVariableUpdate":
        """Allows you to iterate through the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppVAUserVariableUpdate:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppVAUserVariableUpdate.COM_val)))
            return arg_ppVAUserVariableUpdate.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def GetItemByIndex(self, index:int) -> "IVAUserVariableUpdate":
        """Retrieves a user variable update in the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppVAUserVariableUpdate:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppVAUserVariableUpdate.COM_val)))
            return arg_ppVAUserVariableUpdate.python_val

    def GetItemByName(self, name:str) -> "IVAUserVariableUpdate":
        """Retrieves a user variable update in the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppVAUserVariableUpdate:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppVAUserVariableUpdate.COM_val)))
            return arg_ppVAUserVariableUpdate.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{7DC1728B-C032-4810-BE7B-7801C5CF906C}", IVAUserVariableUpdateCollection)
agcls.AgTypeNameMap["IVAUserVariableUpdateCollection"] = IVAUserVariableUpdateCollection

class IVACalculationGraphCollection(object):
    """The list of Calculations Graphs to display."""
    _uuid = "{77FD67C8-A85F-42F8-8546-9E1B944FF7F9}"
    _num_methods = 6
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_Add"] = _raise_uninitialized_error
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_RemoveAll"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVACalculationGraphCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVACalculationGraphCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVACalculationGraphCollection = agcom.GUID(IVACalculationGraphCollection._uuid)
        vtable_offset_local = IVACalculationGraphCollection._vtable_offset - 1
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVACalculationGraphCollection, vtable_offset_local+1, agcom.LONG, POINTER(agcom.BSTR))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVACalculationGraphCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_Add"] = IAGFUNCTYPE(pUnk, IID_IVACalculationGraphCollection, vtable_offset_local+3, agcom.BSTR)
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IVACalculationGraphCollection, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_RemoveAll"] = IAGFUNCTYPE(pUnk, IID_IVACalculationGraphCollection, vtable_offset_local+5, )
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVACalculationGraphCollection, vtable_offset_local+6, POINTER(agcom.LONG))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVACalculationGraphCollection.__dict__ and type(IVACalculationGraphCollection.__dict__[attrname]) == property:
            return IVACalculationGraphCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVACalculationGraphCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> str:
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Item(self, index:int) -> str:
        """Allows you to iterate through the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_index.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Add(self, graphName:str) -> None:
        """Adds a calculation graph"""
        with agmarshall.BSTR_arg(graphName) as arg_graphName:
            agcls.evaluate_hresult(self.__dict__["_Add"](arg_graphName.COM_val))

    def Remove(self, graphName:str) -> None:
        """Removes a parameter."""
        with agmarshall.BSTR_arg(graphName) as arg_graphName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_graphName.COM_val))

    def RemoveAll(self) -> None:
        """Removes all parameters."""
        agcls.evaluate_hresult(self.__dict__["_RemoveAll"]())

    @property
    def Count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{77FD67C8-A85F-42F8-8546-9E1B944FF7F9}", IVACalculationGraphCollection)
agcls.AgTypeNameMap["IVACalculationGraphCollection"] = IVACalculationGraphCollection

class IVAConstraintCollection(object):
    """The list of constraints assigned to a stopping condition."""
    _uuid = "{055FF747-D60B-4AE2-82CE-B1FA61F85A3E}"
    _num_methods = 10
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Add"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_Cut"] = _raise_uninitialized_error
        self.__dict__["_Paste"] = _raise_uninitialized_error
        self.__dict__["_InsertCopy"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAConstraintCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAConstraintCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAConstraintCollection = agcom.GUID(IVAConstraintCollection._uuid)
        vtable_offset_local = IVAConstraintCollection._vtable_offset - 1
        self.__dict__["_Add"] = IAGFUNCTYPE(pUnk, IID_IVAConstraintCollection, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVAConstraintCollection, vtable_offset_local+2, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IVAConstraintCollection, vtable_offset_local+3, agcom.VARIANT)
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVAConstraintCollection, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVAConstraintCollection, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_Cut"] = IAGFUNCTYPE(pUnk, IID_IVAConstraintCollection, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_Paste"] = IAGFUNCTYPE(pUnk, IID_IVAConstraintCollection, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_InsertCopy"] = IAGFUNCTYPE(pUnk, IID_IVAConstraintCollection, vtable_offset_local+8, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IVAConstraintCollection, vtable_offset_local+9, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IVAConstraintCollection, vtable_offset_local+10, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAConstraintCollection.__dict__ and type(IVAConstraintCollection.__dict__[attrname]) == property:
            return IVAConstraintCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAConstraintCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVAAsTriggerCondition":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Add(self, resultName:str) -> "IVAAsTriggerCondition":
        """Adds a constraint to the collection."""
        with agmarshall.BSTR_arg(resultName) as arg_resultName, \
             agmarshall.AgInterface_out_arg() as arg_ppResult:
            agcls.evaluate_hresult(self.__dict__["_Add"](arg_resultName.COM_val, byref(arg_ppResult.COM_val)))
            return arg_ppResult.python_val

    def Item(self, indexOrName:typing.Any) -> "IVAAsTriggerCondition":
        """A property that allows you to iterate through the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppComponent:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppComponent.COM_val)))
            return arg_ppComponent.python_val

    def Remove(self, indexOrName:typing.Any) -> None:
        """Removes a specified constraint from the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_indexOrName.COM_val))

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """A property that allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def Cut(self, indexOrName:typing.Any) -> None:
        """Copies the constraint into the clipboard and removes the constraint from the list."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_Cut"](arg_indexOrName.COM_val))

    def Paste(self) -> "IVAAsTriggerCondition":
        """Pastes the constraint from the clipboard and inserts into the list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Paste"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def InsertCopy(self, cond:"IVAAsTriggerCondition") -> "IVAAsTriggerCondition":
        """Copies the constraint and inserts the copy into the list."""
        with agmarshall.AgInterface_in_arg(cond, IVAAsTriggerCondition) as arg_cond, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_InsertCopy"](arg_cond.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "IVAAsTriggerCondition":
        """Retrieves a constraint from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppComponent:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppComponent.COM_val)))
            return arg_ppComponent.python_val

    def GetItemByName(self, name:str) -> "IVAAsTriggerCondition":
        """Retrieves a constraint from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppComponent:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppComponent.COM_val)))
            return arg_ppComponent.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{055FF747-D60B-4AE2-82CE-B1FA61F85A3E}", IVAConstraintCollection)
agcls.AgTypeNameMap["IVAConstraintCollection"] = IVAConstraintCollection

class IVAPluginProperties(object):
    """Properties of a plugin attitude control."""
    _uuid = "{E4AEB83C-8A8A-48F2-8DB8-BA2F4299CC97}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetProperty"] = _raise_uninitialized_error
        self.__dict__["_SetProperty"] = _raise_uninitialized_error
        self.__dict__["_GetAvailableProperties"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAPluginProperties._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAPluginProperties from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAPluginProperties = agcom.GUID(IVAPluginProperties._uuid)
        vtable_offset_local = IVAPluginProperties._vtable_offset - 1
        self.__dict__["_GetProperty"] = IAGFUNCTYPE(pUnk, IID_IVAPluginProperties, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.VARIANT))
        self.__dict__["_SetProperty"] = IAGFUNCTYPE(pUnk, IID_IVAPluginProperties, vtable_offset_local+2, agcom.BSTR, agcom.VARIANT)
        self.__dict__["_GetAvailableProperties"] = IAGFUNCTYPE(pUnk, IID_IVAPluginProperties, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAPluginProperties.__dict__ and type(IVAPluginProperties.__dict__[attrname]) == property:
            return IVAPluginProperties.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAPluginProperties.")
    
    def GetProperty(self, path:str) -> typing.Any:
        """Method to get a property."""
        with agmarshall.BSTR_arg(path) as arg_path, \
             agmarshall.VARIANT_arg() as arg_pPropertyValue:
            agcls.evaluate_hresult(self.__dict__["_GetProperty"](arg_path.COM_val, byref(arg_pPropertyValue.COM_val)))
            return arg_pPropertyValue.python_val

    def SetProperty(self, path:str, propertyValue:typing.Any) -> None:
        """Method to set a property."""
        with agmarshall.BSTR_arg(path) as arg_path, \
             agmarshall.VARIANT_arg(propertyValue) as arg_propertyValue:
            agcls.evaluate_hresult(self.__dict__["_SetProperty"](arg_path.COM_val, arg_propertyValue.COM_val))

    @property
    def AvailableProperties(self) -> list:
        """Returns an array of all available properties."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailableProperties"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{E4AEB83C-8A8A-48F2-8DB8-BA2F4299CC97}", IVAPluginProperties)
agcls.AgTypeNameMap["IVAPluginProperties"] = IVAPluginProperties

class IVASNOPTControlCollection(object):
    """Properties for the list of SNOPT control parameters."""
    _uuid = "{2E9D2998-066F-4DC6-9672-8EDF9F604351}"
    _num_methods = 4
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetControlByPaths"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVASNOPTControlCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVASNOPTControlCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVASNOPTControlCollection = agcom.GUID(IVASNOPTControlCollection._uuid)
        vtable_offset_local = IVASNOPTControlCollection._vtable_offset - 1
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTControlCollection, vtable_offset_local+1, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTControlCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTControlCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_GetControlByPaths"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTControlCollection, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVASNOPTControlCollection.__dict__ and type(IVASNOPTControlCollection.__dict__[attrname]) == property:
            return IVASNOPTControlCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVASNOPTControlCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVASNOPTControl":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Item(self, index:int) -> "IVASNOPTControl":
        """Allows you to iterate through the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_sNOPTControl:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_index.COM_val, byref(arg_sNOPTControl.COM_val)))
            return arg_sNOPTControl.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def GetControlByPaths(self, objectPath:str, controlPath:str) -> "IVASNOPTControl":
        """Returns the control specified by the object/control path."""
        with agmarshall.BSTR_arg(objectPath) as arg_objectPath, \
             agmarshall.BSTR_arg(controlPath) as arg_controlPath, \
             agmarshall.AgInterface_out_arg() as arg_sNOPTControl:
            agcls.evaluate_hresult(self.__dict__["_GetControlByPaths"](arg_objectPath.COM_val, arg_controlPath.COM_val, byref(arg_sNOPTControl.COM_val)))
            return arg_sNOPTControl.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{2E9D2998-066F-4DC6-9672-8EDF9F604351}", IVASNOPTControlCollection)
agcls.AgTypeNameMap["IVASNOPTControlCollection"] = IVASNOPTControlCollection

class IVASNOPTResultCollection(object):
    """SNOPT result collection."""
    _uuid = "{53F7183C-7957-4C6F-8987-399A3F4C2A26}"
    _num_methods = 4
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetResultByPaths"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVASNOPTResultCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVASNOPTResultCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVASNOPTResultCollection = agcom.GUID(IVASNOPTResultCollection._uuid)
        vtable_offset_local = IVASNOPTResultCollection._vtable_offset - 1
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTResultCollection, vtable_offset_local+1, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTResultCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTResultCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_GetResultByPaths"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTResultCollection, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVASNOPTResultCollection.__dict__ and type(IVASNOPTResultCollection.__dict__[attrname]) == property:
            return IVASNOPTResultCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVASNOPTResultCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVASNOPTResult":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Item(self, index:int) -> "IVASNOPTResult":
        """Allows you to iterate through the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_sNOPTResult:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_index.COM_val, byref(arg_sNOPTResult.COM_val)))
            return arg_sNOPTResult.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def GetResultByPaths(self, objectPath:str, resultPath:str) -> "IVASNOPTResult":
        """Returns the result specified by the object/result names."""
        with agmarshall.BSTR_arg(objectPath) as arg_objectPath, \
             agmarshall.BSTR_arg(resultPath) as arg_resultPath, \
             agmarshall.AgInterface_out_arg() as arg_sNOPTResult:
            agcls.evaluate_hresult(self.__dict__["_GetResultByPaths"](arg_objectPath.COM_val, arg_resultPath.COM_val, byref(arg_sNOPTResult.COM_val)))
            return arg_sNOPTResult.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{53F7183C-7957-4C6F-8987-399A3F4C2A26}", IVASNOPTResultCollection)
agcls.AgTypeNameMap["IVASNOPTResultCollection"] = IVASNOPTResultCollection

class IVAIPOPTControlCollection(object):
    """Properties for the list of IPOPT control parameters."""
    _uuid = "{CAF26432-D3B9-4A8B-A9A2-9147DD520BBB}"
    _num_methods = 4
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetControlByPaths"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAIPOPTControlCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAIPOPTControlCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAIPOPTControlCollection = agcom.GUID(IVAIPOPTControlCollection._uuid)
        vtable_offset_local = IVAIPOPTControlCollection._vtable_offset - 1
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTControlCollection, vtable_offset_local+1, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTControlCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTControlCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_GetControlByPaths"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTControlCollection, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAIPOPTControlCollection.__dict__ and type(IVAIPOPTControlCollection.__dict__[attrname]) == property:
            return IVAIPOPTControlCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAIPOPTControlCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVAIPOPTControl":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Item(self, index:int) -> "IVAIPOPTControl":
        """Allows you to iterate through the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_iPOPTControl:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_index.COM_val, byref(arg_iPOPTControl.COM_val)))
            return arg_iPOPTControl.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def GetControlByPaths(self, objectPath:str, controlPath:str) -> "IVAIPOPTControl":
        """Returns the control specified by the object/control path."""
        with agmarshall.BSTR_arg(objectPath) as arg_objectPath, \
             agmarshall.BSTR_arg(controlPath) as arg_controlPath, \
             agmarshall.AgInterface_out_arg() as arg_iPOPTControl:
            agcls.evaluate_hresult(self.__dict__["_GetControlByPaths"](arg_objectPath.COM_val, arg_controlPath.COM_val, byref(arg_iPOPTControl.COM_val)))
            return arg_iPOPTControl.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{CAF26432-D3B9-4A8B-A9A2-9147DD520BBB}", IVAIPOPTControlCollection)
agcls.AgTypeNameMap["IVAIPOPTControlCollection"] = IVAIPOPTControlCollection

class IVAIPOPTResultCollection(object):
    """IPOPT result collection."""
    _uuid = "{DC5D0BFD-1459-4DAA-81B9-06790B157ED2}"
    _num_methods = 4
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetResultByPaths"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAIPOPTResultCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAIPOPTResultCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAIPOPTResultCollection = agcom.GUID(IVAIPOPTResultCollection._uuid)
        vtable_offset_local = IVAIPOPTResultCollection._vtable_offset - 1
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTResultCollection, vtable_offset_local+1, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTResultCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTResultCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_GetResultByPaths"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTResultCollection, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAIPOPTResultCollection.__dict__ and type(IVAIPOPTResultCollection.__dict__[attrname]) == property:
            return IVAIPOPTResultCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAIPOPTResultCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVAIPOPTResult":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Item(self, index:int) -> "IVAIPOPTResult":
        """Allows you to iterate through the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_iPOPTResult:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_index.COM_val, byref(arg_iPOPTResult.COM_val)))
            return arg_iPOPTResult.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def GetResultByPaths(self, objectPath:str, resultPath:str) -> "IVAIPOPTResult":
        """Returns the result specified by the object/result names."""
        with agmarshall.BSTR_arg(objectPath) as arg_objectPath, \
             agmarshall.BSTR_arg(resultPath) as arg_resultPath, \
             agmarshall.AgInterface_out_arg() as arg_iPOPTResult:
            agcls.evaluate_hresult(self.__dict__["_GetResultByPaths"](arg_objectPath.COM_val, arg_resultPath.COM_val, byref(arg_iPOPTResult.COM_val)))
            return arg_iPOPTResult.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{DC5D0BFD-1459-4DAA-81B9-06790B157ED2}", IVAIPOPTResultCollection)
agcls.AgTypeNameMap["IVAIPOPTResultCollection"] = IVAIPOPTResultCollection

class IVAManeuverOptimalFiniteSNOPTOptimizer(object):
    """Properties of SNOPT Optimizer options for optimal finite maneuver."""
    _uuid = "{176AB7BE-90C8-4558-8E24-9E9862CE18FD}"
    _num_methods = 21
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetObjective"] = _raise_uninitialized_error
        self.__dict__["_SetObjective"] = _raise_uninitialized_error
        self.__dict__["_GetMaxMajorIterations"] = _raise_uninitialized_error
        self.__dict__["_SetMaxMajorIterations"] = _raise_uninitialized_error
        self.__dict__["_GetToleranceOnMajorFeasibility"] = _raise_uninitialized_error
        self.__dict__["_SetToleranceOnMajorFeasibility"] = _raise_uninitialized_error
        self.__dict__["_GetToleranceOnMajorOptimality"] = _raise_uninitialized_error
        self.__dict__["_SetToleranceOnMajorOptimality"] = _raise_uninitialized_error
        self.__dict__["_GetMaxMinorIterations"] = _raise_uninitialized_error
        self.__dict__["_SetMaxMinorIterations"] = _raise_uninitialized_error
        self.__dict__["_GetToleranceOnMinorFeasibility"] = _raise_uninitialized_error
        self.__dict__["_SetToleranceOnMinorFeasibility"] = _raise_uninitialized_error
        self.__dict__["_GetOptionsFilename"] = _raise_uninitialized_error
        self.__dict__["_SetOptionsFilename"] = _raise_uninitialized_error
        self.__dict__["_GetProvideRuntimeTypeInfo"] = _raise_uninitialized_error
        self.__dict__["_GetUseConsoleMonitor"] = _raise_uninitialized_error
        self.__dict__["_SetUseConsoleMonitor"] = _raise_uninitialized_error
        self.__dict__["_GetAllowInternalPrimalInfeasibilityMeasureNormalization"] = _raise_uninitialized_error
        self.__dict__["_SetAllowInternalPrimalInfeasibilityMeasureNormalization"] = _raise_uninitialized_error
        self.__dict__["_GetSNOPTScaling"] = _raise_uninitialized_error
        self.__dict__["_SetSNOPTScaling"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAManeuverOptimalFiniteSNOPTOptimizer._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAManeuverOptimalFiniteSNOPTOptimizer from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAManeuverOptimalFiniteSNOPTOptimizer = agcom.GUID(IVAManeuverOptimalFiniteSNOPTOptimizer._uuid)
        vtable_offset_local = IVAManeuverOptimalFiniteSNOPTOptimizer._vtable_offset - 1
        self.__dict__["_GetObjective"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetObjective"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetMaxMajorIterations"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetMaxMajorIterations"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetToleranceOnMajorFeasibility"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetToleranceOnMajorFeasibility"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetToleranceOnMajorOptimality"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetToleranceOnMajorOptimality"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetMaxMinorIterations"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_SetMaxMinorIterations"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_GetToleranceOnMinorFeasibility"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetToleranceOnMinorFeasibility"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetOptionsFilename"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+13, POINTER(agcom.BSTR))
        self.__dict__["_SetOptionsFilename"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+14, agcom.BSTR)
        self.__dict__["_GetProvideRuntimeTypeInfo"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+15, POINTER(agcom.PVOID))
        self.__dict__["_GetUseConsoleMonitor"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+16, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseConsoleMonitor"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+17, agcom.VARIANT_BOOL)
        self.__dict__["_GetAllowInternalPrimalInfeasibilityMeasureNormalization"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+18, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetAllowInternalPrimalInfeasibilityMeasureNormalization"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+19, agcom.VARIANT_BOOL)
        self.__dict__["_GetSNOPTScaling"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+20, POINTER(agcom.LONG))
        self.__dict__["_SetSNOPTScaling"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+21, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAManeuverOptimalFiniteSNOPTOptimizer.__dict__ and type(IVAManeuverOptimalFiniteSNOPTOptimizer.__dict__[attrname]) == property:
            return IVAManeuverOptimalFiniteSNOPTOptimizer.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAManeuverOptimalFiniteSNOPTOptimizer.")
    
    @property
    def Objective(self) -> "AgEVAOptimalFiniteSNOPTObjective":
        """Objective."""
        with agmarshall.AgEnum_arg(AgEVAOptimalFiniteSNOPTObjective) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetObjective"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Objective.setter
    def Objective(self, newVal:"AgEVAOptimalFiniteSNOPTObjective") -> None:
        with agmarshall.AgEnum_arg(AgEVAOptimalFiniteSNOPTObjective, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetObjective"](arg_newVal.COM_val))

    @property
    def MaxMajorIterations(self) -> int:
        """The maximum number of major iterations allowed."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxMajorIterations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxMajorIterations.setter
    def MaxMajorIterations(self, newVal:int) -> None:
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxMajorIterations"](arg_newVal.COM_val))

    @property
    def ToleranceOnMajorFeasibility(self) -> float:
        """Specifies how accurately the nonlinear constraints should be satisfied."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetToleranceOnMajorFeasibility"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ToleranceOnMajorFeasibility.setter
    def ToleranceOnMajorFeasibility(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetToleranceOnMajorFeasibility"](arg_newVal.COM_val))

    @property
    def ToleranceOnMajorOptimality(self) -> float:
        """Specifies the final accuracy of the dual variables."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetToleranceOnMajorOptimality"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ToleranceOnMajorOptimality.setter
    def ToleranceOnMajorOptimality(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetToleranceOnMajorOptimality"](arg_newVal.COM_val))

    @property
    def MaxMinorIterations(self) -> int:
        """The maximum number of iterations for the QP subproblem allowed during a single major iteration."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxMinorIterations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxMinorIterations.setter
    def MaxMinorIterations(self, newVal:int) -> None:
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxMinorIterations"](arg_newVal.COM_val))

    @property
    def ToleranceOnMinorFeasibility(self) -> float:
        """The tolerance which the QP subproblem must meet before being considered feasible."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetToleranceOnMinorFeasibility"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ToleranceOnMinorFeasibility.setter
    def ToleranceOnMinorFeasibility(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetToleranceOnMinorFeasibility"](arg_newVal.COM_val))

    @property
    def OptionsFilename(self) -> str:
        """If used, the associated SNOPT specifications file may define any of the various SNOPT options. Options in the file that conflict with options specified elsewhere will take precedence."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetOptionsFilename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @OptionsFilename.setter
    def OptionsFilename(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetOptionsFilename"](arg_newVal.COM_val))

    @property
    def ProvideRuntimeTypeInfo(self) -> "IRuntimeTypeInfo":
        """Returns the IAgRuntimeTypeInfo interface to access properties at runtime."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProvideRuntimeTypeInfo"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def UseConsoleMonitor(self) -> bool:
        """Whether to use the out-of-process console monitor for the optimizer."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseConsoleMonitor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseConsoleMonitor.setter
    def UseConsoleMonitor(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseConsoleMonitor"](arg_newVal.COM_val))

    @property
    def AllowInternalPrimalInfeasibilityMeasureNormalization(self) -> bool:
        """Whether to allow internal normalization of the primal infeasibility measure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAllowInternalPrimalInfeasibilityMeasureNormalization"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AllowInternalPrimalInfeasibilityMeasureNormalization.setter
    def AllowInternalPrimalInfeasibilityMeasureNormalization(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetAllowInternalPrimalInfeasibilityMeasureNormalization"](arg_newVal.COM_val))

    @property
    def SNOPTScaling(self) -> "AgEVAOptimalFiniteSNOPTScaling":
        """SNOPT scaling option."""
        with agmarshall.AgEnum_arg(AgEVAOptimalFiniteSNOPTScaling) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSNOPTScaling"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SNOPTScaling.setter
    def SNOPTScaling(self, newVal:"AgEVAOptimalFiniteSNOPTScaling") -> None:
        with agmarshall.AgEnum_arg(AgEVAOptimalFiniteSNOPTScaling, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetSNOPTScaling"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{176AB7BE-90C8-4558-8E24-9E9862CE18FD}", IVAManeuverOptimalFiniteSNOPTOptimizer)
agcls.AgTypeNameMap["IVAManeuverOptimalFiniteSNOPTOptimizer"] = IVAManeuverOptimalFiniteSNOPTOptimizer

class IVAManeuverOptimalFiniteInitialBoundaryConditions(object):
    """Properties of initial boundary conditions for optimal finite maneuver."""
    _uuid = "{872A109F-710B-49D4-9A7D-544E7044530B}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSetFromInitialGuess"] = _raise_uninitialized_error
        self.__dict__["_SetSetFromInitialGuess"] = _raise_uninitialized_error
        self.__dict__["_Geta"] = _raise_uninitialized_error
        self.__dict__["_Geth"] = _raise_uninitialized_error
        self.__dict__["_Getk"] = _raise_uninitialized_error
        self.__dict__["_Getp"] = _raise_uninitialized_error
        self.__dict__["_Getq"] = _raise_uninitialized_error
        self.__dict__["_GetL"] = _raise_uninitialized_error
        self.__dict__["_GetProvideRuntimeTypeInfo"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAManeuverOptimalFiniteInitialBoundaryConditions._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAManeuverOptimalFiniteInitialBoundaryConditions from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAManeuverOptimalFiniteInitialBoundaryConditions = agcom.GUID(IVAManeuverOptimalFiniteInitialBoundaryConditions._uuid)
        vtable_offset_local = IVAManeuverOptimalFiniteInitialBoundaryConditions._vtable_offset - 1
        self.__dict__["_GetSetFromInitialGuess"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteInitialBoundaryConditions, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetSetFromInitialGuess"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteInitialBoundaryConditions, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_Geta"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteInitialBoundaryConditions, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_Geth"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteInitialBoundaryConditions, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_Getk"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteInitialBoundaryConditions, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Getp"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteInitialBoundaryConditions, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_Getq"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteInitialBoundaryConditions, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetL"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteInitialBoundaryConditions, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_GetProvideRuntimeTypeInfo"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteInitialBoundaryConditions, vtable_offset_local+9, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAManeuverOptimalFiniteInitialBoundaryConditions.__dict__ and type(IVAManeuverOptimalFiniteInitialBoundaryConditions.__dict__[attrname]) == property:
            return IVAManeuverOptimalFiniteInitialBoundaryConditions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAManeuverOptimalFiniteInitialBoundaryConditions.")
    
    @property
    def SetFromInitialGuess(self) -> bool:
        """Set initial boundary condiitons from initial guess."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSetFromInitialGuess"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SetFromInitialGuess.setter
    def SetFromInitialGuess(self, newVal:bool) -> None:
        """Set initial boundary condiitons from initial guess."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetSetFromInitialGuess"](arg_newVal.COM_val))

    @property
    def a(self) -> "IVAManeuverOptimalFiniteBounds":
        """Bound limits for element a."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteBounds:
            agcls.evaluate_hresult(self.__dict__["_Geta"](byref(arg_ppAgVAManeuverOptimalFiniteBounds.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteBounds.python_val

    @property
    def h(self) -> "IVAManeuverOptimalFiniteBounds":
        """Bound limits for element h."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteBounds:
            agcls.evaluate_hresult(self.__dict__["_Geth"](byref(arg_ppAgVAManeuverOptimalFiniteBounds.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteBounds.python_val

    @property
    def k(self) -> "IVAManeuverOptimalFiniteBounds":
        """Bound limits for element k."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteBounds:
            agcls.evaluate_hresult(self.__dict__["_Getk"](byref(arg_ppAgVAManeuverOptimalFiniteBounds.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteBounds.python_val

    @property
    def p(self) -> "IVAManeuverOptimalFiniteBounds":
        """Bound limits for element p."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteBounds:
            agcls.evaluate_hresult(self.__dict__["_Getp"](byref(arg_ppAgVAManeuverOptimalFiniteBounds.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteBounds.python_val

    @property
    def q(self) -> "IVAManeuverOptimalFiniteBounds":
        """Bound limits for element q."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteBounds:
            agcls.evaluate_hresult(self.__dict__["_Getq"](byref(arg_ppAgVAManeuverOptimalFiniteBounds.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteBounds.python_val

    @property
    def L(self) -> "IVAManeuverOptimalFiniteBounds":
        """Bound limits for element L."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteBounds:
            agcls.evaluate_hresult(self.__dict__["_GetL"](byref(arg_ppAgVAManeuverOptimalFiniteBounds.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteBounds.python_val

    @property
    def ProvideRuntimeTypeInfo(self) -> "IRuntimeTypeInfo":
        """Returns the IAgRuntimeTypeInfo interface to access properties at runtime."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProvideRuntimeTypeInfo"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{872A109F-710B-49D4-9A7D-544E7044530B}", IVAManeuverOptimalFiniteInitialBoundaryConditions)
agcls.AgTypeNameMap["IVAManeuverOptimalFiniteInitialBoundaryConditions"] = IVAManeuverOptimalFiniteInitialBoundaryConditions

class IVAManeuverOptimalFiniteFinalBoundaryConditions(object):
    """Properties of final boundary conditions for optimal finite maneuver."""
    _uuid = "{476E5210-09E8-4DD7-ABCC-AF09E67DB21D}"
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSetFromFinalGuess"] = _raise_uninitialized_error
        self.__dict__["_SetSetFromFinalGuess"] = _raise_uninitialized_error
        self.__dict__["_Geta"] = _raise_uninitialized_error
        self.__dict__["_Geth"] = _raise_uninitialized_error
        self.__dict__["_Getk"] = _raise_uninitialized_error
        self.__dict__["_Getp"] = _raise_uninitialized_error
        self.__dict__["_Getq"] = _raise_uninitialized_error
        self.__dict__["_GetL"] = _raise_uninitialized_error
        self.__dict__["_GetLowerDeltaFinalTime"] = _raise_uninitialized_error
        self.__dict__["_SetLowerDeltaFinalTime"] = _raise_uninitialized_error
        self.__dict__["_GetUpperDeltaFinalTime"] = _raise_uninitialized_error
        self.__dict__["_SetUpperDeltaFinalTime"] = _raise_uninitialized_error
        self.__dict__["_GetProvideRuntimeTypeInfo"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAManeuverOptimalFiniteFinalBoundaryConditions._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAManeuverOptimalFiniteFinalBoundaryConditions from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAManeuverOptimalFiniteFinalBoundaryConditions = agcom.GUID(IVAManeuverOptimalFiniteFinalBoundaryConditions._uuid)
        vtable_offset_local = IVAManeuverOptimalFiniteFinalBoundaryConditions._vtable_offset - 1
        self.__dict__["_GetSetFromFinalGuess"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteFinalBoundaryConditions, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetSetFromFinalGuess"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteFinalBoundaryConditions, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_Geta"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteFinalBoundaryConditions, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_Geth"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteFinalBoundaryConditions, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_Getk"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteFinalBoundaryConditions, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Getp"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteFinalBoundaryConditions, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_Getq"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteFinalBoundaryConditions, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetL"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteFinalBoundaryConditions, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_GetLowerDeltaFinalTime"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteFinalBoundaryConditions, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetLowerDeltaFinalTime"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteFinalBoundaryConditions, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetUpperDeltaFinalTime"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteFinalBoundaryConditions, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetUpperDeltaFinalTime"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteFinalBoundaryConditions, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetProvideRuntimeTypeInfo"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteFinalBoundaryConditions, vtable_offset_local+13, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAManeuverOptimalFiniteFinalBoundaryConditions.__dict__ and type(IVAManeuverOptimalFiniteFinalBoundaryConditions.__dict__[attrname]) == property:
            return IVAManeuverOptimalFiniteFinalBoundaryConditions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAManeuverOptimalFiniteFinalBoundaryConditions.")
    
    @property
    def SetFromFinalGuess(self) -> bool:
        """Set initial boundary conditions from initial guess."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSetFromFinalGuess"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SetFromFinalGuess.setter
    def SetFromFinalGuess(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetSetFromFinalGuess"](arg_newVal.COM_val))

    @property
    def a(self) -> "IVAManeuverOptimalFiniteBounds":
        """Bound limits for element a."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteBounds:
            agcls.evaluate_hresult(self.__dict__["_Geta"](byref(arg_ppAgVAManeuverOptimalFiniteBounds.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteBounds.python_val

    @property
    def h(self) -> "IVAManeuverOptimalFiniteBounds":
        """Bound limits for element h."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteBounds:
            agcls.evaluate_hresult(self.__dict__["_Geth"](byref(arg_ppAgVAManeuverOptimalFiniteBounds.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteBounds.python_val

    @property
    def k(self) -> "IVAManeuverOptimalFiniteBounds":
        """Bound limits for element k."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteBounds:
            agcls.evaluate_hresult(self.__dict__["_Getk"](byref(arg_ppAgVAManeuverOptimalFiniteBounds.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteBounds.python_val

    @property
    def p(self) -> "IVAManeuverOptimalFiniteBounds":
        """Bound limits for element p."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteBounds:
            agcls.evaluate_hresult(self.__dict__["_Getp"](byref(arg_ppAgVAManeuverOptimalFiniteBounds.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteBounds.python_val

    @property
    def q(self) -> "IVAManeuverOptimalFiniteBounds":
        """Bound limits for element q."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteBounds:
            agcls.evaluate_hresult(self.__dict__["_Getq"](byref(arg_ppAgVAManeuverOptimalFiniteBounds.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteBounds.python_val

    @property
    def L(self) -> "IVAManeuverOptimalFiniteBounds":
        """Bound limits for element L."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteBounds:
            agcls.evaluate_hresult(self.__dict__["_GetL"](byref(arg_ppAgVAManeuverOptimalFiniteBounds.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteBounds.python_val

    @property
    def LowerDeltaFinalTime(self) -> float:
        """Lower delta for final time"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLowerDeltaFinalTime"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @LowerDeltaFinalTime.setter
    def LowerDeltaFinalTime(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetLowerDeltaFinalTime"](arg_newVal.COM_val))

    @property
    def UpperDeltaFinalTime(self) -> float:
        """Upper delta for final time"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUpperDeltaFinalTime"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UpperDeltaFinalTime.setter
    def UpperDeltaFinalTime(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetUpperDeltaFinalTime"](arg_newVal.COM_val))

    @property
    def ProvideRuntimeTypeInfo(self) -> "IRuntimeTypeInfo":
        """Returns the IAgRuntimeTypeInfo interface to access properties at runtime."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProvideRuntimeTypeInfo"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{476E5210-09E8-4DD7-ABCC-AF09E67DB21D}", IVAManeuverOptimalFiniteFinalBoundaryConditions)
agcls.AgTypeNameMap["IVAManeuverOptimalFiniteFinalBoundaryConditions"] = IVAManeuverOptimalFiniteFinalBoundaryConditions

class IVAManeuverOptimalFinitePathBoundaryConditions(object):
    """Properties of path boundary conditions for optimal finite maneuver."""
    _uuid = "{BF41B9E6-80DE-4E15-8E36-00D735E7B40D}"
    _num_methods = 17
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetComputeFromInitialGuess"] = _raise_uninitialized_error
        self.__dict__["_SetComputeFromInitialGuess"] = _raise_uninitialized_error
        self.__dict__["_Geta"] = _raise_uninitialized_error
        self.__dict__["_Geth"] = _raise_uninitialized_error
        self.__dict__["_Getk"] = _raise_uninitialized_error
        self.__dict__["_Getp"] = _raise_uninitialized_error
        self.__dict__["_Getq"] = _raise_uninitialized_error
        self.__dict__["_GetL"] = _raise_uninitialized_error
        self.__dict__["_GetLowerBoundAzimuth"] = _raise_uninitialized_error
        self.__dict__["_SetLowerBoundAzimuth"] = _raise_uninitialized_error
        self.__dict__["_GetUpperBoundAzimuth"] = _raise_uninitialized_error
        self.__dict__["_SetUpperBoundAzimuth"] = _raise_uninitialized_error
        self.__dict__["_GetLowerBoundElevation"] = _raise_uninitialized_error
        self.__dict__["_SetLowerBoundElevation"] = _raise_uninitialized_error
        self.__dict__["_GetUpperBoundElevation"] = _raise_uninitialized_error
        self.__dict__["_SetUpperBoundElevation"] = _raise_uninitialized_error
        self.__dict__["_GetProvideRuntimeTypeInfo"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAManeuverOptimalFinitePathBoundaryConditions._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAManeuverOptimalFinitePathBoundaryConditions from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAManeuverOptimalFinitePathBoundaryConditions = agcom.GUID(IVAManeuverOptimalFinitePathBoundaryConditions._uuid)
        vtable_offset_local = IVAManeuverOptimalFinitePathBoundaryConditions._vtable_offset - 1
        self.__dict__["_GetComputeFromInitialGuess"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinitePathBoundaryConditions, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetComputeFromInitialGuess"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinitePathBoundaryConditions, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_Geta"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinitePathBoundaryConditions, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_Geth"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinitePathBoundaryConditions, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_Getk"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinitePathBoundaryConditions, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_Getp"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinitePathBoundaryConditions, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_Getq"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinitePathBoundaryConditions, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetL"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinitePathBoundaryConditions, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_GetLowerBoundAzimuth"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinitePathBoundaryConditions, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetLowerBoundAzimuth"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinitePathBoundaryConditions, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetUpperBoundAzimuth"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinitePathBoundaryConditions, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetUpperBoundAzimuth"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinitePathBoundaryConditions, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetLowerBoundElevation"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinitePathBoundaryConditions, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetLowerBoundElevation"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinitePathBoundaryConditions, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetUpperBoundElevation"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinitePathBoundaryConditions, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_SetUpperBoundElevation"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinitePathBoundaryConditions, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_GetProvideRuntimeTypeInfo"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinitePathBoundaryConditions, vtable_offset_local+17, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAManeuverOptimalFinitePathBoundaryConditions.__dict__ and type(IVAManeuverOptimalFinitePathBoundaryConditions.__dict__[attrname]) == property:
            return IVAManeuverOptimalFinitePathBoundaryConditions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAManeuverOptimalFinitePathBoundaryConditions.")
    
    @property
    def ComputeFromInitialGuess(self) -> bool:
        """Compute path boundary condiitons from initial guess."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputeFromInitialGuess"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ComputeFromInitialGuess.setter
    def ComputeFromInitialGuess(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetComputeFromInitialGuess"](arg_newVal.COM_val))

    @property
    def a(self) -> "IVAManeuverOptimalFiniteBounds":
        """Bound limits for element a."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteBounds:
            agcls.evaluate_hresult(self.__dict__["_Geta"](byref(arg_ppAgVAManeuverOptimalFiniteBounds.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteBounds.python_val

    @property
    def h(self) -> "IVAManeuverOptimalFiniteBounds":
        """Bound limits for element h."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteBounds:
            agcls.evaluate_hresult(self.__dict__["_Geth"](byref(arg_ppAgVAManeuverOptimalFiniteBounds.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteBounds.python_val

    @property
    def k(self) -> "IVAManeuverOptimalFiniteBounds":
        """Bound limits for element k."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteBounds:
            agcls.evaluate_hresult(self.__dict__["_Getk"](byref(arg_ppAgVAManeuverOptimalFiniteBounds.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteBounds.python_val

    @property
    def p(self) -> "IVAManeuverOptimalFiniteBounds":
        """Bound limits for element p."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteBounds:
            agcls.evaluate_hresult(self.__dict__["_Getp"](byref(arg_ppAgVAManeuverOptimalFiniteBounds.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteBounds.python_val

    @property
    def q(self) -> "IVAManeuverOptimalFiniteBounds":
        """Bound limits for element q."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteBounds:
            agcls.evaluate_hresult(self.__dict__["_Getq"](byref(arg_ppAgVAManeuverOptimalFiniteBounds.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteBounds.python_val

    @property
    def L(self) -> "IVAManeuverOptimalFiniteBounds":
        """Bound limits for element L."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteBounds:
            agcls.evaluate_hresult(self.__dict__["_GetL"](byref(arg_ppAgVAManeuverOptimalFiniteBounds.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteBounds.python_val

    @property
    def LowerBoundAzimuth(self) -> float:
        """Thrust direction azimuth lower bound along the path"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLowerBoundAzimuth"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @LowerBoundAzimuth.setter
    def LowerBoundAzimuth(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetLowerBoundAzimuth"](arg_newVal.COM_val))

    @property
    def UpperBoundAzimuth(self) -> float:
        """Thrust direction azimuth upper bound along the path"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUpperBoundAzimuth"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UpperBoundAzimuth.setter
    def UpperBoundAzimuth(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetUpperBoundAzimuth"](arg_newVal.COM_val))

    @property
    def LowerBoundElevation(self) -> float:
        """Thrust direction elevation lower bound along the path"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLowerBoundElevation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @LowerBoundElevation.setter
    def LowerBoundElevation(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetLowerBoundElevation"](arg_newVal.COM_val))

    @property
    def UpperBoundElevation(self) -> float:
        """Thrust direction elevation upper bound along the path"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUpperBoundElevation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UpperBoundElevation.setter
    def UpperBoundElevation(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetUpperBoundElevation"](arg_newVal.COM_val))

    @property
    def ProvideRuntimeTypeInfo(self) -> "IRuntimeTypeInfo":
        """Returns the IAgRuntimeTypeInfo interface to access properties at runtime."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProvideRuntimeTypeInfo"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{BF41B9E6-80DE-4E15-8E36-00D735E7B40D}", IVAManeuverOptimalFinitePathBoundaryConditions)
agcls.AgTypeNameMap["IVAManeuverOptimalFinitePathBoundaryConditions"] = IVAManeuverOptimalFinitePathBoundaryConditions

class IVAManeuverOptimalFiniteSteeringNodeCollection(object):
    """Steering/nodes collection."""
    _uuid = "{1808D2D6-FAB4-4750-AE06-B37D95779815}"
    _num_methods = 3
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAManeuverOptimalFiniteSteeringNodeCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAManeuverOptimalFiniteSteeringNodeCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAManeuverOptimalFiniteSteeringNodeCollection = agcom.GUID(IVAManeuverOptimalFiniteSteeringNodeCollection._uuid)
        vtable_offset_local = IVAManeuverOptimalFiniteSteeringNodeCollection._vtable_offset - 1
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSteeringNodeCollection, vtable_offset_local+1, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSteeringNodeCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSteeringNodeCollection, vtable_offset_local+3, POINTER(agcom.LONG))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAManeuverOptimalFiniteSteeringNodeCollection.__dict__ and type(IVAManeuverOptimalFiniteSteeringNodeCollection.__dict__[attrname]) == property:
            return IVAManeuverOptimalFiniteSteeringNodeCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAManeuverOptimalFiniteSteeringNodeCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVAManeuverOptimalFiniteSteeringNodeElement":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Item(self, index:int) -> "IVAManeuverOptimalFiniteSteeringNodeElement":
        """Allows you to iterate through the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_steeringNodeElement:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_index.COM_val, byref(arg_steeringNodeElement.COM_val)))
            return arg_steeringNodeElement.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{1808D2D6-FAB4-4750-AE06-B37D95779815}", IVAManeuverOptimalFiniteSteeringNodeCollection)
agcls.AgTypeNameMap["IVAManeuverOptimalFiniteSteeringNodeCollection"] = IVAManeuverOptimalFiniteSteeringNodeCollection

class IVAManeuverOptimalFiniteBounds(object):
    """The bounds for boundary interfaces."""
    _uuid = "{E2B960BB-5091-43DE-91DD-53D6E0EFA61D}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetLowerBound"] = _raise_uninitialized_error
        self.__dict__["_SetLowerBound"] = _raise_uninitialized_error
        self.__dict__["_GetUpperBound"] = _raise_uninitialized_error
        self.__dict__["_SetUpperBound"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAManeuverOptimalFiniteBounds._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAManeuverOptimalFiniteBounds from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAManeuverOptimalFiniteBounds = agcom.GUID(IVAManeuverOptimalFiniteBounds._uuid)
        vtable_offset_local = IVAManeuverOptimalFiniteBounds._vtable_offset - 1
        self.__dict__["_GetLowerBound"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteBounds, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetLowerBound"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteBounds, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetUpperBound"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteBounds, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetUpperBound"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteBounds, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAManeuverOptimalFiniteBounds.__dict__ and type(IVAManeuverOptimalFiniteBounds.__dict__[attrname]) == property:
            return IVAManeuverOptimalFiniteBounds.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAManeuverOptimalFiniteBounds.")
    
    @property
    def LowerBound(self) -> float:
        """Lower bound for a boundary element."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLowerBound"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @LowerBound.setter
    def LowerBound(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetLowerBound"](arg_newVal.COM_val))

    @property
    def UpperBound(self) -> float:
        """Upper bound for a boundary element."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUpperBound"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UpperBound.setter
    def UpperBound(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetUpperBound"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E2B960BB-5091-43DE-91DD-53D6E0EFA61D}", IVAManeuverOptimalFiniteBounds)
agcls.AgTypeNameMap["IVAManeuverOptimalFiniteBounds"] = IVAManeuverOptimalFiniteBounds

class IVAGoldenSectionControlCollection(object):
    """Properties for the list of Golden Section control parameters."""
    _uuid = "{1E3A8FAA-05F5-4519-A63A-C793CCE4C27A}"
    _num_methods = 4
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetControlByPaths"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAGoldenSectionControlCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAGoldenSectionControlCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAGoldenSectionControlCollection = agcom.GUID(IVAGoldenSectionControlCollection._uuid)
        vtable_offset_local = IVAGoldenSectionControlCollection._vtable_offset - 1
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVAGoldenSectionControlCollection, vtable_offset_local+1, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVAGoldenSectionControlCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVAGoldenSectionControlCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_GetControlByPaths"] = IAGFUNCTYPE(pUnk, IID_IVAGoldenSectionControlCollection, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAGoldenSectionControlCollection.__dict__ and type(IVAGoldenSectionControlCollection.__dict__[attrname]) == property:
            return IVAGoldenSectionControlCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAGoldenSectionControlCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVAGoldenSectionControl":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Item(self, index:int) -> "IVAGoldenSectionControl":
        """Allows you to iterate through the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_goldenSectionControl:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_index.COM_val, byref(arg_goldenSectionControl.COM_val)))
            return arg_goldenSectionControl.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def GetControlByPaths(self, objectPath:str, controlPath:str) -> "IVAGoldenSectionControl":
        """Returns the control specified by the object/control path."""
        with agmarshall.BSTR_arg(objectPath) as arg_objectPath, \
             agmarshall.BSTR_arg(controlPath) as arg_controlPath, \
             agmarshall.AgInterface_out_arg() as arg_goldenSectionControl:
            agcls.evaluate_hresult(self.__dict__["_GetControlByPaths"](arg_objectPath.COM_val, arg_controlPath.COM_val, byref(arg_goldenSectionControl.COM_val)))
            return arg_goldenSectionControl.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{1E3A8FAA-05F5-4519-A63A-C793CCE4C27A}", IVAGoldenSectionControlCollection)
agcls.AgTypeNameMap["IVAGoldenSectionControlCollection"] = IVAGoldenSectionControlCollection

class IVAGoldenSectionControl(object):
    """Properties for control parameters of a Golden Section profile."""
    _uuid = "{91407E31-8792-460C-AE98-32CF4690D53F}"
    _num_methods = 15
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEnable"] = _raise_uninitialized_error
        self.__dict__["_SetEnable"] = _raise_uninitialized_error
        self.__dict__["_GetName"] = _raise_uninitialized_error
        self.__dict__["_GetParentName"] = _raise_uninitialized_error
        self.__dict__["_GetCurrentValue"] = _raise_uninitialized_error
        self.__dict__["_GetLowerBound"] = _raise_uninitialized_error
        self.__dict__["_SetLowerBound"] = _raise_uninitialized_error
        self.__dict__["_GetUpperBound"] = _raise_uninitialized_error
        self.__dict__["_SetUpperBound"] = _raise_uninitialized_error
        self.__dict__["_GetUseCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_SetUseCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_GetCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_SetCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_GetTolerance"] = _raise_uninitialized_error
        self.__dict__["_SetTolerance"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAGoldenSectionControl._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAGoldenSectionControl from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAGoldenSectionControl = agcom.GUID(IVAGoldenSectionControl._uuid)
        vtable_offset_local = IVAGoldenSectionControl._vtable_offset - 1
        self.__dict__["_GetEnable"] = IAGFUNCTYPE(pUnk, IID_IVAGoldenSectionControl, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnable"] = IAGFUNCTYPE(pUnk, IID_IVAGoldenSectionControl, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetName"] = IAGFUNCTYPE(pUnk, IID_IVAGoldenSectionControl, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_GetParentName"] = IAGFUNCTYPE(pUnk, IID_IVAGoldenSectionControl, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_GetCurrentValue"] = IAGFUNCTYPE(pUnk, IID_IVAGoldenSectionControl, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_GetLowerBound"] = IAGFUNCTYPE(pUnk, IID_IVAGoldenSectionControl, vtable_offset_local+6, POINTER(agcom.VARIANT))
        self.__dict__["_SetLowerBound"] = IAGFUNCTYPE(pUnk, IID_IVAGoldenSectionControl, vtable_offset_local+7, agcom.VARIANT)
        self.__dict__["_GetUpperBound"] = IAGFUNCTYPE(pUnk, IID_IVAGoldenSectionControl, vtable_offset_local+8, POINTER(agcom.VARIANT))
        self.__dict__["_SetUpperBound"] = IAGFUNCTYPE(pUnk, IID_IVAGoldenSectionControl, vtable_offset_local+9, agcom.VARIANT)
        self.__dict__["_GetUseCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVAGoldenSectionControl, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVAGoldenSectionControl, vtable_offset_local+11, agcom.VARIANT_BOOL)
        self.__dict__["_GetCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVAGoldenSectionControl, vtable_offset_local+12, POINTER(agcom.BSTR))
        self.__dict__["_SetCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVAGoldenSectionControl, vtable_offset_local+13, agcom.BSTR)
        self.__dict__["_GetTolerance"] = IAGFUNCTYPE(pUnk, IID_IVAGoldenSectionControl, vtable_offset_local+14, POINTER(agcom.VARIANT))
        self.__dict__["_SetTolerance"] = IAGFUNCTYPE(pUnk, IID_IVAGoldenSectionControl, vtable_offset_local+15, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAGoldenSectionControl.__dict__ and type(IVAGoldenSectionControl.__dict__[attrname]) == property:
            return IVAGoldenSectionControl.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAGoldenSectionControl.")
    
    @property
    def Enable(self) -> bool:
        """If true, the variable is being used."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Enable.setter
    def Enable(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnable"](arg_newVal.COM_val))

    @property
    def Name(self) -> str:
        """The name of the parameter."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ParentName(self) -> str:
        """The name of the segment to which the parameter belongs."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetParentName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def CurrentValue(self) -> typing.Any:
        """The value of the independent variable after the last targeter run."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCurrentValue"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def LowerBound(self) -> typing.Any:
        """Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLowerBound"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @LowerBound.setter
    def LowerBound(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetLowerBound"](arg_newVal.COM_val))

    @property
    def UpperBound(self) -> typing.Any:
        """Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUpperBound"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UpperBound.setter
    def UpperBound(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetUpperBound"](arg_newVal.COM_val))

    @property
    def UseCustomDisplayUnit(self) -> bool:
        """If true, allows display of values in another unit."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCustomDisplayUnit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseCustomDisplayUnit.setter
    def UseCustomDisplayUnit(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseCustomDisplayUnit"](arg_newVal.COM_val))

    @property
    def CustomDisplayUnit(self) -> str:
        """The unit in which the value will be displayed in the GUI."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCustomDisplayUnit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CustomDisplayUnit.setter
    def CustomDisplayUnit(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCustomDisplayUnit"](arg_newVal.COM_val))

    @property
    def Tolerance(self) -> typing.Any:
        """How close the targeter should come to the desired. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTolerance"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Tolerance.setter
    def Tolerance(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTolerance"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{91407E31-8792-460C-AE98-32CF4690D53F}", IVAGoldenSectionControl)
agcls.AgTypeNameMap["IVAGoldenSectionControl"] = IVAGoldenSectionControl

class IVAGoldenSectionResultCollection(object):
    """Properties for the list of Golden Section result parameters."""
    _uuid = "{50AD7420-2926-4B14-8C99-88E1942EF754}"
    _num_methods = 4
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetResultByPaths"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAGoldenSectionResultCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAGoldenSectionResultCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAGoldenSectionResultCollection = agcom.GUID(IVAGoldenSectionResultCollection._uuid)
        vtable_offset_local = IVAGoldenSectionResultCollection._vtable_offset - 1
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVAGoldenSectionResultCollection, vtable_offset_local+1, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVAGoldenSectionResultCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVAGoldenSectionResultCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_GetResultByPaths"] = IAGFUNCTYPE(pUnk, IID_IVAGoldenSectionResultCollection, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAGoldenSectionResultCollection.__dict__ and type(IVAGoldenSectionResultCollection.__dict__[attrname]) == property:
            return IVAGoldenSectionResultCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAGoldenSectionResultCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVAGoldenSectionResult":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Item(self, index:int) -> "IVAGoldenSectionResult":
        """Allows you to iterate through the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_goldenSectionControl:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_index.COM_val, byref(arg_goldenSectionControl.COM_val)))
            return arg_goldenSectionControl.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def GetResultByPaths(self, objectPath:str, resultPath:str) -> "IVAGoldenSectionResult":
        """Returns the result specified by the object/result path."""
        with agmarshall.BSTR_arg(objectPath) as arg_objectPath, \
             agmarshall.BSTR_arg(resultPath) as arg_resultPath, \
             agmarshall.AgInterface_out_arg() as arg_goldenSectionResult:
            agcls.evaluate_hresult(self.__dict__["_GetResultByPaths"](arg_objectPath.COM_val, arg_resultPath.COM_val, byref(arg_goldenSectionResult.COM_val)))
            return arg_goldenSectionResult.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{50AD7420-2926-4B14-8C99-88E1942EF754}", IVAGoldenSectionResultCollection)
agcls.AgTypeNameMap["IVAGoldenSectionResultCollection"] = IVAGoldenSectionResultCollection

class IVAGoldenSectionResult(object):
    """Properties for result parameters of a Golden Section profile."""
    _uuid = "{67461697-37E6-4342-978D-9C6143528607}"
    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEnable"] = _raise_uninitialized_error
        self.__dict__["_SetEnable"] = _raise_uninitialized_error
        self.__dict__["_GetName"] = _raise_uninitialized_error
        self.__dict__["_GetParentName"] = _raise_uninitialized_error
        self.__dict__["_GetCurrentValue"] = _raise_uninitialized_error
        self.__dict__["_GetDesiredOperation"] = _raise_uninitialized_error
        self.__dict__["_SetDesiredOperation"] = _raise_uninitialized_error
        self.__dict__["_GetUseCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_SetUseCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_GetCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_SetCustomDisplayUnit"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAGoldenSectionResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAGoldenSectionResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAGoldenSectionResult = agcom.GUID(IVAGoldenSectionResult._uuid)
        vtable_offset_local = IVAGoldenSectionResult._vtable_offset - 1
        self.__dict__["_GetEnable"] = IAGFUNCTYPE(pUnk, IID_IVAGoldenSectionResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnable"] = IAGFUNCTYPE(pUnk, IID_IVAGoldenSectionResult, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetName"] = IAGFUNCTYPE(pUnk, IID_IVAGoldenSectionResult, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_GetParentName"] = IAGFUNCTYPE(pUnk, IID_IVAGoldenSectionResult, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_GetCurrentValue"] = IAGFUNCTYPE(pUnk, IID_IVAGoldenSectionResult, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_GetDesiredOperation"] = IAGFUNCTYPE(pUnk, IID_IVAGoldenSectionResult, vtable_offset_local+6, POINTER(agcom.LONG))
        self.__dict__["_SetDesiredOperation"] = IAGFUNCTYPE(pUnk, IID_IVAGoldenSectionResult, vtable_offset_local+7, agcom.LONG)
        self.__dict__["_GetUseCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVAGoldenSectionResult, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVAGoldenSectionResult, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_GetCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVAGoldenSectionResult, vtable_offset_local+10, POINTER(agcom.BSTR))
        self.__dict__["_SetCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVAGoldenSectionResult, vtable_offset_local+11, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAGoldenSectionResult.__dict__ and type(IVAGoldenSectionResult.__dict__[attrname]) == property:
            return IVAGoldenSectionResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAGoldenSectionResult.")
    
    @property
    def Enable(self) -> bool:
        """If true, the variable is being used."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Enable.setter
    def Enable(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnable"](arg_newVal.COM_val))

    @property
    def Name(self) -> str:
        """The name of the parameter."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ParentName(self) -> str:
        """The name of the segment to which the parameter belongs."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetParentName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def CurrentValue(self) -> typing.Any:
        """The value of the independent variable after the last targeter run."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCurrentValue"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def DesiredOperation(self) -> "AgEVAGoldenSectionDesiredOperation":
        """The Desired Operation/Objective of golden section."""
        with agmarshall.AgEnum_arg(AgEVAGoldenSectionDesiredOperation) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDesiredOperation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DesiredOperation.setter
    def DesiredOperation(self, inVal:"AgEVAGoldenSectionDesiredOperation") -> None:
        with agmarshall.AgEnum_arg(AgEVAGoldenSectionDesiredOperation, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDesiredOperation"](arg_inVal.COM_val))

    @property
    def UseCustomDisplayUnit(self) -> bool:
        """If true, allows display of values in another unit."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCustomDisplayUnit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseCustomDisplayUnit.setter
    def UseCustomDisplayUnit(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseCustomDisplayUnit"](arg_newVal.COM_val))

    @property
    def CustomDisplayUnit(self) -> str:
        """The unit in which the value will be displayed in the GUI."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCustomDisplayUnit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CustomDisplayUnit.setter
    def CustomDisplayUnit(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCustomDisplayUnit"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{67461697-37E6-4342-978D-9C6143528607}", IVAGoldenSectionResult)
agcls.AgTypeNameMap["IVAGoldenSectionResult"] = IVAGoldenSectionResult

class IVAGridSearchControlCollection(object):
    """Properties for the list of Grid Search control parameters."""
    _uuid = "{BD562D00-ABDC-411B-813D-84C1E3597CEF}"
    _num_methods = 4
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetControlByPaths"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAGridSearchControlCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAGridSearchControlCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAGridSearchControlCollection = agcom.GUID(IVAGridSearchControlCollection._uuid)
        vtable_offset_local = IVAGridSearchControlCollection._vtable_offset - 1
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVAGridSearchControlCollection, vtable_offset_local+1, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVAGridSearchControlCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVAGridSearchControlCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_GetControlByPaths"] = IAGFUNCTYPE(pUnk, IID_IVAGridSearchControlCollection, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAGridSearchControlCollection.__dict__ and type(IVAGridSearchControlCollection.__dict__[attrname]) == property:
            return IVAGridSearchControlCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAGridSearchControlCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVAGridSearchControl":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Item(self, index:int) -> "IVAGridSearchControl":
        """Allows you to iterate through the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_gridSearchControl:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_index.COM_val, byref(arg_gridSearchControl.COM_val)))
            return arg_gridSearchControl.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def GetControlByPaths(self, objectPath:str, controlPath:str) -> "IVAGridSearchControl":
        """Returns the control specified by the object/control path."""
        with agmarshall.BSTR_arg(objectPath) as arg_objectPath, \
             agmarshall.BSTR_arg(controlPath) as arg_controlPath, \
             agmarshall.AgInterface_out_arg() as arg_gridSearchControl:
            agcls.evaluate_hresult(self.__dict__["_GetControlByPaths"](arg_objectPath.COM_val, arg_controlPath.COM_val, byref(arg_gridSearchControl.COM_val)))
            return arg_gridSearchControl.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{BD562D00-ABDC-411B-813D-84C1E3597CEF}", IVAGridSearchControlCollection)
agcls.AgTypeNameMap["IVAGridSearchControlCollection"] = IVAGridSearchControlCollection

class IVAGridSearchControl(object):
    """Properties for control parameters of a Grid Search profile."""
    _uuid = "{7E71EB52-998F-49E7-80BA-1B11574D59DF}"
    _num_methods = 15
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEnable"] = _raise_uninitialized_error
        self.__dict__["_SetEnable"] = _raise_uninitialized_error
        self.__dict__["_GetName"] = _raise_uninitialized_error
        self.__dict__["_GetParentName"] = _raise_uninitialized_error
        self.__dict__["_GetCurrentValue"] = _raise_uninitialized_error
        self.__dict__["_GetLowerBound"] = _raise_uninitialized_error
        self.__dict__["_SetLowerBound"] = _raise_uninitialized_error
        self.__dict__["_GetUpperBound"] = _raise_uninitialized_error
        self.__dict__["_SetUpperBound"] = _raise_uninitialized_error
        self.__dict__["_GetUseCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_SetUseCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_GetCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_SetCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_GetStep"] = _raise_uninitialized_error
        self.__dict__["_SetStep"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAGridSearchControl._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAGridSearchControl from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAGridSearchControl = agcom.GUID(IVAGridSearchControl._uuid)
        vtable_offset_local = IVAGridSearchControl._vtable_offset - 1
        self.__dict__["_GetEnable"] = IAGFUNCTYPE(pUnk, IID_IVAGridSearchControl, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnable"] = IAGFUNCTYPE(pUnk, IID_IVAGridSearchControl, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetName"] = IAGFUNCTYPE(pUnk, IID_IVAGridSearchControl, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_GetParentName"] = IAGFUNCTYPE(pUnk, IID_IVAGridSearchControl, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_GetCurrentValue"] = IAGFUNCTYPE(pUnk, IID_IVAGridSearchControl, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_GetLowerBound"] = IAGFUNCTYPE(pUnk, IID_IVAGridSearchControl, vtable_offset_local+6, POINTER(agcom.VARIANT))
        self.__dict__["_SetLowerBound"] = IAGFUNCTYPE(pUnk, IID_IVAGridSearchControl, vtable_offset_local+7, agcom.VARIANT)
        self.__dict__["_GetUpperBound"] = IAGFUNCTYPE(pUnk, IID_IVAGridSearchControl, vtable_offset_local+8, POINTER(agcom.VARIANT))
        self.__dict__["_SetUpperBound"] = IAGFUNCTYPE(pUnk, IID_IVAGridSearchControl, vtable_offset_local+9, agcom.VARIANT)
        self.__dict__["_GetUseCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVAGridSearchControl, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVAGridSearchControl, vtable_offset_local+11, agcom.VARIANT_BOOL)
        self.__dict__["_GetCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVAGridSearchControl, vtable_offset_local+12, POINTER(agcom.BSTR))
        self.__dict__["_SetCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVAGridSearchControl, vtable_offset_local+13, agcom.BSTR)
        self.__dict__["_GetStep"] = IAGFUNCTYPE(pUnk, IID_IVAGridSearchControl, vtable_offset_local+14, POINTER(agcom.VARIANT))
        self.__dict__["_SetStep"] = IAGFUNCTYPE(pUnk, IID_IVAGridSearchControl, vtable_offset_local+15, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAGridSearchControl.__dict__ and type(IVAGridSearchControl.__dict__[attrname]) == property:
            return IVAGridSearchControl.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAGridSearchControl.")
    
    @property
    def Enable(self) -> bool:
        """If true, the variable is being used."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Enable.setter
    def Enable(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnable"](arg_newVal.COM_val))

    @property
    def Name(self) -> str:
        """The name of the parameter."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ParentName(self) -> str:
        """The name of the segment to which the parameter belongs."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetParentName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def CurrentValue(self) -> typing.Any:
        """The value of the independent variable after the last targeter run."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCurrentValue"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def LowerBound(self) -> typing.Any:
        """Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLowerBound"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @LowerBound.setter
    def LowerBound(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetLowerBound"](arg_newVal.COM_val))

    @property
    def UpperBound(self) -> typing.Any:
        """Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUpperBound"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UpperBound.setter
    def UpperBound(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetUpperBound"](arg_newVal.COM_val))

    @property
    def UseCustomDisplayUnit(self) -> bool:
        """If true, allows display of values in another unit."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCustomDisplayUnit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseCustomDisplayUnit.setter
    def UseCustomDisplayUnit(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseCustomDisplayUnit"](arg_newVal.COM_val))

    @property
    def CustomDisplayUnit(self) -> str:
        """The unit in which the value will be displayed in the GUI."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCustomDisplayUnit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CustomDisplayUnit.setter
    def CustomDisplayUnit(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCustomDisplayUnit"](arg_newVal.COM_val))

    @property
    def Step(self) -> typing.Any:
        """Specifies the step size to use when evaluating the grid search. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Step.setter
    def Step(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetStep"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7E71EB52-998F-49E7-80BA-1B11574D59DF}", IVAGridSearchControl)
agcls.AgTypeNameMap["IVAGridSearchControl"] = IVAGridSearchControl

class IVAGridSearchResultCollection(object):
    """Properties for the list of Grid Search result parameters."""
    _uuid = "{BCA009A8-29CD-420A-955E-DC95A251CD9E}"
    _num_methods = 4
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetResultByPaths"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAGridSearchResultCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAGridSearchResultCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAGridSearchResultCollection = agcom.GUID(IVAGridSearchResultCollection._uuid)
        vtable_offset_local = IVAGridSearchResultCollection._vtable_offset - 1
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVAGridSearchResultCollection, vtable_offset_local+1, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVAGridSearchResultCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVAGridSearchResultCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_GetResultByPaths"] = IAGFUNCTYPE(pUnk, IID_IVAGridSearchResultCollection, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAGridSearchResultCollection.__dict__ and type(IVAGridSearchResultCollection.__dict__[attrname]) == property:
            return IVAGridSearchResultCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAGridSearchResultCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVAGridSearchResult":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Item(self, index:int) -> "IVAGridSearchResult":
        """Allows you to iterate through the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_gridSearchControl:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_index.COM_val, byref(arg_gridSearchControl.COM_val)))
            return arg_gridSearchControl.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def GetResultByPaths(self, objectPath:str, resultPath:str) -> "IVAGridSearchResult":
        """Returns the result specified by the object/result path."""
        with agmarshall.BSTR_arg(objectPath) as arg_objectPath, \
             agmarshall.BSTR_arg(resultPath) as arg_resultPath, \
             agmarshall.AgInterface_out_arg() as arg_gridSearchResult:
            agcls.evaluate_hresult(self.__dict__["_GetResultByPaths"](arg_objectPath.COM_val, arg_resultPath.COM_val, byref(arg_gridSearchResult.COM_val)))
            return arg_gridSearchResult.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{BCA009A8-29CD-420A-955E-DC95A251CD9E}", IVAGridSearchResultCollection)
agcls.AgTypeNameMap["IVAGridSearchResultCollection"] = IVAGridSearchResultCollection

class IVAGridSearchResult(object):
    """Properties for result parameters of a Grid Search profile."""
    _uuid = "{36F26633-D0C4-4692-A6D2-4D98451AB3A7}"
    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEnable"] = _raise_uninitialized_error
        self.__dict__["_SetEnable"] = _raise_uninitialized_error
        self.__dict__["_GetName"] = _raise_uninitialized_error
        self.__dict__["_GetParentName"] = _raise_uninitialized_error
        self.__dict__["_GetCurrentValue"] = _raise_uninitialized_error
        self.__dict__["_GetDesiredOperation"] = _raise_uninitialized_error
        self.__dict__["_SetDesiredOperation"] = _raise_uninitialized_error
        self.__dict__["_GetUseCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_SetUseCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_GetCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_SetCustomDisplayUnit"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAGridSearchResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAGridSearchResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAGridSearchResult = agcom.GUID(IVAGridSearchResult._uuid)
        vtable_offset_local = IVAGridSearchResult._vtable_offset - 1
        self.__dict__["_GetEnable"] = IAGFUNCTYPE(pUnk, IID_IVAGridSearchResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnable"] = IAGFUNCTYPE(pUnk, IID_IVAGridSearchResult, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetName"] = IAGFUNCTYPE(pUnk, IID_IVAGridSearchResult, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_GetParentName"] = IAGFUNCTYPE(pUnk, IID_IVAGridSearchResult, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_GetCurrentValue"] = IAGFUNCTYPE(pUnk, IID_IVAGridSearchResult, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_GetDesiredOperation"] = IAGFUNCTYPE(pUnk, IID_IVAGridSearchResult, vtable_offset_local+6, POINTER(agcom.LONG))
        self.__dict__["_SetDesiredOperation"] = IAGFUNCTYPE(pUnk, IID_IVAGridSearchResult, vtable_offset_local+7, agcom.LONG)
        self.__dict__["_GetUseCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVAGridSearchResult, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVAGridSearchResult, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_GetCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVAGridSearchResult, vtable_offset_local+10, POINTER(agcom.BSTR))
        self.__dict__["_SetCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVAGridSearchResult, vtable_offset_local+11, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAGridSearchResult.__dict__ and type(IVAGridSearchResult.__dict__[attrname]) == property:
            return IVAGridSearchResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAGridSearchResult.")
    
    @property
    def Enable(self) -> bool:
        """If true, the variable is being used."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Enable.setter
    def Enable(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnable"](arg_newVal.COM_val))

    @property
    def Name(self) -> str:
        """The name of the parameter."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ParentName(self) -> str:
        """The name of the segment to which the parameter belongs."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetParentName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def CurrentValue(self) -> typing.Any:
        """The value of the independent variable after the last targeter run."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCurrentValue"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def DesiredOperation(self) -> "AgEVAGridSearchDesiredOperation":
        """The Desired Operation/Objective of grid search."""
        with agmarshall.AgEnum_arg(AgEVAGridSearchDesiredOperation) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDesiredOperation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DesiredOperation.setter
    def DesiredOperation(self, inVal:"AgEVAGridSearchDesiredOperation") -> None:
        with agmarshall.AgEnum_arg(AgEVAGridSearchDesiredOperation, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDesiredOperation"](arg_inVal.COM_val))

    @property
    def UseCustomDisplayUnit(self) -> bool:
        """If true, allows display of values in another unit."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCustomDisplayUnit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseCustomDisplayUnit.setter
    def UseCustomDisplayUnit(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseCustomDisplayUnit"](arg_newVal.COM_val))

    @property
    def CustomDisplayUnit(self) -> str:
        """The unit in which the value will be displayed in the GUI."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCustomDisplayUnit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CustomDisplayUnit.setter
    def CustomDisplayUnit(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCustomDisplayUnit"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{36F26633-D0C4-4692-A6D2-4D98451AB3A7}", IVAGridSearchResult)
agcls.AgTypeNameMap["IVAGridSearchResult"] = IVAGridSearchResult

class IVAStoppingConditionElement(object):
    """The status of a stopping condition."""
    _uuid = "{7508042C-1986-42AB-9B83-DE0AAA5626A0}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetActive"] = _raise_uninitialized_error
        self.__dict__["_SetActive"] = _raise_uninitialized_error
        self.__dict__["_EnableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_DisableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_IsControlParameterEnabled"] = _raise_uninitialized_error
        self.__dict__["_GetControlParametersAvailable"] = _raise_uninitialized_error
        self.__dict__["_GetProperties"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStoppingConditionElement._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStoppingConditionElement from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStoppingConditionElement = agcom.GUID(IVAStoppingConditionElement._uuid)
        vtable_offset_local = IVAStoppingConditionElement._vtable_offset - 1
        self.__dict__["_GetActive"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingConditionElement, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetActive"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingConditionElement, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_EnableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingConditionElement, vtable_offset_local+3, agcom.LONG)
        self.__dict__["_DisableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingConditionElement, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_IsControlParameterEnabled"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingConditionElement, vtable_offset_local+5, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetControlParametersAvailable"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingConditionElement, vtable_offset_local+6, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetProperties"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingConditionElement, vtable_offset_local+7, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStoppingConditionElement.__dict__ and type(IVAStoppingConditionElement.__dict__[attrname]) == property:
            return IVAStoppingConditionElement.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStoppingConditionElement.")
    
    @property
    def Active(self) -> bool:
        """If true, the stopping condition is active."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetActive"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Active.setter
    def Active(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetActive"](arg_newVal.COM_val))

    def EnableControlParameter(self, param:"AgEVAControlStoppingCondition") -> None:
        """Enables or disables the specified control parameter"""
        with agmarshall.AgEnum_arg(AgEVAControlStoppingCondition, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_EnableControlParameter"](arg_param.COM_val))

    def DisableControlParameter(self, param:"AgEVAControlStoppingCondition") -> None:
        """Disables the specified control parameter"""
        with agmarshall.AgEnum_arg(AgEVAControlStoppingCondition, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_DisableControlParameter"](arg_param.COM_val))

    def IsControlParameterEnabled(self, param:"AgEVAControlStoppingCondition") -> bool:
        """Sees if the specified control is enabled"""
        with agmarshall.AgEnum_arg(AgEVAControlStoppingCondition, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_IsControlParameterEnabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ControlParametersAvailable(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetControlParametersAvailable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def Properties(self) -> "IVAStoppingConditionComponent":
        """The properties available to the stopping condition."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProperties"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{7508042C-1986-42AB-9B83-DE0AAA5626A0}", IVAStoppingConditionElement)
agcls.AgTypeNameMap["IVAStoppingConditionElement"] = IVAStoppingConditionElement

class IVAStoppingConditionCollection(object):
    """The list of Stopping Conditions."""
    _uuid = "{47FEE61C-D8B9-4E24-8417-6A9D1DF966A9}"
    _num_methods = 10
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Add"] = _raise_uninitialized_error
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_Cut"] = _raise_uninitialized_error
        self.__dict__["_Paste"] = _raise_uninitialized_error
        self.__dict__["_InsertCopy"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStoppingConditionCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStoppingConditionCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStoppingConditionCollection = agcom.GUID(IVAStoppingConditionCollection._uuid)
        vtable_offset_local = IVAStoppingConditionCollection._vtable_offset - 1
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingConditionCollection, vtable_offset_local+1, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Add"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingConditionCollection, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingConditionCollection, vtable_offset_local+3, agcom.VARIANT)
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingConditionCollection, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingConditionCollection, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_Cut"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingConditionCollection, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_Paste"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingConditionCollection, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_InsertCopy"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingConditionCollection, vtable_offset_local+8, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingConditionCollection, vtable_offset_local+9, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingConditionCollection, vtable_offset_local+10, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStoppingConditionCollection.__dict__ and type(IVAStoppingConditionCollection.__dict__[attrname]) == property:
            return IVAStoppingConditionCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStoppingConditionCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVAStoppingConditionElement":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Item(self, indexOrName:typing.Any) -> "IVAStoppingConditionElement":
        """Allows you to iterate through the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppVAStoppingCondition:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppVAStoppingCondition.COM_val)))
            return arg_ppVAStoppingCondition.python_val

    def Add(self, conditionName:str) -> "IVAStoppingConditionElement":
        """Adds a stopping condition."""
        with agmarshall.BSTR_arg(conditionName) as arg_conditionName, \
             agmarshall.AgInterface_out_arg() as arg_ppVAStoppingCondition:
            agcls.evaluate_hresult(self.__dict__["_Add"](arg_conditionName.COM_val, byref(arg_ppVAStoppingCondition.COM_val)))
            return arg_ppVAStoppingCondition.python_val

    def Remove(self, indexOrName:typing.Any) -> None:
        """Removes a stopping condition."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_indexOrName.COM_val))

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def Cut(self, indexOrName:typing.Any) -> None:
        """Copies the stopping condition into the clipboard and removes the stopping condition from the list."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_Cut"](arg_indexOrName.COM_val))

    def Paste(self) -> "IVAStoppingConditionElement":
        """Pastes the stopping condition from the clipboard and inserts into the list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Paste"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def InsertCopy(self, stopCond:"IVAStoppingConditionElement") -> "IVAStoppingConditionElement":
        """Copies the stopping condition and inserts the copy into the list."""
        with agmarshall.AgInterface_in_arg(stopCond, IVAStoppingConditionElement) as arg_stopCond, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_InsertCopy"](arg_stopCond.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "IVAStoppingConditionElement":
        """Retrieves a stopping condition in the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppVAStoppingCondition:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppVAStoppingCondition.COM_val)))
            return arg_ppVAStoppingCondition.python_val

    def GetItemByName(self, name:str) -> "IVAStoppingConditionElement":
        """Retrieves a stopping condition in the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppVAStoppingCondition:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppVAStoppingCondition.COM_val)))
            return arg_ppVAStoppingCondition.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{47FEE61C-D8B9-4E24-8417-6A9D1DF966A9}", IVAStoppingConditionCollection)
agcls.AgTypeNameMap["IVAStoppingConditionCollection"] = IVAStoppingConditionCollection

class IVAMCSSegmentCollection(object):
    """Properties for a collection of segments."""
    _uuid = "{550AD0AB-FAB1-4632-895D-774CA07B120E}"
    _num_methods = 13
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Insert"] = _raise_uninitialized_error
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_RemoveAll"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_Cut"] = _raise_uninitialized_error
        self.__dict__["_Paste"] = _raise_uninitialized_error
        self.__dict__["_InsertCopy"] = _raise_uninitialized_error
        self.__dict__["_InsertByName"] = _raise_uninitialized_error
        self.__dict__["_GetProvideRuntimeTypeInfo"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAMCSSegmentCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAMCSSegmentCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAMCSSegmentCollection = agcom.GUID(IVAMCSSegmentCollection._uuid)
        vtable_offset_local = IVAMCSSegmentCollection._vtable_offset - 1
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSegmentCollection, vtable_offset_local+1, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Insert"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSegmentCollection, vtable_offset_local+2, agcom.LONG, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSegmentCollection, vtable_offset_local+3, agcom.BSTR)
        self.__dict__["_RemoveAll"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSegmentCollection, vtable_offset_local+4, )
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSegmentCollection, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSegmentCollection, vtable_offset_local+6, POINTER(agcom.LONG))
        self.__dict__["_Cut"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSegmentCollection, vtable_offset_local+7, agcom.BSTR)
        self.__dict__["_Paste"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSegmentCollection, vtable_offset_local+8, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_InsertCopy"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSegmentCollection, vtable_offset_local+9, agcom.PVOID, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_InsertByName"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSegmentCollection, vtable_offset_local+10, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_GetProvideRuntimeTypeInfo"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSegmentCollection, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSegmentCollection, vtable_offset_local+12, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSegmentCollection, vtable_offset_local+13, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAMCSSegmentCollection.__dict__ and type(IVAMCSSegmentCollection.__dict__[attrname]) == property:
            return IVAMCSSegmentCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAMCSSegmentCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVAMCSSegment":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Item(self, indexOrName:typing.Any) -> "IVAMCSSegment":
        """Returns the specified segment(using segment name or index number)."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppVAMCSSegment:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppVAMCSSegment.COM_val)))
            return arg_ppVAMCSSegment.python_val

    def Insert(self, segmentType:"AgEVASegmentType", segmentName:str, segmentToInsertBefore:str) -> "IVAMCSSegment":
        """Adds a segment to the segment collection."""
        with agmarshall.AgEnum_arg(AgEVASegmentType, segmentType) as arg_segmentType, \
             agmarshall.BSTR_arg(segmentName) as arg_segmentName, \
             agmarshall.BSTR_arg(segmentToInsertBefore) as arg_segmentToInsertBefore, \
             agmarshall.AgInterface_out_arg() as arg_ppMCSSegment:
            agcls.evaluate_hresult(self.__dict__["_Insert"](arg_segmentType.COM_val, arg_segmentName.COM_val, arg_segmentToInsertBefore.COM_val, byref(arg_ppMCSSegment.COM_val)))
            return arg_ppMCSSegment.python_val

    def Remove(self, segmentNameToRemove:str) -> None:
        """Removes a segment; the End segment cannot be deleted."""
        with agmarshall.BSTR_arg(segmentNameToRemove) as arg_segmentNameToRemove:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_segmentNameToRemove.COM_val))

    def RemoveAll(self) -> None:
        """Removes all segments; the End segment cannot be deleted."""
        agcls.evaluate_hresult(self.__dict__["_RemoveAll"]())

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def Cut(self, segmentNameToCut:str) -> None:
        """Copies the segment into the clipboard and removes the segment from the sequence."""
        with agmarshall.BSTR_arg(segmentNameToCut) as arg_segmentNameToCut:
            agcls.evaluate_hresult(self.__dict__["_Cut"](arg_segmentNameToCut.COM_val))

    def Paste(self, segmentToPasteBefore:str) -> "IVAMCSSegment":
        """Pastes the segment from the clipboard and inserts in before the given segment name."""
        with agmarshall.BSTR_arg(segmentToPasteBefore) as arg_segmentToPasteBefore, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Paste"](arg_segmentToPasteBefore.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def InsertCopy(self, segment:"IVAMCSSegment", segmentToInsertBefore:str) -> "IVAMCSSegment":
        """Copies the segment pointer and inserts the copy before the given segment name."""
        with agmarshall.AgInterface_in_arg(segment, IVAMCSSegment) as arg_segment, \
             agmarshall.BSTR_arg(segmentToInsertBefore) as arg_segmentToInsertBefore, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_InsertCopy"](arg_segment.COM_val, arg_segmentToInsertBefore.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def InsertByName(self, segmentName:str, segmentToInsertBefore:str) -> "IVAMCSSegment":
        """Inserts a segment by name to the segment collection."""
        with agmarshall.BSTR_arg(segmentName) as arg_segmentName, \
             agmarshall.BSTR_arg(segmentToInsertBefore) as arg_segmentToInsertBefore, \
             agmarshall.AgInterface_out_arg() as arg_ppMCSSegment:
            agcls.evaluate_hresult(self.__dict__["_InsertByName"](arg_segmentName.COM_val, arg_segmentToInsertBefore.COM_val, byref(arg_ppMCSSegment.COM_val)))
            return arg_ppMCSSegment.python_val

    @property
    def ProvideRuntimeTypeInfo(self) -> "IRuntimeTypeInfo":
        """Returns the IAgRuntimeTypeInfo interface to access properties at runtime."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProvideRuntimeTypeInfo"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "IVAMCSSegment":
        """Retrieves the specified segment(using segment index number)."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppVAMCSSegment:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppVAMCSSegment.COM_val)))
            return arg_ppVAMCSSegment.python_val

    def GetItemByName(self, name:str) -> "IVAMCSSegment":
        """Retrieves the specified segment(using segment name)."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppVAMCSSegment:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppVAMCSSegment.COM_val)))
            return arg_ppVAMCSSegment.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{550AD0AB-FAB1-4632-895D-774CA07B120E}", IVAMCSSegmentCollection)
agcls.AgTypeNameMap["IVAMCSSegmentCollection"] = IVAMCSSegmentCollection

class IVAState(object):
    """Spacecraft Parameters properties for the spacecraft configuration."""
    _uuid = "{44DC2BBF-BC83-42AE-80A1-C1C4B399637F}"
    _num_methods = 33
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetElementType"] = _raise_uninitialized_error
        self.__dict__["_SetElementType"] = _raise_uninitialized_error
        self.__dict__["_GetElement"] = _raise_uninitialized_error
        self.__dict__["_GetEpoch"] = _raise_uninitialized_error
        self.__dict__["_SetEpoch"] = _raise_uninitialized_error
        self.__dict__["_GetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_GetDryMass"] = _raise_uninitialized_error
        self.__dict__["_SetDryMass"] = _raise_uninitialized_error
        self.__dict__["_GetFuelMass"] = _raise_uninitialized_error
        self.__dict__["_SetFuelMass"] = _raise_uninitialized_error
        self.__dict__["_GetDragArea"] = _raise_uninitialized_error
        self.__dict__["_SetDragArea"] = _raise_uninitialized_error
        self.__dict__["_GetSRPArea"] = _raise_uninitialized_error
        self.__dict__["_SetSRPArea"] = _raise_uninitialized_error
        self.__dict__["_GetTankPressure"] = _raise_uninitialized_error
        self.__dict__["_SetTankPressure"] = _raise_uninitialized_error
        self.__dict__["_GetTankTemperature"] = _raise_uninitialized_error
        self.__dict__["_SetTankTemperature"] = _raise_uninitialized_error
        self.__dict__["_GetFuelDensity"] = _raise_uninitialized_error
        self.__dict__["_SetFuelDensity"] = _raise_uninitialized_error
        self.__dict__["_GetCr"] = _raise_uninitialized_error
        self.__dict__["_SetCr"] = _raise_uninitialized_error
        self.__dict__["_GetCd"] = _raise_uninitialized_error
        self.__dict__["_SetCd"] = _raise_uninitialized_error
        self.__dict__["_GetRadiationPressureCoeff"] = _raise_uninitialized_error
        self.__dict__["_SetRadiationPressureCoeff"] = _raise_uninitialized_error
        self.__dict__["_GetRadiationPressureArea"] = _raise_uninitialized_error
        self.__dict__["_SetRadiationPressureArea"] = _raise_uninitialized_error
        self.__dict__["_GetK1"] = _raise_uninitialized_error
        self.__dict__["_SetK1"] = _raise_uninitialized_error
        self.__dict__["_GetK2"] = _raise_uninitialized_error
        self.__dict__["_SetK2"] = _raise_uninitialized_error
        self.__dict__["_GetInFrameName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAState._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAState from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAState = agcom.GUID(IVAState._uuid)
        vtable_offset_local = IVAState._vtable_offset - 1
        self.__dict__["_GetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAState, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAState, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetElement"] = IAGFUNCTYPE(pUnk, IID_IVAState, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetEpoch"] = IAGFUNCTYPE(pUnk, IID_IVAState, vtable_offset_local+4, POINTER(agcom.VARIANT))
        self.__dict__["_SetEpoch"] = IAGFUNCTYPE(pUnk, IID_IVAState, vtable_offset_local+5, agcom.VARIANT)
        self.__dict__["_GetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAState, vtable_offset_local+6, POINTER(agcom.BSTR))
        self.__dict__["_GetDryMass"] = IAGFUNCTYPE(pUnk, IID_IVAState, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDryMass"] = IAGFUNCTYPE(pUnk, IID_IVAState, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetFuelMass"] = IAGFUNCTYPE(pUnk, IID_IVAState, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetFuelMass"] = IAGFUNCTYPE(pUnk, IID_IVAState, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetDragArea"] = IAGFUNCTYPE(pUnk, IID_IVAState, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDragArea"] = IAGFUNCTYPE(pUnk, IID_IVAState, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetSRPArea"] = IAGFUNCTYPE(pUnk, IID_IVAState, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetSRPArea"] = IAGFUNCTYPE(pUnk, IID_IVAState, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetTankPressure"] = IAGFUNCTYPE(pUnk, IID_IVAState, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTankPressure"] = IAGFUNCTYPE(pUnk, IID_IVAState, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_GetTankTemperature"] = IAGFUNCTYPE(pUnk, IID_IVAState, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTankTemperature"] = IAGFUNCTYPE(pUnk, IID_IVAState, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_GetFuelDensity"] = IAGFUNCTYPE(pUnk, IID_IVAState, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_SetFuelDensity"] = IAGFUNCTYPE(pUnk, IID_IVAState, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_GetCr"] = IAGFUNCTYPE(pUnk, IID_IVAState, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_SetCr"] = IAGFUNCTYPE(pUnk, IID_IVAState, vtable_offset_local+22, agcom.DOUBLE)
        self.__dict__["_GetCd"] = IAGFUNCTYPE(pUnk, IID_IVAState, vtable_offset_local+23, POINTER(agcom.DOUBLE))
        self.__dict__["_SetCd"] = IAGFUNCTYPE(pUnk, IID_IVAState, vtable_offset_local+24, agcom.DOUBLE)
        self.__dict__["_GetRadiationPressureCoeff"] = IAGFUNCTYPE(pUnk, IID_IVAState, vtable_offset_local+25, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRadiationPressureCoeff"] = IAGFUNCTYPE(pUnk, IID_IVAState, vtable_offset_local+26, agcom.DOUBLE)
        self.__dict__["_GetRadiationPressureArea"] = IAGFUNCTYPE(pUnk, IID_IVAState, vtable_offset_local+27, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRadiationPressureArea"] = IAGFUNCTYPE(pUnk, IID_IVAState, vtable_offset_local+28, agcom.DOUBLE)
        self.__dict__["_GetK1"] = IAGFUNCTYPE(pUnk, IID_IVAState, vtable_offset_local+29, POINTER(agcom.DOUBLE))
        self.__dict__["_SetK1"] = IAGFUNCTYPE(pUnk, IID_IVAState, vtable_offset_local+30, agcom.DOUBLE)
        self.__dict__["_GetK2"] = IAGFUNCTYPE(pUnk, IID_IVAState, vtable_offset_local+31, POINTER(agcom.DOUBLE))
        self.__dict__["_SetK2"] = IAGFUNCTYPE(pUnk, IID_IVAState, vtable_offset_local+32, agcom.DOUBLE)
        self.__dict__["_GetInFrameName"] = IAGFUNCTYPE(pUnk, IID_IVAState, vtable_offset_local+33, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAState.__dict__ and type(IVAState.__dict__[attrname]) == property:
            return IVAState.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAState.")
    
    @property
    def ElementType(self) -> "AgEVAElementType":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVAElementType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def SetElementType(self, elementType:"AgEVAElementType") -> None:
        """Sets the element type."""
        with agmarshall.AgEnum_arg(AgEVAElementType, elementType) as arg_elementType:
            agcls.evaluate_hresult(self.__dict__["_SetElementType"](arg_elementType.COM_val))

    @property
    def Element(self) -> "IVAElement":
        """Returns the currently selected element type."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAElement:
            agcls.evaluate_hresult(self.__dict__["_GetElement"](byref(arg_ppVAElement.COM_val)))
            return arg_ppVAElement.python_val

    @property
    def Epoch(self) -> typing.Any:
        """The epoch of the Orbit State. Uses DateFormat Dimension."""
        with agmarshall.VARIANT_arg() as arg_pEpoch:
            agcls.evaluate_hresult(self.__dict__["_GetEpoch"](byref(arg_pEpoch.COM_val)))
            return arg_pEpoch.python_val

    @Epoch.setter
    def Epoch(self, epoch:typing.Any) -> None:
        with agmarshall.VARIANT_arg(epoch) as arg_epoch:
            agcls.evaluate_hresult(self.__dict__["_SetEpoch"](arg_epoch.COM_val))

    @property
    def CoordSystemName(self) -> str:
        """The coordinate system."""
        with agmarshall.BSTR_arg() as arg_pCoordSysName:
            agcls.evaluate_hresult(self.__dict__["_GetCoordSystemName"](byref(arg_pCoordSysName.COM_val)))
            return arg_pCoordSysName.python_val

    @property
    def DryMass(self) -> float:
        """The mass of the spacecraft exclusive of propellant. Uses Mass Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pDryMass:
            agcls.evaluate_hresult(self.__dict__["_GetDryMass"](byref(arg_pDryMass.COM_val)))
            return arg_pDryMass.python_val

    @DryMass.setter
    def DryMass(self, dryMass:float) -> None:
        with agmarshall.DOUBLE_arg(dryMass) as arg_dryMass:
            agcls.evaluate_hresult(self.__dict__["_SetDryMass"](arg_dryMass.COM_val))

    @property
    def FuelMass(self) -> float:
        """The mass of the spacecraft propellant. Uses Mass Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pFuelMass:
            agcls.evaluate_hresult(self.__dict__["_GetFuelMass"](byref(arg_pFuelMass.COM_val)))
            return arg_pFuelMass.python_val

    @FuelMass.setter
    def FuelMass(self, fuelMass:float) -> None:
        with agmarshall.DOUBLE_arg(fuelMass) as arg_fuelMass:
            agcls.evaluate_hresult(self.__dict__["_SetFuelMass"](arg_fuelMass.COM_val))

    @property
    def DragArea(self) -> float:
        """The cross-sectional area of the spacecraft assumed perpendicular to the direction of motion, used for atmospheric drag calculations. Uses SmallArea Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pFuelMass:
            agcls.evaluate_hresult(self.__dict__["_GetDragArea"](byref(arg_pFuelMass.COM_val)))
            return arg_pFuelMass.python_val

    @DragArea.setter
    def DragArea(self, fuelMass:float) -> None:
        with agmarshall.DOUBLE_arg(fuelMass) as arg_fuelMass:
            agcls.evaluate_hresult(self.__dict__["_SetDragArea"](arg_fuelMass.COM_val))

    @property
    def SRPArea(self) -> float:
        """The cross-sectional area of the spacecraft assumed perpendicular to the direction of solar radiation, used for solar radiation calculations. Uses SmallArea Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pSRPArea:
            agcls.evaluate_hresult(self.__dict__["_GetSRPArea"](byref(arg_pSRPArea.COM_val)))
            return arg_pSRPArea.python_val

    @SRPArea.setter
    def SRPArea(self, sRPArea:float) -> None:
        with agmarshall.DOUBLE_arg(sRPArea) as arg_sRPArea:
            agcls.evaluate_hresult(self.__dict__["_SetSRPArea"](arg_sRPArea.COM_val))

    @property
    def TankPressure(self) -> float:
        """The fuel tank pressure. Uses Pressure Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pTankPressure:
            agcls.evaluate_hresult(self.__dict__["_GetTankPressure"](byref(arg_pTankPressure.COM_val)))
            return arg_pTankPressure.python_val

    @TankPressure.setter
    def TankPressure(self, tankPressure:float) -> None:
        with agmarshall.DOUBLE_arg(tankPressure) as arg_tankPressure:
            agcls.evaluate_hresult(self.__dict__["_SetTankPressure"](arg_tankPressure.COM_val))

    @property
    def TankTemperature(self) -> float:
        """The temperature of the fuel tank. Uses Temperature Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pTankTemperature:
            agcls.evaluate_hresult(self.__dict__["_GetTankTemperature"](byref(arg_pTankTemperature.COM_val)))
            return arg_pTankTemperature.python_val

    @TankTemperature.setter
    def TankTemperature(self, tankTemperature:float) -> None:
        with agmarshall.DOUBLE_arg(tankTemperature) as arg_tankTemperature:
            agcls.evaluate_hresult(self.__dict__["_SetTankTemperature"](arg_tankTemperature.COM_val))

    @property
    def FuelDensity(self) -> float:
        """The density of the fuel tank. Uses SmallDensity Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pFuelDensity:
            agcls.evaluate_hresult(self.__dict__["_GetFuelDensity"](byref(arg_pFuelDensity.COM_val)))
            return arg_pFuelDensity.python_val

    @FuelDensity.setter
    def FuelDensity(self, fuelDensity:float) -> None:
        with agmarshall.DOUBLE_arg(fuelDensity) as arg_fuelDensity:
            agcls.evaluate_hresult(self.__dict__["_SetFuelDensity"](arg_fuelDensity.COM_val))

    @property
    def Cr(self) -> float:
        """The reflectivity of the spacecraft used for solar radiation pressure calculations, where 2.0 is fully reflective and 1.0 is not reflective at all. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pCr:
            agcls.evaluate_hresult(self.__dict__["_GetCr"](byref(arg_pCr.COM_val)))
            return arg_pCr.python_val

    @Cr.setter
    def Cr(self, cr:float) -> None:
        with agmarshall.DOUBLE_arg(cr) as arg_cr:
            agcls.evaluate_hresult(self.__dict__["_SetCr"](arg_cr.COM_val))

    @property
    def Cd(self) -> float:
        """The dimensionless drag coefficient associated with the drag area. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pCd:
            agcls.evaluate_hresult(self.__dict__["_GetCd"](byref(arg_pCd.COM_val)))
            return arg_pCd.python_val

    @Cd.setter
    def Cd(self, cd:float) -> None:
        with agmarshall.DOUBLE_arg(cd) as arg_cd:
            agcls.evaluate_hresult(self.__dict__["_SetCd"](arg_cd.COM_val))

    @property
    def RadiationPressureCoeff(self) -> float:
        """The reflectivity of the spacecraft used for central body radiation pressure (albedo / thermal pressure) calculations, where 2.0 is fully reflective and 1.0 is not reflective at all. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pRadiationPressureCoeff:
            agcls.evaluate_hresult(self.__dict__["_GetRadiationPressureCoeff"](byref(arg_pRadiationPressureCoeff.COM_val)))
            return arg_pRadiationPressureCoeff.python_val

    @RadiationPressureCoeff.setter
    def RadiationPressureCoeff(self, radiationPressureCoeff:float) -> None:
        with agmarshall.DOUBLE_arg(radiationPressureCoeff) as arg_radiationPressureCoeff:
            agcls.evaluate_hresult(self.__dict__["_SetRadiationPressureCoeff"](arg_radiationPressureCoeff.COM_val))

    @property
    def RadiationPressureArea(self) -> float:
        """The cross-sectional area of the spacecraft assumed perpendicular to the direction of central body radiation, used for central body radiation (albedo / thermal pressure) calculations. Uses Small Area Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pRadiationPressureArea:
            agcls.evaluate_hresult(self.__dict__["_GetRadiationPressureArea"](byref(arg_pRadiationPressureArea.COM_val)))
            return arg_pRadiationPressureArea.python_val

    @RadiationPressureArea.setter
    def RadiationPressureArea(self, radPressureArea:float) -> None:
        with agmarshall.DOUBLE_arg(radPressureArea) as arg_radPressureArea:
            agcls.evaluate_hresult(self.__dict__["_SetRadiationPressureArea"](arg_radPressureArea.COM_val))

    @property
    def K1(self) -> float:
        """If you are using a non-spherical SRP model, this field defines the model's GPS solar radiation pressure K1 (scale) value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pK1:
            agcls.evaluate_hresult(self.__dict__["_GetK1"](byref(arg_pK1.COM_val)))
            return arg_pK1.python_val

    @K1.setter
    def K1(self, k1:float) -> None:
        with agmarshall.DOUBLE_arg(k1) as arg_k1:
            agcls.evaluate_hresult(self.__dict__["_SetK1"](arg_k1.COM_val))

    @property
    def K2(self) -> float:
        """If you are using a non-spherical SRP model, this field defines the model's GPS solar radiation pressure K2 (scale) value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pK2:
            agcls.evaluate_hresult(self.__dict__["_GetK2"](byref(arg_pK2.COM_val)))
            return arg_pK2.python_val

    @K2.setter
    def K2(self, k2:float) -> None:
        with agmarshall.DOUBLE_arg(k2) as arg_k2:
            agcls.evaluate_hresult(self.__dict__["_SetK2"](arg_k2.COM_val))

    def GetInFrameName(self, frameName:str) -> "IVAState":
        """Gets the orbit state in the specified frame."""
        with agmarshall.BSTR_arg(frameName) as arg_frameName, \
             agmarshall.AgInterface_out_arg() as arg_ppOrbitState:
            agcls.evaluate_hresult(self.__dict__["_GetInFrameName"](arg_frameName.COM_val, byref(arg_ppOrbitState.COM_val)))
            return arg_ppOrbitState.python_val


agcls.AgClassCatalog.add_catalog_entry("{44DC2BBF-BC83-42AE-80A1-C1C4B399637F}", IVAState)
agcls.AgTypeNameMap["IVAState"] = IVAState

class IVAStoppingConditionComponent(object):
    """Properties for a stopping condition."""
    _uuid = "{BB400CAB-0917-4921-BD15-73F6039F3AF2}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetStoppingConditionType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStoppingConditionComponent._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStoppingConditionComponent from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStoppingConditionComponent = agcom.GUID(IVAStoppingConditionComponent._uuid)
        vtable_offset_local = IVAStoppingConditionComponent._vtable_offset - 1
        self.__dict__["_GetStoppingConditionType"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingConditionComponent, vtable_offset_local+1, POINTER(agcom.LONG))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStoppingConditionComponent.__dict__ and type(IVAStoppingConditionComponent.__dict__[attrname]) == property:
            return IVAStoppingConditionComponent.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStoppingConditionComponent.")
    
    @property
    def StoppingConditionType(self) -> "AgEVAStoppingCondition":
        """The type of stopping condition."""
        with agmarshall.AgEnum_arg(AgEVAStoppingCondition) as arg_pEVAStoppingCondition:
            agcls.evaluate_hresult(self.__dict__["_GetStoppingConditionType"](byref(arg_pEVAStoppingCondition.COM_val)))
            return arg_pEVAStoppingCondition.python_val


agcls.AgClassCatalog.add_catalog_entry("{BB400CAB-0917-4921-BD15-73F6039F3AF2}", IVAStoppingConditionComponent)
agcls.AgTypeNameMap["IVAStoppingConditionComponent"] = IVAStoppingConditionComponent

class IVAAutomaticSequence(object):
    """Properties for automatic sequences."""
    _uuid = "{B38BC6BA-95F1-4F88-A09D-5657DB8A31AC}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_MakeCopy"] = _raise_uninitialized_error
        self.__dict__["_GetName"] = _raise_uninitialized_error
        self.__dict__["_SetName"] = _raise_uninitialized_error
        self.__dict__["_GetUserComment"] = _raise_uninitialized_error
        self.__dict__["_SetUserComment"] = _raise_uninitialized_error
        self.__dict__["_GetSequence"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAAutomaticSequence._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAAutomaticSequence from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAAutomaticSequence = agcom.GUID(IVAAutomaticSequence._uuid)
        vtable_offset_local = IVAAutomaticSequence._vtable_offset - 1
        self.__dict__["_MakeCopy"] = IAGFUNCTYPE(pUnk, IID_IVAAutomaticSequence, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_GetName"] = IAGFUNCTYPE(pUnk, IID_IVAAutomaticSequence, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_SetName"] = IAGFUNCTYPE(pUnk, IID_IVAAutomaticSequence, vtable_offset_local+3, agcom.BSTR)
        self.__dict__["_GetUserComment"] = IAGFUNCTYPE(pUnk, IID_IVAAutomaticSequence, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_SetUserComment"] = IAGFUNCTYPE(pUnk, IID_IVAAutomaticSequence, vtable_offset_local+5, agcom.BSTR)
        self.__dict__["_GetSequence"] = IAGFUNCTYPE(pUnk, IID_IVAAutomaticSequence, vtable_offset_local+6, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAAutomaticSequence.__dict__ and type(IVAAutomaticSequence.__dict__[attrname]) == property:
            return IVAAutomaticSequence.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAAutomaticSequence.")
    
    def MakeCopy(self, uniqueName:str) -> "IVAAutomaticSequence":
        """Makes a copy of the sequence."""
        with agmarshall.BSTR_arg(uniqueName) as arg_uniqueName, \
             agmarshall.AgInterface_out_arg() as arg_ppAutomaticSequence:
            agcls.evaluate_hresult(self.__dict__["_MakeCopy"](arg_uniqueName.COM_val, byref(arg_ppAutomaticSequence.COM_val)))
            return arg_ppAutomaticSequence.python_val

    @property
    def Name(self) -> str:
        """The name of the sequence."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Name.setter
    def Name(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetName"](arg_newVal.COM_val))

    @property
    def UserComment(self) -> str:
        """The user comment."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUserComment"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UserComment.setter
    def UserComment(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetUserComment"](arg_newVal.COM_val))

    @property
    def Sequence(self) -> "IVAMCSSegmentCollection":
        """Returns the segment collection of the sequence."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAMCSSegmentCollection:
            agcls.evaluate_hresult(self.__dict__["_GetSequence"](byref(arg_ppVAMCSSegmentCollection.COM_val)))
            return arg_ppVAMCSSegmentCollection.python_val


agcls.AgClassCatalog.add_catalog_entry("{B38BC6BA-95F1-4F88-A09D-5657DB8A31AC}", IVAAutomaticSequence)
agcls.AgTypeNameMap["IVAAutomaticSequence"] = IVAAutomaticSequence

class IVAAutomaticSequenceCollection(object):
    """Properties for the Automatic Sequence Browser."""
    _uuid = "{E71D785F-1A4C-4E98-BDC1-4EE7055D1FDC}"
    _num_methods = 7
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Add"] = _raise_uninitialized_error
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAAutomaticSequenceCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAAutomaticSequenceCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAAutomaticSequenceCollection = agcom.GUID(IVAAutomaticSequenceCollection._uuid)
        vtable_offset_local = IVAAutomaticSequenceCollection._vtable_offset - 1
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVAAutomaticSequenceCollection, vtable_offset_local+1, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Add"] = IAGFUNCTYPE(pUnk, IID_IVAAutomaticSequenceCollection, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IVAAutomaticSequenceCollection, vtable_offset_local+3, agcom.VARIANT)
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVAAutomaticSequenceCollection, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVAAutomaticSequenceCollection, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IVAAutomaticSequenceCollection, vtable_offset_local+6, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IVAAutomaticSequenceCollection, vtable_offset_local+7, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAAutomaticSequenceCollection.__dict__ and type(IVAAutomaticSequenceCollection.__dict__[attrname]) == property:
            return IVAAutomaticSequenceCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAAutomaticSequenceCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVAAutomaticSequence":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Item(self, indexOrName:typing.Any) -> "IVAAutomaticSequence":
        """Returns the given automatic sequence."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppVAAutomaticSequence:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppVAAutomaticSequence.COM_val)))
            return arg_ppVAAutomaticSequence.python_val

    def Add(self, name:str) -> "IVAAutomaticSequence":
        """Creates a new sequence."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppVAAutomaticSequence:
            agcls.evaluate_hresult(self.__dict__["_Add"](arg_name.COM_val, byref(arg_ppVAAutomaticSequence.COM_val)))
            return arg_ppVAAutomaticSequence.python_val

    def Remove(self, indexOrName:typing.Any) -> None:
        """Removes a sequence."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_indexOrName.COM_val))

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Count(self) -> int:
        """The size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def GetItemByIndex(self, index:int) -> "IVAAutomaticSequence":
        """Retrieves the given automatic sequence found by the index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppVAAutomaticSequence:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppVAAutomaticSequence.COM_val)))
            return arg_ppVAAutomaticSequence.python_val

    def GetItemByName(self, name:str) -> "IVAAutomaticSequence":
        """Retrieves the given automatic sequence found by the name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppVAAutomaticSequence:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppVAAutomaticSequence.COM_val)))
            return arg_ppVAAutomaticSequence.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{E71D785F-1A4C-4E98-BDC1-4EE7055D1FDC}", IVAAutomaticSequenceCollection)
agcls.AgTypeNameMap["IVAAutomaticSequenceCollection"] = IVAAutomaticSequenceCollection

class IVABPlaneCollection(object):
    """Properties for the collection of B-Planes."""
    _uuid = "{64D1804F-3A12-4DA5-AF4F-79C6AE3B39BC}"
    _num_methods = 6
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Add"] = _raise_uninitialized_error
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_RemoveAll"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVABPlaneCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVABPlaneCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVABPlaneCollection = agcom.GUID(IVABPlaneCollection._uuid)
        vtable_offset_local = IVABPlaneCollection._vtable_offset - 1
        self.__dict__["_Add"] = IAGFUNCTYPE(pUnk, IID_IVABPlaneCollection, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IVABPlaneCollection, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_RemoveAll"] = IAGFUNCTYPE(pUnk, IID_IVABPlaneCollection, vtable_offset_local+3, )
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVABPlaneCollection, vtable_offset_local+4, agcom.LONG, POINTER(agcom.BSTR))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVABPlaneCollection, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVABPlaneCollection, vtable_offset_local+6, POINTER(agcom.LONG))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVABPlaneCollection.__dict__ and type(IVABPlaneCollection.__dict__[attrname]) == property:
            return IVABPlaneCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVABPlaneCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> str:
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Add(self, bPlaneName:str) -> None:
        """Adds a BPlane."""
        with agmarshall.BSTR_arg(bPlaneName) as arg_bPlaneName:
            agcls.evaluate_hresult(self.__dict__["_Add"](arg_bPlaneName.COM_val))

    def Remove(self, bPlaneName:str) -> None:
        """Removes a BPlane."""
        with agmarshall.BSTR_arg(bPlaneName) as arg_bPlaneName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_bPlaneName.COM_val))

    def RemoveAll(self) -> None:
        """Removes all BPlanes."""
        agcls.evaluate_hresult(self.__dict__["_RemoveAll"]())

    def Item(self, index:int) -> str:
        """Allows you to iterate through the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_index.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def Count(self) -> int:
        """The number of active BPlanes."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{64D1804F-3A12-4DA5-AF4F-79C6AE3B39BC}", IVABPlaneCollection)
agcls.AgTypeNameMap["IVABPlaneCollection"] = IVABPlaneCollection

class IVACalcObjectCollection(object):
    """Collection of calculation objects."""
    _uuid = "{ECCA3BE7-235C-439B-8DE8-8A5010C4A484}"
    _num_methods = 10
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Add"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_Cut"] = _raise_uninitialized_error
        self.__dict__["_Paste"] = _raise_uninitialized_error
        self.__dict__["_InsertCopy"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVACalcObjectCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVACalcObjectCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVACalcObjectCollection = agcom.GUID(IVACalcObjectCollection._uuid)
        vtable_offset_local = IVACalcObjectCollection._vtable_offset - 1
        self.__dict__["_Add"] = IAGFUNCTYPE(pUnk, IID_IVACalcObjectCollection, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVACalcObjectCollection, vtable_offset_local+2, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IVACalcObjectCollection, vtable_offset_local+3, agcom.VARIANT)
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVACalcObjectCollection, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVACalcObjectCollection, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_Cut"] = IAGFUNCTYPE(pUnk, IID_IVACalcObjectCollection, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_Paste"] = IAGFUNCTYPE(pUnk, IID_IVACalcObjectCollection, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_InsertCopy"] = IAGFUNCTYPE(pUnk, IID_IVACalcObjectCollection, vtable_offset_local+8, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IVACalcObjectCollection, vtable_offset_local+9, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IVACalcObjectCollection, vtable_offset_local+10, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVACalcObjectCollection.__dict__ and type(IVACalcObjectCollection.__dict__[attrname]) == property:
            return IVACalcObjectCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVACalcObjectCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IComponentInfo":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Add(self, name:str) -> "IComponentInfo":
        """Adds a calc object to the collection."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppComponent:
            agcls.evaluate_hresult(self.__dict__["_Add"](arg_name.COM_val, byref(arg_ppComponent.COM_val)))
            return arg_ppComponent.python_val

    def Item(self, indexOrName:typing.Any) -> "IComponentInfo":
        """Returns a calc object."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppComponent:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppComponent.COM_val)))
            return arg_ppComponent.python_val

    def Remove(self, indexOrName:typing.Any) -> None:
        """Removes a calc object from the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_indexOrName.COM_val))

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def Cut(self, indexOrName:typing.Any) -> None:
        """Copies a calc object to the clipboard and removes the calc object from the list."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_Cut"](arg_indexOrName.COM_val))

    def Paste(self) -> "IComponentInfo":
        """Pastes a calc object from the clipboard into the list."""
        with agmarshall.AgInterface_out_arg() as arg_ppCalcObj:
            agcls.evaluate_hresult(self.__dict__["_Paste"](byref(arg_ppCalcObj.COM_val)))
            return arg_ppCalcObj.python_val

    def InsertCopy(self, calcObj:"IComponentInfo") -> "IComponentInfo":
        """Copies a calc object and inserts the copy into the list."""
        with agmarshall.AgInterface_in_arg(calcObj, IComponentInfo) as arg_calcObj, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_InsertCopy"](arg_calcObj.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "IComponentInfo":
        """Retrieves a calc object found by the index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppComponent:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppComponent.COM_val)))
            return arg_ppComponent.python_val

    def GetItemByName(self, name:str) -> "IComponentInfo":
        """Retrieves a calc object found by the name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppComponent:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppComponent.COM_val)))
            return arg_ppComponent.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{ECCA3BE7-235C-439B-8DE8-8A5010C4A484}", IVACalcObjectCollection)
agcls.AgTypeNameMap["IVACalcObjectCollection"] = IVACalcObjectCollection

class IVAManeuverFinitePropagator(object):
    """Properties for the propagation of a Finite Maneuver."""
    _uuid = "{6F8D5070-D155-4D40-A682-46EF2B69F1A3}"
    _num_methods = 21
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPropagatorName"] = _raise_uninitialized_error
        self.__dict__["_SetPropagatorName"] = _raise_uninitialized_error
        self.__dict__["_GetStoppingConditions"] = _raise_uninitialized_error
        self.__dict__["_GetMinPropagationTime"] = _raise_uninitialized_error
        self.__dict__["_SetMinPropagationTime"] = _raise_uninitialized_error
        self.__dict__["_GetMaxPropagationTime"] = _raise_uninitialized_error
        self.__dict__["_SetMaxPropagationTime"] = _raise_uninitialized_error
        self.__dict__["_GetEnableMaxPropagationTime"] = _raise_uninitialized_error
        self.__dict__["_SetEnableMaxPropagationTime"] = _raise_uninitialized_error
        self.__dict__["_GetEnableWarningMessage"] = _raise_uninitialized_error
        self.__dict__["_SetEnableWarningMessage"] = _raise_uninitialized_error
        self.__dict__["_GetEnableCenterBurn"] = _raise_uninitialized_error
        self.__dict__["_SetEnableCenterBurn"] = _raise_uninitialized_error
        self.__dict__["_GetBias"] = _raise_uninitialized_error
        self.__dict__["_SetBias"] = _raise_uninitialized_error
        self.__dict__["_GetOverrideMaxPropagationTime"] = _raise_uninitialized_error
        self.__dict__["_SetOverrideMaxPropagationTime"] = _raise_uninitialized_error
        self.__dict__["_GetShouldStopForInitiallySurpassedEpochStoppingConditions"] = _raise_uninitialized_error
        self.__dict__["_SetShouldStopForInitiallySurpassedEpochStoppingConditions"] = _raise_uninitialized_error
        self.__dict__["_GetShouldReinitializeSTMAtStartOfSegmentPropagation"] = _raise_uninitialized_error
        self.__dict__["_SetShouldReinitializeSTMAtStartOfSegmentPropagation"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAManeuverFinitePropagator._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAManeuverFinitePropagator from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAManeuverFinitePropagator = agcom.GUID(IVAManeuverFinitePropagator._uuid)
        vtable_offset_local = IVAManeuverFinitePropagator._vtable_offset - 1
        self.__dict__["_GetPropagatorName"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverFinitePropagator, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetPropagatorName"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverFinitePropagator, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetStoppingConditions"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverFinitePropagator, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetMinPropagationTime"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverFinitePropagator, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMinPropagationTime"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverFinitePropagator, vtable_offset_local+5, agcom.DOUBLE)
        self.__dict__["_GetMaxPropagationTime"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverFinitePropagator, vtable_offset_local+6, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaxPropagationTime"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverFinitePropagator, vtable_offset_local+7, agcom.DOUBLE)
        self.__dict__["_GetEnableMaxPropagationTime"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverFinitePropagator, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnableMaxPropagationTime"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverFinitePropagator, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_GetEnableWarningMessage"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverFinitePropagator, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnableWarningMessage"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverFinitePropagator, vtable_offset_local+11, agcom.VARIANT_BOOL)
        self.__dict__["_GetEnableCenterBurn"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverFinitePropagator, vtable_offset_local+12, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnableCenterBurn"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverFinitePropagator, vtable_offset_local+13, agcom.VARIANT_BOOL)
        self.__dict__["_GetBias"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverFinitePropagator, vtable_offset_local+14, POINTER(agcom.DOUBLE))
        self.__dict__["_SetBias"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverFinitePropagator, vtable_offset_local+15, agcom.DOUBLE)
        self.__dict__["_GetOverrideMaxPropagationTime"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverFinitePropagator, vtable_offset_local+16, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetOverrideMaxPropagationTime"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverFinitePropagator, vtable_offset_local+17, agcom.VARIANT_BOOL)
        self.__dict__["_GetShouldStopForInitiallySurpassedEpochStoppingConditions"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverFinitePropagator, vtable_offset_local+18, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetShouldStopForInitiallySurpassedEpochStoppingConditions"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverFinitePropagator, vtable_offset_local+19, agcom.VARIANT_BOOL)
        self.__dict__["_GetShouldReinitializeSTMAtStartOfSegmentPropagation"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverFinitePropagator, vtable_offset_local+20, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetShouldReinitializeSTMAtStartOfSegmentPropagation"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverFinitePropagator, vtable_offset_local+21, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAManeuverFinitePropagator.__dict__ and type(IVAManeuverFinitePropagator.__dict__[attrname]) == property:
            return IVAManeuverFinitePropagator.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAManeuverFinitePropagator.")
    
    @property
    def PropagatorName(self) -> str:
        """The propagator."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPropagatorName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @PropagatorName.setter
    def PropagatorName(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetPropagatorName"](arg_newVal.COM_val))

    @property
    def StoppingConditions(self) -> "IVAStoppingConditionCollection":
        """The stopping conditions list."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAStoppingConditionCollection:
            agcls.evaluate_hresult(self.__dict__["_GetStoppingConditions"](byref(arg_ppVAStoppingConditionCollection.COM_val)))
            return arg_ppVAStoppingConditionCollection.python_val

    @property
    def MinPropagationTime(self) -> float:
        """Minimum Propagation Time - the minimum time that must elapse from the beginning of the segment until Astrogator will begin checking stopping conditions for satisfaction. Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinPropagationTime"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MinPropagationTime.setter
    def MinPropagationTime(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetMinPropagationTime"](arg_newVal.COM_val))

    @property
    def MaxPropagationTime(self) -> float:
        """Maximum Propagation Time - the maximum propagation time, after which the segment will end regardless of whether the stopping conditions have been satisfied. Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxPropagationTime"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxPropagationTime.setter
    def MaxPropagationTime(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxPropagationTime"](arg_newVal.COM_val))

    @property
    def EnableMaxPropagationTime(self) -> bool:
        """Enable Maximum Propagation Time - apply the maximum propagation time."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnableMaxPropagationTime"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EnableMaxPropagationTime.setter
    def EnableMaxPropagationTime(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnableMaxPropagationTime"](arg_newVal.COM_val))

    @property
    def EnableWarningMessage(self) -> bool:
        """Issue a warning message if propagation is stopped by the Maximum Propagation Time parameter."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnableWarningMessage"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EnableWarningMessage.setter
    def EnableWarningMessage(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnableWarningMessage"](arg_newVal.COM_val))

    @property
    def EnableCenterBurn(self) -> bool:
        """This property is only available for use with a duration stopping condition. If selected, you are setting the maneuver to start half the time before the previous segment ended."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnableCenterBurn"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EnableCenterBurn.setter
    def EnableCenterBurn(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnableCenterBurn"](arg_newVal.COM_val))

    @property
    def Bias(self) -> float:
        """The value by which to adjust the centering of the burn. A positive value will center the burn after the previous segment ends by the amount specified in the Burn Center Bias field. Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetBias"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Bias.setter
    def Bias(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetBias"](arg_newVal.COM_val))

    @property
    def OverrideMaxPropagationTime(self) -> bool:
        """Override Maximum Propagation Time - if there is a duration or epoch stopping condition that occurs after the maximum propagation time, ignore the maximum propagation time."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetOverrideMaxPropagationTime"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @OverrideMaxPropagationTime.setter
    def OverrideMaxPropagationTime(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetOverrideMaxPropagationTime"](arg_newVal.COM_val))

    @property
    def ShouldStopForInitiallySurpassedEpochStoppingConditions(self) -> bool:
        """Stop immediately if propagation begins beyond an active epoch stopping condition."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetShouldStopForInitiallySurpassedEpochStoppingConditions"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ShouldStopForInitiallySurpassedEpochStoppingConditions.setter
    def ShouldStopForInitiallySurpassedEpochStoppingConditions(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetShouldStopForInitiallySurpassedEpochStoppingConditions"](arg_newVal.COM_val))

    @property
    def ShouldReinitializeSTMAtStartOfSegmentPropagation(self) -> bool:
        """If this segment is propagating the state transition matrix, reset it to the identity matrix at the start of the segment."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetShouldReinitializeSTMAtStartOfSegmentPropagation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ShouldReinitializeSTMAtStartOfSegmentPropagation.setter
    def ShouldReinitializeSTMAtStartOfSegmentPropagation(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetShouldReinitializeSTMAtStartOfSegmentPropagation"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{6F8D5070-D155-4D40-A682-46EF2B69F1A3}", IVAManeuverFinitePropagator)
agcls.AgTypeNameMap["IVAManeuverFinitePropagator"] = IVAManeuverFinitePropagator

class IVABurnoutVelocity(object):
    """Properties for the burnout velocity of a Launch segment."""
    _uuid = "{A1EA8DE5-41D0-4419-988E-98EEACEECAE9}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetBurnoutOption"] = _raise_uninitialized_error
        self.__dict__["_SetBurnoutOption"] = _raise_uninitialized_error
        self.__dict__["_GetFixedVelocity"] = _raise_uninitialized_error
        self.__dict__["_SetFixedVelocity"] = _raise_uninitialized_error
        self.__dict__["_GetInertialVelocity"] = _raise_uninitialized_error
        self.__dict__["_SetInertialVelocity"] = _raise_uninitialized_error
        self.__dict__["_GetInertialVelocityAzimuth"] = _raise_uninitialized_error
        self.__dict__["_SetInertialVelocityAzimuth"] = _raise_uninitialized_error
        self.__dict__["_GetInertialHorizontalFPA"] = _raise_uninitialized_error
        self.__dict__["_SetInertialHorizontalFPA"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVABurnoutVelocity._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVABurnoutVelocity from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVABurnoutVelocity = agcom.GUID(IVABurnoutVelocity._uuid)
        vtable_offset_local = IVABurnoutVelocity._vtable_offset - 1
        self.__dict__["_GetBurnoutOption"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutVelocity, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetBurnoutOption"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutVelocity, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetFixedVelocity"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutVelocity, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetFixedVelocity"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutVelocity, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetInertialVelocity"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutVelocity, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetInertialVelocity"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutVelocity, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetInertialVelocityAzimuth"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutVelocity, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_SetInertialVelocityAzimuth"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutVelocity, vtable_offset_local+8, agcom.VARIANT)
        self.__dict__["_GetInertialHorizontalFPA"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutVelocity, vtable_offset_local+9, POINTER(agcom.VARIANT))
        self.__dict__["_SetInertialHorizontalFPA"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutVelocity, vtable_offset_local+10, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVABurnoutVelocity.__dict__ and type(IVABurnoutVelocity.__dict__[attrname]) == property:
            return IVABurnoutVelocity.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVABurnoutVelocity.")
    
    @property
    def BurnoutOption(self) -> "AgEVABurnoutOptions":
        """Select to use the fixed or inertial frame."""
        with agmarshall.AgEnum_arg(AgEVABurnoutOptions) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetBurnoutOption"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @BurnoutOption.setter
    def BurnoutOption(self, newVal:"AgEVABurnoutOptions") -> None:
        with agmarshall.AgEnum_arg(AgEVABurnoutOptions, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetBurnoutOption"](arg_newVal.COM_val))

    @property
    def FixedVelocity(self) -> float:
        """The velocity magnitude . Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetFixedVelocity"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @FixedVelocity.setter
    def FixedVelocity(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetFixedVelocity"](arg_newVal.COM_val))

    @property
    def InertialVelocity(self) -> float:
        """The velocity magnitude. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetInertialVelocity"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @InertialVelocity.setter
    def InertialVelocity(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetInertialVelocity"](arg_newVal.COM_val))

    @property
    def InertialVelocityAzimuth(self) -> typing.Any:
        """The inertial velocity azimuth. Inertial velocity azimuth is the angle from the projection of north in the local horizontal plane to the inertial velocity vector, right handed. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetInertialVelocityAzimuth"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @InertialVelocityAzimuth.setter
    def InertialVelocityAzimuth(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetInertialVelocityAzimuth"](arg_newVal.COM_val))

    @property
    def InertialHorizontalFPA(self) -> typing.Any:
        """Inertial horizontal flight path angle is the angle from the local horizontal to the inertial velocity vector, positive towards radius. It is also 90 degrees minus vertical flight path angle. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetInertialHorizontalFPA"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @InertialHorizontalFPA.setter
    def InertialHorizontalFPA(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetInertialHorizontalFPA"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{A1EA8DE5-41D0-4419-988E-98EEACEECAE9}", IVABurnoutVelocity)
agcls.AgTypeNameMap["IVABurnoutVelocity"] = IVABurnoutVelocity

class IVAAttitudeControl(object):
    """Properties for attitude options for a maneuver segment."""
    _uuid = "{FC43EF22-B727-4538-9E97-B3CD445436CD}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetLeadDuration"] = _raise_uninitialized_error
        self.__dict__["_SetLeadDuration"] = _raise_uninitialized_error
        self.__dict__["_GetTrailDuration"] = _raise_uninitialized_error
        self.__dict__["_SetTrailDuration"] = _raise_uninitialized_error
        self.__dict__["_GetBodyAxis"] = _raise_uninitialized_error
        self.__dict__["_SetBodyAxis"] = _raise_uninitialized_error
        self.__dict__["_GetConstraintSign"] = _raise_uninitialized_error
        self.__dict__["_SetConstraintSign"] = _raise_uninitialized_error
        self.__dict__["_GetConstraintVectorName"] = _raise_uninitialized_error
        self.__dict__["_SetConstraintVectorName"] = _raise_uninitialized_error
        self.__dict__["_GetCustomFunction"] = _raise_uninitialized_error
        self.__dict__["_SetCustomFunction"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAAttitudeControl._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAAttitudeControl from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAAttitudeControl = agcom.GUID(IVAAttitudeControl._uuid)
        vtable_offset_local = IVAAttitudeControl._vtable_offset - 1
        self.__dict__["_GetLeadDuration"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControl, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetLeadDuration"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControl, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetTrailDuration"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControl, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTrailDuration"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControl, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetBodyAxis"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControl, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetBodyAxis"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControl, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetConstraintSign"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControl, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetConstraintSign"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControl, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetConstraintVectorName"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControl, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_SetConstraintVectorName"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControl, vtable_offset_local+10, agcom.BSTR)
        self.__dict__["_GetCustomFunction"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControl, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_SetCustomFunction"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControl, vtable_offset_local+12, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAAttitudeControl.__dict__ and type(IVAAttitudeControl.__dict__[attrname]) == property:
            return IVAAttitudeControl.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAAttitudeControl.")
    
    @property
    def LeadDuration(self) -> float:
        """How long before the maneuver starts the maneuver attitude. Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLeadDuration"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @LeadDuration.setter
    def LeadDuration(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetLeadDuration"](arg_newVal.COM_val))

    @property
    def TrailDuration(self) -> float:
        """How long to maintain that attitude after the maneuver. Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTrailDuration"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TrailDuration.setter
    def TrailDuration(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTrailDuration"](arg_newVal.COM_val))

    @property
    def BodyAxis(self) -> "AgEVABodyAxis":
        """Whether the engine acceleration (the direction opposite the engine's exhaust) is aligned with positive or negative X, Y or Z body axis."""
        with agmarshall.AgEnum_arg(AgEVABodyAxis) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetBodyAxis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @BodyAxis.setter
    def BodyAxis(self, newVal:"AgEVABodyAxis") -> None:
        with agmarshall.AgEnum_arg(AgEVABodyAxis, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetBodyAxis"](arg_newVal.COM_val))

    @property
    def ConstraintSign(self) -> "AgEVAConstraintSign":
        """Whether the Constraint Vector is positive or negative."""
        with agmarshall.AgEnum_arg(AgEVAConstraintSign) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetConstraintSign"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ConstraintSign.setter
    def ConstraintSign(self, newVal:"AgEVAConstraintSign") -> None:
        with agmarshall.AgEnum_arg(AgEVAConstraintSign, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetConstraintSign"](arg_newVal.COM_val))

    @property
    def ConstraintVectorName(self) -> str:
        """Constraint Vector - the vector toward which this body vector is constrained."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetConstraintVectorName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ConstraintVectorName.setter
    def ConstraintVectorName(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetConstraintVectorName"](arg_newVal.COM_val))

    @property
    def CustomFunction(self) -> "AgEVACustomFunction":
        """The attitude definition to use for other STK functions."""
        with agmarshall.AgEnum_arg(AgEVACustomFunction) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCustomFunction"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CustomFunction.setter
    def CustomFunction(self, newVal:"AgEVACustomFunction") -> None:
        with agmarshall.AgEnum_arg(AgEVACustomFunction, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCustomFunction"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{FC43EF22-B727-4538-9E97-B3CD445436CD}", IVAAttitudeControl)
agcls.AgTypeNameMap["IVAAttitudeControl"] = IVAAttitudeControl

class IVAAttitudeControlFinite(IVAAttitudeControl):
    """The attitude control of a finite maneuver"""
    _uuid = "{827F3B46-D066-462B-A3DB-1DCD56A816BA}"
    _num_methods = 0
    _vtable_offset = IVAAttitudeControl._vtable_offset + IVAAttitudeControl._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAAttitudeControlFinite._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAAttitudeControlFinite from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAAttitudeControl._private_init(self, pUnk)
        IID_IVAAttitudeControlFinite = agcom.GUID(IVAAttitudeControlFinite._uuid)
        vtable_offset_local = IVAAttitudeControlFinite._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAAttitudeControlFinite.__dict__ and type(IVAAttitudeControlFinite.__dict__[attrname]) == property:
            return IVAAttitudeControlFinite.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAAttitudeControl.__setattr__(self, attrname, value)
    

agcls.AgClassCatalog.add_catalog_entry("{827F3B46-D066-462B-A3DB-1DCD56A816BA}", IVAAttitudeControlFinite)
agcls.AgTypeNameMap["IVAAttitudeControlFinite"] = IVAAttitudeControlFinite

class IVAAttitudeControlImpulsive(IVAAttitudeControl):
    """The attitude control of an impulsive maneuver."""
    _uuid = "{0BD5E890-FBD8-415E-9E29-38731985F366}"
    _num_methods = 0
    _vtable_offset = IVAAttitudeControl._vtable_offset + IVAAttitudeControl._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAAttitudeControlImpulsive._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAAttitudeControlImpulsive from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAAttitudeControl._private_init(self, pUnk)
        IID_IVAAttitudeControlImpulsive = agcom.GUID(IVAAttitudeControlImpulsive._uuid)
        vtable_offset_local = IVAAttitudeControlImpulsive._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAAttitudeControlImpulsive.__dict__ and type(IVAAttitudeControlImpulsive.__dict__[attrname]) == property:
            return IVAAttitudeControlImpulsive.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAAttitudeControl.__setattr__(self, attrname, value)
    

agcls.AgClassCatalog.add_catalog_entry("{0BD5E890-FBD8-415E-9E29-38731985F366}", IVAAttitudeControlImpulsive)
agcls.AgTypeNameMap["IVAAttitudeControlImpulsive"] = IVAAttitudeControlImpulsive

class IVAAttitudeControlOptimalFinite(IVAAttitudeControl):
    """The attitude control of a optimal finite maneuver"""
    _uuid = "{EF8743CB-4A4F-4B89-AB50-D76843E4D618}"
    _num_methods = 0
    _vtable_offset = IVAAttitudeControl._vtable_offset + IVAAttitudeControl._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAAttitudeControlOptimalFinite._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAAttitudeControlOptimalFinite from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAAttitudeControl._private_init(self, pUnk)
        IID_IVAAttitudeControlOptimalFinite = agcom.GUID(IVAAttitudeControlOptimalFinite._uuid)
        vtable_offset_local = IVAAttitudeControlOptimalFinite._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAAttitudeControlOptimalFinite.__dict__ and type(IVAAttitudeControlOptimalFinite.__dict__[attrname]) == property:
            return IVAAttitudeControlOptimalFinite.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAAttitudeControl.__setattr__(self, attrname, value)
    

agcls.AgClassCatalog.add_catalog_entry("{EF8743CB-4A4F-4B89-AB50-D76843E4D618}", IVAAttitudeControlOptimalFinite)
agcls.AgTypeNameMap["IVAAttitudeControlOptimalFinite"] = IVAAttitudeControlOptimalFinite

class IVAManeuver(object):
    """Properties of an Impulsive Maneuver Segment."""
    _uuid = "{C70B417E-D1C4-40E8-8CDC-67EDED0B56AE}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAttitudeControlType"] = _raise_uninitialized_error
        self.__dict__["_SetAttitudeControlType"] = _raise_uninitialized_error
        self.__dict__["_GetAttitudeControl"] = _raise_uninitialized_error
        self.__dict__["_GetPropulsionMethod"] = _raise_uninitialized_error
        self.__dict__["_SetPropulsionMethod"] = _raise_uninitialized_error
        self.__dict__["_GetPropulsionMethodValue"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAManeuver._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAManeuver from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAManeuver = agcom.GUID(IVAManeuver._uuid)
        vtable_offset_local = IVAManeuver._vtable_offset - 1
        self.__dict__["_GetAttitudeControlType"] = IAGFUNCTYPE(pUnk, IID_IVAManeuver, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetAttitudeControlType"] = IAGFUNCTYPE(pUnk, IID_IVAManeuver, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetAttitudeControl"] = IAGFUNCTYPE(pUnk, IID_IVAManeuver, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetPropulsionMethod"] = IAGFUNCTYPE(pUnk, IID_IVAManeuver, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_SetPropulsionMethod"] = IAGFUNCTYPE(pUnk, IID_IVAManeuver, vtable_offset_local+5, agcom.LONG, agcom.BSTR)
        self.__dict__["_GetPropulsionMethodValue"] = IAGFUNCTYPE(pUnk, IID_IVAManeuver, vtable_offset_local+6, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAManeuver.__dict__ and type(IVAManeuver.__dict__[attrname]) == property:
            return IVAManeuver.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAManeuver.")
    
    @property
    def AttitudeControlType(self) -> "AgEVAAttitudeControl":
        """Determines the attitude parameters available for you to specify."""
        with agmarshall.AgEnum_arg(AgEVAAttitudeControl) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAttitudeControlType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def SetAttitudeControlType(self, attitudeControlType:"AgEVAAttitudeControl") -> None:
        """Sets the attitude control type."""
        with agmarshall.AgEnum_arg(AgEVAAttitudeControl, attitudeControlType) as arg_attitudeControlType:
            agcls.evaluate_hresult(self.__dict__["_SetAttitudeControlType"](arg_attitudeControlType.COM_val))

    @property
    def AttitudeControl(self) -> "IVAAttitudeControl":
        """The attitude control properties collection."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAAttitudeControl:
            agcls.evaluate_hresult(self.__dict__["_GetAttitudeControl"](byref(arg_ppVAAttitudeControl.COM_val)))
            return arg_ppVAAttitudeControl.python_val

    @property
    def PropulsionMethod(self) -> "AgEVAPropulsionMethod":
        """The propulsion type to be modeled."""
        with agmarshall.AgEnum_arg(AgEVAPropulsionMethod) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPropulsionMethod"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def SetPropulsionMethod(self, propulsionMethod:"AgEVAPropulsionMethod", value:str) -> None:
        """Sets the propulsion type and associated engine/thruster set."""
        with agmarshall.AgEnum_arg(AgEVAPropulsionMethod, propulsionMethod) as arg_propulsionMethod, \
             agmarshall.BSTR_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_SetPropulsionMethod"](arg_propulsionMethod.COM_val, arg_value.COM_val))

    @property
    def PropulsionMethodValue(self) -> str:
        """The specific engine model or thruster set to be used for the maneuver."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPropulsionMethodValue"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{C70B417E-D1C4-40E8-8CDC-67EDED0B56AE}", IVAManeuver)
agcls.AgTypeNameMap["IVAManeuver"] = IVAManeuver

class IVADisplaySystem(object):
    """The launch coordinate system."""
    _uuid = "{90BFC47C-35B5-4169-9543-36C65DFABB6A}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVADisplaySystem._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVADisplaySystem from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVADisplaySystem = agcom.GUID(IVADisplaySystem._uuid)
        vtable_offset_local = IVADisplaySystem._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVADisplaySystem.__dict__ and type(IVADisplaySystem.__dict__[attrname]) == property:
            return IVADisplaySystem.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVADisplaySystem.")
    

agcls.AgClassCatalog.add_catalog_entry("{90BFC47C-35B5-4169-9543-36C65DFABB6A}", IVADisplaySystem)
agcls.AgTypeNameMap["IVADisplaySystem"] = IVADisplaySystem

class IVABurnout(object):
    """The burnout point reference frame."""
    _uuid = "{0BEFC7BA-14CF-422D-BD67-352572ABB55F}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVABurnout._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVABurnout from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVABurnout = agcom.GUID(IVABurnout._uuid)
        vtable_offset_local = IVABurnout._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVABurnout.__dict__ and type(IVABurnout.__dict__[attrname]) == property:
            return IVABurnout.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVABurnout.")
    

agcls.AgClassCatalog.add_catalog_entry("{0BEFC7BA-14CF-422D-BD67-352572ABB55F}", IVABurnout)
agcls.AgTypeNameMap["IVABurnout"] = IVABurnout

class IVAScriptingSegment(object):
    """Object properties for scripting options."""
    _uuid = "{08B0F341-8A54-43B8-A0B9-50A462E70C71}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetComponentName"] = _raise_uninitialized_error
        self.__dict__["_SetComponentName"] = _raise_uninitialized_error
        self.__dict__["_GetAttribute"] = _raise_uninitialized_error
        self.__dict__["_SetAttribute"] = _raise_uninitialized_error
        self.__dict__["_GetUnit"] = _raise_uninitialized_error
        self.__dict__["_SetUnit"] = _raise_uninitialized_error
        self.__dict__["_GetAvailableAttributeValues"] = _raise_uninitialized_error
        self.__dict__["_GetReadOnlyProperty"] = _raise_uninitialized_error
        self.__dict__["_SetReadOnlyProperty"] = _raise_uninitialized_error
        self.__dict__["_GetObjectName"] = _raise_uninitialized_error
        self.__dict__["_SetObjectName"] = _raise_uninitialized_error
        self.__dict__["_GetAvailableObjectNames"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAScriptingSegment._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAScriptingSegment from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAScriptingSegment = agcom.GUID(IVAScriptingSegment._uuid)
        vtable_offset_local = IVAScriptingSegment._vtable_offset - 1
        self.__dict__["_GetComponentName"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingSegment, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetComponentName"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingSegment, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetAttribute"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingSegment, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetAttribute"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingSegment, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_GetUnit"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingSegment, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_SetUnit"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingSegment, vtable_offset_local+6, agcom.BSTR)
        self.__dict__["_GetAvailableAttributeValues"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingSegment, vtable_offset_local+7, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetReadOnlyProperty"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingSegment, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetReadOnlyProperty"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingSegment, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_GetObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingSegment, vtable_offset_local+10, POINTER(agcom.BSTR))
        self.__dict__["_SetObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingSegment, vtable_offset_local+11, agcom.BSTR)
        self.__dict__["_GetAvailableObjectNames"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingSegment, vtable_offset_local+12, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAScriptingSegment.__dict__ and type(IVAScriptingSegment.__dict__[attrname]) == property:
            return IVAScriptingSegment.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAScriptingSegment.")
    
    @property
    def ComponentName(self) -> str:
        """The name of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComponentName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ComponentName.setter
    def ComponentName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetComponentName"](arg_inVal.COM_val))

    @property
    def Attribute(self) -> str:
        """The name of the attribute."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAttribute"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Attribute.setter
    def Attribute(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAttribute"](arg_inVal.COM_val))

    @property
    def Unit(self) -> str:
        """The unit."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUnit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Unit.setter
    def Unit(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUnit"](arg_inVal.COM_val))

    @property
    def AvailableAttributeValues(self) -> list:
        """Returns a list of available attribute values."""
        with agmarshall.SAFEARRAY_arg() as arg_ppNewVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailableAttributeValues"](byref(arg_ppNewVal.COM_val)))
            return arg_ppNewVal.python_val

    @property
    def ReadOnlyProperty(self) -> bool:
        """True if it is a read-only property."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetReadOnlyProperty"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ReadOnlyProperty.setter
    def ReadOnlyProperty(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetReadOnlyProperty"](arg_inVal.COM_val))

    @property
    def ObjectName(self) -> str:
        """The profile/segment that contains the attribute."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetObjectName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ObjectName.setter
    def ObjectName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetObjectName"](arg_inVal.COM_val))

    @property
    def AvailableObjectNames(self) -> list:
        """Returns a list of available profile/segment names."""
        with agmarshall.SAFEARRAY_arg() as arg_ppNewVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailableObjectNames"](byref(arg_ppNewVal.COM_val)))
            return arg_ppNewVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{08B0F341-8A54-43B8-A0B9-50A462E70C71}", IVAScriptingSegment)
agcls.AgTypeNameMap["IVAScriptingSegment"] = IVAScriptingSegment

class IVAScriptingSegmentCollection(object):
    """The list of object properties that the script can interact with."""
    _uuid = "{07549510-B2B9-4AA0-A9AA-E2FDFBC9BBEE}"
    _num_methods = 12
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Add"] = _raise_uninitialized_error
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_RemoveAll"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetProvideRuntimeTypeInfo"] = _raise_uninitialized_error
        self.__dict__["_Cut"] = _raise_uninitialized_error
        self.__dict__["_Paste"] = _raise_uninitialized_error
        self.__dict__["_InsertCopy"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAScriptingSegmentCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAScriptingSegmentCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAScriptingSegmentCollection = agcom.GUID(IVAScriptingSegmentCollection._uuid)
        vtable_offset_local = IVAScriptingSegmentCollection._vtable_offset - 1
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingSegmentCollection, vtable_offset_local+1, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Add"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingSegmentCollection, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingSegmentCollection, vtable_offset_local+3, agcom.VARIANT)
        self.__dict__["_RemoveAll"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingSegmentCollection, vtable_offset_local+4, )
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingSegmentCollection, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingSegmentCollection, vtable_offset_local+6, POINTER(agcom.LONG))
        self.__dict__["_GetProvideRuntimeTypeInfo"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingSegmentCollection, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_Cut"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingSegmentCollection, vtable_offset_local+8, agcom.VARIANT)
        self.__dict__["_Paste"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingSegmentCollection, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_InsertCopy"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingSegmentCollection, vtable_offset_local+10, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingSegmentCollection, vtable_offset_local+11, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingSegmentCollection, vtable_offset_local+12, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAScriptingSegmentCollection.__dict__ and type(IVAScriptingSegmentCollection.__dict__[attrname]) == property:
            return IVAScriptingSegmentCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAScriptingSegmentCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVAScriptingSegment":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Item(self, indexOrName:typing.Any) -> "IVAScriptingSegment":
        """Allows you to iterate through the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppVAScriptingSegment:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppVAScriptingSegment.COM_val)))
            return arg_ppVAScriptingSegment.python_val

    def Add(self, componentName:str) -> "IVAScriptingSegment":
        """Adds an object property to the collection."""
        with agmarshall.BSTR_arg(componentName) as arg_componentName, \
             agmarshall.AgInterface_out_arg() as arg_ppVAScriptingSegment:
            agcls.evaluate_hresult(self.__dict__["_Add"](arg_componentName.COM_val, byref(arg_ppVAScriptingSegment.COM_val)))
            return arg_ppVAScriptingSegment.python_val

    def Remove(self, indexOrName:typing.Any) -> None:
        """Removes a object property."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_indexOrName.COM_val))

    def RemoveAll(self) -> None:
        """Removes all object properties."""
        agcls.evaluate_hresult(self.__dict__["_RemoveAll"]())

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ProvideRuntimeTypeInfo(self) -> "IRuntimeTypeInfo":
        """Returns the IAgRuntimeTypeInfo interface to access properties at runtime."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProvideRuntimeTypeInfo"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Cut(self, indexOrName:typing.Any) -> None:
        """Copies the object property into the clipboard and removes the object property from the list."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_Cut"](arg_indexOrName.COM_val))

    def Paste(self) -> "IVAScriptingSegment":
        """Pastes the object property from the clipboard and inserts into the list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Paste"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def InsertCopy(self, objProperty:"IVAScriptingSegment") -> "IVAScriptingSegment":
        """Copies the object property and inserts the copy into the list."""
        with agmarshall.AgInterface_in_arg(objProperty, IVAScriptingSegment) as arg_objProperty, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_InsertCopy"](arg_objProperty.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "IVAScriptingSegment":
        """Retrieves a scripting segment in the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppVAScriptingSegment:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppVAScriptingSegment.COM_val)))
            return arg_ppVAScriptingSegment.python_val

    def GetItemByName(self, name:str) -> "IVAScriptingSegment":
        """Retrieves a scripting segment in the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppVAScriptingSegment:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppVAScriptingSegment.COM_val)))
            return arg_ppVAScriptingSegment.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{07549510-B2B9-4AA0-A9AA-E2FDFBC9BBEE}", IVAScriptingSegmentCollection)
agcls.AgTypeNameMap["IVAScriptingSegmentCollection"] = IVAScriptingSegmentCollection

class IVAScriptingParameterEnumerationChoice(object):
    """Enumeration choice."""
    _uuid = "{DED30CDF-730F-4125-AEB8-6A668248B484}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetName"] = _raise_uninitialized_error
        self.__dict__["_SetName"] = _raise_uninitialized_error
        self.__dict__["_GetValue"] = _raise_uninitialized_error
        self.__dict__["_SetValue"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAScriptingParameterEnumerationChoice._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAScriptingParameterEnumerationChoice from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAScriptingParameterEnumerationChoice = agcom.GUID(IVAScriptingParameterEnumerationChoice._uuid)
        vtable_offset_local = IVAScriptingParameterEnumerationChoice._vtable_offset - 1
        self.__dict__["_GetName"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameterEnumerationChoice, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetName"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameterEnumerationChoice, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetValue"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameterEnumerationChoice, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetValue"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameterEnumerationChoice, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAScriptingParameterEnumerationChoice.__dict__ and type(IVAScriptingParameterEnumerationChoice.__dict__[attrname]) == property:
            return IVAScriptingParameterEnumerationChoice.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAScriptingParameterEnumerationChoice.")
    
    @property
    def Name(self) -> str:
        """Name of the enumeration"""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Name.setter
    def Name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetName"](arg_inVal.COM_val))

    @property
    def Value(self) -> int:
        """Integer value of the enumeration"""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetValue"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Value.setter
    def Value(self, inVal:int) -> None:
        with agmarshall.LONG_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetValue"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{DED30CDF-730F-4125-AEB8-6A668248B484}", IVAScriptingParameterEnumerationChoice)
agcls.AgTypeNameMap["IVAScriptingParameterEnumerationChoice"] = IVAScriptingParameterEnumerationChoice

class IVAScriptingParameterEnumerationChoiceCollection(object):
    """The list of enumeration choices available when parameter type is Enumeration."""
    _uuid = "{FF132A94-418D-41DB-8AA2-9DA77625A1A0}"
    _num_methods = 11
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Add"] = _raise_uninitialized_error
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_Cut"] = _raise_uninitialized_error
        self.__dict__["_Paste"] = _raise_uninitialized_error
        self.__dict__["_InsertCopy"] = _raise_uninitialized_error
        self.__dict__["_GetProvideRuntimeTypeInfo"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAScriptingParameterEnumerationChoiceCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAScriptingParameterEnumerationChoiceCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAScriptingParameterEnumerationChoiceCollection = agcom.GUID(IVAScriptingParameterEnumerationChoiceCollection._uuid)
        vtable_offset_local = IVAScriptingParameterEnumerationChoiceCollection._vtable_offset - 1
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameterEnumerationChoiceCollection, vtable_offset_local+1, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Add"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameterEnumerationChoiceCollection, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameterEnumerationChoiceCollection, vtable_offset_local+3, agcom.VARIANT)
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameterEnumerationChoiceCollection, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameterEnumerationChoiceCollection, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_Cut"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameterEnumerationChoiceCollection, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_Paste"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameterEnumerationChoiceCollection, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_InsertCopy"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameterEnumerationChoiceCollection, vtable_offset_local+8, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_GetProvideRuntimeTypeInfo"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameterEnumerationChoiceCollection, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameterEnumerationChoiceCollection, vtable_offset_local+10, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameterEnumerationChoiceCollection, vtable_offset_local+11, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAScriptingParameterEnumerationChoiceCollection.__dict__ and type(IVAScriptingParameterEnumerationChoiceCollection.__dict__[attrname]) == property:
            return IVAScriptingParameterEnumerationChoiceCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAScriptingParameterEnumerationChoiceCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVAScriptingParameterEnumerationChoice":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Item(self, indexOrName:typing.Any) -> "IVAScriptingParameterEnumerationChoice":
        """Allows you to iterate through the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppChoice:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppChoice.COM_val)))
            return arg_ppChoice.python_val

    def Add(self, choiceName:str) -> "IVAScriptingParameterEnumerationChoice":
        """Adds an enumeration choice to the collection."""
        with agmarshall.BSTR_arg(choiceName) as arg_choiceName, \
             agmarshall.AgInterface_out_arg() as arg_ppChoice:
            agcls.evaluate_hresult(self.__dict__["_Add"](arg_choiceName.COM_val, byref(arg_ppChoice.COM_val)))
            return arg_ppChoice.python_val

    def Remove(self, indexOrName:typing.Any) -> None:
        """Removes an enumeration choice."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_indexOrName.COM_val))

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def Cut(self, indexOrName:typing.Any) -> None:
        """Copies the enumeration choice into the clipboard and removes the enumeration choice from the list."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_Cut"](arg_indexOrName.COM_val))

    def Paste(self) -> "IVAScriptingParameterEnumerationChoice":
        """Pastes the enumeration choice from the clipboard and inserts into the list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Paste"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def InsertCopy(self, choice:"IVAScriptingParameterEnumerationChoice") -> "IVAScriptingParameterEnumerationChoice":
        """Copies the enumeration choice and inserts the copy into the list."""
        with agmarshall.AgInterface_in_arg(choice, IVAScriptingParameterEnumerationChoice) as arg_choice, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_InsertCopy"](arg_choice.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ProvideRuntimeTypeInfo(self) -> "IRuntimeTypeInfo":
        """Returns the IAgRuntimeTypeInfo interface to access properties at runtime."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProvideRuntimeTypeInfo"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "IVAScriptingParameterEnumerationChoice":
        """Retrieves a scripting parameter enumeration choice in the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppChoice:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppChoice.COM_val)))
            return arg_ppChoice.python_val

    def GetItemByName(self, name:str) -> "IVAScriptingParameterEnumerationChoice":
        """Retrieves a scripting parameter enumeration choice in the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppChoice:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppChoice.COM_val)))
            return arg_ppChoice.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{FF132A94-418D-41DB-8AA2-9DA77625A1A0}", IVAScriptingParameterEnumerationChoiceCollection)
agcls.AgTypeNameMap["IVAScriptingParameterEnumerationChoiceCollection"] = IVAScriptingParameterEnumerationChoiceCollection

class IVAScriptingParameter(object):
    """Parameter properties for scripting options."""
    _uuid = "{9E855CDD-3359-4D5D-AE7D-5C260E0EE4B3}"
    _num_methods = 23
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetName"] = _raise_uninitialized_error
        self.__dict__["_SetName"] = _raise_uninitialized_error
        self.__dict__["_GetParamValue"] = _raise_uninitialized_error
        self.__dict__["_SetParamValue"] = _raise_uninitialized_error
        self.__dict__["_GetUnit"] = _raise_uninitialized_error
        self.__dict__["_SetUnit"] = _raise_uninitialized_error
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_SetType"] = _raise_uninitialized_error
        self.__dict__["_GetInheritValue"] = _raise_uninitialized_error
        self.__dict__["_SetInheritValue"] = _raise_uninitialized_error
        self.__dict__["_GetUserComment"] = _raise_uninitialized_error
        self.__dict__["_SetUserComment"] = _raise_uninitialized_error
        self.__dict__["_GetDimension"] = _raise_uninitialized_error
        self.__dict__["_SetDimension"] = _raise_uninitialized_error
        self.__dict__["_GetEnumerationChoices"] = _raise_uninitialized_error
        self.__dict__["_GetUseMinValue"] = _raise_uninitialized_error
        self.__dict__["_SetUseMinValue"] = _raise_uninitialized_error
        self.__dict__["_GetMinValue"] = _raise_uninitialized_error
        self.__dict__["_SetMinValue"] = _raise_uninitialized_error
        self.__dict__["_GetUseMaxValue"] = _raise_uninitialized_error
        self.__dict__["_SetUseMaxValue"] = _raise_uninitialized_error
        self.__dict__["_GetMaxValue"] = _raise_uninitialized_error
        self.__dict__["_SetMaxValue"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAScriptingParameter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAScriptingParameter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAScriptingParameter = agcom.GUID(IVAScriptingParameter._uuid)
        vtable_offset_local = IVAScriptingParameter._vtable_offset - 1
        self.__dict__["_GetName"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameter, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetName"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameter, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetParamValue"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameter, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_SetParamValue"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameter, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_GetUnit"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameter, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_SetUnit"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameter, vtable_offset_local+6, agcom.BSTR)
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameter, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetType"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameter, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetInheritValue"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameter, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetInheritValue"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameter, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_GetUserComment"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameter, vtable_offset_local+11, POINTER(agcom.BSTR))
        self.__dict__["_SetUserComment"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameter, vtable_offset_local+12, agcom.BSTR)
        self.__dict__["_GetDimension"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameter, vtable_offset_local+13, POINTER(agcom.BSTR))
        self.__dict__["_SetDimension"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameter, vtable_offset_local+14, agcom.BSTR)
        self.__dict__["_GetEnumerationChoices"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameter, vtable_offset_local+15, POINTER(agcom.PVOID))
        self.__dict__["_GetUseMinValue"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameter, vtable_offset_local+16, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseMinValue"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameter, vtable_offset_local+17, agcom.VARIANT_BOOL)
        self.__dict__["_GetMinValue"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameter, vtable_offset_local+18, POINTER(agcom.VARIANT))
        self.__dict__["_SetMinValue"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameter, vtable_offset_local+19, agcom.VARIANT)
        self.__dict__["_GetUseMaxValue"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameter, vtable_offset_local+20, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseMaxValue"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameter, vtable_offset_local+21, agcom.VARIANT_BOOL)
        self.__dict__["_GetMaxValue"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameter, vtable_offset_local+22, POINTER(agcom.VARIANT))
        self.__dict__["_SetMaxValue"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameter, vtable_offset_local+23, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAScriptingParameter.__dict__ and type(IVAScriptingParameter.__dict__[attrname]) == property:
            return IVAScriptingParameter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAScriptingParameter.")
    
    @property
    def Name(self) -> str:
        """The parameter name."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Name.setter
    def Name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetName"](arg_inVal.COM_val))

    @property
    def ParamValue(self) -> typing.Any:
        """The parameter value.  Set in Object Model unit preference for selected dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetParamValue"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ParamValue.setter
    def ParamValue(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetParamValue"](arg_inVal.COM_val))

    @property
    def Unit(self) -> str:
        """The parameter's unit that is used to represent ParamValue during the scripting tool script execution. ParamValue is set in Object Model unit preference for selected dimension and not this unit. As with other units configurable in the desktop environment for STK, this unit is separate (and may differ) from the Object Model unit preference."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUnit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Unit.setter
    def Unit(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUnit"](arg_inVal.COM_val))

    @property
    def Type(self) -> "AgEVAScriptingParameterType":
        """The parameter's type."""
        with agmarshall.AgEnum_arg(AgEVAScriptingParameterType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Type.setter
    def Type(self, inVal:"AgEVAScriptingParameterType") -> None:
        with agmarshall.AgEnum_arg(AgEVAScriptingParameterType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetType"](arg_inVal.COM_val))

    @property
    def InheritValue(self) -> bool:
        """If true, parameter value will be inherited from previous profile's value."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVAl:
            agcls.evaluate_hresult(self.__dict__["_GetInheritValue"](byref(arg_pVAl.COM_val)))
            return arg_pVAl.python_val

    @InheritValue.setter
    def InheritValue(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetInheritValue"](arg_inVal.COM_val))

    @property
    def UserComment(self) -> str:
        """The parameter's comment."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUserComment"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UserComment.setter
    def UserComment(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUserComment"](arg_inVal.COM_val))

    @property
    def Dimension(self) -> str:
        """The parameter's dimension."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDimension"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Dimension.setter
    def Dimension(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDimension"](arg_inVal.COM_val))

    @property
    def EnumerationChoices(self) -> "IVAScriptingParameterEnumerationChoiceCollection":
        """The collection of enumerations to use when parameter type is eVAScriptingParameterTypeEnumeration."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnumerationChoices"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def UseMinValue(self) -> bool:
        """If true, a minimum value will be enforced for the parameter value"""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseMinValue"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseMinValue.setter
    def UseMinValue(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseMinValue"](arg_inVal.COM_val))

    @property
    def MinValue(self) -> typing.Any:
        """The minimum value permitted for the parameter value"""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinValue"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MinValue.setter
    def MinValue(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMinValue"](arg_inVal.COM_val))

    @property
    def UseMaxValue(self) -> bool:
        """If true, a maximum value will be enforced for the parameter value"""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseMaxValue"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseMaxValue.setter
    def UseMaxValue(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseMaxValue"](arg_inVal.COM_val))

    @property
    def MaxValue(self) -> typing.Any:
        """The maximum value permitted for the parameter value"""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxValue"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxValue.setter
    def MaxValue(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxValue"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{9E855CDD-3359-4D5D-AE7D-5C260E0EE4B3}", IVAScriptingParameter)
agcls.AgTypeNameMap["IVAScriptingParameter"] = IVAScriptingParameter

class IVAScriptingParameterCollection(object):
    """The list of parameters that the script can interact with."""
    _uuid = "{57FC26AA-550D-4408-844E-24F983C94671}"
    _num_methods = 12
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Add"] = _raise_uninitialized_error
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_RemoveAll"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetProvideRuntimeTypeInfo"] = _raise_uninitialized_error
        self.__dict__["_Cut"] = _raise_uninitialized_error
        self.__dict__["_Paste"] = _raise_uninitialized_error
        self.__dict__["_InsertCopy"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAScriptingParameterCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAScriptingParameterCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAScriptingParameterCollection = agcom.GUID(IVAScriptingParameterCollection._uuid)
        vtable_offset_local = IVAScriptingParameterCollection._vtable_offset - 1
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameterCollection, vtable_offset_local+1, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Add"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameterCollection, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameterCollection, vtable_offset_local+3, agcom.VARIANT)
        self.__dict__["_RemoveAll"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameterCollection, vtable_offset_local+4, )
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameterCollection, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameterCollection, vtable_offset_local+6, POINTER(agcom.LONG))
        self.__dict__["_GetProvideRuntimeTypeInfo"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameterCollection, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_Cut"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameterCollection, vtable_offset_local+8, agcom.VARIANT)
        self.__dict__["_Paste"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameterCollection, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_InsertCopy"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameterCollection, vtable_offset_local+10, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameterCollection, vtable_offset_local+11, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingParameterCollection, vtable_offset_local+12, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAScriptingParameterCollection.__dict__ and type(IVAScriptingParameterCollection.__dict__[attrname]) == property:
            return IVAScriptingParameterCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAScriptingParameterCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVAScriptingParameter":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Item(self, indexOrName:typing.Any) -> "IVAScriptingParameter":
        """Allows you to iterate through the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppVAScriptingParameter:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppVAScriptingParameter.COM_val)))
            return arg_ppVAScriptingParameter.python_val

    def Add(self, parameterName:str) -> "IVAScriptingParameter":
        """Adds a parameter to the collection."""
        with agmarshall.BSTR_arg(parameterName) as arg_parameterName, \
             agmarshall.AgInterface_out_arg() as arg_ppVAScriptingParameter:
            agcls.evaluate_hresult(self.__dict__["_Add"](arg_parameterName.COM_val, byref(arg_ppVAScriptingParameter.COM_val)))
            return arg_ppVAScriptingParameter.python_val

    def Remove(self, indexOrName:typing.Any) -> None:
        """Removes a parameter."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_indexOrName.COM_val))

    def RemoveAll(self) -> None:
        """Removes all parameters."""
        agcls.evaluate_hresult(self.__dict__["_RemoveAll"]())

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ProvideRuntimeTypeInfo(self) -> "IRuntimeTypeInfo":
        """Returns the IAgRuntimeTypeInfo interface to access properties at runtime."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProvideRuntimeTypeInfo"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Cut(self, indexOrName:typing.Any) -> None:
        """Copies the parameter into the clipboard and removes the parameter from the list."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_Cut"](arg_indexOrName.COM_val))

    def Paste(self) -> "IVAScriptingParameter":
        """Pastes the parameter from the clipboard and inserts into the list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Paste"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def InsertCopy(self, parameter:"IVAScriptingParameter") -> "IVAScriptingParameter":
        """Copies the parameter and inserts the copy into the list."""
        with agmarshall.AgInterface_in_arg(parameter, IVAScriptingParameter) as arg_parameter, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_InsertCopy"](arg_parameter.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "IVAScriptingParameter":
        """Retrieves a scripting parameter in the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppVAScriptingParameter:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppVAScriptingParameter.COM_val)))
            return arg_ppVAScriptingParameter.python_val

    def GetItemByName(self, name:str) -> "IVAScriptingParameter":
        """Retrieves a scripting parameter in the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppVAScriptingParameter:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppVAScriptingParameter.COM_val)))
            return arg_ppVAScriptingParameter.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{57FC26AA-550D-4408-844E-24F983C94671}", IVAScriptingParameterCollection)
agcls.AgTypeNameMap["IVAScriptingParameterCollection"] = IVAScriptingParameterCollection

class IVAScriptingCalcObject(object):
    """Calc Object properties for scripting options."""
    _uuid = "{6DDE7375-1872-436C-B2BE-ADBF1881FFF0}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetComponentName"] = _raise_uninitialized_error
        self.__dict__["_SetComponentName"] = _raise_uninitialized_error
        self.__dict__["_GetCalcObjectName"] = _raise_uninitialized_error
        self.__dict__["_SetCalcObjectName"] = _raise_uninitialized_error
        self.__dict__["_GetCalcObject"] = _raise_uninitialized_error
        self.__dict__["_SetCalcObject"] = _raise_uninitialized_error
        self.__dict__["_GetUnit"] = _raise_uninitialized_error
        self.__dict__["_SetUnit"] = _raise_uninitialized_error
        self.__dict__["_CopyCalcObjectToClipboard"] = _raise_uninitialized_error
        self.__dict__["_PasteCalcObjectFromClipboard"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAScriptingCalcObject._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAScriptingCalcObject from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAScriptingCalcObject = agcom.GUID(IVAScriptingCalcObject._uuid)
        vtable_offset_local = IVAScriptingCalcObject._vtable_offset - 1
        self.__dict__["_GetComponentName"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingCalcObject, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetComponentName"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingCalcObject, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetCalcObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingCalcObject, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetCalcObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingCalcObject, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_GetCalcObject"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingCalcObject, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetCalcObject"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingCalcObject, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetUnit"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingCalcObject, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_SetUnit"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingCalcObject, vtable_offset_local+8, agcom.BSTR)
        self.__dict__["_CopyCalcObjectToClipboard"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingCalcObject, vtable_offset_local+9, )
        self.__dict__["_PasteCalcObjectFromClipboard"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingCalcObject, vtable_offset_local+10, )
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAScriptingCalcObject.__dict__ and type(IVAScriptingCalcObject.__dict__[attrname]) == property:
            return IVAScriptingCalcObject.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAScriptingCalcObject.")
    
    @property
    def ComponentName(self) -> str:
        """The name of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComponentName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ComponentName.setter
    def ComponentName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetComponentName"](arg_inVal.COM_val))

    @property
    def CalcObjectName(self) -> str:
        """The name of the calculation object."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCalcObjectName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CalcObjectName.setter
    def CalcObjectName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCalcObjectName"](arg_inVal.COM_val))

    @property
    def CalcObject(self) -> "IComponentInfo":
        """The calculation object type."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCalcObject"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @CalcObject.setter
    def CalcObject(self, inVal:"IComponentInfo") -> None:
        with agmarshall.AgInterface_in_arg(inVal, IComponentInfo) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCalcObject"](arg_inVal.COM_val))

    @property
    def Unit(self) -> str:
        """The unit."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUnit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Unit.setter
    def Unit(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUnit"](arg_inVal.COM_val))

    def CopyCalcObjectToClipboard(self) -> None:
        """Copies the wrapped calc object to the clipboard."""
        agcls.evaluate_hresult(self.__dict__["_CopyCalcObjectToClipboard"]())

    def PasteCalcObjectFromClipboard(self) -> None:
        """Replaces the wrapped calc object with the instance in the clipboard."""
        agcls.evaluate_hresult(self.__dict__["_PasteCalcObjectFromClipboard"]())


agcls.AgClassCatalog.add_catalog_entry("{6DDE7375-1872-436C-B2BE-ADBF1881FFF0}", IVAScriptingCalcObject)
agcls.AgTypeNameMap["IVAScriptingCalcObject"] = IVAScriptingCalcObject

class IVAScriptingCalcObjectCollection(object):
    """The list of calc objects that the script can interact with."""
    _uuid = "{C7742744-0197-46E3-AE3F-E6F60357FACD}"
    _num_methods = 11
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Add"] = _raise_uninitialized_error
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_RemoveAll"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_Cut"] = _raise_uninitialized_error
        self.__dict__["_Paste"] = _raise_uninitialized_error
        self.__dict__["_InsertCopy"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAScriptingCalcObjectCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAScriptingCalcObjectCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAScriptingCalcObjectCollection = agcom.GUID(IVAScriptingCalcObjectCollection._uuid)
        vtable_offset_local = IVAScriptingCalcObjectCollection._vtable_offset - 1
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingCalcObjectCollection, vtable_offset_local+1, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Add"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingCalcObjectCollection, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingCalcObjectCollection, vtable_offset_local+3, agcom.VARIANT)
        self.__dict__["_RemoveAll"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingCalcObjectCollection, vtable_offset_local+4, )
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingCalcObjectCollection, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingCalcObjectCollection, vtable_offset_local+6, POINTER(agcom.LONG))
        self.__dict__["_Cut"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingCalcObjectCollection, vtable_offset_local+7, agcom.VARIANT)
        self.__dict__["_Paste"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingCalcObjectCollection, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_InsertCopy"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingCalcObjectCollection, vtable_offset_local+9, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingCalcObjectCollection, vtable_offset_local+10, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingCalcObjectCollection, vtable_offset_local+11, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAScriptingCalcObjectCollection.__dict__ and type(IVAScriptingCalcObjectCollection.__dict__[attrname]) == property:
            return IVAScriptingCalcObjectCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAScriptingCalcObjectCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVAScriptingCalcObject":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Item(self, indexOrName:typing.Any) -> "IVAScriptingCalcObject":
        """Allows you to iterate through the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppCalcObjectWrapper:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppCalcObjectWrapper.COM_val)))
            return arg_ppCalcObjectWrapper.python_val

    def Add(self, componentName:str) -> "IVAScriptingCalcObject":
        """Adds a calculation object to the collection."""
        with agmarshall.BSTR_arg(componentName) as arg_componentName, \
             agmarshall.AgInterface_out_arg() as arg_ppVAScriptingParameter:
            agcls.evaluate_hresult(self.__dict__["_Add"](arg_componentName.COM_val, byref(arg_ppVAScriptingParameter.COM_val)))
            return arg_ppVAScriptingParameter.python_val

    def Remove(self, indexOrName:typing.Any) -> None:
        """Removes a calculation object."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_indexOrName.COM_val))

    def RemoveAll(self) -> None:
        """Removes all calculation objects."""
        agcls.evaluate_hresult(self.__dict__["_RemoveAll"]())

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def Cut(self, indexOrName:typing.Any) -> None:
        """Copies the calc object into the clipboard and removes the calc object from the list."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_Cut"](arg_indexOrName.COM_val))

    def Paste(self) -> "IVAScriptingCalcObject":
        """Pastes the calc object from the clipboard and inserts into the list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Paste"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def InsertCopy(self, calcObj:"IVAScriptingCalcObject") -> "IVAScriptingCalcObject":
        """Copies the calc object and inserts the copy into the list."""
        with agmarshall.AgInterface_in_arg(calcObj, IVAScriptingCalcObject) as arg_calcObj, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_InsertCopy"](arg_calcObj.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "IVAScriptingCalcObject":
        """Retrieves a scripting calc object from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByName(self, componentName:str) -> "IVAScriptingCalcObject":
        """Retrieves a scripting calc object from the collection by name."""
        with agmarshall.BSTR_arg(componentName) as arg_componentName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_componentName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{C7742744-0197-46E3-AE3F-E6F60357FACD}", IVAScriptingCalcObjectCollection)
agcls.AgTypeNameMap["IVAScriptingCalcObjectCollection"] = IVAScriptingCalcObjectCollection

class IVAScriptingTool(object):
    """Properties for the Scripting Tool."""
    _uuid = "{BA2389F3-C687-40B6-B4FC-F61F2BF80E6E}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEnable"] = _raise_uninitialized_error
        self.__dict__["_SetEnable"] = _raise_uninitialized_error
        self.__dict__["_GetSegmentProperties"] = _raise_uninitialized_error
        self.__dict__["_GetCalcObjects"] = _raise_uninitialized_error
        self.__dict__["_GetParameters"] = _raise_uninitialized_error
        self.__dict__["_GetLanguageType"] = _raise_uninitialized_error
        self.__dict__["_SetLanguageType"] = _raise_uninitialized_error
        self.__dict__["_ScriptText"] = _raise_uninitialized_error
        self.__dict__["_CopyToClipboard"] = _raise_uninitialized_error
        self.__dict__["_PasteFromClipboard"] = _raise_uninitialized_error
        self.__dict__["_GetPreIterate"] = _raise_uninitialized_error
        self.__dict__["_SetPreIterate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAScriptingTool._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAScriptingTool from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAScriptingTool = agcom.GUID(IVAScriptingTool._uuid)
        vtable_offset_local = IVAScriptingTool._vtable_offset - 1
        self.__dict__["_GetEnable"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingTool, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnable"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingTool, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetSegmentProperties"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingTool, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetCalcObjects"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingTool, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetParameters"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingTool, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_GetLanguageType"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingTool, vtable_offset_local+6, POINTER(agcom.LONG))
        self.__dict__["_SetLanguageType"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingTool, vtable_offset_local+7, agcom.LONG)
        self.__dict__["_ScriptText"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingTool, vtable_offset_local+8, agcom.BSTR)
        self.__dict__["_CopyToClipboard"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingTool, vtable_offset_local+9, )
        self.__dict__["_PasteFromClipboard"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingTool, vtable_offset_local+10, )
        self.__dict__["_GetPreIterate"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingTool, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetPreIterate"] = IAGFUNCTYPE(pUnk, IID_IVAScriptingTool, vtable_offset_local+12, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAScriptingTool.__dict__ and type(IVAScriptingTool.__dict__[attrname]) == property:
            return IVAScriptingTool.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAScriptingTool.")
    
    @property
    def Enable(self) -> bool:
        """If true, the scripting tool is enabled."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Enable.setter
    def Enable(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnable"](arg_inVal.COM_val))

    @property
    def SegmentProperties(self) -> "IVAScriptingSegmentCollection":
        """Returns the collection of the segment properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSegmentProperties"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def CalcObjects(self) -> "IVAScriptingCalcObjectCollection":
        """Returns the collection of the calculation objects."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCalcObjects"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Parameters(self) -> "IVAScriptingParameterCollection":
        """Returns the collection of parameters."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetParameters"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def LanguageType(self) -> "AgEVALanguage":
        """The scripting language being used."""
        with agmarshall.AgEnum_arg(AgEVALanguage) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLanguageType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @LanguageType.setter
    def LanguageType(self, inVal:"AgEVALanguage") -> None:
        with agmarshall.AgEnum_arg(AgEVALanguage, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetLanguageType"](arg_inVal.COM_val))

    def ScriptText(self, script:str) -> None:
        """Injects the script into the scripting tool."""
        with agmarshall.BSTR_arg(script) as arg_script:
            agcls.evaluate_hresult(self.__dict__["_ScriptText"](arg_script.COM_val))

    def CopyToClipboard(self) -> None:
        """Copies entire scripting tool to clipboard."""
        agcls.evaluate_hresult(self.__dict__["_CopyToClipboard"]())

    def PasteFromClipboard(self) -> None:
        """Replaces entire scripting tool with scripting tool in clipboard."""
        agcls.evaluate_hresult(self.__dict__["_PasteFromClipboard"]())

    @property
    def PreIterate(self) -> bool:
        """If true, the sequence will run once before executing the script."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPreIterate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @PreIterate.setter
    def PreIterate(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetPreIterate"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{BA2389F3-C687-40B6-B4FC-F61F2BF80E6E}", IVAScriptingTool)
agcls.AgTypeNameMap["IVAScriptingTool"] = IVAScriptingTool

class IVAElement(object):
    """The elements of the selected coordinate type."""
    _uuid = "{D1D2C328-052A-4C2A-BC2F-739B55556384}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAElement._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAElement from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAElement = agcom.GUID(IVAElement._uuid)
        vtable_offset_local = IVAElement._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAElement.__dict__ and type(IVAElement.__dict__[attrname]) == property:
            return IVAElement.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAElement.")
    

agcls.AgClassCatalog.add_catalog_entry("{D1D2C328-052A-4C2A-BC2F-739B55556384}", IVAElement)
agcls.AgTypeNameMap["IVAElement"] = IVAElement

class IVASpacecraftParameters(object):
    """Properties for spacecraft configuration."""
    _uuid = "{6642A93A-65F8-4D50-A3E8-51B17A9AE3CF}"
    _num_methods = 18
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetDryMass"] = _raise_uninitialized_error
        self.__dict__["_SetDryMass"] = _raise_uninitialized_error
        self.__dict__["_GetCd"] = _raise_uninitialized_error
        self.__dict__["_SetCd"] = _raise_uninitialized_error
        self.__dict__["_GetDragArea"] = _raise_uninitialized_error
        self.__dict__["_SetDragArea"] = _raise_uninitialized_error
        self.__dict__["_GetCr"] = _raise_uninitialized_error
        self.__dict__["_SetCr"] = _raise_uninitialized_error
        self.__dict__["_GetSolarRadiationPressureArea"] = _raise_uninitialized_error
        self.__dict__["_SetSolarRadiationPressureArea"] = _raise_uninitialized_error
        self.__dict__["_GetCk"] = _raise_uninitialized_error
        self.__dict__["_SetCk"] = _raise_uninitialized_error
        self.__dict__["_GetRadiationPressureArea"] = _raise_uninitialized_error
        self.__dict__["_SetRadiationPressureArea"] = _raise_uninitialized_error
        self.__dict__["_GetK1"] = _raise_uninitialized_error
        self.__dict__["_SetK1"] = _raise_uninitialized_error
        self.__dict__["_GetK2"] = _raise_uninitialized_error
        self.__dict__["_SetK2"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVASpacecraftParameters._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVASpacecraftParameters from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVASpacecraftParameters = agcom.GUID(IVASpacecraftParameters._uuid)
        vtable_offset_local = IVASpacecraftParameters._vtable_offset - 1
        self.__dict__["_GetDryMass"] = IAGFUNCTYPE(pUnk, IID_IVASpacecraftParameters, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDryMass"] = IAGFUNCTYPE(pUnk, IID_IVASpacecraftParameters, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetCd"] = IAGFUNCTYPE(pUnk, IID_IVASpacecraftParameters, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetCd"] = IAGFUNCTYPE(pUnk, IID_IVASpacecraftParameters, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetDragArea"] = IAGFUNCTYPE(pUnk, IID_IVASpacecraftParameters, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDragArea"] = IAGFUNCTYPE(pUnk, IID_IVASpacecraftParameters, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetCr"] = IAGFUNCTYPE(pUnk, IID_IVASpacecraftParameters, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetCr"] = IAGFUNCTYPE(pUnk, IID_IVASpacecraftParameters, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetSolarRadiationPressureArea"] = IAGFUNCTYPE(pUnk, IID_IVASpacecraftParameters, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetSolarRadiationPressureArea"] = IAGFUNCTYPE(pUnk, IID_IVASpacecraftParameters, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetCk"] = IAGFUNCTYPE(pUnk, IID_IVASpacecraftParameters, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetCk"] = IAGFUNCTYPE(pUnk, IID_IVASpacecraftParameters, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetRadiationPressureArea"] = IAGFUNCTYPE(pUnk, IID_IVASpacecraftParameters, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRadiationPressureArea"] = IAGFUNCTYPE(pUnk, IID_IVASpacecraftParameters, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetK1"] = IAGFUNCTYPE(pUnk, IID_IVASpacecraftParameters, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_SetK1"] = IAGFUNCTYPE(pUnk, IID_IVASpacecraftParameters, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_GetK2"] = IAGFUNCTYPE(pUnk, IID_IVASpacecraftParameters, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_SetK2"] = IAGFUNCTYPE(pUnk, IID_IVASpacecraftParameters, vtable_offset_local+18, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVASpacecraftParameters.__dict__ and type(IVASpacecraftParameters.__dict__[attrname]) == property:
            return IVASpacecraftParameters.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVASpacecraftParameters.")
    
    @property
    def DryMass(self) -> float:
        """The mass of the spacecraft exclusive of propellant. Uses Mass Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDryMass"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DryMass.setter
    def DryMass(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetDryMass"](arg_newVal.COM_val))

    @property
    def Cd(self) -> float:
        """The dimensionless drag coefficient associated with the drag area. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCd"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Cd.setter
    def Cd(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCd"](arg_newVal.COM_val))

    @property
    def DragArea(self) -> float:
        """The cross-sectional area of the spacecraft assumed perpendicular to the direction of motion, used for atmospheric drag calculations. Uses SmallArea Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragArea"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragArea.setter
    def DragArea(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragArea"](arg_newVal.COM_val))

    @property
    def Cr(self) -> float:
        """The reflectivity of the spacecraft used for solar radiation pressure calculations, where 2.0 is fully reflective and 1.0 is not reflective at all. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCr"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Cr.setter
    def Cr(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCr"](arg_newVal.COM_val))

    @property
    def SolarRadiationPressureArea(self) -> float:
        """The cross-sectional area of the spacecraft assumed perpendicular to the direction of solar radiation, used for solar radiation calculations. Uses SmallArea Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSolarRadiationPressureArea"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SolarRadiationPressureArea.setter
    def SolarRadiationPressureArea(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetSolarRadiationPressureArea"](arg_newVal.COM_val))

    @property
    def Ck(self) -> float:
        """The reflectivity of the spacecraft used for central body radiation pressure (albedo / thermal pressure) calculations, where 2.0 is fully reflective and 1.0 is not reflective at all. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCk"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Ck.setter
    def Ck(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCk"](arg_newVal.COM_val))

    @property
    def RadiationPressureArea(self) -> float:
        """The cross-sectional area of the spacecraft assumed perpendicular to the direction of central body radiation, used for central body radiation (albedo / thermal pressure) calculations. Uses SmallArea Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRadiationPressureArea"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RadiationPressureArea.setter
    def RadiationPressureArea(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetRadiationPressureArea"](arg_newVal.COM_val))

    @property
    def K1(self) -> float:
        """If you are using a non-spherical SRP model, this field defines the model's GPS solar radiation pressure K1 (scale) value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetK1"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @K1.setter
    def K1(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetK1"](arg_newVal.COM_val))

    @property
    def K2(self) -> float:
        """If you are using a non-spherical SRP model, this field defines the model's GPS solar radiation pressure K2 (scale) value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetK2"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @K2.setter
    def K2(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetK2"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{6642A93A-65F8-4D50-A3E8-51B17A9AE3CF}", IVASpacecraftParameters)
agcls.AgTypeNameMap["IVASpacecraftParameters"] = IVASpacecraftParameters

class IVAFuelTank(object):
    """Properties for fuel tank configuration."""
    _uuid = "{6CB64830-3EDB-4E0E-A55B-DAC26DCCCA47}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTankPressure"] = _raise_uninitialized_error
        self.__dict__["_SetTankPressure"] = _raise_uninitialized_error
        self.__dict__["_GetTankVolume"] = _raise_uninitialized_error
        self.__dict__["_SetTankVolume"] = _raise_uninitialized_error
        self.__dict__["_GetTankTemperature"] = _raise_uninitialized_error
        self.__dict__["_SetTankTemperature"] = _raise_uninitialized_error
        self.__dict__["_GetFuelDensity"] = _raise_uninitialized_error
        self.__dict__["_SetFuelDensity"] = _raise_uninitialized_error
        self.__dict__["_GetFuelMass"] = _raise_uninitialized_error
        self.__dict__["_SetFuelMass"] = _raise_uninitialized_error
        self.__dict__["_GetMaximumFuelMass"] = _raise_uninitialized_error
        self.__dict__["_SetMaximumFuelMass"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAFuelTank._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAFuelTank from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAFuelTank = agcom.GUID(IVAFuelTank._uuid)
        vtable_offset_local = IVAFuelTank._vtable_offset - 1
        self.__dict__["_GetTankPressure"] = IAGFUNCTYPE(pUnk, IID_IVAFuelTank, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTankPressure"] = IAGFUNCTYPE(pUnk, IID_IVAFuelTank, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetTankVolume"] = IAGFUNCTYPE(pUnk, IID_IVAFuelTank, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTankVolume"] = IAGFUNCTYPE(pUnk, IID_IVAFuelTank, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetTankTemperature"] = IAGFUNCTYPE(pUnk, IID_IVAFuelTank, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTankTemperature"] = IAGFUNCTYPE(pUnk, IID_IVAFuelTank, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetFuelDensity"] = IAGFUNCTYPE(pUnk, IID_IVAFuelTank, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetFuelDensity"] = IAGFUNCTYPE(pUnk, IID_IVAFuelTank, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetFuelMass"] = IAGFUNCTYPE(pUnk, IID_IVAFuelTank, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetFuelMass"] = IAGFUNCTYPE(pUnk, IID_IVAFuelTank, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetMaximumFuelMass"] = IAGFUNCTYPE(pUnk, IID_IVAFuelTank, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaximumFuelMass"] = IAGFUNCTYPE(pUnk, IID_IVAFuelTank, vtable_offset_local+12, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAFuelTank.__dict__ and type(IVAFuelTank.__dict__[attrname]) == property:
            return IVAFuelTank.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAFuelTank.")
    
    @property
    def TankPressure(self) -> float:
        """The fuel tank pressure. Uses Pressure Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTankPressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TankPressure.setter
    def TankPressure(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTankPressure"](arg_newVal.COM_val))

    @property
    def TankVolume(self) -> float:
        """The volume of the fuel tank. Uses SmallVolume Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTankVolume"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TankVolume.setter
    def TankVolume(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTankVolume"](arg_newVal.COM_val))

    @property
    def TankTemperature(self) -> float:
        """The temperature of the fuel tank. Uses Temperature Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTankTemperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TankTemperature.setter
    def TankTemperature(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTankTemperature"](arg_newVal.COM_val))

    @property
    def FuelDensity(self) -> float:
        """The density of the fuel. Uses SmallDensity Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetFuelDensity"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @FuelDensity.setter
    def FuelDensity(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetFuelDensity"](arg_newVal.COM_val))

    @property
    def FuelMass(self) -> float:
        """The mass of the spacecraft propellant. Uses Mass Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetFuelMass"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @FuelMass.setter
    def FuelMass(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetFuelMass"](arg_newVal.COM_val))

    @property
    def MaximumFuelMass(self) -> float:
        """The maximum fuel mass of the spacecraft; this parameter specifically applies to Finite Maneuver segments that are being executed in Backward Sequences. Uses Mass Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaximumFuelMass"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaximumFuelMass.setter
    def MaximumFuelMass(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaximumFuelMass"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{6CB64830-3EDB-4E0E-A55B-DAC26DCCCA47}", IVAFuelTank)
agcls.AgTypeNameMap["IVAFuelTank"] = IVAFuelTank

class IVAMCSSegmentProperties(object):
    """The segment properties."""
    _uuid = "{B8C99C10-CB59-4C72-A97C-CBF561C41D4D}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetDisplayCoordinateSystem"] = _raise_uninitialized_error
        self.__dict__["_SetDisplayCoordinateSystem"] = _raise_uninitialized_error
        self.__dict__["_GetColor"] = _raise_uninitialized_error
        self.__dict__["_SetColor"] = _raise_uninitialized_error
        self.__dict__["_GetUpdateAnimationTimeAfterRun"] = _raise_uninitialized_error
        self.__dict__["_SetUpdateAnimationTimeAfterRun"] = _raise_uninitialized_error
        self.__dict__["_ApplyFinalStateToBPlanes"] = _raise_uninitialized_error
        self.__dict__["_GetBPlanes"] = _raise_uninitialized_error
        self.__dict__["_GetLastRunCode"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAMCSSegmentProperties._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAMCSSegmentProperties from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAMCSSegmentProperties = agcom.GUID(IVAMCSSegmentProperties._uuid)
        vtable_offset_local = IVAMCSSegmentProperties._vtable_offset - 1
        self.__dict__["_GetDisplayCoordinateSystem"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSegmentProperties, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetDisplayCoordinateSystem"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSegmentProperties, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetColor"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSegmentProperties, vtable_offset_local+3, POINTER(agcom.OLE_COLOR))
        self.__dict__["_SetColor"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSegmentProperties, vtable_offset_local+4, agcom.OLE_COLOR)
        self.__dict__["_GetUpdateAnimationTimeAfterRun"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSegmentProperties, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUpdateAnimationTimeAfterRun"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSegmentProperties, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_ApplyFinalStateToBPlanes"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSegmentProperties, vtable_offset_local+7, )
        self.__dict__["_GetBPlanes"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSegmentProperties, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_GetLastRunCode"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSegmentProperties, vtable_offset_local+9, POINTER(agcom.LONG))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAMCSSegmentProperties.__dict__ and type(IVAMCSSegmentProperties.__dict__[attrname]) == property:
            return IVAMCSSegmentProperties.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAMCSSegmentProperties.")
    
    @property
    def DisplayCoordinateSystem(self) -> str:
        """The coordinate system that will be used in the segment summary report."""
        with agmarshall.BSTR_arg() as arg_pDisplayCoordinateSystem:
            agcls.evaluate_hresult(self.__dict__["_GetDisplayCoordinateSystem"](byref(arg_pDisplayCoordinateSystem.COM_val)))
            return arg_pDisplayCoordinateSystem.python_val

    @DisplayCoordinateSystem.setter
    def DisplayCoordinateSystem(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDisplayCoordinateSystem"](arg_inVal.COM_val))

    @property
    def Color(self) -> agcolor.Color:
        """The display color of the segment."""
        with agmarshall.OLE_COLOR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetColor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Color.setter
    def Color(self, inVal:agcolor.Color) -> None:
        with agmarshall.OLE_COLOR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetColor"](arg_inVal.COM_val))

    @property
    def UpdateAnimationTimeAfterRun(self) -> bool:
        """If true, Astrogator will set the animation time to the final epoch of the segment when the segment finishes running."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUpdateAnimationTimeAfterRun"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UpdateAnimationTimeAfterRun.setter
    def UpdateAnimationTimeAfterRun(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUpdateAnimationTimeAfterRun"](arg_inVal.COM_val))

    def ApplyFinalStateToBPlanes(self) -> None:
        """Applies the last calculated final state of the segment to all selected B-Planes."""
        agcls.evaluate_hresult(self.__dict__["_ApplyFinalStateToBPlanes"]())

    @property
    def BPlanes(self) -> "IVABPlaneCollection":
        """The B-Plane or B-Planes to which the epoch, position, and velocity of the segment's final state will be applied, according to the B-Plane's definition."""
        with agmarshall.AgInterface_out_arg() as arg_ppVABPlaneCollection:
            agcls.evaluate_hresult(self.__dict__["_GetBPlanes"](byref(arg_ppVABPlaneCollection.COM_val)))
            return arg_ppVABPlaneCollection.python_val

    @property
    def LastRunCode(self) -> "AgEVARunCode":
        """The last run code returned by the segment."""
        with agmarshall.AgEnum_arg(AgEVARunCode) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLastRunCode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{B8C99C10-CB59-4C72-A97C-CBF561C41D4D}", IVAMCSSegmentProperties)
agcls.AgTypeNameMap["IVAMCSSegmentProperties"] = IVAMCSSegmentProperties

class IVAMCSEnd(object):
    """Properties for an End segment."""
    _uuid = "{7AE91388-7900-4AA0-BF30-546957ACFE94}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAMCSEnd._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAMCSEnd from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAMCSEnd = agcom.GUID(IVAMCSEnd._uuid)
        vtable_offset_local = IVAMCSEnd._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAMCSEnd.__dict__ and type(IVAMCSEnd.__dict__[attrname]) == property:
            return IVAMCSEnd.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAMCSEnd.")
    

agcls.AgClassCatalog.add_catalog_entry("{7AE91388-7900-4AA0-BF30-546957ACFE94}", IVAMCSEnd)
agcls.AgTypeNameMap["IVAMCSEnd"] = IVAMCSEnd

class IVAMCSInitialState(object):
    """Properties for an Initial State segment."""
    _uuid = "{D7458E20-A5E4-45C8-81A1-38A29F4131FD}"
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_SetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_GetOrbitEpoch"] = _raise_uninitialized_error
        self.__dict__["_SetOrbitEpoch"] = _raise_uninitialized_error
        self.__dict__["_GetSpacecraftParameters"] = _raise_uninitialized_error
        self.__dict__["_GetFuelTank"] = _raise_uninitialized_error
        self.__dict__["_GetElementType"] = _raise_uninitialized_error
        self.__dict__["_SetElementType"] = _raise_uninitialized_error
        self.__dict__["_GetElement"] = _raise_uninitialized_error
        self.__dict__["_EnableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_DisableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_IsControlParameterEnabled"] = _raise_uninitialized_error
        self.__dict__["_GetControlParametersAvailable"] = _raise_uninitialized_error
        self.__dict__["_GetUserVariables"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAMCSInitialState._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAMCSInitialState from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAMCSInitialState = agcom.GUID(IVAMCSInitialState._uuid)
        vtable_offset_local = IVAMCSInitialState._vtable_offset - 1
        self.__dict__["_GetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAMCSInitialState, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAMCSInitialState, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetOrbitEpoch"] = IAGFUNCTYPE(pUnk, IID_IVAMCSInitialState, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_SetOrbitEpoch"] = IAGFUNCTYPE(pUnk, IID_IVAMCSInitialState, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_GetSpacecraftParameters"] = IAGFUNCTYPE(pUnk, IID_IVAMCSInitialState, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_GetFuelTank"] = IAGFUNCTYPE(pUnk, IID_IVAMCSInitialState, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_GetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAMCSInitialState, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAMCSInitialState, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetElement"] = IAGFUNCTYPE(pUnk, IID_IVAMCSInitialState, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_EnableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAMCSInitialState, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_DisableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAMCSInitialState, vtable_offset_local+11, agcom.LONG)
        self.__dict__["_IsControlParameterEnabled"] = IAGFUNCTYPE(pUnk, IID_IVAMCSInitialState, vtable_offset_local+12, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetControlParametersAvailable"] = IAGFUNCTYPE(pUnk, IID_IVAMCSInitialState, vtable_offset_local+13, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetUserVariables"] = IAGFUNCTYPE(pUnk, IID_IVAMCSInitialState, vtable_offset_local+14, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAMCSInitialState.__dict__ and type(IVAMCSInitialState.__dict__[attrname]) == property:
            return IVAMCSInitialState.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAMCSInitialState.")
    
    @property
    def CoordSystemName(self) -> str:
        """The coordinate system."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordSystemName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordSystemName.setter
    def CoordSystemName(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordSystemName"](arg_newVal.COM_val))

    @property
    def OrbitEpoch(self) -> typing.Any:
        """The orbit epoch. Uses DateFormat Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetOrbitEpoch"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @OrbitEpoch.setter
    def OrbitEpoch(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetOrbitEpoch"](arg_newVal.COM_val))

    @property
    def SpacecraftParameters(self) -> "IVASpacecraftParameters":
        """The spacecraft  parameters."""
        with agmarshall.AgInterface_out_arg() as arg_ppSpacecraftParameters:
            agcls.evaluate_hresult(self.__dict__["_GetSpacecraftParameters"](byref(arg_ppSpacecraftParameters.COM_val)))
            return arg_ppSpacecraftParameters.python_val

    @property
    def FuelTank(self) -> "IVAFuelTank":
        """The fuel tank parameters."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAFuelTank:
            agcls.evaluate_hresult(self.__dict__["_GetFuelTank"](byref(arg_ppVAFuelTank.COM_val)))
            return arg_ppVAFuelTank.python_val

    @property
    def ElementType(self) -> "AgEVAElementType":
        """The coordinate type."""
        with agmarshall.AgEnum_arg(AgEVAElementType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def SetElementType(self, elementType:"AgEVAElementType") -> None:
        """Selects an coordinate type."""
        with agmarshall.AgEnum_arg(AgEVAElementType, elementType) as arg_elementType:
            agcls.evaluate_hresult(self.__dict__["_SetElementType"](arg_elementType.COM_val))

    @property
    def Element(self) -> "IVAElement":
        """The elements of the selected coordinate type."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAElement:
            agcls.evaluate_hresult(self.__dict__["_GetElement"](byref(arg_ppVAElement.COM_val)))
            return arg_ppVAElement.python_val

    def EnableControlParameter(self, param:"AgEVAControlInitState") -> None:
        """Enables a control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlInitState, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_EnableControlParameter"](arg_param.COM_val))

    def DisableControlParameter(self, param:"AgEVAControlInitState") -> None:
        """Disables a control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlInitState, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_DisableControlParameter"](arg_param.COM_val))

    def IsControlParameterEnabled(self, param:"AgEVAControlInitState") -> bool:
        """Sees if a control is enabled."""
        with agmarshall.AgEnum_arg(AgEVAControlInitState, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_IsControlParameterEnabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ControlParametersAvailable(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetControlParametersAvailable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def UserVariables(self) -> "IVAUserVariableCollection":
        """Interface used to modify user variables for the initial state segment."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUserVariables"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{D7458E20-A5E4-45C8-81A1-38A29F4131FD}", IVAMCSInitialState)
agcls.AgTypeNameMap["IVAMCSInitialState"] = IVAMCSInitialState

class IVAMCSSegment(object):
    """General properties for segments."""
    _uuid = "{46F093C1-5138-4A6F-A79C-7F4DB8E7BCB4}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetType"] = _raise_uninitialized_error
        self.__dict__["_GetProperties"] = _raise_uninitialized_error
        self.__dict__["_GetInitialState"] = _raise_uninitialized_error
        self.__dict__["_GetFinalState"] = _raise_uninitialized_error
        self.__dict__["_GetResultValue"] = _raise_uninitialized_error
        self.__dict__["_Run"] = _raise_uninitialized_error
        self.__dict__["_GetResults"] = _raise_uninitialized_error
        self.__dict__["_GetExecSummary"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAMCSSegment._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAMCSSegment from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAMCSSegment = agcom.GUID(IVAMCSSegment._uuid)
        vtable_offset_local = IVAMCSSegment._vtable_offset - 1
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSegment, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_GetProperties"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSegment, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetInitialState"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSegment, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetFinalState"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSegment, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetResultValue"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSegment, vtable_offset_local+5, agcom.BSTR, POINTER(agcom.VARIANT))
        self.__dict__["_Run"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSegment, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_GetResults"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSegment, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetExecSummary"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSegment, vtable_offset_local+8, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAMCSSegment.__dict__ and type(IVAMCSSegment.__dict__[attrname]) == property:
            return IVAMCSSegment.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAMCSSegment.")
    
    @property
    def Type(self) -> "AgEVASegmentType":
        """Returns the type of segment."""
        with agmarshall.AgEnum_arg(AgEVASegmentType) as arg_pSegmentType:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pSegmentType.COM_val)))
            return arg_pSegmentType.python_val

    @property
    def Properties(self) -> "IVAMCSSegmentProperties":
        """Returns the properties of the segment."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAMCSSegmentProperties:
            agcls.evaluate_hresult(self.__dict__["_GetProperties"](byref(arg_ppVAMCSSegmentProperties.COM_val)))
            return arg_ppVAMCSSegmentProperties.python_val

    @property
    def InitialState(self) -> "IVAState":
        """The initial state of the segment."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetInitialState"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def FinalState(self) -> "IVAState":
        """The final state of the segment."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetFinalState"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetResultValue(self, resultName:str) -> typing.Any:
        """Returns a result value."""
        with agmarshall.BSTR_arg(resultName) as arg_resultName, \
             agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetResultValue"](arg_resultName.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def Run(self) -> "IVAState":
        """Runs the segment in individual segment mode.  See IAgVADriverMCS."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Run"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Results(self) -> "IVACalcObjectCollection":
        """The results of the segment."""
        with agmarshall.AgInterface_out_arg() as arg_ppVACalcObjectCollection:
            agcls.evaluate_hresult(self.__dict__["_GetResults"](byref(arg_ppVACalcObjectCollection.COM_val)))
            return arg_ppVACalcObjectCollection.python_val

    @property
    def ExecSummary(self) -> "IDrResult":
        """The segment summary report."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetExecSummary"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{46F093C1-5138-4A6F-A79C-7F4DB8E7BCB4}", IVAMCSSegment)
agcls.AgTypeNameMap["IVAMCSSegment"] = IVAMCSSegment

class IVAMCSOptions(object):
    """Properties for the MCS Options."""
    _uuid = "{81715712-591E-4553-9DC7-A1266F82E7D9}"
    _num_methods = 37
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetDrawTrajectoryIn2D"] = _raise_uninitialized_error
        self.__dict__["_SetDrawTrajectoryIn2D"] = _raise_uninitialized_error
        self.__dict__["_GetDrawTrajectoryIn3D"] = _raise_uninitialized_error
        self.__dict__["_SetDrawTrajectoryIn3D"] = _raise_uninitialized_error
        self.__dict__["_GetUpdateAnimationTimeForAllObjects"] = _raise_uninitialized_error
        self.__dict__["_SetUpdateAnimationTimeForAllObjects"] = _raise_uninitialized_error
        self.__dict__["_GetClearDWCGraphicsBeforeEachRun"] = _raise_uninitialized_error
        self.__dict__["_SetClearDWCGraphicsBeforeEachRun"] = _raise_uninitialized_error
        self.__dict__["_GetClearAdditionalBPlanePoints"] = _raise_uninitialized_error
        self.__dict__["_SetClearAdditionalBPlanePoints"] = _raise_uninitialized_error
        self.__dict__["_GetPropagateOnApply"] = _raise_uninitialized_error
        self.__dict__["_SetPropagateOnApply"] = _raise_uninitialized_error
        self.__dict__["_GetEnableTrajectorySegmentColors"] = _raise_uninitialized_error
        self.__dict__["_SetEnableTrajectorySegmentColors"] = _raise_uninitialized_error
        self.__dict__["_GetSaveNumbersInRawFormat"] = _raise_uninitialized_error
        self.__dict__["_SetSaveNumbersInRawFormat"] = _raise_uninitialized_error
        self.__dict__["_GetStoppingConditionTimeTolerance"] = _raise_uninitialized_error
        self.__dict__["_SetStoppingConditionTimeTolerance"] = _raise_uninitialized_error
        self.__dict__["_GetEnableSegmentControls"] = _raise_uninitialized_error
        self.__dict__["_SetEnableSegmentControls"] = _raise_uninitialized_error
        self.__dict__["_GetEnableSegmentResults"] = _raise_uninitialized_error
        self.__dict__["_SetEnableSegmentResults"] = _raise_uninitialized_error
        self.__dict__["_GetEnableLogging"] = _raise_uninitialized_error
        self.__dict__["_SetEnableLogging"] = _raise_uninitialized_error
        self.__dict__["_GetGraphicsUpdateRate"] = _raise_uninitialized_error
        self.__dict__["_SetGraphicsUpdateRate"] = _raise_uninitialized_error
        self.__dict__["_GetPromoteControls"] = _raise_uninitialized_error
        self.__dict__["_SetPromoteControls"] = _raise_uninitialized_error
        self.__dict__["_GetUseNominalSettings"] = _raise_uninitialized_error
        self.__dict__["_SetUseNominalSettings"] = _raise_uninitialized_error
        self.__dict__["_GetMinEphemStep"] = _raise_uninitialized_error
        self.__dict__["_SetMinEphemStep"] = _raise_uninitialized_error
        self.__dict__["_GetGenerateEphemeris"] = _raise_uninitialized_error
        self.__dict__["_SetGenerateEphemeris"] = _raise_uninitialized_error
        self.__dict__["_GetUserVariables"] = _raise_uninitialized_error
        self.__dict__["_GetSmartRunMode"] = _raise_uninitialized_error
        self.__dict__["_SetSmartRunMode"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAMCSOptions._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAMCSOptions from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAMCSOptions = agcom.GUID(IVAMCSOptions._uuid)
        vtable_offset_local = IVAMCSOptions._vtable_offset - 1
        self.__dict__["_GetDrawTrajectoryIn2D"] = IAGFUNCTYPE(pUnk, IID_IVAMCSOptions, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetDrawTrajectoryIn2D"] = IAGFUNCTYPE(pUnk, IID_IVAMCSOptions, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetDrawTrajectoryIn3D"] = IAGFUNCTYPE(pUnk, IID_IVAMCSOptions, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetDrawTrajectoryIn3D"] = IAGFUNCTYPE(pUnk, IID_IVAMCSOptions, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_GetUpdateAnimationTimeForAllObjects"] = IAGFUNCTYPE(pUnk, IID_IVAMCSOptions, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUpdateAnimationTimeForAllObjects"] = IAGFUNCTYPE(pUnk, IID_IVAMCSOptions, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetClearDWCGraphicsBeforeEachRun"] = IAGFUNCTYPE(pUnk, IID_IVAMCSOptions, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetClearDWCGraphicsBeforeEachRun"] = IAGFUNCTYPE(pUnk, IID_IVAMCSOptions, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_GetClearAdditionalBPlanePoints"] = IAGFUNCTYPE(pUnk, IID_IVAMCSOptions, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetClearAdditionalBPlanePoints"] = IAGFUNCTYPE(pUnk, IID_IVAMCSOptions, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_GetPropagateOnApply"] = IAGFUNCTYPE(pUnk, IID_IVAMCSOptions, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetPropagateOnApply"] = IAGFUNCTYPE(pUnk, IID_IVAMCSOptions, vtable_offset_local+12, agcom.VARIANT_BOOL)
        self.__dict__["_GetEnableTrajectorySegmentColors"] = IAGFUNCTYPE(pUnk, IID_IVAMCSOptions, vtable_offset_local+13, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnableTrajectorySegmentColors"] = IAGFUNCTYPE(pUnk, IID_IVAMCSOptions, vtable_offset_local+14, agcom.VARIANT_BOOL)
        self.__dict__["_GetSaveNumbersInRawFormat"] = IAGFUNCTYPE(pUnk, IID_IVAMCSOptions, vtable_offset_local+15, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetSaveNumbersInRawFormat"] = IAGFUNCTYPE(pUnk, IID_IVAMCSOptions, vtable_offset_local+16, agcom.VARIANT_BOOL)
        self.__dict__["_GetStoppingConditionTimeTolerance"] = IAGFUNCTYPE(pUnk, IID_IVAMCSOptions, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStoppingConditionTimeTolerance"] = IAGFUNCTYPE(pUnk, IID_IVAMCSOptions, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_GetEnableSegmentControls"] = IAGFUNCTYPE(pUnk, IID_IVAMCSOptions, vtable_offset_local+19, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnableSegmentControls"] = IAGFUNCTYPE(pUnk, IID_IVAMCSOptions, vtable_offset_local+20, agcom.VARIANT_BOOL)
        self.__dict__["_GetEnableSegmentResults"] = IAGFUNCTYPE(pUnk, IID_IVAMCSOptions, vtable_offset_local+21, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnableSegmentResults"] = IAGFUNCTYPE(pUnk, IID_IVAMCSOptions, vtable_offset_local+22, agcom.VARIANT_BOOL)
        self.__dict__["_GetEnableLogging"] = IAGFUNCTYPE(pUnk, IID_IVAMCSOptions, vtable_offset_local+23, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnableLogging"] = IAGFUNCTYPE(pUnk, IID_IVAMCSOptions, vtable_offset_local+24, agcom.VARIANT_BOOL)
        self.__dict__["_GetGraphicsUpdateRate"] = IAGFUNCTYPE(pUnk, IID_IVAMCSOptions, vtable_offset_local+25, POINTER(agcom.DOUBLE))
        self.__dict__["_SetGraphicsUpdateRate"] = IAGFUNCTYPE(pUnk, IID_IVAMCSOptions, vtable_offset_local+26, agcom.DOUBLE)
        self.__dict__["_GetPromoteControls"] = IAGFUNCTYPE(pUnk, IID_IVAMCSOptions, vtable_offset_local+27, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetPromoteControls"] = IAGFUNCTYPE(pUnk, IID_IVAMCSOptions, vtable_offset_local+28, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseNominalSettings"] = IAGFUNCTYPE(pUnk, IID_IVAMCSOptions, vtable_offset_local+29, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseNominalSettings"] = IAGFUNCTYPE(pUnk, IID_IVAMCSOptions, vtable_offset_local+30, agcom.VARIANT_BOOL)
        self.__dict__["_GetMinEphemStep"] = IAGFUNCTYPE(pUnk, IID_IVAMCSOptions, vtable_offset_local+31, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMinEphemStep"] = IAGFUNCTYPE(pUnk, IID_IVAMCSOptions, vtable_offset_local+32, agcom.DOUBLE)
        self.__dict__["_GetGenerateEphemeris"] = IAGFUNCTYPE(pUnk, IID_IVAMCSOptions, vtable_offset_local+33, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetGenerateEphemeris"] = IAGFUNCTYPE(pUnk, IID_IVAMCSOptions, vtable_offset_local+34, agcom.VARIANT_BOOL)
        self.__dict__["_GetUserVariables"] = IAGFUNCTYPE(pUnk, IID_IVAMCSOptions, vtable_offset_local+35, POINTER(agcom.PVOID))
        self.__dict__["_GetSmartRunMode"] = IAGFUNCTYPE(pUnk, IID_IVAMCSOptions, vtable_offset_local+36, POINTER(agcom.LONG))
        self.__dict__["_SetSmartRunMode"] = IAGFUNCTYPE(pUnk, IID_IVAMCSOptions, vtable_offset_local+37, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAMCSOptions.__dict__ and type(IVAMCSOptions.__dict__[attrname]) == property:
            return IVAMCSOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAMCSOptions.")
    
    @property
    def DrawTrajectoryIn2D(self) -> bool:
        """If true, Astrogator will draw the trajectory in the 2D Graphics windows as the ephemeris is calculated during the current run."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDrawTrajectoryIn2D"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DrawTrajectoryIn2D.setter
    def DrawTrajectoryIn2D(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetDrawTrajectoryIn2D"](arg_newVal.COM_val))

    @property
    def DrawTrajectoryIn3D(self) -> bool:
        """If true, Astrogator will draw the trajectory in the 3D Graphics windows as the ephemeris is calculated during the current run."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDrawTrajectoryIn3D"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DrawTrajectoryIn3D.setter
    def DrawTrajectoryIn3D(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetDrawTrajectoryIn3D"](arg_newVal.COM_val))

    @property
    def UpdateAnimationTimeForAllObjects(self) -> bool:
        """If true, all other objects will be animated so that they appear at the proper position for the time being computed as the trajectory is calculated."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUpdateAnimationTimeForAllObjects"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UpdateAnimationTimeForAllObjects.setter
    def UpdateAnimationTimeForAllObjects(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetUpdateAnimationTimeForAllObjects"](arg_newVal.COM_val))

    @property
    def ClearDWCGraphicsBeforeEachRun(self) -> bool:
        """If true, Astrogator will automatically clear all target iteration graphics of the previous run - in all graphics windows - before the current run draws new calculations."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetClearDWCGraphicsBeforeEachRun"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ClearDWCGraphicsBeforeEachRun.setter
    def ClearDWCGraphicsBeforeEachRun(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetClearDWCGraphicsBeforeEachRun"](arg_newVal.COM_val))

    @property
    def ClearAdditionalBPlanePoints(self) -> bool:
        """If true, Astrogator will clear all additional B-Plane points from any previous run - in all graphics windows - before the current run."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetClearAdditionalBPlanePoints"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ClearAdditionalBPlanePoints.setter
    def ClearAdditionalBPlanePoints(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetClearAdditionalBPlanePoints"](arg_newVal.COM_val))

    @property
    def PropagateOnApply(self) -> bool:
        """If true, Astrogator will propagate trajectories whenever you click OK or Apply on the Orbit page. If you want to close the Properties Browser for the satellite without running the MCS, make certain this option is disabled."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPropagateOnApply"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @PropagateOnApply.setter
    def PropagateOnApply(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetPropagateOnApply"](arg_newVal.COM_val))

    @property
    def EnableTrajectorySegmentColors(self) -> bool:
        """If true, trajectory segments are displayed in the 2D Graphics window in the colors selected for the respective segments; otherwise the color of the trajectory is defined by the 2D Graphics Attributes page."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnableTrajectorySegmentColors"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EnableTrajectorySegmentColors.setter
    def EnableTrajectorySegmentColors(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnableTrajectorySegmentColors"](arg_newVal.COM_val))

    @property
    def SaveNumbersInRawFormat(self) -> bool:
        """If true, Astrogator will store satellite information in binary format - to preserve the maximum amount of precision."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSaveNumbersInRawFormat"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SaveNumbersInRawFormat.setter
    def SaveNumbersInRawFormat(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetSaveNumbersInRawFormat"](arg_newVal.COM_val))

    @property
    def StoppingConditionTimeTolerance(self) -> float:
        """The time tolerance, which will be applied with respect to desired trip values throughout the MCS. If this value is set to zero, time tolerance will not be applied."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetStoppingConditionTimeTolerance"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @StoppingConditionTimeTolerance.setter
    def StoppingConditionTimeTolerance(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetStoppingConditionTimeTolerance"](arg_newVal.COM_val))

    @property
    def EnableSegmentControls(self) -> bool:
        """If true, Astrogator will automatically add independent variables to differential correctors."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnableSegmentControls"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EnableSegmentControls.setter
    def EnableSegmentControls(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnableSegmentControls"](arg_newVal.COM_val))

    @property
    def EnableSegmentResults(self) -> bool:
        """If true, Astrogator will automatically add dependent variables to differential correctors."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnableSegmentResults"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EnableSegmentResults.setter
    def EnableSegmentResults(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnableSegmentResults"](arg_newVal.COM_val))

    @property
    def EnableLogging(self) -> bool:
        """If true, target sequences can be set to produce 'run history' log files for differential corrector profiles. By default, a target sequence does not produce a log file."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnableLogging"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EnableLogging.setter
    def EnableLogging(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnableLogging"](arg_newVal.COM_val))

    @property
    def GraphicsUpdateRate(self) -> float:
        """The rate (between 0 and 1) at which to update graphics. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetGraphicsUpdateRate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @GraphicsUpdateRate.setter
    def GraphicsUpdateRate(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetGraphicsUpdateRate"](arg_newVal.COM_val))

    @property
    def PromoteControls(self) -> bool:
        """If true, a target sequence will be able to affect controls and results within a nested target sequence in addition to its own."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPromoteControls"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @PromoteControls.setter
    def PromoteControls(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetPromoteControls"](arg_inVal.COM_val))

    @property
    def UseNominalSettings(self) -> bool:
        """If true, components or segments that are modified by a target sequence will be restored to their nominal values as soon as the target sequence completes its run."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseNominalSettings"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseNominalSettings.setter
    def UseNominalSettings(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseNominalSettings"](arg_inVal.COM_val))

    @property
    def MinEphemStep(self) -> float:
        """The minimum step size for saving ephemeris. Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinEphemStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MinEphemStep.setter
    def MinEphemStep(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetMinEphemStep"](arg_newVal.COM_val))

    @property
    def GenerateEphemeris(self) -> bool:
        """If true, Astrogator will generate ephemeris."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetGenerateEphemeris"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @GenerateEphemeris.setter
    def GenerateEphemeris(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetGenerateEphemeris"](arg_newVal.COM_val))

    @property
    def UserVariables(self) -> "IVAUserVariableDefinitionCollection":
        """Interface used to add/remove user variables."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUserVariables"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def SmartRunMode(self) -> "AgEVASmartRunMode":
        """Controls whether the run will attempt to only run changed segments."""
        with agmarshall.AgEnum_arg(AgEVASmartRunMode) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSmartRunMode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SmartRunMode.setter
    def SmartRunMode(self, inVal:"AgEVASmartRunMode") -> None:
        """Controls whether the run will attempt to only run changed segments."""
        with agmarshall.AgEnum_arg(AgEVASmartRunMode, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSmartRunMode"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{81715712-591E-4553-9DC7-A1266F82E7D9}", IVAMCSOptions)
agcls.AgTypeNameMap["IVAMCSOptions"] = IVAMCSOptions

class IVADriverMCS(object):
    """Properties for the Mission Control Sequence."""
    _uuid = "{109E17B9-8E27-4B6B-A8BE-33DFF19A2C89}"
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetMainSequence"] = _raise_uninitialized_error
        self.__dict__["_GetOptions"] = _raise_uninitialized_error
        self.__dict__["_GetAutoSequence"] = _raise_uninitialized_error
        self.__dict__["_RunMCS"] = _raise_uninitialized_error
        self.__dict__["_BeginRun"] = _raise_uninitialized_error
        self.__dict__["_EndRun"] = _raise_uninitialized_error
        self.__dict__["_ClearDWCGraphics"] = _raise_uninitialized_error
        self.__dict__["_ResetAllProfiles"] = _raise_uninitialized_error
        self.__dict__["_ApplyAllProfileChanges"] = _raise_uninitialized_error
        self.__dict__["_AppendRun"] = _raise_uninitialized_error
        self.__dict__["_AppendRunFromTime"] = _raise_uninitialized_error
        self.__dict__["_AppendRunFromState"] = _raise_uninitialized_error
        self.__dict__["_RunMCS2"] = _raise_uninitialized_error
        self.__dict__["_GetCalculationGraphs"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVADriverMCS._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVADriverMCS from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVADriverMCS = agcom.GUID(IVADriverMCS._uuid)
        vtable_offset_local = IVADriverMCS._vtable_offset - 1
        self.__dict__["_GetMainSequence"] = IAGFUNCTYPE(pUnk, IID_IVADriverMCS, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetOptions"] = IAGFUNCTYPE(pUnk, IID_IVADriverMCS, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetAutoSequence"] = IAGFUNCTYPE(pUnk, IID_IVADriverMCS, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_RunMCS"] = IAGFUNCTYPE(pUnk, IID_IVADriverMCS, vtable_offset_local+4, )
        self.__dict__["_BeginRun"] = IAGFUNCTYPE(pUnk, IID_IVADriverMCS, vtable_offset_local+5, )
        self.__dict__["_EndRun"] = IAGFUNCTYPE(pUnk, IID_IVADriverMCS, vtable_offset_local+6, )
        self.__dict__["_ClearDWCGraphics"] = IAGFUNCTYPE(pUnk, IID_IVADriverMCS, vtable_offset_local+7, )
        self.__dict__["_ResetAllProfiles"] = IAGFUNCTYPE(pUnk, IID_IVADriverMCS, vtable_offset_local+8, )
        self.__dict__["_ApplyAllProfileChanges"] = IAGFUNCTYPE(pUnk, IID_IVADriverMCS, vtable_offset_local+9, )
        self.__dict__["_AppendRun"] = IAGFUNCTYPE(pUnk, IID_IVADriverMCS, vtable_offset_local+10, )
        self.__dict__["_AppendRunFromTime"] = IAGFUNCTYPE(pUnk, IID_IVADriverMCS, vtable_offset_local+11, agcom.VARIANT, agcom.LONG)
        self.__dict__["_AppendRunFromState"] = IAGFUNCTYPE(pUnk, IID_IVADriverMCS, vtable_offset_local+12, agcom.PVOID, agcom.LONG)
        self.__dict__["_RunMCS2"] = IAGFUNCTYPE(pUnk, IID_IVADriverMCS, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_GetCalculationGraphs"] = IAGFUNCTYPE(pUnk, IID_IVADriverMCS, vtable_offset_local+14, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVADriverMCS.__dict__ and type(IVADriverMCS.__dict__[attrname]) == property:
            return IVADriverMCS.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVADriverMCS.")
    
    @property
    def MainSequence(self) -> "IVAMCSSegmentCollection":
        """The Mission Control Sequence."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAMCSSegmentCollection:
            agcls.evaluate_hresult(self.__dict__["_GetMainSequence"](byref(arg_ppVAMCSSegmentCollection.COM_val)))
            return arg_ppVAMCSSegmentCollection.python_val

    @property
    def Options(self) -> "IVAMCSOptions":
        """The Mission Control Sequence options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAMCSOptions:
            agcls.evaluate_hresult(self.__dict__["_GetOptions"](byref(arg_ppVAMCSOptions.COM_val)))
            return arg_ppVAMCSOptions.python_val

    @property
    def AutoSequence(self) -> "IVAAutomaticSequenceCollection":
        """The Automatic Sequences."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAAutomaticSequenceCollection:
            agcls.evaluate_hresult(self.__dict__["_GetAutoSequence"](byref(arg_ppVAAutomaticSequenceCollection.COM_val)))
            return arg_ppVAAutomaticSequenceCollection.python_val

    def RunMCS(self) -> None:
        """Runs the current MCS."""
        agcls.evaluate_hresult(self.__dict__["_RunMCS"]())

    def BeginRun(self) -> None:
        """Begins an individual segment mode run."""
        agcls.evaluate_hresult(self.__dict__["_BeginRun"]())

    def EndRun(self) -> None:
        """Ends an individual segment mode run."""
        agcls.evaluate_hresult(self.__dict__["_EndRun"]())

    def ClearDWCGraphics(self) -> None:
        """Clears the draw while calculating graphics"""
        agcls.evaluate_hresult(self.__dict__["_ClearDWCGraphics"]())

    def ResetAllProfiles(self) -> None:
        """Resets all active profiles in all target sequences."""
        agcls.evaluate_hresult(self.__dict__["_ResetAllProfiles"]())

    def ApplyAllProfileChanges(self) -> None:
        """Applies all active profile changes in all target sequences."""
        agcls.evaluate_hresult(self.__dict__["_ApplyAllProfileChanges"]())

    def AppendRun(self) -> None:
        """Append the existing ephemeris with another individual segment mode run"""
        agcls.evaluate_hresult(self.__dict__["_AppendRun"]())

    def AppendRunFromTime(self, epoch:typing.Any, clearEphemerisDirection:"AgEVAClearEphemerisDirection") -> None:
        """Append the existing ephemeris with another individual segment mode run, starting at a specified time. Ephemeris is cleared from time based on clear direction."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgEnum_arg(AgEVAClearEphemerisDirection, clearEphemerisDirection) as arg_clearEphemerisDirection:
            agcls.evaluate_hresult(self.__dict__["_AppendRunFromTime"](arg_epoch.COM_val, arg_clearEphemerisDirection.COM_val))

    def AppendRunFromState(self, appendState:"IVAState", clearEphemerisDirection:"AgEVAClearEphemerisDirection") -> None:
        """Append the existing ephemeris with another individual segment mode run, starting at a specified state. Ephemeris is cleared from time based on clear direction."""
        with agmarshall.AgInterface_in_arg(appendState, IVAState) as arg_appendState, \
             agmarshall.AgEnum_arg(AgEVAClearEphemerisDirection, clearEphemerisDirection) as arg_clearEphemerisDirection:
            agcls.evaluate_hresult(self.__dict__["_AppendRunFromState"](arg_appendState.COM_val, arg_clearEphemerisDirection.COM_val))

    def RunMCS2(self) -> "AgEVARunCode":
        """Runs the current MCS and returns an error code."""
        with agmarshall.AgEnum_arg(AgEVARunCode) as arg_pRunCode:
            agcls.evaluate_hresult(self.__dict__["_RunMCS2"](byref(arg_pRunCode.COM_val)))
            return arg_pRunCode.python_val

    @property
    def CalculationGraphs(self) -> "IVACalculationGraphCollection":
        """The calculation graphs."""
        with agmarshall.AgInterface_out_arg() as arg_ppVACalculationGraphCollection:
            agcls.evaluate_hresult(self.__dict__["_GetCalculationGraphs"](byref(arg_ppVACalculationGraphCollection.COM_val)))
            return arg_ppVACalculationGraphCollection.python_val


agcls.AgClassCatalog.add_catalog_entry("{109E17B9-8E27-4B6B-A8BE-33DFF19A2C89}", IVADriverMCS)
agcls.AgTypeNameMap["IVADriverMCS"] = IVADriverMCS

class IVAElementCartesian(IVAElement):
    """Properties for Cartesian elements."""
    _uuid = "{63C45864-E165-498E-A88E-8104FABF50B9}"
    _num_methods = 12
    _vtable_offset = IVAElement._vtable_offset + IVAElement._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetX"] = _raise_uninitialized_error
        self.__dict__["_SetX"] = _raise_uninitialized_error
        self.__dict__["_GetY"] = _raise_uninitialized_error
        self.__dict__["_SetY"] = _raise_uninitialized_error
        self.__dict__["_GetZ"] = _raise_uninitialized_error
        self.__dict__["_SetZ"] = _raise_uninitialized_error
        self.__dict__["_GetVx"] = _raise_uninitialized_error
        self.__dict__["_SetVx"] = _raise_uninitialized_error
        self.__dict__["_GetVy"] = _raise_uninitialized_error
        self.__dict__["_SetVy"] = _raise_uninitialized_error
        self.__dict__["_GetVz"] = _raise_uninitialized_error
        self.__dict__["_SetVz"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAElementCartesian._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAElementCartesian from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAElement._private_init(self, pUnk)
        IID_IVAElementCartesian = agcom.GUID(IVAElementCartesian._uuid)
        vtable_offset_local = IVAElementCartesian._vtable_offset - 1
        self.__dict__["_GetX"] = IAGFUNCTYPE(pUnk, IID_IVAElementCartesian, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetX"] = IAGFUNCTYPE(pUnk, IID_IVAElementCartesian, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetY"] = IAGFUNCTYPE(pUnk, IID_IVAElementCartesian, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetY"] = IAGFUNCTYPE(pUnk, IID_IVAElementCartesian, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetZ"] = IAGFUNCTYPE(pUnk, IID_IVAElementCartesian, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetZ"] = IAGFUNCTYPE(pUnk, IID_IVAElementCartesian, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetVx"] = IAGFUNCTYPE(pUnk, IID_IVAElementCartesian, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetVx"] = IAGFUNCTYPE(pUnk, IID_IVAElementCartesian, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetVy"] = IAGFUNCTYPE(pUnk, IID_IVAElementCartesian, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetVy"] = IAGFUNCTYPE(pUnk, IID_IVAElementCartesian, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetVz"] = IAGFUNCTYPE(pUnk, IID_IVAElementCartesian, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetVz"] = IAGFUNCTYPE(pUnk, IID_IVAElementCartesian, vtable_offset_local+12, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAElementCartesian.__dict__ and type(IVAElementCartesian.__dict__[attrname]) == property:
            return IVAElementCartesian.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAElement.__setattr__(self, attrname, value)
    
    @property
    def X(self) -> float:
        """X position component. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetX"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @X.setter
    def X(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetX"](arg_newVal.COM_val))

    @property
    def Y(self) -> float:
        """Y position component. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetY"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Y.setter
    def Y(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetY"](arg_newVal.COM_val))

    @property
    def Z(self) -> float:
        """Z position component. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetZ"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Z.setter
    def Z(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetZ"](arg_newVal.COM_val))

    @property
    def Vx(self) -> float:
        """Vx velocity component. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVx"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Vx.setter
    def Vx(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetVx"](arg_newVal.COM_val))

    @property
    def Vy(self) -> float:
        """Vy velocity component. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVy"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Vy.setter
    def Vy(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetVy"](arg_newVal.COM_val))

    @property
    def Vz(self) -> float:
        """Vz velocity component. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVz"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Vz.setter
    def Vz(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetVz"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{63C45864-E165-498E-A88E-8104FABF50B9}", IVAElementCartesian)
agcls.AgTypeNameMap["IVAElementCartesian"] = IVAElementCartesian

class IVAElementKeplerian(IVAElement):
    """Properties for Keplerian elements"""
    _uuid = "{3550E5F6-FDEF-4325-BDBA-2BA984208ECB}"
    _num_methods = 46
    _vtable_offset = IVAElement._vtable_offset + IVAElement._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSemiMajorAxis"] = _raise_uninitialized_error
        self.__dict__["_SetSemiMajorAxis"] = _raise_uninitialized_error
        self.__dict__["_GetEccentricity"] = _raise_uninitialized_error
        self.__dict__["_SetEccentricity"] = _raise_uninitialized_error
        self.__dict__["_GetInclination"] = _raise_uninitialized_error
        self.__dict__["_SetInclination"] = _raise_uninitialized_error
        self.__dict__["_GetRAAN"] = _raise_uninitialized_error
        self.__dict__["_SetRAAN"] = _raise_uninitialized_error
        self.__dict__["_GetArgOfPeriapsis"] = _raise_uninitialized_error
        self.__dict__["_SetArgOfPeriapsis"] = _raise_uninitialized_error
        self.__dict__["_GetTrueAnomaly"] = _raise_uninitialized_error
        self.__dict__["_SetTrueAnomaly"] = _raise_uninitialized_error
        self.__dict__["_GetApoapsisAltitudeSize"] = _raise_uninitialized_error
        self.__dict__["_SetApoapsisAltitudeSize"] = _raise_uninitialized_error
        self.__dict__["_GetApoapsisRadiusSize"] = _raise_uninitialized_error
        self.__dict__["_SetApoapsisRadiusSize"] = _raise_uninitialized_error
        self.__dict__["_GetMeanMotion"] = _raise_uninitialized_error
        self.__dict__["_SetMeanMotion"] = _raise_uninitialized_error
        self.__dict__["_GetPeriapsisAltitudeSize"] = _raise_uninitialized_error
        self.__dict__["_SetPeriapsisAltitudeSize"] = _raise_uninitialized_error
        self.__dict__["_GetPeriapsisRadiusSize"] = _raise_uninitialized_error
        self.__dict__["_SetPeriapsisRadiusSize"] = _raise_uninitialized_error
        self.__dict__["_GetPeriod"] = _raise_uninitialized_error
        self.__dict__["_SetPeriod"] = _raise_uninitialized_error
        self.__dict__["_GetLAN"] = _raise_uninitialized_error
        self.__dict__["_SetLAN"] = _raise_uninitialized_error
        self.__dict__["_GetArgOfLatitude"] = _raise_uninitialized_error
        self.__dict__["_SetArgOfLatitude"] = _raise_uninitialized_error
        self.__dict__["_GetEccentricAnomaly"] = _raise_uninitialized_error
        self.__dict__["_SetEccentricAnomaly"] = _raise_uninitialized_error
        self.__dict__["_GetMeanAnomaly"] = _raise_uninitialized_error
        self.__dict__["_SetMeanAnomaly"] = _raise_uninitialized_error
        self.__dict__["_GetTimePastAscNode"] = _raise_uninitialized_error
        self.__dict__["_SetTimePastAscNode"] = _raise_uninitialized_error
        self.__dict__["_GetTimePastPeriapsis"] = _raise_uninitialized_error
        self.__dict__["_SetTimePastPeriapsis"] = _raise_uninitialized_error
        self.__dict__["_GetElementType"] = _raise_uninitialized_error
        self.__dict__["_SetElementType"] = _raise_uninitialized_error
        self.__dict__["_GetApoapsisAltitudeShape"] = _raise_uninitialized_error
        self.__dict__["_SetApoapsisAltitudeShape"] = _raise_uninitialized_error
        self.__dict__["_GetApoapsisRadiusShape"] = _raise_uninitialized_error
        self.__dict__["_SetApoapsisRadiusShape"] = _raise_uninitialized_error
        self.__dict__["_GetPeriapsisAltitudeShape"] = _raise_uninitialized_error
        self.__dict__["_SetPeriapsisAltitudeShape"] = _raise_uninitialized_error
        self.__dict__["_GetPeriapsisRadiusShape"] = _raise_uninitialized_error
        self.__dict__["_SetPeriapsisRadiusShape"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAElementKeplerian._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAElementKeplerian from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAElement._private_init(self, pUnk)
        IID_IVAElementKeplerian = agcom.GUID(IVAElementKeplerian._uuid)
        vtable_offset_local = IVAElementKeplerian._vtable_offset - 1
        self.__dict__["_GetSemiMajorAxis"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetSemiMajorAxis"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetEccentricity"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetEccentricity"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetInclination"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_SetInclination"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_GetRAAN"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_SetRAAN"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+8, agcom.VARIANT)
        self.__dict__["_GetArgOfPeriapsis"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+9, POINTER(agcom.VARIANT))
        self.__dict__["_SetArgOfPeriapsis"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+10, agcom.VARIANT)
        self.__dict__["_GetTrueAnomaly"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+11, POINTER(agcom.VARIANT))
        self.__dict__["_SetTrueAnomaly"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+12, agcom.VARIANT)
        self.__dict__["_GetApoapsisAltitudeSize"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetApoapsisAltitudeSize"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetApoapsisRadiusSize"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_SetApoapsisRadiusSize"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_GetMeanMotion"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMeanMotion"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_GetPeriapsisAltitudeSize"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_SetPeriapsisAltitudeSize"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_GetPeriapsisRadiusSize"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_SetPeriapsisRadiusSize"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+22, agcom.DOUBLE)
        self.__dict__["_GetPeriod"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+23, POINTER(agcom.DOUBLE))
        self.__dict__["_SetPeriod"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+24, agcom.DOUBLE)
        self.__dict__["_GetLAN"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+25, POINTER(agcom.VARIANT))
        self.__dict__["_SetLAN"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+26, agcom.VARIANT)
        self.__dict__["_GetArgOfLatitude"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+27, POINTER(agcom.VARIANT))
        self.__dict__["_SetArgOfLatitude"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+28, agcom.VARIANT)
        self.__dict__["_GetEccentricAnomaly"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+29, POINTER(agcom.VARIANT))
        self.__dict__["_SetEccentricAnomaly"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+30, agcom.VARIANT)
        self.__dict__["_GetMeanAnomaly"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+31, POINTER(agcom.VARIANT))
        self.__dict__["_SetMeanAnomaly"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+32, agcom.VARIANT)
        self.__dict__["_GetTimePastAscNode"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+33, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTimePastAscNode"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+34, agcom.DOUBLE)
        self.__dict__["_GetTimePastPeriapsis"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+35, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTimePastPeriapsis"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+36, agcom.DOUBLE)
        self.__dict__["_GetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+37, POINTER(agcom.LONG))
        self.__dict__["_SetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+38, agcom.LONG)
        self.__dict__["_GetApoapsisAltitudeShape"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+39, POINTER(agcom.DOUBLE))
        self.__dict__["_SetApoapsisAltitudeShape"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+40, agcom.DOUBLE)
        self.__dict__["_GetApoapsisRadiusShape"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+41, POINTER(agcom.DOUBLE))
        self.__dict__["_SetApoapsisRadiusShape"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+42, agcom.DOUBLE)
        self.__dict__["_GetPeriapsisAltitudeShape"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+43, POINTER(agcom.DOUBLE))
        self.__dict__["_SetPeriapsisAltitudeShape"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+44, agcom.DOUBLE)
        self.__dict__["_GetPeriapsisRadiusShape"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+45, POINTER(agcom.DOUBLE))
        self.__dict__["_SetPeriapsisRadiusShape"] = IAGFUNCTYPE(pUnk, IID_IVAElementKeplerian, vtable_offset_local+46, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAElementKeplerian.__dict__ and type(IVAElementKeplerian.__dict__[attrname]) == property:
            return IVAElementKeplerian.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAElement.__setattr__(self, attrname, value)
    
    @property
    def SemiMajorAxis(self) -> float:
        """One-half the distance along the long axis of the elliptical orbit. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSemiMajorAxis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SemiMajorAxis.setter
    def SemiMajorAxis(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetSemiMajorAxis"](arg_newVal.COM_val))

    @property
    def Eccentricity(self) -> float:
        """Describes the shape of the ellipse (a real number >= 0 and <1, where 0 = a circular orbit). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEccentricity"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Eccentricity.setter
    def Eccentricity(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEccentricity"](arg_newVal.COM_val))

    @property
    def Inclination(self) -> typing.Any:
        """The angle between the angular momentum vector (perpendicular to the plane of the orbit) and the inertial Z axis. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetInclination"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Inclination.setter
    def Inclination(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetInclination"](arg_newVal.COM_val))

    @property
    def RAAN(self) -> typing.Any:
        """The angle from the inertial X axis to the ascending node measured in a right-handed sense about the inertial Z axis in the equatorial plane. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRAAN"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RAAN.setter
    def RAAN(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetRAAN"](arg_newVal.COM_val))

    @property
    def ArgOfPeriapsis(self) -> typing.Any:
        """The angle from the ascending node to the eccentricity vector (lowest point of orbit) measured in the direction of the satellite's motion and in the orbit plane. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetArgOfPeriapsis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ArgOfPeriapsis.setter
    def ArgOfPeriapsis(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetArgOfPeriapsis"](arg_newVal.COM_val))

    @property
    def TrueAnomaly(self) -> typing.Any:
        """The angle from the eccentricity vector (points toward perigee) to the satellite position vector, measured in the direction of satellite motion and in the orbit plane. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTrueAnomaly"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TrueAnomaly.setter
    def TrueAnomaly(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTrueAnomaly"](arg_newVal.COM_val))

    @property
    def ApoapsisAltitudeSize(self) -> float:
        """Measured from the \"surface\" of the Earth to the points of maximum and minimum radius in the orbit. For these values, the surface of the Earth is modeled as a sphere whose radius equals the equatorial radius of the Earth. Uses Distance dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetApoapsisAltitudeSize"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ApoapsisAltitudeSize.setter
    def ApoapsisAltitudeSize(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetApoapsisAltitudeSize"](arg_inVal.COM_val))

    @property
    def ApoapsisRadiusSize(self) -> float:
        """Measured from the center of the Earth to the points of maximum and minimum radius in the orbit. Uses Distance dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetApoapsisRadiusSize"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ApoapsisRadiusSize.setter
    def ApoapsisRadiusSize(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetApoapsisRadiusSize"](arg_inVal.COM_val))

    @property
    def MeanMotion(self) -> float:
        """The uniform rate of the satellite in a circular orbit of the same period, typically expressed as degrees or radians per second, or as revolutions per day. Uses AngleRate dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMeanMotion"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MeanMotion.setter
    def MeanMotion(self, inVal:float) -> None:
        """."""
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMeanMotion"](arg_inVal.COM_val))

    @property
    def PeriapsisAltitudeSize(self) -> float:
        """Measured from the \"surface\" of the Earth to the points of maximum and minimum radius in the orbit. For these values, the surface of the Earth is modeled as a sphere whose radius equals the equatorial radius of the Earth. Uses Distance dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPeriapsisAltitudeSize"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @PeriapsisAltitudeSize.setter
    def PeriapsisAltitudeSize(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetPeriapsisAltitudeSize"](arg_inVal.COM_val))

    @property
    def PeriapsisRadiusSize(self) -> float:
        """Measured from the center of the Earth to the points of maximum and minimum radius in the orbit. Uses Distance dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPeriapsisRadiusSize"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @PeriapsisRadiusSize.setter
    def PeriapsisRadiusSize(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetPeriapsisRadiusSize"](arg_inVal.COM_val))

    @property
    def Period(self) -> float:
        """The duration of one orbit, based on assumed two-body motion. Uses Time dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPeriod"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Period.setter
    def Period(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetPeriod"](arg_inVal.COM_val))

    @property
    def LAN(self) -> typing.Any:
        """The Earth-fixed longitude where the satellite has crossed the inertial equator (the intersection of the ground track and the inertial equator) from south to north based on an assumption of two-body motion. Uses Angle dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLAN"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @LAN.setter
    def LAN(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetLAN"](arg_inVal.COM_val))

    @property
    def ArgOfLatitude(self) -> typing.Any:
        """The sum of the True Anomaly and the Argument of Perigee. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetArgOfLatitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ArgOfLatitude.setter
    def ArgOfLatitude(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetArgOfLatitude"](arg_newVal.COM_val))

    @property
    def EccentricAnomaly(self) -> typing.Any:
        """Angle measured with origin at the center of the ellipse from the direction of perigee to a point on a circumscribing circle from which a line perpendicular to the SMA intersects the position of the satellite on the ellipse. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEccentricAnomaly"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EccentricAnomaly.setter
    def EccentricAnomaly(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEccentricAnomaly"](arg_newVal.COM_val))

    @property
    def MeanAnomaly(self) -> typing.Any:
        """The angle from the eccentricity vector to a position vector where the satellite would be if it were always moving at its average angular rate. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMeanAnomaly"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MeanAnomaly.setter
    def MeanAnomaly(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetMeanAnomaly"](arg_newVal.COM_val))

    @property
    def TimePastAscNode(self) -> float:
        """The elapsed time since the last ascending node crossing based on assumed two-body motion. Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimePastAscNode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TimePastAscNode.setter
    def TimePastAscNode(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTimePastAscNode"](arg_newVal.COM_val))

    @property
    def TimePastPeriapsis(self) -> float:
        """The elapsed time since the last perigee passage based on assumed two-body motion. Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimePastPeriapsis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TimePastPeriapsis.setter
    def TimePastPeriapsis(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTimePastPeriapsis"](arg_newVal.COM_val))

    @property
    def ElementType(self) -> "AgEVAElement":
        """Which type of element (osculating or mean)."""
        with agmarshall.AgEnum_arg(AgEVAElement) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElementType.setter
    def ElementType(self, inVal:"AgEVAElement") -> None:
        """."""
        with agmarshall.AgEnum_arg(AgEVAElement, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetElementType"](arg_inVal.COM_val))

    @property
    def ApoapsisAltitudeShape(self) -> float:
        """Describes the shape of the ellipse. Uses Distance dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetApoapsisAltitudeShape"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ApoapsisAltitudeShape.setter
    def ApoapsisAltitudeShape(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetApoapsisAltitudeShape"](arg_inVal.COM_val))

    @property
    def ApoapsisRadiusShape(self) -> float:
        """Describes the shape of the ellipse. Uses Distance dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetApoapsisRadiusShape"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ApoapsisRadiusShape.setter
    def ApoapsisRadiusShape(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetApoapsisRadiusShape"](arg_inVal.COM_val))

    @property
    def PeriapsisAltitudeShape(self) -> float:
        """Describes the shape of the ellipse. Uses Distance dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPeriapsisAltitudeShape"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @PeriapsisAltitudeShape.setter
    def PeriapsisAltitudeShape(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetPeriapsisAltitudeShape"](arg_inVal.COM_val))

    @property
    def PeriapsisRadiusShape(self) -> float:
        """Describes the shape of the ellipse. Uses Distance dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPeriapsisRadiusShape"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @PeriapsisRadiusShape.setter
    def PeriapsisRadiusShape(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetPeriapsisRadiusShape"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3550E5F6-FDEF-4325-BDBA-2BA984208ECB}", IVAElementKeplerian)
agcls.AgTypeNameMap["IVAElementKeplerian"] = IVAElementKeplerian

class IVAElementDelaunay(IVAElement):
    """Properties for Delaunay elements"""
    _uuid = "{2D09DD04-C97C-43DB-B01A-D78DDD52FE1F}"
    _num_methods = 18
    _vtable_offset = IVAElement._vtable_offset + IVAElement._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetMeanAnomaly"] = _raise_uninitialized_error
        self.__dict__["_SetMeanAnomaly"] = _raise_uninitialized_error
        self.__dict__["_GetArgOfPeriapsis"] = _raise_uninitialized_error
        self.__dict__["_SetArgOfPeriapsis"] = _raise_uninitialized_error
        self.__dict__["_GetRAAN"] = _raise_uninitialized_error
        self.__dict__["_SetRAAN"] = _raise_uninitialized_error
        self.__dict__["_GetDelaunayL"] = _raise_uninitialized_error
        self.__dict__["_SetDelaunayL"] = _raise_uninitialized_error
        self.__dict__["_GetSemiMajorAxis"] = _raise_uninitialized_error
        self.__dict__["_SetSemiMajorAxis"] = _raise_uninitialized_error
        self.__dict__["_GetDelaunayG"] = _raise_uninitialized_error
        self.__dict__["_SetDelaunayG"] = _raise_uninitialized_error
        self.__dict__["_GetSemilatusRectum"] = _raise_uninitialized_error
        self.__dict__["_SetSemilatusRectum"] = _raise_uninitialized_error
        self.__dict__["_GetDelaunayH"] = _raise_uninitialized_error
        self.__dict__["_SetDelaunayH"] = _raise_uninitialized_error
        self.__dict__["_GetInclination"] = _raise_uninitialized_error
        self.__dict__["_SetInclination"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAElementDelaunay._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAElementDelaunay from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAElement._private_init(self, pUnk)
        IID_IVAElementDelaunay = agcom.GUID(IVAElementDelaunay._uuid)
        vtable_offset_local = IVAElementDelaunay._vtable_offset - 1
        self.__dict__["_GetMeanAnomaly"] = IAGFUNCTYPE(pUnk, IID_IVAElementDelaunay, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_SetMeanAnomaly"] = IAGFUNCTYPE(pUnk, IID_IVAElementDelaunay, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_GetArgOfPeriapsis"] = IAGFUNCTYPE(pUnk, IID_IVAElementDelaunay, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_SetArgOfPeriapsis"] = IAGFUNCTYPE(pUnk, IID_IVAElementDelaunay, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_GetRAAN"] = IAGFUNCTYPE(pUnk, IID_IVAElementDelaunay, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_SetRAAN"] = IAGFUNCTYPE(pUnk, IID_IVAElementDelaunay, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_GetDelaunayL"] = IAGFUNCTYPE(pUnk, IID_IVAElementDelaunay, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDelaunayL"] = IAGFUNCTYPE(pUnk, IID_IVAElementDelaunay, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetSemiMajorAxis"] = IAGFUNCTYPE(pUnk, IID_IVAElementDelaunay, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetSemiMajorAxis"] = IAGFUNCTYPE(pUnk, IID_IVAElementDelaunay, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetDelaunayG"] = IAGFUNCTYPE(pUnk, IID_IVAElementDelaunay, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDelaunayG"] = IAGFUNCTYPE(pUnk, IID_IVAElementDelaunay, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetSemilatusRectum"] = IAGFUNCTYPE(pUnk, IID_IVAElementDelaunay, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetSemilatusRectum"] = IAGFUNCTYPE(pUnk, IID_IVAElementDelaunay, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetDelaunayH"] = IAGFUNCTYPE(pUnk, IID_IVAElementDelaunay, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDelaunayH"] = IAGFUNCTYPE(pUnk, IID_IVAElementDelaunay, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_GetInclination"] = IAGFUNCTYPE(pUnk, IID_IVAElementDelaunay, vtable_offset_local+17, POINTER(agcom.VARIANT))
        self.__dict__["_SetInclination"] = IAGFUNCTYPE(pUnk, IID_IVAElementDelaunay, vtable_offset_local+18, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAElementDelaunay.__dict__ and type(IVAElementDelaunay.__dict__[attrname]) == property:
            return IVAElementDelaunay.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAElement.__setattr__(self, attrname, value)
    
    @property
    def MeanAnomaly(self) -> typing.Any:
        """The angle from the eccentricity vector to a position vector where the satellite would be if it were always moving at its average angular rate (l). Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMeanAnomaly"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MeanAnomaly.setter
    def MeanAnomaly(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetMeanAnomaly"](arg_newVal.COM_val))

    @property
    def ArgOfPeriapsis(self) -> typing.Any:
        """The angle from the ascending node to the eccentricity vector (lowest point of orbit) measured in the direction of the satellite's motion and in the orbit plane (g). Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetArgOfPeriapsis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ArgOfPeriapsis.setter
    def ArgOfPeriapsis(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetArgOfPeriapsis"](arg_newVal.COM_val))

    @property
    def RAAN(self) -> typing.Any:
        """The angle from the inertial X axis to the ascending node measured in a right-handed sense about the inertial Z axis in the equatorial plane (h). Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRAAN"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RAAN.setter
    def RAAN(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetRAAN"](arg_newVal.COM_val))

    @property
    def DelaunayL(self) -> float:
        """Related to the two-body orbital energy. Defined as sqrt(GM * a).   Uses AreaRate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDelaunayL"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DelaunayL.setter
    def DelaunayL(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetDelaunayL"](arg_newVal.COM_val))

    @property
    def SemiMajorAxis(self) -> float:
        """One-half the distance along the long axis of the elliptical orbit. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSemiMajorAxis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SemiMajorAxis.setter
    def SemiMajorAxis(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetSemiMajorAxis"](arg_newVal.COM_val))

    @property
    def DelaunayG(self) -> float:
        """The magnitude of the orbital angular momentum. Defined as sqrt(GM * p). Uses AreaRate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDelaunayG"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DelaunayG.setter
    def DelaunayG(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetDelaunayG"](arg_newVal.COM_val))

    @property
    def SemilatusRectum(self) -> float:
        """Semi-latus Rectum. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSemilatusRectum"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SemilatusRectum.setter
    def SemilatusRectum(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetSemilatusRectum"](arg_newVal.COM_val))

    @property
    def DelaunayH(self) -> float:
        """The Z component of the orbital angular momentum. Defined as G cos(inc).  Uses AreaRate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDelaunayH"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DelaunayH.setter
    def DelaunayH(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetDelaunayH"](arg_newVal.COM_val))

    @property
    def Inclination(self) -> typing.Any:
        """The angle between the angular momentum vector (perpendicular to the plane of the orbit) and the inertial Z axis. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetInclination"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Inclination.setter
    def Inclination(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetInclination"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2D09DD04-C97C-43DB-B01A-D78DDD52FE1F}", IVAElementDelaunay)
agcls.AgTypeNameMap["IVAElementDelaunay"] = IVAElementDelaunay

class IVAElementEquinoctial(IVAElement):
    """Properties for Equinoctial elements"""
    _uuid = "{90FA8C03-AA29-446A-A23A-085B71502DAA}"
    _num_methods = 16
    _vtable_offset = IVAElement._vtable_offset + IVAElement._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSemiMajorAxis"] = _raise_uninitialized_error
        self.__dict__["_SetSemiMajorAxis"] = _raise_uninitialized_error
        self.__dict__["_GetMeanMotion"] = _raise_uninitialized_error
        self.__dict__["_SetMeanMotion"] = _raise_uninitialized_error
        self.__dict__["_Geth"] = _raise_uninitialized_error
        self.__dict__["_Seth"] = _raise_uninitialized_error
        self.__dict__["_Getk"] = _raise_uninitialized_error
        self.__dict__["_Setk"] = _raise_uninitialized_error
        self.__dict__["_Getp"] = _raise_uninitialized_error
        self.__dict__["_Setp"] = _raise_uninitialized_error
        self.__dict__["_Getq"] = _raise_uninitialized_error
        self.__dict__["_Setq"] = _raise_uninitialized_error
        self.__dict__["_GetMeanLongitude"] = _raise_uninitialized_error
        self.__dict__["_SetMeanLongitude"] = _raise_uninitialized_error
        self.__dict__["_GetFormulation"] = _raise_uninitialized_error
        self.__dict__["_SetFormulation"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAElementEquinoctial._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAElementEquinoctial from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAElement._private_init(self, pUnk)
        IID_IVAElementEquinoctial = agcom.GUID(IVAElementEquinoctial._uuid)
        vtable_offset_local = IVAElementEquinoctial._vtable_offset - 1
        self.__dict__["_GetSemiMajorAxis"] = IAGFUNCTYPE(pUnk, IID_IVAElementEquinoctial, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetSemiMajorAxis"] = IAGFUNCTYPE(pUnk, IID_IVAElementEquinoctial, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetMeanMotion"] = IAGFUNCTYPE(pUnk, IID_IVAElementEquinoctial, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMeanMotion"] = IAGFUNCTYPE(pUnk, IID_IVAElementEquinoctial, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_Geth"] = IAGFUNCTYPE(pUnk, IID_IVAElementEquinoctial, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_Seth"] = IAGFUNCTYPE(pUnk, IID_IVAElementEquinoctial, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_Getk"] = IAGFUNCTYPE(pUnk, IID_IVAElementEquinoctial, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_Setk"] = IAGFUNCTYPE(pUnk, IID_IVAElementEquinoctial, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_Getp"] = IAGFUNCTYPE(pUnk, IID_IVAElementEquinoctial, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_Setp"] = IAGFUNCTYPE(pUnk, IID_IVAElementEquinoctial, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_Getq"] = IAGFUNCTYPE(pUnk, IID_IVAElementEquinoctial, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_Setq"] = IAGFUNCTYPE(pUnk, IID_IVAElementEquinoctial, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetMeanLongitude"] = IAGFUNCTYPE(pUnk, IID_IVAElementEquinoctial, vtable_offset_local+13, POINTER(agcom.VARIANT))
        self.__dict__["_SetMeanLongitude"] = IAGFUNCTYPE(pUnk, IID_IVAElementEquinoctial, vtable_offset_local+14, agcom.VARIANT)
        self.__dict__["_GetFormulation"] = IAGFUNCTYPE(pUnk, IID_IVAElementEquinoctial, vtable_offset_local+15, POINTER(agcom.LONG))
        self.__dict__["_SetFormulation"] = IAGFUNCTYPE(pUnk, IID_IVAElementEquinoctial, vtable_offset_local+16, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAElementEquinoctial.__dict__ and type(IVAElementEquinoctial.__dict__[attrname]) == property:
            return IVAElementEquinoctial.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAElement.__setattr__(self, attrname, value)
    
    @property
    def SemiMajorAxis(self) -> float:
        """Half the length of the major axis of the orbital ellipse. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSemiMajorAxis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SemiMajorAxis.setter
    def SemiMajorAxis(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetSemiMajorAxis"](arg_newVal.COM_val))

    @property
    def MeanMotion(self) -> float:
        """The average angular rate of the satellite based on 2 body motion. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMeanMotion"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MeanMotion.setter
    def MeanMotion(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetMeanMotion"](arg_newVal.COM_val))

    @property
    def h(self) -> float:
        """h/k collectively describe the shape of the satellite's orbit and the position of perigee. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_Geth"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @h.setter
    def h(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_Seth"](arg_newVal.COM_val))

    @property
    def k(self) -> float:
        """h/k collectively describe the shape of the satellite's orbit and the position of perigee. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_Getk"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @k.setter
    def k(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_Setk"](arg_newVal.COM_val))

    @property
    def p(self) -> float:
        """p/q collectively describe the orientation of the satellite's orbit plane. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_Getp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @p.setter
    def p(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_Setp"](arg_newVal.COM_val))

    @property
    def q(self) -> float:
        """p/q collectively describe the orientation of the satellite's orbit plane. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_Getq"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @q.setter
    def q(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_Setq"](arg_newVal.COM_val))

    @property
    def MeanLongitude(self) -> typing.Any:
        """Specifies a satellite's position within its orbit at epoch and equals the sum of the classical Right Ascension of the Ascending Node, Argument of Perigee, and Mean Anomaly. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMeanLongitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MeanLongitude.setter
    def MeanLongitude(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetMeanLongitude"](arg_newVal.COM_val))

    @property
    def Formulation(self) -> "AgEVAFormulation":
        """Retrograde, which has its singularity at an inclination of 0 deg. Posigrade, which has its singularity at an inclination of 180 deg."""
        with agmarshall.AgEnum_arg(AgEVAFormulation) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetFormulation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Formulation.setter
    def Formulation(self, inVal:"AgEVAFormulation") -> None:
        with agmarshall.AgEnum_arg(AgEVAFormulation, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetFormulation"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{90FA8C03-AA29-446A-A23A-085B71502DAA}", IVAElementEquinoctial)
agcls.AgTypeNameMap["IVAElementEquinoctial"] = IVAElementEquinoctial

class IVAElementMixedSpherical(IVAElement):
    """Properties for Mixed Spherical elements"""
    _uuid = "{8A1D2A11-5A9D-49D8-9CE6-6435B1173292}"
    _num_methods = 14
    _vtable_offset = IVAElement._vtable_offset + IVAElement._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetLongitude"] = _raise_uninitialized_error
        self.__dict__["_SetLongitude"] = _raise_uninitialized_error
        self.__dict__["_GetLatitude"] = _raise_uninitialized_error
        self.__dict__["_SetLatitude"] = _raise_uninitialized_error
        self.__dict__["_GetAltitude"] = _raise_uninitialized_error
        self.__dict__["_SetAltitude"] = _raise_uninitialized_error
        self.__dict__["_GetHorizontalFlightPathAngle"] = _raise_uninitialized_error
        self.__dict__["_SetHorizontalFlightPathAngle"] = _raise_uninitialized_error
        self.__dict__["_GetVelocityAzimuth"] = _raise_uninitialized_error
        self.__dict__["_SetVelocityAzimuth"] = _raise_uninitialized_error
        self.__dict__["_GetVelocityMagnitude"] = _raise_uninitialized_error
        self.__dict__["_SetVelocityMagnitude"] = _raise_uninitialized_error
        self.__dict__["_GetVerticalFlightPathAngle"] = _raise_uninitialized_error
        self.__dict__["_SetVerticalFlightPathAngle"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAElementMixedSpherical._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAElementMixedSpherical from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAElement._private_init(self, pUnk)
        IID_IVAElementMixedSpherical = agcom.GUID(IVAElementMixedSpherical._uuid)
        vtable_offset_local = IVAElementMixedSpherical._vtable_offset - 1
        self.__dict__["_GetLongitude"] = IAGFUNCTYPE(pUnk, IID_IVAElementMixedSpherical, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_SetLongitude"] = IAGFUNCTYPE(pUnk, IID_IVAElementMixedSpherical, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_GetLatitude"] = IAGFUNCTYPE(pUnk, IID_IVAElementMixedSpherical, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_SetLatitude"] = IAGFUNCTYPE(pUnk, IID_IVAElementMixedSpherical, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_GetAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAElementMixedSpherical, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAElementMixedSpherical, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetHorizontalFlightPathAngle"] = IAGFUNCTYPE(pUnk, IID_IVAElementMixedSpherical, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_SetHorizontalFlightPathAngle"] = IAGFUNCTYPE(pUnk, IID_IVAElementMixedSpherical, vtable_offset_local+8, agcom.VARIANT)
        self.__dict__["_GetVelocityAzimuth"] = IAGFUNCTYPE(pUnk, IID_IVAElementMixedSpherical, vtable_offset_local+9, POINTER(agcom.VARIANT))
        self.__dict__["_SetVelocityAzimuth"] = IAGFUNCTYPE(pUnk, IID_IVAElementMixedSpherical, vtable_offset_local+10, agcom.VARIANT)
        self.__dict__["_GetVelocityMagnitude"] = IAGFUNCTYPE(pUnk, IID_IVAElementMixedSpherical, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetVelocityMagnitude"] = IAGFUNCTYPE(pUnk, IID_IVAElementMixedSpherical, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetVerticalFlightPathAngle"] = IAGFUNCTYPE(pUnk, IID_IVAElementMixedSpherical, vtable_offset_local+13, POINTER(agcom.VARIANT))
        self.__dict__["_SetVerticalFlightPathAngle"] = IAGFUNCTYPE(pUnk, IID_IVAElementMixedSpherical, vtable_offset_local+14, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAElementMixedSpherical.__dict__ and type(IVAElementMixedSpherical.__dict__[attrname]) == property:
            return IVAElementMixedSpherical.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAElement.__setattr__(self, attrname, value)
    
    @property
    def Longitude(self) -> typing.Any:
        """Measured from -180.0 deg to +360.0 deg. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLongitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Longitude.setter
    def Longitude(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetLongitude"](arg_newVal.COM_val))

    @property
    def Latitude(self) -> typing.Any:
        """Measured from -90.0 deg to +90.0 deg. The geodetic latitude of a point is the angle between (1) the normal to the reference ellipsoid that passes through the satellite position and (2) the equatorial plane. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLatitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Latitude.setter
    def Latitude(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetLatitude"](arg_newVal.COM_val))

    @property
    def Altitude(self) -> float:
        """The object's position above or below the reference ellipsoid. Altitude is measured along a normal to the surface of the reference ellipsoid. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAltitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Altitude.setter
    def Altitude(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetAltitude"](arg_newVal.COM_val))

    @property
    def HorizontalFlightPathAngle(self) -> typing.Any:
        """Horizontal (Hor FPA) or vertical (Ver FPA) flight path angle. The angle between the inertial velocity vector and the radius vector (vertical) or the complement of this angle (horizontal). Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetHorizontalFlightPathAngle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @HorizontalFlightPathAngle.setter
    def HorizontalFlightPathAngle(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetHorizontalFlightPathAngle"](arg_newVal.COM_val))

    @property
    def VelocityAzimuth(self) -> typing.Any:
        """The angle in the satellite local horizontal plane between the projection of the inertial velocity vector onto this plane and the local north direction measured as positive in the clockwise direction. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVelocityAzimuth"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VelocityAzimuth.setter
    def VelocityAzimuth(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetVelocityAzimuth"](arg_newVal.COM_val))

    @property
    def VelocityMagnitude(self) -> float:
        """The angle in the satellite local horizontal plane between the projection of the inertial velocity vector onto this plane and the local north direction measured as positive in the clockwise direction. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVelocityMagnitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VelocityMagnitude.setter
    def VelocityMagnitude(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetVelocityMagnitude"](arg_newVal.COM_val))

    @property
    def VerticalFlightPathAngle(self) -> typing.Any:
        """Horizontal (Hor FPA) or vertical (Ver FPA) flight path angle. The angle between the inertial velocity vector and the radius vector (vertical) or the complement of this angle (horizontal). Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVerticalFlightPathAngle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VerticalFlightPathAngle.setter
    def VerticalFlightPathAngle(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetVerticalFlightPathAngle"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{8A1D2A11-5A9D-49D8-9CE6-6435B1173292}", IVAElementMixedSpherical)
agcls.AgTypeNameMap["IVAElementMixedSpherical"] = IVAElementMixedSpherical

class IVAElementSpherical(IVAElement):
    """Properties for Spherical elements"""
    _uuid = "{C2B6D754-C55A-4FE1-88AE-976A54FD0C75}"
    _num_methods = 14
    _vtable_offset = IVAElement._vtable_offset + IVAElement._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetRightAscension"] = _raise_uninitialized_error
        self.__dict__["_SetRightAscension"] = _raise_uninitialized_error
        self.__dict__["_GetDeclination"] = _raise_uninitialized_error
        self.__dict__["_SetDeclination"] = _raise_uninitialized_error
        self.__dict__["_GetRadiusMagnitude"] = _raise_uninitialized_error
        self.__dict__["_SetRadiusMagnitude"] = _raise_uninitialized_error
        self.__dict__["_GetHorizontalFlightPathAngle"] = _raise_uninitialized_error
        self.__dict__["_SetHorizontalFlightPathAngle"] = _raise_uninitialized_error
        self.__dict__["_GetVelocityAzimuth"] = _raise_uninitialized_error
        self.__dict__["_SetVelocityAzimuth"] = _raise_uninitialized_error
        self.__dict__["_GetVelocityMagnitude"] = _raise_uninitialized_error
        self.__dict__["_SetVelocityMagnitude"] = _raise_uninitialized_error
        self.__dict__["_GetVerticalFlightPathAngle"] = _raise_uninitialized_error
        self.__dict__["_SetVerticalFlightPathAngle"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAElementSpherical._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAElementSpherical from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAElement._private_init(self, pUnk)
        IID_IVAElementSpherical = agcom.GUID(IVAElementSpherical._uuid)
        vtable_offset_local = IVAElementSpherical._vtable_offset - 1
        self.__dict__["_GetRightAscension"] = IAGFUNCTYPE(pUnk, IID_IVAElementSpherical, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_SetRightAscension"] = IAGFUNCTYPE(pUnk, IID_IVAElementSpherical, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_GetDeclination"] = IAGFUNCTYPE(pUnk, IID_IVAElementSpherical, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_SetDeclination"] = IAGFUNCTYPE(pUnk, IID_IVAElementSpherical, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_GetRadiusMagnitude"] = IAGFUNCTYPE(pUnk, IID_IVAElementSpherical, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRadiusMagnitude"] = IAGFUNCTYPE(pUnk, IID_IVAElementSpherical, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetHorizontalFlightPathAngle"] = IAGFUNCTYPE(pUnk, IID_IVAElementSpherical, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_SetHorizontalFlightPathAngle"] = IAGFUNCTYPE(pUnk, IID_IVAElementSpherical, vtable_offset_local+8, agcom.VARIANT)
        self.__dict__["_GetVelocityAzimuth"] = IAGFUNCTYPE(pUnk, IID_IVAElementSpherical, vtable_offset_local+9, POINTER(agcom.VARIANT))
        self.__dict__["_SetVelocityAzimuth"] = IAGFUNCTYPE(pUnk, IID_IVAElementSpherical, vtable_offset_local+10, agcom.VARIANT)
        self.__dict__["_GetVelocityMagnitude"] = IAGFUNCTYPE(pUnk, IID_IVAElementSpherical, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetVelocityMagnitude"] = IAGFUNCTYPE(pUnk, IID_IVAElementSpherical, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetVerticalFlightPathAngle"] = IAGFUNCTYPE(pUnk, IID_IVAElementSpherical, vtable_offset_local+13, POINTER(agcom.VARIANT))
        self.__dict__["_SetVerticalFlightPathAngle"] = IAGFUNCTYPE(pUnk, IID_IVAElementSpherical, vtable_offset_local+14, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAElementSpherical.__dict__ and type(IVAElementSpherical.__dict__[attrname]) == property:
            return IVAElementSpherical.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAElement.__setattr__(self, attrname, value)
    
    @property
    def RightAscension(self) -> typing.Any:
        """Defined as the angle from the X axis to the projection of the satellite position vector in the equatorial plane measured as positive in the direction of the Y axis. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRightAscension"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RightAscension.setter
    def RightAscension(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetRightAscension"](arg_newVal.COM_val))

    @property
    def Declination(self) -> typing.Any:
        """Defined as the angle between the satellite position vector and the inertial equatorial plane measured as positive toward the positive inertial Z axis. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDeclination"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Declination.setter
    def Declination(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetDeclination"](arg_newVal.COM_val))

    @property
    def RadiusMagnitude(self) -> float:
        """The magnitude of the satellite position vector. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRadiusMagnitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RadiusMagnitude.setter
    def RadiusMagnitude(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetRadiusMagnitude"](arg_newVal.COM_val))

    @property
    def HorizontalFlightPathAngle(self) -> typing.Any:
        """Horizontal (Hor FPA) or vertical (Ver FPA) flight path angle. The angle between the velocity vector and the radius vector (vertical) or the complement of this angle (horizontal). Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetHorizontalFlightPathAngle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @HorizontalFlightPathAngle.setter
    def HorizontalFlightPathAngle(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetHorizontalFlightPathAngle"](arg_newVal.COM_val))

    @property
    def VelocityAzimuth(self) -> typing.Any:
        """The angle in the satellite local horizontal plane between the projection of the velocity vector onto this plane and the local north direction measured as positive in the clockwise direction. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVelocityAzimuth"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VelocityAzimuth.setter
    def VelocityAzimuth(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetVelocityAzimuth"](arg_newVal.COM_val))

    @property
    def VelocityMagnitude(self) -> float:
        """The magnitude of the velocity vector. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVelocityMagnitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VelocityMagnitude.setter
    def VelocityMagnitude(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetVelocityMagnitude"](arg_newVal.COM_val))

    @property
    def VerticalFlightPathAngle(self) -> typing.Any:
        """Horizontal (Hor FPA) or vertical (Ver FPA) flight path angle. The angle between the velocity vector and the radius vector (vertical) or the complement of this angle (horizontal). Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVerticalFlightPathAngle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VerticalFlightPathAngle.setter
    def VerticalFlightPathAngle(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetVerticalFlightPathAngle"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{C2B6D754-C55A-4FE1-88AE-976A54FD0C75}", IVAElementSpherical)
agcls.AgTypeNameMap["IVAElementSpherical"] = IVAElementSpherical

class IVAElementTargetVectorIncomingAsymptote(IVAElement):
    """Properties for Target Vector Incoming Asymptote elements."""
    _uuid = "{B7EA61B2-6910-43E7-B4F7-CBA647EC19A3}"
    _num_methods = 12
    _vtable_offset = IVAElement._vtable_offset + IVAElement._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetRadiusOfPeriapsis"] = _raise_uninitialized_error
        self.__dict__["_SetRadiusOfPeriapsis"] = _raise_uninitialized_error
        self.__dict__["_GetC3Energy"] = _raise_uninitialized_error
        self.__dict__["_SetC3Energy"] = _raise_uninitialized_error
        self.__dict__["_GetRAIncomingAsymptote"] = _raise_uninitialized_error
        self.__dict__["_SetRAIncomingAsymptote"] = _raise_uninitialized_error
        self.__dict__["_GetDeclinationIncomingAsymptote"] = _raise_uninitialized_error
        self.__dict__["_SetDeclinationIncomingAsymptote"] = _raise_uninitialized_error
        self.__dict__["_GetVelocityAzimuthPeriapsis"] = _raise_uninitialized_error
        self.__dict__["_SetVelocityAzimuthPeriapsis"] = _raise_uninitialized_error
        self.__dict__["_GetTrueAnomaly"] = _raise_uninitialized_error
        self.__dict__["_SetTrueAnomaly"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAElementTargetVectorIncomingAsymptote._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAElementTargetVectorIncomingAsymptote from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAElement._private_init(self, pUnk)
        IID_IVAElementTargetVectorIncomingAsymptote = agcom.GUID(IVAElementTargetVectorIncomingAsymptote._uuid)
        vtable_offset_local = IVAElementTargetVectorIncomingAsymptote._vtable_offset - 1
        self.__dict__["_GetRadiusOfPeriapsis"] = IAGFUNCTYPE(pUnk, IID_IVAElementTargetVectorIncomingAsymptote, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRadiusOfPeriapsis"] = IAGFUNCTYPE(pUnk, IID_IVAElementTargetVectorIncomingAsymptote, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetC3Energy"] = IAGFUNCTYPE(pUnk, IID_IVAElementTargetVectorIncomingAsymptote, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetC3Energy"] = IAGFUNCTYPE(pUnk, IID_IVAElementTargetVectorIncomingAsymptote, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetRAIncomingAsymptote"] = IAGFUNCTYPE(pUnk, IID_IVAElementTargetVectorIncomingAsymptote, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_SetRAIncomingAsymptote"] = IAGFUNCTYPE(pUnk, IID_IVAElementTargetVectorIncomingAsymptote, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_GetDeclinationIncomingAsymptote"] = IAGFUNCTYPE(pUnk, IID_IVAElementTargetVectorIncomingAsymptote, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_SetDeclinationIncomingAsymptote"] = IAGFUNCTYPE(pUnk, IID_IVAElementTargetVectorIncomingAsymptote, vtable_offset_local+8, agcom.VARIANT)
        self.__dict__["_GetVelocityAzimuthPeriapsis"] = IAGFUNCTYPE(pUnk, IID_IVAElementTargetVectorIncomingAsymptote, vtable_offset_local+9, POINTER(agcom.VARIANT))
        self.__dict__["_SetVelocityAzimuthPeriapsis"] = IAGFUNCTYPE(pUnk, IID_IVAElementTargetVectorIncomingAsymptote, vtable_offset_local+10, agcom.VARIANT)
        self.__dict__["_GetTrueAnomaly"] = IAGFUNCTYPE(pUnk, IID_IVAElementTargetVectorIncomingAsymptote, vtable_offset_local+11, POINTER(agcom.VARIANT))
        self.__dict__["_SetTrueAnomaly"] = IAGFUNCTYPE(pUnk, IID_IVAElementTargetVectorIncomingAsymptote, vtable_offset_local+12, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAElementTargetVectorIncomingAsymptote.__dict__ and type(IVAElementTargetVectorIncomingAsymptote.__dict__[attrname]) == property:
            return IVAElementTargetVectorIncomingAsymptote.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAElement.__setattr__(self, attrname, value)
    
    @property
    def RadiusOfPeriapsis(self) -> float:
        """Radius of Periapsis. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRadiusOfPeriapsis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RadiusOfPeriapsis.setter
    def RadiusOfPeriapsis(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetRadiusOfPeriapsis"](arg_newVal.COM_val))

    @property
    def C3Energy(self) -> float:
        """C3Energy (Rate squared)."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetC3Energy"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @C3Energy.setter
    def C3Energy(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetC3Energy"](arg_newVal.COM_val))

    @property
    def RAIncomingAsymptote(self) -> typing.Any:
        """Right Ascension of Incoming Asymptote. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRAIncomingAsymptote"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RAIncomingAsymptote.setter
    def RAIncomingAsymptote(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetRAIncomingAsymptote"](arg_newVal.COM_val))

    @property
    def DeclinationIncomingAsymptote(self) -> typing.Any:
        """Declination of Incoming Asymptote. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDeclinationIncomingAsymptote"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DeclinationIncomingAsymptote.setter
    def DeclinationIncomingAsymptote(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetDeclinationIncomingAsymptote"](arg_newVal.COM_val))

    @property
    def VelocityAzimuthPeriapsis(self) -> typing.Any:
        """Velocity Azimuth at Periapsis. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVelocityAzimuthPeriapsis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VelocityAzimuthPeriapsis.setter
    def VelocityAzimuthPeriapsis(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetVelocityAzimuthPeriapsis"](arg_newVal.COM_val))

    @property
    def TrueAnomaly(self) -> typing.Any:
        """True Anomaly. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTrueAnomaly"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TrueAnomaly.setter
    def TrueAnomaly(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTrueAnomaly"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{B7EA61B2-6910-43E7-B4F7-CBA647EC19A3}", IVAElementTargetVectorIncomingAsymptote)
agcls.AgTypeNameMap["IVAElementTargetVectorIncomingAsymptote"] = IVAElementTargetVectorIncomingAsymptote

class IVAElementTargetVectorOutgoingAsymptote(IVAElement):
    """Properties for Target Vector Outgoing Asymptote elements."""
    _uuid = "{BE7E87B6-AC1F-4A19-A1C8-15272B707777}"
    _num_methods = 12
    _vtable_offset = IVAElement._vtable_offset + IVAElement._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetRadiusOfPeriapsis"] = _raise_uninitialized_error
        self.__dict__["_SetRadiusOfPeriapsis"] = _raise_uninitialized_error
        self.__dict__["_GetC3Energy"] = _raise_uninitialized_error
        self.__dict__["_SetC3Energy"] = _raise_uninitialized_error
        self.__dict__["_GetRAOutgoingAsymptote"] = _raise_uninitialized_error
        self.__dict__["_SetRAOutgoingAsymptote"] = _raise_uninitialized_error
        self.__dict__["_GetDeclinationOutgoingAsymptote"] = _raise_uninitialized_error
        self.__dict__["_SetDeclinationOutgoingAsymptote"] = _raise_uninitialized_error
        self.__dict__["_GetVelocityAzimuthPeriapsis"] = _raise_uninitialized_error
        self.__dict__["_SetVelocityAzimuthPeriapsis"] = _raise_uninitialized_error
        self.__dict__["_GetTrueAnomaly"] = _raise_uninitialized_error
        self.__dict__["_SetTrueAnomaly"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAElementTargetVectorOutgoingAsymptote._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAElementTargetVectorOutgoingAsymptote from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAElement._private_init(self, pUnk)
        IID_IVAElementTargetVectorOutgoingAsymptote = agcom.GUID(IVAElementTargetVectorOutgoingAsymptote._uuid)
        vtable_offset_local = IVAElementTargetVectorOutgoingAsymptote._vtable_offset - 1
        self.__dict__["_GetRadiusOfPeriapsis"] = IAGFUNCTYPE(pUnk, IID_IVAElementTargetVectorOutgoingAsymptote, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRadiusOfPeriapsis"] = IAGFUNCTYPE(pUnk, IID_IVAElementTargetVectorOutgoingAsymptote, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetC3Energy"] = IAGFUNCTYPE(pUnk, IID_IVAElementTargetVectorOutgoingAsymptote, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetC3Energy"] = IAGFUNCTYPE(pUnk, IID_IVAElementTargetVectorOutgoingAsymptote, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetRAOutgoingAsymptote"] = IAGFUNCTYPE(pUnk, IID_IVAElementTargetVectorOutgoingAsymptote, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_SetRAOutgoingAsymptote"] = IAGFUNCTYPE(pUnk, IID_IVAElementTargetVectorOutgoingAsymptote, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_GetDeclinationOutgoingAsymptote"] = IAGFUNCTYPE(pUnk, IID_IVAElementTargetVectorOutgoingAsymptote, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_SetDeclinationOutgoingAsymptote"] = IAGFUNCTYPE(pUnk, IID_IVAElementTargetVectorOutgoingAsymptote, vtable_offset_local+8, agcom.VARIANT)
        self.__dict__["_GetVelocityAzimuthPeriapsis"] = IAGFUNCTYPE(pUnk, IID_IVAElementTargetVectorOutgoingAsymptote, vtable_offset_local+9, POINTER(agcom.VARIANT))
        self.__dict__["_SetVelocityAzimuthPeriapsis"] = IAGFUNCTYPE(pUnk, IID_IVAElementTargetVectorOutgoingAsymptote, vtable_offset_local+10, agcom.VARIANT)
        self.__dict__["_GetTrueAnomaly"] = IAGFUNCTYPE(pUnk, IID_IVAElementTargetVectorOutgoingAsymptote, vtable_offset_local+11, POINTER(agcom.VARIANT))
        self.__dict__["_SetTrueAnomaly"] = IAGFUNCTYPE(pUnk, IID_IVAElementTargetVectorOutgoingAsymptote, vtable_offset_local+12, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAElementTargetVectorOutgoingAsymptote.__dict__ and type(IVAElementTargetVectorOutgoingAsymptote.__dict__[attrname]) == property:
            return IVAElementTargetVectorOutgoingAsymptote.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAElement.__setattr__(self, attrname, value)
    
    @property
    def RadiusOfPeriapsis(self) -> float:
        """Radius of Periapsis. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRadiusOfPeriapsis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RadiusOfPeriapsis.setter
    def RadiusOfPeriapsis(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetRadiusOfPeriapsis"](arg_newVal.COM_val))

    @property
    def C3Energy(self) -> float:
        """C3Energy (Rate Squared)."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetC3Energy"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @C3Energy.setter
    def C3Energy(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetC3Energy"](arg_newVal.COM_val))

    @property
    def RAOutgoingAsymptote(self) -> typing.Any:
        """Right Ascension of Incoming Asymptote. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRAOutgoingAsymptote"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RAOutgoingAsymptote.setter
    def RAOutgoingAsymptote(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetRAOutgoingAsymptote"](arg_newVal.COM_val))

    @property
    def DeclinationOutgoingAsymptote(self) -> typing.Any:
        """Declination of Incoming Asymptote. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDeclinationOutgoingAsymptote"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DeclinationOutgoingAsymptote.setter
    def DeclinationOutgoingAsymptote(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetDeclinationOutgoingAsymptote"](arg_newVal.COM_val))

    @property
    def VelocityAzimuthPeriapsis(self) -> typing.Any:
        """Velocity Azimuth at Periapsis. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVelocityAzimuthPeriapsis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VelocityAzimuthPeriapsis.setter
    def VelocityAzimuthPeriapsis(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetVelocityAzimuthPeriapsis"](arg_newVal.COM_val))

    @property
    def TrueAnomaly(self) -> typing.Any:
        """True Anomaly. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTrueAnomaly"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TrueAnomaly.setter
    def TrueAnomaly(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTrueAnomaly"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{BE7E87B6-AC1F-4A19-A1C8-15272B707777}", IVAElementTargetVectorOutgoingAsymptote)
agcls.AgTypeNameMap["IVAElementTargetVectorOutgoingAsymptote"] = IVAElementTargetVectorOutgoingAsymptote

class IVAElementGeodetic(IVAElement):
    """Properties for Geodetic elements"""
    _uuid = "{091F376E-6C32-4567-BE00-D1CE1857B50F}"
    _num_methods = 16
    _vtable_offset = IVAElement._vtable_offset + IVAElement._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetLatitude"] = _raise_uninitialized_error
        self.__dict__["_SetLatitude"] = _raise_uninitialized_error
        self.__dict__["_GetLongitude"] = _raise_uninitialized_error
        self.__dict__["_SetLongitude"] = _raise_uninitialized_error
        self.__dict__["_GetAltitude"] = _raise_uninitialized_error
        self.__dict__["_SetAltitude"] = _raise_uninitialized_error
        self.__dict__["_GetRadiusMagnitude"] = _raise_uninitialized_error
        self.__dict__["_SetRadiusMagnitude"] = _raise_uninitialized_error
        self.__dict__["_GetLatitudeRate"] = _raise_uninitialized_error
        self.__dict__["_SetLatitudeRate"] = _raise_uninitialized_error
        self.__dict__["_GetLongitudeRate"] = _raise_uninitialized_error
        self.__dict__["_SetLongitudeRate"] = _raise_uninitialized_error
        self.__dict__["_GetAltitudeRate"] = _raise_uninitialized_error
        self.__dict__["_SetAltitudeRate"] = _raise_uninitialized_error
        self.__dict__["_GetRadiusRate"] = _raise_uninitialized_error
        self.__dict__["_SetRadiusRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAElementGeodetic._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAElementGeodetic from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAElement._private_init(self, pUnk)
        IID_IVAElementGeodetic = agcom.GUID(IVAElementGeodetic._uuid)
        vtable_offset_local = IVAElementGeodetic._vtable_offset - 1
        self.__dict__["_GetLatitude"] = IAGFUNCTYPE(pUnk, IID_IVAElementGeodetic, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_SetLatitude"] = IAGFUNCTYPE(pUnk, IID_IVAElementGeodetic, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_GetLongitude"] = IAGFUNCTYPE(pUnk, IID_IVAElementGeodetic, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_SetLongitude"] = IAGFUNCTYPE(pUnk, IID_IVAElementGeodetic, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_GetAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAElementGeodetic, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAElementGeodetic, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetRadiusMagnitude"] = IAGFUNCTYPE(pUnk, IID_IVAElementGeodetic, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRadiusMagnitude"] = IAGFUNCTYPE(pUnk, IID_IVAElementGeodetic, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetLatitudeRate"] = IAGFUNCTYPE(pUnk, IID_IVAElementGeodetic, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetLatitudeRate"] = IAGFUNCTYPE(pUnk, IID_IVAElementGeodetic, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetLongitudeRate"] = IAGFUNCTYPE(pUnk, IID_IVAElementGeodetic, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetLongitudeRate"] = IAGFUNCTYPE(pUnk, IID_IVAElementGeodetic, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetAltitudeRate"] = IAGFUNCTYPE(pUnk, IID_IVAElementGeodetic, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAltitudeRate"] = IAGFUNCTYPE(pUnk, IID_IVAElementGeodetic, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetRadiusRate"] = IAGFUNCTYPE(pUnk, IID_IVAElementGeodetic, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRadiusRate"] = IAGFUNCTYPE(pUnk, IID_IVAElementGeodetic, vtable_offset_local+16, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAElementGeodetic.__dict__ and type(IVAElementGeodetic.__dict__[attrname]) == property:
            return IVAElementGeodetic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAElement.__setattr__(self, attrname, value)
    
    @property
    def Latitude(self) -> typing.Any:
        """Measured in degrees from -90.0 deg to +90.0 deg. The geodetic latitude of a point is the angle between the normal to the reference ellipsoid and the equatorial plane. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLatitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Latitude.setter
    def Latitude(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetLatitude"](arg_newVal.COM_val))

    @property
    def Longitude(self) -> typing.Any:
        """Measured in degrees from -360.0 deg to +360.0 deg. The longitude of a point is the angle between the projection of the position vector in the equatorial plane and the prime meridian. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLongitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Longitude.setter
    def Longitude(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetLongitude"](arg_newVal.COM_val))

    @property
    def Altitude(self) -> float:
        """Measured along an outward normal to the surface of the ellipsoid. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAltitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Altitude.setter
    def Altitude(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetAltitude"](arg_newVal.COM_val))

    @property
    def RadiusMagnitude(self) -> float:
        """Measured from the center of the Earth. Specified as distance above or below the reference ellipsoid. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRadiusMagnitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RadiusMagnitude.setter
    def RadiusMagnitude(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetRadiusMagnitude"](arg_newVal.COM_val))

    @property
    def LatitudeRate(self) -> float:
        """The rate of change of the satellite's latitude. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLatitudeRate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @LatitudeRate.setter
    def LatitudeRate(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetLatitudeRate"](arg_newVal.COM_val))

    @property
    def LongitudeRate(self) -> float:
        """The rate of change of the satellite's longitude. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLongitudeRate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @LongitudeRate.setter
    def LongitudeRate(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetLongitudeRate"](arg_newVal.COM_val))

    @property
    def AltitudeRate(self) -> float:
        """The rate of change of the altitude. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAltitudeRate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AltitudeRate.setter
    def AltitudeRate(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetAltitudeRate"](arg_newVal.COM_val))

    @property
    def RadiusRate(self) -> float:
        """The rate of change of the radius. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRadiusRate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RadiusRate.setter
    def RadiusRate(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetRadiusRate"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{091F376E-6C32-4567-BE00-D1CE1857B50F}", IVAElementGeodetic)
agcls.AgTypeNameMap["IVAElementGeodetic"] = IVAElementGeodetic

class IVAElementBPlane(IVAElement):
    """Properties for BPlane elements"""
    _uuid = "{83490C08-4958-4B0E-8AE9-E6795F70211A}"
    _num_methods = 26
    _vtable_offset = IVAElement._vtable_offset + IVAElement._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetRightAscensionOfBPlane"] = _raise_uninitialized_error
        self.__dict__["_SetRightAscensionOfBPlane"] = _raise_uninitialized_error
        self.__dict__["_GetDeclinationOfBPlane"] = _raise_uninitialized_error
        self.__dict__["_SetDeclinationOfBPlane"] = _raise_uninitialized_error
        self.__dict__["_GetBDotRFirstBVector"] = _raise_uninitialized_error
        self.__dict__["_SetBDotRFirstBVector"] = _raise_uninitialized_error
        self.__dict__["_GetBDotTSecondBVector"] = _raise_uninitialized_error
        self.__dict__["_SetBDotTSecondBVector"] = _raise_uninitialized_error
        self.__dict__["_GetHyperbolicTurningAngle"] = _raise_uninitialized_error
        self.__dict__["_SetHyperbolicTurningAngle"] = _raise_uninitialized_error
        self.__dict__["_GetOrbitalC3Energy"] = _raise_uninitialized_error
        self.__dict__["_SetOrbitalC3Energy"] = _raise_uninitialized_error
        self.__dict__["_GetHyperbolicVInfinity"] = _raise_uninitialized_error
        self.__dict__["_SetHyperbolicVInfinity"] = _raise_uninitialized_error
        self.__dict__["_GetSemiMajorAxis"] = _raise_uninitialized_error
        self.__dict__["_SetSemiMajorAxis"] = _raise_uninitialized_error
        self.__dict__["_GetBDotTFirstBVector"] = _raise_uninitialized_error
        self.__dict__["_SetBDotTFirstBVector"] = _raise_uninitialized_error
        self.__dict__["_GetBThetaFirstBVector"] = _raise_uninitialized_error
        self.__dict__["_SetBThetaFirstBVector"] = _raise_uninitialized_error
        self.__dict__["_GetBDotRSecondBVector"] = _raise_uninitialized_error
        self.__dict__["_SetBDotRSecondBVector"] = _raise_uninitialized_error
        self.__dict__["_GetBMagSecondBVector"] = _raise_uninitialized_error
        self.__dict__["_SetBMagSecondBVector"] = _raise_uninitialized_error
        self.__dict__["_GetTrueAnomaly"] = _raise_uninitialized_error
        self.__dict__["_SetTrueAnomaly"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAElementBPlane._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAElementBPlane from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAElement._private_init(self, pUnk)
        IID_IVAElementBPlane = agcom.GUID(IVAElementBPlane._uuid)
        vtable_offset_local = IVAElementBPlane._vtable_offset - 1
        self.__dict__["_GetRightAscensionOfBPlane"] = IAGFUNCTYPE(pUnk, IID_IVAElementBPlane, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRightAscensionOfBPlane"] = IAGFUNCTYPE(pUnk, IID_IVAElementBPlane, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetDeclinationOfBPlane"] = IAGFUNCTYPE(pUnk, IID_IVAElementBPlane, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDeclinationOfBPlane"] = IAGFUNCTYPE(pUnk, IID_IVAElementBPlane, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetBDotRFirstBVector"] = IAGFUNCTYPE(pUnk, IID_IVAElementBPlane, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetBDotRFirstBVector"] = IAGFUNCTYPE(pUnk, IID_IVAElementBPlane, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetBDotTSecondBVector"] = IAGFUNCTYPE(pUnk, IID_IVAElementBPlane, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetBDotTSecondBVector"] = IAGFUNCTYPE(pUnk, IID_IVAElementBPlane, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetHyperbolicTurningAngle"] = IAGFUNCTYPE(pUnk, IID_IVAElementBPlane, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetHyperbolicTurningAngle"] = IAGFUNCTYPE(pUnk, IID_IVAElementBPlane, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetOrbitalC3Energy"] = IAGFUNCTYPE(pUnk, IID_IVAElementBPlane, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetOrbitalC3Energy"] = IAGFUNCTYPE(pUnk, IID_IVAElementBPlane, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetHyperbolicVInfinity"] = IAGFUNCTYPE(pUnk, IID_IVAElementBPlane, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetHyperbolicVInfinity"] = IAGFUNCTYPE(pUnk, IID_IVAElementBPlane, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetSemiMajorAxis"] = IAGFUNCTYPE(pUnk, IID_IVAElementBPlane, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_SetSemiMajorAxis"] = IAGFUNCTYPE(pUnk, IID_IVAElementBPlane, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_GetBDotTFirstBVector"] = IAGFUNCTYPE(pUnk, IID_IVAElementBPlane, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_SetBDotTFirstBVector"] = IAGFUNCTYPE(pUnk, IID_IVAElementBPlane, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_GetBThetaFirstBVector"] = IAGFUNCTYPE(pUnk, IID_IVAElementBPlane, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_SetBThetaFirstBVector"] = IAGFUNCTYPE(pUnk, IID_IVAElementBPlane, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_GetBDotRSecondBVector"] = IAGFUNCTYPE(pUnk, IID_IVAElementBPlane, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_SetBDotRSecondBVector"] = IAGFUNCTYPE(pUnk, IID_IVAElementBPlane, vtable_offset_local+22, agcom.DOUBLE)
        self.__dict__["_GetBMagSecondBVector"] = IAGFUNCTYPE(pUnk, IID_IVAElementBPlane, vtable_offset_local+23, POINTER(agcom.DOUBLE))
        self.__dict__["_SetBMagSecondBVector"] = IAGFUNCTYPE(pUnk, IID_IVAElementBPlane, vtable_offset_local+24, agcom.DOUBLE)
        self.__dict__["_GetTrueAnomaly"] = IAGFUNCTYPE(pUnk, IID_IVAElementBPlane, vtable_offset_local+25, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTrueAnomaly"] = IAGFUNCTYPE(pUnk, IID_IVAElementBPlane, vtable_offset_local+26, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAElementBPlane.__dict__ and type(IVAElementBPlane.__dict__[attrname]) == property:
            return IVAElementBPlane.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAElement.__setattr__(self, attrname, value)
    
    @property
    def RightAscensionOfBPlane(self) -> float:
        """Right Ascension of the B-Plane Normal."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRightAscensionOfBPlane"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RightAscensionOfBPlane.setter
    def RightAscensionOfBPlane(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetRightAscensionOfBPlane"](arg_newVal.COM_val))

    @property
    def DeclinationOfBPlane(self) -> float:
        """Declination of the B-Plane Normal."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDeclinationOfBPlane"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DeclinationOfBPlane.setter
    def DeclinationOfBPlane(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetDeclinationOfBPlane"](arg_newVal.COM_val))

    @property
    def BDotRFirstBVector(self) -> float:
        """B vector dotted with R vector."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetBDotRFirstBVector"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @BDotRFirstBVector.setter
    def BDotRFirstBVector(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetBDotRFirstBVector"](arg_newVal.COM_val))

    @property
    def BDotTSecondBVector(self) -> float:
        """B vector dotted with T vector."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetBDotTSecondBVector"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @BDotTSecondBVector.setter
    def BDotTSecondBVector(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetBDotTSecondBVector"](arg_newVal.COM_val))

    @property
    def HyperbolicTurningAngle(self) -> float:
        """Hyperbolic turning angle."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetHyperbolicTurningAngle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @HyperbolicTurningAngle.setter
    def HyperbolicTurningAngle(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetHyperbolicTurningAngle"](arg_newVal.COM_val))

    @property
    def OrbitalC3Energy(self) -> float:
        """Orbital C3 Energy."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetOrbitalC3Energy"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @OrbitalC3Energy.setter
    def OrbitalC3Energy(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetOrbitalC3Energy"](arg_newVal.COM_val))

    @property
    def HyperbolicVInfinity(self) -> float:
        """Hyperbolic V infinity."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetHyperbolicVInfinity"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @HyperbolicVInfinity.setter
    def HyperbolicVInfinity(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetHyperbolicVInfinity"](arg_newVal.COM_val))

    @property
    def SemiMajorAxis(self) -> float:
        """Semi-major axis."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSemiMajorAxis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SemiMajorAxis.setter
    def SemiMajorAxis(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetSemiMajorAxis"](arg_newVal.COM_val))

    @property
    def BDotTFirstBVector(self) -> float:
        """B vector dotted with T vector used as the first quantity to define the B vector."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetBDotTFirstBVector"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @BDotTFirstBVector.setter
    def BDotTFirstBVector(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetBDotTFirstBVector"](arg_newVal.COM_val))

    @property
    def BThetaFirstBVector(self) -> float:
        """Angle between the B vector and T vector used as the first quantity to define the B vector."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetBThetaFirstBVector"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @BThetaFirstBVector.setter
    def BThetaFirstBVector(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetBThetaFirstBVector"](arg_newVal.COM_val))

    @property
    def BDotRSecondBVector(self) -> float:
        """B vector dotted with T vector used as the second quantity to define the B vector."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetBDotRSecondBVector"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @BDotRSecondBVector.setter
    def BDotRSecondBVector(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetBDotRSecondBVector"](arg_newVal.COM_val))

    @property
    def BMagSecondBVector(self) -> float:
        """Magnitude of the B vector used as the second quantity to define the B vector."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetBMagSecondBVector"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @BMagSecondBVector.setter
    def BMagSecondBVector(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetBMagSecondBVector"](arg_newVal.COM_val))

    @property
    def TrueAnomaly(self) -> float:
        """True Anomaly."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTrueAnomaly"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TrueAnomaly.setter
    def TrueAnomaly(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTrueAnomaly"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{83490C08-4958-4B0E-8AE9-E6795F70211A}", IVAElementBPlane)
agcls.AgTypeNameMap["IVAElementBPlane"] = IVAElementBPlane

class IVAStoppingCondition(IVAStoppingConditionComponent):
    """Basic properties for a stopping condition."""
    _uuid = "{7B18D549-E67A-4532-9767-ECC78418475D}"
    _num_methods = 30
    _vtable_offset = IVAStoppingConditionComponent._vtable_offset + IVAStoppingConditionComponent._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTrip"] = _raise_uninitialized_error
        self.__dict__["_SetTrip"] = _raise_uninitialized_error
        self.__dict__["_GetTolerance"] = _raise_uninitialized_error
        self.__dict__["_SetTolerance"] = _raise_uninitialized_error
        self.__dict__["_GetRepeatCount"] = _raise_uninitialized_error
        self.__dict__["_SetRepeatCount"] = _raise_uninitialized_error
        self.__dict__["_GetInherited"] = _raise_uninitialized_error
        self.__dict__["_SetInherited"] = _raise_uninitialized_error
        self.__dict__["_GetMaxTripTimes"] = _raise_uninitialized_error
        self.__dict__["_SetMaxTripTimes"] = _raise_uninitialized_error
        self.__dict__["_GetCoordSystem"] = _raise_uninitialized_error
        self.__dict__["_SetCoordSystem"] = _raise_uninitialized_error
        self.__dict__["_GetSequence"] = _raise_uninitialized_error
        self.__dict__["_SetSequence"] = _raise_uninitialized_error
        self.__dict__["_GetConstraints"] = _raise_uninitialized_error
        self.__dict__["_GetUserCalcObjectName"] = _raise_uninitialized_error
        self.__dict__["_SetUserCalcObjectName"] = _raise_uninitialized_error
        self.__dict__["_GetUserCalcObject"] = _raise_uninitialized_error
        self.__dict__["_SetUserCalcObject"] = _raise_uninitialized_error
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetCriterion"] = _raise_uninitialized_error
        self.__dict__["_SetCriterion"] = _raise_uninitialized_error
        self.__dict__["_GetBeforeConditions"] = _raise_uninitialized_error
        self.__dict__["_GetDimension"] = _raise_uninitialized_error
        self.__dict__["_GetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_SetReferencePoint"] = _raise_uninitialized_error
        self.__dict__["_CopyUserCalcObjectToClipboard"] = _raise_uninitialized_error
        self.__dict__["_PasteUserCalcObjectFromClipboard"] = _raise_uninitialized_error
        self.__dict__["_GetUserCalcObjectLinkEmbedControl"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStoppingCondition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStoppingCondition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAStoppingConditionComponent._private_init(self, pUnk)
        IID_IVAStoppingCondition = agcom.GUID(IVAStoppingCondition._uuid)
        vtable_offset_local = IVAStoppingCondition._vtable_offset - 1
        self.__dict__["_GetTrip"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingCondition, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_SetTrip"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingCondition, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_GetTolerance"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingCondition, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTolerance"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingCondition, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetRepeatCount"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingCondition, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRepeatCount"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingCondition, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetInherited"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingCondition, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetInherited"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingCondition, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_GetMaxTripTimes"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingCondition, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaxTripTimes"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingCondition, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetCoordSystem"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingCondition, vtable_offset_local+11, POINTER(agcom.BSTR))
        self.__dict__["_SetCoordSystem"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingCondition, vtable_offset_local+12, agcom.BSTR)
        self.__dict__["_GetSequence"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingCondition, vtable_offset_local+13, POINTER(agcom.BSTR))
        self.__dict__["_SetSequence"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingCondition, vtable_offset_local+14, agcom.BSTR)
        self.__dict__["_GetConstraints"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingCondition, vtable_offset_local+15, POINTER(agcom.PVOID))
        self.__dict__["_GetUserCalcObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingCondition, vtable_offset_local+16, POINTER(agcom.BSTR))
        self.__dict__["_SetUserCalcObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingCondition, vtable_offset_local+17, agcom.BSTR)
        self.__dict__["_GetUserCalcObject"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingCondition, vtable_offset_local+18, POINTER(agcom.PVOID))
        self.__dict__["_SetUserCalcObject"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingCondition, vtable_offset_local+19, agcom.PVOID)
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingCondition, vtable_offset_local+20, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingCondition, vtable_offset_local+21, agcom.BSTR)
        self.__dict__["_GetCriterion"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingCondition, vtable_offset_local+22, POINTER(agcom.LONG))
        self.__dict__["_SetCriterion"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingCondition, vtable_offset_local+23, agcom.LONG)
        self.__dict__["_GetBeforeConditions"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingCondition, vtable_offset_local+24, POINTER(agcom.PVOID))
        self.__dict__["_GetDimension"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingCondition, vtable_offset_local+25, POINTER(agcom.BSTR))
        self.__dict__["_GetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingCondition, vtable_offset_local+26, POINTER(agcom.BSTR))
        self.__dict__["_SetReferencePoint"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingCondition, vtable_offset_local+27, agcom.BSTR)
        self.__dict__["_CopyUserCalcObjectToClipboard"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingCondition, vtable_offset_local+28, )
        self.__dict__["_PasteUserCalcObjectFromClipboard"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingCondition, vtable_offset_local+29, )
        self.__dict__["_GetUserCalcObjectLinkEmbedControl"] = IAGFUNCTYPE(pUnk, IID_IVAStoppingCondition, vtable_offset_local+30, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStoppingCondition.__dict__ and type(IVAStoppingCondition.__dict__[attrname]) == property:
            return IVAStoppingCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAStoppingConditionComponent.__setattr__(self, attrname, value)
    
    @property
    def Trip(self) -> typing.Any:
        """The desired value - the value at which the condition will be satisfied. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTrip"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Trip.setter
    def Trip(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTrip"](arg_newVal.COM_val))

    @property
    def Tolerance(self) -> float:
        """The desired tolerance for achieving the stopping condition. Dimension depends on context."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTolerance"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Tolerance.setter
    def Tolerance(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTolerance"](arg_newVal.COM_val))

    @property
    def RepeatCount(self) -> float:
        """The number of times the condition must be satisfied before the propagation ends or moves on to the designated automatic sequence. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRepeatCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RepeatCount.setter
    def RepeatCount(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetRepeatCount"](arg_newVal.COM_val))

    @property
    def Inherited(self) -> bool:
        """Condition Inherited by Automatic Sequences - if true, the stopping condition will be applied to any automatic sequences activated within the same segment."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetInherited"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Inherited.setter
    def Inherited(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetInherited"](arg_newVal.COM_val))

    @property
    def MaxTripTimes(self) -> float:
        """The maximum number of times that the stopping condition will be applied - and any resulting automatic sequences executed. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxTripTimes"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxTripTimes.setter
    def MaxTripTimes(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxTripTimes"](arg_inVal.COM_val))

    @property
    def CoordSystem(self) -> str:
        """The coordinate system. The default coordinate system of a stopping condition is Earth Inertial."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordSystem"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordSystem.setter
    def CoordSystem(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordSystem"](arg_newVal.COM_val))

    @property
    def Sequence(self) -> str:
        """The automatic sequence to trigger if the highlighted stopping condition is satisfied."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSequence"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Sequence.setter
    def Sequence(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetSequence"](arg_newVal.COM_val))

    @property
    def Constraints(self) -> "IVAConstraintCollection":
        """Further conditions that must be met in order for the stopping condition to be deemed satisfied."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAConstraintCollection:
            agcls.evaluate_hresult(self.__dict__["_GetConstraints"](byref(arg_ppVAConstraintCollection.COM_val)))
            return arg_ppVAConstraintCollection.python_val

    @property
    def UserCalcObjectName(self) -> str:
        """User Calc Object - a User Calculation Object for the highlighted stopping condition. For user-defined stopping conditions, use this field to specify what kind of value you want to stop on."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUserCalcObjectName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UserCalcObjectName.setter
    def UserCalcObjectName(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetUserCalcObjectName"](arg_newVal.COM_val))

    @property
    def UserCalcObject(self) -> "IComponentInfo":
        """A User Calculation Object for the highlighted stopping condition. For user-defined stopping conditions, use this field to specify what kind of value you want to stop on."""
        with agmarshall.AgInterface_out_arg() as arg_ppComponentInfo:
            agcls.evaluate_hresult(self.__dict__["_GetUserCalcObject"](byref(arg_ppComponentInfo.COM_val)))
            return arg_ppComponentInfo.python_val

    @UserCalcObject.setter
    def UserCalcObject(self, newVal:"IComponentInfo") -> None:
        with agmarshall.AgInterface_in_arg(newVal, IComponentInfo) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetUserCalcObject"](arg_newVal.COM_val))

    @property
    def CentralBodyName(self) -> str:
        """The central body. The default central body of a stopping condition is the Earth."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_newVal.COM_val))

    @property
    def Criterion(self) -> "AgEVACriterion":
        """Specifies the direction from which the stopping condition value must be achieved."""
        with agmarshall.AgEnum_arg(AgEVACriterion) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCriterion"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Criterion.setter
    def Criterion(self, newVal:"AgEVACriterion") -> None:
        with agmarshall.AgEnum_arg(AgEVACriterion, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCriterion"](arg_newVal.COM_val))

    @property
    def BeforeConditions(self) -> "IVAStoppingConditionCollection":
        """A 'before' stopping condition is used to define a stopping condition that depends on two events. Astrogator will ignore a stopping condition until its 'before' conditions are met. Astrogator then interpolates backwards to the normal stopping condition."""
        with agmarshall.AgInterface_out_arg() as arg_ppStoppingConditionCollection:
            agcls.evaluate_hresult(self.__dict__["_GetBeforeConditions"](byref(arg_ppStoppingConditionCollection.COM_val)))
            return arg_ppStoppingConditionCollection.python_val

    @property
    def Dimension(self) -> str:
        """The dimension of the stopping condition."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDimension"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def ReferencePoint(self) -> str:
        """Reference point used for calculation."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePoint"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @ReferencePoint.setter
    def ReferencePoint(self, inVal:str) -> None:
        """Reference point used for calculation."""
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetReferencePoint"](arg_inVal.COM_val))

    def CopyUserCalcObjectToClipboard(self) -> None:
        """Copies the user-defined stopping condition calc object to the clipboard."""
        agcls.evaluate_hresult(self.__dict__["_CopyUserCalcObjectToClipboard"]())

    def PasteUserCalcObjectFromClipboard(self) -> None:
        """Replaces the user-defined stopping condition calc object with the calc object in the clipboard."""
        agcls.evaluate_hresult(self.__dict__["_PasteUserCalcObjectFromClipboard"]())

    @property
    def UserCalcObjectLinkEmbedControl(self) -> "IComponentLinkEmbedControl":
        """Gets the link / embed controller for managing the user calc. object."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_GetUserCalcObjectLinkEmbedControl"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{7B18D549-E67A-4532-9767-ECC78418475D}", IVAStoppingCondition)
agcls.AgTypeNameMap["IVAStoppingCondition"] = IVAStoppingCondition

class IVALightingStoppingCondition(IVAStoppingConditionComponent):
    """Properties for a lighting stopping condition."""
    _uuid = "{05642E87-6580-4E1F-82EF-BA6406DBAC65}"
    _num_methods = 18
    _vtable_offset = IVAStoppingConditionComponent._vtable_offset + IVAStoppingConditionComponent._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetMaxTripTimes"] = _raise_uninitialized_error
        self.__dict__["_SetMaxTripTimes"] = _raise_uninitialized_error
        self.__dict__["_GetRepeatCount"] = _raise_uninitialized_error
        self.__dict__["_SetRepeatCount"] = _raise_uninitialized_error
        self.__dict__["_GetConstraints"] = _raise_uninitialized_error
        self.__dict__["_GetBeforeConditions"] = _raise_uninitialized_error
        self.__dict__["_GetInherited"] = _raise_uninitialized_error
        self.__dict__["_SetInherited"] = _raise_uninitialized_error
        self.__dict__["_GetSequence"] = _raise_uninitialized_error
        self.__dict__["_SetSequence"] = _raise_uninitialized_error
        self.__dict__["_GetCondition"] = _raise_uninitialized_error
        self.__dict__["_SetCondition"] = _raise_uninitialized_error
        self.__dict__["_GetEclipsingBodiesListSource"] = _raise_uninitialized_error
        self.__dict__["_SetEclipsingBodiesListSource"] = _raise_uninitialized_error
        self.__dict__["_AddEclipsingBody"] = _raise_uninitialized_error
        self.__dict__["_RemoveEclipsingBody"] = _raise_uninitialized_error
        self.__dict__["_GetEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_GetAvailableEclipsingBodies"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVALightingStoppingCondition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVALightingStoppingCondition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAStoppingConditionComponent._private_init(self, pUnk)
        IID_IVALightingStoppingCondition = agcom.GUID(IVALightingStoppingCondition._uuid)
        vtable_offset_local = IVALightingStoppingCondition._vtable_offset - 1
        self.__dict__["_GetMaxTripTimes"] = IAGFUNCTYPE(pUnk, IID_IVALightingStoppingCondition, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaxTripTimes"] = IAGFUNCTYPE(pUnk, IID_IVALightingStoppingCondition, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetRepeatCount"] = IAGFUNCTYPE(pUnk, IID_IVALightingStoppingCondition, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRepeatCount"] = IAGFUNCTYPE(pUnk, IID_IVALightingStoppingCondition, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetConstraints"] = IAGFUNCTYPE(pUnk, IID_IVALightingStoppingCondition, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_GetBeforeConditions"] = IAGFUNCTYPE(pUnk, IID_IVALightingStoppingCondition, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_GetInherited"] = IAGFUNCTYPE(pUnk, IID_IVALightingStoppingCondition, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetInherited"] = IAGFUNCTYPE(pUnk, IID_IVALightingStoppingCondition, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_GetSequence"] = IAGFUNCTYPE(pUnk, IID_IVALightingStoppingCondition, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_SetSequence"] = IAGFUNCTYPE(pUnk, IID_IVALightingStoppingCondition, vtable_offset_local+10, agcom.BSTR)
        self.__dict__["_GetCondition"] = IAGFUNCTYPE(pUnk, IID_IVALightingStoppingCondition, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_SetCondition"] = IAGFUNCTYPE(pUnk, IID_IVALightingStoppingCondition, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_GetEclipsingBodiesListSource"] = IAGFUNCTYPE(pUnk, IID_IVALightingStoppingCondition, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_SetEclipsingBodiesListSource"] = IAGFUNCTYPE(pUnk, IID_IVALightingStoppingCondition, vtable_offset_local+14, agcom.LONG)
        self.__dict__["_AddEclipsingBody"] = IAGFUNCTYPE(pUnk, IID_IVALightingStoppingCondition, vtable_offset_local+15, agcom.BSTR)
        self.__dict__["_RemoveEclipsingBody"] = IAGFUNCTYPE(pUnk, IID_IVALightingStoppingCondition, vtable_offset_local+16, agcom.BSTR)
        self.__dict__["_GetEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_IVALightingStoppingCondition, vtable_offset_local+17, POINTER(agcom.SAFEARRAY))
        self.__dict__["_GetAvailableEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_IVALightingStoppingCondition, vtable_offset_local+18, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVALightingStoppingCondition.__dict__ and type(IVALightingStoppingCondition.__dict__[attrname]) == property:
            return IVALightingStoppingCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAStoppingConditionComponent.__setattr__(self, attrname, value)
    
    @property
    def MaxTripTimes(self) -> float:
        """Rhe maximum number of times that the stopping condition will be applied - and any resulting automatic sequences executed. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxTripTimes"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxTripTimes.setter
    def MaxTripTimes(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxTripTimes"](arg_inVal.COM_val))

    @property
    def RepeatCount(self) -> float:
        """The number of times the condition must be satisfied before the propagation ends or moves on to the designated automatic sequence. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRepeatCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RepeatCount.setter
    def RepeatCount(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetRepeatCount"](arg_newVal.COM_val))

    @property
    def Constraints(self) -> "IVAConstraintCollection":
        """Further conditions that must be met in order for the stopping condition to be deemed satisfied."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAConstraintCollection:
            agcls.evaluate_hresult(self.__dict__["_GetConstraints"](byref(arg_ppVAConstraintCollection.COM_val)))
            return arg_ppVAConstraintCollection.python_val

    @property
    def BeforeConditions(self) -> "IVAStoppingConditionCollection":
        """A 'before' stopping condition is used to define a stopping condition that depends on two events. Astrogator will ignore a stopping condition until its 'before' conditions are met. Astrogator then interpolates backwards to the normal stopping condition."""
        with agmarshall.AgInterface_out_arg() as arg_ppStoppingConditionCollection:
            agcls.evaluate_hresult(self.__dict__["_GetBeforeConditions"](byref(arg_ppStoppingConditionCollection.COM_val)))
            return arg_ppStoppingConditionCollection.python_val

    @property
    def Inherited(self) -> bool:
        """Condition Inherited by Automatic Sequences - if true, the stopping condition will be applied to any automatic sequences activated within the same segment."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetInherited"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Inherited.setter
    def Inherited(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetInherited"](arg_newVal.COM_val))

    @property
    def Sequence(self) -> str:
        """The automatic sequence to trigger if the highlighted stopping condition is satisfied."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSequence"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Sequence.setter
    def Sequence(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetSequence"](arg_newVal.COM_val))

    @property
    def Condition(self) -> "AgEVALightingCondition":
        """Specifies the direction from which the stopping condition value must be achieved."""
        with agmarshall.AgEnum_arg(AgEVALightingCondition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCondition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Condition.setter
    def Condition(self, newVal:"AgEVALightingCondition") -> None:
        with agmarshall.AgEnum_arg(AgEVALightingCondition, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCondition"](arg_newVal.COM_val))

    @property
    def EclipsingBodiesListSource(self) -> "AgEVAEclipsingBodiesSource":
        """Eclipsing Bodies List Source."""
        with agmarshall.AgEnum_arg(AgEVAEclipsingBodiesSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEclipsingBodiesListSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EclipsingBodiesListSource.setter
    def EclipsingBodiesListSource(self, newVal:"AgEVAEclipsingBodiesSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAEclipsingBodiesSource, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEclipsingBodiesListSource"](arg_newVal.COM_val))

    def AddEclipsingBody(self, eclipsingBody:str) -> None:
        """Adds an eclipsing body."""
        with agmarshall.BSTR_arg(eclipsingBody) as arg_eclipsingBody:
            agcls.evaluate_hresult(self.__dict__["_AddEclipsingBody"](arg_eclipsingBody.COM_val))

    def RemoveEclipsingBody(self, eclipsingBody:str) -> None:
        """Removes an eclipsing body."""
        with agmarshall.BSTR_arg(eclipsingBody) as arg_eclipsingBody:
            agcls.evaluate_hresult(self.__dict__["_RemoveEclipsingBody"](arg_eclipsingBody.COM_val))

    @property
    def EclipsingBodies(self) -> list:
        """Returns a list of user selected eclipsing bodies."""
        with agmarshall.SAFEARRAY_arg() as arg_ppNewVal:
            agcls.evaluate_hresult(self.__dict__["_GetEclipsingBodies"](byref(arg_ppNewVal.COM_val)))
            return arg_ppNewVal.python_val

    @property
    def AvailableEclipsingBodies(self) -> list:
        """Returns a list of available eclipsing bodies."""
        with agmarshall.SAFEARRAY_arg() as arg_ppNewVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailableEclipsingBodies"](byref(arg_ppNewVal.COM_val)))
            return arg_ppNewVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{05642E87-6580-4E1F-82EF-BA6406DBAC65}", IVALightingStoppingCondition)
agcls.AgTypeNameMap["IVALightingStoppingCondition"] = IVALightingStoppingCondition

class IVAAccessStoppingCondition(IVAStoppingConditionComponent):
    """Properties for an access stopping condition."""
    _uuid = "{2A2D2F12-9F9B-43F6-B6B0-00088C006504}"
    _num_methods = 28
    _vtable_offset = IVAStoppingConditionComponent._vtable_offset + IVAStoppingConditionComponent._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTimeConvergence"] = _raise_uninitialized_error
        self.__dict__["_SetTimeConvergence"] = _raise_uninitialized_error
        self.__dict__["_GetRepeatCount"] = _raise_uninitialized_error
        self.__dict__["_SetRepeatCount"] = _raise_uninitialized_error
        self.__dict__["_GetInherited"] = _raise_uninitialized_error
        self.__dict__["_SetInherited"] = _raise_uninitialized_error
        self.__dict__["_GetMaxTripTimes"] = _raise_uninitialized_error
        self.__dict__["_SetMaxTripTimes"] = _raise_uninitialized_error
        self.__dict__["_GetSequence"] = _raise_uninitialized_error
        self.__dict__["_SetSequence"] = _raise_uninitialized_error
        self.__dict__["_GetConstraints"] = _raise_uninitialized_error
        self.__dict__["_GetCriterion"] = _raise_uninitialized_error
        self.__dict__["_SetCriterion"] = _raise_uninitialized_error
        self.__dict__["_GetBeforeConditions"] = _raise_uninitialized_error
        self.__dict__["_GetAberrationType"] = _raise_uninitialized_error
        self.__dict__["_SetAberrationType"] = _raise_uninitialized_error
        self.__dict__["_SetBaseSelection"] = _raise_uninitialized_error
        self.__dict__["_GetBaseSelectionType"] = _raise_uninitialized_error
        self.__dict__["_GetBaseSelection"] = _raise_uninitialized_error
        self.__dict__["_GetClockHost"] = _raise_uninitialized_error
        self.__dict__["_SetClockHost"] = _raise_uninitialized_error
        self.__dict__["_GetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_SetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_GetTargetObject"] = _raise_uninitialized_error
        self.__dict__["_GetTimeDelayConvergenceTolerance"] = _raise_uninitialized_error
        self.__dict__["_SetTimeDelayConvergenceTolerance"] = _raise_uninitialized_error
        self.__dict__["_GetUseLightTimeDelay"] = _raise_uninitialized_error
        self.__dict__["_SetUseLightTimeDelay"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAAccessStoppingCondition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAAccessStoppingCondition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAStoppingConditionComponent._private_init(self, pUnk)
        IID_IVAAccessStoppingCondition = agcom.GUID(IVAAccessStoppingCondition._uuid)
        vtable_offset_local = IVAAccessStoppingCondition._vtable_offset - 1
        self.__dict__["_GetTimeConvergence"] = IAGFUNCTYPE(pUnk, IID_IVAAccessStoppingCondition, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTimeConvergence"] = IAGFUNCTYPE(pUnk, IID_IVAAccessStoppingCondition, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetRepeatCount"] = IAGFUNCTYPE(pUnk, IID_IVAAccessStoppingCondition, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRepeatCount"] = IAGFUNCTYPE(pUnk, IID_IVAAccessStoppingCondition, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetInherited"] = IAGFUNCTYPE(pUnk, IID_IVAAccessStoppingCondition, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetInherited"] = IAGFUNCTYPE(pUnk, IID_IVAAccessStoppingCondition, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetMaxTripTimes"] = IAGFUNCTYPE(pUnk, IID_IVAAccessStoppingCondition, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaxTripTimes"] = IAGFUNCTYPE(pUnk, IID_IVAAccessStoppingCondition, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetSequence"] = IAGFUNCTYPE(pUnk, IID_IVAAccessStoppingCondition, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_SetSequence"] = IAGFUNCTYPE(pUnk, IID_IVAAccessStoppingCondition, vtable_offset_local+10, agcom.BSTR)
        self.__dict__["_GetConstraints"] = IAGFUNCTYPE(pUnk, IID_IVAAccessStoppingCondition, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_GetCriterion"] = IAGFUNCTYPE(pUnk, IID_IVAAccessStoppingCondition, vtable_offset_local+12, POINTER(agcom.LONG))
        self.__dict__["_SetCriterion"] = IAGFUNCTYPE(pUnk, IID_IVAAccessStoppingCondition, vtable_offset_local+13, agcom.LONG)
        self.__dict__["_GetBeforeConditions"] = IAGFUNCTYPE(pUnk, IID_IVAAccessStoppingCondition, vtable_offset_local+14, POINTER(agcom.PVOID))
        self.__dict__["_GetAberrationType"] = IAGFUNCTYPE(pUnk, IID_IVAAccessStoppingCondition, vtable_offset_local+15, POINTER(agcom.LONG))
        self.__dict__["_SetAberrationType"] = IAGFUNCTYPE(pUnk, IID_IVAAccessStoppingCondition, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_SetBaseSelection"] = IAGFUNCTYPE(pUnk, IID_IVAAccessStoppingCondition, vtable_offset_local+17, agcom.LONG)
        self.__dict__["_GetBaseSelectionType"] = IAGFUNCTYPE(pUnk, IID_IVAAccessStoppingCondition, vtable_offset_local+18, POINTER(agcom.LONG))
        self.__dict__["_GetBaseSelection"] = IAGFUNCTYPE(pUnk, IID_IVAAccessStoppingCondition, vtable_offset_local+19, POINTER(agcom.PVOID))
        self.__dict__["_GetClockHost"] = IAGFUNCTYPE(pUnk, IID_IVAAccessStoppingCondition, vtable_offset_local+20, POINTER(agcom.LONG))
        self.__dict__["_SetClockHost"] = IAGFUNCTYPE(pUnk, IID_IVAAccessStoppingCondition, vtable_offset_local+21, agcom.LONG)
        self.__dict__["_GetSignalSense"] = IAGFUNCTYPE(pUnk, IID_IVAAccessStoppingCondition, vtable_offset_local+22, POINTER(agcom.LONG))
        self.__dict__["_SetSignalSense"] = IAGFUNCTYPE(pUnk, IID_IVAAccessStoppingCondition, vtable_offset_local+23, agcom.LONG)
        self.__dict__["_GetTargetObject"] = IAGFUNCTYPE(pUnk, IID_IVAAccessStoppingCondition, vtable_offset_local+24, POINTER(agcom.PVOID))
        self.__dict__["_GetTimeDelayConvergenceTolerance"] = IAGFUNCTYPE(pUnk, IID_IVAAccessStoppingCondition, vtable_offset_local+25, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTimeDelayConvergenceTolerance"] = IAGFUNCTYPE(pUnk, IID_IVAAccessStoppingCondition, vtable_offset_local+26, agcom.DOUBLE)
        self.__dict__["_GetUseLightTimeDelay"] = IAGFUNCTYPE(pUnk, IID_IVAAccessStoppingCondition, vtable_offset_local+27, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseLightTimeDelay"] = IAGFUNCTYPE(pUnk, IID_IVAAccessStoppingCondition, vtable_offset_local+28, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAAccessStoppingCondition.__dict__ and type(IVAAccessStoppingCondition.__dict__[attrname]) == property:
            return IVAAccessStoppingCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAStoppingConditionComponent.__setattr__(self, attrname, value)
    
    @property
    def TimeConvergence(self) -> float:
        """Sets the time tolerance that is used by the access algorithms to determine the start times and stop times of access intervals. Uses Time dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeConvergence"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TimeConvergence.setter
    def TimeConvergence(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTimeConvergence"](arg_newVal.COM_val))

    @property
    def RepeatCount(self) -> float:
        """The number of times the condition must be satisfied before the propagation ends or moves on to the designated automatic sequence. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRepeatCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RepeatCount.setter
    def RepeatCount(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetRepeatCount"](arg_newVal.COM_val))

    @property
    def Inherited(self) -> bool:
        """Condition Inherited by Automatic Sequences - if true, the stopping condition will be applied to any automatic sequences activated within the same segment."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetInherited"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Inherited.setter
    def Inherited(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetInherited"](arg_newVal.COM_val))

    @property
    def MaxTripTimes(self) -> float:
        """The maximum number of times that the stopping condition will be applied - and any resulting automatic sequences executed. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxTripTimes"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxTripTimes.setter
    def MaxTripTimes(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxTripTimes"](arg_inVal.COM_val))

    @property
    def Sequence(self) -> str:
        """The automatic sequence to trigger if the highlighted stopping condition is satisfied."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSequence"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Sequence.setter
    def Sequence(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetSequence"](arg_newVal.COM_val))

    @property
    def Constraints(self) -> "IVAConstraintCollection":
        """Further conditions that must be met in order for the stopping condition to be deemed satisfied."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAConstraintCollection:
            agcls.evaluate_hresult(self.__dict__["_GetConstraints"](byref(arg_ppVAConstraintCollection.COM_val)))
            return arg_ppVAConstraintCollection.python_val

    @property
    def Criterion(self) -> "AgEVAAccessCriterion":
        """Specifies the direction from which the stopping condition value must be achieved."""
        with agmarshall.AgEnum_arg(AgEVAAccessCriterion) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCriterion"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Criterion.setter
    def Criterion(self, newVal:"AgEVAAccessCriterion") -> None:
        with agmarshall.AgEnum_arg(AgEVAAccessCriterion, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCriterion"](arg_newVal.COM_val))

    @property
    def BeforeConditions(self) -> "IVAStoppingConditionCollection":
        """A 'before' stopping condition is used to define a stopping condition that depends on two events. Astrogator will ignore a stopping condition until its 'before' conditions are met. Astrogator then interpolates backwards to the normal stopping condition."""
        with agmarshall.AgInterface_out_arg() as arg_ppStoppingConditionCollection:
            agcls.evaluate_hresult(self.__dict__["_GetBeforeConditions"](byref(arg_ppStoppingConditionCollection.COM_val)))
            return arg_ppStoppingConditionCollection.python_val

    @property
    def AberrationType(self) -> "AgEAberrationType":
        """Sets the model of aberration to be used in access computations."""
        with agmarshall.AgEnum_arg(AgEAberrationType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAberrationType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AberrationType.setter
    def AberrationType(self, inVal:"AgEAberrationType") -> None:
        with agmarshall.AgEnum_arg(AgEAberrationType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAberrationType"](arg_inVal.COM_val))

    def SetBaseSelection(self, selection:"AgEVABaseSelection") -> None:
        """BaseSelection"""
        with agmarshall.AgEnum_arg(AgEVABaseSelection, selection) as arg_selection:
            agcls.evaluate_hresult(self.__dict__["_SetBaseSelection"](arg_selection.COM_val))

    @property
    def BaseSelectionType(self) -> "AgEVABaseSelection":
        """The base object for the access calculation."""
        with agmarshall.AgEnum_arg(AgEVABaseSelection) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetBaseSelectionType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def BaseSelection(self) -> "ILinkToObject":
        """Returns the base selection object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetBaseSelection"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ClockHost(self) -> "AgEIvClockHost":
        """Time values are reported with a clock colocated with the clock host object."""
        with agmarshall.AgEnum_arg(AgEIvClockHost) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetClockHost"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ClockHost.setter
    def ClockHost(self, inVal:"AgEIvClockHost") -> None:
        with agmarshall.AgEnum_arg(AgEIvClockHost, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetClockHost"](arg_inVal.COM_val))

    @property
    def SignalSense(self) -> "AgEIvTimeSense":
        """Sets the direction of the signal."""
        with agmarshall.AgEnum_arg(AgEIvTimeSense) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalSense"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SignalSense.setter
    def SignalSense(self, inVal:"AgEIvTimeSense") -> None:
        with agmarshall.AgEnum_arg(AgEIvTimeSense, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSignalSense"](arg_inVal.COM_val))

    @property
    def TargetObject(self) -> "ILinkToObject":
        """The target object for the access calculation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetObject"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def TimeDelayConvergenceTolerance(self) -> float:
        """The tolerance used when iterating to determine the light time delay. The iteration stops when the improvement in the value is less than this tolerance. Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeDelayConvergenceTolerance"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TimeDelayConvergenceTolerance.setter
    def TimeDelayConvergenceTolerance(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetTimeDelayConvergenceTolerance"](arg_inVal.COM_val))

    @property
    def UseLightTimeDelay(self) -> bool:
        """Whether to consider light time delay in access computations."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseLightTimeDelay"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseLightTimeDelay.setter
    def UseLightTimeDelay(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseLightTimeDelay"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2A2D2F12-9F9B-43F6-B6B0-00088C006504}", IVAAccessStoppingCondition)
agcls.AgTypeNameMap["IVAAccessStoppingCondition"] = IVAAccessStoppingCondition

class IVAMCSPropagate(object):
    """Properties for a Propagate segment."""
    _uuid = "{41E66E06-FD6A-4523-8956-B0DF0BE5479E}"
    _num_methods = 21
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPropagatorName"] = _raise_uninitialized_error
        self.__dict__["_SetPropagatorName"] = _raise_uninitialized_error
        self.__dict__["_GetStoppingConditions"] = _raise_uninitialized_error
        self.__dict__["_GetMinPropagationTime"] = _raise_uninitialized_error
        self.__dict__["_SetMinPropagationTime"] = _raise_uninitialized_error
        self.__dict__["_GetMaxPropagationTime"] = _raise_uninitialized_error
        self.__dict__["_SetMaxPropagationTime"] = _raise_uninitialized_error
        self.__dict__["_GetEnableMaxPropagationTime"] = _raise_uninitialized_error
        self.__dict__["_SetEnableMaxPropagationTime"] = _raise_uninitialized_error
        self.__dict__["_GetEnableWarningMessage"] = _raise_uninitialized_error
        self.__dict__["_SetEnableWarningMessage"] = _raise_uninitialized_error
        self.__dict__["_EnableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_DisableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_IsControlParameterEnabled"] = _raise_uninitialized_error
        self.__dict__["_GetControlParametersAvailable"] = _raise_uninitialized_error
        self.__dict__["_GetOverrideMaxPropagationTime"] = _raise_uninitialized_error
        self.__dict__["_SetOverrideMaxPropagationTime"] = _raise_uninitialized_error
        self.__dict__["_GetShouldStopForInitiallySurpassedEpochStoppingConditions"] = _raise_uninitialized_error
        self.__dict__["_SetShouldStopForInitiallySurpassedEpochStoppingConditions"] = _raise_uninitialized_error
        self.__dict__["_GetShouldReinitializeSTMAtStartOfSegmentPropagation"] = _raise_uninitialized_error
        self.__dict__["_SetShouldReinitializeSTMAtStartOfSegmentPropagation"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAMCSPropagate._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAMCSPropagate from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAMCSPropagate = agcom.GUID(IVAMCSPropagate._uuid)
        vtable_offset_local = IVAMCSPropagate._vtable_offset - 1
        self.__dict__["_GetPropagatorName"] = IAGFUNCTYPE(pUnk, IID_IVAMCSPropagate, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetPropagatorName"] = IAGFUNCTYPE(pUnk, IID_IVAMCSPropagate, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetStoppingConditions"] = IAGFUNCTYPE(pUnk, IID_IVAMCSPropagate, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetMinPropagationTime"] = IAGFUNCTYPE(pUnk, IID_IVAMCSPropagate, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMinPropagationTime"] = IAGFUNCTYPE(pUnk, IID_IVAMCSPropagate, vtable_offset_local+5, agcom.DOUBLE)
        self.__dict__["_GetMaxPropagationTime"] = IAGFUNCTYPE(pUnk, IID_IVAMCSPropagate, vtable_offset_local+6, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaxPropagationTime"] = IAGFUNCTYPE(pUnk, IID_IVAMCSPropagate, vtable_offset_local+7, agcom.DOUBLE)
        self.__dict__["_GetEnableMaxPropagationTime"] = IAGFUNCTYPE(pUnk, IID_IVAMCSPropagate, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnableMaxPropagationTime"] = IAGFUNCTYPE(pUnk, IID_IVAMCSPropagate, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_GetEnableWarningMessage"] = IAGFUNCTYPE(pUnk, IID_IVAMCSPropagate, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnableWarningMessage"] = IAGFUNCTYPE(pUnk, IID_IVAMCSPropagate, vtable_offset_local+11, agcom.VARIANT_BOOL)
        self.__dict__["_EnableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAMCSPropagate, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_DisableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAMCSPropagate, vtable_offset_local+13, agcom.LONG)
        self.__dict__["_IsControlParameterEnabled"] = IAGFUNCTYPE(pUnk, IID_IVAMCSPropagate, vtable_offset_local+14, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetControlParametersAvailable"] = IAGFUNCTYPE(pUnk, IID_IVAMCSPropagate, vtable_offset_local+15, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetOverrideMaxPropagationTime"] = IAGFUNCTYPE(pUnk, IID_IVAMCSPropagate, vtable_offset_local+16, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetOverrideMaxPropagationTime"] = IAGFUNCTYPE(pUnk, IID_IVAMCSPropagate, vtable_offset_local+17, agcom.VARIANT_BOOL)
        self.__dict__["_GetShouldStopForInitiallySurpassedEpochStoppingConditions"] = IAGFUNCTYPE(pUnk, IID_IVAMCSPropagate, vtable_offset_local+18, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetShouldStopForInitiallySurpassedEpochStoppingConditions"] = IAGFUNCTYPE(pUnk, IID_IVAMCSPropagate, vtable_offset_local+19, agcom.VARIANT_BOOL)
        self.__dict__["_GetShouldReinitializeSTMAtStartOfSegmentPropagation"] = IAGFUNCTYPE(pUnk, IID_IVAMCSPropagate, vtable_offset_local+20, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetShouldReinitializeSTMAtStartOfSegmentPropagation"] = IAGFUNCTYPE(pUnk, IID_IVAMCSPropagate, vtable_offset_local+21, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAMCSPropagate.__dict__ and type(IVAMCSPropagate.__dict__[attrname]) == property:
            return IVAMCSPropagate.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAMCSPropagate.")
    
    @property
    def PropagatorName(self) -> str:
        """The propagator."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPropagatorName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @PropagatorName.setter
    def PropagatorName(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetPropagatorName"](arg_newVal.COM_val))

    @property
    def StoppingConditions(self) -> "IVAStoppingConditionCollection":
        """The list of stopping conditions defined for the segment."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAStoppingConditionCollection:
            agcls.evaluate_hresult(self.__dict__["_GetStoppingConditions"](byref(arg_ppVAStoppingConditionCollection.COM_val)))
            return arg_ppVAStoppingConditionCollection.python_val

    @property
    def MinPropagationTime(self) -> float:
        """The minimum time that must elapse from the beginning of the segment until Astrogator will begin checking stopping conditions for satisfaction. Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinPropagationTime"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MinPropagationTime.setter
    def MinPropagationTime(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetMinPropagationTime"](arg_newVal.COM_val))

    @property
    def MaxPropagationTime(self) -> float:
        """The maximum propagation time, after which the segment will end regardless of whether the stopping conditions have been satisfied. Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxPropagationTime"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxPropagationTime.setter
    def MaxPropagationTime(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxPropagationTime"](arg_newVal.COM_val))

    @property
    def EnableMaxPropagationTime(self) -> bool:
        """If true, the maximum propagation time is enforced."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnableMaxPropagationTime"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EnableMaxPropagationTime.setter
    def EnableMaxPropagationTime(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnableMaxPropagationTime"](arg_newVal.COM_val))

    @property
    def EnableWarningMessage(self) -> bool:
        """If true, Astrogator will issue a warning message if propagation is stopped by the Maximum Propagation Time parameter."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnableWarningMessage"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EnableWarningMessage.setter
    def EnableWarningMessage(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnableWarningMessage"](arg_newVal.COM_val))

    def EnableControlParameter(self, param:"AgEVAControlAdvanced") -> None:
        """Enables or disables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlAdvanced, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_EnableControlParameter"](arg_param.COM_val))

    def DisableControlParameter(self, param:"AgEVAControlAdvanced") -> None:
        """Disables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlAdvanced, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_DisableControlParameter"](arg_param.COM_val))

    def IsControlParameterEnabled(self, param:"AgEVAControlAdvanced") -> bool:
        """Sees if the specified control is enabled."""
        with agmarshall.AgEnum_arg(AgEVAControlAdvanced, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_IsControlParameterEnabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ControlParametersAvailable(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetControlParametersAvailable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def OverrideMaxPropagationTime(self) -> bool:
        """Override Maximum Propagation Time - if there is a duration or epoch stopping condition that occurs after the maximum propagation time, ignore the maximum propagation time."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetOverrideMaxPropagationTime"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @OverrideMaxPropagationTime.setter
    def OverrideMaxPropagationTime(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetOverrideMaxPropagationTime"](arg_newVal.COM_val))

    @property
    def ShouldStopForInitiallySurpassedEpochStoppingConditions(self) -> bool:
        """Stop immediately if propagation begins beyond an active epoch stopping condition."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetShouldStopForInitiallySurpassedEpochStoppingConditions"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ShouldStopForInitiallySurpassedEpochStoppingConditions.setter
    def ShouldStopForInitiallySurpassedEpochStoppingConditions(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetShouldStopForInitiallySurpassedEpochStoppingConditions"](arg_newVal.COM_val))

    @property
    def ShouldReinitializeSTMAtStartOfSegmentPropagation(self) -> bool:
        """If this segment is propagating the state transition matrix, reset it to the identity matrix at the start of the segment."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetShouldReinitializeSTMAtStartOfSegmentPropagation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ShouldReinitializeSTMAtStartOfSegmentPropagation.setter
    def ShouldReinitializeSTMAtStartOfSegmentPropagation(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetShouldReinitializeSTMAtStartOfSegmentPropagation"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{41E66E06-FD6A-4523-8956-B0DF0BE5479E}", IVAMCSPropagate)
agcls.AgTypeNameMap["IVAMCSPropagate"] = IVAMCSPropagate

class IVAMCSSequence(object):
    """Properties for a Sequence segment."""
    _uuid = "{0FE48F27-40D3-4D78-9B87-6539D1977696}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetRepeatCount"] = _raise_uninitialized_error
        self.__dict__["_SetRepeatCount"] = _raise_uninitialized_error
        self.__dict__["_GetGenerateEphemeris"] = _raise_uninitialized_error
        self.__dict__["_SetGenerateEphemeris"] = _raise_uninitialized_error
        self.__dict__["_GetSegments"] = _raise_uninitialized_error
        self.__dict__["_GetSequenceStateToPass"] = _raise_uninitialized_error
        self.__dict__["_SetSequenceStateToPass"] = _raise_uninitialized_error
        self.__dict__["_GetScriptingTool"] = _raise_uninitialized_error
        self.__dict__["_ApplyScript"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAMCSSequence._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAMCSSequence from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAMCSSequence = agcom.GUID(IVAMCSSequence._uuid)
        vtable_offset_local = IVAMCSSequence._vtable_offset - 1
        self.__dict__["_GetRepeatCount"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSequence, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetRepeatCount"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSequence, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetGenerateEphemeris"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSequence, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetGenerateEphemeris"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSequence, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_GetSegments"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSequence, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_GetSequenceStateToPass"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSequence, vtable_offset_local+6, POINTER(agcom.LONG))
        self.__dict__["_SetSequenceStateToPass"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSequence, vtable_offset_local+7, agcom.LONG)
        self.__dict__["_GetScriptingTool"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSequence, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_ApplyScript"] = IAGFUNCTYPE(pUnk, IID_IVAMCSSequence, vtable_offset_local+9, )
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAMCSSequence.__dict__ and type(IVAMCSSequence.__dict__[attrname]) == property:
            return IVAMCSSequence.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAMCSSequence.")
    
    @property
    def RepeatCount(self) -> int:
        """The number of times that the sequence will be executed. A sequence that is repeated is executed immediately subsequent to the previous execution of the sequence. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRepeatCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RepeatCount.setter
    def RepeatCount(self, newVal:int) -> None:
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetRepeatCount"](arg_newVal.COM_val))

    @property
    def GenerateEphemeris(self) -> bool:
        """If true, the sequence generates ephemeris and displays it in the 2D and 3D Graphics windows."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetGenerateEphemeris"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @GenerateEphemeris.setter
    def GenerateEphemeris(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetGenerateEphemeris"](arg_newVal.COM_val))

    @property
    def Segments(self) -> "IVAMCSSegmentCollection":
        """The list of segments defined for the sequence."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAMCSSegmentCollection:
            agcls.evaluate_hresult(self.__dict__["_GetSegments"](byref(arg_ppVAMCSSegmentCollection.COM_val)))
            return arg_ppVAMCSSegmentCollection.python_val

    @property
    def SequenceStateToPass(self) -> "AgEVASequenceStateToPass":
        """State To Pass To Next Segment - the state of the sequence to pass."""
        with agmarshall.AgEnum_arg(AgEVASequenceStateToPass) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSequenceStateToPass"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SequenceStateToPass.setter
    def SequenceStateToPass(self, inVal:"AgEVASequenceStateToPass") -> None:
        with agmarshall.AgEnum_arg(AgEVASequenceStateToPass, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSequenceStateToPass"](arg_inVal.COM_val))

    @property
    def ScriptingTool(self) -> "IVAScriptingTool":
        """Returns the Scripting tool for the sequence."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScriptingTool"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def ApplyScript(self) -> None:
        """Apply the script."""
        agcls.evaluate_hresult(self.__dict__["_ApplyScript"]())


agcls.AgClassCatalog.add_catalog_entry("{0FE48F27-40D3-4D78-9B87-6539D1977696}", IVAMCSSequence)
agcls.AgTypeNameMap["IVAMCSSequence"] = IVAMCSSequence

class IVAMCSBackwardSequence(IVAMCSSequence):
    """Properties for a Backward Sequence segment."""
    _uuid = "{F9AF6E49-B8E0-4E5E-91CC-04E622CBC9EF}"
    _num_methods = 0
    _vtable_offset = IVAMCSSequence._vtable_offset + IVAMCSSequence._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAMCSBackwardSequence._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAMCSBackwardSequence from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAMCSSequence._private_init(self, pUnk)
        IID_IVAMCSBackwardSequence = agcom.GUID(IVAMCSBackwardSequence._uuid)
        vtable_offset_local = IVAMCSBackwardSequence._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAMCSBackwardSequence.__dict__ and type(IVAMCSBackwardSequence.__dict__[attrname]) == property:
            return IVAMCSBackwardSequence.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAMCSSequence.__setattr__(self, attrname, value)
    

agcls.AgClassCatalog.add_catalog_entry("{F9AF6E49-B8E0-4E5E-91CC-04E622CBC9EF}", IVAMCSBackwardSequence)
agcls.AgTypeNameMap["IVAMCSBackwardSequence"] = IVAMCSBackwardSequence

class IVAMCSLaunch(object):
    """Properties for a Launch segment."""
    _uuid = "{C342C18C-80EF-4E1F-8363-90181B755E66}"
    _num_methods = 32
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetStepSize"] = _raise_uninitialized_error
        self.__dict__["_SetStepSize"] = _raise_uninitialized_error
        self.__dict__["_GetPreLaunchTime"] = _raise_uninitialized_error
        self.__dict__["_SetPreLaunchTime"] = _raise_uninitialized_error
        self.__dict__["_GetEpoch"] = _raise_uninitialized_error
        self.__dict__["_SetEpoch"] = _raise_uninitialized_error
        self.__dict__["_EnableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_DisableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_IsControlParameterEnabled"] = _raise_uninitialized_error
        self.__dict__["_GetControlParametersAvailable"] = _raise_uninitialized_error
        self.__dict__["_GetInitialAcceleration"] = _raise_uninitialized_error
        self.__dict__["_SetInitialAcceleration"] = _raise_uninitialized_error
        self.__dict__["_GetSpacecraftParameters"] = _raise_uninitialized_error
        self.__dict__["_GetFuelTank"] = _raise_uninitialized_error
        self.__dict__["_GetDisplaySystemType"] = _raise_uninitialized_error
        self.__dict__["_SetDisplaySystemType"] = _raise_uninitialized_error
        self.__dict__["_GetDisplaySystem"] = _raise_uninitialized_error
        self.__dict__["_GetAscentType"] = _raise_uninitialized_error
        self.__dict__["_SetAscentType"] = _raise_uninitialized_error
        self.__dict__["_GetTimeOfFlight"] = _raise_uninitialized_error
        self.__dict__["_SetTimeOfFlight"] = _raise_uninitialized_error
        self.__dict__["_GetBurnoutType"] = _raise_uninitialized_error
        self.__dict__["_SetBurnoutType"] = _raise_uninitialized_error
        self.__dict__["_GetBurnout"] = _raise_uninitialized_error
        self.__dict__["_GetBurnoutVelocity"] = _raise_uninitialized_error
        self.__dict__["_GetUsePreviousSegmentState"] = _raise_uninitialized_error
        self.__dict__["_SetUsePreviousSegmentState"] = _raise_uninitialized_error
        self.__dict__["_GetSetMetEpoch"] = _raise_uninitialized_error
        self.__dict__["_SetSetMetEpoch"] = _raise_uninitialized_error
        self.__dict__["_GetUserVariables"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAMCSLaunch._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAMCSLaunch from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAMCSLaunch = agcom.GUID(IVAMCSLaunch._uuid)
        vtable_offset_local = IVAMCSLaunch._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAMCSLaunch, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAMCSLaunch, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetStepSize"] = IAGFUNCTYPE(pUnk, IID_IVAMCSLaunch, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStepSize"] = IAGFUNCTYPE(pUnk, IID_IVAMCSLaunch, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetPreLaunchTime"] = IAGFUNCTYPE(pUnk, IID_IVAMCSLaunch, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetPreLaunchTime"] = IAGFUNCTYPE(pUnk, IID_IVAMCSLaunch, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetEpoch"] = IAGFUNCTYPE(pUnk, IID_IVAMCSLaunch, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_SetEpoch"] = IAGFUNCTYPE(pUnk, IID_IVAMCSLaunch, vtable_offset_local+8, agcom.VARIANT)
        self.__dict__["_EnableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAMCSLaunch, vtable_offset_local+9, agcom.LONG)
        self.__dict__["_DisableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAMCSLaunch, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_IsControlParameterEnabled"] = IAGFUNCTYPE(pUnk, IID_IVAMCSLaunch, vtable_offset_local+11, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetControlParametersAvailable"] = IAGFUNCTYPE(pUnk, IID_IVAMCSLaunch, vtable_offset_local+12, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetInitialAcceleration"] = IAGFUNCTYPE(pUnk, IID_IVAMCSLaunch, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetInitialAcceleration"] = IAGFUNCTYPE(pUnk, IID_IVAMCSLaunch, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetSpacecraftParameters"] = IAGFUNCTYPE(pUnk, IID_IVAMCSLaunch, vtable_offset_local+15, POINTER(agcom.PVOID))
        self.__dict__["_GetFuelTank"] = IAGFUNCTYPE(pUnk, IID_IVAMCSLaunch, vtable_offset_local+16, POINTER(agcom.PVOID))
        self.__dict__["_GetDisplaySystemType"] = IAGFUNCTYPE(pUnk, IID_IVAMCSLaunch, vtable_offset_local+17, POINTER(agcom.LONG))
        self.__dict__["_SetDisplaySystemType"] = IAGFUNCTYPE(pUnk, IID_IVAMCSLaunch, vtable_offset_local+18, agcom.LONG)
        self.__dict__["_GetDisplaySystem"] = IAGFUNCTYPE(pUnk, IID_IVAMCSLaunch, vtable_offset_local+19, POINTER(agcom.PVOID))
        self.__dict__["_GetAscentType"] = IAGFUNCTYPE(pUnk, IID_IVAMCSLaunch, vtable_offset_local+20, POINTER(agcom.LONG))
        self.__dict__["_SetAscentType"] = IAGFUNCTYPE(pUnk, IID_IVAMCSLaunch, vtable_offset_local+21, agcom.LONG)
        self.__dict__["_GetTimeOfFlight"] = IAGFUNCTYPE(pUnk, IID_IVAMCSLaunch, vtable_offset_local+22, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTimeOfFlight"] = IAGFUNCTYPE(pUnk, IID_IVAMCSLaunch, vtable_offset_local+23, agcom.DOUBLE)
        self.__dict__["_GetBurnoutType"] = IAGFUNCTYPE(pUnk, IID_IVAMCSLaunch, vtable_offset_local+24, POINTER(agcom.LONG))
        self.__dict__["_SetBurnoutType"] = IAGFUNCTYPE(pUnk, IID_IVAMCSLaunch, vtable_offset_local+25, agcom.LONG)
        self.__dict__["_GetBurnout"] = IAGFUNCTYPE(pUnk, IID_IVAMCSLaunch, vtable_offset_local+26, POINTER(agcom.PVOID))
        self.__dict__["_GetBurnoutVelocity"] = IAGFUNCTYPE(pUnk, IID_IVAMCSLaunch, vtable_offset_local+27, POINTER(agcom.PVOID))
        self.__dict__["_GetUsePreviousSegmentState"] = IAGFUNCTYPE(pUnk, IID_IVAMCSLaunch, vtable_offset_local+28, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUsePreviousSegmentState"] = IAGFUNCTYPE(pUnk, IID_IVAMCSLaunch, vtable_offset_local+29, agcom.VARIANT_BOOL)
        self.__dict__["_GetSetMetEpoch"] = IAGFUNCTYPE(pUnk, IID_IVAMCSLaunch, vtable_offset_local+30, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetSetMetEpoch"] = IAGFUNCTYPE(pUnk, IID_IVAMCSLaunch, vtable_offset_local+31, agcom.VARIANT_BOOL)
        self.__dict__["_GetUserVariables"] = IAGFUNCTYPE(pUnk, IID_IVAMCSLaunch, vtable_offset_local+32, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAMCSLaunch.__dict__ and type(IVAMCSLaunch.__dict__[attrname]) == property:
            return IVAMCSLaunch.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAMCSLaunch.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_newVal.COM_val))

    @property
    def StepSize(self) -> float:
        """The time interval between calculated ephemeris output points. Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetStepSize"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @StepSize.setter
    def StepSize(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetStepSize"](arg_newVal.COM_val))

    @property
    def PreLaunchTime(self) -> float:
        """The amount of time before the spacecraft's launch that it will be created in the scenario. The vehicle will remain at the launch position until beginning of the launch epoch. Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPreLaunchTime"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @PreLaunchTime.setter
    def PreLaunchTime(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetPreLaunchTime"](arg_newVal.COM_val))

    @property
    def Epoch(self) -> typing.Any:
        """The date and time of the launch. Uses DateFormat Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEpoch"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Epoch.setter
    def Epoch(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEpoch"](arg_newVal.COM_val))

    def EnableControlParameter(self, param:"AgEVAControlLaunch") -> None:
        """Enables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlLaunch, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_EnableControlParameter"](arg_param.COM_val))

    def DisableControlParameter(self, param:"AgEVAControlLaunch") -> None:
        """Disables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlLaunch, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_DisableControlParameter"](arg_param.COM_val))

    def IsControlParameterEnabled(self, param:"AgEVAControlLaunch") -> bool:
        """Sees if the specified control is enabled."""
        with agmarshall.AgEnum_arg(AgEVAControlLaunch, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_IsControlParameterEnabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ControlParametersAvailable(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetControlParametersAvailable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def InitialAcceleration(self) -> float:
        """The initial acceleration, for the Quartic Motion Ascent Type. Uses Acceleration Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetInitialAcceleration"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @InitialAcceleration.setter
    def InitialAcceleration(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetInitialAcceleration"](arg_newVal.COM_val))

    @property
    def SpacecraftParameters(self) -> "IVASpacecraftParameters":
        """Satellite Properties - the spacecraft's physical properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppVASpacecraftParameters:
            agcls.evaluate_hresult(self.__dict__["_GetSpacecraftParameters"](byref(arg_ppVASpacecraftParameters.COM_val)))
            return arg_ppVASpacecraftParameters.python_val

    @property
    def FuelTank(self) -> "IVAFuelTank":
        """The spacecraft's fuel tank properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAFuelTank:
            agcls.evaluate_hresult(self.__dict__["_GetFuelTank"](byref(arg_ppVAFuelTank.COM_val)))
            return arg_ppVAFuelTank.python_val

    @property
    def DisplaySystemType(self) -> "AgEVALaunchDisplaySystem":
        """The launch coordinate type."""
        with agmarshall.AgEnum_arg(AgEVALaunchDisplaySystem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDisplaySystemType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def SetDisplaySystemType(self, displaySystemType:"AgEVALaunchDisplaySystem") -> None:
        """Sets the display system type."""
        with agmarshall.AgEnum_arg(AgEVALaunchDisplaySystem, displaySystemType) as arg_displaySystemType:
            agcls.evaluate_hresult(self.__dict__["_SetDisplaySystemType"](arg_displaySystemType.COM_val))

    @property
    def DisplaySystem(self) -> "IVADisplaySystem":
        """Gets the current Display System."""
        with agmarshall.AgInterface_out_arg() as arg_ppVADisplaySystem:
            agcls.evaluate_hresult(self.__dict__["_GetDisplaySystem"](byref(arg_ppVADisplaySystem.COM_val)))
            return arg_ppVADisplaySystem.python_val

    @property
    def AscentType(self) -> "AgEVAAscentType":
        """The order of the spline used to generate the motion along the ellipse."""
        with agmarshall.AgEnum_arg(AgEVAAscentType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAscentType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AscentType.setter
    def AscentType(self, newVal:"AgEVAAscentType") -> None:
        with agmarshall.AgEnum_arg(AgEVAAscentType, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetAscentType"](arg_newVal.COM_val))

    @property
    def TimeOfFlight(self) -> float:
        """The time of flight (the time from launch to burnout). Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeOfFlight"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TimeOfFlight.setter
    def TimeOfFlight(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTimeOfFlight"](arg_newVal.COM_val))

    @property
    def BurnoutType(self) -> "AgEVABurnoutType":
        """The burnout type."""
        with agmarshall.AgEnum_arg(AgEVABurnoutType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetBurnoutType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def SetBurnoutType(self, burnoutType:"AgEVABurnoutType") -> None:
        """Sets the burnout type."""
        with agmarshall.AgEnum_arg(AgEVABurnoutType, burnoutType) as arg_burnoutType:
            agcls.evaluate_hresult(self.__dict__["_SetBurnoutType"](arg_burnoutType.COM_val))

    @property
    def Burnout(self) -> "IVABurnout":
        """The burnout point definition."""
        with agmarshall.AgInterface_out_arg() as arg_ppVABurnout:
            agcls.evaluate_hresult(self.__dict__["_GetBurnout"](byref(arg_ppVABurnout.COM_val)))
            return arg_ppVABurnout.python_val

    @property
    def BurnoutVelocity(self) -> "IVABurnoutVelocity":
        """The burnout velocity definition."""
        with agmarshall.AgInterface_out_arg() as arg_ppVABurnoutVelocity:
            agcls.evaluate_hresult(self.__dict__["_GetBurnoutVelocity"](byref(arg_ppVABurnoutVelocity.COM_val)))
            return arg_ppVABurnoutVelocity.python_val

    @property
    def UsePreviousSegmentState(self) -> bool:
        """If true, the previous segment state is used to define the launch location parameters."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUsePreviousSegmentState"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UsePreviousSegmentState.setter
    def UsePreviousSegmentState(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetUsePreviousSegmentState"](arg_newVal.COM_val))

    @property
    def SetMetEpoch(self) -> bool:
        """If true, the Mission Elapsed Time epoch will be set to the launch epoch."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSetMetEpoch"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SetMetEpoch.setter
    def SetMetEpoch(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetSetMetEpoch"](arg_newVal.COM_val))

    @property
    def UserVariables(self) -> "IVAUserVariableCollection":
        """Interface used to modify user variables for the launch segment."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUserVariables"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{C342C18C-80EF-4E1F-8363-90181B755E66}", IVAMCSLaunch)
agcls.AgTypeNameMap["IVAMCSLaunch"] = IVAMCSLaunch

class IVADisplaySystemGeodetic(IVADisplaySystem):
    """Properties for a geodetic launch coordinate system."""
    _uuid = "{3A9597F2-E224-44C9-801F-60CA7A1CB2A1}"
    _num_methods = 6
    _vtable_offset = IVADisplaySystem._vtable_offset + IVADisplaySystem._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetLatitude"] = _raise_uninitialized_error
        self.__dict__["_SetLatitude"] = _raise_uninitialized_error
        self.__dict__["_GetLongitude"] = _raise_uninitialized_error
        self.__dict__["_SetLongitude"] = _raise_uninitialized_error
        self.__dict__["_GetAltitude"] = _raise_uninitialized_error
        self.__dict__["_SetAltitude"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVADisplaySystemGeodetic._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVADisplaySystemGeodetic from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVADisplaySystem._private_init(self, pUnk)
        IID_IVADisplaySystemGeodetic = agcom.GUID(IVADisplaySystemGeodetic._uuid)
        vtable_offset_local = IVADisplaySystemGeodetic._vtable_offset - 1
        self.__dict__["_GetLatitude"] = IAGFUNCTYPE(pUnk, IID_IVADisplaySystemGeodetic, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_SetLatitude"] = IAGFUNCTYPE(pUnk, IID_IVADisplaySystemGeodetic, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_GetLongitude"] = IAGFUNCTYPE(pUnk, IID_IVADisplaySystemGeodetic, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_SetLongitude"] = IAGFUNCTYPE(pUnk, IID_IVADisplaySystemGeodetic, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_GetAltitude"] = IAGFUNCTYPE(pUnk, IID_IVADisplaySystemGeodetic, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAltitude"] = IAGFUNCTYPE(pUnk, IID_IVADisplaySystemGeodetic, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVADisplaySystemGeodetic.__dict__ and type(IVADisplaySystemGeodetic.__dict__[attrname]) == property:
            return IVADisplaySystemGeodetic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVADisplaySystem.__setattr__(self, attrname, value)
    
    @property
    def Latitude(self) -> typing.Any:
        """The latitude of the launch location. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLatitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Latitude.setter
    def Latitude(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetLatitude"](arg_newVal.COM_val))

    @property
    def Longitude(self) -> typing.Any:
        """The longitude of the launch location. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLongitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Longitude.setter
    def Longitude(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetLongitude"](arg_newVal.COM_val))

    @property
    def Altitude(self) -> float:
        """The altitude of the launch location. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAltitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Altitude.setter
    def Altitude(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetAltitude"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3A9597F2-E224-44C9-801F-60CA7A1CB2A1}", IVADisplaySystemGeodetic)
agcls.AgTypeNameMap["IVADisplaySystemGeodetic"] = IVADisplaySystemGeodetic

class IVADisplaySystemGeocentric(IVADisplaySystem):
    """Properties for a geocentric launch coordinate system."""
    _uuid = "{FD9BAAFA-0CDC-481C-A76C-9F25698C468A}"
    _num_methods = 6
    _vtable_offset = IVADisplaySystem._vtable_offset + IVADisplaySystem._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetLatitude"] = _raise_uninitialized_error
        self.__dict__["_SetLatitude"] = _raise_uninitialized_error
        self.__dict__["_GetLongitude"] = _raise_uninitialized_error
        self.__dict__["_SetLongitude"] = _raise_uninitialized_error
        self.__dict__["_GetRadius"] = _raise_uninitialized_error
        self.__dict__["_SetRadius"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVADisplaySystemGeocentric._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVADisplaySystemGeocentric from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVADisplaySystem._private_init(self, pUnk)
        IID_IVADisplaySystemGeocentric = agcom.GUID(IVADisplaySystemGeocentric._uuid)
        vtable_offset_local = IVADisplaySystemGeocentric._vtable_offset - 1
        self.__dict__["_GetLatitude"] = IAGFUNCTYPE(pUnk, IID_IVADisplaySystemGeocentric, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_SetLatitude"] = IAGFUNCTYPE(pUnk, IID_IVADisplaySystemGeocentric, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_GetLongitude"] = IAGFUNCTYPE(pUnk, IID_IVADisplaySystemGeocentric, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_SetLongitude"] = IAGFUNCTYPE(pUnk, IID_IVADisplaySystemGeocentric, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_GetRadius"] = IAGFUNCTYPE(pUnk, IID_IVADisplaySystemGeocentric, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRadius"] = IAGFUNCTYPE(pUnk, IID_IVADisplaySystemGeocentric, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVADisplaySystemGeocentric.__dict__ and type(IVADisplaySystemGeocentric.__dict__[attrname]) == property:
            return IVADisplaySystemGeocentric.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVADisplaySystem.__setattr__(self, attrname, value)
    
    @property
    def Latitude(self) -> typing.Any:
        """The latitude of the launch location. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLatitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Latitude.setter
    def Latitude(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetLatitude"](arg_newVal.COM_val))

    @property
    def Longitude(self) -> typing.Any:
        """The longitude of the launch location. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLongitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Longitude.setter
    def Longitude(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetLongitude"](arg_newVal.COM_val))

    @property
    def Radius(self) -> float:
        """The radius of the launch location. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRadius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Radius.setter
    def Radius(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetRadius"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{FD9BAAFA-0CDC-481C-A76C-9F25698C468A}", IVADisplaySystemGeocentric)
agcls.AgTypeNameMap["IVADisplaySystemGeocentric"] = IVADisplaySystemGeocentric

class IVABurnoutCBFCartesian(IVABurnout):
    """Properties for a Cartesian CBF burnout state definition."""
    _uuid = "{A45DD94F-A384-4CCB-B803-F29F2DA41A39}"
    _num_methods = 12
    _vtable_offset = IVABurnout._vtable_offset + IVABurnout._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCartesianBurnoutX"] = _raise_uninitialized_error
        self.__dict__["_SetCartesianBurnoutX"] = _raise_uninitialized_error
        self.__dict__["_GetCartesianBurnoutY"] = _raise_uninitialized_error
        self.__dict__["_SetCartesianBurnoutY"] = _raise_uninitialized_error
        self.__dict__["_GetCartesianBurnoutZ"] = _raise_uninitialized_error
        self.__dict__["_SetCartesianBurnoutZ"] = _raise_uninitialized_error
        self.__dict__["_GetCartesianBurnoutVX"] = _raise_uninitialized_error
        self.__dict__["_SetCartesianBurnoutVX"] = _raise_uninitialized_error
        self.__dict__["_GetCartesianBurnoutVY"] = _raise_uninitialized_error
        self.__dict__["_SetCartesianBurnoutVY"] = _raise_uninitialized_error
        self.__dict__["_GetCartesianBurnoutVZ"] = _raise_uninitialized_error
        self.__dict__["_SetCartesianBurnoutVZ"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVABurnoutCBFCartesian._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVABurnoutCBFCartesian from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVABurnout._private_init(self, pUnk)
        IID_IVABurnoutCBFCartesian = agcom.GUID(IVABurnoutCBFCartesian._uuid)
        vtable_offset_local = IVABurnoutCBFCartesian._vtable_offset - 1
        self.__dict__["_GetCartesianBurnoutX"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutCBFCartesian, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetCartesianBurnoutX"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutCBFCartesian, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetCartesianBurnoutY"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutCBFCartesian, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetCartesianBurnoutY"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutCBFCartesian, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetCartesianBurnoutZ"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutCBFCartesian, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetCartesianBurnoutZ"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutCBFCartesian, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetCartesianBurnoutVX"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutCBFCartesian, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetCartesianBurnoutVX"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutCBFCartesian, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetCartesianBurnoutVY"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutCBFCartesian, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetCartesianBurnoutVY"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutCBFCartesian, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetCartesianBurnoutVZ"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutCBFCartesian, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetCartesianBurnoutVZ"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutCBFCartesian, vtable_offset_local+12, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVABurnoutCBFCartesian.__dict__ and type(IVABurnoutCBFCartesian.__dict__[attrname]) == property:
            return IVABurnoutCBFCartesian.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVABurnout.__setattr__(self, attrname, value)
    
    @property
    def CartesianBurnoutX(self) -> float:
        """The CBF x component of the spacecraft burnout location. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCartesianBurnoutX"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CartesianBurnoutX.setter
    def CartesianBurnoutX(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCartesianBurnoutX"](arg_newVal.COM_val))

    @property
    def CartesianBurnoutY(self) -> float:
        """The CBF y component of the spacecraft burnout location. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCartesianBurnoutY"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CartesianBurnoutY.setter
    def CartesianBurnoutY(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCartesianBurnoutY"](arg_newVal.COM_val))

    @property
    def CartesianBurnoutZ(self) -> float:
        """The CBF z component of the spacecraft burnout location. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCartesianBurnoutZ"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CartesianBurnoutZ.setter
    def CartesianBurnoutZ(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCartesianBurnoutZ"](arg_newVal.COM_val))

    @property
    def CartesianBurnoutVX(self) -> float:
        """The CBF x component of the spacecraft burnout velocity. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCartesianBurnoutVX"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CartesianBurnoutVX.setter
    def CartesianBurnoutVX(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCartesianBurnoutVX"](arg_newVal.COM_val))

    @property
    def CartesianBurnoutVY(self) -> float:
        """The CBF y component of the spacecraft burnout velocity. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCartesianBurnoutVY"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CartesianBurnoutVY.setter
    def CartesianBurnoutVY(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCartesianBurnoutVY"](arg_newVal.COM_val))

    @property
    def CartesianBurnoutVZ(self) -> float:
        """The CBF z component of the spacecraft burnout velocity. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCartesianBurnoutVZ"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CartesianBurnoutVZ.setter
    def CartesianBurnoutVZ(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCartesianBurnoutVZ"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{A45DD94F-A384-4CCB-B803-F29F2DA41A39}", IVABurnoutCBFCartesian)
agcls.AgTypeNameMap["IVABurnoutCBFCartesian"] = IVABurnoutCBFCartesian

class IVABurnoutGeodetic(IVABurnout):
    """Properties for a geodetic burnout point definition."""
    _uuid = "{CA74E0CB-01D7-4D65-BC0D-82A469B5E320}"
    _num_methods = 6
    _vtable_offset = IVABurnout._vtable_offset + IVABurnout._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetLatitude"] = _raise_uninitialized_error
        self.__dict__["_SetLatitude"] = _raise_uninitialized_error
        self.__dict__["_GetLongitude"] = _raise_uninitialized_error
        self.__dict__["_SetLongitude"] = _raise_uninitialized_error
        self.__dict__["_GetAltitude"] = _raise_uninitialized_error
        self.__dict__["_SetAltitude"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVABurnoutGeodetic._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVABurnoutGeodetic from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVABurnout._private_init(self, pUnk)
        IID_IVABurnoutGeodetic = agcom.GUID(IVABurnoutGeodetic._uuid)
        vtable_offset_local = IVABurnoutGeodetic._vtable_offset - 1
        self.__dict__["_GetLatitude"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutGeodetic, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_SetLatitude"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutGeodetic, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_GetLongitude"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutGeodetic, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_SetLongitude"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutGeodetic, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_GetAltitude"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutGeodetic, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAltitude"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutGeodetic, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVABurnoutGeodetic.__dict__ and type(IVABurnoutGeodetic.__dict__[attrname]) == property:
            return IVABurnoutGeodetic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVABurnout.__setattr__(self, attrname, value)
    
    @property
    def Latitude(self) -> typing.Any:
        """The latitude of the spacecraft burnout. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLatitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Latitude.setter
    def Latitude(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetLatitude"](arg_newVal.COM_val))

    @property
    def Longitude(self) -> typing.Any:
        """The longitude of the spacecraft burnout. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLongitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Longitude.setter
    def Longitude(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetLongitude"](arg_newVal.COM_val))

    @property
    def Altitude(self) -> float:
        """The altitude of the spacecraft burnout. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAltitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Altitude.setter
    def Altitude(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetAltitude"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{CA74E0CB-01D7-4D65-BC0D-82A469B5E320}", IVABurnoutGeodetic)
agcls.AgTypeNameMap["IVABurnoutGeodetic"] = IVABurnoutGeodetic

class IVABurnoutGeocentric(IVABurnout):
    """{Properties for a geocentric burnout point definition."""
    _uuid = "{BFFA4B30-4A19-4FF9-849D-E6DD6534116D}"
    _num_methods = 6
    _vtable_offset = IVABurnout._vtable_offset + IVABurnout._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetLatitude"] = _raise_uninitialized_error
        self.__dict__["_SetLatitude"] = _raise_uninitialized_error
        self.__dict__["_GetLongitude"] = _raise_uninitialized_error
        self.__dict__["_SetLongitude"] = _raise_uninitialized_error
        self.__dict__["_GetRadius"] = _raise_uninitialized_error
        self.__dict__["_SetRadius"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVABurnoutGeocentric._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVABurnoutGeocentric from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVABurnout._private_init(self, pUnk)
        IID_IVABurnoutGeocentric = agcom.GUID(IVABurnoutGeocentric._uuid)
        vtable_offset_local = IVABurnoutGeocentric._vtable_offset - 1
        self.__dict__["_GetLatitude"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutGeocentric, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_SetLatitude"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutGeocentric, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_GetLongitude"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutGeocentric, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_SetLongitude"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutGeocentric, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_GetRadius"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutGeocentric, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRadius"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutGeocentric, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVABurnoutGeocentric.__dict__ and type(IVABurnoutGeocentric.__dict__[attrname]) == property:
            return IVABurnoutGeocentric.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVABurnout.__setattr__(self, attrname, value)
    
    @property
    def Latitude(self) -> typing.Any:
        """The latitude of the spacecraft burnout. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLatitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Latitude.setter
    def Latitude(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetLatitude"](arg_newVal.COM_val))

    @property
    def Longitude(self) -> typing.Any:
        """The longitude of the spacecraft burnout. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLongitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Longitude.setter
    def Longitude(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetLongitude"](arg_newVal.COM_val))

    @property
    def Radius(self) -> float:
        """The radius of the spacecraft burnout. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRadius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Radius.setter
    def Radius(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetRadius"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{BFFA4B30-4A19-4FF9-849D-E6DD6534116D}", IVABurnoutGeocentric)
agcls.AgTypeNameMap["IVABurnoutGeocentric"] = IVABurnoutGeocentric

class IVABurnoutLaunchAzAlt(IVABurnout):
    """Properties for a launch azimuth / altitude burnout point definition."""
    _uuid = "{FCE8CBAF-46BE-4F76-AB1A-E2116127A402}"
    _num_methods = 6
    _vtable_offset = IVABurnout._vtable_offset + IVABurnout._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAzimuth"] = _raise_uninitialized_error
        self.__dict__["_SetAzimuth"] = _raise_uninitialized_error
        self.__dict__["_GetDownRangeDist"] = _raise_uninitialized_error
        self.__dict__["_SetDownRangeDist"] = _raise_uninitialized_error
        self.__dict__["_GetAltitudeRadius"] = _raise_uninitialized_error
        self.__dict__["_SetAltitudeRadius"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVABurnoutLaunchAzAlt._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVABurnoutLaunchAzAlt from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVABurnout._private_init(self, pUnk)
        IID_IVABurnoutLaunchAzAlt = agcom.GUID(IVABurnoutLaunchAzAlt._uuid)
        vtable_offset_local = IVABurnoutLaunchAzAlt._vtable_offset - 1
        self.__dict__["_GetAzimuth"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutLaunchAzAlt, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_SetAzimuth"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutLaunchAzAlt, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_GetDownRangeDist"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutLaunchAzAlt, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDownRangeDist"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutLaunchAzAlt, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetAltitudeRadius"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutLaunchAzAlt, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAltitudeRadius"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutLaunchAzAlt, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVABurnoutLaunchAzAlt.__dict__ and type(IVABurnoutLaunchAzAlt.__dict__[attrname]) == property:
            return IVABurnoutLaunchAzAlt.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVABurnout.__setattr__(self, attrname, value)
    
    @property
    def Azimuth(self) -> typing.Any:
        """The azimuth of the launch trajectory. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAzimuth"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Azimuth.setter
    def Azimuth(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetAzimuth"](arg_newVal.COM_val))

    @property
    def DownRangeDist(self) -> float:
        """The downrange distance of the spacecraft from launch at burnout. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDownRangeDist"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DownRangeDist.setter
    def DownRangeDist(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetDownRangeDist"](arg_newVal.COM_val))

    @property
    def AltitudeRadius(self) -> float:
        """The altitude of the spacecraft at burnout. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAltitudeRadius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AltitudeRadius.setter
    def AltitudeRadius(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetAltitudeRadius"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{FCE8CBAF-46BE-4F76-AB1A-E2116127A402}", IVABurnoutLaunchAzAlt)
agcls.AgTypeNameMap["IVABurnoutLaunchAzAlt"] = IVABurnoutLaunchAzAlt

class IVABurnoutLaunchAzRadius(IVABurnout):
    """Properties for a launch azimuth / radius burnout point definition."""
    _uuid = "{623DDE08-539E-4BAD-A63D-FCC195094F14}"
    _num_methods = 6
    _vtable_offset = IVABurnout._vtable_offset + IVABurnout._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAzimuth"] = _raise_uninitialized_error
        self.__dict__["_SetAzimuth"] = _raise_uninitialized_error
        self.__dict__["_GetDownRangeDist"] = _raise_uninitialized_error
        self.__dict__["_SetDownRangeDist"] = _raise_uninitialized_error
        self.__dict__["_GetRadius"] = _raise_uninitialized_error
        self.__dict__["_SetRadius"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVABurnoutLaunchAzRadius._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVABurnoutLaunchAzRadius from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVABurnout._private_init(self, pUnk)
        IID_IVABurnoutLaunchAzRadius = agcom.GUID(IVABurnoutLaunchAzRadius._uuid)
        vtable_offset_local = IVABurnoutLaunchAzRadius._vtable_offset - 1
        self.__dict__["_GetAzimuth"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutLaunchAzRadius, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_SetAzimuth"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutLaunchAzRadius, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_GetDownRangeDist"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutLaunchAzRadius, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDownRangeDist"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutLaunchAzRadius, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetRadius"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutLaunchAzRadius, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRadius"] = IAGFUNCTYPE(pUnk, IID_IVABurnoutLaunchAzRadius, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVABurnoutLaunchAzRadius.__dict__ and type(IVABurnoutLaunchAzRadius.__dict__[attrname]) == property:
            return IVABurnoutLaunchAzRadius.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVABurnout.__setattr__(self, attrname, value)
    
    @property
    def Azimuth(self) -> typing.Any:
        """The azimuth of the launch trajectory. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAzimuth"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Azimuth.setter
    def Azimuth(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetAzimuth"](arg_newVal.COM_val))

    @property
    def DownRangeDist(self) -> float:
        """The downrange distance of the spacecraft from launch at burnout. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDownRangeDist"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DownRangeDist.setter
    def DownRangeDist(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetDownRangeDist"](arg_newVal.COM_val))

    @property
    def Radius(self) -> float:
        """The radius of the spacecraft at burnout. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRadius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Radius.setter
    def Radius(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetRadius"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{623DDE08-539E-4BAD-A63D-FCC195094F14}", IVABurnoutLaunchAzRadius)
agcls.AgTypeNameMap["IVABurnoutLaunchAzRadius"] = IVABurnoutLaunchAzRadius

class IVAMCSFollow(object):
    """Properties for a Follow segment."""
    _uuid = "{88C0BA74-B2B8-4B69-85B5-94B6CC7DEACE}"
    _num_methods = 22
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetLeader"] = _raise_uninitialized_error
        self.__dict__["_GetXOffset"] = _raise_uninitialized_error
        self.__dict__["_SetXOffset"] = _raise_uninitialized_error
        self.__dict__["_GetYOffset"] = _raise_uninitialized_error
        self.__dict__["_SetYOffset"] = _raise_uninitialized_error
        self.__dict__["_GetZOffset"] = _raise_uninitialized_error
        self.__dict__["_SetZOffset"] = _raise_uninitialized_error
        self.__dict__["_GetSeparationConditions"] = _raise_uninitialized_error
        self.__dict__["_GetSpacecraftParameters"] = _raise_uninitialized_error
        self.__dict__["_GetFuelTank"] = _raise_uninitialized_error
        self.__dict__["_GetJoiningType"] = _raise_uninitialized_error
        self.__dict__["_SetJoiningType"] = _raise_uninitialized_error
        self.__dict__["_GetSeparationType"] = _raise_uninitialized_error
        self.__dict__["_SetSeparationType"] = _raise_uninitialized_error
        self.__dict__["_GetSpacecraftAndFuelTankType"] = _raise_uninitialized_error
        self.__dict__["_SetSpacecraftAndFuelTankType"] = _raise_uninitialized_error
        self.__dict__["_GetJoiningConditions"] = _raise_uninitialized_error
        self.__dict__["_EnableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_DisableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_IsControlParameterEnabled"] = _raise_uninitialized_error
        self.__dict__["_GetControlParametersAvailable"] = _raise_uninitialized_error
        self.__dict__["_GetUserVariables"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAMCSFollow._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAMCSFollow from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAMCSFollow = agcom.GUID(IVAMCSFollow._uuid)
        vtable_offset_local = IVAMCSFollow._vtable_offset - 1
        self.__dict__["_GetLeader"] = IAGFUNCTYPE(pUnk, IID_IVAMCSFollow, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetXOffset"] = IAGFUNCTYPE(pUnk, IID_IVAMCSFollow, vtable_offset_local+2, POINTER(agcom.DOUBLE))
        self.__dict__["_SetXOffset"] = IAGFUNCTYPE(pUnk, IID_IVAMCSFollow, vtable_offset_local+3, agcom.DOUBLE)
        self.__dict__["_GetYOffset"] = IAGFUNCTYPE(pUnk, IID_IVAMCSFollow, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_SetYOffset"] = IAGFUNCTYPE(pUnk, IID_IVAMCSFollow, vtable_offset_local+5, agcom.DOUBLE)
        self.__dict__["_GetZOffset"] = IAGFUNCTYPE(pUnk, IID_IVAMCSFollow, vtable_offset_local+6, POINTER(agcom.DOUBLE))
        self.__dict__["_SetZOffset"] = IAGFUNCTYPE(pUnk, IID_IVAMCSFollow, vtable_offset_local+7, agcom.DOUBLE)
        self.__dict__["_GetSeparationConditions"] = IAGFUNCTYPE(pUnk, IID_IVAMCSFollow, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_GetSpacecraftParameters"] = IAGFUNCTYPE(pUnk, IID_IVAMCSFollow, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_GetFuelTank"] = IAGFUNCTYPE(pUnk, IID_IVAMCSFollow, vtable_offset_local+10, POINTER(agcom.PVOID))
        self.__dict__["_GetJoiningType"] = IAGFUNCTYPE(pUnk, IID_IVAMCSFollow, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_SetJoiningType"] = IAGFUNCTYPE(pUnk, IID_IVAMCSFollow, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_GetSeparationType"] = IAGFUNCTYPE(pUnk, IID_IVAMCSFollow, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_SetSeparationType"] = IAGFUNCTYPE(pUnk, IID_IVAMCSFollow, vtable_offset_local+14, agcom.LONG)
        self.__dict__["_GetSpacecraftAndFuelTankType"] = IAGFUNCTYPE(pUnk, IID_IVAMCSFollow, vtable_offset_local+15, POINTER(agcom.LONG))
        self.__dict__["_SetSpacecraftAndFuelTankType"] = IAGFUNCTYPE(pUnk, IID_IVAMCSFollow, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_GetJoiningConditions"] = IAGFUNCTYPE(pUnk, IID_IVAMCSFollow, vtable_offset_local+17, POINTER(agcom.PVOID))
        self.__dict__["_EnableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAMCSFollow, vtable_offset_local+18, agcom.LONG)
        self.__dict__["_DisableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAMCSFollow, vtable_offset_local+19, agcom.LONG)
        self.__dict__["_IsControlParameterEnabled"] = IAGFUNCTYPE(pUnk, IID_IVAMCSFollow, vtable_offset_local+20, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetControlParametersAvailable"] = IAGFUNCTYPE(pUnk, IID_IVAMCSFollow, vtable_offset_local+21, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetUserVariables"] = IAGFUNCTYPE(pUnk, IID_IVAMCSFollow, vtable_offset_local+22, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAMCSFollow.__dict__ and type(IVAMCSFollow.__dict__[attrname]) == property:
            return IVAMCSFollow.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAMCSFollow.")
    
    @property
    def Leader(self) -> "ILinkToObject":
        """The leader object."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_GetLeader"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val

    @property
    def XOffset(self) -> float:
        """The distance that the spacecraft will be offset from the leader's body frame along the X axis. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetXOffset"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @XOffset.setter
    def XOffset(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetXOffset"](arg_newVal.COM_val))

    @property
    def YOffset(self) -> float:
        """The distance that the spacecraft will be offset from the leader's body frame along the Y axis. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetYOffset"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @YOffset.setter
    def YOffset(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetYOffset"](arg_newVal.COM_val))

    @property
    def ZOffset(self) -> float:
        """The distance that the spacecraft will be offset from the leader's body frame along the Z axis. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetZOffset"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ZOffset.setter
    def ZOffset(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetZOffset"](arg_newVal.COM_val))

    @property
    def SeparationConditions(self) -> "IVAStoppingConditionCollection":
        """If separation conditions are specified, the list of separation conditions."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAStoppingConditionCollection:
            agcls.evaluate_hresult(self.__dict__["_GetSeparationConditions"](byref(arg_ppVAStoppingConditionCollection.COM_val)))
            return arg_ppVAStoppingConditionCollection.python_val

    @property
    def SpacecraftParameters(self) -> "IVASpacecraftParameters":
        """The spacecraft's physical properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppVASpacecraftParameters:
            agcls.evaluate_hresult(self.__dict__["_GetSpacecraftParameters"](byref(arg_ppVASpacecraftParameters.COM_val)))
            return arg_ppVASpacecraftParameters.python_val

    @property
    def FuelTank(self) -> "IVAFuelTank":
        """The spacecraft's fuel tank properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAFuelTank:
            agcls.evaluate_hresult(self.__dict__["_GetFuelTank"](byref(arg_ppVAFuelTank.COM_val)))
            return arg_ppVAFuelTank.python_val

    @property
    def JoiningType(self) -> "AgEVAFollowJoin":
        """The joining type."""
        with agmarshall.AgEnum_arg(AgEVAFollowJoin) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetJoiningType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @JoiningType.setter
    def JoiningType(self, newVal:"AgEVAFollowJoin") -> None:
        with agmarshall.AgEnum_arg(AgEVAFollowJoin, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetJoiningType"](arg_newVal.COM_val))

    @property
    def SeparationType(self) -> "AgEVAFollowSeparation":
        """The separation type."""
        with agmarshall.AgEnum_arg(AgEVAFollowSeparation) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSeparationType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SeparationType.setter
    def SeparationType(self, newVal:"AgEVAFollowSeparation") -> None:
        with agmarshall.AgEnum_arg(AgEVAFollowSeparation, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetSeparationType"](arg_newVal.COM_val))

    @property
    def SpacecraftAndFuelTankType(self) -> "AgEVAFollowSpacecraftAndFuelTank":
        """The spacecraft snd fuel tank configuration type."""
        with agmarshall.AgEnum_arg(AgEVAFollowSpacecraftAndFuelTank) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSpacecraftAndFuelTankType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SpacecraftAndFuelTankType.setter
    def SpacecraftAndFuelTankType(self, newVal:"AgEVAFollowSpacecraftAndFuelTank") -> None:
        with agmarshall.AgEnum_arg(AgEVAFollowSpacecraftAndFuelTank, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetSpacecraftAndFuelTankType"](arg_newVal.COM_val))

    @property
    def JoiningConditions(self) -> "IVAStoppingConditionCollection":
        """If joining conditions are specified, the list of joining conditions."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAStoppingConditionCollection:
            agcls.evaluate_hresult(self.__dict__["_GetJoiningConditions"](byref(arg_ppVAStoppingConditionCollection.COM_val)))
            return arg_ppVAStoppingConditionCollection.python_val

    def EnableControlParameter(self, param:"AgEVAControlFollow") -> None:
        """Enables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlFollow, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_EnableControlParameter"](arg_param.COM_val))

    def DisableControlParameter(self, param:"AgEVAControlFollow") -> None:
        """Disables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlFollow, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_DisableControlParameter"](arg_param.COM_val))

    def IsControlParameterEnabled(self, param:"AgEVAControlFollow") -> bool:
        """Sees if the specified control is enabled."""
        with agmarshall.AgEnum_arg(AgEVAControlFollow, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_IsControlParameterEnabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ControlParametersAvailable(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetControlParametersAvailable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def UserVariables(self) -> "IVAUserVariableCollection":
        """Interface used to modify user variables for the follow segment."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUserVariables"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{88C0BA74-B2B8-4B69-85B5-94B6CC7DEACE}", IVAMCSFollow)
agcls.AgTypeNameMap["IVAMCSFollow"] = IVAMCSFollow

class IVAMCSManeuver(object):
    """General properties for a Maneuver segment."""
    _uuid = "{B640A28E-36A1-4934-ABC6-1A74C1A1B9E5}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetManeuverType"] = _raise_uninitialized_error
        self.__dict__["_SetManeuverType"] = _raise_uninitialized_error
        self.__dict__["_GetManeuver"] = _raise_uninitialized_error
        self.__dict__["_EnableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_DisableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_IsControlParameterEnabled"] = _raise_uninitialized_error
        self.__dict__["_GetControlParametersAvailable"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAMCSManeuver._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAMCSManeuver from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAMCSManeuver = agcom.GUID(IVAMCSManeuver._uuid)
        vtable_offset_local = IVAMCSManeuver._vtable_offset - 1
        self.__dict__["_GetManeuverType"] = IAGFUNCTYPE(pUnk, IID_IVAMCSManeuver, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetManeuverType"] = IAGFUNCTYPE(pUnk, IID_IVAMCSManeuver, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetManeuver"] = IAGFUNCTYPE(pUnk, IID_IVAMCSManeuver, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_EnableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAMCSManeuver, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_DisableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAMCSManeuver, vtable_offset_local+5, agcom.LONG)
        self.__dict__["_IsControlParameterEnabled"] = IAGFUNCTYPE(pUnk, IID_IVAMCSManeuver, vtable_offset_local+6, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetControlParametersAvailable"] = IAGFUNCTYPE(pUnk, IID_IVAMCSManeuver, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAMCSManeuver.__dict__ and type(IVAMCSManeuver.__dict__[attrname]) == property:
            return IVAMCSManeuver.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAMCSManeuver.")
    
    @property
    def ManeuverType(self) -> "AgEVAManeuverType":
        """The maneuver type."""
        with agmarshall.AgEnum_arg(AgEVAManeuverType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetManeuverType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def SetManeuverType(self, maneuverType:"AgEVAManeuverType") -> None:
        """Sets the maneuver type"""
        with agmarshall.AgEnum_arg(AgEVAManeuverType, maneuverType) as arg_maneuverType:
            agcls.evaluate_hresult(self.__dict__["_SetManeuverType"](arg_maneuverType.COM_val))

    @property
    def Maneuver(self) -> "IVAManeuver":
        """The Maneuver properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAManeuver:
            agcls.evaluate_hresult(self.__dict__["_GetManeuver"](byref(arg_ppVAManeuver.COM_val)))
            return arg_ppVAManeuver.python_val

    def EnableControlParameter(self, param:"AgEVAControlManeuver") -> None:
        """Enables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlManeuver, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_EnableControlParameter"](arg_param.COM_val))

    def DisableControlParameter(self, param:"AgEVAControlManeuver") -> None:
        """Disables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlManeuver, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_DisableControlParameter"](arg_param.COM_val))

    def IsControlParameterEnabled(self, param:"AgEVAControlManeuver") -> bool:
        """Sees if the specified control is enabled."""
        with agmarshall.AgEnum_arg(AgEVAControlManeuver, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_IsControlParameterEnabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ControlParametersAvailable(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetControlParametersAvailable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{B640A28E-36A1-4934-ABC6-1A74C1A1B9E5}", IVAMCSManeuver)
agcls.AgTypeNameMap["IVAMCSManeuver"] = IVAMCSManeuver

class IVAManeuverFinite(IVAManeuver):
    """Engine properties for a Finite Maneuver."""
    _uuid = "{2BE095B5-A674-4868-9178-6ADB00753CBF}"
    _num_methods = 7
    _vtable_offset = IVAManeuver._vtable_offset + IVAManeuver._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPressureMode"] = _raise_uninitialized_error
        self.__dict__["_SetPressureMode"] = _raise_uninitialized_error
        self.__dict__["_GetThrustEfficiency"] = _raise_uninitialized_error
        self.__dict__["_SetThrustEfficiency"] = _raise_uninitialized_error
        self.__dict__["_GetThrustEfficiencyMode"] = _raise_uninitialized_error
        self.__dict__["_SetThrustEfficiencyMode"] = _raise_uninitialized_error
        self.__dict__["_GetPropagator"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAManeuverFinite._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAManeuverFinite from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAManeuver._private_init(self, pUnk)
        IID_IVAManeuverFinite = agcom.GUID(IVAManeuverFinite._uuid)
        vtable_offset_local = IVAManeuverFinite._vtable_offset - 1
        self.__dict__["_GetPressureMode"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverFinite, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetPressureMode"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverFinite, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetThrustEfficiency"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverFinite, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetThrustEfficiency"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverFinite, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetThrustEfficiencyMode"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverFinite, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetThrustEfficiencyMode"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverFinite, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetPropagator"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverFinite, vtable_offset_local+7, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAManeuverFinite.__dict__ and type(IVAManeuverFinite.__dict__[attrname]) == property:
            return IVAManeuverFinite.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAManeuver.__setattr__(self, attrname, value)
    
    @property
    def PressureMode(self) -> "AgEVAPressureMode":
        """The pressure mode."""
        with agmarshall.AgEnum_arg(AgEVAPressureMode) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPressureMode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @PressureMode.setter
    def PressureMode(self, newVal:"AgEVAPressureMode") -> None:
        with agmarshall.AgEnum_arg(AgEVAPressureMode, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetPressureMode"](arg_newVal.COM_val))

    @property
    def ThrustEfficiency(self) -> float:
        """The thrust efficiency value. Any number above zero is valid, with typical values around 0.98 to 1.02. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetThrustEfficiency"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ThrustEfficiency.setter
    def ThrustEfficiency(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetThrustEfficiency"](arg_newVal.COM_val))

    @property
    def ThrustEfficiencyMode(self) -> "AgEVAThrustType":
        """Thrust - the calculations that are effected by the thrust efficiency value."""
        with agmarshall.AgEnum_arg(AgEVAThrustType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetThrustEfficiencyMode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ThrustEfficiencyMode.setter
    def ThrustEfficiencyMode(self, newVal:"AgEVAThrustType") -> None:
        with agmarshall.AgEnum_arg(AgEVAThrustType, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetThrustEfficiencyMode"](arg_newVal.COM_val))

    @property
    def Propagator(self) -> "IVAManeuverFinitePropagator":
        """The propagator."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAManeuverFinitePropagator:
            agcls.evaluate_hresult(self.__dict__["_GetPropagator"](byref(arg_ppVAManeuverFinitePropagator.COM_val)))
            return arg_ppVAManeuverFinitePropagator.python_val


agcls.AgClassCatalog.add_catalog_entry("{2BE095B5-A674-4868-9178-6ADB00753CBF}", IVAManeuverFinite)
agcls.AgTypeNameMap["IVAManeuverFinite"] = IVAManeuverFinite

class IVAManeuverImpulsive(IVAManeuver):
    """Properties for an Impulsive Maneuver."""
    _uuid = "{41595314-A798-41ED-80DD-0DA873CCF8A0}"
    _num_methods = 2
    _vtable_offset = IVAManeuver._vtable_offset + IVAManeuver._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetUpdateMass"] = _raise_uninitialized_error
        self.__dict__["_SetUpdateMass"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAManeuverImpulsive._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAManeuverImpulsive from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAManeuver._private_init(self, pUnk)
        IID_IVAManeuverImpulsive = agcom.GUID(IVAManeuverImpulsive._uuid)
        vtable_offset_local = IVAManeuverImpulsive._vtable_offset - 1
        self.__dict__["_GetUpdateMass"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverImpulsive, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUpdateMass"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverImpulsive, vtable_offset_local+2, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAManeuverImpulsive.__dict__ and type(IVAManeuverImpulsive.__dict__[attrname]) == property:
            return IVAManeuverImpulsive.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAManeuver.__setattr__(self, attrname, value)
    
    @property
    def UpdateMass(self) -> bool:
        """True if the mass of the spacecraft will be updated on the basis of fuel usage."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUpdateMass"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UpdateMass.setter
    def UpdateMass(self, pVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetUpdateMass"](arg_pVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{41595314-A798-41ED-80DD-0DA873CCF8A0}", IVAManeuverImpulsive)
agcls.AgTypeNameMap["IVAManeuverImpulsive"] = IVAManeuverImpulsive

class IVAAttitudeControlImpulsiveVelocityVector(IVAAttitudeControlImpulsive):
    """Properties for the Velocity Vector attitude control for an Impulsive Maneuver."""
    _uuid = "{EF098B53-D99D-4AB6-A227-DED98E48B4DB}"
    _num_methods = 3
    _vtable_offset = IVAAttitudeControlImpulsive._vtable_offset + IVAAttitudeControlImpulsive._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetDeltaVMagnitude"] = _raise_uninitialized_error
        self.__dict__["_SetDeltaVMagnitude"] = _raise_uninitialized_error
        self.__dict__["_GetBodyConstraintVector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAAttitudeControlImpulsiveVelocityVector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAAttitudeControlImpulsiveVelocityVector from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAAttitudeControlImpulsive._private_init(self, pUnk)
        IID_IVAAttitudeControlImpulsiveVelocityVector = agcom.GUID(IVAAttitudeControlImpulsiveVelocityVector._uuid)
        vtable_offset_local = IVAAttitudeControlImpulsiveVelocityVector._vtable_offset - 1
        self.__dict__["_GetDeltaVMagnitude"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveVelocityVector, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDeltaVMagnitude"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveVelocityVector, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetBodyConstraintVector"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveVelocityVector, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAAttitudeControlImpulsiveVelocityVector.__dict__ and type(IVAAttitudeControlImpulsiveVelocityVector.__dict__[attrname]) == property:
            return IVAAttitudeControlImpulsiveVelocityVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAAttitudeControlImpulsive.__setattr__(self, attrname, value)
    
    @property
    def DeltaVMagnitude(self) -> float:
        """The size of the delta-V to be applied to the orbit along the velocity vector. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDeltaVMagnitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DeltaVMagnitude.setter
    def DeltaVMagnitude(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetDeltaVMagnitude"](arg_newVal.COM_val))

    @property
    def BodyConstraintVector(self) -> "IDirection":
        """Defines a constraint vector in spacecraft body coordinates to complete the attitude definition."""
        with agmarshall.AgInterface_out_arg() as arg_ppDirection:
            agcls.evaluate_hresult(self.__dict__["_GetBodyConstraintVector"](byref(arg_ppDirection.COM_val)))
            return arg_ppDirection.python_val


agcls.AgClassCatalog.add_catalog_entry("{EF098B53-D99D-4AB6-A227-DED98E48B4DB}", IVAAttitudeControlImpulsiveVelocityVector)
agcls.AgTypeNameMap["IVAAttitudeControlImpulsiveVelocityVector"] = IVAAttitudeControlImpulsiveVelocityVector

class IVAAttitudeControlImpulsiveAntiVelocityVector(IVAAttitudeControlImpulsive):
    """Properties for the Anti-Velocity Vector attitude control for an Impulsive Maneuver."""
    _uuid = "{711B2692-73A2-4C08-9AF3-CC1F93317DF2}"
    _num_methods = 3
    _vtable_offset = IVAAttitudeControlImpulsive._vtable_offset + IVAAttitudeControlImpulsive._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetDeltaVMagnitude"] = _raise_uninitialized_error
        self.__dict__["_SetDeltaVMagnitude"] = _raise_uninitialized_error
        self.__dict__["_GetBodyConstraintVector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAAttitudeControlImpulsiveAntiVelocityVector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAAttitudeControlImpulsiveAntiVelocityVector from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAAttitudeControlImpulsive._private_init(self, pUnk)
        IID_IVAAttitudeControlImpulsiveAntiVelocityVector = agcom.GUID(IVAAttitudeControlImpulsiveAntiVelocityVector._uuid)
        vtable_offset_local = IVAAttitudeControlImpulsiveAntiVelocityVector._vtable_offset - 1
        self.__dict__["_GetDeltaVMagnitude"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveAntiVelocityVector, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDeltaVMagnitude"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveAntiVelocityVector, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetBodyConstraintVector"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveAntiVelocityVector, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAAttitudeControlImpulsiveAntiVelocityVector.__dict__ and type(IVAAttitudeControlImpulsiveAntiVelocityVector.__dict__[attrname]) == property:
            return IVAAttitudeControlImpulsiveAntiVelocityVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAAttitudeControlImpulsive.__setattr__(self, attrname, value)
    
    @property
    def DeltaVMagnitude(self) -> float:
        """The size of the delta-V to be applied to the orbit along the velocity vector. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDeltaVMagnitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DeltaVMagnitude.setter
    def DeltaVMagnitude(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetDeltaVMagnitude"](arg_newVal.COM_val))

    @property
    def BodyConstraintVector(self) -> "IDirection":
        """Defines a constraint vector in spacecraft body coordinates to complete the attitude definition."""
        with agmarshall.AgInterface_out_arg() as arg_ppDirection:
            agcls.evaluate_hresult(self.__dict__["_GetBodyConstraintVector"](byref(arg_ppDirection.COM_val)))
            return arg_ppDirection.python_val


agcls.AgClassCatalog.add_catalog_entry("{711B2692-73A2-4C08-9AF3-CC1F93317DF2}", IVAAttitudeControlImpulsiveAntiVelocityVector)
agcls.AgTypeNameMap["IVAAttitudeControlImpulsiveAntiVelocityVector"] = IVAAttitudeControlImpulsiveAntiVelocityVector

class IVAAttitudeControlImpulsiveAttitude(IVAAttitudeControlImpulsive):
    """Properties for the Attitude attitude control for an Impulsive Maneuver."""
    _uuid = "{D9334B8B-9016-4F73-A134-0C61C91060E1}"
    _num_methods = 5
    _vtable_offset = IVAAttitudeControlImpulsive._vtable_offset + IVAAttitudeControlImpulsive._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetDeltaVMagnitude"] = _raise_uninitialized_error
        self.__dict__["_SetDeltaVMagnitude"] = _raise_uninitialized_error
        self.__dict__["_GetRefAxesName"] = _raise_uninitialized_error
        self.__dict__["_SetRefAxesName"] = _raise_uninitialized_error
        self.__dict__["_GetOrientation"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAAttitudeControlImpulsiveAttitude._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAAttitudeControlImpulsiveAttitude from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAAttitudeControlImpulsive._private_init(self, pUnk)
        IID_IVAAttitudeControlImpulsiveAttitude = agcom.GUID(IVAAttitudeControlImpulsiveAttitude._uuid)
        vtable_offset_local = IVAAttitudeControlImpulsiveAttitude._vtable_offset - 1
        self.__dict__["_GetDeltaVMagnitude"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveAttitude, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDeltaVMagnitude"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveAttitude, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetRefAxesName"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveAttitude, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetRefAxesName"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveAttitude, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_GetOrientation"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveAttitude, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAAttitudeControlImpulsiveAttitude.__dict__ and type(IVAAttitudeControlImpulsiveAttitude.__dict__[attrname]) == property:
            return IVAAttitudeControlImpulsiveAttitude.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAAttitudeControlImpulsive.__setattr__(self, attrname, value)
    
    @property
    def DeltaVMagnitude(self) -> float:
        """The size of the delta-V to be applied along the X axis - as defined by the selected axes and rotation. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDeltaVMagnitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DeltaVMagnitude.setter
    def DeltaVMagnitude(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetDeltaVMagnitude"](arg_newVal.COM_val))

    @property
    def RefAxesName(self) -> str:
        """Ref Axes - the reference axes to be used in modeling this maneuver."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRefAxesName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RefAxesName.setter
    def RefAxesName(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetRefAxesName"](arg_newVal.COM_val))

    @property
    def Orientation(self) -> "IOrientation":
        """The orientation of the attitude."""
        with agmarshall.AgInterface_out_arg() as arg_ppOrientation:
            agcls.evaluate_hresult(self.__dict__["_GetOrientation"](byref(arg_ppOrientation.COM_val)))
            return arg_ppOrientation.python_val


agcls.AgClassCatalog.add_catalog_entry("{D9334B8B-9016-4F73-A134-0C61C91060E1}", IVAAttitudeControlImpulsiveAttitude)
agcls.AgTypeNameMap["IVAAttitudeControlImpulsiveAttitude"] = IVAAttitudeControlImpulsiveAttitude

class IVAAttitudeControlImpulsiveFile(IVAAttitudeControlImpulsive):
    """Properties for the File attitude control for an Impulsive Maneuver."""
    _uuid = "{24B73A06-3F9E-4409-AE5E-00504C6A2AD7}"
    _num_methods = 7
    _vtable_offset = IVAAttitudeControlImpulsive._vtable_offset + IVAAttitudeControlImpulsive._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetDeltaVMagnitude"] = _raise_uninitialized_error
        self.__dict__["_SetDeltaVMagnitude"] = _raise_uninitialized_error
        self.__dict__["_GetFilename"] = _raise_uninitialized_error
        self.__dict__["_SetFilename"] = _raise_uninitialized_error
        self.__dict__["_GetFileTimeOffset"] = _raise_uninitialized_error
        self.__dict__["_SetFileTimeOffset"] = _raise_uninitialized_error
        self.__dict__["_GetFullFilename"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAAttitudeControlImpulsiveFile._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAAttitudeControlImpulsiveFile from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAAttitudeControlImpulsive._private_init(self, pUnk)
        IID_IVAAttitudeControlImpulsiveFile = agcom.GUID(IVAAttitudeControlImpulsiveFile._uuid)
        vtable_offset_local = IVAAttitudeControlImpulsiveFile._vtable_offset - 1
        self.__dict__["_GetDeltaVMagnitude"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveFile, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDeltaVMagnitude"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveFile, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetFilename"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveFile, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetFilename"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveFile, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_GetFileTimeOffset"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveFile, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetFileTimeOffset"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveFile, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetFullFilename"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveFile, vtable_offset_local+7, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAAttitudeControlImpulsiveFile.__dict__ and type(IVAAttitudeControlImpulsiveFile.__dict__[attrname]) == property:
            return IVAAttitudeControlImpulsiveFile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAAttitudeControlImpulsive.__setattr__(self, attrname, value)
    
    @property
    def DeltaVMagnitude(self) -> float:
        """The size of the delta-V to be applied to the orbit along the specified direction. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDeltaVMagnitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DeltaVMagnitude.setter
    def DeltaVMagnitude(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetDeltaVMagnitude"](arg_newVal.COM_val))

    @property
    def Filename(self) -> str:
        """The attitude file to use."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Filename.setter
    def Filename(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetFilename"](arg_newVal.COM_val))

    @property
    def FileTimeOffset(self) -> float:
        """The time offset can be used to adjust the time stored in the attitude file. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetFileTimeOffset"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @FileTimeOffset.setter
    def FileTimeOffset(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetFileTimeOffset"](arg_newVal.COM_val))

    @property
    def FullFilename(self) -> str:
        """The full path and name of the attitude file to use."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetFullFilename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{24B73A06-3F9E-4409-AE5E-00504C6A2AD7}", IVAAttitudeControlImpulsiveFile)
agcls.AgTypeNameMap["IVAAttitudeControlImpulsiveFile"] = IVAAttitudeControlImpulsiveFile

class IVAAttitudeControlImpulsiveThrustVector(IVAAttitudeControlImpulsive):
    """Properties for the Thrust Vector attitude control for an Impulsive Maneuver."""
    _uuid = "{3C985D0B-4049-4C5E-81BC-E394CCE17787}"
    _num_methods = 23
    _vtable_offset = IVAAttitudeControlImpulsive._vtable_offset + IVAAttitudeControlImpulsive._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetThrustAxesName"] = _raise_uninitialized_error
        self.__dict__["_SetThrustAxesName"] = _raise_uninitialized_error
        self.__dict__["_GetBodyConstraintVector"] = _raise_uninitialized_error
        self.__dict__["_GetAllowNegativeSphericalMagnitude"] = _raise_uninitialized_error
        self.__dict__["_SetAllowNegativeSphericalMagnitude"] = _raise_uninitialized_error
        self.__dict__["_GetCoordType"] = _raise_uninitialized_error
        self.__dict__["_SetCoordType"] = _raise_uninitialized_error
        self.__dict__["_GetX"] = _raise_uninitialized_error
        self.__dict__["_SetX"] = _raise_uninitialized_error
        self.__dict__["_GetY"] = _raise_uninitialized_error
        self.__dict__["_SetY"] = _raise_uninitialized_error
        self.__dict__["_GetZ"] = _raise_uninitialized_error
        self.__dict__["_SetZ"] = _raise_uninitialized_error
        self.__dict__["_GetAzimuth"] = _raise_uninitialized_error
        self.__dict__["_SetAzimuth"] = _raise_uninitialized_error
        self.__dict__["_GetElevation"] = _raise_uninitialized_error
        self.__dict__["_SetElevation"] = _raise_uninitialized_error
        self.__dict__["_GetMagnitude"] = _raise_uninitialized_error
        self.__dict__["_SetMagnitude"] = _raise_uninitialized_error
        self.__dict__["_AssignCartesian"] = _raise_uninitialized_error
        self.__dict__["_QueryCartesian"] = _raise_uninitialized_error
        self.__dict__["_AssignSpherical"] = _raise_uninitialized_error
        self.__dict__["_QuerySpherical"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAAttitudeControlImpulsiveThrustVector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAAttitudeControlImpulsiveThrustVector from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAAttitudeControlImpulsive._private_init(self, pUnk)
        IID_IVAAttitudeControlImpulsiveThrustVector = agcom.GUID(IVAAttitudeControlImpulsiveThrustVector._uuid)
        vtable_offset_local = IVAAttitudeControlImpulsiveThrustVector._vtable_offset - 1
        self.__dict__["_GetThrustAxesName"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveThrustVector, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetThrustAxesName"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveThrustVector, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetBodyConstraintVector"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveThrustVector, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetAllowNegativeSphericalMagnitude"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveThrustVector, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetAllowNegativeSphericalMagnitude"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveThrustVector, vtable_offset_local+5, agcom.VARIANT_BOOL)
        self.__dict__["_GetCoordType"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveThrustVector, vtable_offset_local+6, POINTER(agcom.LONG))
        self.__dict__["_SetCoordType"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveThrustVector, vtable_offset_local+7, agcom.LONG)
        self.__dict__["_GetX"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveThrustVector, vtable_offset_local+8, POINTER(agcom.DOUBLE))
        self.__dict__["_SetX"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveThrustVector, vtable_offset_local+9, agcom.DOUBLE)
        self.__dict__["_GetY"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveThrustVector, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_SetY"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveThrustVector, vtable_offset_local+11, agcom.DOUBLE)
        self.__dict__["_GetZ"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveThrustVector, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_SetZ"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveThrustVector, vtable_offset_local+13, agcom.DOUBLE)
        self.__dict__["_GetAzimuth"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveThrustVector, vtable_offset_local+14, POINTER(agcom.VARIANT))
        self.__dict__["_SetAzimuth"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveThrustVector, vtable_offset_local+15, agcom.VARIANT)
        self.__dict__["_GetElevation"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveThrustVector, vtable_offset_local+16, POINTER(agcom.VARIANT))
        self.__dict__["_SetElevation"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveThrustVector, vtable_offset_local+17, agcom.VARIANT)
        self.__dict__["_GetMagnitude"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveThrustVector, vtable_offset_local+18, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMagnitude"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveThrustVector, vtable_offset_local+19, agcom.DOUBLE)
        self.__dict__["_AssignCartesian"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveThrustVector, vtable_offset_local+20, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE)
        self.__dict__["_QueryCartesian"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveThrustVector, vtable_offset_local+21, POINTER(agcom.SAFEARRAY))
        self.__dict__["_AssignSpherical"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveThrustVector, vtable_offset_local+22, agcom.VARIANT, agcom.VARIANT, agcom.DOUBLE)
        self.__dict__["_QuerySpherical"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlImpulsiveThrustVector, vtable_offset_local+23, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAAttitudeControlImpulsiveThrustVector.__dict__ and type(IVAAttitudeControlImpulsiveThrustVector.__dict__[attrname]) == property:
            return IVAAttitudeControlImpulsiveThrustVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAAttitudeControlImpulsive.__setattr__(self, attrname, value)
    
    @property
    def ThrustAxesName(self) -> str:
        """The thrust axes."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetThrustAxesName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ThrustAxesName.setter
    def ThrustAxesName(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetThrustAxesName"](arg_newVal.COM_val))

    @property
    def BodyConstraintVector(self) -> "IDirection":
        """Defines a constraint vector in spacecraft body coordinates to complete the attitude definition."""
        with agmarshall.AgInterface_out_arg() as arg_ppDirection:
            agcls.evaluate_hresult(self.__dict__["_GetBodyConstraintVector"](byref(arg_ppDirection.COM_val)))
            return arg_ppDirection.python_val

    @property
    def AllowNegativeSphericalMagnitude(self) -> bool:
        """True if the spherical magnitude should be allowed to be less than zero."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAllowNegativeSphericalMagnitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AllowNegativeSphericalMagnitude.setter
    def AllowNegativeSphericalMagnitude(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetAllowNegativeSphericalMagnitude"](arg_newVal.COM_val))

    @property
    def CoordType(self) -> "AgEVAImpDeltaVRep":
        """The coordinate representation for the DeltaV."""
        with agmarshall.AgEnum_arg(AgEVAImpDeltaVRep) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordType.setter
    def CoordType(self, newVal:"AgEVAImpDeltaVRep") -> None:
        with agmarshall.AgEnum_arg(AgEVAImpDeltaVRep, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordType"](arg_newVal.COM_val))

    @property
    def X(self) -> float:
        """The Cartesian X component of the impulsive DeltaV (dimension: SmallDistance/Time)."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetX"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @X.setter
    def X(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetX"](arg_newVal.COM_val))

    @property
    def Y(self) -> float:
        """The Cartesian Y component of the impulsive DeltaV (dimension: SmallDistance/Time)."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetY"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Y.setter
    def Y(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetY"](arg_newVal.COM_val))

    @property
    def Z(self) -> float:
        """The Cartesian Z component of the impulsive DeltaV (dimension: SmallDistance/Time)."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetZ"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Z.setter
    def Z(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetZ"](arg_newVal.COM_val))

    @property
    def Azimuth(self) -> typing.Any:
        """The spherical Azimuth angle of the impulsive DeltaV (dimension: Angle)."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAzimuth"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Azimuth.setter
    def Azimuth(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetAzimuth"](arg_newVal.COM_val))

    @property
    def Elevation(self) -> typing.Any:
        """The spherical Elevation angle of the impulsive DeltaV (dimension: Angle)."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElevation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Elevation.setter
    def Elevation(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetElevation"](arg_newVal.COM_val))

    @property
    def Magnitude(self) -> float:
        """The spherical Magnitude of the impulsive DeltaV (dimension: SmallDistance/Time)."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMagnitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Magnitude.setter
    def Magnitude(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetMagnitude"](arg_newVal.COM_val))

    def AssignCartesian(self, xVal:float, yVal:float, zVal:float) -> None:
        """Assign all three Cartesian components of the DeltaV vector (dimension: SmallDistance/Time)"""
        with agmarshall.DOUBLE_arg(xVal) as arg_xVal, \
             agmarshall.DOUBLE_arg(yVal) as arg_yVal, \
             agmarshall.DOUBLE_arg(zVal) as arg_zVal:
            agcls.evaluate_hresult(self.__dict__["_AssignCartesian"](arg_xVal.COM_val, arg_yVal.COM_val, arg_zVal.COM_val))

    def QueryCartesian(self) -> list:
        """Get all three Cartesian components of the DeltaV vector as an array (dimension: SmallDistance/Time)"""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_QueryCartesian"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def AssignSpherical(self, azVal:typing.Any, elVal:typing.Any, magVal:float) -> None:
        """Assign all three spherical components of the DeltaV vector (order Az, El, Mag; dimensions: Angle, Angle, SmallDistance/Time)"""
        with agmarshall.VARIANT_arg(azVal) as arg_azVal, \
             agmarshall.VARIANT_arg(elVal) as arg_elVal, \
             agmarshall.DOUBLE_arg(magVal) as arg_magVal:
            agcls.evaluate_hresult(self.__dict__["_AssignSpherical"](arg_azVal.COM_val, arg_elVal.COM_val, arg_magVal.COM_val))

    def QuerySpherical(self) -> list:
        """Get all three spherical components of the DeltaV vector as an array (order Az, El, Mag; dimensions: Angle, Angle, SmallDistance/Time)"""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_QuerySpherical"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{3C985D0B-4049-4C5E-81BC-E394CCE17787}", IVAAttitudeControlImpulsiveThrustVector)
agcls.AgTypeNameMap["IVAAttitudeControlImpulsiveThrustVector"] = IVAAttitudeControlImpulsiveThrustVector

class IVAAttitudeControlFiniteAntiVelocityVector(IVAAttitudeControlFinite):
    """Properties for the Anti-Velocity Vector attitude control for a Finite Maneuver."""
    _uuid = "{DB9276FA-2033-425D-9453-A0862C3DC715}"
    _num_methods = 3
    _vtable_offset = IVAAttitudeControlFinite._vtable_offset + IVAAttitudeControlFinite._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAttitudeUpdate"] = _raise_uninitialized_error
        self.__dict__["_SetAttitudeUpdate"] = _raise_uninitialized_error
        self.__dict__["_GetBodyConstraintVector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAAttitudeControlFiniteAntiVelocityVector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAAttitudeControlFiniteAntiVelocityVector from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAAttitudeControlFinite._private_init(self, pUnk)
        IID_IVAAttitudeControlFiniteAntiVelocityVector = agcom.GUID(IVAAttitudeControlFiniteAntiVelocityVector._uuid)
        vtable_offset_local = IVAAttitudeControlFiniteAntiVelocityVector._vtable_offset - 1
        self.__dict__["_GetAttitudeUpdate"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteAntiVelocityVector, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetAttitudeUpdate"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteAntiVelocityVector, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetBodyConstraintVector"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteAntiVelocityVector, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAAttitudeControlFiniteAntiVelocityVector.__dict__ and type(IVAAttitudeControlFiniteAntiVelocityVector.__dict__[attrname]) == property:
            return IVAAttitudeControlFiniteAntiVelocityVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAAttitudeControlFinite.__setattr__(self, attrname, value)
    
    @property
    def AttitudeUpdate(self) -> "AgEVAAttitudeUpdate":
        """How and when the attitude will be updated."""
        with agmarshall.AgEnum_arg(AgEVAAttitudeUpdate) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAttitudeUpdate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AttitudeUpdate.setter
    def AttitudeUpdate(self, newVal:"AgEVAAttitudeUpdate") -> None:
        with agmarshall.AgEnum_arg(AgEVAAttitudeUpdate, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetAttitudeUpdate"](arg_newVal.COM_val))

    @property
    def BodyConstraintVector(self) -> "IDirection":
        """Defines a constraint vector in spacecraft body coordinates to complete the attitude definition."""
        with agmarshall.AgInterface_out_arg() as arg_ppDirection:
            agcls.evaluate_hresult(self.__dict__["_GetBodyConstraintVector"](byref(arg_ppDirection.COM_val)))
            return arg_ppDirection.python_val


agcls.AgClassCatalog.add_catalog_entry("{DB9276FA-2033-425D-9453-A0862C3DC715}", IVAAttitudeControlFiniteAntiVelocityVector)
agcls.AgTypeNameMap["IVAAttitudeControlFiniteAntiVelocityVector"] = IVAAttitudeControlFiniteAntiVelocityVector

class IVAAttitudeControlFiniteAttitude(IVAAttitudeControlFinite):
    """Properties for the Attitude attitude control for a Finite Maneuver."""
    _uuid = "{BE7E2121-2A2E-4045-BE6F-E75256FDD287}"
    _num_methods = 5
    _vtable_offset = IVAAttitudeControlFinite._vtable_offset + IVAAttitudeControlFinite._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAttitudeUpdate"] = _raise_uninitialized_error
        self.__dict__["_SetAttitudeUpdate"] = _raise_uninitialized_error
        self.__dict__["_GetRefAxesName"] = _raise_uninitialized_error
        self.__dict__["_SetRefAxesName"] = _raise_uninitialized_error
        self.__dict__["_GetOrientation"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAAttitudeControlFiniteAttitude._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAAttitudeControlFiniteAttitude from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAAttitudeControlFinite._private_init(self, pUnk)
        IID_IVAAttitudeControlFiniteAttitude = agcom.GUID(IVAAttitudeControlFiniteAttitude._uuid)
        vtable_offset_local = IVAAttitudeControlFiniteAttitude._vtable_offset - 1
        self.__dict__["_GetAttitudeUpdate"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteAttitude, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetAttitudeUpdate"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteAttitude, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetRefAxesName"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteAttitude, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetRefAxesName"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteAttitude, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_GetOrientation"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteAttitude, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAAttitudeControlFiniteAttitude.__dict__ and type(IVAAttitudeControlFiniteAttitude.__dict__[attrname]) == property:
            return IVAAttitudeControlFiniteAttitude.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAAttitudeControlFinite.__setattr__(self, attrname, value)
    
    @property
    def AttitudeUpdate(self) -> "AgEVAAttitudeUpdate":
        """How and when the attitude will be updated."""
        with agmarshall.AgEnum_arg(AgEVAAttitudeUpdate) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAttitudeUpdate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AttitudeUpdate.setter
    def AttitudeUpdate(self, newVal:"AgEVAAttitudeUpdate") -> None:
        with agmarshall.AgEnum_arg(AgEVAAttitudeUpdate, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetAttitudeUpdate"](arg_newVal.COM_val))

    @property
    def RefAxesName(self) -> str:
        """Ref Axes - the reference axes to be used in modeling this maneuver."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRefAxesName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RefAxesName.setter
    def RefAxesName(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetRefAxesName"](arg_newVal.COM_val))

    @property
    def Orientation(self) -> "IOrientation":
        """The orientation of the attitude."""
        with agmarshall.AgInterface_out_arg() as arg_ppOrientation:
            agcls.evaluate_hresult(self.__dict__["_GetOrientation"](byref(arg_ppOrientation.COM_val)))
            return arg_ppOrientation.python_val


agcls.AgClassCatalog.add_catalog_entry("{BE7E2121-2A2E-4045-BE6F-E75256FDD287}", IVAAttitudeControlFiniteAttitude)
agcls.AgTypeNameMap["IVAAttitudeControlFiniteAttitude"] = IVAAttitudeControlFiniteAttitude

class IVAAttitudeControlFiniteFile(IVAAttitudeControlFinite):
    """Properties for the File attitude control for a Finite Maneuver."""
    _uuid = "{B2B44C74-C8D0-4AE0-A259-F73CD60AEC97}"
    _num_methods = 5
    _vtable_offset = IVAAttitudeControlFinite._vtable_offset + IVAAttitudeControlFinite._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFilename"] = _raise_uninitialized_error
        self.__dict__["_SetFilename"] = _raise_uninitialized_error
        self.__dict__["_GetFileTimeOffset"] = _raise_uninitialized_error
        self.__dict__["_SetFileTimeOffset"] = _raise_uninitialized_error
        self.__dict__["_GetFullFilename"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAAttitudeControlFiniteFile._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAAttitudeControlFiniteFile from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAAttitudeControlFinite._private_init(self, pUnk)
        IID_IVAAttitudeControlFiniteFile = agcom.GUID(IVAAttitudeControlFiniteFile._uuid)
        vtable_offset_local = IVAAttitudeControlFiniteFile._vtable_offset - 1
        self.__dict__["_GetFilename"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteFile, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetFilename"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteFile, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetFileTimeOffset"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteFile, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetFileTimeOffset"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteFile, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetFullFilename"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteFile, vtable_offset_local+5, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAAttitudeControlFiniteFile.__dict__ and type(IVAAttitudeControlFiniteFile.__dict__[attrname]) == property:
            return IVAAttitudeControlFiniteFile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAAttitudeControlFinite.__setattr__(self, attrname, value)
    
    @property
    def Filename(self) -> str:
        """The attitude file to use."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Filename.setter
    def Filename(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetFilename"](arg_newVal.COM_val))

    @property
    def FileTimeOffset(self) -> float:
        """The time offset can be used to adjust the time stored in the attitude file. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetFileTimeOffset"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @FileTimeOffset.setter
    def FileTimeOffset(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetFileTimeOffset"](arg_newVal.COM_val))

    @property
    def FullFilename(self) -> str:
        """The full path and name of the attitude file to use."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetFullFilename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{B2B44C74-C8D0-4AE0-A259-F73CD60AEC97}", IVAAttitudeControlFiniteFile)
agcls.AgTypeNameMap["IVAAttitudeControlFiniteFile"] = IVAAttitudeControlFiniteFile

class IVAAttitudeControlFiniteThrustVector(IVAAttitudeControlFinite):
    """Properties for the Thrust Vector attitude control for a Finite Maneuver."""
    _uuid = "{5928D05A-399E-4773-A934-23E9B9EEF39E}"
    _num_methods = 6
    _vtable_offset = IVAAttitudeControlFinite._vtable_offset + IVAAttitudeControlFinite._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAttitudeUpdate"] = _raise_uninitialized_error
        self.__dict__["_SetAttitudeUpdate"] = _raise_uninitialized_error
        self.__dict__["_GetThrustAxesName"] = _raise_uninitialized_error
        self.__dict__["_SetThrustAxesName"] = _raise_uninitialized_error
        self.__dict__["_GetBodyConstraintVector"] = _raise_uninitialized_error
        self.__dict__["_GetThrustVector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAAttitudeControlFiniteThrustVector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAAttitudeControlFiniteThrustVector from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAAttitudeControlFinite._private_init(self, pUnk)
        IID_IVAAttitudeControlFiniteThrustVector = agcom.GUID(IVAAttitudeControlFiniteThrustVector._uuid)
        vtable_offset_local = IVAAttitudeControlFiniteThrustVector._vtable_offset - 1
        self.__dict__["_GetAttitudeUpdate"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteThrustVector, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetAttitudeUpdate"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteThrustVector, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetThrustAxesName"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteThrustVector, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetThrustAxesName"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteThrustVector, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_GetBodyConstraintVector"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteThrustVector, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_GetThrustVector"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteThrustVector, vtable_offset_local+6, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAAttitudeControlFiniteThrustVector.__dict__ and type(IVAAttitudeControlFiniteThrustVector.__dict__[attrname]) == property:
            return IVAAttitudeControlFiniteThrustVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAAttitudeControlFinite.__setattr__(self, attrname, value)
    
    @property
    def AttitudeUpdate(self) -> "AgEVAAttitudeUpdate":
        """How and when the attitude will be updated."""
        with agmarshall.AgEnum_arg(AgEVAAttitudeUpdate) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAttitudeUpdate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AttitudeUpdate.setter
    def AttitudeUpdate(self, newVal:"AgEVAAttitudeUpdate") -> None:
        with agmarshall.AgEnum_arg(AgEVAAttitudeUpdate, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetAttitudeUpdate"](arg_newVal.COM_val))

    @property
    def ThrustAxesName(self) -> str:
        """The thrust axes."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetThrustAxesName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ThrustAxesName.setter
    def ThrustAxesName(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetThrustAxesName"](arg_newVal.COM_val))

    @property
    def BodyConstraintVector(self) -> "IDirection":
        """Defines a constraint vector in spacecraft body coordinates to complete the attitude definition."""
        with agmarshall.AgInterface_out_arg() as arg_ppDirection:
            agcls.evaluate_hresult(self.__dict__["_GetBodyConstraintVector"](byref(arg_ppDirection.COM_val)))
            return arg_ppDirection.python_val

    @property
    def ThrustVector(self) -> "IDirection":
        """Defines the thrust vector in the reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppDirection:
            agcls.evaluate_hresult(self.__dict__["_GetThrustVector"](byref(arg_ppDirection.COM_val)))
            return arg_ppDirection.python_val


agcls.AgClassCatalog.add_catalog_entry("{5928D05A-399E-4773-A934-23E9B9EEF39E}", IVAAttitudeControlFiniteThrustVector)
agcls.AgTypeNameMap["IVAAttitudeControlFiniteThrustVector"] = IVAAttitudeControlFiniteThrustVector

class IVAAttitudeControlFiniteTimeVarying(IVAAttitudeControlFinite):
    """Properties for the Time Varying attitude control for a Finite Maneuver."""
    _uuid = "{52E48F6D-0FD1-4E30-9398-DCCA988454CE}"
    _num_methods = 35
    _vtable_offset = IVAAttitudeControlFinite._vtable_offset + IVAAttitudeControlFinite._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetThrustAxesName"] = _raise_uninitialized_error
        self.__dict__["_SetThrustAxesName"] = _raise_uninitialized_error
        self.__dict__["_GetBodyConstraintVector"] = _raise_uninitialized_error
        self.__dict__["_GetAz0"] = _raise_uninitialized_error
        self.__dict__["_SetAz0"] = _raise_uninitialized_error
        self.__dict__["_GetAz1"] = _raise_uninitialized_error
        self.__dict__["_SetAz1"] = _raise_uninitialized_error
        self.__dict__["_GetAz2"] = _raise_uninitialized_error
        self.__dict__["_SetAz2"] = _raise_uninitialized_error
        self.__dict__["_GetAz3"] = _raise_uninitialized_error
        self.__dict__["_SetAz3"] = _raise_uninitialized_error
        self.__dict__["_GetAz4"] = _raise_uninitialized_error
        self.__dict__["_SetAz4"] = _raise_uninitialized_error
        self.__dict__["_GetAzA"] = _raise_uninitialized_error
        self.__dict__["_SetAzA"] = _raise_uninitialized_error
        self.__dict__["_GetAzF"] = _raise_uninitialized_error
        self.__dict__["_SetAzF"] = _raise_uninitialized_error
        self.__dict__["_GetAzP"] = _raise_uninitialized_error
        self.__dict__["_SetAzP"] = _raise_uninitialized_error
        self.__dict__["_GetEl0"] = _raise_uninitialized_error
        self.__dict__["_SetEl0"] = _raise_uninitialized_error
        self.__dict__["_GetEl1"] = _raise_uninitialized_error
        self.__dict__["_SetEl1"] = _raise_uninitialized_error
        self.__dict__["_GetEl2"] = _raise_uninitialized_error
        self.__dict__["_SetEl2"] = _raise_uninitialized_error
        self.__dict__["_GetEl3"] = _raise_uninitialized_error
        self.__dict__["_SetEl3"] = _raise_uninitialized_error
        self.__dict__["_GetEl4"] = _raise_uninitialized_error
        self.__dict__["_SetEl4"] = _raise_uninitialized_error
        self.__dict__["_GetElA"] = _raise_uninitialized_error
        self.__dict__["_SetElA"] = _raise_uninitialized_error
        self.__dict__["_GetElF"] = _raise_uninitialized_error
        self.__dict__["_SetElF"] = _raise_uninitialized_error
        self.__dict__["_GetElP"] = _raise_uninitialized_error
        self.__dict__["_SetElP"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAAttitudeControlFiniteTimeVarying._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAAttitudeControlFiniteTimeVarying from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAAttitudeControlFinite._private_init(self, pUnk)
        IID_IVAAttitudeControlFiniteTimeVarying = agcom.GUID(IVAAttitudeControlFiniteTimeVarying._uuid)
        vtable_offset_local = IVAAttitudeControlFiniteTimeVarying._vtable_offset - 1
        self.__dict__["_GetThrustAxesName"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteTimeVarying, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetThrustAxesName"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteTimeVarying, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetBodyConstraintVector"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteTimeVarying, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetAz0"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteTimeVarying, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAz0"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteTimeVarying, vtable_offset_local+5, agcom.DOUBLE)
        self.__dict__["_GetAz1"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteTimeVarying, vtable_offset_local+6, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAz1"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteTimeVarying, vtable_offset_local+7, agcom.DOUBLE)
        self.__dict__["_GetAz2"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteTimeVarying, vtable_offset_local+8, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAz2"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteTimeVarying, vtable_offset_local+9, agcom.DOUBLE)
        self.__dict__["_GetAz3"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteTimeVarying, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAz3"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteTimeVarying, vtable_offset_local+11, agcom.DOUBLE)
        self.__dict__["_GetAz4"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteTimeVarying, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAz4"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteTimeVarying, vtable_offset_local+13, agcom.DOUBLE)
        self.__dict__["_GetAzA"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteTimeVarying, vtable_offset_local+14, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAzA"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteTimeVarying, vtable_offset_local+15, agcom.DOUBLE)
        self.__dict__["_GetAzF"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteTimeVarying, vtable_offset_local+16, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAzF"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteTimeVarying, vtable_offset_local+17, agcom.DOUBLE)
        self.__dict__["_GetAzP"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteTimeVarying, vtable_offset_local+18, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAzP"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteTimeVarying, vtable_offset_local+19, agcom.DOUBLE)
        self.__dict__["_GetEl0"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteTimeVarying, vtable_offset_local+20, POINTER(agcom.DOUBLE))
        self.__dict__["_SetEl0"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteTimeVarying, vtable_offset_local+21, agcom.DOUBLE)
        self.__dict__["_GetEl1"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteTimeVarying, vtable_offset_local+22, POINTER(agcom.DOUBLE))
        self.__dict__["_SetEl1"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteTimeVarying, vtable_offset_local+23, agcom.DOUBLE)
        self.__dict__["_GetEl2"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteTimeVarying, vtable_offset_local+24, POINTER(agcom.DOUBLE))
        self.__dict__["_SetEl2"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteTimeVarying, vtable_offset_local+25, agcom.DOUBLE)
        self.__dict__["_GetEl3"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteTimeVarying, vtable_offset_local+26, POINTER(agcom.DOUBLE))
        self.__dict__["_SetEl3"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteTimeVarying, vtable_offset_local+27, agcom.DOUBLE)
        self.__dict__["_GetEl4"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteTimeVarying, vtable_offset_local+28, POINTER(agcom.DOUBLE))
        self.__dict__["_SetEl4"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteTimeVarying, vtable_offset_local+29, agcom.DOUBLE)
        self.__dict__["_GetElA"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteTimeVarying, vtable_offset_local+30, POINTER(agcom.DOUBLE))
        self.__dict__["_SetElA"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteTimeVarying, vtable_offset_local+31, agcom.DOUBLE)
        self.__dict__["_GetElF"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteTimeVarying, vtable_offset_local+32, POINTER(agcom.DOUBLE))
        self.__dict__["_SetElF"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteTimeVarying, vtable_offset_local+33, agcom.DOUBLE)
        self.__dict__["_GetElP"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteTimeVarying, vtable_offset_local+34, POINTER(agcom.DOUBLE))
        self.__dict__["_SetElP"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteTimeVarying, vtable_offset_local+35, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAAttitudeControlFiniteTimeVarying.__dict__ and type(IVAAttitudeControlFiniteTimeVarying.__dict__[attrname]) == property:
            return IVAAttitudeControlFiniteTimeVarying.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAAttitudeControlFinite.__setattr__(self, attrname, value)
    
    @property
    def ThrustAxesName(self) -> str:
        """The thrust axes."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetThrustAxesName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ThrustAxesName.setter
    def ThrustAxesName(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetThrustAxesName"](arg_newVal.COM_val))

    @property
    def BodyConstraintVector(self) -> "IDirection":
        """Defines a constraint vector in spacecraft body coordinates to complete the attitude definition."""
        with agmarshall.AgInterface_out_arg() as arg_ppDirection:
            agcls.evaluate_hresult(self.__dict__["_GetBodyConstraintVector"](byref(arg_ppDirection.COM_val)))
            return arg_ppDirection.python_val

    @property
    def Az0(self) -> float:
        """Azimuth constant term (dimension: angle)"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAz0"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Az0.setter
    def Az0(self, pVal:float) -> None:
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetAz0"](arg_pVal.COM_val))

    @property
    def Az1(self) -> float:
        """Azimuth linear term (dimension: angle/time)"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAz1"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Az1.setter
    def Az1(self, pVal:float) -> None:
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetAz1"](arg_pVal.COM_val))

    @property
    def Az2(self) -> float:
        """Azimuth quadratic term (dimension: angle/time^2)"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAz2"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Az2.setter
    def Az2(self, pVal:float) -> None:
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetAz2"](arg_pVal.COM_val))

    @property
    def Az3(self) -> float:
        """Azimuth cubic term (dimension: angle/time^3)"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAz3"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Az3.setter
    def Az3(self, pVal:float) -> None:
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetAz3"](arg_pVal.COM_val))

    @property
    def Az4(self) -> float:
        """Azimuth quartic term (dimension: angle/time^4)"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAz4"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Az4.setter
    def Az4(self, pVal:float) -> None:
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetAz4"](arg_pVal.COM_val))

    @property
    def AzA(self) -> float:
        """Azimuth sine term amplitude (dimension: angle)"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAzA"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AzA.setter
    def AzA(self, pVal:float) -> None:
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetAzA"](arg_pVal.COM_val))

    @property
    def AzF(self) -> float:
        """Azimuth sine term frequency (dimension: angle/time)"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAzF"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AzF.setter
    def AzF(self, pVal:float) -> None:
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetAzF"](arg_pVal.COM_val))

    @property
    def AzP(self) -> float:
        """Azimuth sine term phase (dimension: angle)"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAzP"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AzP.setter
    def AzP(self, pVal:float) -> None:
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetAzP"](arg_pVal.COM_val))

    @property
    def El0(self) -> float:
        """Elevation constant term (dimension: angle)"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEl0"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @El0.setter
    def El0(self, pVal:float) -> None:
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetEl0"](arg_pVal.COM_val))

    @property
    def El1(self) -> float:
        """Elevation linear term (dimension: angle/time)"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEl1"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @El1.setter
    def El1(self, pVal:float) -> None:
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetEl1"](arg_pVal.COM_val))

    @property
    def El2(self) -> float:
        """Elevation quadratic term (dimension: angle/time^2)"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEl2"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @El2.setter
    def El2(self, pVal:float) -> None:
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetEl2"](arg_pVal.COM_val))

    @property
    def El3(self) -> float:
        """Elevation cubic term (dimension: angle/time^3)"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEl3"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @El3.setter
    def El3(self, pVal:float) -> None:
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetEl3"](arg_pVal.COM_val))

    @property
    def El4(self) -> float:
        """Elevation quartic term (dimension: angle/time^4)"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEl4"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @El4.setter
    def El4(self, pVal:float) -> None:
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetEl4"](arg_pVal.COM_val))

    @property
    def ElA(self) -> float:
        """Elevation sine term amplitude (dimension: angle)"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElA"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElA.setter
    def ElA(self, pVal:float) -> None:
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetElA"](arg_pVal.COM_val))

    @property
    def ElF(self) -> float:
        """Elevation sine term frequency (dimension: angle/time)"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElF"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElF.setter
    def ElF(self, pVal:float) -> None:
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetElF"](arg_pVal.COM_val))

    @property
    def ElP(self) -> float:
        """Elevation sine term phase (dimension: angle)"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElP"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElP.setter
    def ElP(self, pVal:float) -> None:
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetElP"](arg_pVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{52E48F6D-0FD1-4E30-9398-DCCA988454CE}", IVAAttitudeControlFiniteTimeVarying)
agcls.AgTypeNameMap["IVAAttitudeControlFiniteTimeVarying"] = IVAAttitudeControlFiniteTimeVarying

class IVAAttitudeControlFiniteVelocityVector(IVAAttitudeControlFinite):
    """Properties for the Velocity Vector attitude control for a Finite Maneuver."""
    _uuid = "{0AD7345F-8B3C-474A-A1FC-AF0BA8BE4F38}"
    _num_methods = 3
    _vtable_offset = IVAAttitudeControlFinite._vtable_offset + IVAAttitudeControlFinite._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAttitudeUpdate"] = _raise_uninitialized_error
        self.__dict__["_SetAttitudeUpdate"] = _raise_uninitialized_error
        self.__dict__["_GetBodyConstraintVector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAAttitudeControlFiniteVelocityVector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAAttitudeControlFiniteVelocityVector from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAAttitudeControlFinite._private_init(self, pUnk)
        IID_IVAAttitudeControlFiniteVelocityVector = agcom.GUID(IVAAttitudeControlFiniteVelocityVector._uuid)
        vtable_offset_local = IVAAttitudeControlFiniteVelocityVector._vtable_offset - 1
        self.__dict__["_GetAttitudeUpdate"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteVelocityVector, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetAttitudeUpdate"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteVelocityVector, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetBodyConstraintVector"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFiniteVelocityVector, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAAttitudeControlFiniteVelocityVector.__dict__ and type(IVAAttitudeControlFiniteVelocityVector.__dict__[attrname]) == property:
            return IVAAttitudeControlFiniteVelocityVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAAttitudeControlFinite.__setattr__(self, attrname, value)
    
    @property
    def AttitudeUpdate(self) -> "AgEVAAttitudeUpdate":
        """How and when the attitude will be updated."""
        with agmarshall.AgEnum_arg(AgEVAAttitudeUpdate) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAttitudeUpdate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AttitudeUpdate.setter
    def AttitudeUpdate(self, newVal:"AgEVAAttitudeUpdate") -> None:
        with agmarshall.AgEnum_arg(AgEVAAttitudeUpdate, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetAttitudeUpdate"](arg_newVal.COM_val))

    @property
    def BodyConstraintVector(self) -> "IDirection":
        """Defines a constraint vector in spacecraft body coordinates to complete the attitude definition."""
        with agmarshall.AgInterface_out_arg() as arg_ppDirection:
            agcls.evaluate_hresult(self.__dict__["_GetBodyConstraintVector"](byref(arg_ppDirection.COM_val)))
            return arg_ppDirection.python_val


agcls.AgClassCatalog.add_catalog_entry("{0AD7345F-8B3C-474A-A1FC-AF0BA8BE4F38}", IVAAttitudeControlFiniteVelocityVector)
agcls.AgTypeNameMap["IVAAttitudeControlFiniteVelocityVector"] = IVAAttitudeControlFiniteVelocityVector

class IVAAttitudeControlFinitePlugin(IVAAttitudeControlFinite):
    """Properties for the Plugin attitude control for a Finite Maneuver."""
    _uuid = "{97762200-0ECD-423E-83FA-128D9DBC9C59}"
    _num_methods = 3
    _vtable_offset = IVAAttitudeControlFinite._vtable_offset + IVAAttitudeControlFinite._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_SelectPluginByName"] = _raise_uninitialized_error
        self.__dict__["_GetPluginName"] = _raise_uninitialized_error
        self.__dict__["_GetPluginConfig"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAAttitudeControlFinitePlugin._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAAttitudeControlFinitePlugin from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAAttitudeControlFinite._private_init(self, pUnk)
        IID_IVAAttitudeControlFinitePlugin = agcom.GUID(IVAAttitudeControlFinitePlugin._uuid)
        vtable_offset_local = IVAAttitudeControlFinitePlugin._vtable_offset - 1
        self.__dict__["_SelectPluginByName"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFinitePlugin, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_GetPluginName"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFinitePlugin, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_GetPluginConfig"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlFinitePlugin, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAAttitudeControlFinitePlugin.__dict__ and type(IVAAttitudeControlFinitePlugin.__dict__[attrname]) == property:
            return IVAAttitudeControlFinitePlugin.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAAttitudeControlFinite.__setattr__(self, attrname, value)
    
    def SelectPluginByName(self, name:str) -> None:
        """Selects plugin using the plugin name."""
        with agmarshall.BSTR_arg(name) as arg_name:
            agcls.evaluate_hresult(self.__dict__["_SelectPluginByName"](arg_name.COM_val))

    @property
    def PluginName(self) -> str:
        """The selected plugin's name."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPluginName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def PluginConfig(self) -> "IVAPluginProperties":
        """The properties of the selected plugin."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPluginConfig"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{97762200-0ECD-423E-83FA-128D9DBC9C59}", IVAAttitudeControlFinitePlugin)
agcls.AgTypeNameMap["IVAAttitudeControlFinitePlugin"] = IVAAttitudeControlFinitePlugin

class IVAAttitudeControlOptimalFiniteLagrange(IVAAttitudeControlOptimalFinite):
    """Properties for the Lagrange Interpolation attitude control for a Optimal Finite Maneuver."""
    _uuid = "{5E65B4C8-BFDB-4812-BE54-FF94FEDFDB12}"
    _num_methods = 1
    _vtable_offset = IVAAttitudeControlOptimalFinite._vtable_offset + IVAAttitudeControlOptimalFinite._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetBodyConstraintVector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAAttitudeControlOptimalFiniteLagrange._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAAttitudeControlOptimalFiniteLagrange from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAAttitudeControlOptimalFinite._private_init(self, pUnk)
        IID_IVAAttitudeControlOptimalFiniteLagrange = agcom.GUID(IVAAttitudeControlOptimalFiniteLagrange._uuid)
        vtable_offset_local = IVAAttitudeControlOptimalFiniteLagrange._vtable_offset - 1
        self.__dict__["_GetBodyConstraintVector"] = IAGFUNCTYPE(pUnk, IID_IVAAttitudeControlOptimalFiniteLagrange, vtable_offset_local+1, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAAttitudeControlOptimalFiniteLagrange.__dict__ and type(IVAAttitudeControlOptimalFiniteLagrange.__dict__[attrname]) == property:
            return IVAAttitudeControlOptimalFiniteLagrange.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAAttitudeControlOptimalFinite.__setattr__(self, attrname, value)
    
    @property
    def BodyConstraintVector(self) -> "IDirection":
        """Defines a constraint vector in spacecraft body coordinates to complete the attitude definition."""
        with agmarshall.AgInterface_out_arg() as arg_ppDirection:
            agcls.evaluate_hresult(self.__dict__["_GetBodyConstraintVector"](byref(arg_ppDirection.COM_val)))
            return arg_ppDirection.python_val


agcls.AgClassCatalog.add_catalog_entry("{5E65B4C8-BFDB-4812-BE54-FF94FEDFDB12}", IVAAttitudeControlOptimalFiniteLagrange)
agcls.AgTypeNameMap["IVAAttitudeControlOptimalFiniteLagrange"] = IVAAttitudeControlOptimalFiniteLagrange

class IVAMCSHold(object):
    """Properties for a Hold segment."""
    _uuid = "{E53CB41B-2AFA-40B5-97AE-079CA69F0779}"
    _num_methods = 23
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetStepSize"] = _raise_uninitialized_error
        self.__dict__["_SetStepSize"] = _raise_uninitialized_error
        self.__dict__["_GetHoldFrameName"] = _raise_uninitialized_error
        self.__dict__["_SetHoldFrameName"] = _raise_uninitialized_error
        self.__dict__["_GetEnableHoldAttitude"] = _raise_uninitialized_error
        self.__dict__["_SetEnableHoldAttitude"] = _raise_uninitialized_error
        self.__dict__["_GetStoppingConditions"] = _raise_uninitialized_error
        self.__dict__["_GetMinPropagationTime"] = _raise_uninitialized_error
        self.__dict__["_SetMinPropagationTime"] = _raise_uninitialized_error
        self.__dict__["_GetMaxPropagationTime"] = _raise_uninitialized_error
        self.__dict__["_SetMaxPropagationTime"] = _raise_uninitialized_error
        self.__dict__["_GetEnableMaxPropagationTime"] = _raise_uninitialized_error
        self.__dict__["_SetEnableMaxPropagationTime"] = _raise_uninitialized_error
        self.__dict__["_GetEnableWarningMessage"] = _raise_uninitialized_error
        self.__dict__["_SetEnableWarningMessage"] = _raise_uninitialized_error
        self.__dict__["_EnableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_DisableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_IsControlParameterEnabled"] = _raise_uninitialized_error
        self.__dict__["_GetControlParametersAvailable"] = _raise_uninitialized_error
        self.__dict__["_GetOverrideMaxPropagationTime"] = _raise_uninitialized_error
        self.__dict__["_SetOverrideMaxPropagationTime"] = _raise_uninitialized_error
        self.__dict__["_GetShouldStopForInitiallySurpassedEpochStoppingConditions"] = _raise_uninitialized_error
        self.__dict__["_SetShouldStopForInitiallySurpassedEpochStoppingConditions"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAMCSHold._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAMCSHold from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAMCSHold = agcom.GUID(IVAMCSHold._uuid)
        vtable_offset_local = IVAMCSHold._vtable_offset - 1
        self.__dict__["_GetStepSize"] = IAGFUNCTYPE(pUnk, IID_IVAMCSHold, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetStepSize"] = IAGFUNCTYPE(pUnk, IID_IVAMCSHold, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetHoldFrameName"] = IAGFUNCTYPE(pUnk, IID_IVAMCSHold, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetHoldFrameName"] = IAGFUNCTYPE(pUnk, IID_IVAMCSHold, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_GetEnableHoldAttitude"] = IAGFUNCTYPE(pUnk, IID_IVAMCSHold, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnableHoldAttitude"] = IAGFUNCTYPE(pUnk, IID_IVAMCSHold, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetStoppingConditions"] = IAGFUNCTYPE(pUnk, IID_IVAMCSHold, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetMinPropagationTime"] = IAGFUNCTYPE(pUnk, IID_IVAMCSHold, vtable_offset_local+8, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMinPropagationTime"] = IAGFUNCTYPE(pUnk, IID_IVAMCSHold, vtable_offset_local+9, agcom.DOUBLE)
        self.__dict__["_GetMaxPropagationTime"] = IAGFUNCTYPE(pUnk, IID_IVAMCSHold, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaxPropagationTime"] = IAGFUNCTYPE(pUnk, IID_IVAMCSHold, vtable_offset_local+11, agcom.DOUBLE)
        self.__dict__["_GetEnableMaxPropagationTime"] = IAGFUNCTYPE(pUnk, IID_IVAMCSHold, vtable_offset_local+12, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnableMaxPropagationTime"] = IAGFUNCTYPE(pUnk, IID_IVAMCSHold, vtable_offset_local+13, agcom.VARIANT_BOOL)
        self.__dict__["_GetEnableWarningMessage"] = IAGFUNCTYPE(pUnk, IID_IVAMCSHold, vtable_offset_local+14, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnableWarningMessage"] = IAGFUNCTYPE(pUnk, IID_IVAMCSHold, vtable_offset_local+15, agcom.VARIANT_BOOL)
        self.__dict__["_EnableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAMCSHold, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_DisableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAMCSHold, vtable_offset_local+17, agcom.LONG)
        self.__dict__["_IsControlParameterEnabled"] = IAGFUNCTYPE(pUnk, IID_IVAMCSHold, vtable_offset_local+18, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetControlParametersAvailable"] = IAGFUNCTYPE(pUnk, IID_IVAMCSHold, vtable_offset_local+19, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetOverrideMaxPropagationTime"] = IAGFUNCTYPE(pUnk, IID_IVAMCSHold, vtable_offset_local+20, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetOverrideMaxPropagationTime"] = IAGFUNCTYPE(pUnk, IID_IVAMCSHold, vtable_offset_local+21, agcom.VARIANT_BOOL)
        self.__dict__["_GetShouldStopForInitiallySurpassedEpochStoppingConditions"] = IAGFUNCTYPE(pUnk, IID_IVAMCSHold, vtable_offset_local+22, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetShouldStopForInitiallySurpassedEpochStoppingConditions"] = IAGFUNCTYPE(pUnk, IID_IVAMCSHold, vtable_offset_local+23, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAMCSHold.__dict__ and type(IVAMCSHold.__dict__[attrname]) == property:
            return IVAMCSHold.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAMCSHold.")
    
    @property
    def StepSize(self) -> float:
        """The time interval between calculated ephemeris output points. Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetStepSize"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @StepSize.setter
    def StepSize(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetStepSize"](arg_newVal.COM_val))

    @property
    def HoldFrameName(self) -> str:
        """Hold Frame - the reference frame of the Hold segment."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetHoldFrameName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @HoldFrameName.setter
    def HoldFrameName(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetHoldFrameName"](arg_newVal.COM_val))

    @property
    def EnableHoldAttitude(self) -> bool:
        """Enable Hold Altitude - if true, the spacecraft's attitude is fixed within the hold frame."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnableHoldAttitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EnableHoldAttitude.setter
    def EnableHoldAttitude(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnableHoldAttitude"](arg_newVal.COM_val))

    @property
    def StoppingConditions(self) -> "IVAStoppingConditionCollection":
        """The stopping conditions defined for the segment."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAStoppingConditionCollection:
            agcls.evaluate_hresult(self.__dict__["_GetStoppingConditions"](byref(arg_ppVAStoppingConditionCollection.COM_val)))
            return arg_ppVAStoppingConditionCollection.python_val

    @property
    def MinPropagationTime(self) -> float:
        """Minimum Propagation Time - the minimum time that must elapse from the beginning of the segment until Astrogator will begin checking stopping conditions for satisfaction. Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinPropagationTime"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MinPropagationTime.setter
    def MinPropagationTime(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetMinPropagationTime"](arg_newVal.COM_val))

    @property
    def MaxPropagationTime(self) -> float:
        """Maximum Propagation Time - the maximum propagation time, after which the segment will end regardless of whether the stopping conditions have been satisfied. Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxPropagationTime"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxPropagationTime.setter
    def MaxPropagationTime(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxPropagationTime"](arg_newVal.COM_val))

    @property
    def EnableMaxPropagationTime(self) -> bool:
        """Enable Maximum Propagation Time - if true, the maximum propagation time will be enforced."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnableMaxPropagationTime"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EnableMaxPropagationTime.setter
    def EnableMaxPropagationTime(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnableMaxPropagationTime"](arg_newVal.COM_val))

    @property
    def EnableWarningMessage(self) -> bool:
        """If true, Astrogator will issue a warning message if propagation is stopped by the Maximum Propagation Time parameter."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnableWarningMessage"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EnableWarningMessage.setter
    def EnableWarningMessage(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnableWarningMessage"](arg_newVal.COM_val))

    def EnableControlParameter(self, param:"AgEVAControlAdvanced") -> None:
        """Enables or disables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlAdvanced, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_EnableControlParameter"](arg_param.COM_val))

    def DisableControlParameter(self, param:"AgEVAControlAdvanced") -> None:
        """Disables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlAdvanced, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_DisableControlParameter"](arg_param.COM_val))

    def IsControlParameterEnabled(self, param:"AgEVAControlAdvanced") -> bool:
        """Sees if the specified control is enabled."""
        with agmarshall.AgEnum_arg(AgEVAControlAdvanced, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_IsControlParameterEnabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ControlParametersAvailable(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetControlParametersAvailable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def OverrideMaxPropagationTime(self) -> bool:
        """Override Maximum Propagation Time - if there is a duration or epoch stopping condition that occurs after the maximum propagation time, ignore the maximum propagation time."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetOverrideMaxPropagationTime"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @OverrideMaxPropagationTime.setter
    def OverrideMaxPropagationTime(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetOverrideMaxPropagationTime"](arg_newVal.COM_val))

    @property
    def ShouldStopForInitiallySurpassedEpochStoppingConditions(self) -> bool:
        """Stop immediately if propagation begins beyond an active epoch stopping condition."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetShouldStopForInitiallySurpassedEpochStoppingConditions"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ShouldStopForInitiallySurpassedEpochStoppingConditions.setter
    def ShouldStopForInitiallySurpassedEpochStoppingConditions(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetShouldStopForInitiallySurpassedEpochStoppingConditions"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E53CB41B-2AFA-40B5-97AE-079CA69F0779}", IVAMCSHold)
agcls.AgTypeNameMap["IVAMCSHold"] = IVAMCSHold

class IVAMCSUpdate(object):
    """Properties for an Update segment."""
    _uuid = "{070D13DE-2D3C-4002-8D20-A8483EA1F8E3}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_SetActionAndValue"] = _raise_uninitialized_error
        self.__dict__["_GetAction"] = _raise_uninitialized_error
        self.__dict__["_GetValue"] = _raise_uninitialized_error
        self.__dict__["_SetAction"] = _raise_uninitialized_error
        self.__dict__["_SetValue"] = _raise_uninitialized_error
        self.__dict__["_DisableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_EnableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_IsControlParameterEnabled"] = _raise_uninitialized_error
        self.__dict__["_GetControlParametersAvailable"] = _raise_uninitialized_error
        self.__dict__["_GetUserVariables"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAMCSUpdate._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAMCSUpdate from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAMCSUpdate = agcom.GUID(IVAMCSUpdate._uuid)
        vtable_offset_local = IVAMCSUpdate._vtable_offset - 1
        self.__dict__["_SetActionAndValue"] = IAGFUNCTYPE(pUnk, IID_IVAMCSUpdate, vtable_offset_local+1, agcom.LONG, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_GetAction"] = IAGFUNCTYPE(pUnk, IID_IVAMCSUpdate, vtable_offset_local+2, agcom.LONG, POINTER(agcom.LONG))
        self.__dict__["_GetValue"] = IAGFUNCTYPE(pUnk, IID_IVAMCSUpdate, vtable_offset_local+3, agcom.LONG, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAction"] = IAGFUNCTYPE(pUnk, IID_IVAMCSUpdate, vtable_offset_local+4, agcom.LONG, agcom.LONG)
        self.__dict__["_SetValue"] = IAGFUNCTYPE(pUnk, IID_IVAMCSUpdate, vtable_offset_local+5, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_DisableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAMCSUpdate, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_EnableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAMCSUpdate, vtable_offset_local+7, agcom.LONG)
        self.__dict__["_IsControlParameterEnabled"] = IAGFUNCTYPE(pUnk, IID_IVAMCSUpdate, vtable_offset_local+8, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetControlParametersAvailable"] = IAGFUNCTYPE(pUnk, IID_IVAMCSUpdate, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetUserVariables"] = IAGFUNCTYPE(pUnk, IID_IVAMCSUpdate, vtable_offset_local+10, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAMCSUpdate.__dict__ and type(IVAMCSUpdate.__dict__[attrname]) == property:
            return IVAMCSUpdate.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAMCSUpdate.")
    
    def SetActionAndValue(self, parameterType:"AgEVAUpdateParam", actionType:"AgEVAUpdateAction", value:float) -> None:
        """Sets an action and the new value."""
        with agmarshall.AgEnum_arg(AgEVAUpdateParam, parameterType) as arg_parameterType, \
             agmarshall.AgEnum_arg(AgEVAUpdateAction, actionType) as arg_actionType, \
             agmarshall.DOUBLE_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_SetActionAndValue"](arg_parameterType.COM_val, arg_actionType.COM_val, arg_value.COM_val))

    def GetAction(self, parameterType:"AgEVAUpdateParam") -> "AgEVAUpdateAction":
        """Gets the action type for a parameter."""
        with agmarshall.AgEnum_arg(AgEVAUpdateParam, parameterType) as arg_parameterType, \
             agmarshall.AgEnum_arg(AgEVAUpdateAction) as arg_pActionType:
            agcls.evaluate_hresult(self.__dict__["_GetAction"](arg_parameterType.COM_val, byref(arg_pActionType.COM_val)))
            return arg_pActionType.python_val

    def GetValue(self, parameterType:"AgEVAUpdateParam") -> float:
        """Gets the value type for a parameter."""
        with agmarshall.AgEnum_arg(AgEVAUpdateParam, parameterType) as arg_parameterType, \
             agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetValue"](arg_parameterType.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def SetAction(self, parameterName:"AgEVAUpdateParam", actionType:"AgEVAUpdateAction") -> None:
        """Sets the update action type."""
        with agmarshall.AgEnum_arg(AgEVAUpdateParam, parameterName) as arg_parameterName, \
             agmarshall.AgEnum_arg(AgEVAUpdateAction, actionType) as arg_actionType:
            agcls.evaluate_hresult(self.__dict__["_SetAction"](arg_parameterName.COM_val, arg_actionType.COM_val))

    def SetValue(self, parameterName:"AgEVAUpdateParam", value:float) -> None:
        """Sets the update value."""
        with agmarshall.AgEnum_arg(AgEVAUpdateParam, parameterName) as arg_parameterName, \
             agmarshall.DOUBLE_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_SetValue"](arg_parameterName.COM_val, arg_value.COM_val))

    def DisableControlParameter(self, param:"AgEVAControlUpdate") -> None:
        """Disables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlUpdate, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_DisableControlParameter"](arg_param.COM_val))

    def EnableControlParameter(self, param:"AgEVAControlUpdate") -> None:
        """Enables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlUpdate, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_EnableControlParameter"](arg_param.COM_val))

    def IsControlParameterEnabled(self, param:"AgEVAControlUpdate") -> bool:
        """Sees if the specified control is enabled."""
        with agmarshall.AgEnum_arg(AgEVAControlUpdate, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_IsControlParameterEnabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ControlParametersAvailable(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetControlParametersAvailable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def UserVariables(self) -> "IVAUserVariableUpdateCollection":
        """Interface used to modify user variables for the update segment."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetUserVariables"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{070D13DE-2D3C-4002-8D20-A8483EA1F8E3}", IVAMCSUpdate)
agcls.AgTypeNameMap["IVAMCSUpdate"] = IVAMCSUpdate

class IVAMCSReturn(object):
    """Properties for a Return segment."""
    _uuid = "{9C9AB217-64E6-4697-98F8-3B4BCB34AD62}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReturnControlToParentSequence"] = _raise_uninitialized_error
        self.__dict__["_SetReturnControlToParentSequence"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAMCSReturn._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAMCSReturn from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAMCSReturn = agcom.GUID(IVAMCSReturn._uuid)
        vtable_offset_local = IVAMCSReturn._vtable_offset - 1
        self.__dict__["_GetReturnControlToParentSequence"] = IAGFUNCTYPE(pUnk, IID_IVAMCSReturn, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetReturnControlToParentSequence"] = IAGFUNCTYPE(pUnk, IID_IVAMCSReturn, vtable_offset_local+2, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAMCSReturn.__dict__ and type(IVAMCSReturn.__dict__[attrname]) == property:
            return IVAMCSReturn.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAMCSReturn.")
    
    @property
    def ReturnControlToParentSequence(self) -> "AgEVAReturnControl":
        """The state of the segment."""
        with agmarshall.AgEnum_arg(AgEVAReturnControl) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetReturnControlToParentSequence"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ReturnControlToParentSequence.setter
    def ReturnControlToParentSequence(self, newVal:"AgEVAReturnControl") -> None:
        with agmarshall.AgEnum_arg(AgEVAReturnControl, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetReturnControlToParentSequence"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{9C9AB217-64E6-4697-98F8-3B4BCB34AD62}", IVAMCSReturn)
agcls.AgTypeNameMap["IVAMCSReturn"] = IVAMCSReturn

class IVAMCSStop(object):
    """Properties for a Stop segment."""
    _uuid = "{E6CFAA75-3E0C-4B68-9897-66B5556DCD5B}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEnabled"] = _raise_uninitialized_error
        self.__dict__["_SetEnabled"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAMCSStop._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAMCSStop from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAMCSStop = agcom.GUID(IVAMCSStop._uuid)
        vtable_offset_local = IVAMCSStop._vtable_offset - 1
        self.__dict__["_GetEnabled"] = IAGFUNCTYPE(pUnk, IID_IVAMCSStop, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnabled"] = IAGFUNCTYPE(pUnk, IID_IVAMCSStop, vtable_offset_local+2, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAMCSStop.__dict__ and type(IVAMCSStop.__dict__[attrname]) == property:
            return IVAMCSStop.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAMCSStop.")
    
    @property
    def Enabled(self) -> bool:
        """If true, the segment will stop the execution of the MCS."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnabled"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Enabled.setter
    def Enabled(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnabled"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E6CFAA75-3E0C-4B68-9897-66B5556DCD5B}", IVAMCSStop)
agcls.AgTypeNameMap["IVAMCSStop"] = IVAMCSStop

class IVAProfile(object):
    """General properties for target sequence profiles."""
    _uuid = "{CA331A4E-223E-410B-987C-9BE49AEC33A2}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Copy"] = _raise_uninitialized_error
        self.__dict__["_GetName"] = _raise_uninitialized_error
        self.__dict__["_SetName"] = _raise_uninitialized_error
        self.__dict__["_GetStatus"] = _raise_uninitialized_error
        self.__dict__["_GetUserComment"] = _raise_uninitialized_error
        self.__dict__["_SetUserComment"] = _raise_uninitialized_error
        self.__dict__["_GetMode"] = _raise_uninitialized_error
        self.__dict__["_SetMode"] = _raise_uninitialized_error
        self.__dict__["_GetType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAProfile._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAProfile from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAProfile = agcom.GUID(IVAProfile._uuid)
        vtable_offset_local = IVAProfile._vtable_offset - 1
        self.__dict__["_Copy"] = IAGFUNCTYPE(pUnk, IID_IVAProfile, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetName"] = IAGFUNCTYPE(pUnk, IID_IVAProfile, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_SetName"] = IAGFUNCTYPE(pUnk, IID_IVAProfile, vtable_offset_local+3, agcom.BSTR)
        self.__dict__["_GetStatus"] = IAGFUNCTYPE(pUnk, IID_IVAProfile, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_GetUserComment"] = IAGFUNCTYPE(pUnk, IID_IVAProfile, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_SetUserComment"] = IAGFUNCTYPE(pUnk, IID_IVAProfile, vtable_offset_local+6, agcom.BSTR)
        self.__dict__["_GetMode"] = IAGFUNCTYPE(pUnk, IID_IVAProfile, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetMode"] = IAGFUNCTYPE(pUnk, IID_IVAProfile, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetType"] = IAGFUNCTYPE(pUnk, IID_IVAProfile, vtable_offset_local+9, POINTER(agcom.LONG))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAProfile.__dict__ and type(IVAProfile.__dict__[attrname]) == property:
            return IVAProfile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAProfile.")
    
    def Copy(self) -> "IVAProfile":
        """Makes a copy of the profile."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAProfile:
            agcls.evaluate_hresult(self.__dict__["_Copy"](byref(arg_ppVAProfile.COM_val)))
            return arg_ppVAProfile.python_val

    @property
    def Name(self) -> str:
        """The name of the profile."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Name.setter
    def Name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetName"](arg_inVal.COM_val))

    @property
    def Status(self) -> str:
        """The status of the profile."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetStatus"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def UserComment(self) -> str:
        """A user comment."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUserComment"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UserComment.setter
    def UserComment(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUserComment"](arg_inVal.COM_val))

    @property
    def Mode(self) -> "AgEVAProfileMode":
        """The profile's mode."""
        with agmarshall.AgEnum_arg(AgEVAProfileMode) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Mode.setter
    def Mode(self, inVal:"AgEVAProfileMode") -> None:
        with agmarshall.AgEnum_arg(AgEVAProfileMode, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMode"](arg_inVal.COM_val))

    @property
    def Type(self) -> "AgEVAProfile":
        """Return the current profile type."""
        with agmarshall.AgEnum_arg(AgEVAProfile) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{CA331A4E-223E-410B-987C-9BE49AEC33A2}", IVAProfile)
agcls.AgTypeNameMap["IVAProfile"] = IVAProfile

class IVAProfileCollection(object):
    """Properties for a list of target sequence profiles."""
    _uuid = "{BA4A3DD4-79DF-4E22-A71B-A0F0A484CA5A}"
    _num_methods = 14
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Add"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetAvailableProfiles"] = _raise_uninitialized_error
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_RemoveAll"] = _raise_uninitialized_error
        self.__dict__["_GetProvideRuntimeTypeInfo"] = _raise_uninitialized_error
        self.__dict__["_Cut"] = _raise_uninitialized_error
        self.__dict__["_Paste"] = _raise_uninitialized_error
        self.__dict__["_InsertCopy"] = _raise_uninitialized_error
        self.__dict__["_Add2"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAProfileCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAProfileCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAProfileCollection = agcom.GUID(IVAProfileCollection._uuid)
        vtable_offset_local = IVAProfileCollection._vtable_offset - 1
        self.__dict__["_Add"] = IAGFUNCTYPE(pUnk, IID_IVAProfileCollection, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVAProfileCollection, vtable_offset_local+2, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVAProfileCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVAProfileCollection, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetAvailableProfiles"] = IAGFUNCTYPE(pUnk, IID_IVAProfileCollection, vtable_offset_local+5, POINTER(agcom.SAFEARRAY))
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IVAProfileCollection, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_RemoveAll"] = IAGFUNCTYPE(pUnk, IID_IVAProfileCollection, vtable_offset_local+7, )
        self.__dict__["_GetProvideRuntimeTypeInfo"] = IAGFUNCTYPE(pUnk, IID_IVAProfileCollection, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_Cut"] = IAGFUNCTYPE(pUnk, IID_IVAProfileCollection, vtable_offset_local+9, agcom.VARIANT)
        self.__dict__["_Paste"] = IAGFUNCTYPE(pUnk, IID_IVAProfileCollection, vtable_offset_local+10, agcom.VARIANT, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_InsertCopy"] = IAGFUNCTYPE(pUnk, IID_IVAProfileCollection, vtable_offset_local+11, agcom.PVOID, agcom.VARIANT, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_Add2"] = IAGFUNCTYPE(pUnk, IID_IVAProfileCollection, vtable_offset_local+12, agcom.BSTR, agcom.VARIANT, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IVAProfileCollection, vtable_offset_local+13, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IVAProfileCollection, vtable_offset_local+14, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAProfileCollection.__dict__ and type(IVAProfileCollection.__dict__[attrname]) == property:
            return IVAProfileCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAProfileCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVAProfile":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Add(self, profileName:str) -> "IVAProfile":
        """Adds a profile."""
        with agmarshall.BSTR_arg(profileName) as arg_profileName, \
             agmarshall.AgInterface_out_arg() as arg_ppVAProfile:
            agcls.evaluate_hresult(self.__dict__["_Add"](arg_profileName.COM_val, byref(arg_ppVAProfile.COM_val)))
            return arg_ppVAProfile.python_val

    def Item(self, indexOrName:typing.Any) -> "IVAProfile":
        """Allows you to iterate through the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppVAProfile:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppVAProfile.COM_val)))
            return arg_ppVAProfile.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def AvailableProfiles(self) -> list:
        """Returns a list of available profiles."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetAvailableProfiles"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Remove(self, indexOrProfileName:typing.Any) -> None:
        """Removes an item from the profile collection."""
        with agmarshall.VARIANT_arg(indexOrProfileName) as arg_indexOrProfileName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_indexOrProfileName.COM_val))

    def RemoveAll(self) -> None:
        """Removes all profiles from the profile collection."""
        agcls.evaluate_hresult(self.__dict__["_RemoveAll"]())

    @property
    def ProvideRuntimeTypeInfo(self) -> "IRuntimeTypeInfo":
        """Returns the IAgRuntimeTypeInfo interface to access properties at runtime."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProvideRuntimeTypeInfo"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Cut(self, indexOrName:typing.Any) -> None:
        """Copies the profile into the clipboard and removes profile from the list."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_Cut"](arg_indexOrName.COM_val))

    def Paste(self, indexOrName:typing.Any, direction:"AgEVAProfileInsertDirection") -> "IVAProfile":
        """Pastes the profile from the clipboard and inserts into the list."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgEnum_arg(AgEVAProfileInsertDirection, direction) as arg_direction, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Paste"](arg_indexOrName.COM_val, arg_direction.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def InsertCopy(self, profile:"IVAProfile", indexOrName:typing.Any, direction:"AgEVAProfileInsertDirection") -> "IVAProfile":
        """Copies the profile and inserts the copy into the list."""
        with agmarshall.AgInterface_in_arg(profile, IVAProfile) as arg_profile, \
             agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgEnum_arg(AgEVAProfileInsertDirection, direction) as arg_direction, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_InsertCopy"](arg_profile.COM_val, arg_indexOrName.COM_val, arg_direction.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Add2(self, profileName:str, indexOrName:typing.Any, direction:"AgEVAProfileInsertDirection") -> "IVAProfile":
        """Adds a profile."""
        with agmarshall.BSTR_arg(profileName) as arg_profileName, \
             agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgEnum_arg(AgEVAProfileInsertDirection, direction) as arg_direction, \
             agmarshall.AgInterface_out_arg() as arg_ppVAProfile:
            agcls.evaluate_hresult(self.__dict__["_Add2"](arg_profileName.COM_val, arg_indexOrName.COM_val, arg_direction.COM_val, byref(arg_ppVAProfile.COM_val)))
            return arg_ppVAProfile.python_val

    def GetItemByIndex(self, index:int) -> "IVAProfile":
        """Retrieves a profile from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppVAProfile:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppVAProfile.COM_val)))
            return arg_ppVAProfile.python_val

    def GetItemByName(self, name:str) -> "IVAProfile":
        """Retrieves a profile from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppVAProfile:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppVAProfile.COM_val)))
            return arg_ppVAProfile.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{BA4A3DD4-79DF-4E22-A71B-A0F0A484CA5A}", IVAProfileCollection)
agcls.AgTypeNameMap["IVAProfileCollection"] = IVAProfileCollection

class IVAMCSTargetSequence(object):
    """General properties of a TargetSequence segment."""
    _uuid = "{703A8064-AB76-41FC-AADA-5134C30DB1C9}"
    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAction"] = _raise_uninitialized_error
        self.__dict__["_SetAction"] = _raise_uninitialized_error
        self.__dict__["_GetWhenProfilesFinish"] = _raise_uninitialized_error
        self.__dict__["_SetWhenProfilesFinish"] = _raise_uninitialized_error
        self.__dict__["_GetContinueOnFailure"] = _raise_uninitialized_error
        self.__dict__["_SetContinueOnFailure"] = _raise_uninitialized_error
        self.__dict__["_GetSegments"] = _raise_uninitialized_error
        self.__dict__["_GetProfiles"] = _raise_uninitialized_error
        self.__dict__["_ApplyProfiles"] = _raise_uninitialized_error
        self.__dict__["_ResetProfiles"] = _raise_uninitialized_error
        self.__dict__["_ApplyProfile"] = _raise_uninitialized_error
        self.__dict__["_ResetProfile"] = _raise_uninitialized_error
        self.__dict__["_ApplyProfileByName"] = _raise_uninitialized_error
        self.__dict__["_ResetProfileByName"] = _raise_uninitialized_error
        self.__dict__["_GetResetInnerTargeters"] = _raise_uninitialized_error
        self.__dict__["_SetResetInnerTargeters"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAMCSTargetSequence._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAMCSTargetSequence from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAMCSTargetSequence = agcom.GUID(IVAMCSTargetSequence._uuid)
        vtable_offset_local = IVAMCSTargetSequence._vtable_offset - 1
        self.__dict__["_GetAction"] = IAGFUNCTYPE(pUnk, IID_IVAMCSTargetSequence, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetAction"] = IAGFUNCTYPE(pUnk, IID_IVAMCSTargetSequence, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetWhenProfilesFinish"] = IAGFUNCTYPE(pUnk, IID_IVAMCSTargetSequence, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetWhenProfilesFinish"] = IAGFUNCTYPE(pUnk, IID_IVAMCSTargetSequence, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetContinueOnFailure"] = IAGFUNCTYPE(pUnk, IID_IVAMCSTargetSequence, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetContinueOnFailure"] = IAGFUNCTYPE(pUnk, IID_IVAMCSTargetSequence, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetSegments"] = IAGFUNCTYPE(pUnk, IID_IVAMCSTargetSequence, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetProfiles"] = IAGFUNCTYPE(pUnk, IID_IVAMCSTargetSequence, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_ApplyProfiles"] = IAGFUNCTYPE(pUnk, IID_IVAMCSTargetSequence, vtable_offset_local+9, )
        self.__dict__["_ResetProfiles"] = IAGFUNCTYPE(pUnk, IID_IVAMCSTargetSequence, vtable_offset_local+10, )
        self.__dict__["_ApplyProfile"] = IAGFUNCTYPE(pUnk, IID_IVAMCSTargetSequence, vtable_offset_local+11, agcom.PVOID)
        self.__dict__["_ResetProfile"] = IAGFUNCTYPE(pUnk, IID_IVAMCSTargetSequence, vtable_offset_local+12, agcom.PVOID)
        self.__dict__["_ApplyProfileByName"] = IAGFUNCTYPE(pUnk, IID_IVAMCSTargetSequence, vtable_offset_local+13, agcom.BSTR)
        self.__dict__["_ResetProfileByName"] = IAGFUNCTYPE(pUnk, IID_IVAMCSTargetSequence, vtable_offset_local+14, agcom.BSTR)
        self.__dict__["_GetResetInnerTargeters"] = IAGFUNCTYPE(pUnk, IID_IVAMCSTargetSequence, vtable_offset_local+15, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetResetInnerTargeters"] = IAGFUNCTYPE(pUnk, IID_IVAMCSTargetSequence, vtable_offset_local+16, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAMCSTargetSequence.__dict__ and type(IVAMCSTargetSequence.__dict__[attrname]) == property:
            return IVAMCSTargetSequence.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAMCSTargetSequence.")
    
    @property
    def Action(self) -> "AgEVATargetSeqAction":
        """Whether to run the sequence nominally or using profiles."""
        with agmarshall.AgEnum_arg(AgEVATargetSeqAction) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAction"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Action.setter
    def Action(self, newVal:"AgEVATargetSeqAction") -> None:
        with agmarshall.AgEnum_arg(AgEVATargetSeqAction, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetAction"](arg_newVal.COM_val))

    @property
    def WhenProfilesFinish(self) -> "AgEVAProfilesFinish":
        """When Profiles Converge - the action to be carried out if targeting has converged."""
        with agmarshall.AgEnum_arg(AgEVAProfilesFinish) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetWhenProfilesFinish"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @WhenProfilesFinish.setter
    def WhenProfilesFinish(self, newVal:"AgEVAProfilesFinish") -> None:
        with agmarshall.AgEnum_arg(AgEVAProfilesFinish, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetWhenProfilesFinish"](arg_newVal.COM_val))

    @property
    def ContinueOnFailure(self) -> bool:
        """Continue if profiles don't converge - if true, the target sequence continues if a profile fails to converge; otherwise, the MCS will stop upon the failure of a search profile."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetContinueOnFailure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ContinueOnFailure.setter
    def ContinueOnFailure(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetContinueOnFailure"](arg_newVal.COM_val))

    @property
    def Segments(self) -> "IVAMCSSegmentCollection":
        """Returns the segments contained within the target sequence."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAMCSSegmentCollection:
            agcls.evaluate_hresult(self.__dict__["_GetSegments"](byref(arg_ppVAMCSSegmentCollection.COM_val)))
            return arg_ppVAMCSSegmentCollection.python_val

    @property
    def Profiles(self) -> "IVAProfileCollection":
        """Returns the profiles used within the target sequence."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAProfileCollection:
            agcls.evaluate_hresult(self.__dict__["_GetProfiles"](byref(arg_ppVAProfileCollection.COM_val)))
            return arg_ppVAProfileCollection.python_val

    def ApplyProfiles(self) -> None:
        """Apply Changes - applies the current values of search profiles' controls and the changes specified by the segment configuration profiles to the segments within the target sequence."""
        agcls.evaluate_hresult(self.__dict__["_ApplyProfiles"]())

    def ResetProfiles(self) -> None:
        """Reset - resets the controls of the search profiles to the segments' values."""
        agcls.evaluate_hresult(self.__dict__["_ResetProfiles"]())

    def ApplyProfile(self, profile:"IVAProfile") -> None:
        """Apply Changes - applies the current values of specified profile to the segments within the target sequence."""
        with agmarshall.AgInterface_in_arg(profile, IVAProfile) as arg_profile:
            agcls.evaluate_hresult(self.__dict__["_ApplyProfile"](arg_profile.COM_val))

    def ResetProfile(self, profile:"IVAProfile") -> None:
        """Reset - resets the current values of specified profile."""
        with agmarshall.AgInterface_in_arg(profile, IVAProfile) as arg_profile:
            agcls.evaluate_hresult(self.__dict__["_ResetProfile"](arg_profile.COM_val))

    def ApplyProfileByName(self, profile:str) -> None:
        """Apply Changes - applies the current values of specified profile to the segments within the target sequence."""
        with agmarshall.BSTR_arg(profile) as arg_profile:
            agcls.evaluate_hresult(self.__dict__["_ApplyProfileByName"](arg_profile.COM_val))

    def ResetProfileByName(self, profile:str) -> None:
        """Reset - resets the current values of specified profile."""
        with agmarshall.BSTR_arg(profile) as arg_profile:
            agcls.evaluate_hresult(self.__dict__["_ResetProfileByName"](arg_profile.COM_val))

    @property
    def ResetInnerTargeters(self) -> bool:
        """If true, inner target sequences will have their profiles reset before each run."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetResetInnerTargeters"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ResetInnerTargeters.setter
    def ResetInnerTargeters(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetResetInnerTargeters"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{703A8064-AB76-41FC-AADA-5134C30DB1C9}", IVAMCSTargetSequence)
agcls.AgTypeNameMap["IVAMCSTargetSequence"] = IVAMCSTargetSequence

class IVADCControl(object):
    """Properties for control parameters of a differential corrector profile."""
    _uuid = "{5F55DF8A-688A-48E6-A084-48E270AB766E}"
    _num_methods = 25
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEnable"] = _raise_uninitialized_error
        self.__dict__["_SetEnable"] = _raise_uninitialized_error
        self.__dict__["_GetName"] = _raise_uninitialized_error
        self.__dict__["_GetFinalValue"] = _raise_uninitialized_error
        self.__dict__["_GetLastUpdate"] = _raise_uninitialized_error
        self.__dict__["_GetParentName"] = _raise_uninitialized_error
        self.__dict__["_GetInitialValue"] = _raise_uninitialized_error
        self.__dict__["_GetPerturbation"] = _raise_uninitialized_error
        self.__dict__["_SetPerturbation"] = _raise_uninitialized_error
        self.__dict__["_GetCorrection"] = _raise_uninitialized_error
        self.__dict__["_SetCorrection"] = _raise_uninitialized_error
        self.__dict__["_GetTolerance"] = _raise_uninitialized_error
        self.__dict__["_SetTolerance"] = _raise_uninitialized_error
        self.__dict__["_GetMaxStep"] = _raise_uninitialized_error
        self.__dict__["_SetMaxStep"] = _raise_uninitialized_error
        self.__dict__["_GetScalingMethod"] = _raise_uninitialized_error
        self.__dict__["_SetScalingMethod"] = _raise_uninitialized_error
        self.__dict__["_GetScalingValue"] = _raise_uninitialized_error
        self.__dict__["_SetScalingValue"] = _raise_uninitialized_error
        self.__dict__["_GetDimension"] = _raise_uninitialized_error
        self.__dict__["_GetUseCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_SetUseCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_GetCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_SetCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_GetValues"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVADCControl._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVADCControl from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVADCControl = agcom.GUID(IVADCControl._uuid)
        vtable_offset_local = IVADCControl._vtable_offset - 1
        self.__dict__["_GetEnable"] = IAGFUNCTYPE(pUnk, IID_IVADCControl, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnable"] = IAGFUNCTYPE(pUnk, IID_IVADCControl, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetName"] = IAGFUNCTYPE(pUnk, IID_IVADCControl, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_GetFinalValue"] = IAGFUNCTYPE(pUnk, IID_IVADCControl, vtable_offset_local+4, POINTER(agcom.VARIANT))
        self.__dict__["_GetLastUpdate"] = IAGFUNCTYPE(pUnk, IID_IVADCControl, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_GetParentName"] = IAGFUNCTYPE(pUnk, IID_IVADCControl, vtable_offset_local+6, POINTER(agcom.BSTR))
        self.__dict__["_GetInitialValue"] = IAGFUNCTYPE(pUnk, IID_IVADCControl, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_GetPerturbation"] = IAGFUNCTYPE(pUnk, IID_IVADCControl, vtable_offset_local+8, POINTER(agcom.VARIANT))
        self.__dict__["_SetPerturbation"] = IAGFUNCTYPE(pUnk, IID_IVADCControl, vtable_offset_local+9, agcom.VARIANT)
        self.__dict__["_GetCorrection"] = IAGFUNCTYPE(pUnk, IID_IVADCControl, vtable_offset_local+10, POINTER(agcom.VARIANT))
        self.__dict__["_SetCorrection"] = IAGFUNCTYPE(pUnk, IID_IVADCControl, vtable_offset_local+11, agcom.VARIANT)
        self.__dict__["_GetTolerance"] = IAGFUNCTYPE(pUnk, IID_IVADCControl, vtable_offset_local+12, POINTER(agcom.VARIANT))
        self.__dict__["_SetTolerance"] = IAGFUNCTYPE(pUnk, IID_IVADCControl, vtable_offset_local+13, agcom.VARIANT)
        self.__dict__["_GetMaxStep"] = IAGFUNCTYPE(pUnk, IID_IVADCControl, vtable_offset_local+14, POINTER(agcom.VARIANT))
        self.__dict__["_SetMaxStep"] = IAGFUNCTYPE(pUnk, IID_IVADCControl, vtable_offset_local+15, agcom.VARIANT)
        self.__dict__["_GetScalingMethod"] = IAGFUNCTYPE(pUnk, IID_IVADCControl, vtable_offset_local+16, POINTER(agcom.LONG))
        self.__dict__["_SetScalingMethod"] = IAGFUNCTYPE(pUnk, IID_IVADCControl, vtable_offset_local+17, agcom.LONG)
        self.__dict__["_GetScalingValue"] = IAGFUNCTYPE(pUnk, IID_IVADCControl, vtable_offset_local+18, POINTER(agcom.VARIANT))
        self.__dict__["_SetScalingValue"] = IAGFUNCTYPE(pUnk, IID_IVADCControl, vtable_offset_local+19, agcom.VARIANT)
        self.__dict__["_GetDimension"] = IAGFUNCTYPE(pUnk, IID_IVADCControl, vtable_offset_local+20, POINTER(agcom.BSTR))
        self.__dict__["_GetUseCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVADCControl, vtable_offset_local+21, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVADCControl, vtable_offset_local+22, agcom.VARIANT_BOOL)
        self.__dict__["_GetCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVADCControl, vtable_offset_local+23, POINTER(agcom.BSTR))
        self.__dict__["_SetCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVADCControl, vtable_offset_local+24, agcom.BSTR)
        self.__dict__["_GetValues"] = IAGFUNCTYPE(pUnk, IID_IVADCControl, vtable_offset_local+25, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVADCControl.__dict__ and type(IVADCControl.__dict__[attrname]) == property:
            return IVADCControl.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVADCControl.")
    
    @property
    def Enable(self) -> bool:
        """If true, the variable is being used."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Enable.setter
    def Enable(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnable"](arg_newVal.COM_val))

    @property
    def Name(self) -> str:
        """The name of the parameter."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def FinalValue(self) -> typing.Any:
        """The value of the independent variable after the last targeter run."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetFinalValue"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def LastUpdate(self) -> typing.Any:
        """The amount by which the value of the independent variable changed during the last targeter run."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLastUpdate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ParentName(self) -> str:
        """The name of the segment to which the parameter belongs."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetParentName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def InitialValue(self) -> typing.Any:
        """The nominal value of the element selected as a parameter. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetInitialValue"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def Perturbation(self) -> typing.Any:
        """The value to be used in calculating numerical derivatives. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPerturbation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Perturbation.setter
    def Perturbation(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetPerturbation"](arg_newVal.COM_val))

    @property
    def Correction(self) -> typing.Any:
        """The amount by which the nominal value of the parameter should be corrected to achieve the selected goals. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCorrection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Correction.setter
    def Correction(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCorrection"](arg_newVal.COM_val))

    @property
    def Tolerance(self) -> typing.Any:
        """The smallest update to the parameter to be made before the targeter stops. Only used if the convergence criteria is set to 'Either equality constraints or last control parameter updates within tolerance'. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTolerance"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Tolerance.setter
    def Tolerance(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTolerance"](arg_newVal.COM_val))

    @property
    def MaxStep(self) -> typing.Any:
        """The maximum increment to make to the value of the parameter in any one step. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxStep.setter
    def MaxStep(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxStep"](arg_newVal.COM_val))

    @property
    def ScalingMethod(self) -> "AgEVADCScalingMethod":
        """Allows better numerical behavior if the parameters have very different magnitudes. The same scaling method is applied to all parameters."""
        with agmarshall.AgEnum_arg(AgEVADCScalingMethod) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetScalingMethod"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ScalingMethod.setter
    def ScalingMethod(self, newVal:"AgEVADCScalingMethod") -> None:
        with agmarshall.AgEnum_arg(AgEVADCScalingMethod, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetScalingMethod"](arg_newVal.COM_val))

    @property
    def ScalingValue(self) -> typing.Any:
        """Applies to the Specified Value scaling method. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetScalingValue"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ScalingValue.setter
    def ScalingValue(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetScalingValue"](arg_newVal.COM_val))

    @property
    def Dimension(self) -> str:
        """Dimension of the constraint."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDimension"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def UseCustomDisplayUnit(self) -> bool:
        """If true, allows display of values in another unit."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCustomDisplayUnit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseCustomDisplayUnit.setter
    def UseCustomDisplayUnit(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseCustomDisplayUnit"](arg_newVal.COM_val))

    @property
    def CustomDisplayUnit(self) -> str:
        """The unit in which the value will be displayed in the GUI."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCustomDisplayUnit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CustomDisplayUnit.setter
    def CustomDisplayUnit(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCustomDisplayUnit"](arg_newVal.COM_val))

    @property
    def Values(self) -> list:
        """List of values of this independent variable at each iteration, including nominal run. Dimension depends on context."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetValues"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{5F55DF8A-688A-48E6-A084-48E270AB766E}", IVADCControl)
agcls.AgTypeNameMap["IVADCControl"] = IVADCControl

class IVADCResult(object):
    """Properties for equality constraints of a differential corrector profile."""
    _uuid = "{F55E0916-7FAE-469B-AB4F-9D09C26BB554}"
    _num_methods = 22
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEnable"] = _raise_uninitialized_error
        self.__dict__["_SetEnable"] = _raise_uninitialized_error
        self.__dict__["_GetName"] = _raise_uninitialized_error
        self.__dict__["_GetDesiredValue"] = _raise_uninitialized_error
        self.__dict__["_SetDesiredValue"] = _raise_uninitialized_error
        self.__dict__["_GetCurrentValue"] = _raise_uninitialized_error
        self.__dict__["_GetParentName"] = _raise_uninitialized_error
        self.__dict__["_GetDifference"] = _raise_uninitialized_error
        self.__dict__["_GetTolerance"] = _raise_uninitialized_error
        self.__dict__["_SetTolerance"] = _raise_uninitialized_error
        self.__dict__["_GetScalingMethod"] = _raise_uninitialized_error
        self.__dict__["_SetScalingMethod"] = _raise_uninitialized_error
        self.__dict__["_GetScalingValue"] = _raise_uninitialized_error
        self.__dict__["_SetScalingValue"] = _raise_uninitialized_error
        self.__dict__["_GetWeight"] = _raise_uninitialized_error
        self.__dict__["_SetWeight"] = _raise_uninitialized_error
        self.__dict__["_GetDimension"] = _raise_uninitialized_error
        self.__dict__["_GetUseCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_SetUseCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_GetCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_SetCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_GetValues"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVADCResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVADCResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVADCResult = agcom.GUID(IVADCResult._uuid)
        vtable_offset_local = IVADCResult._vtable_offset - 1
        self.__dict__["_GetEnable"] = IAGFUNCTYPE(pUnk, IID_IVADCResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnable"] = IAGFUNCTYPE(pUnk, IID_IVADCResult, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetName"] = IAGFUNCTYPE(pUnk, IID_IVADCResult, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_GetDesiredValue"] = IAGFUNCTYPE(pUnk, IID_IVADCResult, vtable_offset_local+4, POINTER(agcom.VARIANT))
        self.__dict__["_SetDesiredValue"] = IAGFUNCTYPE(pUnk, IID_IVADCResult, vtable_offset_local+5, agcom.VARIANT)
        self.__dict__["_GetCurrentValue"] = IAGFUNCTYPE(pUnk, IID_IVADCResult, vtable_offset_local+6, POINTER(agcom.VARIANT))
        self.__dict__["_GetParentName"] = IAGFUNCTYPE(pUnk, IID_IVADCResult, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_GetDifference"] = IAGFUNCTYPE(pUnk, IID_IVADCResult, vtable_offset_local+8, POINTER(agcom.VARIANT))
        self.__dict__["_GetTolerance"] = IAGFUNCTYPE(pUnk, IID_IVADCResult, vtable_offset_local+9, POINTER(agcom.VARIANT))
        self.__dict__["_SetTolerance"] = IAGFUNCTYPE(pUnk, IID_IVADCResult, vtable_offset_local+10, agcom.VARIANT)
        self.__dict__["_GetScalingMethod"] = IAGFUNCTYPE(pUnk, IID_IVADCResult, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_SetScalingMethod"] = IAGFUNCTYPE(pUnk, IID_IVADCResult, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_GetScalingValue"] = IAGFUNCTYPE(pUnk, IID_IVADCResult, vtable_offset_local+13, POINTER(agcom.VARIANT))
        self.__dict__["_SetScalingValue"] = IAGFUNCTYPE(pUnk, IID_IVADCResult, vtable_offset_local+14, agcom.VARIANT)
        self.__dict__["_GetWeight"] = IAGFUNCTYPE(pUnk, IID_IVADCResult, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_SetWeight"] = IAGFUNCTYPE(pUnk, IID_IVADCResult, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_GetDimension"] = IAGFUNCTYPE(pUnk, IID_IVADCResult, vtable_offset_local+17, POINTER(agcom.BSTR))
        self.__dict__["_GetUseCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVADCResult, vtable_offset_local+18, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVADCResult, vtable_offset_local+19, agcom.VARIANT_BOOL)
        self.__dict__["_GetCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVADCResult, vtable_offset_local+20, POINTER(agcom.BSTR))
        self.__dict__["_SetCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVADCResult, vtable_offset_local+21, agcom.BSTR)
        self.__dict__["_GetValues"] = IAGFUNCTYPE(pUnk, IID_IVADCResult, vtable_offset_local+22, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVADCResult.__dict__ and type(IVADCResult.__dict__[attrname]) == property:
            return IVADCResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVADCResult.")
    
    @property
    def Enable(self) -> bool:
        """If true, the variable is being used."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Enable.setter
    def Enable(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnable"](arg_newVal.COM_val))

    @property
    def Name(self) -> str:
        """The name of the parameter."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def DesiredValue(self) -> typing.Any:
        """The desired value. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDesiredValue"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DesiredValue.setter
    def DesiredValue(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetDesiredValue"](arg_newVal.COM_val))

    @property
    def CurrentValue(self) -> typing.Any:
        """The value achieved for this dependent variable in the last targeter run. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCurrentValue"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ParentName(self) -> str:
        """Object - the name of the segment to which the parameter belongs."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetParentName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def Difference(self) -> typing.Any:
        """The difference between the current and desired value for this dependent variable. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDifference"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def Tolerance(self) -> typing.Any:
        """How close the targeter should come to the desired value before stopping. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTolerance"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Tolerance.setter
    def Tolerance(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTolerance"](arg_newVal.COM_val))

    @property
    def ScalingMethod(self) -> "AgEVADCScalingMethod":
        """Allows better numerical behavior if the constraints have very different magnitudes. The same scaling method is applied to all constraints."""
        with agmarshall.AgEnum_arg(AgEVADCScalingMethod) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetScalingMethod"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ScalingMethod.setter
    def ScalingMethod(self, newVal:"AgEVADCScalingMethod") -> None:
        with agmarshall.AgEnum_arg(AgEVADCScalingMethod, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetScalingMethod"](arg_newVal.COM_val))

    @property
    def ScalingValue(self) -> typing.Any:
        """Applies to the Specified Value scaling method. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetScalingValue"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ScalingValue.setter
    def ScalingValue(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetScalingValue"](arg_newVal.COM_val))

    @property
    def Weight(self) -> float:
        """The factor by which the constraint error is to be multiplied. This is used to emphasize/de-emphasize the importance of one constraint relative to the others. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetWeight"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Weight.setter
    def Weight(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetWeight"](arg_newVal.COM_val))

    @property
    def Dimension(self) -> str:
        """The dimension of the values."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDimension"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def UseCustomDisplayUnit(self) -> bool:
        """If true, allows display of values in another unit."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCustomDisplayUnit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseCustomDisplayUnit.setter
    def UseCustomDisplayUnit(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseCustomDisplayUnit"](arg_newVal.COM_val))

    @property
    def CustomDisplayUnit(self) -> str:
        """The unit in which the value will be displayed in the GUI."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCustomDisplayUnit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CustomDisplayUnit.setter
    def CustomDisplayUnit(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCustomDisplayUnit"](arg_newVal.COM_val))

    @property
    def Values(self) -> list:
        """List of values of this dependent variable at each iteration, including nominal run. Dimension depends on context."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetValues"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{F55E0916-7FAE-469B-AB4F-9D09C26BB554}", IVADCResult)
agcls.AgTypeNameMap["IVADCResult"] = IVADCResult

class IVASearchPluginControl(object):
    """Properties of search plugin control parameters."""
    _uuid = "{71AB197F-79CB-438C-8F0A-A48FA0069865}"
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetControlName"] = _raise_uninitialized_error
        self.__dict__["_GetCurrentValue"] = _raise_uninitialized_error
        self.__dict__["_GetParentSegmentName"] = _raise_uninitialized_error
        self.__dict__["_GetInitialValue"] = _raise_uninitialized_error
        self.__dict__["_GetPluginIdentifier"] = _raise_uninitialized_error
        self.__dict__["_GetPluginConfig"] = _raise_uninitialized_error
        self.__dict__["_GetDimension"] = _raise_uninitialized_error
        self.__dict__["_GetUseCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_SetUseCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_GetCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_SetCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_GetValues"] = _raise_uninitialized_error
        self.__dict__["_SetCurrentValue"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVASearchPluginControl._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVASearchPluginControl from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVASearchPluginControl = agcom.GUID(IVASearchPluginControl._uuid)
        vtable_offset_local = IVASearchPluginControl._vtable_offset - 1
        self.__dict__["_GetControlName"] = IAGFUNCTYPE(pUnk, IID_IVASearchPluginControl, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_GetCurrentValue"] = IAGFUNCTYPE(pUnk, IID_IVASearchPluginControl, vtable_offset_local+2, POINTER(agcom.VARIANT))
        self.__dict__["_GetParentSegmentName"] = IAGFUNCTYPE(pUnk, IID_IVASearchPluginControl, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_GetInitialValue"] = IAGFUNCTYPE(pUnk, IID_IVASearchPluginControl, vtable_offset_local+4, POINTER(agcom.VARIANT))
        self.__dict__["_GetPluginIdentifier"] = IAGFUNCTYPE(pUnk, IID_IVASearchPluginControl, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_GetPluginConfig"] = IAGFUNCTYPE(pUnk, IID_IVASearchPluginControl, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_GetDimension"] = IAGFUNCTYPE(pUnk, IID_IVASearchPluginControl, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_GetUseCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVASearchPluginControl, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVASearchPluginControl, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_GetCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVASearchPluginControl, vtable_offset_local+10, POINTER(agcom.BSTR))
        self.__dict__["_SetCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVASearchPluginControl, vtable_offset_local+11, agcom.BSTR)
        self.__dict__["_GetValues"] = IAGFUNCTYPE(pUnk, IID_IVASearchPluginControl, vtable_offset_local+12, POINTER(agcom.SAFEARRAY))
        self.__dict__["_SetCurrentValue"] = IAGFUNCTYPE(pUnk, IID_IVASearchPluginControl, vtable_offset_local+13, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVASearchPluginControl.__dict__ and type(IVASearchPluginControl.__dict__[attrname]) == property:
            return IVASearchPluginControl.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVASearchPluginControl.")
    
    @property
    def ControlName(self) -> str:
        """The name of the control parameter."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetControlName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def CurrentValue(self) -> typing.Any:
        """The current value of the control parameter."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCurrentValue"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ParentSegmentName(self) -> str:
        """The parent segment of the control parameter."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetParentSegmentName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def InitialValue(self) -> typing.Any:
        """The initial value of the control parameter. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetInitialValue"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def PluginIdentifier(self) -> str:
        """The plugin identifier."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPluginIdentifier"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def PluginConfig(self) -> "IVAPluginProperties":
        """The properties of the selected plugin."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPluginConfig"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Dimension(self) -> str:
        """The dimension of the values."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDimension"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def UseCustomDisplayUnit(self) -> bool:
        """If true, allows display of values in another unit."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCustomDisplayUnit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseCustomDisplayUnit.setter
    def UseCustomDisplayUnit(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseCustomDisplayUnit"](arg_newVal.COM_val))

    @property
    def CustomDisplayUnit(self) -> str:
        """The unit in which the value will be displayed in the GUI."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCustomDisplayUnit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CustomDisplayUnit.setter
    def CustomDisplayUnit(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCustomDisplayUnit"](arg_newVal.COM_val))

    @property
    def Values(self) -> list:
        """List of values of this independent variable at each iteration, including nominal run. Dimension depends on context."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetValues"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @CurrentValue.setter
    def CurrentValue(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCurrentValue"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{71AB197F-79CB-438C-8F0A-A48FA0069865}", IVASearchPluginControl)
agcls.AgTypeNameMap["IVASearchPluginControl"] = IVASearchPluginControl

class IVASearchPluginResult(object):
    """Properties of search plugin equality constraints."""
    _uuid = "{7881FB30-0FB9-43EF-98A1-9CF84D69A23F}"
    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetResultName"] = _raise_uninitialized_error
        self.__dict__["_GetCurrentValue"] = _raise_uninitialized_error
        self.__dict__["_GetParentSegmentName"] = _raise_uninitialized_error
        self.__dict__["_GetPluginIdentifier"] = _raise_uninitialized_error
        self.__dict__["_GetPluginConfig"] = _raise_uninitialized_error
        self.__dict__["_GetDimension"] = _raise_uninitialized_error
        self.__dict__["_GetUseCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_SetUseCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_GetCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_SetCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_GetValues"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVASearchPluginResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVASearchPluginResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVASearchPluginResult = agcom.GUID(IVASearchPluginResult._uuid)
        vtable_offset_local = IVASearchPluginResult._vtable_offset - 1
        self.__dict__["_GetResultName"] = IAGFUNCTYPE(pUnk, IID_IVASearchPluginResult, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_GetCurrentValue"] = IAGFUNCTYPE(pUnk, IID_IVASearchPluginResult, vtable_offset_local+2, POINTER(agcom.VARIANT))
        self.__dict__["_GetParentSegmentName"] = IAGFUNCTYPE(pUnk, IID_IVASearchPluginResult, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_GetPluginIdentifier"] = IAGFUNCTYPE(pUnk, IID_IVASearchPluginResult, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_GetPluginConfig"] = IAGFUNCTYPE(pUnk, IID_IVASearchPluginResult, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_GetDimension"] = IAGFUNCTYPE(pUnk, IID_IVASearchPluginResult, vtable_offset_local+6, POINTER(agcom.BSTR))
        self.__dict__["_GetUseCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVASearchPluginResult, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVASearchPluginResult, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_GetCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVASearchPluginResult, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_SetCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVASearchPluginResult, vtable_offset_local+10, agcom.BSTR)
        self.__dict__["_GetValues"] = IAGFUNCTYPE(pUnk, IID_IVASearchPluginResult, vtable_offset_local+11, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVASearchPluginResult.__dict__ and type(IVASearchPluginResult.__dict__[attrname]) == property:
            return IVASearchPluginResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVASearchPluginResult.")
    
    @property
    def ResultName(self) -> str:
        """The name of the equality constraint."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetResultName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def CurrentValue(self) -> typing.Any:
        """The current value of the result variable."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCurrentValue"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ParentSegmentName(self) -> str:
        """The parent segment of the result variable."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetParentSegmentName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def PluginIdentifier(self) -> str:
        """The plugin identifier."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPluginIdentifier"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def PluginConfig(self) -> "IVAPluginProperties":
        """The properties of the selected plugin."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPluginConfig"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Dimension(self) -> str:
        """The dimension of the values."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDimension"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def UseCustomDisplayUnit(self) -> bool:
        """If true, allows display of values in another unit."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCustomDisplayUnit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseCustomDisplayUnit.setter
    def UseCustomDisplayUnit(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseCustomDisplayUnit"](arg_newVal.COM_val))

    @property
    def CustomDisplayUnit(self) -> str:
        """The unit in which the value will be displayed in the GUI."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCustomDisplayUnit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CustomDisplayUnit.setter
    def CustomDisplayUnit(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCustomDisplayUnit"](arg_newVal.COM_val))

    @property
    def Values(self) -> list:
        """List of values of this dependent variable at each iteration, including nominal run. Dimension depends on context."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetValues"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{7881FB30-0FB9-43EF-98A1-9CF84D69A23F}", IVASearchPluginResult)
agcls.AgTypeNameMap["IVASearchPluginResult"] = IVASearchPluginResult

class IVASearchPluginResultCollection(object):
    """Properties for the list of search plugin equality constraints."""
    _uuid = "{48F5FEA5-9306-4115-B120-E479FD31A601}"
    _num_methods = 4
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetResultByPaths"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVASearchPluginResultCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVASearchPluginResultCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVASearchPluginResultCollection = agcom.GUID(IVASearchPluginResultCollection._uuid)
        vtable_offset_local = IVASearchPluginResultCollection._vtable_offset - 1
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVASearchPluginResultCollection, vtable_offset_local+1, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVASearchPluginResultCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVASearchPluginResultCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_GetResultByPaths"] = IAGFUNCTYPE(pUnk, IID_IVASearchPluginResultCollection, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVASearchPluginResultCollection.__dict__ and type(IVASearchPluginResultCollection.__dict__[attrname]) == property:
            return IVASearchPluginResultCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVASearchPluginResultCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVASearchPluginResult":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Item(self, index:int) -> "IVASearchPluginResult":
        """Allows you to iterate through the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_searchConstraintResult:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_index.COM_val, byref(arg_searchConstraintResult.COM_val)))
            return arg_searchConstraintResult.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Function to enumerate through the collection"""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Count(self) -> int:
        """Size of the collection"""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def GetResultByPaths(self, objectPath:str, resultPath:str) -> "IVASearchPluginResult":
        """Returns the result specified by the object/result path."""
        with agmarshall.BSTR_arg(objectPath) as arg_objectPath, \
             agmarshall.BSTR_arg(resultPath) as arg_resultPath, \
             agmarshall.AgInterface_out_arg() as arg_searchConstraintResult:
            agcls.evaluate_hresult(self.__dict__["_GetResultByPaths"](arg_objectPath.COM_val, arg_resultPath.COM_val, byref(arg_searchConstraintResult.COM_val)))
            return arg_searchConstraintResult.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{48F5FEA5-9306-4115-B120-E479FD31A601}", IVASearchPluginResultCollection)
agcls.AgTypeNameMap["IVASearchPluginResultCollection"] = IVASearchPluginResultCollection

class IVASearchPluginControlCollection(object):
    """Properties for the list of search plugin control parameters."""
    _uuid = "{6DAD8352-416A-402F-BD38-40CEF9E0CE4C}"
    _num_methods = 4
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetControlByPaths"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVASearchPluginControlCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVASearchPluginControlCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVASearchPluginControlCollection = agcom.GUID(IVASearchPluginControlCollection._uuid)
        vtable_offset_local = IVASearchPluginControlCollection._vtable_offset - 1
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVASearchPluginControlCollection, vtable_offset_local+1, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVASearchPluginControlCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVASearchPluginControlCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_GetControlByPaths"] = IAGFUNCTYPE(pUnk, IID_IVASearchPluginControlCollection, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVASearchPluginControlCollection.__dict__ and type(IVASearchPluginControlCollection.__dict__[attrname]) == property:
            return IVASearchPluginControlCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVASearchPluginControlCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVASearchPluginControl":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Item(self, index:int) -> "IVASearchPluginControl":
        """Allows you to iterate through the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_searchPluginControl:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_index.COM_val, byref(arg_searchPluginControl.COM_val)))
            return arg_searchPluginControl.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Property that allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def GetControlByPaths(self, objectPath:str, controlPath:str) -> "IVASearchPluginControl":
        """Returns the control specified by the object/control path."""
        with agmarshall.BSTR_arg(objectPath) as arg_objectPath, \
             agmarshall.BSTR_arg(controlPath) as arg_controlPath, \
             agmarshall.AgInterface_out_arg() as arg_searchPluginControl:
            agcls.evaluate_hresult(self.__dict__["_GetControlByPaths"](arg_objectPath.COM_val, arg_controlPath.COM_val, byref(arg_searchPluginControl.COM_val)))
            return arg_searchPluginControl.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{6DAD8352-416A-402F-BD38-40CEF9E0CE4C}", IVASearchPluginControlCollection)
agcls.AgTypeNameMap["IVASearchPluginControlCollection"] = IVASearchPluginControlCollection

class IVADCControlCollection(object):
    """Properties for the list of control parameters for a differential corrector profile."""
    _uuid = "{271A0046-EC08-49FC-A75A-4D49B6E7AD3A}"
    _num_methods = 5
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetControlByPaths"] = _raise_uninitialized_error
        self.__dict__["_GetProvideRuntimeTypeInfo"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVADCControlCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVADCControlCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVADCControlCollection = agcom.GUID(IVADCControlCollection._uuid)
        vtable_offset_local = IVADCControlCollection._vtable_offset - 1
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVADCControlCollection, vtable_offset_local+1, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVADCControlCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVADCControlCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_GetControlByPaths"] = IAGFUNCTYPE(pUnk, IID_IVADCControlCollection, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_GetProvideRuntimeTypeInfo"] = IAGFUNCTYPE(pUnk, IID_IVADCControlCollection, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVADCControlCollection.__dict__ and type(IVADCControlCollection.__dict__[attrname]) == property:
            return IVADCControlCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVADCControlCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVADCControl":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Item(self, index:int) -> "IVADCControl":
        """Allows you to iterate through the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_dCControl:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_index.COM_val, byref(arg_dCControl.COM_val)))
            return arg_dCControl.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def GetControlByPaths(self, objectPath:str, controlPath:str) -> "IVADCControl":
        """Returns the control specified by the object/control path."""
        with agmarshall.BSTR_arg(objectPath) as arg_objectPath, \
             agmarshall.BSTR_arg(controlPath) as arg_controlPath, \
             agmarshall.AgInterface_out_arg() as arg_dCControl:
            agcls.evaluate_hresult(self.__dict__["_GetControlByPaths"](arg_objectPath.COM_val, arg_controlPath.COM_val, byref(arg_dCControl.COM_val)))
            return arg_dCControl.python_val

    @property
    def ProvideRuntimeTypeInfo(self) -> "IRuntimeTypeInfo":
        """Returns the IAgRuntimeTypeInfo interface to access properties at runtime."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProvideRuntimeTypeInfo"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{271A0046-EC08-49FC-A75A-4D49B6E7AD3A}", IVADCControlCollection)
agcls.AgTypeNameMap["IVADCControlCollection"] = IVADCControlCollection

class IVADCResultCollection(object):
    """Differential Corrector result collection."""
    _uuid = "{1AB78F87-F0BC-42DF-80C9-AAACF11FE5D4}"
    _num_methods = 5
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetResultByPaths"] = _raise_uninitialized_error
        self.__dict__["_GetProvideRuntimeTypeInfo"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVADCResultCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVADCResultCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVADCResultCollection = agcom.GUID(IVADCResultCollection._uuid)
        vtable_offset_local = IVADCResultCollection._vtable_offset - 1
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVADCResultCollection, vtable_offset_local+1, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVADCResultCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVADCResultCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_GetResultByPaths"] = IAGFUNCTYPE(pUnk, IID_IVADCResultCollection, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_GetProvideRuntimeTypeInfo"] = IAGFUNCTYPE(pUnk, IID_IVADCResultCollection, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVADCResultCollection.__dict__ and type(IVADCResultCollection.__dict__[attrname]) == property:
            return IVADCResultCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVADCResultCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVADCResult":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Item(self, index:int) -> "IVADCResult":
        """Allows you to iterate through the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_dCResult:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_index.COM_val, byref(arg_dCResult.COM_val)))
            return arg_dCResult.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def GetResultByPaths(self, objectPath:str, resultPath:str) -> "IVADCResult":
        """Returns the result specified by the object/result path."""
        with agmarshall.BSTR_arg(objectPath) as arg_objectPath, \
             agmarshall.BSTR_arg(resultPath) as arg_resultPath, \
             agmarshall.AgInterface_out_arg() as arg_dCResult:
            agcls.evaluate_hresult(self.__dict__["_GetResultByPaths"](arg_objectPath.COM_val, arg_resultPath.COM_val, byref(arg_dCResult.COM_val)))
            return arg_dCResult.python_val

    @property
    def ProvideRuntimeTypeInfo(self) -> "IRuntimeTypeInfo":
        """Returns the IAgRuntimeTypeInfo interface to access properties at runtime."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProvideRuntimeTypeInfo"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{1AB78F87-F0BC-42DF-80C9-AAACF11FE5D4}", IVADCResultCollection)
agcls.AgTypeNameMap["IVADCResultCollection"] = IVADCResultCollection

class IVATargeterGraphActiveControl(object):
    """Properties for targeter graph active control."""
    _uuid = "{341791C5-446F-4812-BDE8-702EE9D3D980}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetName"] = _raise_uninitialized_error
        self.__dict__["_GetParentName"] = _raise_uninitialized_error
        self.__dict__["_GetShowGraphValue"] = _raise_uninitialized_error
        self.__dict__["_SetShowGraphValue"] = _raise_uninitialized_error
        self.__dict__["_GetLineColor"] = _raise_uninitialized_error
        self.__dict__["_SetLineColor"] = _raise_uninitialized_error
        self.__dict__["_GetPointStyle"] = _raise_uninitialized_error
        self.__dict__["_SetPointStyle"] = _raise_uninitialized_error
        self.__dict__["_GetYAxis"] = _raise_uninitialized_error
        self.__dict__["_SetYAxis"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVATargeterGraphActiveControl._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVATargeterGraphActiveControl from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVATargeterGraphActiveControl = agcom.GUID(IVATargeterGraphActiveControl._uuid)
        vtable_offset_local = IVATargeterGraphActiveControl._vtable_offset - 1
        self.__dict__["_GetName"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphActiveControl, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_GetParentName"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphActiveControl, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_GetShowGraphValue"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphActiveControl, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetShowGraphValue"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphActiveControl, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_GetLineColor"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphActiveControl, vtable_offset_local+5, POINTER(agcom.OLE_COLOR))
        self.__dict__["_SetLineColor"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphActiveControl, vtable_offset_local+6, agcom.OLE_COLOR)
        self.__dict__["_GetPointStyle"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphActiveControl, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_SetPointStyle"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphActiveControl, vtable_offset_local+8, agcom.BSTR)
        self.__dict__["_GetYAxis"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphActiveControl, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_SetYAxis"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphActiveControl, vtable_offset_local+10, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVATargeterGraphActiveControl.__dict__ and type(IVATargeterGraphActiveControl.__dict__[attrname]) == property:
            return IVATargeterGraphActiveControl.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVATargeterGraphActiveControl.")
    
    @property
    def Name(self) -> str:
        """The name of the active control."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def ParentName(self) -> str:
        """The segment or component to which the element belongs."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetParentName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def ShowGraphValue(self) -> bool:
        """Show the value."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetShowGraphValue"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ShowGraphValue.setter
    def ShowGraphValue(self, inVal:bool) -> None:
        """Show the value."""
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetShowGraphValue"](arg_inVal.COM_val))

    @property
    def LineColor(self) -> agcolor.Color:
        """Line Color."""
        with agmarshall.OLE_COLOR_arg() as arg_pValue:
            agcls.evaluate_hresult(self.__dict__["_GetLineColor"](byref(arg_pValue.COM_val)))
            return arg_pValue.python_val

    @LineColor.setter
    def LineColor(self, inVal:agcolor.Color) -> None:
        """Line Color."""
        with agmarshall.OLE_COLOR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetLineColor"](arg_inVal.COM_val))

    @property
    def PointStyle(self) -> str:
        """Point Style."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPointStyle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @PointStyle.setter
    def PointStyle(self, inVal:str) -> None:
        """Point Style."""
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetPointStyle"](arg_inVal.COM_val))

    @property
    def YAxis(self) -> str:
        """Select whether to display the control's value range on the left or right side of the graph."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetYAxis"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @YAxis.setter
    def YAxis(self, inVal:str) -> None:
        """Select whether to display the control's value range on the left or right side of the graph."""
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetYAxis"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{341791C5-446F-4812-BDE8-702EE9D3D980}", IVATargeterGraphActiveControl)
agcls.AgTypeNameMap["IVATargeterGraphActiveControl"] = IVATargeterGraphActiveControl

class IVATargeterGraphResult(object):
    """Properties for targeter graph result."""
    _uuid = "{16985A6D-61AE-467F-9A66-255556F9C8E1}"
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetName"] = _raise_uninitialized_error
        self.__dict__["_GetParentName"] = _raise_uninitialized_error
        self.__dict__["_GetShowDesiredValue"] = _raise_uninitialized_error
        self.__dict__["_SetShowDesiredValue"] = _raise_uninitialized_error
        self.__dict__["_GetLineColor"] = _raise_uninitialized_error
        self.__dict__["_SetLineColor"] = _raise_uninitialized_error
        self.__dict__["_GetPointStyle"] = _raise_uninitialized_error
        self.__dict__["_SetPointStyle"] = _raise_uninitialized_error
        self.__dict__["_GetYAxis"] = _raise_uninitialized_error
        self.__dict__["_SetYAxis"] = _raise_uninitialized_error
        self.__dict__["_GetGraphOption"] = _raise_uninitialized_error
        self.__dict__["_SetGraphOption"] = _raise_uninitialized_error
        self.__dict__["_GetShowToleranceBand"] = _raise_uninitialized_error
        self.__dict__["_SetShowToleranceBand"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVATargeterGraphResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVATargeterGraphResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVATargeterGraphResult = agcom.GUID(IVATargeterGraphResult._uuid)
        vtable_offset_local = IVATargeterGraphResult._vtable_offset - 1
        self.__dict__["_GetName"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphResult, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_GetParentName"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphResult, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_GetShowDesiredValue"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphResult, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetShowDesiredValue"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphResult, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_GetLineColor"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphResult, vtable_offset_local+5, POINTER(agcom.OLE_COLOR))
        self.__dict__["_SetLineColor"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphResult, vtable_offset_local+6, agcom.OLE_COLOR)
        self.__dict__["_GetPointStyle"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphResult, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_SetPointStyle"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphResult, vtable_offset_local+8, agcom.BSTR)
        self.__dict__["_GetYAxis"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphResult, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_SetYAxis"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphResult, vtable_offset_local+10, agcom.BSTR)
        self.__dict__["_GetGraphOption"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphResult, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_SetGraphOption"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphResult, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_GetShowToleranceBand"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphResult, vtable_offset_local+13, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetShowToleranceBand"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphResult, vtable_offset_local+14, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVATargeterGraphResult.__dict__ and type(IVATargeterGraphResult.__dict__[attrname]) == property:
            return IVATargeterGraphResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVATargeterGraphResult.")
    
    @property
    def Name(self) -> str:
        """The name of the result."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def ParentName(self) -> str:
        """The segment or component for which this result has been selected."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetParentName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def ShowDesiredValue(self) -> bool:
        """Show the desired value."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetShowDesiredValue"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ShowDesiredValue.setter
    def ShowDesiredValue(self, inVal:bool) -> None:
        """Show the desired value."""
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetShowDesiredValue"](arg_inVal.COM_val))

    @property
    def LineColor(self) -> agcolor.Color:
        """Line Color."""
        with agmarshall.OLE_COLOR_arg() as arg_pValue:
            agcls.evaluate_hresult(self.__dict__["_GetLineColor"](byref(arg_pValue.COM_val)))
            return arg_pValue.python_val

    @LineColor.setter
    def LineColor(self, inVal:agcolor.Color) -> None:
        """Line Color."""
        with agmarshall.OLE_COLOR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetLineColor"](arg_inVal.COM_val))

    @property
    def PointStyle(self) -> str:
        """Point Style."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPointStyle"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @PointStyle.setter
    def PointStyle(self, inVal:str) -> None:
        """Point Style."""
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetPointStyle"](arg_inVal.COM_val))

    @property
    def YAxis(self) -> str:
        """Select whether to display the result's value range on the left or right side of the graph."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetYAxis"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @YAxis.setter
    def YAxis(self, inVal:str) -> None:
        """Select whether to display the result's value range on the left or right side of the graph."""
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetYAxis"](arg_inVal.COM_val))

    @property
    def GraphOption(self) -> "AgEVAGraphOption":
        """Graph option."""
        with agmarshall.AgEnum_arg(AgEVAGraphOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetGraphOption"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @GraphOption.setter
    def GraphOption(self, inVal:"AgEVAGraphOption") -> None:
        """Graph option."""
        with agmarshall.AgEnum_arg(AgEVAGraphOption, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetGraphOption"](arg_inVal.COM_val))

    @property
    def ShowToleranceBand(self) -> bool:
        """Show the tolerance band."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetShowToleranceBand"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ShowToleranceBand.setter
    def ShowToleranceBand(self, inVal:bool) -> None:
        """Show the tolerance band."""
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetShowToleranceBand"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{16985A6D-61AE-467F-9A66-255556F9C8E1}", IVATargeterGraphResult)
agcls.AgTypeNameMap["IVATargeterGraphResult"] = IVATargeterGraphResult

class IVATargeterGraphActiveControlCollection(object):
    """Targeter graph active controls."""
    _uuid = "{57FE9616-8C44-4F5B-8B31-F005C0B678A2}"
    _num_methods = 4
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetProvideRuntimeTypeInfo"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVATargeterGraphActiveControlCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVATargeterGraphActiveControlCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVATargeterGraphActiveControlCollection = agcom.GUID(IVATargeterGraphActiveControlCollection._uuid)
        vtable_offset_local = IVATargeterGraphActiveControlCollection._vtable_offset - 1
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphActiveControlCollection, vtable_offset_local+1, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphActiveControlCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphActiveControlCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_GetProvideRuntimeTypeInfo"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphActiveControlCollection, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVATargeterGraphActiveControlCollection.__dict__ and type(IVATargeterGraphActiveControlCollection.__dict__[attrname]) == property:
            return IVATargeterGraphActiveControlCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVATargeterGraphActiveControlCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVATargeterGraphActiveControl":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Item(self, index:int) -> "IVATargeterGraphActiveControl":
        """Allows you to iterate through the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_dCControl:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_index.COM_val, byref(arg_dCControl.COM_val)))
            return arg_dCControl.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ProvideRuntimeTypeInfo(self) -> "IRuntimeTypeInfo":
        """Returns the IAgRuntimeTypeInfo interface to access properties at runtime."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProvideRuntimeTypeInfo"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{57FE9616-8C44-4F5B-8B31-F005C0B678A2}", IVATargeterGraphActiveControlCollection)
agcls.AgTypeNameMap["IVATargeterGraphActiveControlCollection"] = IVATargeterGraphActiveControlCollection

class IVATargeterGraphResultCollection(object):
    """Targeter graph results."""
    _uuid = "{00E250BC-BA84-4ED7-A6A8-43FA17EF2731}"
    _num_methods = 4
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_GetProvideRuntimeTypeInfo"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVATargeterGraphResultCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVATargeterGraphResultCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVATargeterGraphResultCollection = agcom.GUID(IVATargeterGraphResultCollection._uuid)
        vtable_offset_local = IVATargeterGraphResultCollection._vtable_offset - 1
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphResultCollection, vtable_offset_local+1, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphResultCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphResultCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_GetProvideRuntimeTypeInfo"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphResultCollection, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVATargeterGraphResultCollection.__dict__ and type(IVATargeterGraphResultCollection.__dict__[attrname]) == property:
            return IVATargeterGraphResultCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVATargeterGraphResultCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVATargeterGraphResult":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Item(self, index:int) -> "IVATargeterGraphResult":
        """Allows you to iterate through the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_dCControl:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_index.COM_val, byref(arg_dCControl.COM_val)))
            return arg_dCControl.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ProvideRuntimeTypeInfo(self) -> "IRuntimeTypeInfo":
        """Returns the IAgRuntimeTypeInfo interface to access properties at runtime."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProvideRuntimeTypeInfo"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{00E250BC-BA84-4ED7-A6A8-43FA17EF2731}", IVATargeterGraphResultCollection)
agcls.AgTypeNameMap["IVATargeterGraphResultCollection"] = IVATargeterGraphResultCollection

class IVATargeterGraph(object):
    """Properties for a Targeter Graph."""
    _uuid = "{418A2587-7803-4746-9A49-1B1A87BB906A}"
    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetName"] = _raise_uninitialized_error
        self.__dict__["_SetName"] = _raise_uninitialized_error
        self.__dict__["_GetGenerateOnRun"] = _raise_uninitialized_error
        self.__dict__["_SetGenerateOnRun"] = _raise_uninitialized_error
        self.__dict__["_GetUserComment"] = _raise_uninitialized_error
        self.__dict__["_SetUserComment"] = _raise_uninitialized_error
        self.__dict__["_GetShowLabelIterations"] = _raise_uninitialized_error
        self.__dict__["_SetShowLabelIterations"] = _raise_uninitialized_error
        self.__dict__["_GetShowDesiredValue"] = _raise_uninitialized_error
        self.__dict__["_SetShowDesiredValue"] = _raise_uninitialized_error
        self.__dict__["_GetShowToleranceBand"] = _raise_uninitialized_error
        self.__dict__["_SetShowToleranceBand"] = _raise_uninitialized_error
        self.__dict__["_GetIndependentVariable"] = _raise_uninitialized_error
        self.__dict__["_SetIndependentVariable"] = _raise_uninitialized_error
        self.__dict__["_GetActiveControls"] = _raise_uninitialized_error
        self.__dict__["_GetResults"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVATargeterGraph._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVATargeterGraph from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVATargeterGraph = agcom.GUID(IVATargeterGraph._uuid)
        vtable_offset_local = IVATargeterGraph._vtable_offset - 1
        self.__dict__["_GetName"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraph, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetName"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraph, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetGenerateOnRun"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraph, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetGenerateOnRun"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraph, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_GetUserComment"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraph, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_SetUserComment"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraph, vtable_offset_local+6, agcom.BSTR)
        self.__dict__["_GetShowLabelIterations"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraph, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetShowLabelIterations"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraph, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_GetShowDesiredValue"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraph, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetShowDesiredValue"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraph, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_GetShowToleranceBand"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraph, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetShowToleranceBand"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraph, vtable_offset_local+12, agcom.VARIANT_BOOL)
        self.__dict__["_GetIndependentVariable"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraph, vtable_offset_local+13, POINTER(agcom.BSTR))
        self.__dict__["_SetIndependentVariable"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraph, vtable_offset_local+14, agcom.BSTR)
        self.__dict__["_GetActiveControls"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraph, vtable_offset_local+15, POINTER(agcom.PVOID))
        self.__dict__["_GetResults"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraph, vtable_offset_local+16, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVATargeterGraph.__dict__ and type(IVATargeterGraph.__dict__[attrname]) == property:
            return IVATargeterGraph.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVATargeterGraph.")
    
    @property
    def Name(self) -> str:
        """The name of the graph."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Name.setter
    def Name(self, inVal:str) -> None:
        """The name of the graph."""
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetName"](arg_inVal.COM_val))

    @property
    def GenerateOnRun(self) -> bool:
        """Generate the graph while MCS is being run."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetGenerateOnRun"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @GenerateOnRun.setter
    def GenerateOnRun(self, inVal:bool) -> None:
        """Generate the graph while MCS is being run."""
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetGenerateOnRun"](arg_inVal.COM_val))

    @property
    def UserComment(self) -> str:
        """User Comment."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUserComment"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UserComment.setter
    def UserComment(self, inVal:str) -> None:
        """User Comment."""
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUserComment"](arg_inVal.COM_val))

    @property
    def ShowLabelIterations(self) -> bool:
        """Label each of the points on the graph labeled according to its iteration number."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetShowLabelIterations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ShowLabelIterations.setter
    def ShowLabelIterations(self, inVal:bool) -> None:
        """Label each of the points on the graph labeled according to its iteration number."""
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetShowLabelIterations"](arg_inVal.COM_val))

    @property
    def ShowDesiredValue(self) -> bool:
        """Show the desired equality constraint value(s) on the graph. Not applicable to SNOPT and IPOPT search profiles."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetShowDesiredValue"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ShowDesiredValue.setter
    def ShowDesiredValue(self, inVal:bool) -> None:
        """Show the desired equality constraint value(s) on the graph. Not applicable to SNOPT and IPOPT search profiles."""
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetShowDesiredValue"](arg_inVal.COM_val))

    @property
    def ShowToleranceBand(self) -> bool:
        """Show the tolerance band on the graph. Not applicable to SNOPT and IPOPT search profiles."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetShowToleranceBand"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ShowToleranceBand.setter
    def ShowToleranceBand(self, inVal:bool) -> None:
        """Show the tolerance band on the graph. Not applicable to SNOPT and IPOPT search profiles."""
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetShowToleranceBand"](arg_inVal.COM_val))

    @property
    def IndependentVariable(self) -> str:
        """Select the graph's X axis."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetIndependentVariable"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @IndependentVariable.setter
    def IndependentVariable(self, inVal:str) -> None:
        """Select the graph's X axis."""
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetIndependentVariable"](arg_inVal.COM_val))

    @property
    def ActiveControls(self) -> "IVATargeterGraphActiveControlCollection":
        """Active Controls."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetActiveControls"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Results(self) -> "IVATargeterGraphResultCollection":
        """Results."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetResults"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{418A2587-7803-4746-9A49-1B1A87BB906A}", IVATargeterGraph)
agcls.AgTypeNameMap["IVATargeterGraph"] = IVATargeterGraph

class IVATargeterGraphCollection(object):
    """The list of User Variables accessed through the Driver."""
    _uuid = "{10EA0426-F62C-40C1-B1C6-A5B5E0BD0414}"
    _num_methods = 11
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_AddGraph"] = _raise_uninitialized_error
        self.__dict__["_RemoveGraph"] = _raise_uninitialized_error
        self.__dict__["_GetProvideRuntimeTypeInfo"] = _raise_uninitialized_error
        self.__dict__["_Cut"] = _raise_uninitialized_error
        self.__dict__["_Paste"] = _raise_uninitialized_error
        self.__dict__["_InsertCopy"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVATargeterGraphCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVATargeterGraphCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVATargeterGraphCollection = agcom.GUID(IVATargeterGraphCollection._uuid)
        vtable_offset_local = IVATargeterGraphCollection._vtable_offset - 1
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphCollection, vtable_offset_local+1, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_AddGraph"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphCollection, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_RemoveGraph"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphCollection, vtable_offset_local+5, agcom.VARIANT)
        self.__dict__["_GetProvideRuntimeTypeInfo"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphCollection, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_Cut"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphCollection, vtable_offset_local+7, agcom.VARIANT)
        self.__dict__["_Paste"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphCollection, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_InsertCopy"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphCollection, vtable_offset_local+9, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphCollection, vtable_offset_local+10, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IVATargeterGraphCollection, vtable_offset_local+11, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVATargeterGraphCollection.__dict__ and type(IVATargeterGraphCollection.__dict__[attrname]) == property:
            return IVATargeterGraphCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVATargeterGraphCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVATargeterGraph":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Item(self, indexOrName:typing.Any) -> "IVATargeterGraph":
        """Allows you to iterate through the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_targeterGraph:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_targeterGraph.COM_val)))
            return arg_targeterGraph.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def AddGraph(self) -> "IVATargeterGraph":
        """Adds a new targeter graph."""
        with agmarshall.AgInterface_out_arg() as arg_targeterGraph:
            agcls.evaluate_hresult(self.__dict__["_AddGraph"](byref(arg_targeterGraph.COM_val)))
            return arg_targeterGraph.python_val

    def RemoveGraph(self, indexOrName:typing.Any) -> None:
        """Removes a targeter graph."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_RemoveGraph"](arg_indexOrName.COM_val))

    @property
    def ProvideRuntimeTypeInfo(self) -> "IRuntimeTypeInfo":
        """Returns the IAgRuntimeTypeInfo interface to access properties at runtime."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetProvideRuntimeTypeInfo"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Cut(self, indexOrName:typing.Any) -> None:
        """Copies a targeter graph to the clipboard and removes the targeter graph from the list."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_Cut"](arg_indexOrName.COM_val))

    def Paste(self) -> "IVATargeterGraph":
        """Pastes a targeter graph from the clipboard into the list."""
        with agmarshall.AgInterface_out_arg() as arg_ppGraph:
            agcls.evaluate_hresult(self.__dict__["_Paste"](byref(arg_ppGraph.COM_val)))
            return arg_ppGraph.python_val

    def InsertCopy(self, graph:"IVATargeterGraph") -> "IVATargeterGraph":
        """Copies a targeter graph and inserts the copy into the list."""
        with agmarshall.AgInterface_in_arg(graph, IVATargeterGraph) as arg_graph, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_InsertCopy"](arg_graph.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "IVATargeterGraph":
        """Retrieves a targeter graph from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppTargeterGraph:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppTargeterGraph.COM_val)))
            return arg_ppTargeterGraph.python_val

    def GetItemByName(self, name:str) -> "IVATargeterGraph":
        """Retrieves a targeter graph from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppTargeterGraph:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppTargeterGraph.COM_val)))
            return arg_ppTargeterGraph.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{10EA0426-F62C-40C1-B1C6-A5B5E0BD0414}", IVATargeterGraphCollection)
agcls.AgTypeNameMap["IVATargeterGraphCollection"] = IVATargeterGraphCollection

class IVAProfileSearchPlugin(IVAProfile):
    """Properties of a plugin search profile."""
    _uuid = "{9380509D-A189-453D-B1EF-D1D8E34420FF}"
    _num_methods = 8
    _vtable_offset = IVAProfile._vtable_offset + IVAProfile._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetControls"] = _raise_uninitialized_error
        self.__dict__["_GetResults"] = _raise_uninitialized_error
        self.__dict__["_GetPluginConfig"] = _raise_uninitialized_error
        self.__dict__["_GetPluginIdentifier"] = _raise_uninitialized_error
        self.__dict__["_GetScriptingTool"] = _raise_uninitialized_error
        self.__dict__["_GetResetControlsBeforeRun"] = _raise_uninitialized_error
        self.__dict__["_SetResetControlsBeforeRun"] = _raise_uninitialized_error
        self.__dict__["_GetTargeterGraphs"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAProfileSearchPlugin._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAProfileSearchPlugin from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAProfile._private_init(self, pUnk)
        IID_IVAProfileSearchPlugin = agcom.GUID(IVAProfileSearchPlugin._uuid)
        vtable_offset_local = IVAProfileSearchPlugin._vtable_offset - 1
        self.__dict__["_GetControls"] = IAGFUNCTYPE(pUnk, IID_IVAProfileSearchPlugin, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetResults"] = IAGFUNCTYPE(pUnk, IID_IVAProfileSearchPlugin, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetPluginConfig"] = IAGFUNCTYPE(pUnk, IID_IVAProfileSearchPlugin, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetPluginIdentifier"] = IAGFUNCTYPE(pUnk, IID_IVAProfileSearchPlugin, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_GetScriptingTool"] = IAGFUNCTYPE(pUnk, IID_IVAProfileSearchPlugin, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_GetResetControlsBeforeRun"] = IAGFUNCTYPE(pUnk, IID_IVAProfileSearchPlugin, vtable_offset_local+6, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetResetControlsBeforeRun"] = IAGFUNCTYPE(pUnk, IID_IVAProfileSearchPlugin, vtable_offset_local+7, agcom.VARIANT_BOOL)
        self.__dict__["_GetTargeterGraphs"] = IAGFUNCTYPE(pUnk, IID_IVAProfileSearchPlugin, vtable_offset_local+8, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAProfileSearchPlugin.__dict__ and type(IVAProfileSearchPlugin.__dict__[attrname]) == property:
            return IVAProfileSearchPlugin.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAProfile.__setattr__(self, attrname, value)
    
    @property
    def Controls(self) -> "IVASearchPluginControlCollection":
        """The selected control parameters."""
        with agmarshall.AgInterface_out_arg() as arg_ppSearchPluginControlCollection:
            agcls.evaluate_hresult(self.__dict__["_GetControls"](byref(arg_ppSearchPluginControlCollection.COM_val)))
            return arg_ppSearchPluginControlCollection.python_val

    @property
    def Results(self) -> "IVASearchPluginResultCollection":
        """The selected equality constraints."""
        with agmarshall.AgInterface_out_arg() as arg_ppSearchPluginResultCollection:
            agcls.evaluate_hresult(self.__dict__["_GetResults"](byref(arg_ppSearchPluginResultCollection.COM_val)))
            return arg_ppSearchPluginResultCollection.python_val

    @property
    def PluginConfig(self) -> "IVAPluginProperties":
        """The properties of the selected plugin."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPluginConfig"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def PluginIdentifier(self) -> str:
        """The plugin identifier."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPluginIdentifier"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def ScriptingTool(self) -> "IVAScriptingTool":
        """Returns the Scripting tool for the sequence."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScriptingTool"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ResetControlsBeforeRun(self) -> bool:
        """Reset controls before each run."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetResetControlsBeforeRun"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ResetControlsBeforeRun.setter
    def ResetControlsBeforeRun(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetResetControlsBeforeRun"](arg_newVal.COM_val))

    @property
    def TargeterGraphs(self) -> "IVATargeterGraphCollection":
        """Graphs"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargeterGraphs"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{9380509D-A189-453D-B1EF-D1D8E34420FF}", IVAProfileSearchPlugin)
agcls.AgTypeNameMap["IVAProfileSearchPlugin"] = IVAProfileSearchPlugin

class IVAProfileDifferentialCorrector(IVAProfile):
    """Properties for a Differential Corrector profile."""
    _uuid = "{E131F674-A7BA-408C-9109-BF50D16BE4F0}"
    _num_methods = 39
    _vtable_offset = IVAProfile._vtable_offset + IVAProfile._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetControlParameters"] = _raise_uninitialized_error
        self.__dict__["_GetResults"] = _raise_uninitialized_error
        self.__dict__["_GetMaxIterations"] = _raise_uninitialized_error
        self.__dict__["_SetMaxIterations"] = _raise_uninitialized_error
        self.__dict__["_GetEnableDisplayStatus"] = _raise_uninitialized_error
        self.__dict__["_SetEnableDisplayStatus"] = _raise_uninitialized_error
        self.__dict__["_GetConvergenceCriteria"] = _raise_uninitialized_error
        self.__dict__["_SetConvergenceCriteria"] = _raise_uninitialized_error
        self.__dict__["_GetEnableLineSearch"] = _raise_uninitialized_error
        self.__dict__["_SetEnableLineSearch"] = _raise_uninitialized_error
        self.__dict__["_GetMaxLineSearchIterations"] = _raise_uninitialized_error
        self.__dict__["_SetMaxLineSearchIterations"] = _raise_uninitialized_error
        self.__dict__["_GetLineSearchLowerBound"] = _raise_uninitialized_error
        self.__dict__["_SetLineSearchLowerBound"] = _raise_uninitialized_error
        self.__dict__["_GetLineSearchUpperBound"] = _raise_uninitialized_error
        self.__dict__["_SetLineSearchUpperBound"] = _raise_uninitialized_error
        self.__dict__["_GetLineSearchTolerance"] = _raise_uninitialized_error
        self.__dict__["_SetLineSearchTolerance"] = _raise_uninitialized_error
        self.__dict__["_GetEnableHomotopy"] = _raise_uninitialized_error
        self.__dict__["_SetEnableHomotopy"] = _raise_uninitialized_error
        self.__dict__["_GetHomotopySteps"] = _raise_uninitialized_error
        self.__dict__["_SetHomotopySteps"] = _raise_uninitialized_error
        self.__dict__["_GetDerivativeCalcMethod"] = _raise_uninitialized_error
        self.__dict__["_SetDerivativeCalcMethod"] = _raise_uninitialized_error
        self.__dict__["_GetClearCorrectionsBeforeRun"] = _raise_uninitialized_error
        self.__dict__["_SetClearCorrectionsBeforeRun"] = _raise_uninitialized_error
        self.__dict__["_GetEnableBPlaneNominal"] = _raise_uninitialized_error
        self.__dict__["_SetEnableBPlaneNominal"] = _raise_uninitialized_error
        self.__dict__["_GetEnableBPlanePerturbations"] = _raise_uninitialized_error
        self.__dict__["_SetEnableBPlanePerturbations"] = _raise_uninitialized_error
        self.__dict__["_GetDrawPerturbation"] = _raise_uninitialized_error
        self.__dict__["_SetDrawPerturbation"] = _raise_uninitialized_error
        self.__dict__["_GetScriptingTool"] = _raise_uninitialized_error
        self.__dict__["_GetRootFindingAlgorithm"] = _raise_uninitialized_error
        self.__dict__["_SetRootFindingAlgorithm"] = _raise_uninitialized_error
        self.__dict__["_GetNumIterations"] = _raise_uninitialized_error
        self.__dict__["_GetTargeterGraphs"] = _raise_uninitialized_error
        self.__dict__["_GetStopOnLimitCycleDetection"] = _raise_uninitialized_error
        self.__dict__["_SetStopOnLimitCycleDetection"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAProfileDifferentialCorrector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAProfileDifferentialCorrector from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAProfile._private_init(self, pUnk)
        IID_IVAProfileDifferentialCorrector = agcom.GUID(IVAProfileDifferentialCorrector._uuid)
        vtable_offset_local = IVAProfileDifferentialCorrector._vtable_offset - 1
        self.__dict__["_GetControlParameters"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetResults"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetMaxIterations"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetMaxIterations"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetEnableDisplayStatus"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnableDisplayStatus"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetConvergenceCriteria"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetConvergenceCriteria"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetEnableLineSearch"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnableLineSearch"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_GetMaxLineSearchIterations"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_SetMaxLineSearchIterations"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_GetLineSearchLowerBound"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetLineSearchLowerBound"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetLineSearchUpperBound"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_SetLineSearchUpperBound"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_GetLineSearchTolerance"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_SetLineSearchTolerance"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_GetEnableHomotopy"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+19, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnableHomotopy"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+20, agcom.VARIANT_BOOL)
        self.__dict__["_GetHomotopySteps"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+21, POINTER(agcom.LONG))
        self.__dict__["_SetHomotopySteps"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+22, agcom.LONG)
        self.__dict__["_GetDerivativeCalcMethod"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+23, POINTER(agcom.LONG))
        self.__dict__["_SetDerivativeCalcMethod"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+24, agcom.LONG)
        self.__dict__["_GetClearCorrectionsBeforeRun"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+25, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetClearCorrectionsBeforeRun"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+26, agcom.VARIANT_BOOL)
        self.__dict__["_GetEnableBPlaneNominal"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+27, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnableBPlaneNominal"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+28, agcom.VARIANT_BOOL)
        self.__dict__["_GetEnableBPlanePerturbations"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+29, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnableBPlanePerturbations"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+30, agcom.VARIANT_BOOL)
        self.__dict__["_GetDrawPerturbation"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+31, POINTER(agcom.LONG))
        self.__dict__["_SetDrawPerturbation"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+32, agcom.LONG)
        self.__dict__["_GetScriptingTool"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+33, POINTER(agcom.PVOID))
        self.__dict__["_GetRootFindingAlgorithm"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+34, POINTER(agcom.LONG))
        self.__dict__["_SetRootFindingAlgorithm"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+35, agcom.LONG)
        self.__dict__["_GetNumIterations"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+36, POINTER(agcom.LONG))
        self.__dict__["_GetTargeterGraphs"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+37, POINTER(agcom.PVOID))
        self.__dict__["_GetStopOnLimitCycleDetection"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+38, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetStopOnLimitCycleDetection"] = IAGFUNCTYPE(pUnk, IID_IVAProfileDifferentialCorrector, vtable_offset_local+39, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAProfileDifferentialCorrector.__dict__ and type(IVAProfileDifferentialCorrector.__dict__[attrname]) == property:
            return IVAProfileDifferentialCorrector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAProfile.__setattr__(self, attrname, value)
    
    @property
    def ControlParameters(self) -> "IVADCControlCollection":
        """The list of control parameters defined for the profile."""
        with agmarshall.AgInterface_out_arg() as arg_ppVADCControlCollection:
            agcls.evaluate_hresult(self.__dict__["_GetControlParameters"](byref(arg_ppVADCControlCollection.COM_val)))
            return arg_ppVADCControlCollection.python_val

    @property
    def Results(self) -> "IVADCResultCollection":
        """The list of results defined for the profile."""
        with agmarshall.AgInterface_out_arg() as arg_ppVADCResultCollection:
            agcls.evaluate_hresult(self.__dict__["_GetResults"](byref(arg_ppVADCResultCollection.COM_val)))
            return arg_ppVADCResultCollection.python_val

    @property
    def MaxIterations(self) -> int:
        """The number of complete iterations of the profile to try before stopping. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxIterations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxIterations.setter
    def MaxIterations(self, newVal:int) -> None:
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxIterations"](arg_newVal.COM_val))

    @property
    def EnableDisplayStatus(self) -> bool:
        """If true, a page will appear during the targeting run to report the status of the targeting effort in terms of proximity to the desired value for each dependent variable in the profile."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnableDisplayStatus"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EnableDisplayStatus.setter
    def EnableDisplayStatus(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnableDisplayStatus"](arg_newVal.COM_val))

    @property
    def ConvergenceCriteria(self) -> "AgEVAConvergenceCriteria":
        """The convergence criteria."""
        with agmarshall.AgEnum_arg(AgEVAConvergenceCriteria) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetConvergenceCriteria"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ConvergenceCriteria.setter
    def ConvergenceCriteria(self, newVal:"AgEVAConvergenceCriteria") -> None:
        with agmarshall.AgEnum_arg(AgEVAConvergenceCriteria, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetConvergenceCriteria"](arg_newVal.COM_val))

    @property
    def EnableLineSearch(self) -> bool:
        """If true, the profile will perform a line search."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnableLineSearch"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EnableLineSearch.setter
    def EnableLineSearch(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnableLineSearch"](arg_newVal.COM_val))

    @property
    def MaxLineSearchIterations(self) -> int:
        """The number of line search iterations to try before stopping. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxLineSearchIterations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxLineSearchIterations.setter
    def MaxLineSearchIterations(self, newVal:int) -> None:
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxLineSearchIterations"](arg_newVal.COM_val))

    @property
    def LineSearchLowerBound(self) -> float:
        """The low boundary for the line search. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLineSearchLowerBound"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @LineSearchLowerBound.setter
    def LineSearchLowerBound(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetLineSearchLowerBound"](arg_newVal.COM_val))

    @property
    def LineSearchUpperBound(self) -> float:
        """The high boundary for the line search. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLineSearchUpperBound"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @LineSearchUpperBound.setter
    def LineSearchUpperBound(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetLineSearchUpperBound"](arg_newVal.COM_val))

    @property
    def LineSearchTolerance(self) -> float:
        """The tolerance for the line search. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLineSearchTolerance"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @LineSearchTolerance.setter
    def LineSearchTolerance(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetLineSearchTolerance"](arg_newVal.COM_val))

    @property
    def EnableHomotopy(self) -> bool:
        """If true, the profile will divide the problem into steps to solve it."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnableHomotopy"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EnableHomotopy.setter
    def EnableHomotopy(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnableHomotopy"](arg_newVal.COM_val))

    @property
    def HomotopySteps(self) -> int:
        """The number of steps to divide a problem into for a homotopic calculation. Dimensionless - ."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetHomotopySteps"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @HomotopySteps.setter
    def HomotopySteps(self, newVal:int) -> None:
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetHomotopySteps"](arg_newVal.COM_val))

    @property
    def DerivativeCalcMethod(self) -> "AgEVADeriveCalcMethod":
        """The derivative calculation method."""
        with agmarshall.AgEnum_arg(AgEVADeriveCalcMethod) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDerivativeCalcMethod"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DerivativeCalcMethod.setter
    def DerivativeCalcMethod(self, newVal:"AgEVADeriveCalcMethod") -> None:
        with agmarshall.AgEnum_arg(AgEVADeriveCalcMethod, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetDerivativeCalcMethod"](arg_newVal.COM_val))

    @property
    def ClearCorrectionsBeforeRun(self) -> bool:
        """Clear Corrections Before Each Run - if true, the differential corrector is automatically reset each time that it is run, discarding information that was computed the last time it was run."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetClearCorrectionsBeforeRun"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ClearCorrectionsBeforeRun.setter
    def ClearCorrectionsBeforeRun(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetClearCorrectionsBeforeRun"](arg_newVal.COM_val))

    @property
    def EnableBPlaneNominal(self) -> bool:
        """If true, Astrogator will update the display of B-Planes for the nominal run of each iteration during the targeting process."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnableBPlaneNominal"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EnableBPlaneNominal.setter
    def EnableBPlaneNominal(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnableBPlaneNominal"](arg_newVal.COM_val))

    @property
    def EnableBPlanePerturbations(self) -> bool:
        """If true, Astrogator will update the display of B-Planes for both of the perturbations of each iteration during the targeting process."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnableBPlanePerturbations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EnableBPlanePerturbations.setter
    def EnableBPlanePerturbations(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnableBPlanePerturbations"](arg_newVal.COM_val))

    @property
    def DrawPerturbation(self) -> "AgEVADrawPerturbation":
        """Defines the display of perturbations in the 2D and 3D Graphics windows, if you have set Astrogator to draw while calculating."""
        with agmarshall.AgEnum_arg(AgEVADrawPerturbation) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDrawPerturbation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DrawPerturbation.setter
    def DrawPerturbation(self, newVal:"AgEVADrawPerturbation") -> None:
        with agmarshall.AgEnum_arg(AgEVADrawPerturbation, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetDrawPerturbation"](arg_newVal.COM_val))

    @property
    def ScriptingTool(self) -> "IVAScriptingTool":
        """Returns the Scripting tool for the sequence."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScriptingTool"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def RootFindingAlgorithm(self) -> "AgEVARootFindingAlgorithm":
        """The root-finding algorithm to use."""
        with agmarshall.AgEnum_arg(AgEVARootFindingAlgorithm) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRootFindingAlgorithm"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RootFindingAlgorithm.setter
    def RootFindingAlgorithm(self, pVal:"AgEVARootFindingAlgorithm") -> None:
        with agmarshall.AgEnum_arg(AgEVARootFindingAlgorithm, pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetRootFindingAlgorithm"](arg_pVal.COM_val))

    @property
    def NumIterations(self) -> int:
        """The number of iterations of the last run"""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNumIterations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def TargeterGraphs(self) -> "IVATargeterGraphCollection":
        """Graphs"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargeterGraphs"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def StopOnLimitCycleDetection(self) -> bool:
        """If true, Astrogator will stop targeting if a limit cycle is detected."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetStopOnLimitCycleDetection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @StopOnLimitCycleDetection.setter
    def StopOnLimitCycleDetection(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetStopOnLimitCycleDetection"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E131F674-A7BA-408C-9109-BF50D16BE4F0}", IVAProfileDifferentialCorrector)
agcls.AgTypeNameMap["IVAProfileDifferentialCorrector"] = IVAProfileDifferentialCorrector

class IVAProfileChangeManeuverType(IVAProfile):
    """Properties for a Change Maneuver Type profile."""
    _uuid = "{17F50A61-1E84-4060-A86A-93434A5522D5}"
    _num_methods = 4
    _vtable_offset = IVAProfile._vtable_offset + IVAProfile._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSegment"] = _raise_uninitialized_error
        self.__dict__["_SetSegment"] = _raise_uninitialized_error
        self.__dict__["_GetManeuverType"] = _raise_uninitialized_error
        self.__dict__["_SetManeuverType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAProfileChangeManeuverType._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAProfileChangeManeuverType from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAProfile._private_init(self, pUnk)
        IID_IVAProfileChangeManeuverType = agcom.GUID(IVAProfileChangeManeuverType._uuid)
        vtable_offset_local = IVAProfileChangeManeuverType._vtable_offset - 1
        self.__dict__["_GetSegment"] = IAGFUNCTYPE(pUnk, IID_IVAProfileChangeManeuverType, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_SetSegment"] = IAGFUNCTYPE(pUnk, IID_IVAProfileChangeManeuverType, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetManeuverType"] = IAGFUNCTYPE(pUnk, IID_IVAProfileChangeManeuverType, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetManeuverType"] = IAGFUNCTYPE(pUnk, IID_IVAProfileChangeManeuverType, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAProfileChangeManeuverType.__dict__ and type(IVAProfileChangeManeuverType.__dict__[attrname]) == property:
            return IVAProfileChangeManeuverType.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAProfile.__setattr__(self, attrname, value)
    
    @property
    def Segment(self) -> "IVAMCSManeuver":
        """The targeted maneuver segment."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAMCSManeuver:
            agcls.evaluate_hresult(self.__dict__["_GetSegment"](byref(arg_ppVAMCSManeuver.COM_val)))
            return arg_ppVAMCSManeuver.python_val

    @Segment.setter
    def Segment(self, pSegment:"IVAMCSManeuver") -> None:
        with agmarshall.AgInterface_in_arg(pSegment, IVAMCSManeuver) as arg_pSegment:
            agcls.evaluate_hresult(self.__dict__["_SetSegment"](arg_pSegment.COM_val))

    @property
    def ManeuverType(self) -> "AgEVAManeuverType":
        """The new maneuver type for the targeted segment."""
        with agmarshall.AgEnum_arg(AgEVAManeuverType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetManeuverType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ManeuverType.setter
    def ManeuverType(self, newVal:"AgEVAManeuverType") -> None:
        with agmarshall.AgEnum_arg(AgEVAManeuverType, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetManeuverType"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{17F50A61-1E84-4060-A86A-93434A5522D5}", IVAProfileChangeManeuverType)
agcls.AgTypeNameMap["IVAProfileChangeManeuverType"] = IVAProfileChangeManeuverType

class IVAProfileScriptingTool(IVAProfile):
    """Properties for a Scripting Tool profile."""
    _uuid = "{8D1192C7-8230-4475-BAFF-A135F9EE0ABD}"
    _num_methods = 10
    _vtable_offset = IVAProfile._vtable_offset + IVAProfile._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEnable"] = _raise_uninitialized_error
        self.__dict__["_SetEnable"] = _raise_uninitialized_error
        self.__dict__["_GetSegmentProperties"] = _raise_uninitialized_error
        self.__dict__["_GetCalcObjects"] = _raise_uninitialized_error
        self.__dict__["_GetParameters"] = _raise_uninitialized_error
        self.__dict__["_GetLanguageType"] = _raise_uninitialized_error
        self.__dict__["_SetLanguageType"] = _raise_uninitialized_error
        self.__dict__["_ScriptText"] = _raise_uninitialized_error
        self.__dict__["_CopyToClipboard"] = _raise_uninitialized_error
        self.__dict__["_PasteFromClipboard"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAProfileScriptingTool._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAProfileScriptingTool from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAProfile._private_init(self, pUnk)
        IID_IVAProfileScriptingTool = agcom.GUID(IVAProfileScriptingTool._uuid)
        vtable_offset_local = IVAProfileScriptingTool._vtable_offset - 1
        self.__dict__["_GetEnable"] = IAGFUNCTYPE(pUnk, IID_IVAProfileScriptingTool, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnable"] = IAGFUNCTYPE(pUnk, IID_IVAProfileScriptingTool, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetSegmentProperties"] = IAGFUNCTYPE(pUnk, IID_IVAProfileScriptingTool, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetCalcObjects"] = IAGFUNCTYPE(pUnk, IID_IVAProfileScriptingTool, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetParameters"] = IAGFUNCTYPE(pUnk, IID_IVAProfileScriptingTool, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_GetLanguageType"] = IAGFUNCTYPE(pUnk, IID_IVAProfileScriptingTool, vtable_offset_local+6, POINTER(agcom.LONG))
        self.__dict__["_SetLanguageType"] = IAGFUNCTYPE(pUnk, IID_IVAProfileScriptingTool, vtable_offset_local+7, agcom.LONG)
        self.__dict__["_ScriptText"] = IAGFUNCTYPE(pUnk, IID_IVAProfileScriptingTool, vtable_offset_local+8, agcom.BSTR)
        self.__dict__["_CopyToClipboard"] = IAGFUNCTYPE(pUnk, IID_IVAProfileScriptingTool, vtable_offset_local+9, )
        self.__dict__["_PasteFromClipboard"] = IAGFUNCTYPE(pUnk, IID_IVAProfileScriptingTool, vtable_offset_local+10, )
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAProfileScriptingTool.__dict__ and type(IVAProfileScriptingTool.__dict__[attrname]) == property:
            return IVAProfileScriptingTool.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAProfile.__setattr__(self, attrname, value)
    
    @property
    def Enable(self) -> bool:
        """If true, the scripting tool will be used."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Enable.setter
    def Enable(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnable"](arg_inVal.COM_val))

    @property
    def SegmentProperties(self) -> "IVAScriptingSegmentCollection":
        """Returns the collection of the segment properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetSegmentProperties"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def CalcObjects(self) -> "IVAScriptingCalcObjectCollection":
        """Returns the collection of the calc objects."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCalcObjects"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Parameters(self) -> "IVAScriptingParameterCollection":
        """Returns the collection of parameters."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetParameters"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def LanguageType(self) -> "AgEVALanguage":
        """The scripting language being used."""
        with agmarshall.AgEnum_arg(AgEVALanguage) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLanguageType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @LanguageType.setter
    def LanguageType(self, inVal:"AgEVALanguage") -> None:
        with agmarshall.AgEnum_arg(AgEVALanguage, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetLanguageType"](arg_inVal.COM_val))

    def ScriptText(self, script:str) -> None:
        """Injects the script into the scripting tool."""
        with agmarshall.BSTR_arg(script) as arg_script:
            agcls.evaluate_hresult(self.__dict__["_ScriptText"](arg_script.COM_val))

    def CopyToClipboard(self) -> None:
        """Copies entire scripting tool to clipboard."""
        agcls.evaluate_hresult(self.__dict__["_CopyToClipboard"]())

    def PasteFromClipboard(self) -> None:
        """Replaces entire scripting tool with scripting tool in clipboard."""
        agcls.evaluate_hresult(self.__dict__["_PasteFromClipboard"]())


agcls.AgClassCatalog.add_catalog_entry("{8D1192C7-8230-4475-BAFF-A135F9EE0ABD}", IVAProfileScriptingTool)
agcls.AgTypeNameMap["IVAProfileScriptingTool"] = IVAProfileScriptingTool

class IVAProfileChangeReturnSegment(IVAProfile):
    """Properties for a Change Return Segment profile."""
    _uuid = "{B65E05D2-1B1C-414C-A57E-A93333A5D57C}"
    _num_methods = 5
    _vtable_offset = IVAProfile._vtable_offset + IVAProfile._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSegmentName"] = _raise_uninitialized_error
        self.__dict__["_SetSegmentName"] = _raise_uninitialized_error
        self.__dict__["_SetSegment"] = _raise_uninitialized_error
        self.__dict__["_GetState"] = _raise_uninitialized_error
        self.__dict__["_SetState"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAProfileChangeReturnSegment._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAProfileChangeReturnSegment from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAProfile._private_init(self, pUnk)
        IID_IVAProfileChangeReturnSegment = agcom.GUID(IVAProfileChangeReturnSegment._uuid)
        vtable_offset_local = IVAProfileChangeReturnSegment._vtable_offset - 1
        self.__dict__["_GetSegmentName"] = IAGFUNCTYPE(pUnk, IID_IVAProfileChangeReturnSegment, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetSegmentName"] = IAGFUNCTYPE(pUnk, IID_IVAProfileChangeReturnSegment, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_SetSegment"] = IAGFUNCTYPE(pUnk, IID_IVAProfileChangeReturnSegment, vtable_offset_local+3, agcom.PVOID)
        self.__dict__["_GetState"] = IAGFUNCTYPE(pUnk, IID_IVAProfileChangeReturnSegment, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_SetState"] = IAGFUNCTYPE(pUnk, IID_IVAProfileChangeReturnSegment, vtable_offset_local+5, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAProfileChangeReturnSegment.__dict__ and type(IVAProfileChangeReturnSegment.__dict__[attrname]) == property:
            return IVAProfileChangeReturnSegment.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAProfile.__setattr__(self, attrname, value)
    
    @property
    def SegmentName(self) -> str:
        """The targeted return segment."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSegmentName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SegmentName.setter
    def SegmentName(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetSegmentName"](arg_newVal.COM_val))

    def SetSegment(self, pVAMCSReturn:"IVAMCSReturn") -> None:
        """Sets the return segment to target."""
        with agmarshall.AgInterface_in_arg(pVAMCSReturn, IVAMCSReturn) as arg_pVAMCSReturn:
            agcls.evaluate_hresult(self.__dict__["_SetSegment"](arg_pVAMCSReturn.COM_val))

    @property
    def State(self) -> "AgEVAReturnControl":
        """The new state for the targeted return segment."""
        with agmarshall.AgEnum_arg(AgEVAReturnControl) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetState"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @State.setter
    def State(self, newVal:"AgEVAReturnControl") -> None:
        with agmarshall.AgEnum_arg(AgEVAReturnControl, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetState"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{B65E05D2-1B1C-414C-A57E-A93333A5D57C}", IVAProfileChangeReturnSegment)
agcls.AgTypeNameMap["IVAProfileChangeReturnSegment"] = IVAProfileChangeReturnSegment

class IVAProfileChangePropagator(IVAProfile):
    """Properties for a Change Propagator profile."""
    _uuid = "{FB6704EC-C787-4051-BE39-1584C5CAD0F6}"
    _num_methods = 5
    _vtable_offset = IVAProfile._vtable_offset + IVAProfile._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSegmentName"] = _raise_uninitialized_error
        self.__dict__["_SetSegmentName"] = _raise_uninitialized_error
        self.__dict__["_SetSegment"] = _raise_uninitialized_error
        self.__dict__["_GetPropagatorName"] = _raise_uninitialized_error
        self.__dict__["_SetPropagatorName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAProfileChangePropagator._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAProfileChangePropagator from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAProfile._private_init(self, pUnk)
        IID_IVAProfileChangePropagator = agcom.GUID(IVAProfileChangePropagator._uuid)
        vtable_offset_local = IVAProfileChangePropagator._vtable_offset - 1
        self.__dict__["_GetSegmentName"] = IAGFUNCTYPE(pUnk, IID_IVAProfileChangePropagator, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetSegmentName"] = IAGFUNCTYPE(pUnk, IID_IVAProfileChangePropagator, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_SetSegment"] = IAGFUNCTYPE(pUnk, IID_IVAProfileChangePropagator, vtable_offset_local+3, agcom.PVOID)
        self.__dict__["_GetPropagatorName"] = IAGFUNCTYPE(pUnk, IID_IVAProfileChangePropagator, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_SetPropagatorName"] = IAGFUNCTYPE(pUnk, IID_IVAProfileChangePropagator, vtable_offset_local+5, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAProfileChangePropagator.__dict__ and type(IVAProfileChangePropagator.__dict__[attrname]) == property:
            return IVAProfileChangePropagator.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAProfile.__setattr__(self, attrname, value)
    
    @property
    def SegmentName(self) -> str:
        """The name of the profile."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSegmentName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SegmentName.setter
    def SegmentName(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetSegmentName"](arg_newVal.COM_val))

    def SetSegment(self, pVAMCSSegment:"IVAMCSSegment") -> None:
        """The targeted segment."""
        with agmarshall.AgInterface_in_arg(pVAMCSSegment, IVAMCSSegment) as arg_pVAMCSSegment:
            agcls.evaluate_hresult(self.__dict__["_SetSegment"](arg_pVAMCSSegment.COM_val))

    @property
    def PropagatorName(self) -> str:
        """The new propagator's name."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPropagatorName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @PropagatorName.setter
    def PropagatorName(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetPropagatorName"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{FB6704EC-C787-4051-BE39-1584C5CAD0F6}", IVAProfileChangePropagator)
agcls.AgTypeNameMap["IVAProfileChangePropagator"] = IVAProfileChangePropagator

class IVAProfileChangeStopSegment(IVAProfile):
    """Properties for a Change Stop Segment profile."""
    _uuid = "{1B9A0E28-8C19-448D-9CD1-AB10B492C767}"
    _num_methods = 5
    _vtable_offset = IVAProfile._vtable_offset + IVAProfile._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSegmentName"] = _raise_uninitialized_error
        self.__dict__["_SetSegmentName"] = _raise_uninitialized_error
        self.__dict__["_SetSegment"] = _raise_uninitialized_error
        self.__dict__["_GetState"] = _raise_uninitialized_error
        self.__dict__["_SetState"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAProfileChangeStopSegment._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAProfileChangeStopSegment from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAProfile._private_init(self, pUnk)
        IID_IVAProfileChangeStopSegment = agcom.GUID(IVAProfileChangeStopSegment._uuid)
        vtable_offset_local = IVAProfileChangeStopSegment._vtable_offset - 1
        self.__dict__["_GetSegmentName"] = IAGFUNCTYPE(pUnk, IID_IVAProfileChangeStopSegment, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetSegmentName"] = IAGFUNCTYPE(pUnk, IID_IVAProfileChangeStopSegment, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_SetSegment"] = IAGFUNCTYPE(pUnk, IID_IVAProfileChangeStopSegment, vtable_offset_local+3, agcom.PVOID)
        self.__dict__["_GetState"] = IAGFUNCTYPE(pUnk, IID_IVAProfileChangeStopSegment, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_SetState"] = IAGFUNCTYPE(pUnk, IID_IVAProfileChangeStopSegment, vtable_offset_local+5, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAProfileChangeStopSegment.__dict__ and type(IVAProfileChangeStopSegment.__dict__[attrname]) == property:
            return IVAProfileChangeStopSegment.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAProfile.__setattr__(self, attrname, value)
    
    @property
    def SegmentName(self) -> str:
        """The targeted stop segment."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSegmentName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SegmentName.setter
    def SegmentName(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetSegmentName"](arg_newVal.COM_val))

    def SetSegment(self, pVAMCSStop:"IVAMCSStop") -> None:
        """Sets the stop segment to target."""
        with agmarshall.AgInterface_in_arg(pVAMCSStop, IVAMCSStop) as arg_pVAMCSStop:
            agcls.evaluate_hresult(self.__dict__["_SetSegment"](arg_pVAMCSStop.COM_val))

    @property
    def State(self) -> "AgEVAState":
        """The new state of the targeted stop segment."""
        with agmarshall.AgEnum_arg(AgEVAState) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetState"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @State.setter
    def State(self, newVal:"AgEVAState") -> None:
        with agmarshall.AgEnum_arg(AgEVAState, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetState"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{1B9A0E28-8C19-448D-9CD1-AB10B492C767}", IVAProfileChangeStopSegment)
agcls.AgTypeNameMap["IVAProfileChangeStopSegment"] = IVAProfileChangeStopSegment

class IVAProfileChangeStoppingConditionState(IVAProfile):
    """Properties for a Change Stopping Condition State profile."""
    _uuid = "{977C9F84-852A-4B5D-861B-8F9E3809CE7D}"
    _num_methods = 8
    _vtable_offset = IVAProfile._vtable_offset + IVAProfile._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSegmentName"] = _raise_uninitialized_error
        self.__dict__["_SetSegmentName"] = _raise_uninitialized_error
        self.__dict__["_SetSegment"] = _raise_uninitialized_error
        self.__dict__["_GetState"] = _raise_uninitialized_error
        self.__dict__["_SetState"] = _raise_uninitialized_error
        self.__dict__["_SetTrigger"] = _raise_uninitialized_error
        self.__dict__["_GetTriggerName"] = _raise_uninitialized_error
        self.__dict__["_SetTriggerName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAProfileChangeStoppingConditionState._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAProfileChangeStoppingConditionState from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAProfile._private_init(self, pUnk)
        IID_IVAProfileChangeStoppingConditionState = agcom.GUID(IVAProfileChangeStoppingConditionState._uuid)
        vtable_offset_local = IVAProfileChangeStoppingConditionState._vtable_offset - 1
        self.__dict__["_GetSegmentName"] = IAGFUNCTYPE(pUnk, IID_IVAProfileChangeStoppingConditionState, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetSegmentName"] = IAGFUNCTYPE(pUnk, IID_IVAProfileChangeStoppingConditionState, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_SetSegment"] = IAGFUNCTYPE(pUnk, IID_IVAProfileChangeStoppingConditionState, vtable_offset_local+3, agcom.PVOID)
        self.__dict__["_GetState"] = IAGFUNCTYPE(pUnk, IID_IVAProfileChangeStoppingConditionState, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_SetState"] = IAGFUNCTYPE(pUnk, IID_IVAProfileChangeStoppingConditionState, vtable_offset_local+5, agcom.LONG)
        self.__dict__["_SetTrigger"] = IAGFUNCTYPE(pUnk, IID_IVAProfileChangeStoppingConditionState, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_GetTriggerName"] = IAGFUNCTYPE(pUnk, IID_IVAProfileChangeStoppingConditionState, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_SetTriggerName"] = IAGFUNCTYPE(pUnk, IID_IVAProfileChangeStoppingConditionState, vtable_offset_local+8, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAProfileChangeStoppingConditionState.__dict__ and type(IVAProfileChangeStoppingConditionState.__dict__[attrname]) == property:
            return IVAProfileChangeStoppingConditionState.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAProfile.__setattr__(self, attrname, value)
    
    @property
    def SegmentName(self) -> str:
        """The segment that contains the targeted stopping condition."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSegmentName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SegmentName.setter
    def SegmentName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSegmentName"](arg_inVal.COM_val))

    def SetSegment(self, mCSSegment:"IVAMCSSegment") -> None:
        """Sets the targeted segment."""
        with agmarshall.AgInterface_in_arg(mCSSegment, IVAMCSSegment) as arg_mCSSegment:
            agcls.evaluate_hresult(self.__dict__["_SetSegment"](arg_mCSSegment.COM_val))

    @property
    def State(self) -> "AgEVAState":
        """The new state of the targeted stopping condition."""
        with agmarshall.AgEnum_arg(AgEVAState) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetState"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @State.setter
    def State(self, newVal:"AgEVAState") -> None:
        with agmarshall.AgEnum_arg(AgEVAState, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetState"](arg_newVal.COM_val))

    def SetTrigger(self, stoppingCondition:"IVAStoppingCondition") -> None:
        """The targeted stopping condition."""
        with agmarshall.AgInterface_in_arg(stoppingCondition, IVAStoppingCondition) as arg_stoppingCondition:
            agcls.evaluate_hresult(self.__dict__["_SetTrigger"](arg_stoppingCondition.COM_val))

    @property
    def TriggerName(self) -> str:
        """The name of the targeted stopping condition."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTriggerName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TriggerName.setter
    def TriggerName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetTriggerName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{977C9F84-852A-4B5D-861B-8F9E3809CE7D}", IVAProfileChangeStoppingConditionState)
agcls.AgTypeNameMap["IVAProfileChangeStoppingConditionState"] = IVAProfileChangeStoppingConditionState

class IVAProfileSeedFiniteManeuver(IVAProfile):
    """Properties for a Seed Finite Maneuver segment."""
    _uuid = "{C56665D5-CEF3-47A1-854E-64CB0A8CA9CA}"
    _num_methods = 5
    _vtable_offset = IVAProfile._vtable_offset + IVAProfile._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSegmentName"] = _raise_uninitialized_error
        self.__dict__["_SetSegmentName"] = _raise_uninitialized_error
        self.__dict__["_SetSegment"] = _raise_uninitialized_error
        self.__dict__["_GetLeaveAllActiveStoppingConditionsActive"] = _raise_uninitialized_error
        self.__dict__["_SetLeaveAllActiveStoppingConditionsActive"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAProfileSeedFiniteManeuver._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAProfileSeedFiniteManeuver from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAProfile._private_init(self, pUnk)
        IID_IVAProfileSeedFiniteManeuver = agcom.GUID(IVAProfileSeedFiniteManeuver._uuid)
        vtable_offset_local = IVAProfileSeedFiniteManeuver._vtable_offset - 1
        self.__dict__["_GetSegmentName"] = IAGFUNCTYPE(pUnk, IID_IVAProfileSeedFiniteManeuver, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetSegmentName"] = IAGFUNCTYPE(pUnk, IID_IVAProfileSeedFiniteManeuver, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_SetSegment"] = IAGFUNCTYPE(pUnk, IID_IVAProfileSeedFiniteManeuver, vtable_offset_local+3, agcom.PVOID)
        self.__dict__["_GetLeaveAllActiveStoppingConditionsActive"] = IAGFUNCTYPE(pUnk, IID_IVAProfileSeedFiniteManeuver, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetLeaveAllActiveStoppingConditionsActive"] = IAGFUNCTYPE(pUnk, IID_IVAProfileSeedFiniteManeuver, vtable_offset_local+5, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAProfileSeedFiniteManeuver.__dict__ and type(IVAProfileSeedFiniteManeuver.__dict__[attrname]) == property:
            return IVAProfileSeedFiniteManeuver.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAProfile.__setattr__(self, attrname, value)
    
    @property
    def SegmentName(self) -> str:
        """The targeted maneuver segment."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSegmentName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SegmentName.setter
    def SegmentName(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetSegmentName"](arg_newVal.COM_val))

    def SetSegment(self, pVAMCSManeuver:"IVAMCSManeuver") -> None:
        """Sets the maneuver segment to target."""
        with agmarshall.AgInterface_in_arg(pVAMCSManeuver, IVAMCSManeuver) as arg_pVAMCSManeuver:
            agcls.evaluate_hresult(self.__dict__["_SetSegment"](arg_pVAMCSManeuver.COM_val))

    @property
    def LeaveAllActiveStoppingConditionsActive(self) -> bool:
        """If true, all active stopping conditions on the seeded maneuver will remain active during run."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLeaveAllActiveStoppingConditionsActive"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @LeaveAllActiveStoppingConditionsActive.setter
    def LeaveAllActiveStoppingConditionsActive(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetLeaveAllActiveStoppingConditionsActive"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{C56665D5-CEF3-47A1-854E-64CB0A8CA9CA}", IVAProfileSeedFiniteManeuver)
agcls.AgTypeNameMap["IVAProfileSeedFiniteManeuver"] = IVAProfileSeedFiniteManeuver

class IVAProfileRunOnce(IVAProfile):
    """Properties for a Run Once profile."""
    _uuid = "{75574EA3-277E-4A6D-9529-3342088679DB}"
    _num_methods = 0
    _vtable_offset = IVAProfile._vtable_offset + IVAProfile._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAProfileRunOnce._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAProfileRunOnce from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAProfile._private_init(self, pUnk)
        IID_IVAProfileRunOnce = agcom.GUID(IVAProfileRunOnce._uuid)
        vtable_offset_local = IVAProfileRunOnce._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAProfileRunOnce.__dict__ and type(IVAProfileRunOnce.__dict__[attrname]) == property:
            return IVAProfileRunOnce.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAProfile.__setattr__(self, attrname, value)
    

agcls.AgClassCatalog.add_catalog_entry("{75574EA3-277E-4A6D-9529-3342088679DB}", IVAProfileRunOnce)
agcls.AgTypeNameMap["IVAProfileRunOnce"] = IVAProfileRunOnce

class IVAUserVariableDefinition(object):
    """Properties for a User Variable definition."""
    _uuid = "{25F2A622-8F6A-4CBB-91C6-ED5AD9C24028}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetUnitDimension"] = _raise_uninitialized_error
        self.__dict__["_SetUnitDimension"] = _raise_uninitialized_error
        self.__dict__["_GetVariableName"] = _raise_uninitialized_error
        self.__dict__["_SetVariableName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAUserVariableDefinition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAUserVariableDefinition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAUserVariableDefinition = agcom.GUID(IVAUserVariableDefinition._uuid)
        vtable_offset_local = IVAUserVariableDefinition._vtable_offset - 1
        self.__dict__["_GetUnitDimension"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariableDefinition, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetUnitDimension"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariableDefinition, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetVariableName"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariableDefinition, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetVariableName"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariableDefinition, vtable_offset_local+4, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAUserVariableDefinition.__dict__ and type(IVAUserVariableDefinition.__dict__[attrname]) == property:
            return IVAUserVariableDefinition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAUserVariableDefinition.")
    
    @property
    def UnitDimension(self) -> str:
        """The dimension of the user variable."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUnitDimension"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UnitDimension.setter
    def UnitDimension(self, inVal:str) -> None:
        """The dimension of the user variable."""
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUnitDimension"](arg_inVal.COM_val))

    @property
    def VariableName(self) -> str:
        """The name of the user variable."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVariableName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VariableName.setter
    def VariableName(self, inVal:str) -> None:
        """The name of the user variable."""
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVariableName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{25F2A622-8F6A-4CBB-91C6-ED5AD9C24028}", IVAUserVariableDefinition)
agcls.AgTypeNameMap["IVAUserVariableDefinition"] = IVAUserVariableDefinition

class IVAUserVariable(object):
    """The properties for a User Variable initial value."""
    _uuid = "{31B617D6-AE6D-46CE-845D-90FFCD7A5B13}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetUnitDimension"] = _raise_uninitialized_error
        self.__dict__["_GetVariableName"] = _raise_uninitialized_error
        self.__dict__["_GetVariableValue"] = _raise_uninitialized_error
        self.__dict__["_SetVariableValue"] = _raise_uninitialized_error
        self.__dict__["_EnableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_DisableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_IsControlParameterEnabled"] = _raise_uninitialized_error
        self.__dict__["_GetControlParametersAvailable"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAUserVariable._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAUserVariable from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAUserVariable = agcom.GUID(IVAUserVariable._uuid)
        vtable_offset_local = IVAUserVariable._vtable_offset - 1
        self.__dict__["_GetUnitDimension"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariable, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_GetVariableName"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariable, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_GetVariableValue"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariable, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_SetVariableValue"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariable, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_EnableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariable, vtable_offset_local+5, )
        self.__dict__["_DisableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariable, vtable_offset_local+6, )
        self.__dict__["_IsControlParameterEnabled"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariable, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetControlParametersAvailable"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariable, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAUserVariable.__dict__ and type(IVAUserVariable.__dict__[attrname]) == property:
            return IVAUserVariable.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAUserVariable.")
    
    @property
    def UnitDimension(self) -> str:
        """The dimension of the user variable."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUnitDimension"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def VariableName(self) -> str:
        """The name of the user variable."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVariableName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def VariableValue(self) -> typing.Any:
        """The initial value of the user variable."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVariableValue"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VariableValue.setter
    def VariableValue(self, inVal:typing.Any) -> None:
        """The initial value of the user variable."""
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVariableValue"](arg_inVal.COM_val))

    def EnableControlParameter(self) -> None:
        """Enables or disables the specified control parameter."""
        agcls.evaluate_hresult(self.__dict__["_EnableControlParameter"]())

    def DisableControlParameter(self) -> None:
        """Disables the specified control parameter."""
        agcls.evaluate_hresult(self.__dict__["_DisableControlParameter"]())

    def IsControlParameterEnabled(self) -> bool:
        """Sees if the specified control is enabled."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_IsControlParameterEnabled"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ControlParametersAvailable(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetControlParametersAvailable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{31B617D6-AE6D-46CE-845D-90FFCD7A5B13}", IVAUserVariable)
agcls.AgTypeNameMap["IVAUserVariable"] = IVAUserVariable

class IVAUserVariableUpdate(object):
    """Properties for a User Variable update."""
    _uuid = "{14F87E74-D85B-40D1-86FF-97E7F514FCF7}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetUnitDimension"] = _raise_uninitialized_error
        self.__dict__["_GetVariableName"] = _raise_uninitialized_error
        self.__dict__["_GetVariableValue"] = _raise_uninitialized_error
        self.__dict__["_SetVariableValue"] = _raise_uninitialized_error
        self.__dict__["_GetVariableAction"] = _raise_uninitialized_error
        self.__dict__["_SetVariableAction"] = _raise_uninitialized_error
        self.__dict__["_EnableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_DisableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_IsControlParameterEnabled"] = _raise_uninitialized_error
        self.__dict__["_GetControlParametersAvailable"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAUserVariableUpdate._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAUserVariableUpdate from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAUserVariableUpdate = agcom.GUID(IVAUserVariableUpdate._uuid)
        vtable_offset_local = IVAUserVariableUpdate._vtable_offset - 1
        self.__dict__["_GetUnitDimension"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariableUpdate, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_GetVariableName"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariableUpdate, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_GetVariableValue"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariableUpdate, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_SetVariableValue"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariableUpdate, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_GetVariableAction"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariableUpdate, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetVariableAction"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariableUpdate, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_EnableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariableUpdate, vtable_offset_local+7, )
        self.__dict__["_DisableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariableUpdate, vtable_offset_local+8, )
        self.__dict__["_IsControlParameterEnabled"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariableUpdate, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetControlParametersAvailable"] = IAGFUNCTYPE(pUnk, IID_IVAUserVariableUpdate, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAUserVariableUpdate.__dict__ and type(IVAUserVariableUpdate.__dict__[attrname]) == property:
            return IVAUserVariableUpdate.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAUserVariableUpdate.")
    
    @property
    def UnitDimension(self) -> str:
        """The dimension of the user variable."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUnitDimension"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def VariableName(self) -> str:
        """The name of the user variable."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVariableName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def VariableValue(self) -> typing.Any:
        """Update value of the user variable."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVariableValue"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VariableValue.setter
    def VariableValue(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVariableValue"](arg_inVal.COM_val))

    @property
    def VariableAction(self) -> "AgEVAUpdateAction":
        """Action to be performed using the value."""
        with agmarshall.AgEnum_arg(AgEVAUpdateAction) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVariableAction"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VariableAction.setter
    def VariableAction(self, inVal:"AgEVAUpdateAction") -> None:
        with agmarshall.AgEnum_arg(AgEVAUpdateAction, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVariableAction"](arg_inVal.COM_val))

    def EnableControlParameter(self) -> None:
        """Enables or disables the specified control parameter."""
        agcls.evaluate_hresult(self.__dict__["_EnableControlParameter"]())

    def DisableControlParameter(self) -> None:
        """Disables the specified control parameter."""
        agcls.evaluate_hresult(self.__dict__["_DisableControlParameter"]())

    def IsControlParameterEnabled(self) -> bool:
        """Sees if the specified control is enabled."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_IsControlParameterEnabled"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ControlParametersAvailable(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetControlParametersAvailable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{14F87E74-D85B-40D1-86FF-97E7F514FCF7}", IVAUserVariableUpdate)
agcls.AgTypeNameMap["IVAUserVariableUpdate"] = IVAUserVariableUpdate

class IVAProfileSNOPTOptimizer(IVAProfile):
    """Properties of SNOPT Optimizer profile."""
    _uuid = "{6BE54C72-2B85-4925-B969-5602527616A1}"
    _num_methods = 22
    _vtable_offset = IVAProfile._vtable_offset + IVAProfile._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetControlParameters"] = _raise_uninitialized_error
        self.__dict__["_GetResults"] = _raise_uninitialized_error
        self.__dict__["_GetTargeterGraphs"] = _raise_uninitialized_error
        self.__dict__["_GetScriptingTool"] = _raise_uninitialized_error
        self.__dict__["_GetResetControlsBeforeRun"] = _raise_uninitialized_error
        self.__dict__["_SetResetControlsBeforeRun"] = _raise_uninitialized_error
        self.__dict__["_GetMaxMajorIterations"] = _raise_uninitialized_error
        self.__dict__["_SetMaxMajorIterations"] = _raise_uninitialized_error
        self.__dict__["_GetToleranceOnMajorFeasibility"] = _raise_uninitialized_error
        self.__dict__["_SetToleranceOnMajorFeasibility"] = _raise_uninitialized_error
        self.__dict__["_GetToleranceOnMajorOptimality"] = _raise_uninitialized_error
        self.__dict__["_SetToleranceOnMajorOptimality"] = _raise_uninitialized_error
        self.__dict__["_GetMaxMinorIterations"] = _raise_uninitialized_error
        self.__dict__["_SetMaxMinorIterations"] = _raise_uninitialized_error
        self.__dict__["_GetToleranceOnMinorFeasibility"] = _raise_uninitialized_error
        self.__dict__["_SetToleranceOnMinorFeasibility"] = _raise_uninitialized_error
        self.__dict__["_GetToleranceOnMinorOptimality"] = _raise_uninitialized_error
        self.__dict__["_SetToleranceOnMinorOptimality"] = _raise_uninitialized_error
        self.__dict__["_GetOptionsFilename"] = _raise_uninitialized_error
        self.__dict__["_SetOptionsFilename"] = _raise_uninitialized_error
        self.__dict__["_GetAllowInternalPrimalInfeasibilityMeasureNormalization"] = _raise_uninitialized_error
        self.__dict__["_SetAllowInternalPrimalInfeasibilityMeasureNormalization"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAProfileSNOPTOptimizer._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAProfileSNOPTOptimizer from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAProfile._private_init(self, pUnk)
        IID_IVAProfileSNOPTOptimizer = agcom.GUID(IVAProfileSNOPTOptimizer._uuid)
        vtable_offset_local = IVAProfileSNOPTOptimizer._vtable_offset - 1
        self.__dict__["_GetControlParameters"] = IAGFUNCTYPE(pUnk, IID_IVAProfileSNOPTOptimizer, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetResults"] = IAGFUNCTYPE(pUnk, IID_IVAProfileSNOPTOptimizer, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetTargeterGraphs"] = IAGFUNCTYPE(pUnk, IID_IVAProfileSNOPTOptimizer, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetScriptingTool"] = IAGFUNCTYPE(pUnk, IID_IVAProfileSNOPTOptimizer, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetResetControlsBeforeRun"] = IAGFUNCTYPE(pUnk, IID_IVAProfileSNOPTOptimizer, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetResetControlsBeforeRun"] = IAGFUNCTYPE(pUnk, IID_IVAProfileSNOPTOptimizer, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetMaxMajorIterations"] = IAGFUNCTYPE(pUnk, IID_IVAProfileSNOPTOptimizer, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetMaxMajorIterations"] = IAGFUNCTYPE(pUnk, IID_IVAProfileSNOPTOptimizer, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetToleranceOnMajorFeasibility"] = IAGFUNCTYPE(pUnk, IID_IVAProfileSNOPTOptimizer, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetToleranceOnMajorFeasibility"] = IAGFUNCTYPE(pUnk, IID_IVAProfileSNOPTOptimizer, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetToleranceOnMajorOptimality"] = IAGFUNCTYPE(pUnk, IID_IVAProfileSNOPTOptimizer, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetToleranceOnMajorOptimality"] = IAGFUNCTYPE(pUnk, IID_IVAProfileSNOPTOptimizer, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetMaxMinorIterations"] = IAGFUNCTYPE(pUnk, IID_IVAProfileSNOPTOptimizer, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_SetMaxMinorIterations"] = IAGFUNCTYPE(pUnk, IID_IVAProfileSNOPTOptimizer, vtable_offset_local+14, agcom.LONG)
        self.__dict__["_GetToleranceOnMinorFeasibility"] = IAGFUNCTYPE(pUnk, IID_IVAProfileSNOPTOptimizer, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_SetToleranceOnMinorFeasibility"] = IAGFUNCTYPE(pUnk, IID_IVAProfileSNOPTOptimizer, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_GetToleranceOnMinorOptimality"] = IAGFUNCTYPE(pUnk, IID_IVAProfileSNOPTOptimizer, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_SetToleranceOnMinorOptimality"] = IAGFUNCTYPE(pUnk, IID_IVAProfileSNOPTOptimizer, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_GetOptionsFilename"] = IAGFUNCTYPE(pUnk, IID_IVAProfileSNOPTOptimizer, vtable_offset_local+19, POINTER(agcom.BSTR))
        self.__dict__["_SetOptionsFilename"] = IAGFUNCTYPE(pUnk, IID_IVAProfileSNOPTOptimizer, vtable_offset_local+20, agcom.BSTR)
        self.__dict__["_GetAllowInternalPrimalInfeasibilityMeasureNormalization"] = IAGFUNCTYPE(pUnk, IID_IVAProfileSNOPTOptimizer, vtable_offset_local+21, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetAllowInternalPrimalInfeasibilityMeasureNormalization"] = IAGFUNCTYPE(pUnk, IID_IVAProfileSNOPTOptimizer, vtable_offset_local+22, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAProfileSNOPTOptimizer.__dict__ and type(IVAProfileSNOPTOptimizer.__dict__[attrname]) == property:
            return IVAProfileSNOPTOptimizer.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAProfile.__setattr__(self, attrname, value)
    
    @property
    def ControlParameters(self) -> "IVASNOPTControlCollection":
        """The list of control parameters defined for the profile."""
        with agmarshall.AgInterface_out_arg() as arg_ppVASNOPTControlCollection:
            agcls.evaluate_hresult(self.__dict__["_GetControlParameters"](byref(arg_ppVASNOPTControlCollection.COM_val)))
            return arg_ppVASNOPTControlCollection.python_val

    @property
    def Results(self) -> "IVASNOPTResultCollection":
        """The list of results defined for the profile."""
        with agmarshall.AgInterface_out_arg() as arg_ppVASNOPTResultCollection:
            agcls.evaluate_hresult(self.__dict__["_GetResults"](byref(arg_ppVASNOPTResultCollection.COM_val)))
            return arg_ppVASNOPTResultCollection.python_val

    @property
    def TargeterGraphs(self) -> "IVATargeterGraphCollection":
        """Graphs"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargeterGraphs"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ScriptingTool(self) -> "IVAScriptingTool":
        """Returns the Scripting tool for the sequence."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScriptingTool"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ResetControlsBeforeRun(self) -> bool:
        """Reset controls before each run."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetResetControlsBeforeRun"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ResetControlsBeforeRun.setter
    def ResetControlsBeforeRun(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetResetControlsBeforeRun"](arg_newVal.COM_val))

    @property
    def MaxMajorIterations(self) -> int:
        """The maximum number of major iterations allowed."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxMajorIterations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxMajorIterations.setter
    def MaxMajorIterations(self, newVal:int) -> None:
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxMajorIterations"](arg_newVal.COM_val))

    @property
    def ToleranceOnMajorFeasibility(self) -> float:
        """Specifies how accurately the nonlinear constraints should be satisfied."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetToleranceOnMajorFeasibility"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ToleranceOnMajorFeasibility.setter
    def ToleranceOnMajorFeasibility(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetToleranceOnMajorFeasibility"](arg_newVal.COM_val))

    @property
    def ToleranceOnMajorOptimality(self) -> float:
        """Specifies the final accuracy of the dual variables."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetToleranceOnMajorOptimality"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ToleranceOnMajorOptimality.setter
    def ToleranceOnMajorOptimality(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetToleranceOnMajorOptimality"](arg_newVal.COM_val))

    @property
    def MaxMinorIterations(self) -> int:
        """The maximum number of iterations for the QP subproblem allowed during a single major iteration."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxMinorIterations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxMinorIterations.setter
    def MaxMinorIterations(self, newVal:int) -> None:
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxMinorIterations"](arg_newVal.COM_val))

    @property
    def ToleranceOnMinorFeasibility(self) -> float:
        """The tolerance which the QP subproblem must meet before being considered feasible."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetToleranceOnMinorFeasibility"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ToleranceOnMinorFeasibility.setter
    def ToleranceOnMinorFeasibility(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetToleranceOnMinorFeasibility"](arg_newVal.COM_val))

    @property
    def ToleranceOnMinorOptimality(self) -> float:
        """This option is undocumented in the SNOPT literature, and included here for completeness in terms of tolerance options."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetToleranceOnMinorOptimality"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ToleranceOnMinorOptimality.setter
    def ToleranceOnMinorOptimality(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetToleranceOnMinorOptimality"](arg_newVal.COM_val))

    @property
    def OptionsFilename(self) -> str:
        """If used, the associated SNOPT specifications file may define any of the various SNOPT options. Options in the file that conflict with options specified elsewhere will take precedence."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetOptionsFilename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @OptionsFilename.setter
    def OptionsFilename(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetOptionsFilename"](arg_newVal.COM_val))

    @property
    def AllowInternalPrimalInfeasibilityMeasureNormalization(self) -> bool:
        """Whether to allow internal normalization of the primal infeasibility measure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAllowInternalPrimalInfeasibilityMeasureNormalization"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AllowInternalPrimalInfeasibilityMeasureNormalization.setter
    def AllowInternalPrimalInfeasibilityMeasureNormalization(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetAllowInternalPrimalInfeasibilityMeasureNormalization"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{6BE54C72-2B85-4925-B969-5602527616A1}", IVAProfileSNOPTOptimizer)
agcls.AgTypeNameMap["IVAProfileSNOPTOptimizer"] = IVAProfileSNOPTOptimizer

class IVASNOPTControl(object):
    """Properties for control parameters of a SNOPT profile."""
    _uuid = "{4C637192-8687-4218-9BD6-A7B7C7B6E720}"
    _num_methods = 17
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEnable"] = _raise_uninitialized_error
        self.__dict__["_SetEnable"] = _raise_uninitialized_error
        self.__dict__["_GetName"] = _raise_uninitialized_error
        self.__dict__["_GetParentName"] = _raise_uninitialized_error
        self.__dict__["_GetInitialValue"] = _raise_uninitialized_error
        self.__dict__["_GetCurrentValue"] = _raise_uninitialized_error
        self.__dict__["_SetCurrentValue"] = _raise_uninitialized_error
        self.__dict__["_GetLowerBound"] = _raise_uninitialized_error
        self.__dict__["_SetLowerBound"] = _raise_uninitialized_error
        self.__dict__["_GetUpperBound"] = _raise_uninitialized_error
        self.__dict__["_SetUpperBound"] = _raise_uninitialized_error
        self.__dict__["_GetScalingValue"] = _raise_uninitialized_error
        self.__dict__["_SetScalingValue"] = _raise_uninitialized_error
        self.__dict__["_GetUseCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_SetUseCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_GetCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_SetCustomDisplayUnit"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVASNOPTControl._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVASNOPTControl from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVASNOPTControl = agcom.GUID(IVASNOPTControl._uuid)
        vtable_offset_local = IVASNOPTControl._vtable_offset - 1
        self.__dict__["_GetEnable"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTControl, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnable"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTControl, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetName"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTControl, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_GetParentName"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTControl, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_GetInitialValue"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTControl, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_GetCurrentValue"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTControl, vtable_offset_local+6, POINTER(agcom.VARIANT))
        self.__dict__["_SetCurrentValue"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTControl, vtable_offset_local+7, agcom.VARIANT)
        self.__dict__["_GetLowerBound"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTControl, vtable_offset_local+8, POINTER(agcom.VARIANT))
        self.__dict__["_SetLowerBound"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTControl, vtable_offset_local+9, agcom.VARIANT)
        self.__dict__["_GetUpperBound"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTControl, vtable_offset_local+10, POINTER(agcom.VARIANT))
        self.__dict__["_SetUpperBound"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTControl, vtable_offset_local+11, agcom.VARIANT)
        self.__dict__["_GetScalingValue"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTControl, vtable_offset_local+12, POINTER(agcom.VARIANT))
        self.__dict__["_SetScalingValue"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTControl, vtable_offset_local+13, agcom.VARIANT)
        self.__dict__["_GetUseCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTControl, vtable_offset_local+14, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTControl, vtable_offset_local+15, agcom.VARIANT_BOOL)
        self.__dict__["_GetCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTControl, vtable_offset_local+16, POINTER(agcom.BSTR))
        self.__dict__["_SetCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTControl, vtable_offset_local+17, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVASNOPTControl.__dict__ and type(IVASNOPTControl.__dict__[attrname]) == property:
            return IVASNOPTControl.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVASNOPTControl.")
    
    @property
    def Enable(self) -> bool:
        """If true, the variable is being used."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Enable.setter
    def Enable(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnable"](arg_newVal.COM_val))

    @property
    def Name(self) -> str:
        """The name of the parameter."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ParentName(self) -> str:
        """The name of the segment to which the parameter belongs."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetParentName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def InitialValue(self) -> typing.Any:
        """The nominal value of the element selected as a parameter. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetInitialValue"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def CurrentValue(self) -> typing.Any:
        """The value of the independent variable after the last targeter run."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCurrentValue"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CurrentValue.setter
    def CurrentValue(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCurrentValue"](arg_newVal.COM_val))

    @property
    def LowerBound(self) -> typing.Any:
        """Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLowerBound"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @LowerBound.setter
    def LowerBound(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetLowerBound"](arg_newVal.COM_val))

    @property
    def UpperBound(self) -> typing.Any:
        """Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUpperBound"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UpperBound.setter
    def UpperBound(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetUpperBound"](arg_newVal.COM_val))

    @property
    def ScalingValue(self) -> typing.Any:
        """Applies to the Specified Value scaling method. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetScalingValue"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ScalingValue.setter
    def ScalingValue(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetScalingValue"](arg_newVal.COM_val))

    @property
    def UseCustomDisplayUnit(self) -> bool:
        """If true, allows display of values in another unit."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCustomDisplayUnit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseCustomDisplayUnit.setter
    def UseCustomDisplayUnit(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseCustomDisplayUnit"](arg_newVal.COM_val))

    @property
    def CustomDisplayUnit(self) -> str:
        """The unit in which the value will be displayed in the GUI."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCustomDisplayUnit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CustomDisplayUnit.setter
    def CustomDisplayUnit(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCustomDisplayUnit"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4C637192-8687-4218-9BD6-A7B7C7B6E720}", IVASNOPTControl)
agcls.AgTypeNameMap["IVASNOPTControl"] = IVASNOPTControl

class IVASNOPTResult(object):
    """Properties for objecvtive and constraints of a SNOPT profile."""
    _uuid = "{79392E1D-E3C7-4403-9D4C-1C13AB8368A9}"
    _num_methods = 19
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEnable"] = _raise_uninitialized_error
        self.__dict__["_SetEnable"] = _raise_uninitialized_error
        self.__dict__["_GetName"] = _raise_uninitialized_error
        self.__dict__["_GetCurrentValue"] = _raise_uninitialized_error
        self.__dict__["_GetParentName"] = _raise_uninitialized_error
        self.__dict__["_GetLowerBound"] = _raise_uninitialized_error
        self.__dict__["_SetLowerBound"] = _raise_uninitialized_error
        self.__dict__["_GetUpperBound"] = _raise_uninitialized_error
        self.__dict__["_SetUpperBound"] = _raise_uninitialized_error
        self.__dict__["_GetScalingValue"] = _raise_uninitialized_error
        self.__dict__["_SetScalingValue"] = _raise_uninitialized_error
        self.__dict__["_GetWeight"] = _raise_uninitialized_error
        self.__dict__["_SetWeight"] = _raise_uninitialized_error
        self.__dict__["_GetGoal"] = _raise_uninitialized_error
        self.__dict__["_SetGoal"] = _raise_uninitialized_error
        self.__dict__["_GetUseCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_SetUseCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_GetCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_SetCustomDisplayUnit"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVASNOPTResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVASNOPTResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVASNOPTResult = agcom.GUID(IVASNOPTResult._uuid)
        vtable_offset_local = IVASNOPTResult._vtable_offset - 1
        self.__dict__["_GetEnable"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnable"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTResult, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetName"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTResult, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_GetCurrentValue"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTResult, vtable_offset_local+4, POINTER(agcom.VARIANT))
        self.__dict__["_GetParentName"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTResult, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_GetLowerBound"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTResult, vtable_offset_local+6, POINTER(agcom.VARIANT))
        self.__dict__["_SetLowerBound"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTResult, vtable_offset_local+7, agcom.VARIANT)
        self.__dict__["_GetUpperBound"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTResult, vtable_offset_local+8, POINTER(agcom.VARIANT))
        self.__dict__["_SetUpperBound"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTResult, vtable_offset_local+9, agcom.VARIANT)
        self.__dict__["_GetScalingValue"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTResult, vtable_offset_local+10, POINTER(agcom.VARIANT))
        self.__dict__["_SetScalingValue"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTResult, vtable_offset_local+11, agcom.VARIANT)
        self.__dict__["_GetWeight"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTResult, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_SetWeight"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTResult, vtable_offset_local+13, agcom.DOUBLE)
        self.__dict__["_GetGoal"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTResult, vtable_offset_local+14, POINTER(agcom.LONG))
        self.__dict__["_SetGoal"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTResult, vtable_offset_local+15, agcom.LONG)
        self.__dict__["_GetUseCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTResult, vtable_offset_local+16, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTResult, vtable_offset_local+17, agcom.VARIANT_BOOL)
        self.__dict__["_GetCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTResult, vtable_offset_local+18, POINTER(agcom.BSTR))
        self.__dict__["_SetCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVASNOPTResult, vtable_offset_local+19, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVASNOPTResult.__dict__ and type(IVASNOPTResult.__dict__[attrname]) == property:
            return IVASNOPTResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVASNOPTResult.")
    
    @property
    def Enable(self) -> bool:
        """If true, the variable is being used."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Enable.setter
    def Enable(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnable"](arg_newVal.COM_val))

    @property
    def Name(self) -> str:
        """The name of the parameter."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def CurrentValue(self) -> typing.Any:
        """The value achieved for this dependent variable in the last targeter run. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCurrentValue"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ParentName(self) -> str:
        """Object - the name of the segment to which the parameter belongs."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetParentName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def LowerBound(self) -> typing.Any:
        """The lower limit achievable by this quantity in the optimizer's iteration history. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLowerBound"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @LowerBound.setter
    def LowerBound(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetLowerBound"](arg_newVal.COM_val))

    @property
    def UpperBound(self) -> typing.Any:
        """The upper limit achievable by this quantity in the optimizer's iteration history. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUpperBound"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UpperBound.setter
    def UpperBound(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetUpperBound"](arg_newVal.COM_val))

    @property
    def ScalingValue(self) -> typing.Any:
        """Applies to the Specified Value scaling method. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetScalingValue"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ScalingValue.setter
    def ScalingValue(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetScalingValue"](arg_newVal.COM_val))

    @property
    def Weight(self) -> float:
        """The factor by which the constraint error is to be multiplied."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetWeight"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Weight.setter
    def Weight(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetWeight"](arg_newVal.COM_val))

    @property
    def Goal(self) -> "AgEVASNOPTGoal":
        """The purpose of the element in the problem."""
        with agmarshall.AgEnum_arg(AgEVASNOPTGoal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetGoal"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Goal.setter
    def Goal(self, inVal:"AgEVASNOPTGoal") -> None:
        with agmarshall.AgEnum_arg(AgEVASNOPTGoal, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetGoal"](arg_inVal.COM_val))

    @property
    def UseCustomDisplayUnit(self) -> bool:
        """If true, allows display of values in another unit."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCustomDisplayUnit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseCustomDisplayUnit.setter
    def UseCustomDisplayUnit(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseCustomDisplayUnit"](arg_newVal.COM_val))

    @property
    def CustomDisplayUnit(self) -> str:
        """The unit in which the value will be displayed in the GUI."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCustomDisplayUnit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CustomDisplayUnit.setter
    def CustomDisplayUnit(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCustomDisplayUnit"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{79392E1D-E3C7-4403-9D4C-1C13AB8368A9}", IVASNOPTResult)
agcls.AgTypeNameMap["IVASNOPTResult"] = IVASNOPTResult

class IVAProfileIPOPTOptimizer(IVAProfile):
    """Properties of IPOPT Optimizer profile."""
    _uuid = "{23DCC03E-E187-41EF-85C8-FC3DCA09E7A8}"
    _num_methods = 18
    _vtable_offset = IVAProfile._vtable_offset + IVAProfile._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetControlParameters"] = _raise_uninitialized_error
        self.__dict__["_GetResults"] = _raise_uninitialized_error
        self.__dict__["_GetTargeterGraphs"] = _raise_uninitialized_error
        self.__dict__["_GetScriptingTool"] = _raise_uninitialized_error
        self.__dict__["_GetResetControlsBeforeRun"] = _raise_uninitialized_error
        self.__dict__["_SetResetControlsBeforeRun"] = _raise_uninitialized_error
        self.__dict__["_GetToleranceOnConvergence"] = _raise_uninitialized_error
        self.__dict__["_SetToleranceOnConvergence"] = _raise_uninitialized_error
        self.__dict__["_GetMaximumIterations"] = _raise_uninitialized_error
        self.__dict__["_SetMaximumIterations"] = _raise_uninitialized_error
        self.__dict__["_GetToleranceOnConstraintViolation"] = _raise_uninitialized_error
        self.__dict__["_SetToleranceOnConstraintViolation"] = _raise_uninitialized_error
        self.__dict__["_GetToleranceOnDualInfeasibility"] = _raise_uninitialized_error
        self.__dict__["_SetToleranceOnDualInfeasibility"] = _raise_uninitialized_error
        self.__dict__["_GetToleranceOnComplementaryInfeasibility"] = _raise_uninitialized_error
        self.__dict__["_SetToleranceOnComplementaryInfeasibility"] = _raise_uninitialized_error
        self.__dict__["_GetOptionsFilename"] = _raise_uninitialized_error
        self.__dict__["_SetOptionsFilename"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAProfileIPOPTOptimizer._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAProfileIPOPTOptimizer from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAProfile._private_init(self, pUnk)
        IID_IVAProfileIPOPTOptimizer = agcom.GUID(IVAProfileIPOPTOptimizer._uuid)
        vtable_offset_local = IVAProfileIPOPTOptimizer._vtable_offset - 1
        self.__dict__["_GetControlParameters"] = IAGFUNCTYPE(pUnk, IID_IVAProfileIPOPTOptimizer, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetResults"] = IAGFUNCTYPE(pUnk, IID_IVAProfileIPOPTOptimizer, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetTargeterGraphs"] = IAGFUNCTYPE(pUnk, IID_IVAProfileIPOPTOptimizer, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetScriptingTool"] = IAGFUNCTYPE(pUnk, IID_IVAProfileIPOPTOptimizer, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetResetControlsBeforeRun"] = IAGFUNCTYPE(pUnk, IID_IVAProfileIPOPTOptimizer, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetResetControlsBeforeRun"] = IAGFUNCTYPE(pUnk, IID_IVAProfileIPOPTOptimizer, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetToleranceOnConvergence"] = IAGFUNCTYPE(pUnk, IID_IVAProfileIPOPTOptimizer, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetToleranceOnConvergence"] = IAGFUNCTYPE(pUnk, IID_IVAProfileIPOPTOptimizer, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetMaximumIterations"] = IAGFUNCTYPE(pUnk, IID_IVAProfileIPOPTOptimizer, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_SetMaximumIterations"] = IAGFUNCTYPE(pUnk, IID_IVAProfileIPOPTOptimizer, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_GetToleranceOnConstraintViolation"] = IAGFUNCTYPE(pUnk, IID_IVAProfileIPOPTOptimizer, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetToleranceOnConstraintViolation"] = IAGFUNCTYPE(pUnk, IID_IVAProfileIPOPTOptimizer, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetToleranceOnDualInfeasibility"] = IAGFUNCTYPE(pUnk, IID_IVAProfileIPOPTOptimizer, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetToleranceOnDualInfeasibility"] = IAGFUNCTYPE(pUnk, IID_IVAProfileIPOPTOptimizer, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetToleranceOnComplementaryInfeasibility"] = IAGFUNCTYPE(pUnk, IID_IVAProfileIPOPTOptimizer, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_SetToleranceOnComplementaryInfeasibility"] = IAGFUNCTYPE(pUnk, IID_IVAProfileIPOPTOptimizer, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_GetOptionsFilename"] = IAGFUNCTYPE(pUnk, IID_IVAProfileIPOPTOptimizer, vtable_offset_local+17, POINTER(agcom.BSTR))
        self.__dict__["_SetOptionsFilename"] = IAGFUNCTYPE(pUnk, IID_IVAProfileIPOPTOptimizer, vtable_offset_local+18, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAProfileIPOPTOptimizer.__dict__ and type(IVAProfileIPOPTOptimizer.__dict__[attrname]) == property:
            return IVAProfileIPOPTOptimizer.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAProfile.__setattr__(self, attrname, value)
    
    @property
    def ControlParameters(self) -> "IVAIPOPTControlCollection":
        """The list of control parameters defined for the profile."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAIPOPTControlCollection:
            agcls.evaluate_hresult(self.__dict__["_GetControlParameters"](byref(arg_ppVAIPOPTControlCollection.COM_val)))
            return arg_ppVAIPOPTControlCollection.python_val

    @property
    def Results(self) -> "IVAIPOPTResultCollection":
        """The list of results defined for the profile."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAIPOPTResultCollection:
            agcls.evaluate_hresult(self.__dict__["_GetResults"](byref(arg_ppVAIPOPTResultCollection.COM_val)))
            return arg_ppVAIPOPTResultCollection.python_val

    @property
    def TargeterGraphs(self) -> "IVATargeterGraphCollection":
        """Graphs"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargeterGraphs"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ScriptingTool(self) -> "IVAScriptingTool":
        """Returns the Scripting tool for the sequence."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScriptingTool"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ResetControlsBeforeRun(self) -> bool:
        """Reset controls before each run."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetResetControlsBeforeRun"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ResetControlsBeforeRun.setter
    def ResetControlsBeforeRun(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetResetControlsBeforeRun"](arg_newVal.COM_val))

    @property
    def ToleranceOnConvergence(self) -> float:
        """The tolerance by which the optimality conditions must be satisfied for the problem to be considered converged. The default value is 1E-8."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetToleranceOnConvergence"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ToleranceOnConvergence.setter
    def ToleranceOnConvergence(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetToleranceOnConvergence"](arg_newVal.COM_val))

    @property
    def MaximumIterations(self) -> int:
        """The maximum number of iterations before IPOPT should give up if it hasn't yet converged on a solution. The default value is 3000."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaximumIterations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaximumIterations.setter
    def MaximumIterations(self, newVal:int) -> None:
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaximumIterations"](arg_newVal.COM_val))

    @property
    def ToleranceOnConstraintViolation(self) -> float:
        """The tolerance by which user-specified constraints are allowed to be violated with the solution still considered feasible. The default value is 1.0E-4."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetToleranceOnConstraintViolation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ToleranceOnConstraintViolation.setter
    def ToleranceOnConstraintViolation(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetToleranceOnConstraintViolation"](arg_newVal.COM_val))

    @property
    def ToleranceOnDualInfeasibility(self) -> float:
        """The desired absolute tolerance on the maximum norm of the dual infeasibility. The default value is 1."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetToleranceOnDualInfeasibility"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ToleranceOnDualInfeasibility.setter
    def ToleranceOnDualInfeasibility(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetToleranceOnDualInfeasibility"](arg_newVal.COM_val))

    @property
    def ToleranceOnComplementaryInfeasibility(self) -> float:
        """The desired absolute tolerance on the maximum norm of the complementarity conditions. The default value is 1.0E-4."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetToleranceOnComplementaryInfeasibility"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ToleranceOnComplementaryInfeasibility.setter
    def ToleranceOnComplementaryInfeasibility(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetToleranceOnComplementaryInfeasibility"](arg_newVal.COM_val))

    @property
    def OptionsFilename(self) -> str:
        """If used, the associated IPOPT specifications file may define any of the various IPOPT options. Options in the file that conflict with options specified elsewhere will take precedence."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetOptionsFilename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @OptionsFilename.setter
    def OptionsFilename(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetOptionsFilename"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{23DCC03E-E187-41EF-85C8-FC3DCA09E7A8}", IVAProfileIPOPTOptimizer)
agcls.AgTypeNameMap["IVAProfileIPOPTOptimizer"] = IVAProfileIPOPTOptimizer

class IVAIPOPTControl(object):
    """Properties for control parameters of a IPOPT profile."""
    _uuid = "{EBDE767F-00E7-4779-ABB9-23DB3B87FE54}"
    _num_methods = 17
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEnable"] = _raise_uninitialized_error
        self.__dict__["_SetEnable"] = _raise_uninitialized_error
        self.__dict__["_GetName"] = _raise_uninitialized_error
        self.__dict__["_GetParentName"] = _raise_uninitialized_error
        self.__dict__["_GetInitialValue"] = _raise_uninitialized_error
        self.__dict__["_GetCurrentValue"] = _raise_uninitialized_error
        self.__dict__["_SetCurrentValue"] = _raise_uninitialized_error
        self.__dict__["_GetLowerBound"] = _raise_uninitialized_error
        self.__dict__["_SetLowerBound"] = _raise_uninitialized_error
        self.__dict__["_GetUpperBound"] = _raise_uninitialized_error
        self.__dict__["_SetUpperBound"] = _raise_uninitialized_error
        self.__dict__["_GetScalingValue"] = _raise_uninitialized_error
        self.__dict__["_SetScalingValue"] = _raise_uninitialized_error
        self.__dict__["_GetUseCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_SetUseCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_GetCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_SetCustomDisplayUnit"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAIPOPTControl._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAIPOPTControl from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAIPOPTControl = agcom.GUID(IVAIPOPTControl._uuid)
        vtable_offset_local = IVAIPOPTControl._vtable_offset - 1
        self.__dict__["_GetEnable"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTControl, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnable"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTControl, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetName"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTControl, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_GetParentName"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTControl, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_GetInitialValue"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTControl, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_GetCurrentValue"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTControl, vtable_offset_local+6, POINTER(agcom.VARIANT))
        self.__dict__["_SetCurrentValue"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTControl, vtable_offset_local+7, agcom.VARIANT)
        self.__dict__["_GetLowerBound"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTControl, vtable_offset_local+8, POINTER(agcom.VARIANT))
        self.__dict__["_SetLowerBound"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTControl, vtable_offset_local+9, agcom.VARIANT)
        self.__dict__["_GetUpperBound"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTControl, vtable_offset_local+10, POINTER(agcom.VARIANT))
        self.__dict__["_SetUpperBound"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTControl, vtable_offset_local+11, agcom.VARIANT)
        self.__dict__["_GetScalingValue"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTControl, vtable_offset_local+12, POINTER(agcom.VARIANT))
        self.__dict__["_SetScalingValue"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTControl, vtable_offset_local+13, agcom.VARIANT)
        self.__dict__["_GetUseCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTControl, vtable_offset_local+14, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTControl, vtable_offset_local+15, agcom.VARIANT_BOOL)
        self.__dict__["_GetCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTControl, vtable_offset_local+16, POINTER(agcom.BSTR))
        self.__dict__["_SetCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTControl, vtable_offset_local+17, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAIPOPTControl.__dict__ and type(IVAIPOPTControl.__dict__[attrname]) == property:
            return IVAIPOPTControl.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAIPOPTControl.")
    
    @property
    def Enable(self) -> bool:
        """If true, the variable is being used."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Enable.setter
    def Enable(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnable"](arg_newVal.COM_val))

    @property
    def Name(self) -> str:
        """The name of the parameter."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ParentName(self) -> str:
        """The name of the segment to which the parameter belongs."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetParentName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def InitialValue(self) -> typing.Any:
        """The nominal value of the element selected as a parameter. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetInitialValue"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def CurrentValue(self) -> typing.Any:
        """The value of the independent variable after the last targeter run."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCurrentValue"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CurrentValue.setter
    def CurrentValue(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCurrentValue"](arg_newVal.COM_val))

    @property
    def LowerBound(self) -> typing.Any:
        """Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLowerBound"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @LowerBound.setter
    def LowerBound(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetLowerBound"](arg_newVal.COM_val))

    @property
    def UpperBound(self) -> typing.Any:
        """Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUpperBound"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UpperBound.setter
    def UpperBound(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetUpperBound"](arg_newVal.COM_val))

    @property
    def ScalingValue(self) -> typing.Any:
        """Applies to the Specified Value scaling method. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetScalingValue"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ScalingValue.setter
    def ScalingValue(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetScalingValue"](arg_newVal.COM_val))

    @property
    def UseCustomDisplayUnit(self) -> bool:
        """If true, allows display of values in another unit."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCustomDisplayUnit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseCustomDisplayUnit.setter
    def UseCustomDisplayUnit(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseCustomDisplayUnit"](arg_newVal.COM_val))

    @property
    def CustomDisplayUnit(self) -> str:
        """The unit in which the value will be displayed in the GUI."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCustomDisplayUnit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CustomDisplayUnit.setter
    def CustomDisplayUnit(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCustomDisplayUnit"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{EBDE767F-00E7-4779-ABB9-23DB3B87FE54}", IVAIPOPTControl)
agcls.AgTypeNameMap["IVAIPOPTControl"] = IVAIPOPTControl

class IVAIPOPTResult(object):
    """Properties for objecvtive and constraints of a IPOPT profile."""
    _uuid = "{CBBEA11D-662A-4218-A9DC-84A16ABAE3D4}"
    _num_methods = 19
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEnable"] = _raise_uninitialized_error
        self.__dict__["_SetEnable"] = _raise_uninitialized_error
        self.__dict__["_GetName"] = _raise_uninitialized_error
        self.__dict__["_GetCurrentValue"] = _raise_uninitialized_error
        self.__dict__["_GetParentName"] = _raise_uninitialized_error
        self.__dict__["_GetLowerBound"] = _raise_uninitialized_error
        self.__dict__["_SetLowerBound"] = _raise_uninitialized_error
        self.__dict__["_GetUpperBound"] = _raise_uninitialized_error
        self.__dict__["_SetUpperBound"] = _raise_uninitialized_error
        self.__dict__["_GetScalingValue"] = _raise_uninitialized_error
        self.__dict__["_SetScalingValue"] = _raise_uninitialized_error
        self.__dict__["_GetWeight"] = _raise_uninitialized_error
        self.__dict__["_SetWeight"] = _raise_uninitialized_error
        self.__dict__["_GetGoal"] = _raise_uninitialized_error
        self.__dict__["_SetGoal"] = _raise_uninitialized_error
        self.__dict__["_GetUseCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_SetUseCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_GetCustomDisplayUnit"] = _raise_uninitialized_error
        self.__dict__["_SetCustomDisplayUnit"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAIPOPTResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAIPOPTResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAIPOPTResult = agcom.GUID(IVAIPOPTResult._uuid)
        vtable_offset_local = IVAIPOPTResult._vtable_offset - 1
        self.__dict__["_GetEnable"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnable"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTResult, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetName"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTResult, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_GetCurrentValue"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTResult, vtable_offset_local+4, POINTER(agcom.VARIANT))
        self.__dict__["_GetParentName"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTResult, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_GetLowerBound"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTResult, vtable_offset_local+6, POINTER(agcom.VARIANT))
        self.__dict__["_SetLowerBound"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTResult, vtable_offset_local+7, agcom.VARIANT)
        self.__dict__["_GetUpperBound"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTResult, vtable_offset_local+8, POINTER(agcom.VARIANT))
        self.__dict__["_SetUpperBound"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTResult, vtable_offset_local+9, agcom.VARIANT)
        self.__dict__["_GetScalingValue"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTResult, vtable_offset_local+10, POINTER(agcom.VARIANT))
        self.__dict__["_SetScalingValue"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTResult, vtable_offset_local+11, agcom.VARIANT)
        self.__dict__["_GetWeight"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTResult, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_SetWeight"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTResult, vtable_offset_local+13, agcom.DOUBLE)
        self.__dict__["_GetGoal"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTResult, vtable_offset_local+14, POINTER(agcom.LONG))
        self.__dict__["_SetGoal"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTResult, vtable_offset_local+15, agcom.LONG)
        self.__dict__["_GetUseCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTResult, vtable_offset_local+16, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTResult, vtable_offset_local+17, agcom.VARIANT_BOOL)
        self.__dict__["_GetCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTResult, vtable_offset_local+18, POINTER(agcom.BSTR))
        self.__dict__["_SetCustomDisplayUnit"] = IAGFUNCTYPE(pUnk, IID_IVAIPOPTResult, vtable_offset_local+19, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAIPOPTResult.__dict__ and type(IVAIPOPTResult.__dict__[attrname]) == property:
            return IVAIPOPTResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAIPOPTResult.")
    
    @property
    def Enable(self) -> bool:
        """If true, the variable is being used."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Enable.setter
    def Enable(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnable"](arg_newVal.COM_val))

    @property
    def Name(self) -> str:
        """The name of the parameter."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def CurrentValue(self) -> typing.Any:
        """The value achieved for this dependent variable in the last targeter run. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCurrentValue"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ParentName(self) -> str:
        """Object - the name of the segment to which the parameter belongs."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetParentName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def LowerBound(self) -> typing.Any:
        """The lower limit achievable by this quantity in the optimizer's iteration history. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLowerBound"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @LowerBound.setter
    def LowerBound(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetLowerBound"](arg_newVal.COM_val))

    @property
    def UpperBound(self) -> typing.Any:
        """The upper limit achievable by this quantity in the optimizer's iteration history. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUpperBound"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UpperBound.setter
    def UpperBound(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetUpperBound"](arg_newVal.COM_val))

    @property
    def ScalingValue(self) -> typing.Any:
        """Applies to the Specified Value scaling method. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetScalingValue"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ScalingValue.setter
    def ScalingValue(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetScalingValue"](arg_newVal.COM_val))

    @property
    def Weight(self) -> float:
        """The factor by which the constraint error is to be multiplied."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetWeight"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Weight.setter
    def Weight(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetWeight"](arg_newVal.COM_val))

    @property
    def Goal(self) -> "AgEVAIPOPTGoal":
        """The purpose of the element in the problem."""
        with agmarshall.AgEnum_arg(AgEVAIPOPTGoal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetGoal"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Goal.setter
    def Goal(self, inVal:"AgEVAIPOPTGoal") -> None:
        with agmarshall.AgEnum_arg(AgEVAIPOPTGoal, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetGoal"](arg_inVal.COM_val))

    @property
    def UseCustomDisplayUnit(self) -> bool:
        """If true, allows display of values in another unit."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseCustomDisplayUnit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseCustomDisplayUnit.setter
    def UseCustomDisplayUnit(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseCustomDisplayUnit"](arg_newVal.COM_val))

    @property
    def CustomDisplayUnit(self) -> str:
        """The unit in which the value will be displayed in the GUI."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCustomDisplayUnit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CustomDisplayUnit.setter
    def CustomDisplayUnit(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCustomDisplayUnit"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{CBBEA11D-662A-4218-A9DC-84A16ABAE3D4}", IVAIPOPTResult)
agcls.AgTypeNameMap["IVAIPOPTResult"] = IVAIPOPTResult

class IVAManeuverOptimalFinite(IVAManeuver):
    """Engine properties for a Optimal Finite Maneuver."""
    _uuid = "{FDEE9E11-C6ED-495E-9DC3-F3674F0D4813}"
    _num_methods = 40
    _vtable_offset = IVAManeuver._vtable_offset + IVAManeuver._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPressureMode"] = _raise_uninitialized_error
        self.__dict__["_SetPressureMode"] = _raise_uninitialized_error
        self.__dict__["_GetThrustEfficiency"] = _raise_uninitialized_error
        self.__dict__["_SetThrustEfficiency"] = _raise_uninitialized_error
        self.__dict__["_GetThrustEfficiencyMode"] = _raise_uninitialized_error
        self.__dict__["_SetThrustEfficiencyMode"] = _raise_uninitialized_error
        self.__dict__["_GetNumberOfNodes"] = _raise_uninitialized_error
        self.__dict__["_SetNumberOfNodes"] = _raise_uninitialized_error
        self.__dict__["_GetInitialGuessFileName"] = _raise_uninitialized_error
        self.__dict__["_SetInitialGuessFileName"] = _raise_uninitialized_error
        self.__dict__["_GetSeedMethod"] = _raise_uninitialized_error
        self.__dict__["_SetSeedMethod"] = _raise_uninitialized_error
        self.__dict__["_RunSeed"] = _raise_uninitialized_error
        self.__dict__["_GetNodeStatusMessage"] = _raise_uninitialized_error
        self.__dict__["_GetRunMode"] = _raise_uninitialized_error
        self.__dict__["_SetRunMode"] = _raise_uninitialized_error
        self.__dict__["_GetHaltMCSWhenNoConvergence"] = _raise_uninitialized_error
        self.__dict__["_SetHaltMCSWhenNoConvergence"] = _raise_uninitialized_error
        self.__dict__["_GetDiscretizationStrategy"] = _raise_uninitialized_error
        self.__dict__["_SetDiscretizationStrategy"] = _raise_uninitialized_error
        self.__dict__["_GetWorkingVariables"] = _raise_uninitialized_error
        self.__dict__["_SetWorkingVariables"] = _raise_uninitialized_error
        self.__dict__["_GetScalingOptions"] = _raise_uninitialized_error
        self.__dict__["_SetScalingOptions"] = _raise_uninitialized_error
        self.__dict__["_GetEnableUnitVectorControls"] = _raise_uninitialized_error
        self.__dict__["_SetEnableUnitVectorControls"] = _raise_uninitialized_error
        self.__dict__["_GetThrustAxes"] = _raise_uninitialized_error
        self.__dict__["_GetSNOPTOptimizer"] = _raise_uninitialized_error
        self.__dict__["_GetInitialBoundaryConditions"] = _raise_uninitialized_error
        self.__dict__["_GetFinalBoundaryConditions"] = _raise_uninitialized_error
        self.__dict__["_GetPathBoundaryConditions"] = _raise_uninitialized_error
        self.__dict__["_GetLogFileName"] = _raise_uninitialized_error
        self.__dict__["_GetExportFormat"] = _raise_uninitialized_error
        self.__dict__["_SetExportFormat"] = _raise_uninitialized_error
        self.__dict__["_GetSteeringNodes"] = _raise_uninitialized_error
        self.__dict__["_ExportNodes"] = _raise_uninitialized_error
        self.__dict__["_GetInitialGuessInterpolationMethod"] = _raise_uninitialized_error
        self.__dict__["_SetInitialGuessInterpolationMethod"] = _raise_uninitialized_error
        self.__dict__["_GetShouldReinitializeSTMAtStartOfSegmentPropagation"] = _raise_uninitialized_error
        self.__dict__["_SetShouldReinitializeSTMAtStartOfSegmentPropagation"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAManeuverOptimalFinite._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAManeuverOptimalFinite from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAManeuver._private_init(self, pUnk)
        IID_IVAManeuverOptimalFinite = agcom.GUID(IVAManeuverOptimalFinite._uuid)
        vtable_offset_local = IVAManeuverOptimalFinite._vtable_offset - 1
        self.__dict__["_GetPressureMode"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetPressureMode"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetThrustEfficiency"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetThrustEfficiency"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetThrustEfficiencyMode"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetThrustEfficiencyMode"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetNumberOfNodes"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetNumberOfNodes"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetInitialGuessFileName"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_SetInitialGuessFileName"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+10, agcom.BSTR)
        self.__dict__["_GetSeedMethod"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_SetSeedMethod"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_RunSeed"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+13, )
        self.__dict__["_GetNodeStatusMessage"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+14, POINTER(agcom.BSTR))
        self.__dict__["_GetRunMode"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+15, POINTER(agcom.LONG))
        self.__dict__["_SetRunMode"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_GetHaltMCSWhenNoConvergence"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+17, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetHaltMCSWhenNoConvergence"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+18, agcom.VARIANT_BOOL)
        self.__dict__["_GetDiscretizationStrategy"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+19, POINTER(agcom.LONG))
        self.__dict__["_SetDiscretizationStrategy"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+20, agcom.LONG)
        self.__dict__["_GetWorkingVariables"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+21, POINTER(agcom.LONG))
        self.__dict__["_SetWorkingVariables"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+22, agcom.LONG)
        self.__dict__["_GetScalingOptions"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+23, POINTER(agcom.LONG))
        self.__dict__["_SetScalingOptions"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+24, agcom.LONG)
        self.__dict__["_GetEnableUnitVectorControls"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+25, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnableUnitVectorControls"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+26, agcom.VARIANT_BOOL)
        self.__dict__["_GetThrustAxes"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+27, POINTER(agcom.BSTR))
        self.__dict__["_GetSNOPTOptimizer"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+28, POINTER(agcom.PVOID))
        self.__dict__["_GetInitialBoundaryConditions"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+29, POINTER(agcom.PVOID))
        self.__dict__["_GetFinalBoundaryConditions"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+30, POINTER(agcom.PVOID))
        self.__dict__["_GetPathBoundaryConditions"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+31, POINTER(agcom.PVOID))
        self.__dict__["_GetLogFileName"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+32, POINTER(agcom.BSTR))
        self.__dict__["_GetExportFormat"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+33, POINTER(agcom.LONG))
        self.__dict__["_SetExportFormat"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+34, agcom.LONG)
        self.__dict__["_GetSteeringNodes"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+35, POINTER(agcom.PVOID))
        self.__dict__["_ExportNodes"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+36, agcom.BSTR)
        self.__dict__["_GetInitialGuessInterpolationMethod"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+37, POINTER(agcom.LONG))
        self.__dict__["_SetInitialGuessInterpolationMethod"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+38, agcom.LONG)
        self.__dict__["_GetShouldReinitializeSTMAtStartOfSegmentPropagation"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+39, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetShouldReinitializeSTMAtStartOfSegmentPropagation"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFinite, vtable_offset_local+40, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAManeuverOptimalFinite.__dict__ and type(IVAManeuverOptimalFinite.__dict__[attrname]) == property:
            return IVAManeuverOptimalFinite.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAManeuver.__setattr__(self, attrname, value)
    
    @property
    def PressureMode(self) -> "AgEVAPressureMode":
        """The pressure mode."""
        with agmarshall.AgEnum_arg(AgEVAPressureMode) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPressureMode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @PressureMode.setter
    def PressureMode(self, newVal:"AgEVAPressureMode") -> None:
        with agmarshall.AgEnum_arg(AgEVAPressureMode, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetPressureMode"](arg_newVal.COM_val))

    @property
    def ThrustEfficiency(self) -> float:
        """The fraction of ideal thrust applied. Any number above zero is valid, with typical values around 0.98 to 1.02. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetThrustEfficiency"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ThrustEfficiency.setter
    def ThrustEfficiency(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetThrustEfficiency"](arg_newVal.COM_val))

    @property
    def ThrustEfficiencyMode(self) -> "AgEVAThrustType":
        """Thrust - the calculations that are effected by the thrust efficiency value."""
        with agmarshall.AgEnum_arg(AgEVAThrustType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetThrustEfficiencyMode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ThrustEfficiencyMode.setter
    def ThrustEfficiencyMode(self, newVal:"AgEVAThrustType") -> None:
        """Mode indicating fraction of ideal thrust applied."""
        with agmarshall.AgEnum_arg(AgEVAThrustType, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetThrustEfficiencyMode"](arg_newVal.COM_val))

    @property
    def NumberOfNodes(self) -> int:
        """Number of nodes to discretize collocation problem into."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNumberOfNodes"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @NumberOfNodes.setter
    def NumberOfNodes(self, newVal:int) -> None:
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetNumberOfNodes"](arg_newVal.COM_val))

    @property
    def InitialGuessFileName(self) -> str:
        """File containing ephemeris for nodes that serve as an initial guess."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetInitialGuessFileName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @InitialGuessFileName.setter
    def InitialGuessFileName(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetInitialGuessFileName"](arg_newVal.COM_val))

    @property
    def SeedMethod(self) -> "AgEVAOptimalFiniteSeedMethod":
        """Initial seed method."""
        with agmarshall.AgEnum_arg(AgEVAOptimalFiniteSeedMethod) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSeedMethod"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SeedMethod.setter
    def SeedMethod(self, newVal:"AgEVAOptimalFiniteSeedMethod") -> None:
        with agmarshall.AgEnum_arg(AgEVAOptimalFiniteSeedMethod, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetSeedMethod"](arg_newVal.COM_val))

    def RunSeed(self) -> None:
        """Run seed."""
        agcls.evaluate_hresult(self.__dict__["_RunSeed"]())

    @property
    def NodeStatusMessage(self) -> str:
        """A message that indicates what nodes are currently held by the segment."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNodeStatusMessage"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def RunMode(self) -> "AgEVAOptimalFiniteRunMode":
        """Run mode."""
        with agmarshall.AgEnum_arg(AgEVAOptimalFiniteRunMode) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRunMode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RunMode.setter
    def RunMode(self, newVal:"AgEVAOptimalFiniteRunMode") -> None:
        with agmarshall.AgEnum_arg(AgEVAOptimalFiniteRunMode, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetRunMode"](arg_newVal.COM_val))

    @property
    def HaltMCSWhenNoConvergence(self) -> bool:
        """Halt MCS and discard result if optimization is unsuccessful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetHaltMCSWhenNoConvergence"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @HaltMCSWhenNoConvergence.setter
    def HaltMCSWhenNoConvergence(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetHaltMCSWhenNoConvergence"](arg_newVal.COM_val))

    @property
    def DiscretizationStrategy(self) -> "AgEVAOptimalFiniteDiscretizationStrategy":
        """Discretization Strategy."""
        with agmarshall.AgEnum_arg(AgEVAOptimalFiniteDiscretizationStrategy) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDiscretizationStrategy"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DiscretizationStrategy.setter
    def DiscretizationStrategy(self, newVal:"AgEVAOptimalFiniteDiscretizationStrategy") -> None:
        with agmarshall.AgEnum_arg(AgEVAOptimalFiniteDiscretizationStrategy, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetDiscretizationStrategy"](arg_newVal.COM_val))

    @property
    def WorkingVariables(self) -> "AgEVAOptimalFiniteWorkingVariables":
        """Working Variables."""
        with agmarshall.AgEnum_arg(AgEVAOptimalFiniteWorkingVariables) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetWorkingVariables"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @WorkingVariables.setter
    def WorkingVariables(self, newVal:"AgEVAOptimalFiniteWorkingVariables") -> None:
        with agmarshall.AgEnum_arg(AgEVAOptimalFiniteWorkingVariables, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetWorkingVariables"](arg_newVal.COM_val))

    @property
    def ScalingOptions(self) -> "AgEVAOptimalFiniteScalingOptions":
        """Scaling Options."""
        with agmarshall.AgEnum_arg(AgEVAOptimalFiniteScalingOptions) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetScalingOptions"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ScalingOptions.setter
    def ScalingOptions(self, newVal:"AgEVAOptimalFiniteScalingOptions") -> None:
        with agmarshall.AgEnum_arg(AgEVAOptimalFiniteScalingOptions, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetScalingOptions"](arg_newVal.COM_val))

    @property
    def EnableUnitVectorControls(self) -> bool:
        """Enable unit vector for thrust direction."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnableUnitVectorControls"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EnableUnitVectorControls.setter
    def EnableUnitVectorControls(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnableUnitVectorControls"](arg_newVal.COM_val))

    @property
    def ThrustAxes(self) -> str:
        """Label reflecting coordinate axes for the thrust vector"""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetThrustAxes"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def SNOPTOptimizer(self) -> "IVAManeuverOptimalFiniteSNOPTOptimizer":
        """SNOPT Optimizer Options."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteSNOPTOptimizer:
            agcls.evaluate_hresult(self.__dict__["_GetSNOPTOptimizer"](byref(arg_ppAgVAManeuverOptimalFiniteSNOPTOptimizer.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteSNOPTOptimizer.python_val

    @property
    def InitialBoundaryConditions(self) -> "IVAManeuverOptimalFiniteInitialBoundaryConditions":
        """Initial Boundary Conditions."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteInitialBoundaryConditions:
            agcls.evaluate_hresult(self.__dict__["_GetInitialBoundaryConditions"](byref(arg_ppAgVAManeuverOptimalFiniteInitialBoundaryConditions.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteInitialBoundaryConditions.python_val

    @property
    def FinalBoundaryConditions(self) -> "IVAManeuverOptimalFiniteFinalBoundaryConditions":
        """Final Boundary Conditions."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteFinalBoundaryConditions:
            agcls.evaluate_hresult(self.__dict__["_GetFinalBoundaryConditions"](byref(arg_ppAgVAManeuverOptimalFiniteFinalBoundaryConditions.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteFinalBoundaryConditions.python_val

    @property
    def PathBoundaryConditions(self) -> "IVAManeuverOptimalFinitePathBoundaryConditions":
        """Path Boundary Conditions."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFinitePathBoundaryConditions:
            agcls.evaluate_hresult(self.__dict__["_GetPathBoundaryConditions"](byref(arg_ppAgVAManeuverOptimalFinitePathBoundaryConditions.COM_val)))
            return arg_ppAgVAManeuverOptimalFinitePathBoundaryConditions.python_val

    @property
    def LogFileName(self) -> str:
        """Log file name for optimal finite maneuver."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLogFileName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ExportFormat(self) -> "AgEVAOptimalFiniteExportNodesFormat":
        """Format for exporting collocation control variables."""
        with agmarshall.AgEnum_arg(AgEVAOptimalFiniteExportNodesFormat) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetExportFormat"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ExportFormat.setter
    def ExportFormat(self, newVal:"AgEVAOptimalFiniteExportNodesFormat") -> None:
        with agmarshall.AgEnum_arg(AgEVAOptimalFiniteExportNodesFormat, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetExportFormat"](arg_newVal.COM_val))

    @property
    def SteeringNodes(self) -> "IVAManeuverOptimalFiniteSteeringNodeCollection":
        """The list of steering nodes."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAManeuverOptimalFiniteFinalSteeringNodeCollection:
            agcls.evaluate_hresult(self.__dict__["_GetSteeringNodes"](byref(arg_ppVAManeuverOptimalFiniteFinalSteeringNodeCollection.COM_val)))
            return arg_ppVAManeuverOptimalFiniteFinalSteeringNodeCollection.python_val

    def ExportNodes(self, fileName:str) -> None:
        """Exports the current set of collocation nodes to a file."""
        with agmarshall.BSTR_arg(fileName) as arg_fileName:
            agcls.evaluate_hresult(self.__dict__["_ExportNodes"](arg_fileName.COM_val))

    @property
    def InitialGuessInterpolationMethod(self) -> "AgEVAOptimalFiniteGuessMethod":
        """Guess interpolation method."""
        with agmarshall.AgEnum_arg(AgEVAOptimalFiniteGuessMethod) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetInitialGuessInterpolationMethod"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @InitialGuessInterpolationMethod.setter
    def InitialGuessInterpolationMethod(self, newVal:"AgEVAOptimalFiniteGuessMethod") -> None:
        with agmarshall.AgEnum_arg(AgEVAOptimalFiniteGuessMethod, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetInitialGuessInterpolationMethod"](arg_newVal.COM_val))

    @property
    def ShouldReinitializeSTMAtStartOfSegmentPropagation(self) -> bool:
        """If this segment is propagating the state transition matrix, reset it to the identity matrix at the start of the segment."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetShouldReinitializeSTMAtStartOfSegmentPropagation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ShouldReinitializeSTMAtStartOfSegmentPropagation.setter
    def ShouldReinitializeSTMAtStartOfSegmentPropagation(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetShouldReinitializeSTMAtStartOfSegmentPropagation"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{FDEE9E11-C6ED-495E-9DC3-F3674F0D4813}", IVAManeuverOptimalFinite)
agcls.AgTypeNameMap["IVAManeuverOptimalFinite"] = IVAManeuverOptimalFinite

class IVAManeuverOptimalFiniteSteeringNodeElement(object):
    """The elements of the steering node."""
    _uuid = "{428CDEC6-6E07-4EDA-B656-AF669F95BB8E}"
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetNodeIndex"] = _raise_uninitialized_error
        self.__dict__["_GetTime"] = _raise_uninitialized_error
        self.__dict__["_GetMass"] = _raise_uninitialized_error
        self.__dict__["_GetAzimuth"] = _raise_uninitialized_error
        self.__dict__["_GetElevation"] = _raise_uninitialized_error
        self.__dict__["_GetDirCosX"] = _raise_uninitialized_error
        self.__dict__["_GetDirCosY"] = _raise_uninitialized_error
        self.__dict__["_GetDirCosZ"] = _raise_uninitialized_error
        self.__dict__["_GetPosX"] = _raise_uninitialized_error
        self.__dict__["_GetPosY"] = _raise_uninitialized_error
        self.__dict__["_GetPosZ"] = _raise_uninitialized_error
        self.__dict__["_GetVelX"] = _raise_uninitialized_error
        self.__dict__["_GetVelY"] = _raise_uninitialized_error
        self.__dict__["_GetVelZ"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAManeuverOptimalFiniteSteeringNodeElement._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAManeuverOptimalFiniteSteeringNodeElement from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAManeuverOptimalFiniteSteeringNodeElement = agcom.GUID(IVAManeuverOptimalFiniteSteeringNodeElement._uuid)
        vtable_offset_local = IVAManeuverOptimalFiniteSteeringNodeElement._vtable_offset - 1
        self.__dict__["_GetNodeIndex"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSteeringNodeElement, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_GetTime"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSteeringNodeElement, vtable_offset_local+2, POINTER(agcom.DOUBLE))
        self.__dict__["_GetMass"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSteeringNodeElement, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_GetAzimuth"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSteeringNodeElement, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_GetElevation"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSteeringNodeElement, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_GetDirCosX"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSteeringNodeElement, vtable_offset_local+6, POINTER(agcom.DOUBLE))
        self.__dict__["_GetDirCosY"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSteeringNodeElement, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_GetDirCosZ"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSteeringNodeElement, vtable_offset_local+8, POINTER(agcom.DOUBLE))
        self.__dict__["_GetPosX"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSteeringNodeElement, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_GetPosY"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSteeringNodeElement, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_GetPosZ"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSteeringNodeElement, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_GetVelX"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSteeringNodeElement, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_GetVelY"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSteeringNodeElement, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_GetVelZ"] = IAGFUNCTYPE(pUnk, IID_IVAManeuverOptimalFiniteSteeringNodeElement, vtable_offset_local+14, POINTER(agcom.DOUBLE))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAManeuverOptimalFiniteSteeringNodeElement.__dict__ and type(IVAManeuverOptimalFiniteSteeringNodeElement.__dict__[attrname]) == property:
            return IVAManeuverOptimalFiniteSteeringNodeElement.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAManeuverOptimalFiniteSteeringNodeElement.")
    
    @property
    def NodeIndex(self) -> int:
        """The index of the node in the array of nodes."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNodeIndex"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def Time(self) -> float:
        """The time associated with the node."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTime"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def Mass(self) -> float:
        """The mass at the node."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMass"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def Azimuth(self) -> float:
        """The azimuth of the steering angle."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAzimuth"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def Elevation(self) -> float:
        """The elevation of the steering angle."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElevation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def DirCosX(self) -> float:
        """The first component of the steering unit vector."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDirCosX"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def DirCosY(self) -> float:
        """The second component of the steering unit vector."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDirCosY"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def DirCosZ(self) -> float:
        """The third component of the steering unit vector."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDirCosZ"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def PosX(self) -> float:
        """The X component of the position vector."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPosX"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def PosY(self) -> float:
        """The Y component of the position vector."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPosY"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def PosZ(self) -> float:
        """The Z component of the position vector."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPosZ"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def VelX(self) -> float:
        """The X component of the velocity vector."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVelX"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def VelY(self) -> float:
        """The Y component of the velocity vector."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVelY"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def VelZ(self) -> float:
        """The Z component of the velocity vector."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVelZ"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{428CDEC6-6E07-4EDA-B656-AF669F95BB8E}", IVAManeuverOptimalFiniteSteeringNodeElement)
agcls.AgTypeNameMap["IVAManeuverOptimalFiniteSteeringNodeElement"] = IVAManeuverOptimalFiniteSteeringNodeElement

class IVAProfileLambertProfile(IVAProfile):
    """Properties for a Lambert profile."""
    _uuid = "{6F736B1F-850D-4736-9106-8BDC4FE52A30}"
    _num_methods = 56
    _vtable_offset = IVAProfile._vtable_offset + IVAProfile._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_SetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_GetTargetCoordType"] = _raise_uninitialized_error
        self.__dict__["_SetTargetCoordType"] = _raise_uninitialized_error
        self.__dict__["_GetEnableSecondManeuver"] = _raise_uninitialized_error
        self.__dict__["_SetEnableSecondManeuver"] = _raise_uninitialized_error
        self.__dict__["_GetTargetPositionX"] = _raise_uninitialized_error
        self.__dict__["_SetTargetPositionX"] = _raise_uninitialized_error
        self.__dict__["_GetTargetPositionY"] = _raise_uninitialized_error
        self.__dict__["_SetTargetPositionY"] = _raise_uninitialized_error
        self.__dict__["_GetTargetPositionZ"] = _raise_uninitialized_error
        self.__dict__["_SetTargetPositionZ"] = _raise_uninitialized_error
        self.__dict__["_GetTargetVelocityX"] = _raise_uninitialized_error
        self.__dict__["_SetTargetVelocityX"] = _raise_uninitialized_error
        self.__dict__["_GetTargetVelocityY"] = _raise_uninitialized_error
        self.__dict__["_SetTargetVelocityY"] = _raise_uninitialized_error
        self.__dict__["_GetTargetVelocityZ"] = _raise_uninitialized_error
        self.__dict__["_SetTargetVelocityZ"] = _raise_uninitialized_error
        self.__dict__["_GetTargetSemimajorAxis"] = _raise_uninitialized_error
        self.__dict__["_SetTargetSemimajorAxis"] = _raise_uninitialized_error
        self.__dict__["_GetTargetEccentricity"] = _raise_uninitialized_error
        self.__dict__["_SetTargetEccentricity"] = _raise_uninitialized_error
        self.__dict__["_GetTargetInclination"] = _raise_uninitialized_error
        self.__dict__["_SetTargetInclination"] = _raise_uninitialized_error
        self.__dict__["_GetTargetRightAscensionOfAscendingNode"] = _raise_uninitialized_error
        self.__dict__["_SetTargetRightAscensionOfAscendingNode"] = _raise_uninitialized_error
        self.__dict__["_GetTargetArgumentOfPeriapsis"] = _raise_uninitialized_error
        self.__dict__["_SetTargetArgumentOfPeriapsis"] = _raise_uninitialized_error
        self.__dict__["_GetTargetTrueAnomaly"] = _raise_uninitialized_error
        self.__dict__["_SetTargetTrueAnomaly"] = _raise_uninitialized_error
        self.__dict__["_GetSolutionOption"] = _raise_uninitialized_error
        self.__dict__["_SetSolutionOption"] = _raise_uninitialized_error
        self.__dict__["_GetTimeOfFlight"] = _raise_uninitialized_error
        self.__dict__["_SetTimeOfFlight"] = _raise_uninitialized_error
        self.__dict__["_GetRevolutions"] = _raise_uninitialized_error
        self.__dict__["_SetRevolutions"] = _raise_uninitialized_error
        self.__dict__["_GetOrbitalEnergy"] = _raise_uninitialized_error
        self.__dict__["_SetOrbitalEnergy"] = _raise_uninitialized_error
        self.__dict__["_GetDirectionOfMotion"] = _raise_uninitialized_error
        self.__dict__["_SetDirectionOfMotion"] = _raise_uninitialized_error
        self.__dict__["_GetCentralBodyCollisionAltitudePadding"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyCollisionAltitudePadding"] = _raise_uninitialized_error
        self.__dict__["_GetEnableWriteToFirstManeuver"] = _raise_uninitialized_error
        self.__dict__["_SetEnableWriteToFirstManeuver"] = _raise_uninitialized_error
        self.__dict__["_GetFirstManeuverSegment"] = _raise_uninitialized_error
        self.__dict__["_SetFirstManeuverSegment"] = _raise_uninitialized_error
        self.__dict__["_GetEnableWriteDurationToPropagate"] = _raise_uninitialized_error
        self.__dict__["_SetEnableWriteDurationToPropagate"] = _raise_uninitialized_error
        self.__dict__["_GetDisableNonLambertPropagateStopConditions"] = _raise_uninitialized_error
        self.__dict__["_SetDisableNonLambertPropagateStopConditions"] = _raise_uninitialized_error
        self.__dict__["_GetPropagateSegment"] = _raise_uninitialized_error
        self.__dict__["_SetPropagateSegment"] = _raise_uninitialized_error
        self.__dict__["_GetEnableWriteToSecondManeuver"] = _raise_uninitialized_error
        self.__dict__["_SetEnableWriteToSecondManeuver"] = _raise_uninitialized_error
        self.__dict__["_GetSecondManeuverSegment"] = _raise_uninitialized_error
        self.__dict__["_SetSecondManeuverSegment"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAProfileLambertProfile._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAProfileLambertProfile from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAProfile._private_init(self, pUnk)
        IID_IVAProfileLambertProfile = agcom.GUID(IVAProfileLambertProfile._uuid)
        vtable_offset_local = IVAProfileLambertProfile._vtable_offset - 1
        self.__dict__["_GetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetTargetCoordType"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetTargetCoordType"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetEnableSecondManeuver"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnableSecondManeuver"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetTargetPositionX"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTargetPositionX"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetTargetPositionY"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTargetPositionY"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetTargetPositionZ"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTargetPositionZ"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetTargetVelocityX"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTargetVelocityX"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetTargetVelocityY"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTargetVelocityY"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_GetTargetVelocityZ"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTargetVelocityZ"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_GetTargetSemimajorAxis"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTargetSemimajorAxis"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_GetTargetEccentricity"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTargetEccentricity"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+22, agcom.DOUBLE)
        self.__dict__["_GetTargetInclination"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+23, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTargetInclination"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+24, agcom.DOUBLE)
        self.__dict__["_GetTargetRightAscensionOfAscendingNode"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+25, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTargetRightAscensionOfAscendingNode"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+26, agcom.DOUBLE)
        self.__dict__["_GetTargetArgumentOfPeriapsis"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+27, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTargetArgumentOfPeriapsis"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+28, agcom.DOUBLE)
        self.__dict__["_GetTargetTrueAnomaly"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+29, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTargetTrueAnomaly"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+30, agcom.DOUBLE)
        self.__dict__["_GetSolutionOption"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+31, POINTER(agcom.LONG))
        self.__dict__["_SetSolutionOption"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+32, agcom.LONG)
        self.__dict__["_GetTimeOfFlight"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+33, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTimeOfFlight"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+34, agcom.DOUBLE)
        self.__dict__["_GetRevolutions"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+35, POINTER(agcom.LONG))
        self.__dict__["_SetRevolutions"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+36, agcom.LONG)
        self.__dict__["_GetOrbitalEnergy"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+37, POINTER(agcom.LONG))
        self.__dict__["_SetOrbitalEnergy"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+38, agcom.LONG)
        self.__dict__["_GetDirectionOfMotion"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+39, POINTER(agcom.LONG))
        self.__dict__["_SetDirectionOfMotion"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+40, agcom.LONG)
        self.__dict__["_GetCentralBodyCollisionAltitudePadding"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+41, POINTER(agcom.DOUBLE))
        self.__dict__["_SetCentralBodyCollisionAltitudePadding"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+42, agcom.DOUBLE)
        self.__dict__["_GetEnableWriteToFirstManeuver"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+43, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnableWriteToFirstManeuver"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+44, agcom.VARIANT_BOOL)
        self.__dict__["_GetFirstManeuverSegment"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+45, POINTER(agcom.BSTR))
        self.__dict__["_SetFirstManeuverSegment"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+46, agcom.BSTR)
        self.__dict__["_GetEnableWriteDurationToPropagate"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+47, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnableWriteDurationToPropagate"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+48, agcom.VARIANT_BOOL)
        self.__dict__["_GetDisableNonLambertPropagateStopConditions"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+49, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetDisableNonLambertPropagateStopConditions"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+50, agcom.VARIANT_BOOL)
        self.__dict__["_GetPropagateSegment"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+51, POINTER(agcom.BSTR))
        self.__dict__["_SetPropagateSegment"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+52, agcom.BSTR)
        self.__dict__["_GetEnableWriteToSecondManeuver"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+53, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnableWriteToSecondManeuver"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+54, agcom.VARIANT_BOOL)
        self.__dict__["_GetSecondManeuverSegment"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+55, POINTER(agcom.BSTR))
        self.__dict__["_SetSecondManeuverSegment"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertProfile, vtable_offset_local+56, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAProfileLambertProfile.__dict__ and type(IVAProfileLambertProfile.__dict__[attrname]) == property:
            return IVAProfileLambertProfile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAProfile.__setattr__(self, attrname, value)
    
    @property
    def CoordSystemName(self) -> str:
        """The coordinate system."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordSystemName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordSystemName.setter
    def CoordSystemName(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordSystemName"](arg_newVal.COM_val))

    @property
    def TargetCoordType(self) -> "AgEVALambertTargetCoordType":
        """The target coordinate type."""
        with agmarshall.AgEnum_arg(AgEVALambertTargetCoordType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetCoordType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def SetTargetCoordType(self, elementType:"AgEVALambertTargetCoordType") -> None:
        """Selects a target coordinate type."""
        with agmarshall.AgEnum_arg(AgEVALambertTargetCoordType, elementType) as arg_elementType:
            agcls.evaluate_hresult(self.__dict__["_SetTargetCoordType"](arg_elementType.COM_val))

    @property
    def EnableSecondManeuver(self) -> bool:
        """Enable to calculate second maneuver at destination."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnableSecondManeuver"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EnableSecondManeuver.setter
    def EnableSecondManeuver(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnableSecondManeuver"](arg_newVal.COM_val))

    @property
    def TargetPositionX(self) -> float:
        """The X component of the target position for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetPositionX"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TargetPositionX.setter
    def TargetPositionX(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTargetPositionX"](arg_newVal.COM_val))

    @property
    def TargetPositionY(self) -> float:
        """The Y component of the target position for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetPositionY"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TargetPositionY.setter
    def TargetPositionY(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTargetPositionY"](arg_newVal.COM_val))

    @property
    def TargetPositionZ(self) -> float:
        """The Z component of the target position for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetPositionZ"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TargetPositionZ.setter
    def TargetPositionZ(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTargetPositionZ"](arg_newVal.COM_val))

    @property
    def TargetVelocityX(self) -> float:
        """The X component of the target velocity for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetVelocityX"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TargetVelocityX.setter
    def TargetVelocityX(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTargetVelocityX"](arg_newVal.COM_val))

    @property
    def TargetVelocityY(self) -> float:
        """The Y component of the target velocity for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetVelocityY"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TargetVelocityY.setter
    def TargetVelocityY(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTargetVelocityY"](arg_newVal.COM_val))

    @property
    def TargetVelocityZ(self) -> float:
        """The Z component of the target velocity for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetVelocityZ"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TargetVelocityZ.setter
    def TargetVelocityZ(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTargetVelocityZ"](arg_newVal.COM_val))

    @property
    def TargetSemimajorAxis(self) -> float:
        """The target semimajor axis for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetSemimajorAxis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TargetSemimajorAxis.setter
    def TargetSemimajorAxis(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTargetSemimajorAxis"](arg_newVal.COM_val))

    @property
    def TargetEccentricity(self) -> float:
        """The target eccentricity for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetEccentricity"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TargetEccentricity.setter
    def TargetEccentricity(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTargetEccentricity"](arg_newVal.COM_val))

    @property
    def TargetInclination(self) -> float:
        """The target inclination for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetInclination"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TargetInclination.setter
    def TargetInclination(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTargetInclination"](arg_newVal.COM_val))

    @property
    def TargetRightAscensionOfAscendingNode(self) -> float:
        """The target right ascension of the ascending node for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetRightAscensionOfAscendingNode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TargetRightAscensionOfAscendingNode.setter
    def TargetRightAscensionOfAscendingNode(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTargetRightAscensionOfAscendingNode"](arg_newVal.COM_val))

    @property
    def TargetArgumentOfPeriapsis(self) -> float:
        """The target argument of periapsis for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetArgumentOfPeriapsis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TargetArgumentOfPeriapsis.setter
    def TargetArgumentOfPeriapsis(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTargetArgumentOfPeriapsis"](arg_newVal.COM_val))

    @property
    def TargetTrueAnomaly(self) -> float:
        """The target true anomaly for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetTrueAnomaly"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TargetTrueAnomaly.setter
    def TargetTrueAnomaly(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTargetTrueAnomaly"](arg_newVal.COM_val))

    @property
    def SolutionOption(self) -> "AgEVALambertSolutionOptionType":
        """Lambert solution calculation type."""
        with agmarshall.AgEnum_arg(AgEVALambertSolutionOptionType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSolutionOption"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SolutionOption.setter
    def SolutionOption(self, newVal:"AgEVALambertSolutionOptionType") -> None:
        with agmarshall.AgEnum_arg(AgEVALambertSolutionOptionType, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetSolutionOption"](arg_newVal.COM_val))

    @property
    def TimeOfFlight(self) -> float:
        """The time of flight between departure and arrival for the Lambert solution."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeOfFlight"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TimeOfFlight.setter
    def TimeOfFlight(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTimeOfFlight"](arg_newVal.COM_val))

    @property
    def Revolutions(self) -> int:
        """The number of revolutions. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRevolutions"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Revolutions.setter
    def Revolutions(self, newVal:int) -> None:
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetRevolutions"](arg_newVal.COM_val))

    @property
    def OrbitalEnergy(self) -> "AgEVALambertOrbitalEnergyType":
        """The orbital energy for the Lambert solution."""
        with agmarshall.AgEnum_arg(AgEVALambertOrbitalEnergyType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetOrbitalEnergy"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @OrbitalEnergy.setter
    def OrbitalEnergy(self, newVal:"AgEVALambertOrbitalEnergyType") -> None:
        with agmarshall.AgEnum_arg(AgEVALambertOrbitalEnergyType, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetOrbitalEnergy"](arg_newVal.COM_val))

    @property
    def DirectionOfMotion(self) -> "AgEVALambertDirectionOfMotionType":
        """The direction of motion (long or short) for the Lambert solution."""
        with agmarshall.AgEnum_arg(AgEVALambertDirectionOfMotionType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDirectionOfMotion"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DirectionOfMotion.setter
    def DirectionOfMotion(self, newVal:"AgEVALambertDirectionOfMotionType") -> None:
        with agmarshall.AgEnum_arg(AgEVALambertDirectionOfMotionType, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetDirectionOfMotion"](arg_newVal.COM_val))

    @property
    def CentralBodyCollisionAltitudePadding(self) -> float:
        """The minimum altitude below which the Lambert algorithm will consider the spacecraft to have hit the central body."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyCollisionAltitudePadding"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyCollisionAltitudePadding.setter
    def CentralBodyCollisionAltitudePadding(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyCollisionAltitudePadding"](arg_newVal.COM_val))

    @property
    def EnableWriteToFirstManeuver(self) -> bool:
        """Set this to true to write the Delta-V solution from Lambert at the start of the transfer to the linked maneuver."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnableWriteToFirstManeuver"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EnableWriteToFirstManeuver.setter
    def EnableWriteToFirstManeuver(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnableWriteToFirstManeuver"](arg_newVal.COM_val))

    @property
    def FirstManeuverSegment(self) -> str:
        """The first maneuver segment to manipulate that occurs at the start of the transfer."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetFirstManeuverSegment"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @FirstManeuverSegment.setter
    def FirstManeuverSegment(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetFirstManeuverSegment"](arg_newVal.COM_val))

    @property
    def EnableWriteDurationToPropagate(self) -> bool:
        """Set this to true to write the Lambert duration of transfer to the 'LambertDuration' stopping condition in the linked propagate segment."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnableWriteDurationToPropagate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EnableWriteDurationToPropagate.setter
    def EnableWriteDurationToPropagate(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnableWriteDurationToPropagate"](arg_newVal.COM_val))

    @property
    def DisableNonLambertPropagateStopConditions(self) -> bool:
        """Set this to true to disable all non-LambertDuration stopping conditions in the propagate segment."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDisableNonLambertPropagateStopConditions"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DisableNonLambertPropagateStopConditions.setter
    def DisableNonLambertPropagateStopConditions(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetDisableNonLambertPropagateStopConditions"](arg_newVal.COM_val))

    @property
    def PropagateSegment(self) -> str:
        """This is the propagate segment to manipulate that contains the transfer duration."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPropagateSegment"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @PropagateSegment.setter
    def PropagateSegment(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetPropagateSegment"](arg_newVal.COM_val))

    @property
    def EnableWriteToSecondManeuver(self) -> bool:
        """Set this to true to write the Delta-V solution from Lambert at the end of the transfer to the linked maneuver."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnableWriteToSecondManeuver"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EnableWriteToSecondManeuver.setter
    def EnableWriteToSecondManeuver(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnableWriteToSecondManeuver"](arg_newVal.COM_val))

    @property
    def SecondManeuverSegment(self) -> str:
        """This is the second maneuver segment to manipulate that occurs at the end of the transfer."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSecondManeuverSegment"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SecondManeuverSegment.setter
    def SecondManeuverSegment(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetSecondManeuverSegment"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{6F736B1F-850D-4736-9106-8BDC4FE52A30}", IVAProfileLambertProfile)
agcls.AgTypeNameMap["IVAProfileLambertProfile"] = IVAProfileLambertProfile

class IVAProfileLambertSearchProfile(IVAProfile):
    """Properties for a Lambert Search Profile."""
    _uuid = "{22C5891F-AD49-40BE-9C99-58E23CCFD106}"
    _num_methods = 64
    _vtable_offset = IVAProfile._vtable_offset + IVAProfile._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_SetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_GetTargetCoordType"] = _raise_uninitialized_error
        self.__dict__["_SetTargetCoordType"] = _raise_uninitialized_error
        self.__dict__["_GetEnableSecondManeuver"] = _raise_uninitialized_error
        self.__dict__["_SetEnableSecondManeuver"] = _raise_uninitialized_error
        self.__dict__["_GetEnableTargetMatchPhase"] = _raise_uninitialized_error
        self.__dict__["_SetEnableTargetMatchPhase"] = _raise_uninitialized_error
        self.__dict__["_GetTargetPositionX"] = _raise_uninitialized_error
        self.__dict__["_SetTargetPositionX"] = _raise_uninitialized_error
        self.__dict__["_GetTargetPositionY"] = _raise_uninitialized_error
        self.__dict__["_SetTargetPositionY"] = _raise_uninitialized_error
        self.__dict__["_GetTargetPositionZ"] = _raise_uninitialized_error
        self.__dict__["_SetTargetPositionZ"] = _raise_uninitialized_error
        self.__dict__["_GetTargetVelocityX"] = _raise_uninitialized_error
        self.__dict__["_SetTargetVelocityX"] = _raise_uninitialized_error
        self.__dict__["_GetTargetVelocityY"] = _raise_uninitialized_error
        self.__dict__["_SetTargetVelocityY"] = _raise_uninitialized_error
        self.__dict__["_GetTargetVelocityZ"] = _raise_uninitialized_error
        self.__dict__["_SetTargetVelocityZ"] = _raise_uninitialized_error
        self.__dict__["_GetTargetSemimajorAxis"] = _raise_uninitialized_error
        self.__dict__["_SetTargetSemimajorAxis"] = _raise_uninitialized_error
        self.__dict__["_GetTargetEccentricity"] = _raise_uninitialized_error
        self.__dict__["_SetTargetEccentricity"] = _raise_uninitialized_error
        self.__dict__["_GetTargetInclination"] = _raise_uninitialized_error
        self.__dict__["_SetTargetInclination"] = _raise_uninitialized_error
        self.__dict__["_GetTargetRightAscensionOfAscendingNode"] = _raise_uninitialized_error
        self.__dict__["_SetTargetRightAscensionOfAscendingNode"] = _raise_uninitialized_error
        self.__dict__["_GetTargetArgumentOfPeriapsis"] = _raise_uninitialized_error
        self.__dict__["_SetTargetArgumentOfPeriapsis"] = _raise_uninitialized_error
        self.__dict__["_GetTargetTrueAnomaly"] = _raise_uninitialized_error
        self.__dict__["_SetTargetTrueAnomaly"] = _raise_uninitialized_error
        self.__dict__["_GetEnableWriteDepartureDelayToFirstPropagate"] = _raise_uninitialized_error
        self.__dict__["_SetEnableWriteDepartureDelayToFirstPropagate"] = _raise_uninitialized_error
        self.__dict__["_GetDisableFirstPropagateNonLambertStopConditions"] = _raise_uninitialized_error
        self.__dict__["_SetDisableFirstPropagateNonLambertStopConditions"] = _raise_uninitialized_error
        self.__dict__["_GetFirstPropagateSegment"] = _raise_uninitialized_error
        self.__dict__["_SetFirstPropagateSegment"] = _raise_uninitialized_error
        self.__dict__["_GetEnableWriteToFirstManeuver"] = _raise_uninitialized_error
        self.__dict__["_SetEnableWriteToFirstManeuver"] = _raise_uninitialized_error
        self.__dict__["_GetFirstManeuverSegment"] = _raise_uninitialized_error
        self.__dict__["_SetFirstManeuverSegment"] = _raise_uninitialized_error
        self.__dict__["_GetLatestDepartureTime"] = _raise_uninitialized_error
        self.__dict__["_SetLatestDepartureTime"] = _raise_uninitialized_error
        self.__dict__["_GetEarliestArrivalTime"] = _raise_uninitialized_error
        self.__dict__["_SetEarliestArrivalTime"] = _raise_uninitialized_error
        self.__dict__["_GetLatestArrivalTime"] = _raise_uninitialized_error
        self.__dict__["_SetLatestArrivalTime"] = _raise_uninitialized_error
        self.__dict__["_GetGridSearchTimeStep"] = _raise_uninitialized_error
        self.__dict__["_SetGridSearchTimeStep"] = _raise_uninitialized_error
        self.__dict__["_GetMaxRevolutions"] = _raise_uninitialized_error
        self.__dict__["_SetMaxRevolutions"] = _raise_uninitialized_error
        self.__dict__["_GetCentralBodyCollisionAltitudePadding"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyCollisionAltitudePadding"] = _raise_uninitialized_error
        self.__dict__["_GetEnableWriteDurationToSecondPropagate"] = _raise_uninitialized_error
        self.__dict__["_SetEnableWriteDurationToSecondPropagate"] = _raise_uninitialized_error
        self.__dict__["_GetDisableSecondPropagateNonLambertStopConditions"] = _raise_uninitialized_error
        self.__dict__["_SetDisableSecondPropagateNonLambertStopConditions"] = _raise_uninitialized_error
        self.__dict__["_GetSecondPropagateSegment"] = _raise_uninitialized_error
        self.__dict__["_SetSecondPropagateSegment"] = _raise_uninitialized_error
        self.__dict__["_GetEnableWriteToSecondManeuver"] = _raise_uninitialized_error
        self.__dict__["_SetEnableWriteToSecondManeuver"] = _raise_uninitialized_error
        self.__dict__["_GetSecondManeuverSegment"] = _raise_uninitialized_error
        self.__dict__["_SetSecondManeuverSegment"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAProfileLambertSearchProfile._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAProfileLambertSearchProfile from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAProfile._private_init(self, pUnk)
        IID_IVAProfileLambertSearchProfile = agcom.GUID(IVAProfileLambertSearchProfile._uuid)
        vtable_offset_local = IVAProfileLambertSearchProfile._vtable_offset - 1
        self.__dict__["_GetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetTargetCoordType"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetTargetCoordType"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetEnableSecondManeuver"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnableSecondManeuver"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetEnableTargetMatchPhase"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnableTargetMatchPhase"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_GetTargetPositionX"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTargetPositionX"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetTargetPositionY"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTargetPositionY"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetTargetPositionZ"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTargetPositionZ"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetTargetVelocityX"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTargetVelocityX"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_GetTargetVelocityY"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTargetVelocityY"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_GetTargetVelocityZ"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTargetVelocityZ"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_GetTargetSemimajorAxis"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTargetSemimajorAxis"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+22, agcom.DOUBLE)
        self.__dict__["_GetTargetEccentricity"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+23, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTargetEccentricity"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+24, agcom.DOUBLE)
        self.__dict__["_GetTargetInclination"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+25, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTargetInclination"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+26, agcom.DOUBLE)
        self.__dict__["_GetTargetRightAscensionOfAscendingNode"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+27, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTargetRightAscensionOfAscendingNode"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+28, agcom.DOUBLE)
        self.__dict__["_GetTargetArgumentOfPeriapsis"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+29, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTargetArgumentOfPeriapsis"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+30, agcom.DOUBLE)
        self.__dict__["_GetTargetTrueAnomaly"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+31, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTargetTrueAnomaly"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+32, agcom.DOUBLE)
        self.__dict__["_GetEnableWriteDepartureDelayToFirstPropagate"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+33, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnableWriteDepartureDelayToFirstPropagate"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+34, agcom.VARIANT_BOOL)
        self.__dict__["_GetDisableFirstPropagateNonLambertStopConditions"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+35, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetDisableFirstPropagateNonLambertStopConditions"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+36, agcom.VARIANT_BOOL)
        self.__dict__["_GetFirstPropagateSegment"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+37, POINTER(agcom.BSTR))
        self.__dict__["_SetFirstPropagateSegment"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+38, agcom.BSTR)
        self.__dict__["_GetEnableWriteToFirstManeuver"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+39, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnableWriteToFirstManeuver"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+40, agcom.VARIANT_BOOL)
        self.__dict__["_GetFirstManeuverSegment"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+41, POINTER(agcom.BSTR))
        self.__dict__["_SetFirstManeuverSegment"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+42, agcom.BSTR)
        self.__dict__["_GetLatestDepartureTime"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+43, POINTER(agcom.DOUBLE))
        self.__dict__["_SetLatestDepartureTime"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+44, agcom.DOUBLE)
        self.__dict__["_GetEarliestArrivalTime"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+45, POINTER(agcom.DOUBLE))
        self.__dict__["_SetEarliestArrivalTime"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+46, agcom.DOUBLE)
        self.__dict__["_GetLatestArrivalTime"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+47, POINTER(agcom.DOUBLE))
        self.__dict__["_SetLatestArrivalTime"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+48, agcom.DOUBLE)
        self.__dict__["_GetGridSearchTimeStep"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+49, POINTER(agcom.DOUBLE))
        self.__dict__["_SetGridSearchTimeStep"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+50, agcom.DOUBLE)
        self.__dict__["_GetMaxRevolutions"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+51, POINTER(agcom.LONG))
        self.__dict__["_SetMaxRevolutions"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+52, agcom.LONG)
        self.__dict__["_GetCentralBodyCollisionAltitudePadding"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+53, POINTER(agcom.DOUBLE))
        self.__dict__["_SetCentralBodyCollisionAltitudePadding"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+54, agcom.DOUBLE)
        self.__dict__["_GetEnableWriteDurationToSecondPropagate"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+55, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnableWriteDurationToSecondPropagate"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+56, agcom.VARIANT_BOOL)
        self.__dict__["_GetDisableSecondPropagateNonLambertStopConditions"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+57, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetDisableSecondPropagateNonLambertStopConditions"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+58, agcom.VARIANT_BOOL)
        self.__dict__["_GetSecondPropagateSegment"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+59, POINTER(agcom.BSTR))
        self.__dict__["_SetSecondPropagateSegment"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+60, agcom.BSTR)
        self.__dict__["_GetEnableWriteToSecondManeuver"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+61, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnableWriteToSecondManeuver"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+62, agcom.VARIANT_BOOL)
        self.__dict__["_GetSecondManeuverSegment"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+63, POINTER(agcom.BSTR))
        self.__dict__["_SetSecondManeuverSegment"] = IAGFUNCTYPE(pUnk, IID_IVAProfileLambertSearchProfile, vtable_offset_local+64, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAProfileLambertSearchProfile.__dict__ and type(IVAProfileLambertSearchProfile.__dict__[attrname]) == property:
            return IVAProfileLambertSearchProfile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAProfile.__setattr__(self, attrname, value)
    
    @property
    def CoordSystemName(self) -> str:
        """The coordinate system."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordSystemName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordSystemName.setter
    def CoordSystemName(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordSystemName"](arg_newVal.COM_val))

    @property
    def TargetCoordType(self) -> "AgEVALambertTargetCoordType":
        """The target coordinate type."""
        with agmarshall.AgEnum_arg(AgEVALambertTargetCoordType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetCoordType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def SetTargetCoordType(self, elementType:"AgEVALambertTargetCoordType") -> None:
        """Selects a target coordinate type."""
        with agmarshall.AgEnum_arg(AgEVALambertTargetCoordType, elementType) as arg_elementType:
            agcls.evaluate_hresult(self.__dict__["_SetTargetCoordType"](arg_elementType.COM_val))

    @property
    def EnableSecondManeuver(self) -> bool:
        """Enable to calculate second maneuver at destination."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnableSecondManeuver"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EnableSecondManeuver.setter
    def EnableSecondManeuver(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnableSecondManeuver"](arg_newVal.COM_val))

    @property
    def EnableTargetMatchPhase(self) -> bool:
        """Set this to true if the satellite should match the phase of the orbit at the target."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnableTargetMatchPhase"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EnableTargetMatchPhase.setter
    def EnableTargetMatchPhase(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnableTargetMatchPhase"](arg_newVal.COM_val))

    @property
    def TargetPositionX(self) -> float:
        """The X component of the target position for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetPositionX"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TargetPositionX.setter
    def TargetPositionX(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTargetPositionX"](arg_newVal.COM_val))

    @property
    def TargetPositionY(self) -> float:
        """The Y component of the target position for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetPositionY"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TargetPositionY.setter
    def TargetPositionY(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTargetPositionY"](arg_newVal.COM_val))

    @property
    def TargetPositionZ(self) -> float:
        """The Z component of the target position for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetPositionZ"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TargetPositionZ.setter
    def TargetPositionZ(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTargetPositionZ"](arg_newVal.COM_val))

    @property
    def TargetVelocityX(self) -> float:
        """The X component of the target velocity for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetVelocityX"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TargetVelocityX.setter
    def TargetVelocityX(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTargetVelocityX"](arg_newVal.COM_val))

    @property
    def TargetVelocityY(self) -> float:
        """The Y component of the target velocity for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetVelocityY"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TargetVelocityY.setter
    def TargetVelocityY(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTargetVelocityY"](arg_newVal.COM_val))

    @property
    def TargetVelocityZ(self) -> float:
        """The Z component of the target velocity for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetVelocityZ"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TargetVelocityZ.setter
    def TargetVelocityZ(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTargetVelocityZ"](arg_newVal.COM_val))

    @property
    def TargetSemimajorAxis(self) -> float:
        """The target semimajor axis for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetSemimajorAxis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TargetSemimajorAxis.setter
    def TargetSemimajorAxis(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTargetSemimajorAxis"](arg_newVal.COM_val))

    @property
    def TargetEccentricity(self) -> float:
        """The target eccentricity for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetEccentricity"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TargetEccentricity.setter
    def TargetEccentricity(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTargetEccentricity"](arg_newVal.COM_val))

    @property
    def TargetInclination(self) -> float:
        """The target inclination for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetInclination"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TargetInclination.setter
    def TargetInclination(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTargetInclination"](arg_newVal.COM_val))

    @property
    def TargetRightAscensionOfAscendingNode(self) -> float:
        """The target right ascension of the ascending node for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetRightAscensionOfAscendingNode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TargetRightAscensionOfAscendingNode.setter
    def TargetRightAscensionOfAscendingNode(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTargetRightAscensionOfAscendingNode"](arg_newVal.COM_val))

    @property
    def TargetArgumentOfPeriapsis(self) -> float:
        """The target argument of periapsis for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetArgumentOfPeriapsis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TargetArgumentOfPeriapsis.setter
    def TargetArgumentOfPeriapsis(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTargetArgumentOfPeriapsis"](arg_newVal.COM_val))

    @property
    def TargetTrueAnomaly(self) -> float:
        """The target true anomaly for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetTrueAnomaly"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TargetTrueAnomaly.setter
    def TargetTrueAnomaly(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetTargetTrueAnomaly"](arg_newVal.COM_val))

    @property
    def EnableWriteDepartureDelayToFirstPropagate(self) -> bool:
        """Set this to true to write the departure delay duration before the Lambert transfer to the 'LambertDuration' stopping condition in the first linked propagate segment."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnableWriteDepartureDelayToFirstPropagate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EnableWriteDepartureDelayToFirstPropagate.setter
    def EnableWriteDepartureDelayToFirstPropagate(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnableWriteDepartureDelayToFirstPropagate"](arg_newVal.COM_val))

    @property
    def DisableFirstPropagateNonLambertStopConditions(self) -> bool:
        """Set this to true to disable all non-LambertDuration stopping conditions in the first propagate segment."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDisableFirstPropagateNonLambertStopConditions"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DisableFirstPropagateNonLambertStopConditions.setter
    def DisableFirstPropagateNonLambertStopConditions(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetDisableFirstPropagateNonLambertStopConditions"](arg_newVal.COM_val))

    @property
    def FirstPropagateSegment(self) -> str:
        """This is the propagate segment to manipulate that contains the departure delay."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetFirstPropagateSegment"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @FirstPropagateSegment.setter
    def FirstPropagateSegment(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetFirstPropagateSegment"](arg_newVal.COM_val))

    @property
    def EnableWriteToFirstManeuver(self) -> bool:
        """et this to true to write the Delta-V solution from Lambert at the start of the transfer to the linked maneuver."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnableWriteToFirstManeuver"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EnableWriteToFirstManeuver.setter
    def EnableWriteToFirstManeuver(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnableWriteToFirstManeuver"](arg_newVal.COM_val))

    @property
    def FirstManeuverSegment(self) -> str:
        """This is the first maneuver segment to manipulate that occurs at the start of the transfer. It is visible when you select Write Initial Inertial Delta-V to Maneuver."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetFirstManeuverSegment"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @FirstManeuverSegment.setter
    def FirstManeuverSegment(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetFirstManeuverSegment"](arg_newVal.COM_val))

    @property
    def LatestDepartureTime(self) -> float:
        """This is the latest time from the start of the target sequence for the first Lambert maneuver to occur."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLatestDepartureTime"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @LatestDepartureTime.setter
    def LatestDepartureTime(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetLatestDepartureTime"](arg_newVal.COM_val))

    @property
    def EarliestArrivalTime(self) -> float:
        """This is the earliest time from the start of the target sequence that the satellite should arrive at its destination."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEarliestArrivalTime"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EarliestArrivalTime.setter
    def EarliestArrivalTime(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEarliestArrivalTime"](arg_newVal.COM_val))

    @property
    def LatestArrivalTime(self) -> float:
        """This is the latest time from the start of the target sequence that the satellite should arrive at its destination."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLatestArrivalTime"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @LatestArrivalTime.setter
    def LatestArrivalTime(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetLatestArrivalTime"](arg_newVal.COM_val))

    @property
    def GridSearchTimeStep(self) -> float:
        """This is the time step between Lambert evaluations for searching over both the departure window and arrival window of time."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetGridSearchTimeStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @GridSearchTimeStep.setter
    def GridSearchTimeStep(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetGridSearchTimeStep"](arg_newVal.COM_val))

    @property
    def MaxRevolutions(self) -> int:
        """This is the maximum number of revolutions for the Lambert solution."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxRevolutions"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxRevolutions.setter
    def MaxRevolutions(self, newVal:int) -> None:
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxRevolutions"](arg_newVal.COM_val))

    @property
    def CentralBodyCollisionAltitudePadding(self) -> float:
        """The minimum altitude below which the Lambert algorithm will consider the spacecraft to have hit the central body."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyCollisionAltitudePadding"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyCollisionAltitudePadding.setter
    def CentralBodyCollisionAltitudePadding(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyCollisionAltitudePadding"](arg_newVal.COM_val))

    @property
    def EnableWriteDurationToSecondPropagate(self) -> bool:
        """Set this to true to write the Lambert duration of transfer to the 'LambertDuration' stopping condition in the second linked propagate segment."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnableWriteDurationToSecondPropagate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EnableWriteDurationToSecondPropagate.setter
    def EnableWriteDurationToSecondPropagate(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnableWriteDurationToSecondPropagate"](arg_newVal.COM_val))

    @property
    def DisableSecondPropagateNonLambertStopConditions(self) -> bool:
        """Set this to true to disable all non-LambertDuration stopping conditions in the second propagate segment. This is visible when you select Write Flight Duration to Second Propagate."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDisableSecondPropagateNonLambertStopConditions"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DisableSecondPropagateNonLambertStopConditions.setter
    def DisableSecondPropagateNonLambertStopConditions(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetDisableSecondPropagateNonLambertStopConditions"](arg_newVal.COM_val))

    @property
    def SecondPropagateSegment(self) -> str:
        """This is the propagate segment to manipulate that contains the transfer duration. It is visible when you select Write Flight Duration to Second Propagate."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSecondPropagateSegment"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SecondPropagateSegment.setter
    def SecondPropagateSegment(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetSecondPropagateSegment"](arg_newVal.COM_val))

    @property
    def EnableWriteToSecondManeuver(self) -> bool:
        """Set this to true to write the Delta-V solution from Lambert at the end of the transfer to the linked maneuver. It is visible when you select Calculate Second Maneuver At Destination ."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnableWriteToSecondManeuver"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EnableWriteToSecondManeuver.setter
    def EnableWriteToSecondManeuver(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnableWriteToSecondManeuver"](arg_newVal.COM_val))

    @property
    def SecondManeuverSegment(self) -> str:
        """This is the second maneuver segment to manipulate that occurs at the end of the transfer. It is visible when you select Write Final Inertial Delta-V to Maneuver."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSecondManeuverSegment"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SecondManeuverSegment.setter
    def SecondManeuverSegment(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetSecondManeuverSegment"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{22C5891F-AD49-40BE-9C99-58E23CCFD106}", IVAProfileLambertSearchProfile)
agcls.AgTypeNameMap["IVAProfileLambertSearchProfile"] = IVAProfileLambertSearchProfile

class IVAProfileGoldenSection(IVAProfile):
    """Properties for a Golden Section profile."""
    _uuid = "{505EC87D-BE26-4477-B7E8-6586731428D0}"
    _num_methods = 9
    _vtable_offset = IVAProfile._vtable_offset + IVAProfile._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTargeterGraphs"] = _raise_uninitialized_error
        self.__dict__["_GetScriptingTool"] = _raise_uninitialized_error
        self.__dict__["_GetControls"] = _raise_uninitialized_error
        self.__dict__["_GetResults"] = _raise_uninitialized_error
        self.__dict__["_GetMaxIterations"] = _raise_uninitialized_error
        self.__dict__["_SetMaxIterations"] = _raise_uninitialized_error
        self.__dict__["_GetLogFile"] = _raise_uninitialized_error
        self.__dict__["_GetEnableDisplayStatus"] = _raise_uninitialized_error
        self.__dict__["_SetEnableDisplayStatus"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAProfileGoldenSection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAProfileGoldenSection from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAProfile._private_init(self, pUnk)
        IID_IVAProfileGoldenSection = agcom.GUID(IVAProfileGoldenSection._uuid)
        vtable_offset_local = IVAProfileGoldenSection._vtable_offset - 1
        self.__dict__["_GetTargeterGraphs"] = IAGFUNCTYPE(pUnk, IID_IVAProfileGoldenSection, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetScriptingTool"] = IAGFUNCTYPE(pUnk, IID_IVAProfileGoldenSection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetControls"] = IAGFUNCTYPE(pUnk, IID_IVAProfileGoldenSection, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetResults"] = IAGFUNCTYPE(pUnk, IID_IVAProfileGoldenSection, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetMaxIterations"] = IAGFUNCTYPE(pUnk, IID_IVAProfileGoldenSection, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetMaxIterations"] = IAGFUNCTYPE(pUnk, IID_IVAProfileGoldenSection, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetLogFile"] = IAGFUNCTYPE(pUnk, IID_IVAProfileGoldenSection, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_GetEnableDisplayStatus"] = IAGFUNCTYPE(pUnk, IID_IVAProfileGoldenSection, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnableDisplayStatus"] = IAGFUNCTYPE(pUnk, IID_IVAProfileGoldenSection, vtable_offset_local+9, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAProfileGoldenSection.__dict__ and type(IVAProfileGoldenSection.__dict__[attrname]) == property:
            return IVAProfileGoldenSection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAProfile.__setattr__(self, attrname, value)
    
    @property
    def TargeterGraphs(self) -> "IVATargeterGraphCollection":
        """Graphs"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargeterGraphs"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ScriptingTool(self) -> "IVAScriptingTool":
        """Returns the Scripting tool for the sequence."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScriptingTool"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Controls(self) -> "IVAGoldenSectionControlCollection":
        """The list of control parameters defined for the profile."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAGoldenSectionControlCollection:
            agcls.evaluate_hresult(self.__dict__["_GetControls"](byref(arg_ppVAGoldenSectionControlCollection.COM_val)))
            return arg_ppVAGoldenSectionControlCollection.python_val

    @property
    def Results(self) -> "IVAGoldenSectionResultCollection":
        """The list of results defined for the profile."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAGoldenSectionResultCollection:
            agcls.evaluate_hresult(self.__dict__["_GetResults"](byref(arg_ppVAGoldenSectionResultCollection.COM_val)))
            return arg_ppVAGoldenSectionResultCollection.python_val

    @property
    def MaxIterations(self) -> int:
        """The number of complete iterations of the profile to try before stopping. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxIterations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxIterations.setter
    def MaxIterations(self, newVal:int) -> None:
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxIterations"](arg_newVal.COM_val))

    @property
    def LogFile(self) -> str:
        """Name of the log file for this profile."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLogFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def EnableDisplayStatus(self) -> bool:
        """If true, a page will appear during the targeting run to report the status of the targeting effort in terms of proximity to the desired value for each dependent variable in the profile."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnableDisplayStatus"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EnableDisplayStatus.setter
    def EnableDisplayStatus(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnableDisplayStatus"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{505EC87D-BE26-4477-B7E8-6586731428D0}", IVAProfileGoldenSection)
agcls.AgTypeNameMap["IVAProfileGoldenSection"] = IVAProfileGoldenSection

class IVAProfileGridSearch(IVAProfile):
    """Properties for a Grid Search profile."""
    _uuid = "{EDE96C58-0563-4B05-A7B6-735C3699FE87}"
    _num_methods = 9
    _vtable_offset = IVAProfile._vtable_offset + IVAProfile._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTargeterGraphs"] = _raise_uninitialized_error
        self.__dict__["_GetScriptingTool"] = _raise_uninitialized_error
        self.__dict__["_GetControls"] = _raise_uninitialized_error
        self.__dict__["_GetResults"] = _raise_uninitialized_error
        self.__dict__["_GetLogFile"] = _raise_uninitialized_error
        self.__dict__["_GetEnableDisplayStatus"] = _raise_uninitialized_error
        self.__dict__["_SetEnableDisplayStatus"] = _raise_uninitialized_error
        self.__dict__["_GetShouldGenerateGraph"] = _raise_uninitialized_error
        self.__dict__["_SetShouldGenerateGraph"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAProfileGridSearch._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAProfileGridSearch from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAProfile._private_init(self, pUnk)
        IID_IVAProfileGridSearch = agcom.GUID(IVAProfileGridSearch._uuid)
        vtable_offset_local = IVAProfileGridSearch._vtable_offset - 1
        self.__dict__["_GetTargeterGraphs"] = IAGFUNCTYPE(pUnk, IID_IVAProfileGridSearch, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetScriptingTool"] = IAGFUNCTYPE(pUnk, IID_IVAProfileGridSearch, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetControls"] = IAGFUNCTYPE(pUnk, IID_IVAProfileGridSearch, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetResults"] = IAGFUNCTYPE(pUnk, IID_IVAProfileGridSearch, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetLogFile"] = IAGFUNCTYPE(pUnk, IID_IVAProfileGridSearch, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_GetEnableDisplayStatus"] = IAGFUNCTYPE(pUnk, IID_IVAProfileGridSearch, vtable_offset_local+6, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetEnableDisplayStatus"] = IAGFUNCTYPE(pUnk, IID_IVAProfileGridSearch, vtable_offset_local+7, agcom.VARIANT_BOOL)
        self.__dict__["_GetShouldGenerateGraph"] = IAGFUNCTYPE(pUnk, IID_IVAProfileGridSearch, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetShouldGenerateGraph"] = IAGFUNCTYPE(pUnk, IID_IVAProfileGridSearch, vtable_offset_local+9, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAProfileGridSearch.__dict__ and type(IVAProfileGridSearch.__dict__[attrname]) == property:
            return IVAProfileGridSearch.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVAProfile.__setattr__(self, attrname, value)
    
    @property
    def TargeterGraphs(self) -> "IVATargeterGraphCollection":
        """Graphs"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargeterGraphs"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ScriptingTool(self) -> "IVAScriptingTool":
        """Returns the Scripting tool for the sequence."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetScriptingTool"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Controls(self) -> "IVAGridSearchControlCollection":
        """The list of control parameters defined for the profile."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAGridSearchControlCollection:
            agcls.evaluate_hresult(self.__dict__["_GetControls"](byref(arg_ppVAGridSearchControlCollection.COM_val)))
            return arg_ppVAGridSearchControlCollection.python_val

    @property
    def Results(self) -> "IVAGridSearchResultCollection":
        """The list of results defined for the profile."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAGridSearchResultCollection:
            agcls.evaluate_hresult(self.__dict__["_GetResults"](byref(arg_ppVAGridSearchResultCollection.COM_val)))
            return arg_ppVAGridSearchResultCollection.python_val

    @property
    def LogFile(self) -> str:
        """Name of the log file for this profile."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLogFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def EnableDisplayStatus(self) -> bool:
        """If true, a page will appear during the targeting run to report the status of the targeting effort in terms of proximity to the desired value for each dependent variable in the profile."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEnableDisplayStatus"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EnableDisplayStatus.setter
    def EnableDisplayStatus(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEnableDisplayStatus"](arg_newVal.COM_val))

    @property
    def ShouldGenerateGraph(self) -> bool:
        """If true, a plot is automatically generate the selected result value versus the control value for the grid search when the profile runs."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetShouldGenerateGraph"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ShouldGenerateGraph.setter
    def ShouldGenerateGraph(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetShouldGenerateGraph"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{EDE96C58-0563-4B05-A7B6-735C3699FE87}", IVAProfileGridSearch)
agcls.AgTypeNameMap["IVAProfileGridSearch"] = IVAProfileGridSearch

class IVACalcObjectLinkEmbedControlCollection(object):
    """Collection of link/embed calculation objects."""
    _uuid = "{4294354A-2EF8-4D34-8FC9-DD360DFCF3EF}"
    _num_methods = 10
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Add"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_Cut"] = _raise_uninitialized_error
        self.__dict__["_Paste"] = _raise_uninitialized_error
        self.__dict__["_InsertCopy"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVACalcObjectLinkEmbedControlCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVACalcObjectLinkEmbedControlCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVACalcObjectLinkEmbedControlCollection = agcom.GUID(IVACalcObjectLinkEmbedControlCollection._uuid)
        vtable_offset_local = IVACalcObjectLinkEmbedControlCollection._vtable_offset - 1
        self.__dict__["_Add"] = IAGFUNCTYPE(pUnk, IID_IVACalcObjectLinkEmbedControlCollection, vtable_offset_local+1, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVACalcObjectLinkEmbedControlCollection, vtable_offset_local+2, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IVACalcObjectLinkEmbedControlCollection, vtable_offset_local+3, agcom.VARIANT)
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVACalcObjectLinkEmbedControlCollection, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVACalcObjectLinkEmbedControlCollection, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_Cut"] = IAGFUNCTYPE(pUnk, IID_IVACalcObjectLinkEmbedControlCollection, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_Paste"] = IAGFUNCTYPE(pUnk, IID_IVACalcObjectLinkEmbedControlCollection, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_InsertCopy"] = IAGFUNCTYPE(pUnk, IID_IVACalcObjectLinkEmbedControlCollection, vtable_offset_local+8, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IVACalcObjectLinkEmbedControlCollection, vtable_offset_local+9, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IVACalcObjectLinkEmbedControlCollection, vtable_offset_local+10, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVACalcObjectLinkEmbedControlCollection.__dict__ and type(IVACalcObjectLinkEmbedControlCollection.__dict__[attrname]) == property:
            return IVACalcObjectLinkEmbedControlCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVACalcObjectLinkEmbedControlCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IComponentLinkEmbedControl":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Add(self, name:str, refType:"AgEComponentLinkEmbedControlReferenceType") -> "IComponentLinkEmbedControl":
        """Adds a link/embed calc object to the collection."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgEnum_arg(AgEComponentLinkEmbedControlReferenceType, refType) as arg_refType, \
             agmarshall.AgInterface_out_arg() as arg_ppComponentLinkEmbedControl:
            agcls.evaluate_hresult(self.__dict__["_Add"](arg_name.COM_val, arg_refType.COM_val, byref(arg_ppComponentLinkEmbedControl.COM_val)))
            return arg_ppComponentLinkEmbedControl.python_val

    def Item(self, indexOrName:typing.Any) -> "IComponentLinkEmbedControl":
        """Returns a link/embed calc object."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppComponentLinkEmbedControl:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppComponentLinkEmbedControl.COM_val)))
            return arg_ppComponentLinkEmbedControl.python_val

    def Remove(self, indexOrName:typing.Any) -> None:
        """Removes a link/embed calc object from the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_indexOrName.COM_val))

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def Cut(self, indexOrName:typing.Any) -> None:
        """Copies a link/embed calc object to the clipboard and removes the calc object from the list."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_Cut"](arg_indexOrName.COM_val))

    def Paste(self) -> "IComponentLinkEmbedControl":
        """Pastes a link/embed calc object from the clipboard into the list."""
        with agmarshall.AgInterface_out_arg() as arg_ppCalcObj:
            agcls.evaluate_hresult(self.__dict__["_Paste"](byref(arg_ppCalcObj.COM_val)))
            return arg_ppCalcObj.python_val

    def InsertCopy(self, calcObj:"IComponentLinkEmbedControl") -> "IComponentLinkEmbedControl":
        """Copies a link/embed calc object and inserts the copy into the list."""
        with agmarshall.AgInterface_in_arg(calcObj, IComponentLinkEmbedControl) as arg_calcObj, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_InsertCopy"](arg_calcObj.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "IComponentLinkEmbedControl":
        """Retrieves a link/embed calc object found by the index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppComponent:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppComponent.COM_val)))
            return arg_ppComponent.python_val

    def GetItemByName(self, name:str) -> "IComponentLinkEmbedControl":
        """Retrieves a link/embed calc object found by the name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppComponent:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppComponent.COM_val)))
            return arg_ppComponent.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{4294354A-2EF8-4D34-8FC9-DD360DFCF3EF}", IVACalcObjectLinkEmbedControlCollection)
agcls.AgTypeNameMap["IVACalcObjectLinkEmbedControlCollection"] = IVACalcObjectLinkEmbedControlCollection

class IVAStateCalcHeightAboveTerrain(object):
    """Interface for StateCalcHeightAboveTerrain"""
    _uuid = "{30A4FAC3-1250-456A-BB29-689AA50F8D75}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcHeightAboveTerrain._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcHeightAboveTerrain from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcHeightAboveTerrain = agcom.GUID(IVAStateCalcHeightAboveTerrain._uuid)
        vtable_offset_local = IVAStateCalcHeightAboveTerrain._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcHeightAboveTerrain, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcHeightAboveTerrain, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcHeightAboveTerrain.__dict__ and type(IVAStateCalcHeightAboveTerrain.__dict__[attrname]) == property:
            return IVAStateCalcHeightAboveTerrain.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcHeightAboveTerrain.")
    
    @property
    def CentralBodyName(self) -> str:
        """Central Body used for calculation"""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        """Central Body used for calculation"""
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{30A4FAC3-1250-456A-BB29-689AA50F8D75}", IVAStateCalcHeightAboveTerrain)
agcls.AgTypeNameMap["IVAStateCalcHeightAboveTerrain"] = IVAStateCalcHeightAboveTerrain

class IVAStateCalcEpoch(object):
    """Properties for an Epoch calculation object."""
    _uuid = "{F23ADE47-91EF-41B9-9606-DA034C50F69D}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcEpoch._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcEpoch from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcEpoch = agcom.GUID(IVAStateCalcEpoch._uuid)
        vtable_offset_local = IVAStateCalcEpoch._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcEpoch.__dict__ and type(IVAStateCalcEpoch.__dict__[attrname]) == property:
            return IVAStateCalcEpoch.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcEpoch.")
    

agcls.AgClassCatalog.add_catalog_entry("{F23ADE47-91EF-41B9-9606-DA034C50F69D}", IVAStateCalcEpoch)
agcls.AgTypeNameMap["IVAStateCalcEpoch"] = IVAStateCalcEpoch

class IVAStateCalcOrbitDelaunayG(object):
    """Interface for AsStateCalcOrbitDelaunayG"""
    _uuid = "{8527A30E-E743-4040-8B0D-7AE1EB237279}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetElementType"] = _raise_uninitialized_error
        self.__dict__["_SetElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcOrbitDelaunayG._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcOrbitDelaunayG from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcOrbitDelaunayG = agcom.GUID(IVAStateCalcOrbitDelaunayG._uuid)
        vtable_offset_local = IVAStateCalcOrbitDelaunayG._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitDelaunayG, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitDelaunayG, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitDelaunayG, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitDelaunayG, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcOrbitDelaunayG.__dict__ and type(IVAStateCalcOrbitDelaunayG.__dict__[attrname]) == property:
            return IVAStateCalcOrbitDelaunayG.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcOrbitDelaunayG.")
    
    @property
    def CentralBodyName(self) -> str:
        """Central Body used for calculation"""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        """Central Body used for calculation"""
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def ElementType(self) -> "AgEVAElement":
        """Choice of osculating or mean elements"""
        with agmarshall.AgEnum_arg(AgEVAElement) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElementType.setter
    def ElementType(self, inVal:"AgEVAElement") -> None:
        """Choice of osculating or mean elements"""
        with agmarshall.AgEnum_arg(AgEVAElement, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetElementType"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{8527A30E-E743-4040-8B0D-7AE1EB237279}", IVAStateCalcOrbitDelaunayG)
agcls.AgTypeNameMap["IVAStateCalcOrbitDelaunayG"] = IVAStateCalcOrbitDelaunayG

class IVAStateCalcOrbitDelaunayH(object):
    """Interface for AsStateCalcOrbitDelaunayH"""
    _uuid = "{01E122E4-2B6D-4301-81D2-B83B6C169CB5}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetElementType"] = _raise_uninitialized_error
        self.__dict__["_SetElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcOrbitDelaunayH._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcOrbitDelaunayH from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcOrbitDelaunayH = agcom.GUID(IVAStateCalcOrbitDelaunayH._uuid)
        vtable_offset_local = IVAStateCalcOrbitDelaunayH._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitDelaunayH, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitDelaunayH, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitDelaunayH, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitDelaunayH, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcOrbitDelaunayH.__dict__ and type(IVAStateCalcOrbitDelaunayH.__dict__[attrname]) == property:
            return IVAStateCalcOrbitDelaunayH.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcOrbitDelaunayH.")
    
    @property
    def CentralBodyName(self) -> str:
        """Central Body used for calculation"""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        """Central Body used for calculation"""
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def ElementType(self) -> "AgEVAElement":
        """Choice of osculating or mean elements"""
        with agmarshall.AgEnum_arg(AgEVAElement) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElementType.setter
    def ElementType(self, inVal:"AgEVAElement") -> None:
        """Choice of osculating or mean elements"""
        with agmarshall.AgEnum_arg(AgEVAElement, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetElementType"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{01E122E4-2B6D-4301-81D2-B83B6C169CB5}", IVAStateCalcOrbitDelaunayH)
agcls.AgTypeNameMap["IVAStateCalcOrbitDelaunayH"] = IVAStateCalcOrbitDelaunayH

class IVAStateCalcOrbitDelaunayL(object):
    """Interface for AsStateCalcOrbitDelaunayL"""
    _uuid = "{10C517CA-1CF0-45FF-B36E-3E3181269745}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetElementType"] = _raise_uninitialized_error
        self.__dict__["_SetElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcOrbitDelaunayL._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcOrbitDelaunayL from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcOrbitDelaunayL = agcom.GUID(IVAStateCalcOrbitDelaunayL._uuid)
        vtable_offset_local = IVAStateCalcOrbitDelaunayL._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitDelaunayL, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitDelaunayL, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitDelaunayL, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitDelaunayL, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcOrbitDelaunayL.__dict__ and type(IVAStateCalcOrbitDelaunayL.__dict__[attrname]) == property:
            return IVAStateCalcOrbitDelaunayL.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcOrbitDelaunayL.")
    
    @property
    def CentralBodyName(self) -> str:
        """Central Body used for calculation"""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        """Central Body used for calculation"""
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def ElementType(self) -> "AgEVAElement":
        """Choice of osculating or mean elements"""
        with agmarshall.AgEnum_arg(AgEVAElement) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElementType.setter
    def ElementType(self, inVal:"AgEVAElement") -> None:
        """Choice of osculating or mean elements"""
        with agmarshall.AgEnum_arg(AgEVAElement, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetElementType"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{10C517CA-1CF0-45FF-B36E-3E3181269745}", IVAStateCalcOrbitDelaunayL)
agcls.AgTypeNameMap["IVAStateCalcOrbitDelaunayL"] = IVAStateCalcOrbitDelaunayL

class IVAStateCalcOrbitSemiLatusRectum(object):
    """Interface for AsStateCalcOrbitSemiLatusRectum"""
    _uuid = "{06396376-8F96-419A-86D4-32298E6A6087}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetElementType"] = _raise_uninitialized_error
        self.__dict__["_SetElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcOrbitSemiLatusRectum._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcOrbitSemiLatusRectum from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcOrbitSemiLatusRectum = agcom.GUID(IVAStateCalcOrbitSemiLatusRectum._uuid)
        vtable_offset_local = IVAStateCalcOrbitSemiLatusRectum._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitSemiLatusRectum, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitSemiLatusRectum, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitSemiLatusRectum, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitSemiLatusRectum, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcOrbitSemiLatusRectum.__dict__ and type(IVAStateCalcOrbitSemiLatusRectum.__dict__[attrname]) == property:
            return IVAStateCalcOrbitSemiLatusRectum.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcOrbitSemiLatusRectum.")
    
    @property
    def CentralBodyName(self) -> str:
        """Central Body used for calculation"""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        """Central Body used for calculation"""
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def ElementType(self) -> "AgEVAElement":
        """Choice of osculating or mean elements"""
        with agmarshall.AgEnum_arg(AgEVAElement) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElementType.setter
    def ElementType(self, inVal:"AgEVAElement") -> None:
        """Choice of osculating or mean elements"""
        with agmarshall.AgEnum_arg(AgEVAElement, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetElementType"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{06396376-8F96-419A-86D4-32298E6A6087}", IVAStateCalcOrbitSemiLatusRectum)
agcls.AgTypeNameMap["IVAStateCalcOrbitSemiLatusRectum"] = IVAStateCalcOrbitSemiLatusRectum

class IVAStateCalcJacobiConstant(object):
    """Properties for a Jacobi Constant calculation object."""
    _uuid = "{12857E60-E0BF-49BE-84EA-F9A0C73DB557}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcJacobiConstant._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcJacobiConstant from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcJacobiConstant = agcom.GUID(IVAStateCalcJacobiConstant._uuid)
        vtable_offset_local = IVAStateCalcJacobiConstant._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcJacobiConstant.__dict__ and type(IVAStateCalcJacobiConstant.__dict__[attrname]) == property:
            return IVAStateCalcJacobiConstant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcJacobiConstant.")
    

agcls.AgClassCatalog.add_catalog_entry("{12857E60-E0BF-49BE-84EA-F9A0C73DB557}", IVAStateCalcJacobiConstant)
agcls.AgTypeNameMap["IVAStateCalcJacobiConstant"] = IVAStateCalcJacobiConstant

class IVAStateCalcCartesianElem(object):
    """Properties for a Cartesian Element calculation object."""
    _uuid = "{43611884-2507-4D9B-AFF2-9BC5AA0786BD}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_SetCoordSystemName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcCartesianElem._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcCartesianElem from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcCartesianElem = agcom.GUID(IVAStateCalcCartesianElem._uuid)
        vtable_offset_local = IVAStateCalcCartesianElem._vtable_offset - 1
        self.__dict__["_GetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCartesianElem, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCartesianElem, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcCartesianElem.__dict__ and type(IVAStateCalcCartesianElem.__dict__[attrname]) == property:
            return IVAStateCalcCartesianElem.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcCartesianElem.")
    
    @property
    def CoordSystemName(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordSystemName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordSystemName.setter
    def CoordSystemName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordSystemName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{43611884-2507-4D9B-AFF2-9BC5AA0786BD}", IVAStateCalcCartesianElem)
agcls.AgTypeNameMap["IVAStateCalcCartesianElem"] = IVAStateCalcCartesianElem

class IVAStateCalcCartSTMElem(object):
    """Properties for a Cartesian STM Element calculation object."""
    _uuid = "{72B246C3-618A-40B7-8501-C39BF07E4B95}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_SetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_GetFinalVar"] = _raise_uninitialized_error
        self.__dict__["_SetFinalVar"] = _raise_uninitialized_error
        self.__dict__["_GetInitVar"] = _raise_uninitialized_error
        self.__dict__["_SetInitVar"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcCartSTMElem._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcCartSTMElem from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcCartSTMElem = agcom.GUID(IVAStateCalcCartSTMElem._uuid)
        vtable_offset_local = IVAStateCalcCartSTMElem._vtable_offset - 1
        self.__dict__["_GetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCartSTMElem, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCartSTMElem, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetFinalVar"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCartSTMElem, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetFinalVar"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCartSTMElem, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetInitVar"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCartSTMElem, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetInitVar"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCartSTMElem, vtable_offset_local+6, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcCartSTMElem.__dict__ and type(IVAStateCalcCartSTMElem.__dict__[attrname]) == property:
            return IVAStateCalcCartSTMElem.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcCartSTMElem.")
    
    @property
    def CoordSystemName(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordSystemName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordSystemName.setter
    def CoordSystemName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordSystemName"](arg_inVal.COM_val))

    @property
    def FinalVar(self) -> "AgEVASTMPertVariables":
        """The final variation variable."""
        with agmarshall.AgEnum_arg(AgEVASTMPertVariables) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetFinalVar"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @FinalVar.setter
    def FinalVar(self, inVal:"AgEVASTMPertVariables") -> None:
        with agmarshall.AgEnum_arg(AgEVASTMPertVariables, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetFinalVar"](arg_inVal.COM_val))

    @property
    def InitVar(self) -> "AgEVASTMPertVariables":
        """The initial variation variable."""
        with agmarshall.AgEnum_arg(AgEVASTMPertVariables) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetInitVar"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @InitVar.setter
    def InitVar(self, inVal:"AgEVASTMPertVariables") -> None:
        with agmarshall.AgEnum_arg(AgEVASTMPertVariables, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetInitVar"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{72B246C3-618A-40B7-8501-C39BF07E4B95}", IVAStateCalcCartSTMElem)
agcls.AgTypeNameMap["IVAStateCalcCartSTMElem"] = IVAStateCalcCartSTMElem

class IVAStateCalcSTMEigenval(object):
    """Properties for an STM Eigenvalue calculation object."""
    _uuid = "{24838E22-D7CE-40FF-8268-9E72AE39467B}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_SetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_GetEigenvalueNumber"] = _raise_uninitialized_error
        self.__dict__["_SetEigenvalueNumber"] = _raise_uninitialized_error
        self.__dict__["_GetEigenvalueComplexPart"] = _raise_uninitialized_error
        self.__dict__["_SetEigenvalueComplexPart"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcSTMEigenval._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcSTMEigenval from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcSTMEigenval = agcom.GUID(IVAStateCalcSTMEigenval._uuid)
        vtable_offset_local = IVAStateCalcSTMEigenval._vtable_offset - 1
        self.__dict__["_GetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSTMEigenval, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSTMEigenval, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetEigenvalueNumber"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSTMEigenval, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetEigenvalueNumber"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSTMEigenval, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetEigenvalueComplexPart"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSTMEigenval, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetEigenvalueComplexPart"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSTMEigenval, vtable_offset_local+6, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcSTMEigenval.__dict__ and type(IVAStateCalcSTMEigenval.__dict__[attrname]) == property:
            return IVAStateCalcSTMEigenval.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcSTMEigenval.")
    
    @property
    def CoordSystemName(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordSystemName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordSystemName.setter
    def CoordSystemName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordSystemName"](arg_inVal.COM_val))

    @property
    def EigenvalueNumber(self) -> "AgEVASTMEigenNumber":
        """The number identifying one of the six Eigenvalues."""
        with agmarshall.AgEnum_arg(AgEVASTMEigenNumber) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEigenvalueNumber"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EigenvalueNumber.setter
    def EigenvalueNumber(self, inVal:"AgEVASTMEigenNumber") -> None:
        with agmarshall.AgEnum_arg(AgEVASTMEigenNumber, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetEigenvalueNumber"](arg_inVal.COM_val))

    @property
    def EigenvalueComplexPart(self) -> "AgEVAComplexNumber":
        """Whether this value represents the real or imaginary part of the Eigenvalue."""
        with agmarshall.AgEnum_arg(AgEVAComplexNumber) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEigenvalueComplexPart"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EigenvalueComplexPart.setter
    def EigenvalueComplexPart(self, inVal:"AgEVAComplexNumber") -> None:
        with agmarshall.AgEnum_arg(AgEVAComplexNumber, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetEigenvalueComplexPart"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{24838E22-D7CE-40FF-8268-9E72AE39467B}", IVAStateCalcSTMEigenval)
agcls.AgTypeNameMap["IVAStateCalcSTMEigenval"] = IVAStateCalcSTMEigenval

class IVAStateCalcSTMEigenvecElem(object):
    """Properties for an STM Eigenvector element calculation object."""
    _uuid = "{7D28974A-19AF-4E80-889E-5CDA7E9DACEB}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_SetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_GetEigenvectorNumber"] = _raise_uninitialized_error
        self.__dict__["_SetEigenvectorNumber"] = _raise_uninitialized_error
        self.__dict__["_GetStateVariable"] = _raise_uninitialized_error
        self.__dict__["_SetStateVariable"] = _raise_uninitialized_error
        self.__dict__["_GetEigenvectorComplexPart"] = _raise_uninitialized_error
        self.__dict__["_SetEigenvectorComplexPart"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcSTMEigenvecElem._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcSTMEigenvecElem from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcSTMEigenvecElem = agcom.GUID(IVAStateCalcSTMEigenvecElem._uuid)
        vtable_offset_local = IVAStateCalcSTMEigenvecElem._vtable_offset - 1
        self.__dict__["_GetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSTMEigenvecElem, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSTMEigenvecElem, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetEigenvectorNumber"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSTMEigenvecElem, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetEigenvectorNumber"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSTMEigenvecElem, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetStateVariable"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSTMEigenvecElem, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetStateVariable"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSTMEigenvecElem, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetEigenvectorComplexPart"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSTMEigenvecElem, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetEigenvectorComplexPart"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSTMEigenvecElem, vtable_offset_local+8, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcSTMEigenvecElem.__dict__ and type(IVAStateCalcSTMEigenvecElem.__dict__[attrname]) == property:
            return IVAStateCalcSTMEigenvecElem.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcSTMEigenvecElem.")
    
    @property
    def CoordSystemName(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordSystemName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordSystemName.setter
    def CoordSystemName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordSystemName"](arg_inVal.COM_val))

    @property
    def EigenvectorNumber(self) -> "AgEVASTMEigenNumber":
        """The number identifying one of the six Eigenvectors."""
        with agmarshall.AgEnum_arg(AgEVASTMEigenNumber) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEigenvectorNumber"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EigenvectorNumber.setter
    def EigenvectorNumber(self, inVal:"AgEVASTMEigenNumber") -> None:
        with agmarshall.AgEnum_arg(AgEVASTMEigenNumber, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetEigenvectorNumber"](arg_inVal.COM_val))

    @property
    def StateVariable(self) -> "AgEVASTMPertVariables":
        """The variable identifying the component within an Eigenvector."""
        with agmarshall.AgEnum_arg(AgEVASTMPertVariables) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetStateVariable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @StateVariable.setter
    def StateVariable(self, inVal:"AgEVASTMPertVariables") -> None:
        with agmarshall.AgEnum_arg(AgEVASTMPertVariables, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetStateVariable"](arg_inVal.COM_val))

    @property
    def EigenvectorComplexPart(self) -> "AgEVAComplexNumber":
        """Whether this value represents the real or imaginary part of an Eigenvector element."""
        with agmarshall.AgEnum_arg(AgEVAComplexNumber) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEigenvectorComplexPart"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EigenvectorComplexPart.setter
    def EigenvectorComplexPart(self, inVal:"AgEVAComplexNumber") -> None:
        with agmarshall.AgEnum_arg(AgEVAComplexNumber, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetEigenvectorComplexPart"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7D28974A-19AF-4E80-889E-5CDA7E9DACEB}", IVAStateCalcSTMEigenvecElem)
agcls.AgTypeNameMap["IVAStateCalcSTMEigenvecElem"] = IVAStateCalcSTMEigenvecElem

class IVAStateCalcEnvironment(object):
    """Properties for an Environment calculation object."""
    _uuid = "{BB89B6D8-34A3-42F2-B7B3-CFDAAA9BE00C}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosModelName"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosModelName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcEnvironment._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcEnvironment from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcEnvironment = agcom.GUID(IVAStateCalcEnvironment._uuid)
        vtable_offset_local = IVAStateCalcEnvironment._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcEnvironment, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcEnvironment, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetAtmosModelName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcEnvironment, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetAtmosModelName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcEnvironment, vtable_offset_local+4, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcEnvironment.__dict__ and type(IVAStateCalcEnvironment.__dict__[attrname]) == property:
            return IVAStateCalcEnvironment.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcEnvironment.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def AtmosModelName(self) -> str:
        """The atmospheric density model of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosModelName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosModelName.setter
    def AtmosModelName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosModelName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{BB89B6D8-34A3-42F2-B7B3-CFDAAA9BE00C}", IVAStateCalcEnvironment)
agcls.AgTypeNameMap["IVAStateCalcEnvironment"] = IVAStateCalcEnvironment

class IVAStateCalcEquinoctialElem(object):
    """Properties for an Equinoctial Element calculation object."""
    _uuid = "{A63BA51C-CE64-410D-832F-7BDCE13E5069}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_SetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_GetElementType"] = _raise_uninitialized_error
        self.__dict__["_SetElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcEquinoctialElem._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcEquinoctialElem from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcEquinoctialElem = agcom.GUID(IVAStateCalcEquinoctialElem._uuid)
        vtable_offset_local = IVAStateCalcEquinoctialElem._vtable_offset - 1
        self.__dict__["_GetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcEquinoctialElem, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcEquinoctialElem, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcEquinoctialElem, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcEquinoctialElem, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcEquinoctialElem.__dict__ and type(IVAStateCalcEquinoctialElem.__dict__[attrname]) == property:
            return IVAStateCalcEquinoctialElem.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcEquinoctialElem.")
    
    @property
    def CoordSystemName(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordSystemName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordSystemName.setter
    def CoordSystemName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordSystemName"](arg_inVal.COM_val))

    @property
    def ElementType(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElementType.setter
    def ElementType(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetElementType"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{A63BA51C-CE64-410D-832F-7BDCE13E5069}", IVAStateCalcEquinoctialElem)
agcls.AgTypeNameMap["IVAStateCalcEquinoctialElem"] = IVAStateCalcEquinoctialElem

class IVAStateCalcDamageFlux(object):
    """Interface for AgAsStateCalcDamageFlux"""
    _uuid = "{5E7EBA7C-121F-4649-8599-A222F65BA10B}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcDamageFlux._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcDamageFlux from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcDamageFlux = agcom.GUID(IVAStateCalcDamageFlux._uuid)
        vtable_offset_local = IVAStateCalcDamageFlux._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcDamageFlux.__dict__ and type(IVAStateCalcDamageFlux.__dict__[attrname]) == property:
            return IVAStateCalcDamageFlux.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcDamageFlux.")
    

agcls.AgClassCatalog.add_catalog_entry("{5E7EBA7C-121F-4649-8599-A222F65BA10B}", IVAStateCalcDamageFlux)
agcls.AgTypeNameMap["IVAStateCalcDamageFlux"] = IVAStateCalcDamageFlux

class IVAStateCalcDamageMassFlux(object):
    """Interface for AgAsStateCalcDamageMassFlux"""
    _uuid = "{CDA309A6-91BD-49DF-BE71-E3F194AB73AE}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcDamageMassFlux._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcDamageMassFlux from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcDamageMassFlux = agcom.GUID(IVAStateCalcDamageMassFlux._uuid)
        vtable_offset_local = IVAStateCalcDamageMassFlux._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcDamageMassFlux.__dict__ and type(IVAStateCalcDamageMassFlux.__dict__[attrname]) == property:
            return IVAStateCalcDamageMassFlux.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcDamageMassFlux.")
    

agcls.AgClassCatalog.add_catalog_entry("{CDA309A6-91BD-49DF-BE71-E3F194AB73AE}", IVAStateCalcDamageMassFlux)
agcls.AgTypeNameMap["IVAStateCalcDamageMassFlux"] = IVAStateCalcDamageMassFlux

class IVAStateCalcMagFieldDipoleL(object):
    """Interface for AgAsStateCalcMagFieldDipoleL"""
    _uuid = "{46E20C5A-4030-4D57-AAA7-38CFFD65D91D}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcMagFieldDipoleL._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcMagFieldDipoleL from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcMagFieldDipoleL = agcom.GUID(IVAStateCalcMagFieldDipoleL._uuid)
        vtable_offset_local = IVAStateCalcMagFieldDipoleL._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcMagFieldDipoleL.__dict__ and type(IVAStateCalcMagFieldDipoleL.__dict__[attrname]) == property:
            return IVAStateCalcMagFieldDipoleL.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcMagFieldDipoleL.")
    

agcls.AgClassCatalog.add_catalog_entry("{46E20C5A-4030-4D57-AAA7-38CFFD65D91D}", IVAStateCalcMagFieldDipoleL)
agcls.AgTypeNameMap["IVAStateCalcMagFieldDipoleL"] = IVAStateCalcMagFieldDipoleL

class IVAStateCalcSEETMagFieldFieldLineSepAngle(object):
    """Properties for a SEETMagFieldFieldLineSepAngle calculation object."""
    _uuid = "{FFCDD5EA-7808-4A0C-BDA5-5E4BC504F968}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTargetObject"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcSEETMagFieldFieldLineSepAngle._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcSEETMagFieldFieldLineSepAngle from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcSEETMagFieldFieldLineSepAngle = agcom.GUID(IVAStateCalcSEETMagFieldFieldLineSepAngle._uuid)
        vtable_offset_local = IVAStateCalcSEETMagFieldFieldLineSepAngle._vtable_offset - 1
        self.__dict__["_GetTargetObject"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSEETMagFieldFieldLineSepAngle, vtable_offset_local+1, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcSEETMagFieldFieldLineSepAngle.__dict__ and type(IVAStateCalcSEETMagFieldFieldLineSepAngle.__dict__[attrname]) == property:
            return IVAStateCalcSEETMagFieldFieldLineSepAngle.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcSEETMagFieldFieldLineSepAngle.")
    
    @property
    def TargetObject(self) -> "ILinkToObject":
        """The reference object."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_GetTargetObject"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val


agcls.AgClassCatalog.add_catalog_entry("{FFCDD5EA-7808-4A0C-BDA5-5E4BC504F968}", IVAStateCalcSEETMagFieldFieldLineSepAngle)
agcls.AgTypeNameMap["IVAStateCalcSEETMagFieldFieldLineSepAngle"] = IVAStateCalcSEETMagFieldFieldLineSepAngle

class IVAStateCalcImpactFlux(object):
    """Interface for AgAsStateCalcImpactFlux"""
    _uuid = "{70F6FCD6-139C-4166-B242-61652F690A89}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcImpactFlux._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcImpactFlux from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcImpactFlux = agcom.GUID(IVAStateCalcImpactFlux._uuid)
        vtable_offset_local = IVAStateCalcImpactFlux._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcImpactFlux.__dict__ and type(IVAStateCalcImpactFlux.__dict__[attrname]) == property:
            return IVAStateCalcImpactFlux.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcImpactFlux.")
    

agcls.AgClassCatalog.add_catalog_entry("{70F6FCD6-139C-4166-B242-61652F690A89}", IVAStateCalcImpactFlux)
agcls.AgTypeNameMap["IVAStateCalcImpactFlux"] = IVAStateCalcImpactFlux

class IVAStateCalcImpactMassFlux(object):
    """Interface for AgAsStateCalcImpactMassFlux"""
    _uuid = "{67D77299-1936-4E9A-A44F-C155686E4DB2}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcImpactMassFlux._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcImpactMassFlux from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcImpactMassFlux = agcom.GUID(IVAStateCalcImpactMassFlux._uuid)
        vtable_offset_local = IVAStateCalcImpactMassFlux._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcImpactMassFlux.__dict__ and type(IVAStateCalcImpactMassFlux.__dict__[attrname]) == property:
            return IVAStateCalcImpactMassFlux.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcImpactMassFlux.")
    

agcls.AgClassCatalog.add_catalog_entry("{67D77299-1936-4E9A-A44F-C155686E4DB2}", IVAStateCalcImpactMassFlux)
agcls.AgTypeNameMap["IVAStateCalcImpactMassFlux"] = IVAStateCalcImpactMassFlux

class IVAStateCalcSEETSAAFlux(object):
    """Interface for AgAsStateCalcSEETSAAFlux"""
    _uuid = "{3C633703-2759-4894-96EA-F6E3C2F98AA1}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcSEETSAAFlux._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcSEETSAAFlux from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcSEETSAAFlux = agcom.GUID(IVAStateCalcSEETSAAFlux._uuid)
        vtable_offset_local = IVAStateCalcSEETSAAFlux._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcSEETSAAFlux.__dict__ and type(IVAStateCalcSEETSAAFlux.__dict__[attrname]) == property:
            return IVAStateCalcSEETSAAFlux.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcSEETSAAFlux.")
    

agcls.AgClassCatalog.add_catalog_entry("{3C633703-2759-4894-96EA-F6E3C2F98AA1}", IVAStateCalcSEETSAAFlux)
agcls.AgTypeNameMap["IVAStateCalcSEETSAAFlux"] = IVAStateCalcSEETSAAFlux

class IVAStateCalcSEETVehTemp(object):
    """Interface for AgAsStateCalcSEETVehTemp"""
    _uuid = "{4B70C4FB-3403-4F3F-9F3F-B2C0CF8DB393}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcSEETVehTemp._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcSEETVehTemp from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcSEETVehTemp = agcom.GUID(IVAStateCalcSEETVehTemp._uuid)
        vtable_offset_local = IVAStateCalcSEETVehTemp._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcSEETVehTemp.__dict__ and type(IVAStateCalcSEETVehTemp.__dict__[attrname]) == property:
            return IVAStateCalcSEETVehTemp.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcSEETVehTemp.")
    

agcls.AgClassCatalog.add_catalog_entry("{4B70C4FB-3403-4F3F-9F3F-B2C0CF8DB393}", IVAStateCalcSEETVehTemp)
agcls.AgTypeNameMap["IVAStateCalcSEETVehTemp"] = IVAStateCalcSEETVehTemp

class IVAStateCalcCloseApproachBearing(object):
    """Properties for a CloseApproachBearing calculation object."""
    _uuid = "{E7717197-6955-4ECB-BF98-DA50AD7547F3}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSelection"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSelection"] = _raise_uninitialized_error
        self.__dict__["_GetReference"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcCloseApproachBearing._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcCloseApproachBearing from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcCloseApproachBearing = agcom.GUID(IVAStateCalcCloseApproachBearing._uuid)
        vtable_offset_local = IVAStateCalcCloseApproachBearing._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCloseApproachBearing, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCloseApproachBearing, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetReferenceSelection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCloseApproachBearing, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetReferenceSelection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCloseApproachBearing, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetReference"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCloseApproachBearing, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcCloseApproachBearing.__dict__ and type(IVAStateCalcCloseApproachBearing.__dict__[attrname]) == property:
            return IVAStateCalcCloseApproachBearing.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcCloseApproachBearing.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def ReferenceSelection(self) -> "AgEVACalcObjectReference":
        """The reference object selection."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSelection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ReferenceSelection.setter
    def ReferenceSelection(self, inVal:"AgEVACalcObjectReference") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSelection"](arg_inVal.COM_val))

    @property
    def Reference(self) -> "ILinkToObject":
        """The reference object."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_GetReference"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val


agcls.AgClassCatalog.add_catalog_entry("{E7717197-6955-4ECB-BF98-DA50AD7547F3}", IVAStateCalcCloseApproachBearing)
agcls.AgTypeNameMap["IVAStateCalcCloseApproachBearing"] = IVAStateCalcCloseApproachBearing

class IVAStateCalcCloseApproachMag(object):
    """Properties for a CloseApproachMagnitude calculation object."""
    _uuid = "{DDACF6D7-29C0-46BB-A21A-123580E25161}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSelection"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSelection"] = _raise_uninitialized_error
        self.__dict__["_GetReference"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcCloseApproachMag._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcCloseApproachMag from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcCloseApproachMag = agcom.GUID(IVAStateCalcCloseApproachMag._uuid)
        vtable_offset_local = IVAStateCalcCloseApproachMag._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCloseApproachMag, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCloseApproachMag, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetReferenceSelection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCloseApproachMag, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetReferenceSelection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCloseApproachMag, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetReference"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCloseApproachMag, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcCloseApproachMag.__dict__ and type(IVAStateCalcCloseApproachMag.__dict__[attrname]) == property:
            return IVAStateCalcCloseApproachMag.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcCloseApproachMag.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def ReferenceSelection(self) -> "AgEVACalcObjectReference":
        """The reference object selection."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSelection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ReferenceSelection.setter
    def ReferenceSelection(self, inVal:"AgEVACalcObjectReference") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSelection"](arg_inVal.COM_val))

    @property
    def Reference(self) -> "ILinkToObject":
        """The reference object."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_GetReference"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val


agcls.AgClassCatalog.add_catalog_entry("{DDACF6D7-29C0-46BB-A21A-123580E25161}", IVAStateCalcCloseApproachMag)
agcls.AgTypeNameMap["IVAStateCalcCloseApproachMag"] = IVAStateCalcCloseApproachMag

class IVAStateCalcCloseApproachTheta(object):
    """Properties for a CloseApproachTheta calculation object."""
    _uuid = "{2F89E7F5-154B-4CED-807A-040A064F1A14}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSelection"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSelection"] = _raise_uninitialized_error
        self.__dict__["_GetReference"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcCloseApproachTheta._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcCloseApproachTheta from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcCloseApproachTheta = agcom.GUID(IVAStateCalcCloseApproachTheta._uuid)
        vtable_offset_local = IVAStateCalcCloseApproachTheta._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCloseApproachTheta, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCloseApproachTheta, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetReferenceSelection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCloseApproachTheta, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetReferenceSelection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCloseApproachTheta, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetReference"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCloseApproachTheta, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcCloseApproachTheta.__dict__ and type(IVAStateCalcCloseApproachTheta.__dict__[attrname]) == property:
            return IVAStateCalcCloseApproachTheta.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcCloseApproachTheta.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def ReferenceSelection(self) -> "AgEVACalcObjectReference":
        """The reference object selection."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSelection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ReferenceSelection.setter
    def ReferenceSelection(self, inVal:"AgEVACalcObjectReference") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSelection"](arg_inVal.COM_val))

    @property
    def Reference(self) -> "ILinkToObject":
        """The reference object."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_GetReference"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val


agcls.AgClassCatalog.add_catalog_entry("{2F89E7F5-154B-4CED-807A-040A064F1A14}", IVAStateCalcCloseApproachTheta)
agcls.AgTypeNameMap["IVAStateCalcCloseApproachTheta"] = IVAStateCalcCloseApproachTheta

class IVAStateCalcCloseApproachX(object):
    """Properties for a CloseApproachX calculation object."""
    _uuid = "{B57EFFE4-9742-4F26-989C-A8D64549F8ED}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSelection"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSelection"] = _raise_uninitialized_error
        self.__dict__["_GetReference"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcCloseApproachX._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcCloseApproachX from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcCloseApproachX = agcom.GUID(IVAStateCalcCloseApproachX._uuid)
        vtable_offset_local = IVAStateCalcCloseApproachX._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCloseApproachX, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCloseApproachX, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetReferenceSelection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCloseApproachX, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetReferenceSelection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCloseApproachX, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetReference"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCloseApproachX, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcCloseApproachX.__dict__ and type(IVAStateCalcCloseApproachX.__dict__[attrname]) == property:
            return IVAStateCalcCloseApproachX.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcCloseApproachX.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def ReferenceSelection(self) -> "AgEVACalcObjectReference":
        """The reference object selection."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSelection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ReferenceSelection.setter
    def ReferenceSelection(self, inVal:"AgEVACalcObjectReference") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSelection"](arg_inVal.COM_val))

    @property
    def Reference(self) -> "ILinkToObject":
        """The reference object."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_GetReference"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val


agcls.AgClassCatalog.add_catalog_entry("{B57EFFE4-9742-4F26-989C-A8D64549F8ED}", IVAStateCalcCloseApproachX)
agcls.AgTypeNameMap["IVAStateCalcCloseApproachX"] = IVAStateCalcCloseApproachX

class IVAStateCalcCloseApproachY(object):
    """Properties for a CloseApproachY calculation object."""
    _uuid = "{7C03BAD0-6CF8-4A20-ABA9-B16006A4016E}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSelection"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSelection"] = _raise_uninitialized_error
        self.__dict__["_GetReference"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcCloseApproachY._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcCloseApproachY from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcCloseApproachY = agcom.GUID(IVAStateCalcCloseApproachY._uuid)
        vtable_offset_local = IVAStateCalcCloseApproachY._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCloseApproachY, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCloseApproachY, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetReferenceSelection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCloseApproachY, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetReferenceSelection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCloseApproachY, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetReference"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCloseApproachY, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcCloseApproachY.__dict__ and type(IVAStateCalcCloseApproachY.__dict__[attrname]) == property:
            return IVAStateCalcCloseApproachY.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcCloseApproachY.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def ReferenceSelection(self) -> "AgEVACalcObjectReference":
        """The reference object selection."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSelection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ReferenceSelection.setter
    def ReferenceSelection(self, inVal:"AgEVACalcObjectReference") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSelection"](arg_inVal.COM_val))

    @property
    def Reference(self) -> "ILinkToObject":
        """The reference object."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_GetReference"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val


agcls.AgClassCatalog.add_catalog_entry("{7C03BAD0-6CF8-4A20-ABA9-B16006A4016E}", IVAStateCalcCloseApproachY)
agcls.AgTypeNameMap["IVAStateCalcCloseApproachY"] = IVAStateCalcCloseApproachY

class IVAStateCalcCloseApproachCosBearing(object):
    """Properties for a CosineOfCloseApproachBearing calculation object."""
    _uuid = "{ED9F8425-E6C7-49D0-842F-84FE096E6C27}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSelection"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSelection"] = _raise_uninitialized_error
        self.__dict__["_GetReference"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcCloseApproachCosBearing._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcCloseApproachCosBearing from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcCloseApproachCosBearing = agcom.GUID(IVAStateCalcCloseApproachCosBearing._uuid)
        vtable_offset_local = IVAStateCalcCloseApproachCosBearing._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCloseApproachCosBearing, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCloseApproachCosBearing, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetReferenceSelection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCloseApproachCosBearing, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetReferenceSelection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCloseApproachCosBearing, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetReference"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCloseApproachCosBearing, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcCloseApproachCosBearing.__dict__ and type(IVAStateCalcCloseApproachCosBearing.__dict__[attrname]) == property:
            return IVAStateCalcCloseApproachCosBearing.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcCloseApproachCosBearing.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def ReferenceSelection(self) -> "AgEVACalcObjectReference":
        """The reference object selection."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSelection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ReferenceSelection.setter
    def ReferenceSelection(self, inVal:"AgEVACalcObjectReference") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSelection"](arg_inVal.COM_val))

    @property
    def Reference(self) -> "ILinkToObject":
        """The reference object."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_GetReference"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val


agcls.AgClassCatalog.add_catalog_entry("{ED9F8425-E6C7-49D0-842F-84FE096E6C27}", IVAStateCalcCloseApproachCosBearing)
agcls.AgTypeNameMap["IVAStateCalcCloseApproachCosBearing"] = IVAStateCalcCloseApproachCosBearing

class IVAStateCalcRelGroundTrackError(object):
    """Properties for a RelGroundTrackError calculation object."""
    _uuid = "{F9BD881C-FBBF-4B59-AA64-8D303DBBCC44}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetDirection"] = _raise_uninitialized_error
        self.__dict__["_SetDirection"] = _raise_uninitialized_error
        self.__dict__["_GetSigned"] = _raise_uninitialized_error
        self.__dict__["_SetSigned"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSelection"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSelection"] = _raise_uninitialized_error
        self.__dict__["_GetReference"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcRelGroundTrackError._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcRelGroundTrackError from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcRelGroundTrackError = agcom.GUID(IVAStateCalcRelGroundTrackError._uuid)
        vtable_offset_local = IVAStateCalcRelGroundTrackError._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelGroundTrackError, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelGroundTrackError, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetDirection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelGroundTrackError, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetDirection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelGroundTrackError, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetSigned"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelGroundTrackError, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetSigned"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelGroundTrackError, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetReferenceSelection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelGroundTrackError, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetReferenceSelection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelGroundTrackError, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetReference"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelGroundTrackError, vtable_offset_local+9, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcRelGroundTrackError.__dict__ and type(IVAStateCalcRelGroundTrackError.__dict__[attrname]) == property:
            return IVAStateCalcRelGroundTrackError.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcRelGroundTrackError.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def Direction(self) -> "AgEVACalcObjectDirection":
        """The direction to search for the desired value."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectDirection) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDirection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Direction.setter
    def Direction(self, inVal:"AgEVACalcObjectDirection") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectDirection, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDirection"](arg_inVal.COM_val))

    @property
    def Signed(self) -> bool:
        """True if signed based on RxV."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSigned"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Signed.setter
    def Signed(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSigned"](arg_inVal.COM_val))

    @property
    def ReferenceSelection(self) -> "AgEVACalcObjectReference":
        """The reference object selection."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSelection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ReferenceSelection.setter
    def ReferenceSelection(self, inVal:"AgEVACalcObjectReference") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSelection"](arg_inVal.COM_val))

    @property
    def Reference(self) -> "ILinkToObject":
        """The reference object."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_GetReference"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val


agcls.AgClassCatalog.add_catalog_entry("{F9BD881C-FBBF-4B59-AA64-8D303DBBCC44}", IVAStateCalcRelGroundTrackError)
agcls.AgTypeNameMap["IVAStateCalcRelGroundTrackError"] = IVAStateCalcRelGroundTrackError

class IVAStateCalcRelAtAOLMaster(object):
    """Properties for a RelativeAtAOL calculation object."""
    _uuid = "{8864FF20-53E7-4609-86A7-C9F7B113B651}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetCalcObjectName"] = _raise_uninitialized_error
        self.__dict__["_SetCalcObjectName"] = _raise_uninitialized_error
        self.__dict__["_GetDirection"] = _raise_uninitialized_error
        self.__dict__["_SetDirection"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSelection"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSelection"] = _raise_uninitialized_error
        self.__dict__["_GetReference"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcRelAtAOLMaster._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcRelAtAOLMaster from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcRelAtAOLMaster = agcom.GUID(IVAStateCalcRelAtAOLMaster._uuid)
        vtable_offset_local = IVAStateCalcRelAtAOLMaster._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelAtAOLMaster, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelAtAOLMaster, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetCalcObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelAtAOLMaster, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetCalcObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelAtAOLMaster, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_GetDirection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelAtAOLMaster, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetDirection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelAtAOLMaster, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetReferenceSelection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelAtAOLMaster, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetReferenceSelection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelAtAOLMaster, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetReference"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelAtAOLMaster, vtable_offset_local+9, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcRelAtAOLMaster.__dict__ and type(IVAStateCalcRelAtAOLMaster.__dict__[attrname]) == property:
            return IVAStateCalcRelAtAOLMaster.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcRelAtAOLMaster.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def CalcObjectName(self) -> str:
        """The calculation object of interest."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCalcObjectName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CalcObjectName.setter
    def CalcObjectName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCalcObjectName"](arg_inVal.COM_val))

    @property
    def Direction(self) -> "AgEVACalcObjectDirection":
        """The direction to search for the desired value."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectDirection) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDirection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Direction.setter
    def Direction(self, inVal:"AgEVACalcObjectDirection") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectDirection, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDirection"](arg_inVal.COM_val))

    @property
    def ReferenceSelection(self) -> "AgEVACalcObjectReference":
        """The reference object selection."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSelection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ReferenceSelection.setter
    def ReferenceSelection(self, inVal:"AgEVACalcObjectReference") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSelection"](arg_inVal.COM_val))

    @property
    def Reference(self) -> "ILinkToObject":
        """The reference object."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_GetReference"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val


agcls.AgClassCatalog.add_catalog_entry("{8864FF20-53E7-4609-86A7-C9F7B113B651}", IVAStateCalcRelAtAOLMaster)
agcls.AgTypeNameMap["IVAStateCalcRelAtAOLMaster"] = IVAStateCalcRelAtAOLMaster

class IVAStateCalcDeltaFromMaster(object):
    """Properties for a Rel Mean Mean Anomaly calculation object."""
    _uuid = "{6203B45E-E2E8-42D1-BB22-9BBF57CC1FDE}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCalcObjectName"] = _raise_uninitialized_error
        self.__dict__["_SetCalcObjectName"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSelection"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSelection"] = _raise_uninitialized_error
        self.__dict__["_GetReference"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcDeltaFromMaster._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcDeltaFromMaster from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcDeltaFromMaster = agcom.GUID(IVAStateCalcDeltaFromMaster._uuid)
        vtable_offset_local = IVAStateCalcDeltaFromMaster._vtable_offset - 1
        self.__dict__["_GetCalcObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDeltaFromMaster, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCalcObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDeltaFromMaster, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetReferenceSelection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDeltaFromMaster, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetReferenceSelection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDeltaFromMaster, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetReference"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDeltaFromMaster, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcDeltaFromMaster.__dict__ and type(IVAStateCalcDeltaFromMaster.__dict__[attrname]) == property:
            return IVAStateCalcDeltaFromMaster.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcDeltaFromMaster.")
    
    @property
    def CalcObjectName(self) -> str:
        """The calculation object of interest."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCalcObjectName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CalcObjectName.setter
    def CalcObjectName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCalcObjectName"](arg_inVal.COM_val))

    @property
    def ReferenceSelection(self) -> "AgEVACalcObjectReference":
        """The reference object selection."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSelection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ReferenceSelection.setter
    def ReferenceSelection(self, inVal:"AgEVACalcObjectReference") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSelection"](arg_inVal.COM_val))

    @property
    def Reference(self) -> "ILinkToObject":
        """The reference object."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_GetReference"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val


agcls.AgClassCatalog.add_catalog_entry("{6203B45E-E2E8-42D1-BB22-9BBF57CC1FDE}", IVAStateCalcDeltaFromMaster)
agcls.AgTypeNameMap["IVAStateCalcDeltaFromMaster"] = IVAStateCalcDeltaFromMaster

class IVAStateCalcLonDriftRate(object):
    """Properties for a Longitude Drift Rate calculation object."""
    _uuid = "{D464DED3-3358-452D-B55C-2B017D04C8F9}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetElementType"] = _raise_uninitialized_error
        self.__dict__["_SetElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcLonDriftRate._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcLonDriftRate from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcLonDriftRate = agcom.GUID(IVAStateCalcLonDriftRate._uuid)
        vtable_offset_local = IVAStateCalcLonDriftRate._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcLonDriftRate, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcLonDriftRate, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcLonDriftRate, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcLonDriftRate, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcLonDriftRate.__dict__ and type(IVAStateCalcLonDriftRate.__dict__[attrname]) == property:
            return IVAStateCalcLonDriftRate.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcLonDriftRate.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def ElementType(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElementType.setter
    def ElementType(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetElementType"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{D464DED3-3358-452D-B55C-2B017D04C8F9}", IVAStateCalcLonDriftRate)
agcls.AgTypeNameMap["IVAStateCalcLonDriftRate"] = IVAStateCalcLonDriftRate

class IVAStateCalcMeanEarthLon(object):
    """Properties for a Mean Earth Longitude calculation object."""
    _uuid = "{49D6969B-42BD-4E55-9016-0F951FF34DEE}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcMeanEarthLon._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcMeanEarthLon from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcMeanEarthLon = agcom.GUID(IVAStateCalcMeanEarthLon._uuid)
        vtable_offset_local = IVAStateCalcMeanEarthLon._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcMeanEarthLon, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcMeanEarthLon, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcMeanEarthLon.__dict__ and type(IVAStateCalcMeanEarthLon.__dict__[attrname]) == property:
            return IVAStateCalcMeanEarthLon.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcMeanEarthLon.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{49D6969B-42BD-4E55-9016-0F951FF34DEE}", IVAStateCalcMeanEarthLon)
agcls.AgTypeNameMap["IVAStateCalcMeanEarthLon"] = IVAStateCalcMeanEarthLon

class IVAStateCalcRectifiedLon(object):
    """Properties for a RectifiedLon calculation object."""
    _uuid = "{FD75BCCA-8F5C-49BA-AADE-040E1186385D}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcRectifiedLon._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcRectifiedLon from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcRectifiedLon = agcom.GUID(IVAStateCalcRectifiedLon._uuid)
        vtable_offset_local = IVAStateCalcRectifiedLon._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRectifiedLon, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRectifiedLon, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcRectifiedLon.__dict__ and type(IVAStateCalcRectifiedLon.__dict__[attrname]) == property:
            return IVAStateCalcRectifiedLon.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcRectifiedLon.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{FD75BCCA-8F5C-49BA-AADE-040E1186385D}", IVAStateCalcRectifiedLon)
agcls.AgTypeNameMap["IVAStateCalcRectifiedLon"] = IVAStateCalcRectifiedLon

class IVAStateCalcGeodeticElem(object):
    """Properties for a Geodetic Element calculation object."""
    _uuid = "{D827128C-F7C1-40CE-AE27-DDF0AAEBB150}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcGeodeticElem._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcGeodeticElem from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcGeodeticElem = agcom.GUID(IVAStateCalcGeodeticElem._uuid)
        vtable_offset_local = IVAStateCalcGeodeticElem._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcGeodeticElem, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcGeodeticElem, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcGeodeticElem.__dict__ and type(IVAStateCalcGeodeticElem.__dict__[attrname]) == property:
            return IVAStateCalcGeodeticElem.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcGeodeticElem.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{D827128C-F7C1-40CE-AE27-DDF0AAEBB150}", IVAStateCalcGeodeticElem)
agcls.AgTypeNameMap["IVAStateCalcGeodeticElem"] = IVAStateCalcGeodeticElem

class IVAStateCalcRepeatingGroundTrackErr(object):
    """Properties for a RepeatingGroundTrackEquatorError calculation object."""
    _uuid = "{53C25A30-1C1E-42F0-AEA5-D67EF1037A18}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceLongitude"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceLongitude"] = _raise_uninitialized_error
        self.__dict__["_GetRepeatCount"] = _raise_uninitialized_error
        self.__dict__["_SetRepeatCount"] = _raise_uninitialized_error
        self.__dict__["_EnableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_DisableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_IsControlParameterEnabled"] = _raise_uninitialized_error
        self.__dict__["_GetControlParametersAvailable"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcRepeatingGroundTrackErr._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcRepeatingGroundTrackErr from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcRepeatingGroundTrackErr = agcom.GUID(IVAStateCalcRepeatingGroundTrackErr._uuid)
        vtable_offset_local = IVAStateCalcRepeatingGroundTrackErr._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRepeatingGroundTrackErr, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRepeatingGroundTrackErr, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetReferenceLongitude"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRepeatingGroundTrackErr, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_SetReferenceLongitude"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRepeatingGroundTrackErr, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_GetRepeatCount"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRepeatingGroundTrackErr, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRepeatCount"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRepeatingGroundTrackErr, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_EnableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRepeatingGroundTrackErr, vtable_offset_local+7, agcom.LONG)
        self.__dict__["_DisableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRepeatingGroundTrackErr, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_IsControlParameterEnabled"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRepeatingGroundTrackErr, vtable_offset_local+9, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetControlParametersAvailable"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRepeatingGroundTrackErr, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcRepeatingGroundTrackErr.__dict__ and type(IVAStateCalcRepeatingGroundTrackErr.__dict__[attrname]) == property:
            return IVAStateCalcRepeatingGroundTrackErr.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcRepeatingGroundTrackErr.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def ReferenceLongitude(self) -> typing.Any:
        """The longitude at the equator to be used as a reference for the repeating ground track. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceLongitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ReferenceLongitude.setter
    def ReferenceLongitude(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceLongitude"](arg_inVal.COM_val))

    @property
    def RepeatCount(self) -> float:
        """The number of orbits before the ground track repeats over the same longitude. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRepeatCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RepeatCount.setter
    def RepeatCount(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetRepeatCount"](arg_inVal.COM_val))

    def EnableControlParameter(self, param:"AgEVAControlRepeatingGroundTrackErr") -> None:
        """Enables the specified control parameter"""
        with agmarshall.AgEnum_arg(AgEVAControlRepeatingGroundTrackErr, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_EnableControlParameter"](arg_param.COM_val))

    def DisableControlParameter(self, param:"AgEVAControlRepeatingGroundTrackErr") -> None:
        """Disables the specified control parameter"""
        with agmarshall.AgEnum_arg(AgEVAControlRepeatingGroundTrackErr, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_DisableControlParameter"](arg_param.COM_val))

    def IsControlParameterEnabled(self, param:"AgEVAControlRepeatingGroundTrackErr") -> bool:
        """Sees if the specified control is enabled"""
        with agmarshall.AgEnum_arg(AgEVAControlRepeatingGroundTrackErr, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_IsControlParameterEnabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ControlParametersAvailable(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetControlParametersAvailable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{53C25A30-1C1E-42F0-AEA5-D67EF1037A18}", IVAStateCalcRepeatingGroundTrackErr)
agcls.AgTypeNameMap["IVAStateCalcRepeatingGroundTrackErr"] = IVAStateCalcRepeatingGroundTrackErr

class IVAStateCalcAltOfApoapsis(object):
    """Properties for an Altitude of Apoapsis calculation object."""
    _uuid = "{891F3D94-A765-42AE-9459-7575CD33E62E}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetElementType"] = _raise_uninitialized_error
        self.__dict__["_SetElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcAltOfApoapsis._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcAltOfApoapsis from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcAltOfApoapsis = agcom.GUID(IVAStateCalcAltOfApoapsis._uuid)
        vtable_offset_local = IVAStateCalcAltOfApoapsis._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcAltOfApoapsis, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcAltOfApoapsis, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcAltOfApoapsis, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcAltOfApoapsis, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcAltOfApoapsis.__dict__ and type(IVAStateCalcAltOfApoapsis.__dict__[attrname]) == property:
            return IVAStateCalcAltOfApoapsis.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcAltOfApoapsis.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def ElementType(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElementType.setter
    def ElementType(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetElementType"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{891F3D94-A765-42AE-9459-7575CD33E62E}", IVAStateCalcAltOfApoapsis)
agcls.AgTypeNameMap["IVAStateCalcAltOfApoapsis"] = IVAStateCalcAltOfApoapsis

class IVAStateCalcAltOfPeriapsis(object):
    """Properties for an Altitude Of Periapsis calculation object."""
    _uuid = "{3A81E388-64C2-41BD-88FC-19E318F08D5C}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetElementType"] = _raise_uninitialized_error
        self.__dict__["_SetElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcAltOfPeriapsis._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcAltOfPeriapsis from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcAltOfPeriapsis = agcom.GUID(IVAStateCalcAltOfPeriapsis._uuid)
        vtable_offset_local = IVAStateCalcAltOfPeriapsis._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcAltOfPeriapsis, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcAltOfPeriapsis, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcAltOfPeriapsis, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcAltOfPeriapsis, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcAltOfPeriapsis.__dict__ and type(IVAStateCalcAltOfPeriapsis.__dict__[attrname]) == property:
            return IVAStateCalcAltOfPeriapsis.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcAltOfPeriapsis.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def ElementType(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElementType.setter
    def ElementType(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetElementType"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3A81E388-64C2-41BD-88FC-19E318F08D5C}", IVAStateCalcAltOfPeriapsis)
agcls.AgTypeNameMap["IVAStateCalcAltOfPeriapsis"] = IVAStateCalcAltOfPeriapsis

class IVAStateCalcArgOfLat(object):
    """Properties for an Argument of Latitude calculation object."""
    _uuid = "{C5B93283-1CEB-407C-837F-21BB7C8227BD}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_SetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_GetElementType"] = _raise_uninitialized_error
        self.__dict__["_SetElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcArgOfLat._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcArgOfLat from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcArgOfLat = agcom.GUID(IVAStateCalcArgOfLat._uuid)
        vtable_offset_local = IVAStateCalcArgOfLat._vtable_offset - 1
        self.__dict__["_GetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcArgOfLat, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcArgOfLat, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcArgOfLat, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcArgOfLat, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcArgOfLat.__dict__ and type(IVAStateCalcArgOfLat.__dict__[attrname]) == property:
            return IVAStateCalcArgOfLat.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcArgOfLat.")
    
    @property
    def CoordSystemName(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordSystemName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordSystemName.setter
    def CoordSystemName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordSystemName"](arg_inVal.COM_val))

    @property
    def ElementType(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElementType.setter
    def ElementType(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetElementType"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{C5B93283-1CEB-407C-837F-21BB7C8227BD}", IVAStateCalcArgOfLat)
agcls.AgTypeNameMap["IVAStateCalcArgOfLat"] = IVAStateCalcArgOfLat

class IVAStateCalcArgOfPeriapsis(object):
    """Properties for an Argument of Periapsis calculation object."""
    _uuid = "{30364B7E-BBCE-4FCF-BC76-7330A97ECE0F}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_SetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_GetElementType"] = _raise_uninitialized_error
        self.__dict__["_SetElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcArgOfPeriapsis._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcArgOfPeriapsis from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcArgOfPeriapsis = agcom.GUID(IVAStateCalcArgOfPeriapsis._uuid)
        vtable_offset_local = IVAStateCalcArgOfPeriapsis._vtable_offset - 1
        self.__dict__["_GetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcArgOfPeriapsis, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcArgOfPeriapsis, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcArgOfPeriapsis, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcArgOfPeriapsis, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcArgOfPeriapsis.__dict__ and type(IVAStateCalcArgOfPeriapsis.__dict__[attrname]) == property:
            return IVAStateCalcArgOfPeriapsis.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcArgOfPeriapsis.")
    
    @property
    def CoordSystemName(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordSystemName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordSystemName.setter
    def CoordSystemName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordSystemName"](arg_inVal.COM_val))

    @property
    def ElementType(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElementType.setter
    def ElementType(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetElementType"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{30364B7E-BBCE-4FCF-BC76-7330A97ECE0F}", IVAStateCalcArgOfPeriapsis)
agcls.AgTypeNameMap["IVAStateCalcArgOfPeriapsis"] = IVAStateCalcArgOfPeriapsis

class IVAStateCalcEccAnomaly(object):
    """Properties for an Eccentric Anomaly calculation object."""
    _uuid = "{9655A1AA-233C-4E4C-9A2E-93B91A439947}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetElementType"] = _raise_uninitialized_error
        self.__dict__["_SetElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcEccAnomaly._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcEccAnomaly from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcEccAnomaly = agcom.GUID(IVAStateCalcEccAnomaly._uuid)
        vtable_offset_local = IVAStateCalcEccAnomaly._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcEccAnomaly, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcEccAnomaly, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcEccAnomaly, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcEccAnomaly, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcEccAnomaly.__dict__ and type(IVAStateCalcEccAnomaly.__dict__[attrname]) == property:
            return IVAStateCalcEccAnomaly.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcEccAnomaly.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def ElementType(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElementType.setter
    def ElementType(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetElementType"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{9655A1AA-233C-4E4C-9A2E-93B91A439947}", IVAStateCalcEccAnomaly)
agcls.AgTypeNameMap["IVAStateCalcEccAnomaly"] = IVAStateCalcEccAnomaly

class IVAStateCalcEccentricity(object):
    """Properties for an Eccentricity calculation object."""
    _uuid = "{3AE52837-A597-473A-83A2-9DC9B2271101}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetElementType"] = _raise_uninitialized_error
        self.__dict__["_SetElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcEccentricity._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcEccentricity from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcEccentricity = agcom.GUID(IVAStateCalcEccentricity._uuid)
        vtable_offset_local = IVAStateCalcEccentricity._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcEccentricity, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcEccentricity, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcEccentricity, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcEccentricity, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcEccentricity.__dict__ and type(IVAStateCalcEccentricity.__dict__[attrname]) == property:
            return IVAStateCalcEccentricity.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcEccentricity.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def ElementType(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElementType.setter
    def ElementType(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetElementType"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3AE52837-A597-473A-83A2-9DC9B2271101}", IVAStateCalcEccentricity)
agcls.AgTypeNameMap["IVAStateCalcEccentricity"] = IVAStateCalcEccentricity

class IVAStateCalcInclination(object):
    """Properties for an Inclination calculation object."""
    _uuid = "{477CF8AA-81BE-4C13-8F6D-7157268869A3}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_SetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_GetElementType"] = _raise_uninitialized_error
        self.__dict__["_SetElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcInclination._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcInclination from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcInclination = agcom.GUID(IVAStateCalcInclination._uuid)
        vtable_offset_local = IVAStateCalcInclination._vtable_offset - 1
        self.__dict__["_GetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcInclination, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcInclination, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcInclination, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcInclination, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcInclination.__dict__ and type(IVAStateCalcInclination.__dict__[attrname]) == property:
            return IVAStateCalcInclination.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcInclination.")
    
    @property
    def CoordSystemName(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordSystemName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordSystemName.setter
    def CoordSystemName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordSystemName"](arg_inVal.COM_val))

    @property
    def ElementType(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElementType.setter
    def ElementType(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetElementType"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{477CF8AA-81BE-4C13-8F6D-7157268869A3}", IVAStateCalcInclination)
agcls.AgTypeNameMap["IVAStateCalcInclination"] = IVAStateCalcInclination

class IVAStateCalcLonOfAscNode(object):
    """Properties for a Longitude of Ascending Node calculation object."""
    _uuid = "{9A4EED12-F650-449B-B3C0-2278D58A8D92}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetElementType"] = _raise_uninitialized_error
        self.__dict__["_SetElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcLonOfAscNode._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcLonOfAscNode from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcLonOfAscNode = agcom.GUID(IVAStateCalcLonOfAscNode._uuid)
        vtable_offset_local = IVAStateCalcLonOfAscNode._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcLonOfAscNode, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcLonOfAscNode, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcLonOfAscNode, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcLonOfAscNode, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcLonOfAscNode.__dict__ and type(IVAStateCalcLonOfAscNode.__dict__[attrname]) == property:
            return IVAStateCalcLonOfAscNode.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcLonOfAscNode.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def ElementType(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElementType.setter
    def ElementType(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetElementType"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{9A4EED12-F650-449B-B3C0-2278D58A8D92}", IVAStateCalcLonOfAscNode)
agcls.AgTypeNameMap["IVAStateCalcLonOfAscNode"] = IVAStateCalcLonOfAscNode

class IVAStateCalcMeanAnomaly(object):
    """Properties for a MeanAnomaly calculation object."""
    _uuid = "{2E620A15-C918-467A-A8C3-817BF13FC602}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetElementType"] = _raise_uninitialized_error
        self.__dict__["_SetElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcMeanAnomaly._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcMeanAnomaly from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcMeanAnomaly = agcom.GUID(IVAStateCalcMeanAnomaly._uuid)
        vtable_offset_local = IVAStateCalcMeanAnomaly._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcMeanAnomaly, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcMeanAnomaly, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcMeanAnomaly, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcMeanAnomaly, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcMeanAnomaly.__dict__ and type(IVAStateCalcMeanAnomaly.__dict__[attrname]) == property:
            return IVAStateCalcMeanAnomaly.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcMeanAnomaly.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def ElementType(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElementType.setter
    def ElementType(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetElementType"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2E620A15-C918-467A-A8C3-817BF13FC602}", IVAStateCalcMeanAnomaly)
agcls.AgTypeNameMap["IVAStateCalcMeanAnomaly"] = IVAStateCalcMeanAnomaly

class IVAStateCalcMeanMotion(object):
    """Properties for a Mean Motion calculation object."""
    _uuid = "{3CF417E4-9A1B-492B-BEA8-A019896B26E9}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetElementType"] = _raise_uninitialized_error
        self.__dict__["_SetElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcMeanMotion._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcMeanMotion from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcMeanMotion = agcom.GUID(IVAStateCalcMeanMotion._uuid)
        vtable_offset_local = IVAStateCalcMeanMotion._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcMeanMotion, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcMeanMotion, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcMeanMotion, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcMeanMotion, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcMeanMotion.__dict__ and type(IVAStateCalcMeanMotion.__dict__[attrname]) == property:
            return IVAStateCalcMeanMotion.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcMeanMotion.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def ElementType(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElementType.setter
    def ElementType(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetElementType"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3CF417E4-9A1B-492B-BEA8-A019896B26E9}", IVAStateCalcMeanMotion)
agcls.AgTypeNameMap["IVAStateCalcMeanMotion"] = IVAStateCalcMeanMotion

class IVAStateCalcOrbitPeriod(object):
    """Properties for an Orbit Period calculation object."""
    _uuid = "{C108486C-571C-4007-9EFD-70CD8745C3D5}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetElementType"] = _raise_uninitialized_error
        self.__dict__["_SetElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcOrbitPeriod._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcOrbitPeriod from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcOrbitPeriod = agcom.GUID(IVAStateCalcOrbitPeriod._uuid)
        vtable_offset_local = IVAStateCalcOrbitPeriod._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitPeriod, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitPeriod, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitPeriod, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitPeriod, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcOrbitPeriod.__dict__ and type(IVAStateCalcOrbitPeriod.__dict__[attrname]) == property:
            return IVAStateCalcOrbitPeriod.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcOrbitPeriod.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def ElementType(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElementType.setter
    def ElementType(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetElementType"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{C108486C-571C-4007-9EFD-70CD8745C3D5}", IVAStateCalcOrbitPeriod)
agcls.AgTypeNameMap["IVAStateCalcOrbitPeriod"] = IVAStateCalcOrbitPeriod

class IVAStateCalcNumRevs(object):
    """Properties for a Number of Revolutions calculation object."""
    _uuid = "{A9FF9984-5A98-44F1-A231-10C3F26A1082}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetElementType"] = _raise_uninitialized_error
        self.__dict__["_SetElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcNumRevs._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcNumRevs from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcNumRevs = agcom.GUID(IVAStateCalcNumRevs._uuid)
        vtable_offset_local = IVAStateCalcNumRevs._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcNumRevs, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcNumRevs, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcNumRevs, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcNumRevs, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcNumRevs.__dict__ and type(IVAStateCalcNumRevs.__dict__[attrname]) == property:
            return IVAStateCalcNumRevs.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcNumRevs.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def ElementType(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElementType.setter
    def ElementType(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetElementType"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{A9FF9984-5A98-44F1-A231-10C3F26A1082}", IVAStateCalcNumRevs)
agcls.AgTypeNameMap["IVAStateCalcNumRevs"] = IVAStateCalcNumRevs

class IVAStateCalcRAAN(object):
    """Properties for a RAAN calculation object."""
    _uuid = "{B2456E5C-7305-4AAD-8318-7A65D65C328A}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_SetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_GetElementType"] = _raise_uninitialized_error
        self.__dict__["_SetElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcRAAN._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcRAAN from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcRAAN = agcom.GUID(IVAStateCalcRAAN._uuid)
        vtable_offset_local = IVAStateCalcRAAN._vtable_offset - 1
        self.__dict__["_GetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRAAN, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRAAN, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRAAN, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRAAN, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcRAAN.__dict__ and type(IVAStateCalcRAAN.__dict__[attrname]) == property:
            return IVAStateCalcRAAN.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcRAAN.")
    
    @property
    def CoordSystemName(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordSystemName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordSystemName.setter
    def CoordSystemName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordSystemName"](arg_inVal.COM_val))

    @property
    def ElementType(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElementType.setter
    def ElementType(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetElementType"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{B2456E5C-7305-4AAD-8318-7A65D65C328A}", IVAStateCalcRAAN)
agcls.AgTypeNameMap["IVAStateCalcRAAN"] = IVAStateCalcRAAN

class IVAStateCalcRadOfApoapsis(object):
    """Properties for a Radius Of Apoapsis calculation object."""
    _uuid = "{2B481148-138F-44EA-9EE2-03FC7FA82CEC}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetElementType"] = _raise_uninitialized_error
        self.__dict__["_SetElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcRadOfApoapsis._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcRadOfApoapsis from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcRadOfApoapsis = agcom.GUID(IVAStateCalcRadOfApoapsis._uuid)
        vtable_offset_local = IVAStateCalcRadOfApoapsis._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRadOfApoapsis, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRadOfApoapsis, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRadOfApoapsis, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRadOfApoapsis, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcRadOfApoapsis.__dict__ and type(IVAStateCalcRadOfApoapsis.__dict__[attrname]) == property:
            return IVAStateCalcRadOfApoapsis.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcRadOfApoapsis.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def ElementType(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElementType.setter
    def ElementType(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetElementType"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2B481148-138F-44EA-9EE2-03FC7FA82CEC}", IVAStateCalcRadOfApoapsis)
agcls.AgTypeNameMap["IVAStateCalcRadOfApoapsis"] = IVAStateCalcRadOfApoapsis

class IVAStateCalcRadOfPeriapsis(object):
    """Properties for a Radius Of Periapsis calculation object."""
    _uuid = "{8AF6B875-ED5E-4734-B98B-17B03203FFE8}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetElementType"] = _raise_uninitialized_error
        self.__dict__["_SetElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcRadOfPeriapsis._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcRadOfPeriapsis from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcRadOfPeriapsis = agcom.GUID(IVAStateCalcRadOfPeriapsis._uuid)
        vtable_offset_local = IVAStateCalcRadOfPeriapsis._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRadOfPeriapsis, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRadOfPeriapsis, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRadOfPeriapsis, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRadOfPeriapsis, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcRadOfPeriapsis.__dict__ and type(IVAStateCalcRadOfPeriapsis.__dict__[attrname]) == property:
            return IVAStateCalcRadOfPeriapsis.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcRadOfPeriapsis.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def ElementType(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElementType.setter
    def ElementType(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetElementType"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{8AF6B875-ED5E-4734-B98B-17B03203FFE8}", IVAStateCalcRadOfPeriapsis)
agcls.AgTypeNameMap["IVAStateCalcRadOfPeriapsis"] = IVAStateCalcRadOfPeriapsis

class IVAStateCalcSemiMajorAxis(object):
    """Properties for a Semimajor Axis calculation object."""
    _uuid = "{0DC03521-C37A-4D96-A820-E0D19835C7DF}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetElementType"] = _raise_uninitialized_error
        self.__dict__["_SetElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcSemiMajorAxis._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcSemiMajorAxis from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcSemiMajorAxis = agcom.GUID(IVAStateCalcSemiMajorAxis._uuid)
        vtable_offset_local = IVAStateCalcSemiMajorAxis._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSemiMajorAxis, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSemiMajorAxis, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSemiMajorAxis, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSemiMajorAxis, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcSemiMajorAxis.__dict__ and type(IVAStateCalcSemiMajorAxis.__dict__[attrname]) == property:
            return IVAStateCalcSemiMajorAxis.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcSemiMajorAxis.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def ElementType(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElementType.setter
    def ElementType(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetElementType"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{0DC03521-C37A-4D96-A820-E0D19835C7DF}", IVAStateCalcSemiMajorAxis)
agcls.AgTypeNameMap["IVAStateCalcSemiMajorAxis"] = IVAStateCalcSemiMajorAxis

class IVAStateCalcTimePastAscNode(object):
    """Properties for a Time Past Ascending Node calculation object."""
    _uuid = "{4ED0F733-4995-4D32-8533-D7A1801C4FBB}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_SetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_GetElementType"] = _raise_uninitialized_error
        self.__dict__["_SetElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcTimePastAscNode._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcTimePastAscNode from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcTimePastAscNode = agcom.GUID(IVAStateCalcTimePastAscNode._uuid)
        vtable_offset_local = IVAStateCalcTimePastAscNode._vtable_offset - 1
        self.__dict__["_GetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcTimePastAscNode, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcTimePastAscNode, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcTimePastAscNode, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcTimePastAscNode, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcTimePastAscNode.__dict__ and type(IVAStateCalcTimePastAscNode.__dict__[attrname]) == property:
            return IVAStateCalcTimePastAscNode.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcTimePastAscNode.")
    
    @property
    def CoordSystemName(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordSystemName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordSystemName.setter
    def CoordSystemName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordSystemName"](arg_inVal.COM_val))

    @property
    def ElementType(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElementType.setter
    def ElementType(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetElementType"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4ED0F733-4995-4D32-8533-D7A1801C4FBB}", IVAStateCalcTimePastAscNode)
agcls.AgTypeNameMap["IVAStateCalcTimePastAscNode"] = IVAStateCalcTimePastAscNode

class IVAStateCalcTimePastPeriapsis(object):
    """Properties for a Time Past Periapsis calculation object."""
    _uuid = "{30BCAEF0-2921-4EE5-B047-79CA370F9C83}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetElementType"] = _raise_uninitialized_error
        self.__dict__["_SetElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcTimePastPeriapsis._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcTimePastPeriapsis from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcTimePastPeriapsis = agcom.GUID(IVAStateCalcTimePastPeriapsis._uuid)
        vtable_offset_local = IVAStateCalcTimePastPeriapsis._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcTimePastPeriapsis, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcTimePastPeriapsis, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcTimePastPeriapsis, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcTimePastPeriapsis, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcTimePastPeriapsis.__dict__ and type(IVAStateCalcTimePastPeriapsis.__dict__[attrname]) == property:
            return IVAStateCalcTimePastPeriapsis.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcTimePastPeriapsis.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def ElementType(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElementType.setter
    def ElementType(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetElementType"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{30BCAEF0-2921-4EE5-B047-79CA370F9C83}", IVAStateCalcTimePastPeriapsis)
agcls.AgTypeNameMap["IVAStateCalcTimePastPeriapsis"] = IVAStateCalcTimePastPeriapsis

class IVAStateCalcDeltaV(object):
    """Properties for a DeltaV calculation object."""
    _uuid = "{F6E77B5A-1A44-4CD0-A0BF-2991C1A33EBA}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcDeltaV._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcDeltaV from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcDeltaV = agcom.GUID(IVAStateCalcDeltaV._uuid)
        vtable_offset_local = IVAStateCalcDeltaV._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcDeltaV.__dict__ and type(IVAStateCalcDeltaV.__dict__[attrname]) == property:
            return IVAStateCalcDeltaV.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcDeltaV.")
    

agcls.AgClassCatalog.add_catalog_entry("{F6E77B5A-1A44-4CD0-A0BF-2991C1A33EBA}", IVAStateCalcDeltaV)
agcls.AgTypeNameMap["IVAStateCalcDeltaV"] = IVAStateCalcDeltaV

class IVAStateCalcDeltaVSquared(object):
    """Properties for a DeltaV Squared calculation object."""
    _uuid = "{52506197-B072-4F2A-A1E6-10728D969E2A}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcDeltaVSquared._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcDeltaVSquared from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcDeltaVSquared = agcom.GUID(IVAStateCalcDeltaVSquared._uuid)
        vtable_offset_local = IVAStateCalcDeltaVSquared._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcDeltaVSquared.__dict__ and type(IVAStateCalcDeltaVSquared.__dict__[attrname]) == property:
            return IVAStateCalcDeltaVSquared.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcDeltaVSquared.")
    

agcls.AgClassCatalog.add_catalog_entry("{52506197-B072-4F2A-A1E6-10728D969E2A}", IVAStateCalcDeltaVSquared)
agcls.AgTypeNameMap["IVAStateCalcDeltaVSquared"] = IVAStateCalcDeltaVSquared

class IVAStateCalcMCSDeltaV(object):
    """Properties for a MCS DeltaV calculation object."""
    _uuid = "{6411CC14-1207-49C7-ACEF-31EC24908D59}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcMCSDeltaV._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcMCSDeltaV from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcMCSDeltaV = agcom.GUID(IVAStateCalcMCSDeltaV._uuid)
        vtable_offset_local = IVAStateCalcMCSDeltaV._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcMCSDeltaV.__dict__ and type(IVAStateCalcMCSDeltaV.__dict__[attrname]) == property:
            return IVAStateCalcMCSDeltaV.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcMCSDeltaV.")
    

agcls.AgClassCatalog.add_catalog_entry("{6411CC14-1207-49C7-ACEF-31EC24908D59}", IVAStateCalcMCSDeltaV)
agcls.AgTypeNameMap["IVAStateCalcMCSDeltaV"] = IVAStateCalcMCSDeltaV

class IVAStateCalcMCSDeltaVSquared(object):
    """Properties for a MCS DeltaV Squared calculation object."""
    _uuid = "{17C279CA-79C4-4076-AF85-6018DA3FAB83}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSquaredType"] = _raise_uninitialized_error
        self.__dict__["_SetSquaredType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcMCSDeltaVSquared._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcMCSDeltaVSquared from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcMCSDeltaVSquared = agcom.GUID(IVAStateCalcMCSDeltaVSquared._uuid)
        vtable_offset_local = IVAStateCalcMCSDeltaVSquared._vtable_offset - 1
        self.__dict__["_GetSquaredType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcMCSDeltaVSquared, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetSquaredType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcMCSDeltaVSquared, vtable_offset_local+2, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcMCSDeltaVSquared.__dict__ and type(IVAStateCalcMCSDeltaVSquared.__dict__[attrname]) == property:
            return IVAStateCalcMCSDeltaVSquared.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcMCSDeltaVSquared.")
    
    @property
    def SquaredType(self) -> "AgEVASquaredType":
        """Whether the value should be calculated as the sum of the squares of the maneuver Delta-Vs or the square of the sum of the maneuver Delta-Vs."""
        with agmarshall.AgEnum_arg(AgEVASquaredType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSquaredType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SquaredType.setter
    def SquaredType(self, inVal:"AgEVASquaredType") -> None:
        """Whether the value should be calculated as the sum of the squares of the maneuver Delta-Vs or the square of the sum of the maneuver Delta-Vs."""
        with agmarshall.AgEnum_arg(AgEVASquaredType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSquaredType"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{17C279CA-79C4-4076-AF85-6018DA3FAB83}", IVAStateCalcMCSDeltaVSquared)
agcls.AgTypeNameMap["IVAStateCalcMCSDeltaVSquared"] = IVAStateCalcMCSDeltaVSquared

class IVAStateCalcSequenceDeltaV(object):
    """Properties for a Sequence DeltaV calculation object."""
    _uuid = "{0F7BEE65-4F80-404D-AA99-1F92F88E2525}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSequenceName"] = _raise_uninitialized_error
        self.__dict__["_SetSequenceName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcSequenceDeltaV._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcSequenceDeltaV from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcSequenceDeltaV = agcom.GUID(IVAStateCalcSequenceDeltaV._uuid)
        vtable_offset_local = IVAStateCalcSequenceDeltaV._vtable_offset - 1
        self.__dict__["_GetSequenceName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSequenceDeltaV, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetSequenceName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSequenceDeltaV, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcSequenceDeltaV.__dict__ and type(IVAStateCalcSequenceDeltaV.__dict__[attrname]) == property:
            return IVAStateCalcSequenceDeltaV.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcSequenceDeltaV.")
    
    @property
    def SequenceName(self) -> str:
        """The sequence whose DeltaV's are to be summed."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSequenceName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SequenceName.setter
    def SequenceName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSequenceName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{0F7BEE65-4F80-404D-AA99-1F92F88E2525}", IVAStateCalcSequenceDeltaV)
agcls.AgTypeNameMap["IVAStateCalcSequenceDeltaV"] = IVAStateCalcSequenceDeltaV

class IVAStateCalcSequenceDeltaVSquared(object):
    """Properties for a Sequence DeltaV Squared calculation object."""
    _uuid = "{D6D37B91-EDAE-4E35-865F-538C2155A239}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSequenceName"] = _raise_uninitialized_error
        self.__dict__["_SetSequenceName"] = _raise_uninitialized_error
        self.__dict__["_GetSquaredType"] = _raise_uninitialized_error
        self.__dict__["_SetSquaredType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcSequenceDeltaVSquared._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcSequenceDeltaVSquared from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcSequenceDeltaVSquared = agcom.GUID(IVAStateCalcSequenceDeltaVSquared._uuid)
        vtable_offset_local = IVAStateCalcSequenceDeltaVSquared._vtable_offset - 1
        self.__dict__["_GetSequenceName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSequenceDeltaVSquared, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetSequenceName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSequenceDeltaVSquared, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetSquaredType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSequenceDeltaVSquared, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetSquaredType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSequenceDeltaVSquared, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcSequenceDeltaVSquared.__dict__ and type(IVAStateCalcSequenceDeltaVSquared.__dict__[attrname]) == property:
            return IVAStateCalcSequenceDeltaVSquared.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcSequenceDeltaVSquared.")
    
    @property
    def SequenceName(self) -> str:
        """The sequence whose DeltaV's are to be accumulated."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSequenceName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SequenceName.setter
    def SequenceName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSequenceName"](arg_inVal.COM_val))

    @property
    def SquaredType(self) -> "AgEVASquaredType":
        """Whether the value should be calculated as the sum of the squares of the maneuver Delta-Vs or the square of the sum of the maneuver Delta-Vs."""
        with agmarshall.AgEnum_arg(AgEVASquaredType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSquaredType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SquaredType.setter
    def SquaredType(self, inVal:"AgEVASquaredType") -> None:
        """Whether the value should be calculated as the sum of the squares of the maneuver Delta-Vs or the square of the sum of the maneuver Delta-Vs."""
        with agmarshall.AgEnum_arg(AgEVASquaredType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSquaredType"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{D6D37B91-EDAE-4E35-865F-538C2155A239}", IVAStateCalcSequenceDeltaVSquared)
agcls.AgTypeNameMap["IVAStateCalcSequenceDeltaVSquared"] = IVAStateCalcSequenceDeltaVSquared

class IVAStateCalcFuelMass(object):
    """Properties for a FuelMass calculation object."""
    _uuid = "{2707D8D8-8D1E-477D-B246-0568788FE867}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcFuelMass._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcFuelMass from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcFuelMass = agcom.GUID(IVAStateCalcFuelMass._uuid)
        vtable_offset_local = IVAStateCalcFuelMass._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcFuelMass.__dict__ and type(IVAStateCalcFuelMass.__dict__[attrname]) == property:
            return IVAStateCalcFuelMass.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcFuelMass.")
    

agcls.AgClassCatalog.add_catalog_entry("{2707D8D8-8D1E-477D-B246-0568788FE867}", IVAStateCalcFuelMass)
agcls.AgTypeNameMap["IVAStateCalcFuelMass"] = IVAStateCalcFuelMass

class IVAStateCalcDensity(object):
    """Properties for a Fuel Density calculation object."""
    _uuid = "{9AE849EC-D75D-45A2-A23A-404C041BDB7B}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcDensity._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcDensity from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcDensity = agcom.GUID(IVAStateCalcDensity._uuid)
        vtable_offset_local = IVAStateCalcDensity._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcDensity.__dict__ and type(IVAStateCalcDensity.__dict__[attrname]) == property:
            return IVAStateCalcDensity.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcDensity.")
    

agcls.AgClassCatalog.add_catalog_entry("{9AE849EC-D75D-45A2-A23A-404C041BDB7B}", IVAStateCalcDensity)
agcls.AgTypeNameMap["IVAStateCalcDensity"] = IVAStateCalcDensity

class IVAStateCalcInertialDeltaVMag(object):
    """Properties for an Inertial DeltaV Magnitude calculation object."""
    _uuid = "{206A8426-8860-4E7B-A0A1-0C1A8D4A79C5}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcInertialDeltaVMag._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcInertialDeltaVMag from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcInertialDeltaVMag = agcom.GUID(IVAStateCalcInertialDeltaVMag._uuid)
        vtable_offset_local = IVAStateCalcInertialDeltaVMag._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcInertialDeltaVMag.__dict__ and type(IVAStateCalcInertialDeltaVMag.__dict__[attrname]) == property:
            return IVAStateCalcInertialDeltaVMag.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcInertialDeltaVMag.")
    

agcls.AgClassCatalog.add_catalog_entry("{206A8426-8860-4E7B-A0A1-0C1A8D4A79C5}", IVAStateCalcInertialDeltaVMag)
agcls.AgTypeNameMap["IVAStateCalcInertialDeltaVMag"] = IVAStateCalcInertialDeltaVMag

class IVAStateCalcInertialDeltaVx(object):
    """Properties for an Inertial DeltaVx calculation object."""
    _uuid = "{D18A9666-512E-476E-89C0-FF6B2D3C2428}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCoordAxesName"] = _raise_uninitialized_error
        self.__dict__["_SetCoordAxesName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcInertialDeltaVx._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcInertialDeltaVx from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcInertialDeltaVx = agcom.GUID(IVAStateCalcInertialDeltaVx._uuid)
        vtable_offset_local = IVAStateCalcInertialDeltaVx._vtable_offset - 1
        self.__dict__["_GetCoordAxesName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcInertialDeltaVx, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCoordAxesName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcInertialDeltaVx, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcInertialDeltaVx.__dict__ and type(IVAStateCalcInertialDeltaVx.__dict__[attrname]) == property:
            return IVAStateCalcInertialDeltaVx.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcInertialDeltaVx.")
    
    @property
    def CoordAxesName(self) -> str:
        """The coordinate axes."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordAxesName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordAxesName.setter
    def CoordAxesName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordAxesName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{D18A9666-512E-476E-89C0-FF6B2D3C2428}", IVAStateCalcInertialDeltaVx)
agcls.AgTypeNameMap["IVAStateCalcInertialDeltaVx"] = IVAStateCalcInertialDeltaVx

class IVAStateCalcInertialDeltaVy(object):
    """Properties for an Inertial DeltaVy calculation object."""
    _uuid = "{4A5489A4-1EDC-4CD1-BF9F-EAF779ECFFD3}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCoordAxesName"] = _raise_uninitialized_error
        self.__dict__["_SetCoordAxesName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcInertialDeltaVy._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcInertialDeltaVy from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcInertialDeltaVy = agcom.GUID(IVAStateCalcInertialDeltaVy._uuid)
        vtable_offset_local = IVAStateCalcInertialDeltaVy._vtable_offset - 1
        self.__dict__["_GetCoordAxesName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcInertialDeltaVy, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCoordAxesName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcInertialDeltaVy, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcInertialDeltaVy.__dict__ and type(IVAStateCalcInertialDeltaVy.__dict__[attrname]) == property:
            return IVAStateCalcInertialDeltaVy.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcInertialDeltaVy.")
    
    @property
    def CoordAxesName(self) -> str:
        """The coordinate axes."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordAxesName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordAxesName.setter
    def CoordAxesName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordAxesName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4A5489A4-1EDC-4CD1-BF9F-EAF779ECFFD3}", IVAStateCalcInertialDeltaVy)
agcls.AgTypeNameMap["IVAStateCalcInertialDeltaVy"] = IVAStateCalcInertialDeltaVy

class IVAStateCalcInertialDeltaVz(object):
    """Properties for an Inertial DeltaVz calculation object."""
    _uuid = "{4301E169-DEE2-411A-9DBD-06DEC30F9EBD}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCoordAxesName"] = _raise_uninitialized_error
        self.__dict__["_SetCoordAxesName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcInertialDeltaVz._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcInertialDeltaVz from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcInertialDeltaVz = agcom.GUID(IVAStateCalcInertialDeltaVz._uuid)
        vtable_offset_local = IVAStateCalcInertialDeltaVz._vtable_offset - 1
        self.__dict__["_GetCoordAxesName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcInertialDeltaVz, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCoordAxesName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcInertialDeltaVz, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcInertialDeltaVz.__dict__ and type(IVAStateCalcInertialDeltaVz.__dict__[attrname]) == property:
            return IVAStateCalcInertialDeltaVz.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcInertialDeltaVz.")
    
    @property
    def CoordAxesName(self) -> str:
        """The coordinate axes."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordAxesName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordAxesName.setter
    def CoordAxesName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordAxesName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4301E169-DEE2-411A-9DBD-06DEC30F9EBD}", IVAStateCalcInertialDeltaVz)
agcls.AgTypeNameMap["IVAStateCalcInertialDeltaVz"] = IVAStateCalcInertialDeltaVz

class IVAStateCalcManeuverSpecificImpulse(object):
    """Properties for a Specific Impulse calculation object."""
    _uuid = "{4EA5927D-76E7-405C-AA5A-903C19B576DC}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcManeuverSpecificImpulse._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcManeuverSpecificImpulse from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcManeuverSpecificImpulse = agcom.GUID(IVAStateCalcManeuverSpecificImpulse._uuid)
        vtable_offset_local = IVAStateCalcManeuverSpecificImpulse._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcManeuverSpecificImpulse.__dict__ and type(IVAStateCalcManeuverSpecificImpulse.__dict__[attrname]) == property:
            return IVAStateCalcManeuverSpecificImpulse.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcManeuverSpecificImpulse.")
    

agcls.AgClassCatalog.add_catalog_entry("{4EA5927D-76E7-405C-AA5A-903C19B576DC}", IVAStateCalcManeuverSpecificImpulse)
agcls.AgTypeNameMap["IVAStateCalcManeuverSpecificImpulse"] = IVAStateCalcManeuverSpecificImpulse

class IVAStateCalcPressure(object):
    """Properties for a Tank Pressure calculation object."""
    _uuid = "{C37E82D4-7AA9-4BA0-92DA-1372268F63D6}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcPressure._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcPressure from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcPressure = agcom.GUID(IVAStateCalcPressure._uuid)
        vtable_offset_local = IVAStateCalcPressure._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcPressure.__dict__ and type(IVAStateCalcPressure.__dict__[attrname]) == property:
            return IVAStateCalcPressure.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcPressure.")
    

agcls.AgClassCatalog.add_catalog_entry("{C37E82D4-7AA9-4BA0-92DA-1372268F63D6}", IVAStateCalcPressure)
agcls.AgTypeNameMap["IVAStateCalcPressure"] = IVAStateCalcPressure

class IVAStateCalcTemperature(object):
    """Properties for a Tank Temperature calculation object."""
    _uuid = "{E0EC7C19-B337-4BFD-9A8B-30A88784D697}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcTemperature._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcTemperature from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcTemperature = agcom.GUID(IVAStateCalcTemperature._uuid)
        vtable_offset_local = IVAStateCalcTemperature._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcTemperature.__dict__ and type(IVAStateCalcTemperature.__dict__[attrname]) == property:
            return IVAStateCalcTemperature.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcTemperature.")
    

agcls.AgClassCatalog.add_catalog_entry("{E0EC7C19-B337-4BFD-9A8B-30A88784D697}", IVAStateCalcTemperature)
agcls.AgTypeNameMap["IVAStateCalcTemperature"] = IVAStateCalcTemperature

class IVAStateCalcVectorX(object):
    """Properties for a Vector X calculation object."""
    _uuid = "{ADD32358-B55C-4758-BBB9-391728F24BB8}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCoordAxesName"] = _raise_uninitialized_error
        self.__dict__["_SetCoordAxesName"] = _raise_uninitialized_error
        self.__dict__["_GetVectorName"] = _raise_uninitialized_error
        self.__dict__["_SetVectorName"] = _raise_uninitialized_error
        self.__dict__["_GetUnitDimension"] = _raise_uninitialized_error
        self.__dict__["_SetUnitDimension"] = _raise_uninitialized_error
        self.__dict__["_GetNormalize"] = _raise_uninitialized_error
        self.__dict__["_SetNormalize"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcVectorX._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcVectorX from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcVectorX = agcom.GUID(IVAStateCalcVectorX._uuid)
        vtable_offset_local = IVAStateCalcVectorX._vtable_offset - 1
        self.__dict__["_GetCoordAxesName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVectorX, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCoordAxesName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVectorX, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetVectorName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVectorX, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetVectorName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVectorX, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_GetUnitDimension"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVectorX, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_SetUnitDimension"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVectorX, vtable_offset_local+6, agcom.BSTR)
        self.__dict__["_GetNormalize"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVectorX, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetNormalize"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVectorX, vtable_offset_local+8, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcVectorX.__dict__ and type(IVAStateCalcVectorX.__dict__[attrname]) == property:
            return IVAStateCalcVectorX.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcVectorX.")
    
    @property
    def CoordAxesName(self) -> str:
        """The coordinate axes."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordAxesName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordAxesName.setter
    def CoordAxesName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordAxesName"](arg_inVal.COM_val))

    @property
    def VectorName(self) -> str:
        """The vector."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VectorName.setter
    def VectorName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVectorName"](arg_inVal.COM_val))

    @property
    def UnitDimension(self) -> str:
        """The unit dimension."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUnitDimension"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UnitDimension.setter
    def UnitDimension(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUnitDimension"](arg_inVal.COM_val))

    @property
    def Normalize(self) -> bool:
        """If true, return the normalized magnitude."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNormalize"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Normalize.setter
    def Normalize(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetNormalize"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{ADD32358-B55C-4758-BBB9-391728F24BB8}", IVAStateCalcVectorX)
agcls.AgTypeNameMap["IVAStateCalcVectorX"] = IVAStateCalcVectorX

class IVAStateCalcVectorY(object):
    """Properties for a Vector Y calculation object."""
    _uuid = "{BCF6F352-A2ED-491B-9961-5A164D6B5388}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCoordAxesName"] = _raise_uninitialized_error
        self.__dict__["_SetCoordAxesName"] = _raise_uninitialized_error
        self.__dict__["_GetVectorName"] = _raise_uninitialized_error
        self.__dict__["_SetVectorName"] = _raise_uninitialized_error
        self.__dict__["_GetUnitDimension"] = _raise_uninitialized_error
        self.__dict__["_SetUnitDimension"] = _raise_uninitialized_error
        self.__dict__["_GetNormalize"] = _raise_uninitialized_error
        self.__dict__["_SetNormalize"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcVectorY._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcVectorY from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcVectorY = agcom.GUID(IVAStateCalcVectorY._uuid)
        vtable_offset_local = IVAStateCalcVectorY._vtable_offset - 1
        self.__dict__["_GetCoordAxesName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVectorY, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCoordAxesName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVectorY, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetVectorName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVectorY, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetVectorName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVectorY, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_GetUnitDimension"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVectorY, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_SetUnitDimension"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVectorY, vtable_offset_local+6, agcom.BSTR)
        self.__dict__["_GetNormalize"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVectorY, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetNormalize"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVectorY, vtable_offset_local+8, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcVectorY.__dict__ and type(IVAStateCalcVectorY.__dict__[attrname]) == property:
            return IVAStateCalcVectorY.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcVectorY.")
    
    @property
    def CoordAxesName(self) -> str:
        """The coordinate axes."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordAxesName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordAxesName.setter
    def CoordAxesName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordAxesName"](arg_inVal.COM_val))

    @property
    def VectorName(self) -> str:
        """The vector."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VectorName.setter
    def VectorName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVectorName"](arg_inVal.COM_val))

    @property
    def UnitDimension(self) -> str:
        """The unit dimension."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUnitDimension"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UnitDimension.setter
    def UnitDimension(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUnitDimension"](arg_inVal.COM_val))

    @property
    def Normalize(self) -> bool:
        """If true, return the normalized magnitude."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNormalize"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Normalize.setter
    def Normalize(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetNormalize"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{BCF6F352-A2ED-491B-9961-5A164D6B5388}", IVAStateCalcVectorY)
agcls.AgTypeNameMap["IVAStateCalcVectorY"] = IVAStateCalcVectorY

class IVAStateCalcVectorZ(object):
    """Properties for a Vector Z calculation object."""
    _uuid = "{7F7E2A8A-7A33-48E3-A622-1A23E2672102}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCoordAxesName"] = _raise_uninitialized_error
        self.__dict__["_SetCoordAxesName"] = _raise_uninitialized_error
        self.__dict__["_GetVectorName"] = _raise_uninitialized_error
        self.__dict__["_SetVectorName"] = _raise_uninitialized_error
        self.__dict__["_GetUnitDimension"] = _raise_uninitialized_error
        self.__dict__["_SetUnitDimension"] = _raise_uninitialized_error
        self.__dict__["_GetNormalize"] = _raise_uninitialized_error
        self.__dict__["_SetNormalize"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcVectorZ._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcVectorZ from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcVectorZ = agcom.GUID(IVAStateCalcVectorZ._uuid)
        vtable_offset_local = IVAStateCalcVectorZ._vtable_offset - 1
        self.__dict__["_GetCoordAxesName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVectorZ, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCoordAxesName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVectorZ, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetVectorName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVectorZ, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetVectorName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVectorZ, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_GetUnitDimension"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVectorZ, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_SetUnitDimension"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVectorZ, vtable_offset_local+6, agcom.BSTR)
        self.__dict__["_GetNormalize"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVectorZ, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetNormalize"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVectorZ, vtable_offset_local+8, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcVectorZ.__dict__ and type(IVAStateCalcVectorZ.__dict__[attrname]) == property:
            return IVAStateCalcVectorZ.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcVectorZ.")
    
    @property
    def CoordAxesName(self) -> str:
        """The coordinate axes."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordAxesName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordAxesName.setter
    def CoordAxesName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordAxesName"](arg_inVal.COM_val))

    @property
    def VectorName(self) -> str:
        """The vector."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VectorName.setter
    def VectorName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVectorName"](arg_inVal.COM_val))

    @property
    def UnitDimension(self) -> str:
        """The unit dimension."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUnitDimension"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UnitDimension.setter
    def UnitDimension(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUnitDimension"](arg_inVal.COM_val))

    @property
    def Normalize(self) -> bool:
        """If true, return the normalized magnitude."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNormalize"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Normalize.setter
    def Normalize(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetNormalize"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7F7E2A8A-7A33-48E3-A622-1A23E2672102}", IVAStateCalcVectorZ)
agcls.AgTypeNameMap["IVAStateCalcVectorZ"] = IVAStateCalcVectorZ

class IVAStateCalcMass(object):
    """Properties for a Total Mass calculation object."""
    _uuid = "{1C324BE8-C857-42F2-AFA9-88AD686E53CE}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcMass._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcMass from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcMass = agcom.GUID(IVAStateCalcMass._uuid)
        vtable_offset_local = IVAStateCalcMass._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcMass.__dict__ and type(IVAStateCalcMass.__dict__[attrname]) == property:
            return IVAStateCalcMass.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcMass.")
    

agcls.AgClassCatalog.add_catalog_entry("{1C324BE8-C857-42F2-AFA9-88AD686E53CE}", IVAStateCalcMass)
agcls.AgTypeNameMap["IVAStateCalcMass"] = IVAStateCalcMass

class IVAStateCalcManeuverTotalMassFlowRate(object):
    """Properties for a Total Mass Flow Rate calculation object."""
    _uuid = "{DFD18CDB-7478-4CB0-86B3-46870753D290}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcManeuverTotalMassFlowRate._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcManeuverTotalMassFlowRate from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcManeuverTotalMassFlowRate = agcom.GUID(IVAStateCalcManeuverTotalMassFlowRate._uuid)
        vtable_offset_local = IVAStateCalcManeuverTotalMassFlowRate._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcManeuverTotalMassFlowRate.__dict__ and type(IVAStateCalcManeuverTotalMassFlowRate.__dict__[attrname]) == property:
            return IVAStateCalcManeuverTotalMassFlowRate.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcManeuverTotalMassFlowRate.")
    

agcls.AgClassCatalog.add_catalog_entry("{DFD18CDB-7478-4CB0-86B3-46870753D290}", IVAStateCalcManeuverTotalMassFlowRate)
agcls.AgTypeNameMap["IVAStateCalcManeuverTotalMassFlowRate"] = IVAStateCalcManeuverTotalMassFlowRate

class IVAStateCalcAbsoluteValue(object):
    """Properties for an Absolute Value calculation object."""
    _uuid = "{214DD350-1B42-48C1-9720-66D109A5376B}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCalcObjectName"] = _raise_uninitialized_error
        self.__dict__["_SetCalcObjectName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcAbsoluteValue._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcAbsoluteValue from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcAbsoluteValue = agcom.GUID(IVAStateCalcAbsoluteValue._uuid)
        vtable_offset_local = IVAStateCalcAbsoluteValue._vtable_offset - 1
        self.__dict__["_GetCalcObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcAbsoluteValue, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCalcObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcAbsoluteValue, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcAbsoluteValue.__dict__ and type(IVAStateCalcAbsoluteValue.__dict__[attrname]) == property:
            return IVAStateCalcAbsoluteValue.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcAbsoluteValue.")
    
    @property
    def CalcObjectName(self) -> str:
        """The calculation object."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCalcObjectName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CalcObjectName.setter
    def CalcObjectName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCalcObjectName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{214DD350-1B42-48C1-9720-66D109A5376B}", IVAStateCalcAbsoluteValue)
agcls.AgTypeNameMap["IVAStateCalcAbsoluteValue"] = IVAStateCalcAbsoluteValue

class IVAStateCalcDifference(object):
    """Properties for a Difference calculation object."""
    _uuid = "{4236F99F-8B4C-495E-BC83-41C4B0F1630E}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCalcObjectName"] = _raise_uninitialized_error
        self.__dict__["_SetCalcObjectName"] = _raise_uninitialized_error
        self.__dict__["_GetDifferenceOrder"] = _raise_uninitialized_error
        self.__dict__["_SetDifferenceOrder"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcDifference._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcDifference from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcDifference = agcom.GUID(IVAStateCalcDifference._uuid)
        vtable_offset_local = IVAStateCalcDifference._vtable_offset - 1
        self.__dict__["_GetCalcObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDifference, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCalcObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDifference, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetDifferenceOrder"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDifference, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetDifferenceOrder"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDifference, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcDifference.__dict__ and type(IVAStateCalcDifference.__dict__[attrname]) == property:
            return IVAStateCalcDifference.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcDifference.")
    
    @property
    def CalcObjectName(self) -> str:
        """The calculation object."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCalcObjectName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CalcObjectName.setter
    def CalcObjectName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCalcObjectName"](arg_inVal.COM_val))

    @property
    def DifferenceOrder(self) -> "AgEVADifferenceOrder":
        """The order of the difference calculation."""
        with agmarshall.AgEnum_arg(AgEVADifferenceOrder) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDifferenceOrder"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DifferenceOrder.setter
    def DifferenceOrder(self, inVal:"AgEVADifferenceOrder") -> None:
        with agmarshall.AgEnum_arg(AgEVADifferenceOrder, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDifferenceOrder"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4236F99F-8B4C-495E-BC83-41C4B0F1630E}", IVAStateCalcDifference)
agcls.AgTypeNameMap["IVAStateCalcDifference"] = IVAStateCalcDifference

class IVAStateCalcDifferenceOtherSegment(object):
    """Properties for a Difference Across Segments calculation object."""
    _uuid = "{E5A6D40B-34F4-4325-AC8F-EE183AC7BA96}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCalcObjectName"] = _raise_uninitialized_error
        self.__dict__["_SetCalcObjectName"] = _raise_uninitialized_error
        self.__dict__["_GetOtherSegmentName"] = _raise_uninitialized_error
        self.__dict__["_SetOtherSegmentName"] = _raise_uninitialized_error
        self.__dict__["_GetSegmentStateToUse"] = _raise_uninitialized_error
        self.__dict__["_SetSegmentStateToUse"] = _raise_uninitialized_error
        self.__dict__["_GetDifferenceOrder"] = _raise_uninitialized_error
        self.__dict__["_SetDifferenceOrder"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcDifferenceOtherSegment._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcDifferenceOtherSegment from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcDifferenceOtherSegment = agcom.GUID(IVAStateCalcDifferenceOtherSegment._uuid)
        vtable_offset_local = IVAStateCalcDifferenceOtherSegment._vtable_offset - 1
        self.__dict__["_GetCalcObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDifferenceOtherSegment, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCalcObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDifferenceOtherSegment, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetOtherSegmentName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDifferenceOtherSegment, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetOtherSegmentName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDifferenceOtherSegment, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_GetSegmentStateToUse"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDifferenceOtherSegment, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetSegmentStateToUse"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDifferenceOtherSegment, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetDifferenceOrder"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDifferenceOtherSegment, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetDifferenceOrder"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDifferenceOtherSegment, vtable_offset_local+8, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcDifferenceOtherSegment.__dict__ and type(IVAStateCalcDifferenceOtherSegment.__dict__[attrname]) == property:
            return IVAStateCalcDifferenceOtherSegment.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcDifferenceOtherSegment.")
    
    @property
    def CalcObjectName(self) -> str:
        """The calculation object."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCalcObjectName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CalcObjectName.setter
    def CalcObjectName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCalcObjectName"](arg_inVal.COM_val))

    @property
    def OtherSegmentName(self) -> str:
        """The segment to be compared against."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetOtherSegmentName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @OtherSegmentName.setter
    def OtherSegmentName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetOtherSegmentName"](arg_inVal.COM_val))

    @property
    def SegmentStateToUse(self) -> "AgEVASegmentState":
        """The segment state to use in the calculation."""
        with agmarshall.AgEnum_arg(AgEVASegmentState) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSegmentStateToUse"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SegmentStateToUse.setter
    def SegmentStateToUse(self, inVal:"AgEVASegmentState") -> None:
        with agmarshall.AgEnum_arg(AgEVASegmentState, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSegmentStateToUse"](arg_inVal.COM_val))

    @property
    def DifferenceOrder(self) -> "AgEVASegmentDifferenceOrder":
        """The order of the difference calculation."""
        with agmarshall.AgEnum_arg(AgEVASegmentDifferenceOrder) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDifferenceOrder"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DifferenceOrder.setter
    def DifferenceOrder(self, inVal:"AgEVASegmentDifferenceOrder") -> None:
        with agmarshall.AgEnum_arg(AgEVASegmentDifferenceOrder, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDifferenceOrder"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E5A6D40B-34F4-4325-AC8F-EE183AC7BA96}", IVAStateCalcDifferenceOtherSegment)
agcls.AgTypeNameMap["IVAStateCalcDifferenceOtherSegment"] = IVAStateCalcDifferenceOtherSegment

class IVAStateCalcPosDifferenceOtherSegment(object):
    """Properties for a Position Difference Across Segments calculation object."""
    _uuid = "{168CD10A-F726-450F-A63F-E00A85FDEF87}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOtherSegmentName"] = _raise_uninitialized_error
        self.__dict__["_SetOtherSegmentName"] = _raise_uninitialized_error
        self.__dict__["_GetSegmentStateToUse"] = _raise_uninitialized_error
        self.__dict__["_SetSegmentStateToUse"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcPosDifferenceOtherSegment._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcPosDifferenceOtherSegment from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcPosDifferenceOtherSegment = agcom.GUID(IVAStateCalcPosDifferenceOtherSegment._uuid)
        vtable_offset_local = IVAStateCalcPosDifferenceOtherSegment._vtable_offset - 1
        self.__dict__["_GetOtherSegmentName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcPosDifferenceOtherSegment, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetOtherSegmentName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcPosDifferenceOtherSegment, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetSegmentStateToUse"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcPosDifferenceOtherSegment, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetSegmentStateToUse"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcPosDifferenceOtherSegment, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcPosDifferenceOtherSegment.__dict__ and type(IVAStateCalcPosDifferenceOtherSegment.__dict__[attrname]) == property:
            return IVAStateCalcPosDifferenceOtherSegment.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcPosDifferenceOtherSegment.")
    
    @property
    def OtherSegmentName(self) -> str:
        """The segment to be compared against."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetOtherSegmentName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @OtherSegmentName.setter
    def OtherSegmentName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetOtherSegmentName"](arg_inVal.COM_val))

    @property
    def SegmentStateToUse(self) -> "AgEVASegmentState":
        """The segment state to use in the calculation."""
        with agmarshall.AgEnum_arg(AgEVASegmentState) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSegmentStateToUse"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SegmentStateToUse.setter
    def SegmentStateToUse(self, inVal:"AgEVASegmentState") -> None:
        with agmarshall.AgEnum_arg(AgEVASegmentState, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSegmentStateToUse"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{168CD10A-F726-450F-A63F-E00A85FDEF87}", IVAStateCalcPosDifferenceOtherSegment)
agcls.AgTypeNameMap["IVAStateCalcPosDifferenceOtherSegment"] = IVAStateCalcPosDifferenceOtherSegment

class IVAStateCalcVelDifferenceOtherSegment(object):
    """Properties for a Velocity Difference Across Segments calculation object."""
    _uuid = "{9BE8161D-7D1A-4FF6-8B63-C160E22844D1}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOtherSegmentName"] = _raise_uninitialized_error
        self.__dict__["_SetOtherSegmentName"] = _raise_uninitialized_error
        self.__dict__["_GetSegmentStateToUse"] = _raise_uninitialized_error
        self.__dict__["_SetSegmentStateToUse"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcVelDifferenceOtherSegment._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcVelDifferenceOtherSegment from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcVelDifferenceOtherSegment = agcom.GUID(IVAStateCalcVelDifferenceOtherSegment._uuid)
        vtable_offset_local = IVAStateCalcVelDifferenceOtherSegment._vtable_offset - 1
        self.__dict__["_GetOtherSegmentName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVelDifferenceOtherSegment, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetOtherSegmentName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVelDifferenceOtherSegment, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetSegmentStateToUse"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVelDifferenceOtherSegment, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetSegmentStateToUse"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVelDifferenceOtherSegment, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcVelDifferenceOtherSegment.__dict__ and type(IVAStateCalcVelDifferenceOtherSegment.__dict__[attrname]) == property:
            return IVAStateCalcVelDifferenceOtherSegment.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcVelDifferenceOtherSegment.")
    
    @property
    def OtherSegmentName(self) -> str:
        """The segment to be compared against."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetOtherSegmentName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @OtherSegmentName.setter
    def OtherSegmentName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetOtherSegmentName"](arg_inVal.COM_val))

    @property
    def SegmentStateToUse(self) -> "AgEVASegmentState":
        """The segment state to use in the calculation."""
        with agmarshall.AgEnum_arg(AgEVASegmentState) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSegmentStateToUse"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SegmentStateToUse.setter
    def SegmentStateToUse(self, inVal:"AgEVASegmentState") -> None:
        with agmarshall.AgEnum_arg(AgEVASegmentState, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSegmentStateToUse"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{9BE8161D-7D1A-4FF6-8B63-C160E22844D1}", IVAStateCalcVelDifferenceOtherSegment)
agcls.AgTypeNameMap["IVAStateCalcVelDifferenceOtherSegment"] = IVAStateCalcVelDifferenceOtherSegment

class IVAStateCalcPosVelDifferenceOtherSegment(object):
    """Properties for a Position and Velocity Difference Across Segments calculation object."""
    _uuid = "{58BA297D-0E89-46C4-9C9B-E8E7EA2B23AC}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetOtherSegmentName"] = _raise_uninitialized_error
        self.__dict__["_SetOtherSegmentName"] = _raise_uninitialized_error
        self.__dict__["_GetSegmentStateToUse"] = _raise_uninitialized_error
        self.__dict__["_SetSegmentStateToUse"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcPosVelDifferenceOtherSegment._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcPosVelDifferenceOtherSegment from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcPosVelDifferenceOtherSegment = agcom.GUID(IVAStateCalcPosVelDifferenceOtherSegment._uuid)
        vtable_offset_local = IVAStateCalcPosVelDifferenceOtherSegment._vtable_offset - 1
        self.__dict__["_GetOtherSegmentName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcPosVelDifferenceOtherSegment, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetOtherSegmentName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcPosVelDifferenceOtherSegment, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetSegmentStateToUse"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcPosVelDifferenceOtherSegment, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetSegmentStateToUse"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcPosVelDifferenceOtherSegment, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcPosVelDifferenceOtherSegment.__dict__ and type(IVAStateCalcPosVelDifferenceOtherSegment.__dict__[attrname]) == property:
            return IVAStateCalcPosVelDifferenceOtherSegment.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcPosVelDifferenceOtherSegment.")
    
    @property
    def OtherSegmentName(self) -> str:
        """The segment to be compared against."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetOtherSegmentName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @OtherSegmentName.setter
    def OtherSegmentName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetOtherSegmentName"](arg_inVal.COM_val))

    @property
    def SegmentStateToUse(self) -> "AgEVASegmentState":
        """The segment state to use in the calculation."""
        with agmarshall.AgEnum_arg(AgEVASegmentState) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSegmentStateToUse"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SegmentStateToUse.setter
    def SegmentStateToUse(self, inVal:"AgEVASegmentState") -> None:
        with agmarshall.AgEnum_arg(AgEVASegmentState, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSegmentStateToUse"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{58BA297D-0E89-46C4-9C9B-E8E7EA2B23AC}", IVAStateCalcPosVelDifferenceOtherSegment)
agcls.AgTypeNameMap["IVAStateCalcPosVelDifferenceOtherSegment"] = IVAStateCalcPosVelDifferenceOtherSegment

class IVAStateCalcValueAtSegment(object):
    """Properties for a Value At Segment calculation object."""
    _uuid = "{950DEE79-D37E-4EE5-AB69-6E145AAFB9AC}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCalcObjectName"] = _raise_uninitialized_error
        self.__dict__["_SetCalcObjectName"] = _raise_uninitialized_error
        self.__dict__["_GetOtherSegmentName"] = _raise_uninitialized_error
        self.__dict__["_SetOtherSegmentName"] = _raise_uninitialized_error
        self.__dict__["_GetSegmentStateToUse"] = _raise_uninitialized_error
        self.__dict__["_SetSegmentStateToUse"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcValueAtSegment._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcValueAtSegment from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcValueAtSegment = agcom.GUID(IVAStateCalcValueAtSegment._uuid)
        vtable_offset_local = IVAStateCalcValueAtSegment._vtable_offset - 1
        self.__dict__["_GetCalcObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcValueAtSegment, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCalcObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcValueAtSegment, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetOtherSegmentName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcValueAtSegment, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetOtherSegmentName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcValueAtSegment, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_GetSegmentStateToUse"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcValueAtSegment, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetSegmentStateToUse"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcValueAtSegment, vtable_offset_local+6, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcValueAtSegment.__dict__ and type(IVAStateCalcValueAtSegment.__dict__[attrname]) == property:
            return IVAStateCalcValueAtSegment.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcValueAtSegment.")
    
    @property
    def CalcObjectName(self) -> str:
        """The calculation object."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCalcObjectName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CalcObjectName.setter
    def CalcObjectName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCalcObjectName"](arg_inVal.COM_val))

    @property
    def OtherSegmentName(self) -> str:
        """The segment to be compared against."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetOtherSegmentName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @OtherSegmentName.setter
    def OtherSegmentName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetOtherSegmentName"](arg_inVal.COM_val))

    @property
    def SegmentStateToUse(self) -> "AgEVASegmentState":
        """The segment state to use in the calculation."""
        with agmarshall.AgEnum_arg(AgEVASegmentState) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSegmentStateToUse"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SegmentStateToUse.setter
    def SegmentStateToUse(self, inVal:"AgEVASegmentState") -> None:
        with agmarshall.AgEnum_arg(AgEVASegmentState, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSegmentStateToUse"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{950DEE79-D37E-4EE5-AB69-6E145AAFB9AC}", IVAStateCalcValueAtSegment)
agcls.AgTypeNameMap["IVAStateCalcValueAtSegment"] = IVAStateCalcValueAtSegment

class IVAStateCalcMaxValue(object):
    """Properties for a Maximum Value calculation object."""
    _uuid = "{A7B9EBBB-D87A-4F04-8DE3-E7812F322B66}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCalcObjectName"] = _raise_uninitialized_error
        self.__dict__["_SetCalcObjectName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcMaxValue._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcMaxValue from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcMaxValue = agcom.GUID(IVAStateCalcMaxValue._uuid)
        vtable_offset_local = IVAStateCalcMaxValue._vtable_offset - 1
        self.__dict__["_GetCalcObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcMaxValue, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCalcObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcMaxValue, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcMaxValue.__dict__ and type(IVAStateCalcMaxValue.__dict__[attrname]) == property:
            return IVAStateCalcMaxValue.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcMaxValue.")
    
    @property
    def CalcObjectName(self) -> str:
        """The calculation  object."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCalcObjectName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CalcObjectName.setter
    def CalcObjectName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCalcObjectName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{A7B9EBBB-D87A-4F04-8DE3-E7812F322B66}", IVAStateCalcMaxValue)
agcls.AgTypeNameMap["IVAStateCalcMaxValue"] = IVAStateCalcMaxValue

class IVAStateCalcMinValue(object):
    """Properties for a Minimum Value calculation object."""
    _uuid = "{22B15669-D363-4C73-87AE-424E1DF37ABA}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCalcObjectName"] = _raise_uninitialized_error
        self.__dict__["_SetCalcObjectName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcMinValue._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcMinValue from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcMinValue = agcom.GUID(IVAStateCalcMinValue._uuid)
        vtable_offset_local = IVAStateCalcMinValue._vtable_offset - 1
        self.__dict__["_GetCalcObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcMinValue, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCalcObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcMinValue, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcMinValue.__dict__ and type(IVAStateCalcMinValue.__dict__[attrname]) == property:
            return IVAStateCalcMinValue.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcMinValue.")
    
    @property
    def CalcObjectName(self) -> str:
        """The calculation  object."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCalcObjectName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CalcObjectName.setter
    def CalcObjectName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCalcObjectName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{22B15669-D363-4C73-87AE-424E1DF37ABA}", IVAStateCalcMinValue)
agcls.AgTypeNameMap["IVAStateCalcMinValue"] = IVAStateCalcMinValue

class IVAStateCalcMeanValue(object):
    """Properties for a Mean Value calculation object."""
    _uuid = "{7523BA0F-0B19-4660-8785-D9C23F29CB1C}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCalcObjectName"] = _raise_uninitialized_error
        self.__dict__["_SetCalcObjectName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcMeanValue._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcMeanValue from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcMeanValue = agcom.GUID(IVAStateCalcMeanValue._uuid)
        vtable_offset_local = IVAStateCalcMeanValue._vtable_offset - 1
        self.__dict__["_GetCalcObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcMeanValue, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCalcObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcMeanValue, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcMeanValue.__dict__ and type(IVAStateCalcMeanValue.__dict__[attrname]) == property:
            return IVAStateCalcMeanValue.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcMeanValue.")
    
    @property
    def CalcObjectName(self) -> str:
        """The calculation  object."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCalcObjectName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CalcObjectName.setter
    def CalcObjectName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCalcObjectName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7523BA0F-0B19-4660-8785-D9C23F29CB1C}", IVAStateCalcMeanValue)
agcls.AgTypeNameMap["IVAStateCalcMeanValue"] = IVAStateCalcMeanValue

class IVAStateCalcMedianValue(object):
    """Properties for a Median Value calculation object."""
    _uuid = "{3B7D51C9-5395-4AAA-828D-2AFF5CAB5676}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCalcObjectName"] = _raise_uninitialized_error
        self.__dict__["_SetCalcObjectName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcMedianValue._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcMedianValue from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcMedianValue = agcom.GUID(IVAStateCalcMedianValue._uuid)
        vtable_offset_local = IVAStateCalcMedianValue._vtable_offset - 1
        self.__dict__["_GetCalcObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcMedianValue, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCalcObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcMedianValue, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcMedianValue.__dict__ and type(IVAStateCalcMedianValue.__dict__[attrname]) == property:
            return IVAStateCalcMedianValue.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcMedianValue.")
    
    @property
    def CalcObjectName(self) -> str:
        """The calculation  object."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCalcObjectName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CalcObjectName.setter
    def CalcObjectName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCalcObjectName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3B7D51C9-5395-4AAA-828D-2AFF5CAB5676}", IVAStateCalcMedianValue)
agcls.AgTypeNameMap["IVAStateCalcMedianValue"] = IVAStateCalcMedianValue

class IVAStateCalcStandardDeviation(object):
    """Properties for a Standard Deviation calculation object."""
    _uuid = "{41847821-7A1E-46E9-AC78-B50A3D1D1500}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCalcObjectName"] = _raise_uninitialized_error
        self.__dict__["_SetCalcObjectName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcStandardDeviation._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcStandardDeviation from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcStandardDeviation = agcom.GUID(IVAStateCalcStandardDeviation._uuid)
        vtable_offset_local = IVAStateCalcStandardDeviation._vtable_offset - 1
        self.__dict__["_GetCalcObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcStandardDeviation, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCalcObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcStandardDeviation, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcStandardDeviation.__dict__ and type(IVAStateCalcStandardDeviation.__dict__[attrname]) == property:
            return IVAStateCalcStandardDeviation.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcStandardDeviation.")
    
    @property
    def CalcObjectName(self) -> str:
        """The calculation  object."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCalcObjectName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CalcObjectName.setter
    def CalcObjectName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCalcObjectName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{41847821-7A1E-46E9-AC78-B50A3D1D1500}", IVAStateCalcStandardDeviation)
agcls.AgTypeNameMap["IVAStateCalcStandardDeviation"] = IVAStateCalcStandardDeviation

class IVAStateCalcNegative(object):
    """Properties for a Negative calculation object."""
    _uuid = "{AE894289-670C-4C3F-8EAB-ABD6056919F2}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCalcObjectName"] = _raise_uninitialized_error
        self.__dict__["_SetCalcObjectName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcNegative._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcNegative from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcNegative = agcom.GUID(IVAStateCalcNegative._uuid)
        vtable_offset_local = IVAStateCalcNegative._vtable_offset - 1
        self.__dict__["_GetCalcObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcNegative, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCalcObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcNegative, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcNegative.__dict__ and type(IVAStateCalcNegative.__dict__[attrname]) == property:
            return IVAStateCalcNegative.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcNegative.")
    
    @property
    def CalcObjectName(self) -> str:
        """The calculation  object."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCalcObjectName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CalcObjectName.setter
    def CalcObjectName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCalcObjectName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{AE894289-670C-4C3F-8EAB-ABD6056919F2}", IVAStateCalcNegative)
agcls.AgTypeNameMap["IVAStateCalcNegative"] = IVAStateCalcNegative

class IVAStateCalcTrueAnomaly(object):
    """Properties for a Mean True Anomaly calculation object."""
    _uuid = "{639BD92E-793C-49C3-A72C-3456824F43EE}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetElementType"] = _raise_uninitialized_error
        self.__dict__["_SetElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcTrueAnomaly._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcTrueAnomaly from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcTrueAnomaly = agcom.GUID(IVAStateCalcTrueAnomaly._uuid)
        vtable_offset_local = IVAStateCalcTrueAnomaly._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcTrueAnomaly, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcTrueAnomaly, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcTrueAnomaly, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcTrueAnomaly, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcTrueAnomaly.__dict__ and type(IVAStateCalcTrueAnomaly.__dict__[attrname]) == property:
            return IVAStateCalcTrueAnomaly.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcTrueAnomaly.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def ElementType(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElementType.setter
    def ElementType(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetElementType"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{639BD92E-793C-49C3-A72C-3456824F43EE}", IVAStateCalcTrueAnomaly)
agcls.AgTypeNameMap["IVAStateCalcTrueAnomaly"] = IVAStateCalcTrueAnomaly

class IVABDotRCalc(object):
    """Properties for a BDotR calculation object."""
    _uuid = "{BE67DDCF-6371-4275-996C-5DDB200E3B3F}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTargetBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetTargetBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetRefVectorName"] = _raise_uninitialized_error
        self.__dict__["_SetRefVectorName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVABDotRCalc._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVABDotRCalc from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVABDotRCalc = agcom.GUID(IVABDotRCalc._uuid)
        vtable_offset_local = IVABDotRCalc._vtable_offset - 1
        self.__dict__["_GetTargetBodyName"] = IAGFUNCTYPE(pUnk, IID_IVABDotRCalc, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetTargetBodyName"] = IAGFUNCTYPE(pUnk, IID_IVABDotRCalc, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetRefVectorName"] = IAGFUNCTYPE(pUnk, IID_IVABDotRCalc, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetRefVectorName"] = IAGFUNCTYPE(pUnk, IID_IVABDotRCalc, vtable_offset_local+4, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVABDotRCalc.__dict__ and type(IVABDotRCalc.__dict__[attrname]) == property:
            return IVABDotRCalc.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVABDotRCalc.")
    
    @property
    def TargetBodyName(self) -> str:
        """The target body for B-plane computation."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TargetBodyName.setter
    def TargetBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetTargetBodyName"](arg_inVal.COM_val))

    @property
    def RefVectorName(self) -> str:
        """The reference vector to use to define the B-plane."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRefVectorName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RefVectorName.setter
    def RefVectorName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetRefVectorName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{BE67DDCF-6371-4275-996C-5DDB200E3B3F}", IVABDotRCalc)
agcls.AgTypeNameMap["IVABDotRCalc"] = IVABDotRCalc

class IVABDotTCalc(object):
    """Properties for a BDotT calculation object."""
    _uuid = "{E9BE921C-D864-4019-A3E7-A54DA59502FD}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTargetBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetTargetBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetRefVectorName"] = _raise_uninitialized_error
        self.__dict__["_SetRefVectorName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVABDotTCalc._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVABDotTCalc from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVABDotTCalc = agcom.GUID(IVABDotTCalc._uuid)
        vtable_offset_local = IVABDotTCalc._vtable_offset - 1
        self.__dict__["_GetTargetBodyName"] = IAGFUNCTYPE(pUnk, IID_IVABDotTCalc, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetTargetBodyName"] = IAGFUNCTYPE(pUnk, IID_IVABDotTCalc, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetRefVectorName"] = IAGFUNCTYPE(pUnk, IID_IVABDotTCalc, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetRefVectorName"] = IAGFUNCTYPE(pUnk, IID_IVABDotTCalc, vtable_offset_local+4, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVABDotTCalc.__dict__ and type(IVABDotTCalc.__dict__[attrname]) == property:
            return IVABDotTCalc.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVABDotTCalc.")
    
    @property
    def TargetBodyName(self) -> str:
        """The target body for B-plane computation."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TargetBodyName.setter
    def TargetBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetTargetBodyName"](arg_inVal.COM_val))

    @property
    def RefVectorName(self) -> str:
        """The reference vector to use to define the B-plane."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRefVectorName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RefVectorName.setter
    def RefVectorName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetRefVectorName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E9BE921C-D864-4019-A3E7-A54DA59502FD}", IVABDotTCalc)
agcls.AgTypeNameMap["IVABDotTCalc"] = IVABDotTCalc

class IVABMagCalc(object):
    """Properties for a BMagnitude calculation object."""
    _uuid = "{7D570198-8048-407E-B532-B7B2B86860C1}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTargetBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetTargetBodyName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVABMagCalc._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVABMagCalc from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVABMagCalc = agcom.GUID(IVABMagCalc._uuid)
        vtable_offset_local = IVABMagCalc._vtable_offset - 1
        self.__dict__["_GetTargetBodyName"] = IAGFUNCTYPE(pUnk, IID_IVABMagCalc, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetTargetBodyName"] = IAGFUNCTYPE(pUnk, IID_IVABMagCalc, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVABMagCalc.__dict__ and type(IVABMagCalc.__dict__[attrname]) == property:
            return IVABMagCalc.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVABMagCalc.")
    
    @property
    def TargetBodyName(self) -> str:
        """The target body for B-plane computation."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TargetBodyName.setter
    def TargetBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetTargetBodyName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7D570198-8048-407E-B532-B7B2B86860C1}", IVABMagCalc)
agcls.AgTypeNameMap["IVABMagCalc"] = IVABMagCalc

class IVABThetaCalc(object):
    """Properties for a BTheta calculation object."""
    _uuid = "{F478A128-3084-457F-B098-09114FF32DB8}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetTargetBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetTargetBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetRefVectorName"] = _raise_uninitialized_error
        self.__dict__["_SetRefVectorName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVABThetaCalc._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVABThetaCalc from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVABThetaCalc = agcom.GUID(IVABThetaCalc._uuid)
        vtable_offset_local = IVABThetaCalc._vtable_offset - 1
        self.__dict__["_GetTargetBodyName"] = IAGFUNCTYPE(pUnk, IID_IVABThetaCalc, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetTargetBodyName"] = IAGFUNCTYPE(pUnk, IID_IVABThetaCalc, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetRefVectorName"] = IAGFUNCTYPE(pUnk, IID_IVABThetaCalc, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetRefVectorName"] = IAGFUNCTYPE(pUnk, IID_IVABThetaCalc, vtable_offset_local+4, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVABThetaCalc.__dict__ and type(IVABThetaCalc.__dict__[attrname]) == property:
            return IVABThetaCalc.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVABThetaCalc.")
    
    @property
    def TargetBodyName(self) -> str:
        """The target body for B-plane computation."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TargetBodyName.setter
    def TargetBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetTargetBodyName"](arg_inVal.COM_val))

    @property
    def RefVectorName(self) -> str:
        """The reference vector to use to define the B-plane."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRefVectorName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RefVectorName.setter
    def RefVectorName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetRefVectorName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{F478A128-3084-457F-B098-09114FF32DB8}", IVABThetaCalc)
agcls.AgTypeNameMap["IVABThetaCalc"] = IVABThetaCalc

class IVAStateCalcDeltaDec(object):
    """Properties for a Delta Declination calculation object."""
    _uuid = "{2C14B234-E769-4969-BFA3-54A5AB2C6F89}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceType"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceType"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceBody"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceBody"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcDeltaDec._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcDeltaDec from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcDeltaDec = agcom.GUID(IVAStateCalcDeltaDec._uuid)
        vtable_offset_local = IVAStateCalcDeltaDec._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDeltaDec, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDeltaDec, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetReferenceType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDeltaDec, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetReferenceType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDeltaDec, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetReferenceBody"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDeltaDec, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_SetReferenceBody"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDeltaDec, vtable_offset_local+6, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcDeltaDec.__dict__ and type(IVAStateCalcDeltaDec.__dict__[attrname]) == property:
            return IVAStateCalcDeltaDec.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcDeltaDec.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def ReferenceType(self) -> "AgEVACalcObjectCentralBodyReference":
        """The central body's reference type"""
        with agmarshall.AgEnum_arg(AgEVACalcObjectCentralBodyReference) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ReferenceType.setter
    def ReferenceType(self, inVal:"AgEVACalcObjectCentralBodyReference") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectCentralBodyReference, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceType"](arg_inVal.COM_val))

    @property
    def ReferenceBody(self) -> str:
        """The reference body of the component. Read only when the ReferenceType is eVACalcObjectCentralBodyReferenceParent."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceBody"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ReferenceBody.setter
    def ReferenceBody(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceBody"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2C14B234-E769-4969-BFA3-54A5AB2C6F89}", IVAStateCalcDeltaDec)
agcls.AgTypeNameMap["IVAStateCalcDeltaDec"] = IVAStateCalcDeltaDec

class IVAStateCalcDeltaRA(object):
    """Properties for a Delta Right Asc calculation object."""
    _uuid = "{42FFF17F-F89E-438E-B5C9-0206AD20D09E}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceType"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceType"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceBody"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceBody"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcDeltaRA._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcDeltaRA from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcDeltaRA = agcom.GUID(IVAStateCalcDeltaRA._uuid)
        vtable_offset_local = IVAStateCalcDeltaRA._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDeltaRA, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDeltaRA, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetReferenceType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDeltaRA, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetReferenceType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDeltaRA, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetReferenceBody"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDeltaRA, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_SetReferenceBody"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDeltaRA, vtable_offset_local+6, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcDeltaRA.__dict__ and type(IVAStateCalcDeltaRA.__dict__[attrname]) == property:
            return IVAStateCalcDeltaRA.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcDeltaRA.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def ReferenceType(self) -> "AgEVACalcObjectCentralBodyReference":
        """The central body's reference type"""
        with agmarshall.AgEnum_arg(AgEVACalcObjectCentralBodyReference) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ReferenceType.setter
    def ReferenceType(self, inVal:"AgEVACalcObjectCentralBodyReference") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectCentralBodyReference, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceType"](arg_inVal.COM_val))

    @property
    def ReferenceBody(self) -> str:
        """The reference body of the component. Read only when the ReferenceType is eVACalcObjectCentralBodyReferenceParent."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceBody"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ReferenceBody.setter
    def ReferenceBody(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceBody"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{42FFF17F-F89E-438E-B5C9-0206AD20D09E}", IVAStateCalcDeltaRA)
agcls.AgTypeNameMap["IVAStateCalcDeltaRA"] = IVAStateCalcDeltaRA

class IVAStateCalcBetaAngle(object):
    """Properties for a Beta Angle calculation object."""
    _uuid = "{6D251D91-4555-4C35-B56C-04832CF014E2}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcBetaAngle._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcBetaAngle from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcBetaAngle = agcom.GUID(IVAStateCalcBetaAngle._uuid)
        vtable_offset_local = IVAStateCalcBetaAngle._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcBetaAngle, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcBetaAngle, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcBetaAngle.__dict__ and type(IVAStateCalcBetaAngle.__dict__[attrname]) == property:
            return IVAStateCalcBetaAngle.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcBetaAngle.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{6D251D91-4555-4C35-B56C-04832CF014E2}", IVAStateCalcBetaAngle)
agcls.AgTypeNameMap["IVAStateCalcBetaAngle"] = IVAStateCalcBetaAngle

class IVAStateCalcLocalApparentSolarLon(object):
    """Properties for a Local Apparent Solar Longitude calculation object."""
    _uuid = "{619668AB-B09E-4160-9ED3-1365F3678C60}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcLocalApparentSolarLon._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcLocalApparentSolarLon from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcLocalApparentSolarLon = agcom.GUID(IVAStateCalcLocalApparentSolarLon._uuid)
        vtable_offset_local = IVAStateCalcLocalApparentSolarLon._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcLocalApparentSolarLon, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcLocalApparentSolarLon, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcLocalApparentSolarLon.__dict__ and type(IVAStateCalcLocalApparentSolarLon.__dict__[attrname]) == property:
            return IVAStateCalcLocalApparentSolarLon.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcLocalApparentSolarLon.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{619668AB-B09E-4160-9ED3-1365F3678C60}", IVAStateCalcLocalApparentSolarLon)
agcls.AgTypeNameMap["IVAStateCalcLocalApparentSolarLon"] = IVAStateCalcLocalApparentSolarLon

class IVAStateCalcLonOfPeriapsis(object):
    """Properties for a Longitude of Periapsis calculation object."""
    _uuid = "{1F8ECEB0-EFBE-4A23-8781-9BDEFF119DF0}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_SetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_GetElementType"] = _raise_uninitialized_error
        self.__dict__["_SetElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcLonOfPeriapsis._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcLonOfPeriapsis from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcLonOfPeriapsis = agcom.GUID(IVAStateCalcLonOfPeriapsis._uuid)
        vtable_offset_local = IVAStateCalcLonOfPeriapsis._vtable_offset - 1
        self.__dict__["_GetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcLonOfPeriapsis, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcLonOfPeriapsis, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcLonOfPeriapsis, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcLonOfPeriapsis, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcLonOfPeriapsis.__dict__ and type(IVAStateCalcLonOfPeriapsis.__dict__[attrname]) == property:
            return IVAStateCalcLonOfPeriapsis.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcLonOfPeriapsis.")
    
    @property
    def CoordSystemName(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordSystemName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordSystemName.setter
    def CoordSystemName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordSystemName"](arg_inVal.COM_val))

    @property
    def ElementType(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElementType.setter
    def ElementType(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetElementType"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{1F8ECEB0-EFBE-4A23-8781-9BDEFF119DF0}", IVAStateCalcLonOfPeriapsis)
agcls.AgTypeNameMap["IVAStateCalcLonOfPeriapsis"] = IVAStateCalcLonOfPeriapsis

class IVAStateCalcOrbitStateValue(object):
    """Properties for an Orbit State Value calculation object."""
    _uuid = "{BE928A27-517C-4D52-A681-DA6CFC89E59F}"
    _num_methods = 20
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCalcObjectName"] = _raise_uninitialized_error
        self.__dict__["_SetCalcObjectName"] = _raise_uninitialized_error
        self.__dict__["_GetInputCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_SetInputCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_GetX"] = _raise_uninitialized_error
        self.__dict__["_SetX"] = _raise_uninitialized_error
        self.__dict__["_GetY"] = _raise_uninitialized_error
        self.__dict__["_SetY"] = _raise_uninitialized_error
        self.__dict__["_GetZ"] = _raise_uninitialized_error
        self.__dict__["_SetZ"] = _raise_uninitialized_error
        self.__dict__["_GetVx"] = _raise_uninitialized_error
        self.__dict__["_SetVx"] = _raise_uninitialized_error
        self.__dict__["_GetVy"] = _raise_uninitialized_error
        self.__dict__["_SetVy"] = _raise_uninitialized_error
        self.__dict__["_GetVz"] = _raise_uninitialized_error
        self.__dict__["_SetVz"] = _raise_uninitialized_error
        self.__dict__["_EnableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_DisableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_IsControlParameterEnabled"] = _raise_uninitialized_error
        self.__dict__["_GetControlParametersAvailable"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcOrbitStateValue._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcOrbitStateValue from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcOrbitStateValue = agcom.GUID(IVAStateCalcOrbitStateValue._uuid)
        vtable_offset_local = IVAStateCalcOrbitStateValue._vtable_offset - 1
        self.__dict__["_GetCalcObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitStateValue, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCalcObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitStateValue, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetInputCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitStateValue, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetInputCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitStateValue, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_GetX"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitStateValue, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_SetX"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitStateValue, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_GetY"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitStateValue, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_SetY"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitStateValue, vtable_offset_local+8, agcom.VARIANT)
        self.__dict__["_GetZ"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitStateValue, vtable_offset_local+9, POINTER(agcom.VARIANT))
        self.__dict__["_SetZ"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitStateValue, vtable_offset_local+10, agcom.VARIANT)
        self.__dict__["_GetVx"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitStateValue, vtable_offset_local+11, POINTER(agcom.VARIANT))
        self.__dict__["_SetVx"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitStateValue, vtable_offset_local+12, agcom.VARIANT)
        self.__dict__["_GetVy"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitStateValue, vtable_offset_local+13, POINTER(agcom.VARIANT))
        self.__dict__["_SetVy"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitStateValue, vtable_offset_local+14, agcom.VARIANT)
        self.__dict__["_GetVz"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitStateValue, vtable_offset_local+15, POINTER(agcom.VARIANT))
        self.__dict__["_SetVz"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitStateValue, vtable_offset_local+16, agcom.VARIANT)
        self.__dict__["_EnableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitStateValue, vtable_offset_local+17, agcom.LONG)
        self.__dict__["_DisableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitStateValue, vtable_offset_local+18, agcom.LONG)
        self.__dict__["_IsControlParameterEnabled"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitStateValue, vtable_offset_local+19, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetControlParametersAvailable"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOrbitStateValue, vtable_offset_local+20, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcOrbitStateValue.__dict__ and type(IVAStateCalcOrbitStateValue.__dict__[attrname]) == property:
            return IVAStateCalcOrbitStateValue.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcOrbitStateValue.")
    
    @property
    def CalcObjectName(self) -> str:
        """The calculation object."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCalcObjectName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CalcObjectName.setter
    def CalcObjectName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCalcObjectName"](arg_inVal.COM_val))

    @property
    def InputCoordSystemName(self) -> str:
        """The coordinate system of the input state."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetInputCoordSystemName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @InputCoordSystemName.setter
    def InputCoordSystemName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetInputCoordSystemName"](arg_inVal.COM_val))

    @property
    def X(self) -> typing.Any:
        """The x position component. Uses Distance Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetX"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @X.setter
    def X(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetX"](arg_inVal.COM_val))

    @property
    def Y(self) -> typing.Any:
        """The y position component. Uses Distance Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetY"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Y.setter
    def Y(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetY"](arg_inVal.COM_val))

    @property
    def Z(self) -> typing.Any:
        """The z position component. Uses Distance Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetZ"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Z.setter
    def Z(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetZ"](arg_inVal.COM_val))

    @property
    def Vx(self) -> typing.Any:
        """The x velocity component. Uses Rate Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVx"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Vx.setter
    def Vx(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVx"](arg_inVal.COM_val))

    @property
    def Vy(self) -> typing.Any:
        """The y velocity component. Uses Rate Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVy"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Vy.setter
    def Vy(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVy"](arg_inVal.COM_val))

    @property
    def Vz(self) -> typing.Any:
        """The z velocity component. Uses Rate Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVz"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Vz.setter
    def Vz(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVz"](arg_inVal.COM_val))

    def EnableControlParameter(self, param:"AgEVAControlOrbitStateValue") -> None:
        """Enables the specified control parameter"""
        with agmarshall.AgEnum_arg(AgEVAControlOrbitStateValue, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_EnableControlParameter"](arg_param.COM_val))

    def DisableControlParameter(self, param:"AgEVAControlOrbitStateValue") -> None:
        """Disables the specified control parameter"""
        with agmarshall.AgEnum_arg(AgEVAControlOrbitStateValue, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_DisableControlParameter"](arg_param.COM_val))

    def IsControlParameterEnabled(self, param:"AgEVAControlOrbitStateValue") -> bool:
        """Sees if the specified control is enabled"""
        with agmarshall.AgEnum_arg(AgEVAControlOrbitStateValue, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_IsControlParameterEnabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ControlParametersAvailable(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetControlParametersAvailable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{BE928A27-517C-4D52-A681-DA6CFC89E59F}", IVAStateCalcOrbitStateValue)
agcls.AgTypeNameMap["IVAStateCalcOrbitStateValue"] = IVAStateCalcOrbitStateValue

class IVAStateCalcSignedEccentricity(object):
    """Properties for a SignedEccentricity calculation object."""
    _uuid = "{CCBD1A51-0C24-4FEA-936D-F8E173931C30}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetElementType"] = _raise_uninitialized_error
        self.__dict__["_SetElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcSignedEccentricity._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcSignedEccentricity from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcSignedEccentricity = agcom.GUID(IVAStateCalcSignedEccentricity._uuid)
        vtable_offset_local = IVAStateCalcSignedEccentricity._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSignedEccentricity, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSignedEccentricity, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSignedEccentricity, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSignedEccentricity, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcSignedEccentricity.__dict__ and type(IVAStateCalcSignedEccentricity.__dict__[attrname]) == property:
            return IVAStateCalcSignedEccentricity.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcSignedEccentricity.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def ElementType(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElementType.setter
    def ElementType(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetElementType"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{CCBD1A51-0C24-4FEA-936D-F8E173931C30}", IVAStateCalcSignedEccentricity)
agcls.AgTypeNameMap["IVAStateCalcSignedEccentricity"] = IVAStateCalcSignedEccentricity

class IVAStateCalcTrueLon(object):
    """Properties for a True Longitude calculation object."""
    _uuid = "{E7F127C5-C675-4952-A10C-17AFCBB90F1B}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_SetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_GetElementType"] = _raise_uninitialized_error
        self.__dict__["_SetElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcTrueLon._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcTrueLon from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcTrueLon = agcom.GUID(IVAStateCalcTrueLon._uuid)
        vtable_offset_local = IVAStateCalcTrueLon._vtable_offset - 1
        self.__dict__["_GetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcTrueLon, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcTrueLon, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcTrueLon, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcTrueLon, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcTrueLon.__dict__ and type(IVAStateCalcTrueLon.__dict__[attrname]) == property:
            return IVAStateCalcTrueLon.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcTrueLon.")
    
    @property
    def CoordSystemName(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordSystemName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordSystemName.setter
    def CoordSystemName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordSystemName"](arg_inVal.COM_val))

    @property
    def ElementType(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElementType.setter
    def ElementType(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetElementType"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E7F127C5-C675-4952-A10C-17AFCBB90F1B}", IVAStateCalcTrueLon)
agcls.AgTypeNameMap["IVAStateCalcTrueLon"] = IVAStateCalcTrueLon

class IVAStateCalcPower(object):
    """Properties for a Power calculation object."""
    _uuid = "{748E8F67-4505-4DE7-8206-4752EF3A9158}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPowerSourceName"] = _raise_uninitialized_error
        self.__dict__["_SetPowerSourceName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcPower._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcPower from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcPower = agcom.GUID(IVAStateCalcPower._uuid)
        vtable_offset_local = IVAStateCalcPower._vtable_offset - 1
        self.__dict__["_GetPowerSourceName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcPower, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetPowerSourceName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcPower, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcPower.__dict__ and type(IVAStateCalcPower.__dict__[attrname]) == property:
            return IVAStateCalcPower.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcPower.")
    
    @property
    def PowerSourceName(self) -> str:
        """The power source."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPowerSourceName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @PowerSourceName.setter
    def PowerSourceName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetPowerSourceName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{748E8F67-4505-4DE7-8206-4752EF3A9158}", IVAStateCalcPower)
agcls.AgTypeNameMap["IVAStateCalcPower"] = IVAStateCalcPower

class IVAStateCalcRelMotion(object):
    """Properties for a Relative Motion calculation object."""
    _uuid = "{9B36C269-5E68-456B-A2BD-B9BEA9B131DB}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetOriginAtMaster"] = _raise_uninitialized_error
        self.__dict__["_SetOriginAtMaster"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSelection"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSelection"] = _raise_uninitialized_error
        self.__dict__["_GetReference"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcRelMotion._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcRelMotion from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcRelMotion = agcom.GUID(IVAStateCalcRelMotion._uuid)
        vtable_offset_local = IVAStateCalcRelMotion._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelMotion, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelMotion, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetOriginAtMaster"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelMotion, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetOriginAtMaster"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelMotion, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_GetReferenceSelection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelMotion, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetReferenceSelection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelMotion, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetReference"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelMotion, vtable_offset_local+7, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcRelMotion.__dict__ and type(IVAStateCalcRelMotion.__dict__[attrname]) == property:
            return IVAStateCalcRelMotion.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcRelMotion.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def OriginAtMaster(self) -> bool:
        """True if the origin is at the reference satellite, false if the origin is at the current satellite."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetOriginAtMaster"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @OriginAtMaster.setter
    def OriginAtMaster(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetOriginAtMaster"](arg_inVal.COM_val))

    @property
    def ReferenceSelection(self) -> "AgEVACalcObjectReference":
        """The reference object selection."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSelection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ReferenceSelection.setter
    def ReferenceSelection(self, inVal:"AgEVACalcObjectReference") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSelection"](arg_inVal.COM_val))

    @property
    def Reference(self) -> "ILinkToObject":
        """The reference object."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_GetReference"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val


agcls.AgClassCatalog.add_catalog_entry("{9B36C269-5E68-456B-A2BD-B9BEA9B131DB}", IVAStateCalcRelMotion)
agcls.AgTypeNameMap["IVAStateCalcRelMotion"] = IVAStateCalcRelMotion

class IVAStateCalcSolarBetaAngle(object):
    """Properties for a Solar Beta Angle calculation object."""
    _uuid = "{1CBEFF7B-1B28-4AEB-A8BD-B329419FC824}"
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetOrbitPlaneSource"] = _raise_uninitialized_error
        self.__dict__["_SetOrbitPlaneSource"] = _raise_uninitialized_error
        self.__dict__["_GetElementType"] = _raise_uninitialized_error
        self.__dict__["_SetElementType"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSelection"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSelection"] = _raise_uninitialized_error
        self.__dict__["_GetReference"] = _raise_uninitialized_error
        self.__dict__["_GetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_SetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_GetSignConvention"] = _raise_uninitialized_error
        self.__dict__["_SetSignConvention"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcSolarBetaAngle._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcSolarBetaAngle from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcSolarBetaAngle = agcom.GUID(IVAStateCalcSolarBetaAngle._uuid)
        vtable_offset_local = IVAStateCalcSolarBetaAngle._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSolarBetaAngle, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSolarBetaAngle, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetOrbitPlaneSource"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSolarBetaAngle, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetOrbitPlaneSource"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSolarBetaAngle, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSolarBetaAngle, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSolarBetaAngle, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetReferenceSelection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSolarBetaAngle, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetReferenceSelection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSolarBetaAngle, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetReference"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSolarBetaAngle, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_GetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSolarBetaAngle, vtable_offset_local+10, POINTER(agcom.LONG))
        self.__dict__["_SetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSolarBetaAngle, vtable_offset_local+11, agcom.LONG)
        self.__dict__["_GetSignConvention"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSolarBetaAngle, vtable_offset_local+12, POINTER(agcom.LONG))
        self.__dict__["_SetSignConvention"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSolarBetaAngle, vtable_offset_local+13, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcSolarBetaAngle.__dict__ and type(IVAStateCalcSolarBetaAngle.__dict__[attrname]) == property:
            return IVAStateCalcSolarBetaAngle.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcSolarBetaAngle.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def OrbitPlaneSource(self) -> "AgEVACalcObjectOrbitPlaneSource":
        """Selection of the satellite that will generate the orbit plane."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectOrbitPlaneSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetOrbitPlaneSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @OrbitPlaneSource.setter
    def OrbitPlaneSource(self, inVal:"AgEVACalcObjectOrbitPlaneSource") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectOrbitPlaneSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetOrbitPlaneSource"](arg_inVal.COM_val))

    @property
    def ElementType(self) -> "AgEVACalcObjectElem":
        """Choice of osculating or mean elements"""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElementType.setter
    def ElementType(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetElementType"](arg_inVal.COM_val))

    @property
    def ReferenceSelection(self) -> "AgEVACalcObjectReference":
        """The reference object selection."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSelection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ReferenceSelection.setter
    def ReferenceSelection(self, inVal:"AgEVACalcObjectReference") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSelection"](arg_inVal.COM_val))

    @property
    def Reference(self) -> "ILinkToObject":
        """The reference object."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_GetReference"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val

    @property
    def SunPosition(self) -> "AgEVACalcObjectSunPosition":
        """The type of the Sun location."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectSunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSunPosition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SunPosition.setter
    def SunPosition(self, inVal:"AgEVACalcObjectSunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectSunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSunPosition"](arg_inVal.COM_val))

    @property
    def SignConvention(self) -> "AgEVACalcObjectAngleSign":
        """Sets the sign of the angle when the relative position has a positive component along the orbit normal."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectAngleSign) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignConvention"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SignConvention.setter
    def SignConvention(self, inVal:"AgEVACalcObjectAngleSign") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectAngleSign, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSignConvention"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{1CBEFF7B-1B28-4AEB-A8BD-B329419FC824}", IVAStateCalcSolarBetaAngle)
agcls.AgTypeNameMap["IVAStateCalcSolarBetaAngle"] = IVAStateCalcSolarBetaAngle

class IVAStateCalcSolarInPlaneAngle(object):
    """Properties for a Solar In Plane Angle calculation object."""
    _uuid = "{08345343-C64C-4CAF-B1C4-EE76DC4917B5}"
    _num_methods = 15
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetOrbitPlaneSource"] = _raise_uninitialized_error
        self.__dict__["_SetOrbitPlaneSource"] = _raise_uninitialized_error
        self.__dict__["_GetElementType"] = _raise_uninitialized_error
        self.__dict__["_SetElementType"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSelection"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSelection"] = _raise_uninitialized_error
        self.__dict__["_GetReference"] = _raise_uninitialized_error
        self.__dict__["_GetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_SetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_GetCounterClockwiseRotation"] = _raise_uninitialized_error
        self.__dict__["_SetCounterClockwiseRotation"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceDirection"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceDirection"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcSolarInPlaneAngle._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcSolarInPlaneAngle from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcSolarInPlaneAngle = agcom.GUID(IVAStateCalcSolarInPlaneAngle._uuid)
        vtable_offset_local = IVAStateCalcSolarInPlaneAngle._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSolarInPlaneAngle, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSolarInPlaneAngle, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetOrbitPlaneSource"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSolarInPlaneAngle, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetOrbitPlaneSource"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSolarInPlaneAngle, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSolarInPlaneAngle, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSolarInPlaneAngle, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetReferenceSelection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSolarInPlaneAngle, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetReferenceSelection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSolarInPlaneAngle, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetReference"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSolarInPlaneAngle, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_GetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSolarInPlaneAngle, vtable_offset_local+10, POINTER(agcom.LONG))
        self.__dict__["_SetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSolarInPlaneAngle, vtable_offset_local+11, agcom.LONG)
        self.__dict__["_GetCounterClockwiseRotation"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSolarInPlaneAngle, vtable_offset_local+12, POINTER(agcom.LONG))
        self.__dict__["_SetCounterClockwiseRotation"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSolarInPlaneAngle, vtable_offset_local+13, agcom.LONG)
        self.__dict__["_GetReferenceDirection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSolarInPlaneAngle, vtable_offset_local+14, POINTER(agcom.LONG))
        self.__dict__["_SetReferenceDirection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcSolarInPlaneAngle, vtable_offset_local+15, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcSolarInPlaneAngle.__dict__ and type(IVAStateCalcSolarInPlaneAngle.__dict__[attrname]) == property:
            return IVAStateCalcSolarInPlaneAngle.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcSolarInPlaneAngle.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def OrbitPlaneSource(self) -> "AgEVACalcObjectOrbitPlaneSource":
        """Selection of the satellite that will generate the orbit plane."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectOrbitPlaneSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetOrbitPlaneSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @OrbitPlaneSource.setter
    def OrbitPlaneSource(self, inVal:"AgEVACalcObjectOrbitPlaneSource") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectOrbitPlaneSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetOrbitPlaneSource"](arg_inVal.COM_val))

    @property
    def ElementType(self) -> "AgEVACalcObjectElem":
        """Choice of osculating or mean elements"""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElementType.setter
    def ElementType(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetElementType"](arg_inVal.COM_val))

    @property
    def ReferenceSelection(self) -> "AgEVACalcObjectReference":
        """The reference object selection."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSelection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ReferenceSelection.setter
    def ReferenceSelection(self, inVal:"AgEVACalcObjectReference") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSelection"](arg_inVal.COM_val))

    @property
    def Reference(self) -> "ILinkToObject":
        """The reference object."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_GetReference"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val

    @property
    def SunPosition(self) -> "AgEVACalcObjectSunPosition":
        """The type of the Sun location."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectSunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSunPosition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SunPosition.setter
    def SunPosition(self, inVal:"AgEVACalcObjectSunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectSunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSunPosition"](arg_inVal.COM_val))

    @property
    def CounterClockwiseRotation(self) -> "AgEVACalcObjectAngleSign":
        """Sets sign of the angle for counterclockwise rotation about orbit normal."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectAngleSign) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCounterClockwiseRotation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CounterClockwiseRotation.setter
    def CounterClockwiseRotation(self, inVal:"AgEVACalcObjectAngleSign") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectAngleSign, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCounterClockwiseRotation"](arg_inVal.COM_val))

    @property
    def ReferenceDirection(self) -> "AgEVACalcObjectReferenceDirection":
        """Direction that establishes the zero value when projected into the orbit plane."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReferenceDirection) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceDirection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ReferenceDirection.setter
    def ReferenceDirection(self, inVal:"AgEVACalcObjectReferenceDirection") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReferenceDirection, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceDirection"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{08345343-C64C-4CAF-B1C4-EE76DC4917B5}", IVAStateCalcSolarInPlaneAngle)
agcls.AgTypeNameMap["IVAStateCalcSolarInPlaneAngle"] = IVAStateCalcSolarInPlaneAngle

class IVAStateCalcRelPosDecAngle(object):
    """Properties for a Relative Position Declination Angle calculation object."""
    _uuid = "{259D6521-23C1-48B4-A718-27AB113952E9}"
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetOrbitPlaneSource"] = _raise_uninitialized_error
        self.__dict__["_SetOrbitPlaneSource"] = _raise_uninitialized_error
        self.__dict__["_GetElementType"] = _raise_uninitialized_error
        self.__dict__["_SetElementType"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSelection"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSelection"] = _raise_uninitialized_error
        self.__dict__["_GetReference"] = _raise_uninitialized_error
        self.__dict__["_GetRelativePositionType"] = _raise_uninitialized_error
        self.__dict__["_SetRelativePositionType"] = _raise_uninitialized_error
        self.__dict__["_GetSignConvention"] = _raise_uninitialized_error
        self.__dict__["_SetSignConvention"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcRelPosDecAngle._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcRelPosDecAngle from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcRelPosDecAngle = agcom.GUID(IVAStateCalcRelPosDecAngle._uuid)
        vtable_offset_local = IVAStateCalcRelPosDecAngle._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelPosDecAngle, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelPosDecAngle, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetOrbitPlaneSource"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelPosDecAngle, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetOrbitPlaneSource"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelPosDecAngle, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelPosDecAngle, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelPosDecAngle, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetReferenceSelection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelPosDecAngle, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetReferenceSelection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelPosDecAngle, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetReference"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelPosDecAngle, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_GetRelativePositionType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelPosDecAngle, vtable_offset_local+10, POINTER(agcom.LONG))
        self.__dict__["_SetRelativePositionType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelPosDecAngle, vtable_offset_local+11, agcom.LONG)
        self.__dict__["_GetSignConvention"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelPosDecAngle, vtable_offset_local+12, POINTER(agcom.LONG))
        self.__dict__["_SetSignConvention"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelPosDecAngle, vtable_offset_local+13, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcRelPosDecAngle.__dict__ and type(IVAStateCalcRelPosDecAngle.__dict__[attrname]) == property:
            return IVAStateCalcRelPosDecAngle.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcRelPosDecAngle.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def OrbitPlaneSource(self) -> "AgEVACalcObjectOrbitPlaneSource":
        """Selection of the satellite that will generate the orbit plane."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectOrbitPlaneSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetOrbitPlaneSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @OrbitPlaneSource.setter
    def OrbitPlaneSource(self, inVal:"AgEVACalcObjectOrbitPlaneSource") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectOrbitPlaneSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetOrbitPlaneSource"](arg_inVal.COM_val))

    @property
    def ElementType(self) -> "AgEVACalcObjectElem":
        """Choice of osculating or mean elements"""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElementType.setter
    def ElementType(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetElementType"](arg_inVal.COM_val))

    @property
    def ReferenceSelection(self) -> "AgEVACalcObjectReference":
        """The reference object selection."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSelection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ReferenceSelection.setter
    def ReferenceSelection(self, inVal:"AgEVACalcObjectReference") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSelection"](arg_inVal.COM_val))

    @property
    def Reference(self) -> "ILinkToObject":
        """The reference object."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_GetReference"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val

    @property
    def RelativePositionType(self) -> "AgEVACalcObjectRelativePosition":
        """The type of the relative position."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectRelativePosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRelativePositionType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RelativePositionType.setter
    def RelativePositionType(self, inVal:"AgEVACalcObjectRelativePosition") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectRelativePosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetRelativePositionType"](arg_inVal.COM_val))

    @property
    def SignConvention(self) -> "AgEVACalcObjectAngleSign":
        """Sets the sign of the angle when the relative position has a positive component along the orbit normal."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectAngleSign) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignConvention"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SignConvention.setter
    def SignConvention(self, inVal:"AgEVACalcObjectAngleSign") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectAngleSign, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSignConvention"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{259D6521-23C1-48B4-A718-27AB113952E9}", IVAStateCalcRelPosDecAngle)
agcls.AgTypeNameMap["IVAStateCalcRelPosDecAngle"] = IVAStateCalcRelPosDecAngle

class IVAStateCalcRelPosInPlaneAngle(object):
    """Properties for a Relative Position In Plane Angle calculation object."""
    _uuid = "{E00BF049-7F38-4938-986F-8AB987CE84D2}"
    _num_methods = 15
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetOrbitPlaneSource"] = _raise_uninitialized_error
        self.__dict__["_SetOrbitPlaneSource"] = _raise_uninitialized_error
        self.__dict__["_GetElementType"] = _raise_uninitialized_error
        self.__dict__["_SetElementType"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSelection"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSelection"] = _raise_uninitialized_error
        self.__dict__["_GetReference"] = _raise_uninitialized_error
        self.__dict__["_GetRelativePositionType"] = _raise_uninitialized_error
        self.__dict__["_SetRelativePositionType"] = _raise_uninitialized_error
        self.__dict__["_GetCounterClockwiseRotation"] = _raise_uninitialized_error
        self.__dict__["_SetCounterClockwiseRotation"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceDirection"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceDirection"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcRelPosInPlaneAngle._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcRelPosInPlaneAngle from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcRelPosInPlaneAngle = agcom.GUID(IVAStateCalcRelPosInPlaneAngle._uuid)
        vtable_offset_local = IVAStateCalcRelPosInPlaneAngle._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelPosInPlaneAngle, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelPosInPlaneAngle, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetOrbitPlaneSource"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelPosInPlaneAngle, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetOrbitPlaneSource"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelPosInPlaneAngle, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelPosInPlaneAngle, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelPosInPlaneAngle, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetReferenceSelection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelPosInPlaneAngle, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetReferenceSelection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelPosInPlaneAngle, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetReference"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelPosInPlaneAngle, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_GetRelativePositionType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelPosInPlaneAngle, vtable_offset_local+10, POINTER(agcom.LONG))
        self.__dict__["_SetRelativePositionType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelPosInPlaneAngle, vtable_offset_local+11, agcom.LONG)
        self.__dict__["_GetCounterClockwiseRotation"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelPosInPlaneAngle, vtable_offset_local+12, POINTER(agcom.LONG))
        self.__dict__["_SetCounterClockwiseRotation"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelPosInPlaneAngle, vtable_offset_local+13, agcom.LONG)
        self.__dict__["_GetReferenceDirection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelPosInPlaneAngle, vtable_offset_local+14, POINTER(agcom.LONG))
        self.__dict__["_SetReferenceDirection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelPosInPlaneAngle, vtable_offset_local+15, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcRelPosInPlaneAngle.__dict__ and type(IVAStateCalcRelPosInPlaneAngle.__dict__[attrname]) == property:
            return IVAStateCalcRelPosInPlaneAngle.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcRelPosInPlaneAngle.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def OrbitPlaneSource(self) -> "AgEVACalcObjectOrbitPlaneSource":
        """Selection of the satellite that will generate the orbit plane."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectOrbitPlaneSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetOrbitPlaneSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @OrbitPlaneSource.setter
    def OrbitPlaneSource(self, inVal:"AgEVACalcObjectOrbitPlaneSource") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectOrbitPlaneSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetOrbitPlaneSource"](arg_inVal.COM_val))

    @property
    def ElementType(self) -> "AgEVACalcObjectElem":
        """Choice of osculating or mean elements"""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElementType.setter
    def ElementType(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetElementType"](arg_inVal.COM_val))

    @property
    def ReferenceSelection(self) -> "AgEVACalcObjectReference":
        """The reference object selection."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSelection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ReferenceSelection.setter
    def ReferenceSelection(self, inVal:"AgEVACalcObjectReference") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSelection"](arg_inVal.COM_val))

    @property
    def Reference(self) -> "ILinkToObject":
        """The reference object."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_GetReference"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val

    @property
    def RelativePositionType(self) -> "AgEVACalcObjectRelativePosition":
        """The type of the relative position."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectRelativePosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRelativePositionType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RelativePositionType.setter
    def RelativePositionType(self, inVal:"AgEVACalcObjectRelativePosition") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectRelativePosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetRelativePositionType"](arg_inVal.COM_val))

    @property
    def CounterClockwiseRotation(self) -> "AgEVACalcObjectAngleSign":
        """Sets sign of the angle for counterclockwise rotation about orbit normal."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectAngleSign) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCounterClockwiseRotation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CounterClockwiseRotation.setter
    def CounterClockwiseRotation(self, inVal:"AgEVACalcObjectAngleSign") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectAngleSign, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCounterClockwiseRotation"](arg_inVal.COM_val))

    @property
    def ReferenceDirection(self) -> "AgEVACalcObjectReferenceDirection":
        """Direction that establishes the zero value when projected into the orbit plane."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReferenceDirection) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceDirection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ReferenceDirection.setter
    def ReferenceDirection(self, inVal:"AgEVACalcObjectReferenceDirection") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReferenceDirection, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceDirection"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E00BF049-7F38-4938-986F-8AB987CE84D2}", IVAStateCalcRelPosInPlaneAngle)
agcls.AgTypeNameMap["IVAStateCalcRelPosInPlaneAngle"] = IVAStateCalcRelPosInPlaneAngle

class IVAStateCalcRelativeInclination(object):
    """Properties for a Relative Inclination Angle calculation object."""
    _uuid = "{D0299E22-99A9-4FEF-82B3-A1A7E9B9C3C1}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetSatelliteOrbitNormalType"] = _raise_uninitialized_error
        self.__dict__["_SetSatelliteOrbitNormalType"] = _raise_uninitialized_error
        self.__dict__["_GetRefSatelliteOrbitNormalType"] = _raise_uninitialized_error
        self.__dict__["_SetRefSatelliteOrbitNormalType"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSelection"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSelection"] = _raise_uninitialized_error
        self.__dict__["_GetReference"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcRelativeInclination._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcRelativeInclination from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcRelativeInclination = agcom.GUID(IVAStateCalcRelativeInclination._uuid)
        vtable_offset_local = IVAStateCalcRelativeInclination._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelativeInclination, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelativeInclination, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetSatelliteOrbitNormalType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelativeInclination, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetSatelliteOrbitNormalType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelativeInclination, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetRefSatelliteOrbitNormalType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelativeInclination, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetRefSatelliteOrbitNormalType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelativeInclination, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetReferenceSelection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelativeInclination, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetReferenceSelection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelativeInclination, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetReference"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRelativeInclination, vtable_offset_local+9, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcRelativeInclination.__dict__ and type(IVAStateCalcRelativeInclination.__dict__[attrname]) == property:
            return IVAStateCalcRelativeInclination.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcRelativeInclination.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def SatelliteOrbitNormalType(self) -> "AgEVACalcObjectElem":
        """Choice of osculating or mean elements for describing the orbit plane."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSatelliteOrbitNormalType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SatelliteOrbitNormalType.setter
    def SatelliteOrbitNormalType(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSatelliteOrbitNormalType"](arg_inVal.COM_val))

    @property
    def RefSatelliteOrbitNormalType(self) -> "AgEVACalcObjectElem":
        """Choice of osculating or mean elements for describing the orbit plane"""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRefSatelliteOrbitNormalType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RefSatelliteOrbitNormalType.setter
    def RefSatelliteOrbitNormalType(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetRefSatelliteOrbitNormalType"](arg_inVal.COM_val))

    @property
    def ReferenceSelection(self) -> "AgEVACalcObjectReference":
        """The reference object selection."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSelection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ReferenceSelection.setter
    def ReferenceSelection(self, inVal:"AgEVACalcObjectReference") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSelection"](arg_inVal.COM_val))

    @property
    def Reference(self) -> "ILinkToObject":
        """The reference object."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_GetReference"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val


agcls.AgClassCatalog.add_catalog_entry("{D0299E22-99A9-4FEF-82B3-A1A7E9B9C3C1}", IVAStateCalcRelativeInclination)
agcls.AgTypeNameMap["IVAStateCalcRelativeInclination"] = IVAStateCalcRelativeInclination

class IVAStateCalcCurvilinearRelMotion(object):
    """Properties for Curvilinear Relative Motion  calculation object."""
    _uuid = "{5658DCFF-6F7B-4935-BA41-135F502DDC07}"
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceEllipse"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceEllipse"] = _raise_uninitialized_error
        self.__dict__["_GetLocationSource"] = _raise_uninitialized_error
        self.__dict__["_SetLocationSource"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSelection"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceSelection"] = _raise_uninitialized_error
        self.__dict__["_GetReference"] = _raise_uninitialized_error
        self.__dict__["_GetElementType"] = _raise_uninitialized_error
        self.__dict__["_SetElementType"] = _raise_uninitialized_error
        self.__dict__["_GetSignConvention"] = _raise_uninitialized_error
        self.__dict__["_SetSignConvention"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcCurvilinearRelMotion._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcCurvilinearRelMotion from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcCurvilinearRelMotion = agcom.GUID(IVAStateCalcCurvilinearRelMotion._uuid)
        vtable_offset_local = IVAStateCalcCurvilinearRelMotion._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCurvilinearRelMotion, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCurvilinearRelMotion, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetReferenceEllipse"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCurvilinearRelMotion, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetReferenceEllipse"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCurvilinearRelMotion, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetLocationSource"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCurvilinearRelMotion, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetLocationSource"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCurvilinearRelMotion, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetReferenceSelection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCurvilinearRelMotion, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetReferenceSelection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCurvilinearRelMotion, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetReference"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCurvilinearRelMotion, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_GetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCurvilinearRelMotion, vtable_offset_local+10, POINTER(agcom.LONG))
        self.__dict__["_SetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCurvilinearRelMotion, vtable_offset_local+11, agcom.LONG)
        self.__dict__["_GetSignConvention"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCurvilinearRelMotion, vtable_offset_local+12, POINTER(agcom.LONG))
        self.__dict__["_SetSignConvention"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCurvilinearRelMotion, vtable_offset_local+13, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcCurvilinearRelMotion.__dict__ and type(IVAStateCalcCurvilinearRelMotion.__dict__[attrname]) == property:
            return IVAStateCalcCurvilinearRelMotion.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcCurvilinearRelMotion.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def ReferenceEllipse(self) -> "AgEVACalcObjectReferenceEllipse":
        """Selection of the satellite orbit that is used as the reference ellipse."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReferenceEllipse) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceEllipse"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ReferenceEllipse.setter
    def ReferenceEllipse(self, inVal:"AgEVACalcObjectReferenceEllipse") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReferenceEllipse, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceEllipse"](arg_inVal.COM_val))

    @property
    def LocationSource(self) -> "AgEVACalcObjectLocationSource":
        """Selection of the satellite whose location is being reported with respect to the reference ellipse."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectLocationSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLocationSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @LocationSource.setter
    def LocationSource(self, inVal:"AgEVACalcObjectLocationSource") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectLocationSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetLocationSource"](arg_inVal.COM_val))

    @property
    def ReferenceSelection(self) -> "AgEVACalcObjectReference":
        """The reference object selection."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSelection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ReferenceSelection.setter
    def ReferenceSelection(self, inVal:"AgEVACalcObjectReference") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceSelection"](arg_inVal.COM_val))

    @property
    def Reference(self) -> "ILinkToObject":
        """The reference object."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_GetReference"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val

    @property
    def ElementType(self) -> "AgEVACalcObjectElem":
        """Choice of osculating or mean elements"""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElementType.setter
    def ElementType(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetElementType"](arg_inVal.COM_val))

    @property
    def SignConvention(self) -> "AgEVACalcObjectAngleSign":
        """Sets the sign of the angle when the relative position has a positive component along the orbit normal."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectAngleSign) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignConvention"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SignConvention.setter
    def SignConvention(self, inVal:"AgEVACalcObjectAngleSign") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectAngleSign, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSignConvention"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{5658DCFF-6F7B-4935-BA41-135F502DDC07}", IVAStateCalcCurvilinearRelMotion)
agcls.AgTypeNameMap["IVAStateCalcCurvilinearRelMotion"] = IVAStateCalcCurvilinearRelMotion

class IVAStateCalcCustomFunction(object):
    """Properties for a Custom Function calculation object."""
    _uuid = "{0943C88D-EE8E-48B1-8C5B-79A4748452C8}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetResetFunctionName"] = _raise_uninitialized_error
        self.__dict__["_SetResetFunctionName"] = _raise_uninitialized_error
        self.__dict__["_GetEvalFunctionName"] = _raise_uninitialized_error
        self.__dict__["_SetEvalFunctionName"] = _raise_uninitialized_error
        self.__dict__["_GetUnitDimension"] = _raise_uninitialized_error
        self.__dict__["_SetUnitDimension"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcCustomFunction._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcCustomFunction from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcCustomFunction = agcom.GUID(IVAStateCalcCustomFunction._uuid)
        vtable_offset_local = IVAStateCalcCustomFunction._vtable_offset - 1
        self.__dict__["_GetResetFunctionName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCustomFunction, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetResetFunctionName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCustomFunction, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetEvalFunctionName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCustomFunction, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetEvalFunctionName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCustomFunction, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_GetUnitDimension"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCustomFunction, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_SetUnitDimension"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCustomFunction, vtable_offset_local+6, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcCustomFunction.__dict__ and type(IVAStateCalcCustomFunction.__dict__[attrname]) == property:
            return IVAStateCalcCustomFunction.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcCustomFunction.")
    
    @property
    def ResetFunctionName(self) -> str:
        """The custom function called before computing, before each segment runs, and before reporting."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetResetFunctionName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ResetFunctionName.setter
    def ResetFunctionName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetResetFunctionName"](arg_inVal.COM_val))

    @property
    def EvalFunctionName(self) -> str:
        """The custom function used to calculate this object's value."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEvalFunctionName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EvalFunctionName.setter
    def EvalFunctionName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetEvalFunctionName"](arg_inVal.COM_val))

    @property
    def UnitDimension(self) -> str:
        """The unit dimension."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUnitDimension"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UnitDimension.setter
    def UnitDimension(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUnitDimension"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{0943C88D-EE8E-48B1-8C5B-79A4748452C8}", IVAStateCalcCustomFunction)
agcls.AgTypeNameMap["IVAStateCalcCustomFunction"] = IVAStateCalcCustomFunction

class IVAStateCalcScript(object):
    """Properties for a Script calculation object."""
    _uuid = "{42A2EAD1-9982-4895-9637-4C83524F2A02}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCalcArguments"] = _raise_uninitialized_error
        self.__dict__["_GetInlineFunc"] = _raise_uninitialized_error
        self.__dict__["_SetInlineFunc"] = _raise_uninitialized_error
        self.__dict__["_GetUnitDimension"] = _raise_uninitialized_error
        self.__dict__["_SetUnitDimension"] = _raise_uninitialized_error
        self.__dict__["_GetCalcArgumentsLinkEmbed"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcScript._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcScript from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcScript = agcom.GUID(IVAStateCalcScript._uuid)
        vtable_offset_local = IVAStateCalcScript._vtable_offset - 1
        self.__dict__["_GetCalcArguments"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcScript, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_GetInlineFunc"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcScript, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_SetInlineFunc"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcScript, vtable_offset_local+3, agcom.BSTR)
        self.__dict__["_GetUnitDimension"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcScript, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_SetUnitDimension"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcScript, vtable_offset_local+5, agcom.BSTR)
        self.__dict__["_GetCalcArgumentsLinkEmbed"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcScript, vtable_offset_local+6, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcScript.__dict__ and type(IVAStateCalcScript.__dict__[attrname]) == property:
            return IVAStateCalcScript.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcScript.")
    
    @property
    def CalcArguments(self) -> "IVACalcObjectCollection":
        """The arguments to be applied to the function."""
        with agmarshall.AgInterface_out_arg() as arg_ppVACalcObjectCollection:
            agcls.evaluate_hresult(self.__dict__["_GetCalcArguments"](byref(arg_ppVACalcObjectCollection.COM_val)))
            return arg_ppVACalcObjectCollection.python_val

    @property
    def InlineFunc(self) -> str:
        """The expression to be applied as a function."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetInlineFunc"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @InlineFunc.setter
    def InlineFunc(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetInlineFunc"](arg_inVal.COM_val))

    @property
    def UnitDimension(self) -> str:
        """The unit dimension."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUnitDimension"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UnitDimension.setter
    def UnitDimension(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUnitDimension"](arg_inVal.COM_val))

    @property
    def CalcArgumentsLinkEmbed(self) -> "IVACalcObjectLinkEmbedControlCollection":
        """The arguments to be applied to the function."""
        with agmarshall.AgInterface_out_arg() as arg_ppVACalcObjectLinkEmbedControlCollection:
            agcls.evaluate_hresult(self.__dict__["_GetCalcArgumentsLinkEmbed"](byref(arg_ppVACalcObjectLinkEmbedControlCollection.COM_val)))
            return arg_ppVACalcObjectLinkEmbedControlCollection.python_val


agcls.AgClassCatalog.add_catalog_entry("{42A2EAD1-9982-4895-9637-4C83524F2A02}", IVAStateCalcScript)
agcls.AgTypeNameMap["IVAStateCalcScript"] = IVAStateCalcScript

class IVAStateCalcCd(object):
    """Properties for a Cd calculation object."""
    _uuid = "{18430B84-59EA-4D47-84B4-E7D5589F1931}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcCd._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcCd from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcCd = agcom.GUID(IVAStateCalcCd._uuid)
        vtable_offset_local = IVAStateCalcCd._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcCd.__dict__ and type(IVAStateCalcCd.__dict__[attrname]) == property:
            return IVAStateCalcCd.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcCd.")
    

agcls.AgClassCatalog.add_catalog_entry("{18430B84-59EA-4D47-84B4-E7D5589F1931}", IVAStateCalcCd)
agcls.AgTypeNameMap["IVAStateCalcCd"] = IVAStateCalcCd

class IVAStateCalcCr(object):
    """Properties for a Cr calculation object."""
    _uuid = "{BC4AD651-BFCA-4E69-8409-54BB0880F9E6}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcCr._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcCr from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcCr = agcom.GUID(IVAStateCalcCr._uuid)
        vtable_offset_local = IVAStateCalcCr._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcCr.__dict__ and type(IVAStateCalcCr.__dict__[attrname]) == property:
            return IVAStateCalcCr.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcCr.")
    

agcls.AgClassCatalog.add_catalog_entry("{BC4AD651-BFCA-4E69-8409-54BB0880F9E6}", IVAStateCalcCr)
agcls.AgTypeNameMap["IVAStateCalcCr"] = IVAStateCalcCr

class IVAStateCalcDragArea(object):
    """Properties for a DragArea calculation object. CAgAsStateCalcDragArea"""
    _uuid = "{0D264D3F-4409-4CF7-95AD-0129F85F2A72}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcDragArea._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcDragArea from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcDragArea = agcom.GUID(IVAStateCalcDragArea._uuid)
        vtable_offset_local = IVAStateCalcDragArea._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcDragArea.__dict__ and type(IVAStateCalcDragArea.__dict__[attrname]) == property:
            return IVAStateCalcDragArea.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcDragArea.")
    

agcls.AgClassCatalog.add_catalog_entry("{0D264D3F-4409-4CF7-95AD-0129F85F2A72}", IVAStateCalcDragArea)
agcls.AgTypeNameMap["IVAStateCalcDragArea"] = IVAStateCalcDragArea

class IVAStateCalcRadiationPressureArea(object):
    """Properties for a RadPressureArea calculation object."""
    _uuid = "{F6C33B19-2B4F-4DBB-8CA0-B3E8B971BC49}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcRadiationPressureArea._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcRadiationPressureArea from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcRadiationPressureArea = agcom.GUID(IVAStateCalcRadiationPressureArea._uuid)
        vtable_offset_local = IVAStateCalcRadiationPressureArea._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcRadiationPressureArea.__dict__ and type(IVAStateCalcRadiationPressureArea.__dict__[attrname]) == property:
            return IVAStateCalcRadiationPressureArea.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcRadiationPressureArea.")
    

agcls.AgClassCatalog.add_catalog_entry("{F6C33B19-2B4F-4DBB-8CA0-B3E8B971BC49}", IVAStateCalcRadiationPressureArea)
agcls.AgTypeNameMap["IVAStateCalcRadiationPressureArea"] = IVAStateCalcRadiationPressureArea

class IVAStateCalcRadiationPressureCoefficient(object):
    """Properties for a RadiationPressureCoefficient calculation object."""
    _uuid = "{9AE54040-18D2-46FC-A12C-C03BDA65FE22}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcRadiationPressureCoefficient._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcRadiationPressureCoefficient from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcRadiationPressureCoefficient = agcom.GUID(IVAStateCalcRadiationPressureCoefficient._uuid)
        vtable_offset_local = IVAStateCalcRadiationPressureCoefficient._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcRadiationPressureCoefficient.__dict__ and type(IVAStateCalcRadiationPressureCoefficient.__dict__[attrname]) == property:
            return IVAStateCalcRadiationPressureCoefficient.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcRadiationPressureCoefficient.")
    

agcls.AgClassCatalog.add_catalog_entry("{9AE54040-18D2-46FC-A12C-C03BDA65FE22}", IVAStateCalcRadiationPressureCoefficient)
agcls.AgTypeNameMap["IVAStateCalcRadiationPressureCoefficient"] = IVAStateCalcRadiationPressureCoefficient

class IVAStateCalcSRPArea(object):
    """Properties for an SRPArea calculation object."""
    _uuid = "{776A4C17-4D73-4ED0-A564-E9BD0D1788EC}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcSRPArea._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcSRPArea from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcSRPArea = agcom.GUID(IVAStateCalcSRPArea._uuid)
        vtable_offset_local = IVAStateCalcSRPArea._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcSRPArea.__dict__ and type(IVAStateCalcSRPArea.__dict__[attrname]) == property:
            return IVAStateCalcSRPArea.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcSRPArea.")
    

agcls.AgClassCatalog.add_catalog_entry("{776A4C17-4D73-4ED0-A564-E9BD0D1788EC}", IVAStateCalcSRPArea)
agcls.AgTypeNameMap["IVAStateCalcSRPArea"] = IVAStateCalcSRPArea

class IVAStateCalcCosOfVerticalFPA(object):
    """Properties for a Cosine of Vertical FPA calculation object."""
    _uuid = "{D2C32FFB-6C5C-46E8-B386-2E69262118C8}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcCosOfVerticalFPA._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcCosOfVerticalFPA from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcCosOfVerticalFPA = agcom.GUID(IVAStateCalcCosOfVerticalFPA._uuid)
        vtable_offset_local = IVAStateCalcCosOfVerticalFPA._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCosOfVerticalFPA, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCosOfVerticalFPA, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcCosOfVerticalFPA.__dict__ and type(IVAStateCalcCosOfVerticalFPA.__dict__[attrname]) == property:
            return IVAStateCalcCosOfVerticalFPA.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcCosOfVerticalFPA.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{D2C32FFB-6C5C-46E8-B386-2E69262118C8}", IVAStateCalcCosOfVerticalFPA)
agcls.AgTypeNameMap["IVAStateCalcCosOfVerticalFPA"] = IVAStateCalcCosOfVerticalFPA

class IVAStateCalcDec(object):
    """Properties for a Declination calculation object."""
    _uuid = "{B3277FB5-1B7A-4A02-91B1-F6682F29CB87}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_SetCoordSystemName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcDec._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcDec from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcDec = agcom.GUID(IVAStateCalcDec._uuid)
        vtable_offset_local = IVAStateCalcDec._vtable_offset - 1
        self.__dict__["_GetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDec, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDec, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcDec.__dict__ and type(IVAStateCalcDec.__dict__[attrname]) == property:
            return IVAStateCalcDec.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcDec.")
    
    @property
    def CoordSystemName(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordSystemName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordSystemName.setter
    def CoordSystemName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordSystemName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{B3277FB5-1B7A-4A02-91B1-F6682F29CB87}", IVAStateCalcDec)
agcls.AgTypeNameMap["IVAStateCalcDec"] = IVAStateCalcDec

class IVAStateCalcFPA(object):
    """Properties for a Flight Path Angle calculation object."""
    _uuid = "{0A7406E7-049A-4054-A1FE-3E86D1998733}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_SetCoordSystemName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcFPA._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcFPA from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcFPA = agcom.GUID(IVAStateCalcFPA._uuid)
        vtable_offset_local = IVAStateCalcFPA._vtable_offset - 1
        self.__dict__["_GetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcFPA, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcFPA, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcFPA.__dict__ and type(IVAStateCalcFPA.__dict__[attrname]) == property:
            return IVAStateCalcFPA.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcFPA.")
    
    @property
    def CoordSystemName(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordSystemName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordSystemName.setter
    def CoordSystemName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordSystemName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{0A7406E7-049A-4054-A1FE-3E86D1998733}", IVAStateCalcFPA)
agcls.AgTypeNameMap["IVAStateCalcFPA"] = IVAStateCalcFPA

class IVAStateCalcRMag(object):
    """Properties for an R Mag calculation object. AsStateCalcRMag"""
    _uuid = "{3E6FAE70-AA94-4036-9FBA-75954E96D759}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetReferencePointName"] = _raise_uninitialized_error
        self.__dict__["_SetReferencePointName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcRMag._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcRMag from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcRMag = agcom.GUID(IVAStateCalcRMag._uuid)
        vtable_offset_local = IVAStateCalcRMag._vtable_offset - 1
        self.__dict__["_GetReferencePointName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRMag, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetReferencePointName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRMag, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcRMag.__dict__ and type(IVAStateCalcRMag.__dict__[attrname]) == property:
            return IVAStateCalcRMag.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcRMag.")
    
    @property
    def ReferencePointName(self) -> str:
        """Reference point used for calculation."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferencePointName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ReferencePointName.setter
    def ReferencePointName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetReferencePointName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3E6FAE70-AA94-4036-9FBA-75954E96D759}", IVAStateCalcRMag)
agcls.AgTypeNameMap["IVAStateCalcRMag"] = IVAStateCalcRMag

class IVAStateCalcRA(object):
    """Properties for a Right Asc calculation object."""
    _uuid = "{3D404DD1-E609-4CA0-87BE-3D9EDD9A7BCE}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_SetCoordSystemName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcRA._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcRA from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcRA = agcom.GUID(IVAStateCalcRA._uuid)
        vtable_offset_local = IVAStateCalcRA._vtable_offset - 1
        self.__dict__["_GetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRA, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRA, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcRA.__dict__ and type(IVAStateCalcRA.__dict__[attrname]) == property:
            return IVAStateCalcRA.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcRA.")
    
    @property
    def CoordSystemName(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordSystemName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordSystemName.setter
    def CoordSystemName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordSystemName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3D404DD1-E609-4CA0-87BE-3D9EDD9A7BCE}", IVAStateCalcRA)
agcls.AgTypeNameMap["IVAStateCalcRA"] = IVAStateCalcRA

class IVAStateCalcVMag(object):
    """Properties for a V Mag calculation object."""
    _uuid = "{6795C6E5-3D87-42A9-A40F-DAFEDA08235B}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_SetCoordSystemName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcVMag._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcVMag from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcVMag = agcom.GUID(IVAStateCalcVMag._uuid)
        vtable_offset_local = IVAStateCalcVMag._vtable_offset - 1
        self.__dict__["_GetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVMag, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVMag, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcVMag.__dict__ and type(IVAStateCalcVMag.__dict__[attrname]) == property:
            return IVAStateCalcVMag.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcVMag.")
    
    @property
    def CoordSystemName(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordSystemName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordSystemName.setter
    def CoordSystemName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordSystemName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{6795C6E5-3D87-42A9-A40F-DAFEDA08235B}", IVAStateCalcVMag)
agcls.AgTypeNameMap["IVAStateCalcVMag"] = IVAStateCalcVMag

class IVAStateCalcVelAz(object):
    """Properties for a Velocity Azimuth calculation object."""
    _uuid = "{5B86F143-59CB-4014-A920-7F46613F2FB5}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_SetCoordSystemName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcVelAz._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcVelAz from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcVelAz = agcom.GUID(IVAStateCalcVelAz._uuid)
        vtable_offset_local = IVAStateCalcVelAz._vtable_offset - 1
        self.__dict__["_GetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVelAz, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVelAz, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcVelAz.__dict__ and type(IVAStateCalcVelAz.__dict__[attrname]) == property:
            return IVAStateCalcVelAz.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcVelAz.")
    
    @property
    def CoordSystemName(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordSystemName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordSystemName.setter
    def CoordSystemName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordSystemName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{5B86F143-59CB-4014-A920-7F46613F2FB5}", IVAStateCalcVelAz)
agcls.AgTypeNameMap["IVAStateCalcVelAz"] = IVAStateCalcVelAz

class IVAStateCalcC3Energy(object):
    """Properties for a C3 Energy calculation object."""
    _uuid = "{23937635-E460-428B-90CC-2EAA1C51870B}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetElementType"] = _raise_uninitialized_error
        self.__dict__["_SetElementType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcC3Energy._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcC3Energy from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcC3Energy = agcom.GUID(IVAStateCalcC3Energy._uuid)
        vtable_offset_local = IVAStateCalcC3Energy._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcC3Energy, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcC3Energy, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcC3Energy, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetElementType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcC3Energy, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcC3Energy.__dict__ and type(IVAStateCalcC3Energy.__dict__[attrname]) == property:
            return IVAStateCalcC3Energy.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcC3Energy.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def ElementType(self) -> "AgEVACalcObjectElem":
        """The element type - osculating or a mean type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetElementType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ElementType.setter
    def ElementType(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetElementType"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{23937635-E460-428B-90CC-2EAA1C51870B}", IVAStateCalcC3Energy)
agcls.AgTypeNameMap["IVAStateCalcC3Energy"] = IVAStateCalcC3Energy

class IVAStateCalcInAsympDec(object):
    """Properties for an Incoming Asymptote Dec calculation object."""
    _uuid = "{BE07A06D-B79A-45C7-A460-A2D22467F1CF}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_SetCoordSystemName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcInAsympDec._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcInAsympDec from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcInAsympDec = agcom.GUID(IVAStateCalcInAsympDec._uuid)
        vtable_offset_local = IVAStateCalcInAsympDec._vtable_offset - 1
        self.__dict__["_GetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcInAsympDec, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcInAsympDec, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcInAsympDec.__dict__ and type(IVAStateCalcInAsympDec.__dict__[attrname]) == property:
            return IVAStateCalcInAsympDec.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcInAsympDec.")
    
    @property
    def CoordSystemName(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordSystemName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordSystemName.setter
    def CoordSystemName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordSystemName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{BE07A06D-B79A-45C7-A460-A2D22467F1CF}", IVAStateCalcInAsympDec)
agcls.AgTypeNameMap["IVAStateCalcInAsympDec"] = IVAStateCalcInAsympDec

class IVAStateCalcInAsympRA(object):
    """Properties for a Incoming Asymptote RA calculation object."""
    _uuid = "{732CE68C-1443-4C38-A037-BD228DD1DD50}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_SetCoordSystemName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcInAsympRA._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcInAsympRA from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcInAsympRA = agcom.GUID(IVAStateCalcInAsympRA._uuid)
        vtable_offset_local = IVAStateCalcInAsympRA._vtable_offset - 1
        self.__dict__["_GetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcInAsympRA, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcInAsympRA, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcInAsympRA.__dict__ and type(IVAStateCalcInAsympRA.__dict__[attrname]) == property:
            return IVAStateCalcInAsympRA.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcInAsympRA.")
    
    @property
    def CoordSystemName(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordSystemName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordSystemName.setter
    def CoordSystemName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordSystemName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{732CE68C-1443-4C38-A037-BD228DD1DD50}", IVAStateCalcInAsympRA)
agcls.AgTypeNameMap["IVAStateCalcInAsympRA"] = IVAStateCalcInAsympRA

class IVAStateCalcInVelAzAtPeriapsis(object):
    """Properties for an Incoming Vel Az at Periapsis calculation object."""
    _uuid = "{10C8047E-4366-4951-A479-BEB44FE74322}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_SetCoordSystemName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcInVelAzAtPeriapsis._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcInVelAzAtPeriapsis from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcInVelAzAtPeriapsis = agcom.GUID(IVAStateCalcInVelAzAtPeriapsis._uuid)
        vtable_offset_local = IVAStateCalcInVelAzAtPeriapsis._vtable_offset - 1
        self.__dict__["_GetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcInVelAzAtPeriapsis, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcInVelAzAtPeriapsis, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcInVelAzAtPeriapsis.__dict__ and type(IVAStateCalcInVelAzAtPeriapsis.__dict__[attrname]) == property:
            return IVAStateCalcInVelAzAtPeriapsis.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcInVelAzAtPeriapsis.")
    
    @property
    def CoordSystemName(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordSystemName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordSystemName.setter
    def CoordSystemName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordSystemName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{10C8047E-4366-4951-A479-BEB44FE74322}", IVAStateCalcInVelAzAtPeriapsis)
agcls.AgTypeNameMap["IVAStateCalcInVelAzAtPeriapsis"] = IVAStateCalcInVelAzAtPeriapsis

class IVAStateCalcOutAsympDec(object):
    """Properties for a Outgoing Asymptote Dec calculation object."""
    _uuid = "{0DB1FF5A-2DA1-4472-A3DF-52B52989E27B}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_SetCoordSystemName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcOutAsympDec._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcOutAsympDec from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcOutAsympDec = agcom.GUID(IVAStateCalcOutAsympDec._uuid)
        vtable_offset_local = IVAStateCalcOutAsympDec._vtable_offset - 1
        self.__dict__["_GetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOutAsympDec, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOutAsympDec, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcOutAsympDec.__dict__ and type(IVAStateCalcOutAsympDec.__dict__[attrname]) == property:
            return IVAStateCalcOutAsympDec.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcOutAsympDec.")
    
    @property
    def CoordSystemName(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordSystemName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordSystemName.setter
    def CoordSystemName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordSystemName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{0DB1FF5A-2DA1-4472-A3DF-52B52989E27B}", IVAStateCalcOutAsympDec)
agcls.AgTypeNameMap["IVAStateCalcOutAsympDec"] = IVAStateCalcOutAsympDec

class IVAStateCalcOutAsympRA(object):
    """Properties for a Outgoing Asymptote RA calculation object."""
    _uuid = "{F2386148-5F54-40D2-91DD-322B912712B3}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_SetCoordSystemName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcOutAsympRA._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcOutAsympRA from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcOutAsympRA = agcom.GUID(IVAStateCalcOutAsympRA._uuid)
        vtable_offset_local = IVAStateCalcOutAsympRA._vtable_offset - 1
        self.__dict__["_GetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOutAsympRA, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOutAsympRA, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcOutAsympRA.__dict__ and type(IVAStateCalcOutAsympRA.__dict__[attrname]) == property:
            return IVAStateCalcOutAsympRA.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcOutAsympRA.")
    
    @property
    def CoordSystemName(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordSystemName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordSystemName.setter
    def CoordSystemName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordSystemName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{F2386148-5F54-40D2-91DD-322B912712B3}", IVAStateCalcOutAsympRA)
agcls.AgTypeNameMap["IVAStateCalcOutAsympRA"] = IVAStateCalcOutAsympRA

class IVAStateCalcOutVelAzAtPeriapsis(object):
    """Properties for a Outgoing Vel Az at Periapsis calculation object."""
    _uuid = "{F908643D-9C89-4EDF-B45F-948B9303F260}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_SetCoordSystemName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcOutVelAzAtPeriapsis._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcOutVelAzAtPeriapsis from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcOutVelAzAtPeriapsis = agcom.GUID(IVAStateCalcOutVelAzAtPeriapsis._uuid)
        vtable_offset_local = IVAStateCalcOutVelAzAtPeriapsis._vtable_offset - 1
        self.__dict__["_GetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOutVelAzAtPeriapsis, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOutVelAzAtPeriapsis, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcOutVelAzAtPeriapsis.__dict__ and type(IVAStateCalcOutVelAzAtPeriapsis.__dict__[attrname]) == property:
            return IVAStateCalcOutVelAzAtPeriapsis.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcOutVelAzAtPeriapsis.")
    
    @property
    def CoordSystemName(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordSystemName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordSystemName.setter
    def CoordSystemName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordSystemName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{F908643D-9C89-4EDF-B45F-948B9303F260}", IVAStateCalcOutVelAzAtPeriapsis)
agcls.AgTypeNameMap["IVAStateCalcOutVelAzAtPeriapsis"] = IVAStateCalcOutVelAzAtPeriapsis

class IVAStateCalcDuration(object):
    """Properties for a Duration calculation object."""
    _uuid = "{429E860D-8706-4C30-9F40-B0113E00BAF8}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcDuration._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcDuration from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcDuration = agcom.GUID(IVAStateCalcDuration._uuid)
        vtable_offset_local = IVAStateCalcDuration._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcDuration.__dict__ and type(IVAStateCalcDuration.__dict__[attrname]) == property:
            return IVAStateCalcDuration.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcDuration.")
    

agcls.AgClassCatalog.add_catalog_entry("{429E860D-8706-4C30-9F40-B0113E00BAF8}", IVAStateCalcDuration)
agcls.AgTypeNameMap["IVAStateCalcDuration"] = IVAStateCalcDuration

class IVAStateCalcUserValue(object):
    """Interface for CAgAsStateCalcUserValue"""
    _uuid = "{BB517244-9226-45E2-9048-9D4E289BA920}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetVariableName"] = _raise_uninitialized_error
        self.__dict__["_SetVariableName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcUserValue._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcUserValue from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcUserValue = agcom.GUID(IVAStateCalcUserValue._uuid)
        vtable_offset_local = IVAStateCalcUserValue._vtable_offset - 1
        self.__dict__["_GetVariableName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcUserValue, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetVariableName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcUserValue, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcUserValue.__dict__ and type(IVAStateCalcUserValue.__dict__[attrname]) == property:
            return IVAStateCalcUserValue.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcUserValue.")
    
    @property
    def VariableName(self) -> str:
        """Name of the user variable"""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVariableName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VariableName.setter
    def VariableName(self, inVal:str) -> None:
        """Name of the user variable"""
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVariableName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{BB517244-9226-45E2-9048-9D4E289BA920}", IVAStateCalcUserValue)
agcls.AgTypeNameMap["IVAStateCalcUserValue"] = IVAStateCalcUserValue

class IVAStateCalcCrdnAngle(object):
    """Properties for an Vector Geometry Tool Angle calculation object."""
    _uuid = "{7EC926A3-7ED6-4091-9E74-EBA5700075A5}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAngleName"] = _raise_uninitialized_error
        self.__dict__["_SetAngleName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcCrdnAngle._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcCrdnAngle from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcCrdnAngle = agcom.GUID(IVAStateCalcCrdnAngle._uuid)
        vtable_offset_local = IVAStateCalcCrdnAngle._vtable_offset - 1
        self.__dict__["_GetAngleName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCrdnAngle, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetAngleName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcCrdnAngle, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcCrdnAngle.__dict__ and type(IVAStateCalcCrdnAngle.__dict__[attrname]) == property:
            return IVAStateCalcCrdnAngle.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcCrdnAngle.")
    
    @property
    def AngleName(self) -> str:
        """The angle."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAngleName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AngleName.setter
    def AngleName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAngleName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7EC926A3-7ED6-4091-9E74-EBA5700075A5}", IVAStateCalcCrdnAngle)
agcls.AgTypeNameMap["IVAStateCalcCrdnAngle"] = IVAStateCalcCrdnAngle

class IVAStateCalcAngle(object):
    """Properties for an Angle Between Vectors calculation object."""
    _uuid = "{E703F5BA-3C07-407B-8BE6-5361172E97FF}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetVector1Name"] = _raise_uninitialized_error
        self.__dict__["_SetVector1Name"] = _raise_uninitialized_error
        self.__dict__["_GetVector2Name"] = _raise_uninitialized_error
        self.__dict__["_SetVector2Name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcAngle._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcAngle from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcAngle = agcom.GUID(IVAStateCalcAngle._uuid)
        vtable_offset_local = IVAStateCalcAngle._vtable_offset - 1
        self.__dict__["_GetVector1Name"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcAngle, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetVector1Name"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcAngle, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetVector2Name"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcAngle, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetVector2Name"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcAngle, vtable_offset_local+4, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcAngle.__dict__ and type(IVAStateCalcAngle.__dict__[attrname]) == property:
            return IVAStateCalcAngle.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcAngle.")
    
    @property
    def Vector1Name(self) -> str:
        """The first vector of the angle."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVector1Name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Vector1Name.setter
    def Vector1Name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVector1Name"](arg_inVal.COM_val))

    @property
    def Vector2Name(self) -> str:
        """The second vector of the angle."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVector2Name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Vector2Name.setter
    def Vector2Name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVector2Name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E703F5BA-3C07-407B-8BE6-5361172E97FF}", IVAStateCalcAngle)
agcls.AgTypeNameMap["IVAStateCalcAngle"] = IVAStateCalcAngle

class IVAStateCalcDotProduct(object):
    """Properties for a Dot Product calculation object."""
    _uuid = "{8B3C8283-79EC-48D1-BFBD-66775AA10803}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetVector1Name"] = _raise_uninitialized_error
        self.__dict__["_SetVector1Name"] = _raise_uninitialized_error
        self.__dict__["_GetVector2Name"] = _raise_uninitialized_error
        self.__dict__["_SetVector2Name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcDotProduct._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcDotProduct from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcDotProduct = agcom.GUID(IVAStateCalcDotProduct._uuid)
        vtable_offset_local = IVAStateCalcDotProduct._vtable_offset - 1
        self.__dict__["_GetVector1Name"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDotProduct, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetVector1Name"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDotProduct, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetVector2Name"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDotProduct, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetVector2Name"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDotProduct, vtable_offset_local+4, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcDotProduct.__dict__ and type(IVAStateCalcDotProduct.__dict__[attrname]) == property:
            return IVAStateCalcDotProduct.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcDotProduct.")
    
    @property
    def Vector1Name(self) -> str:
        """The first vector."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVector1Name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Vector1Name.setter
    def Vector1Name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVector1Name"](arg_inVal.COM_val))

    @property
    def Vector2Name(self) -> str:
        """The second vector."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVector2Name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Vector2Name.setter
    def Vector2Name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVector2Name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{8B3C8283-79EC-48D1-BFBD-66775AA10803}", IVAStateCalcDotProduct)
agcls.AgTypeNameMap["IVAStateCalcDotProduct"] = IVAStateCalcDotProduct

class IVAStateCalcVectorDec(object):
    """Properties for a Vector Dec calculation object."""
    _uuid = "{5709E392-CEF3-4D83-BC2C-FD3F67EE363F}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCoordAxesName"] = _raise_uninitialized_error
        self.__dict__["_SetCoordAxesName"] = _raise_uninitialized_error
        self.__dict__["_GetVectorName"] = _raise_uninitialized_error
        self.__dict__["_SetVectorName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcVectorDec._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcVectorDec from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcVectorDec = agcom.GUID(IVAStateCalcVectorDec._uuid)
        vtable_offset_local = IVAStateCalcVectorDec._vtable_offset - 1
        self.__dict__["_GetCoordAxesName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVectorDec, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCoordAxesName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVectorDec, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetVectorName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVectorDec, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetVectorName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVectorDec, vtable_offset_local+4, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcVectorDec.__dict__ and type(IVAStateCalcVectorDec.__dict__[attrname]) == property:
            return IVAStateCalcVectorDec.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcVectorDec.")
    
    @property
    def CoordAxesName(self) -> str:
        """The coordinate axes."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordAxesName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordAxesName.setter
    def CoordAxesName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordAxesName"](arg_inVal.COM_val))

    @property
    def VectorName(self) -> str:
        """The vector."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VectorName.setter
    def VectorName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVectorName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{5709E392-CEF3-4D83-BC2C-FD3F67EE363F}", IVAStateCalcVectorDec)
agcls.AgTypeNameMap["IVAStateCalcVectorDec"] = IVAStateCalcVectorDec

class IVAStateCalcVectorMag(object):
    """Properties for a Vector Mag calculation object."""
    _uuid = "{522AF5A3-02FE-49E3-931A-3E8234EF896F}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetVectorName"] = _raise_uninitialized_error
        self.__dict__["_SetVectorName"] = _raise_uninitialized_error
        self.__dict__["_GetUnitDimension"] = _raise_uninitialized_error
        self.__dict__["_SetUnitDimension"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcVectorMag._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcVectorMag from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcVectorMag = agcom.GUID(IVAStateCalcVectorMag._uuid)
        vtable_offset_local = IVAStateCalcVectorMag._vtable_offset - 1
        self.__dict__["_GetVectorName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVectorMag, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetVectorName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVectorMag, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetUnitDimension"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVectorMag, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetUnitDimension"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVectorMag, vtable_offset_local+4, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcVectorMag.__dict__ and type(IVAStateCalcVectorMag.__dict__[attrname]) == property:
            return IVAStateCalcVectorMag.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcVectorMag.")
    
    @property
    def VectorName(self) -> str:
        """The vector."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VectorName.setter
    def VectorName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVectorName"](arg_inVal.COM_val))

    @property
    def UnitDimension(self) -> str:
        """The unit dimension."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUnitDimension"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UnitDimension.setter
    def UnitDimension(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUnitDimension"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{522AF5A3-02FE-49E3-931A-3E8234EF896F}", IVAStateCalcVectorMag)
agcls.AgTypeNameMap["IVAStateCalcVectorMag"] = IVAStateCalcVectorMag

class IVAStateCalcVectorRA(object):
    """Properties for a Vector RA calculation object."""
    _uuid = "{E6AF6E11-F9BC-46E0-83C0-ACD79B45B4AD}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCoordAxesName"] = _raise_uninitialized_error
        self.__dict__["_SetCoordAxesName"] = _raise_uninitialized_error
        self.__dict__["_GetVectorName"] = _raise_uninitialized_error
        self.__dict__["_SetVectorName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcVectorRA._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcVectorRA from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcVectorRA = agcom.GUID(IVAStateCalcVectorRA._uuid)
        vtable_offset_local = IVAStateCalcVectorRA._vtable_offset - 1
        self.__dict__["_GetCoordAxesName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVectorRA, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCoordAxesName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVectorRA, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetVectorName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVectorRA, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetVectorName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcVectorRA, vtable_offset_local+4, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcVectorRA.__dict__ and type(IVAStateCalcVectorRA.__dict__[attrname]) == property:
            return IVAStateCalcVectorRA.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcVectorRA.")
    
    @property
    def CoordAxesName(self) -> str:
        """The coordinate axes."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordAxesName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordAxesName.setter
    def CoordAxesName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordAxesName"](arg_inVal.COM_val))

    @property
    def VectorName(self) -> str:
        """The vector."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVectorName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VectorName.setter
    def VectorName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVectorName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E6AF6E11-F9BC-46E0-83C0-ACD79B45B4AD}", IVAStateCalcVectorRA)
agcls.AgTypeNameMap["IVAStateCalcVectorRA"] = IVAStateCalcVectorRA

class IVAStateCalcOnePtAccess(object):
    """Properties for an Access calculation object."""
    _uuid = "{EE091E20-3104-48F9-8163-29272A8B81C8}"
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAberrationType"] = _raise_uninitialized_error
        self.__dict__["_SetAberrationType"] = _raise_uninitialized_error
        self.__dict__["_SetBaseSelection"] = _raise_uninitialized_error
        self.__dict__["_GetBaseSelectionType"] = _raise_uninitialized_error
        self.__dict__["_GetBaseSelection"] = _raise_uninitialized_error
        self.__dict__["_GetClockHost"] = _raise_uninitialized_error
        self.__dict__["_SetClockHost"] = _raise_uninitialized_error
        self.__dict__["_GetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_SetSignalSense"] = _raise_uninitialized_error
        self.__dict__["_GetTargetObject"] = _raise_uninitialized_error
        self.__dict__["_GetTimeDelayConvergenceTolerance"] = _raise_uninitialized_error
        self.__dict__["_SetTimeDelayConvergenceTolerance"] = _raise_uninitialized_error
        self.__dict__["_GetUseLightTimeDelay"] = _raise_uninitialized_error
        self.__dict__["_SetUseLightTimeDelay"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcOnePtAccess._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcOnePtAccess from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcOnePtAccess = agcom.GUID(IVAStateCalcOnePtAccess._uuid)
        vtable_offset_local = IVAStateCalcOnePtAccess._vtable_offset - 1
        self.__dict__["_GetAberrationType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOnePtAccess, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetAberrationType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOnePtAccess, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_SetBaseSelection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOnePtAccess, vtable_offset_local+3, agcom.LONG)
        self.__dict__["_GetBaseSelectionType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOnePtAccess, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_GetBaseSelection"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOnePtAccess, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_GetClockHost"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOnePtAccess, vtable_offset_local+6, POINTER(agcom.LONG))
        self.__dict__["_SetClockHost"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOnePtAccess, vtable_offset_local+7, agcom.LONG)
        self.__dict__["_GetSignalSense"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOnePtAccess, vtable_offset_local+8, POINTER(agcom.LONG))
        self.__dict__["_SetSignalSense"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOnePtAccess, vtable_offset_local+9, agcom.LONG)
        self.__dict__["_GetTargetObject"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOnePtAccess, vtable_offset_local+10, POINTER(agcom.PVOID))
        self.__dict__["_GetTimeDelayConvergenceTolerance"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOnePtAccess, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTimeDelayConvergenceTolerance"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOnePtAccess, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetUseLightTimeDelay"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOnePtAccess, vtable_offset_local+13, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseLightTimeDelay"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcOnePtAccess, vtable_offset_local+14, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcOnePtAccess.__dict__ and type(IVAStateCalcOnePtAccess.__dict__[attrname]) == property:
            return IVAStateCalcOnePtAccess.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcOnePtAccess.")
    
    @property
    def AberrationType(self) -> "AgEAberrationType":
        """The type of aberration to use, if light time delay is applied."""
        with agmarshall.AgEnum_arg(AgEAberrationType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAberrationType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AberrationType.setter
    def AberrationType(self, inVal:"AgEAberrationType") -> None:
        with agmarshall.AgEnum_arg(AgEAberrationType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAberrationType"](arg_inVal.COM_val))

    def SetBaseSelection(self, selection:"AgEVABaseSelection") -> None:
        """Base Selection"""
        with agmarshall.AgEnum_arg(AgEVABaseSelection, selection) as arg_selection:
            agcls.evaluate_hresult(self.__dict__["_SetBaseSelection"](arg_selection.COM_val))

    @property
    def BaseSelectionType(self) -> "AgEVABaseSelection":
        """The base selection type."""
        with agmarshall.AgEnum_arg(AgEVABaseSelection) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetBaseSelectionType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def BaseSelection(self) -> "ILinkToObject":
        """The base selection object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetBaseSelection"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def ClockHost(self) -> "AgEIvClockHost":
        """The object whose location is associated with time."""
        with agmarshall.AgEnum_arg(AgEIvClockHost) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetClockHost"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ClockHost.setter
    def ClockHost(self, inVal:"AgEIvClockHost") -> None:
        with agmarshall.AgEnum_arg(AgEIvClockHost, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetClockHost"](arg_inVal.COM_val))

    @property
    def SignalSense(self) -> "AgEIvTimeSense":
        """Sense of the signal at the base object."""
        with agmarshall.AgEnum_arg(AgEIvTimeSense) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSignalSense"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SignalSense.setter
    def SignalSense(self, inVal:"AgEIvTimeSense") -> None:
        with agmarshall.AgEnum_arg(AgEIvTimeSense, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSignalSense"](arg_inVal.COM_val))

    @property
    def TargetObject(self) -> "ILinkToObject":
        """The target object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTargetObject"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def TimeDelayConvergenceTolerance(self) -> float:
        """The time delay convergence tolerance, if light time delay is applied. Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTimeDelayConvergenceTolerance"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TimeDelayConvergenceTolerance.setter
    def TimeDelayConvergenceTolerance(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetTimeDelayConvergenceTolerance"](arg_inVal.COM_val))

    @property
    def UseLightTimeDelay(self) -> bool:
        """Tue if light time delay is applied."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseLightTimeDelay"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseLightTimeDelay.setter
    def UseLightTimeDelay(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseLightTimeDelay"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{EE091E20-3104-48F9-8163-29272A8B81C8}", IVAStateCalcOnePtAccess)
agcls.AgTypeNameMap["IVAStateCalcOnePtAccess"] = IVAStateCalcOnePtAccess

class IVAStateCalcDifferenceAcrossSegmentsOtherSat(object):
    """Properties for a Difference Across Segments Across Satellites calculation object."""
    _uuid = "{C5C0E056-EC28-4D88-A55F-6BA6D2F2976E}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCalcObjectName"] = _raise_uninitialized_error
        self.__dict__["_SetCalcObjectName"] = _raise_uninitialized_error
        self.__dict__["_GetOtherSegmentName"] = _raise_uninitialized_error
        self.__dict__["_SetOtherSegmentName"] = _raise_uninitialized_error
        self.__dict__["_GetSegmentStateToUse"] = _raise_uninitialized_error
        self.__dict__["_SetSegmentStateToUse"] = _raise_uninitialized_error
        self.__dict__["_GetDifferenceOrder"] = _raise_uninitialized_error
        self.__dict__["_SetDifferenceOrder"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSat"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcDifferenceAcrossSegmentsOtherSat._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcDifferenceAcrossSegmentsOtherSat from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcDifferenceAcrossSegmentsOtherSat = agcom.GUID(IVAStateCalcDifferenceAcrossSegmentsOtherSat._uuid)
        vtable_offset_local = IVAStateCalcDifferenceAcrossSegmentsOtherSat._vtable_offset - 1
        self.__dict__["_GetCalcObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDifferenceAcrossSegmentsOtherSat, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCalcObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDifferenceAcrossSegmentsOtherSat, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetOtherSegmentName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDifferenceAcrossSegmentsOtherSat, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetOtherSegmentName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDifferenceAcrossSegmentsOtherSat, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_GetSegmentStateToUse"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDifferenceAcrossSegmentsOtherSat, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetSegmentStateToUse"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDifferenceAcrossSegmentsOtherSat, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetDifferenceOrder"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDifferenceAcrossSegmentsOtherSat, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetDifferenceOrder"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDifferenceAcrossSegmentsOtherSat, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetReferenceSat"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDifferenceAcrossSegmentsOtherSat, vtable_offset_local+9, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcDifferenceAcrossSegmentsOtherSat.__dict__ and type(IVAStateCalcDifferenceAcrossSegmentsOtherSat.__dict__[attrname]) == property:
            return IVAStateCalcDifferenceAcrossSegmentsOtherSat.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcDifferenceAcrossSegmentsOtherSat.")
    
    @property
    def CalcObjectName(self) -> str:
        """The calculation object."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCalcObjectName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CalcObjectName.setter
    def CalcObjectName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCalcObjectName"](arg_inVal.COM_val))

    @property
    def OtherSegmentName(self) -> str:
        """The segment to be compared against."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetOtherSegmentName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @OtherSegmentName.setter
    def OtherSegmentName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetOtherSegmentName"](arg_inVal.COM_val))

    @property
    def SegmentStateToUse(self) -> "AgEVASegmentState":
        """The segment state to use in the calculation."""
        with agmarshall.AgEnum_arg(AgEVASegmentState) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSegmentStateToUse"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SegmentStateToUse.setter
    def SegmentStateToUse(self, inVal:"AgEVASegmentState") -> None:
        with agmarshall.AgEnum_arg(AgEVASegmentState, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSegmentStateToUse"](arg_inVal.COM_val))

    @property
    def DifferenceOrder(self) -> "AgEVASegmentDifferenceOrder":
        """The order of the difference calculation."""
        with agmarshall.AgEnum_arg(AgEVASegmentDifferenceOrder) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDifferenceOrder"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DifferenceOrder.setter
    def DifferenceOrder(self, inVal:"AgEVASegmentDifferenceOrder") -> None:
        with agmarshall.AgEnum_arg(AgEVASegmentDifferenceOrder, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDifferenceOrder"](arg_inVal.COM_val))

    @property
    def ReferenceSat(self) -> "ILinkToObject":
        """The Astrogator satellite on which the segment to be compared exists."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSat"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val


agcls.AgClassCatalog.add_catalog_entry("{C5C0E056-EC28-4D88-A55F-6BA6D2F2976E}", IVAStateCalcDifferenceAcrossSegmentsOtherSat)
agcls.AgTypeNameMap["IVAStateCalcDifferenceAcrossSegmentsOtherSat"] = IVAStateCalcDifferenceAcrossSegmentsOtherSat

class IVAStateCalcValueAtSegmentOtherSat(object):
    """Properties for a Value At Segment Across Satellites calculation object."""
    _uuid = "{1F7F3653-10FD-4377-B8FB-8C42DABDACC3}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCalcObjectName"] = _raise_uninitialized_error
        self.__dict__["_SetCalcObjectName"] = _raise_uninitialized_error
        self.__dict__["_GetOtherSegmentName"] = _raise_uninitialized_error
        self.__dict__["_SetOtherSegmentName"] = _raise_uninitialized_error
        self.__dict__["_GetSegmentStateToUse"] = _raise_uninitialized_error
        self.__dict__["_SetSegmentStateToUse"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceSat"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcValueAtSegmentOtherSat._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcValueAtSegmentOtherSat from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcValueAtSegmentOtherSat = agcom.GUID(IVAStateCalcValueAtSegmentOtherSat._uuid)
        vtable_offset_local = IVAStateCalcValueAtSegmentOtherSat._vtable_offset - 1
        self.__dict__["_GetCalcObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcValueAtSegmentOtherSat, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCalcObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcValueAtSegmentOtherSat, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetOtherSegmentName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcValueAtSegmentOtherSat, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetOtherSegmentName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcValueAtSegmentOtherSat, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_GetSegmentStateToUse"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcValueAtSegmentOtherSat, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetSegmentStateToUse"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcValueAtSegmentOtherSat, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetReferenceSat"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcValueAtSegmentOtherSat, vtable_offset_local+7, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcValueAtSegmentOtherSat.__dict__ and type(IVAStateCalcValueAtSegmentOtherSat.__dict__[attrname]) == property:
            return IVAStateCalcValueAtSegmentOtherSat.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcValueAtSegmentOtherSat.")
    
    @property
    def CalcObjectName(self) -> str:
        """The calculation object."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCalcObjectName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CalcObjectName.setter
    def CalcObjectName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCalcObjectName"](arg_inVal.COM_val))

    @property
    def OtherSegmentName(self) -> str:
        """The segment to be compared against."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetOtherSegmentName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @OtherSegmentName.setter
    def OtherSegmentName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetOtherSegmentName"](arg_inVal.COM_val))

    @property
    def SegmentStateToUse(self) -> "AgEVASegmentState":
        """The segment state to use in the calculation."""
        with agmarshall.AgEnum_arg(AgEVASegmentState) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSegmentStateToUse"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SegmentStateToUse.setter
    def SegmentStateToUse(self, inVal:"AgEVASegmentState") -> None:
        with agmarshall.AgEnum_arg(AgEVASegmentState, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSegmentStateToUse"](arg_inVal.COM_val))

    @property
    def ReferenceSat(self) -> "ILinkToObject":
        """The Astrogator satellite on which the segment to be compared exists."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceSat"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val


agcls.AgClassCatalog.add_catalog_entry("{1F7F3653-10FD-4377-B8FB-8C42DABDACC3}", IVAStateCalcValueAtSegmentOtherSat)
agcls.AgTypeNameMap["IVAStateCalcValueAtSegmentOtherSat"] = IVAStateCalcValueAtSegmentOtherSat

class IVAStateCalcRARate(object):
    """Properties for a Right Ascension Rate calculation object"""
    _uuid = "{69DDD91C-168B-47BD-9977-EB8431B4C112}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_SetCoordSystemName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcRARate._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcRARate from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcRARate = agcom.GUID(IVAStateCalcRARate._uuid)
        vtable_offset_local = IVAStateCalcRARate._vtable_offset - 1
        self.__dict__["_GetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRARate, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcRARate, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcRARate.__dict__ and type(IVAStateCalcRARate.__dict__[attrname]) == property:
            return IVAStateCalcRARate.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcRARate.")
    
    @property
    def CoordSystemName(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordSystemName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordSystemName.setter
    def CoordSystemName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordSystemName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{69DDD91C-168B-47BD-9977-EB8431B4C112}", IVAStateCalcRARate)
agcls.AgTypeNameMap["IVAStateCalcRARate"] = IVAStateCalcRARate

class IVAStateCalcDecRate(object):
    """Properties for a Declination Rate calculation object"""
    _uuid = "{EE447FA6-4B21-4823-8811-E0E3C38A29E2}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCoordSystemName"] = _raise_uninitialized_error
        self.__dict__["_SetCoordSystemName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcDecRate._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcDecRate from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcDecRate = agcom.GUID(IVAStateCalcDecRate._uuid)
        vtable_offset_local = IVAStateCalcDecRate._vtable_offset - 1
        self.__dict__["_GetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDecRate, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCoordSystemName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcDecRate, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcDecRate.__dict__ and type(IVAStateCalcDecRate.__dict__[attrname]) == property:
            return IVAStateCalcDecRate.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcDecRate.")
    
    @property
    def CoordSystemName(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoordSystemName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoordSystemName.setter
    def CoordSystemName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoordSystemName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{EE447FA6-4B21-4823-8811-E0E3C38A29E2}", IVAStateCalcDecRate)
agcls.AgTypeNameMap["IVAStateCalcDecRate"] = IVAStateCalcDecRate

class IVAStateCalcGravitationalParameter(object):
    """Properties for a Gravitational Parameter calculation object."""
    _uuid = "{1FE2F1B7-9FE8-409E-AAD8-92CC002CDED0}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetGravSource"] = _raise_uninitialized_error
        self.__dict__["_SetGravSource"] = _raise_uninitialized_error
        self.__dict__["_GetGravityFilename"] = _raise_uninitialized_error
        self.__dict__["_SetGravityFilename"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcGravitationalParameter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcGravitationalParameter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcGravitationalParameter = agcom.GUID(IVAStateCalcGravitationalParameter._uuid)
        vtable_offset_local = IVAStateCalcGravitationalParameter._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcGravitationalParameter, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcGravitationalParameter, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetGravSource"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcGravitationalParameter, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetGravSource"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcGravitationalParameter, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetGravityFilename"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcGravitationalParameter, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_SetGravityFilename"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcGravitationalParameter, vtable_offset_local+6, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcGravitationalParameter.__dict__ and type(IVAStateCalcGravitationalParameter.__dict__[attrname]) == property:
            return IVAStateCalcGravitationalParameter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcGravitationalParameter.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def GravSource(self) -> "AgEVAGravitationalParameterSource":
        """The source for the gravitational parameter."""
        with agmarshall.AgEnum_arg(AgEVAGravitationalParameterSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetGravSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @GravSource.setter
    def GravSource(self, inVal:"AgEVAGravitationalParameterSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAGravitationalParameterSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetGravSource"](arg_inVal.COM_val))

    @property
    def GravityFilename(self) -> str:
        """Source for the gravitational parameter if GravSource is set to Gravity File."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetGravityFilename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @GravityFilename.setter
    def GravityFilename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetGravityFilename"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{1FE2F1B7-9FE8-409E-AAD8-92CC002CDED0}", IVAStateCalcGravitationalParameter)
agcls.AgTypeNameMap["IVAStateCalcGravitationalParameter"] = IVAStateCalcGravitationalParameter

class IVAStateCalcReferenceRadius(object):
    """Properties for a Reference Radius calculation object."""
    _uuid = "{E736A217-0B66-48F6-99FA-D338835B4D40}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceRadiusSource"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceRadiusSource"] = _raise_uninitialized_error
        self.__dict__["_GetGravityFilename"] = _raise_uninitialized_error
        self.__dict__["_SetGravityFilename"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcReferenceRadius._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcReferenceRadius from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcReferenceRadius = agcom.GUID(IVAStateCalcReferenceRadius._uuid)
        vtable_offset_local = IVAStateCalcReferenceRadius._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcReferenceRadius, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcReferenceRadius, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetReferenceRadiusSource"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcReferenceRadius, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetReferenceRadiusSource"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcReferenceRadius, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetGravityFilename"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcReferenceRadius, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_SetGravityFilename"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcReferenceRadius, vtable_offset_local+6, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcReferenceRadius.__dict__ and type(IVAStateCalcReferenceRadius.__dict__[attrname]) == property:
            return IVAStateCalcReferenceRadius.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcReferenceRadius.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def ReferenceRadiusSource(self) -> "AgEVAReferenceRadiusSource":
        """The source for the reference radius."""
        with agmarshall.AgEnum_arg(AgEVAReferenceRadiusSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceRadiusSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ReferenceRadiusSource.setter
    def ReferenceRadiusSource(self, inVal:"AgEVAReferenceRadiusSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAReferenceRadiusSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceRadiusSource"](arg_inVal.COM_val))

    @property
    def GravityFilename(self) -> str:
        """Source for the reference radius if RefRadSource is set to Gravity File."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetGravityFilename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @GravityFilename.setter
    def GravityFilename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetGravityFilename"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E736A217-0B66-48F6-99FA-D338835B4D40}", IVAStateCalcReferenceRadius)
agcls.AgTypeNameMap["IVAStateCalcReferenceRadius"] = IVAStateCalcReferenceRadius

class IVAStateCalcGravCoeff(object):
    """Properties for a gravity coefficient calculation object."""
    _uuid = "{057976B1-EBDA-4674-9FC0-556D7BD87599}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetGravityFilename"] = _raise_uninitialized_error
        self.__dict__["_SetGravityFilename"] = _raise_uninitialized_error
        self.__dict__["_GetCoefficientType"] = _raise_uninitialized_error
        self.__dict__["_SetCoefficientType"] = _raise_uninitialized_error
        self.__dict__["_GetDegree"] = _raise_uninitialized_error
        self.__dict__["_SetDegree"] = _raise_uninitialized_error
        self.__dict__["_GetOrder"] = _raise_uninitialized_error
        self.__dict__["_SetOrder"] = _raise_uninitialized_error
        self.__dict__["_GetNormalizationType"] = _raise_uninitialized_error
        self.__dict__["_SetNormalizationType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcGravCoeff._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcGravCoeff from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcGravCoeff = agcom.GUID(IVAStateCalcGravCoeff._uuid)
        vtable_offset_local = IVAStateCalcGravCoeff._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcGravCoeff, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcGravCoeff, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetGravityFilename"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcGravCoeff, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetGravityFilename"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcGravCoeff, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_GetCoefficientType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcGravCoeff, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetCoefficientType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcGravCoeff, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetDegree"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcGravCoeff, vtable_offset_local+7, POINTER(agcom.INT))
        self.__dict__["_SetDegree"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcGravCoeff, vtable_offset_local+8, agcom.INT)
        self.__dict__["_GetOrder"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcGravCoeff, vtable_offset_local+9, POINTER(agcom.INT))
        self.__dict__["_SetOrder"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcGravCoeff, vtable_offset_local+10, agcom.INT)
        self.__dict__["_GetNormalizationType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcGravCoeff, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_SetNormalizationType"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcGravCoeff, vtable_offset_local+12, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcGravCoeff.__dict__ and type(IVAStateCalcGravCoeff.__dict__[attrname]) == property:
            return IVAStateCalcGravCoeff.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcGravCoeff.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def GravityFilename(self) -> str:
        """Source for the gravity coefficient."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetGravityFilename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @GravityFilename.setter
    def GravityFilename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetGravityFilename"](arg_inVal.COM_val))

    @property
    def CoefficientType(self) -> "AgEVAGravCoeffCoefficientType":
        """Coefficient type."""
        with agmarshall.AgEnum_arg(AgEVAGravCoeffCoefficientType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoefficientType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoefficientType.setter
    def CoefficientType(self, inVal:"AgEVAGravCoeffCoefficientType") -> None:
        with agmarshall.AgEnum_arg(AgEVAGravCoeffCoefficientType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoefficientType"](arg_inVal.COM_val))

    @property
    def Degree(self) -> int:
        """Degree of the coefficient."""
        with agmarshall.INT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDegree"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Degree.setter
    def Degree(self, inVal:int) -> None:
        with agmarshall.INT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDegree"](arg_inVal.COM_val))

    @property
    def Order(self) -> int:
        """Order of the coefficient."""
        with agmarshall.INT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetOrder"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Order.setter
    def Order(self, inVal:int) -> None:
        with agmarshall.INT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetOrder"](arg_inVal.COM_val))

    @property
    def NormalizationType(self) -> "AgEVAGravCoeffNormalizationType":
        """Normalization type."""
        with agmarshall.AgEnum_arg(AgEVAGravCoeffNormalizationType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNormalizationType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @NormalizationType.setter
    def NormalizationType(self, inVal:"AgEVAGravCoeffNormalizationType") -> None:
        with agmarshall.AgEnum_arg(AgEVAGravCoeffNormalizationType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetNormalizationType"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{057976B1-EBDA-4674-9FC0-556D7BD87599}", IVAStateCalcGravCoeff)
agcls.AgTypeNameMap["IVAStateCalcGravCoeff"] = IVAStateCalcGravCoeff

class IVAStateCalcSpeedOfLight(object):
    """Properties for a Speed of Light calculation object."""
    _uuid = "{6B7D157C-43CA-4ED4-9C3C-DF8E4ABAE4E0}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcSpeedOfLight._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcSpeedOfLight from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcSpeedOfLight = agcom.GUID(IVAStateCalcSpeedOfLight._uuid)
        vtable_offset_local = IVAStateCalcSpeedOfLight._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcSpeedOfLight.__dict__ and type(IVAStateCalcSpeedOfLight.__dict__[attrname]) == property:
            return IVAStateCalcSpeedOfLight.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcSpeedOfLight.")
    

agcls.AgClassCatalog.add_catalog_entry("{6B7D157C-43CA-4ED4-9C3C-DF8E4ABAE4E0}", IVAStateCalcSpeedOfLight)
agcls.AgTypeNameMap["IVAStateCalcSpeedOfLight"] = IVAStateCalcSpeedOfLight

class IVAStateCalcPi(object):
    """Properties for a Pi calculation object."""
    _uuid = "{DDE94FB4-1751-4F38-9304-5ACC35CDC811}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcPi._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcPi from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcPi = agcom.GUID(IVAStateCalcPi._uuid)
        vtable_offset_local = IVAStateCalcPi._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcPi.__dict__ and type(IVAStateCalcPi.__dict__[attrname]) == property:
            return IVAStateCalcPi.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcPi.")
    

agcls.AgClassCatalog.add_catalog_entry("{DDE94FB4-1751-4F38-9304-5ACC35CDC811}", IVAStateCalcPi)
agcls.AgTypeNameMap["IVAStateCalcPi"] = IVAStateCalcPi

class IVAStateCalcScalar(object):
    """Properties for a Scalar calculation object."""
    _uuid = "{D792B480-CCC7-4040-BD41-A26E56DE6CA8}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetScalarName"] = _raise_uninitialized_error
        self.__dict__["_SetScalarName"] = _raise_uninitialized_error
        self.__dict__["_GetUnitDimension"] = _raise_uninitialized_error
        self.__dict__["_SetUnitDimension"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcScalar._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcScalar from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcScalar = agcom.GUID(IVAStateCalcScalar._uuid)
        vtable_offset_local = IVAStateCalcScalar._vtable_offset - 1
        self.__dict__["_GetScalarName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcScalar, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetScalarName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcScalar, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetUnitDimension"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcScalar, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetUnitDimension"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcScalar, vtable_offset_local+4, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcScalar.__dict__ and type(IVAStateCalcScalar.__dict__[attrname]) == property:
            return IVAStateCalcScalar.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcScalar.")
    
    @property
    def ScalarName(self) -> str:
        """The scalar name."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetScalarName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ScalarName.setter
    def ScalarName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetScalarName"](arg_inVal.COM_val))

    @property
    def UnitDimension(self) -> str:
        """The unit dimension."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUnitDimension"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UnitDimension.setter
    def UnitDimension(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUnitDimension"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{D792B480-CCC7-4040-BD41-A26E56DE6CA8}", IVAStateCalcScalar)
agcls.AgTypeNameMap["IVAStateCalcScalar"] = IVAStateCalcScalar

class IVAStateCalcApparentSolarTime(object):
    """Properties for an Apparent Solar Time calculation object."""
    _uuid = "{439AD289-B0FE-4596-A6AC-A29B6F98C313}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcApparentSolarTime._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcApparentSolarTime from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcApparentSolarTime = agcom.GUID(IVAStateCalcApparentSolarTime._uuid)
        vtable_offset_local = IVAStateCalcApparentSolarTime._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcApparentSolarTime, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcApparentSolarTime, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcApparentSolarTime.__dict__ and type(IVAStateCalcApparentSolarTime.__dict__[attrname]) == property:
            return IVAStateCalcApparentSolarTime.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcApparentSolarTime.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{439AD289-B0FE-4596-A6AC-A29B6F98C313}", IVAStateCalcApparentSolarTime)
agcls.AgTypeNameMap["IVAStateCalcApparentSolarTime"] = IVAStateCalcApparentSolarTime

class IVAStateCalcEarthMeanSolarTime(object):
    """Properties for an Earth Mean Solar Time calculation object."""
    _uuid = "{45C37D81-A752-4AA8-AC7D-7FAD78AA7763}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcEarthMeanSolarTime._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcEarthMeanSolarTime from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcEarthMeanSolarTime = agcom.GUID(IVAStateCalcEarthMeanSolarTime._uuid)
        vtable_offset_local = IVAStateCalcEarthMeanSolarTime._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcEarthMeanSolarTime, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcEarthMeanSolarTime, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcEarthMeanSolarTime.__dict__ and type(IVAStateCalcEarthMeanSolarTime.__dict__[attrname]) == property:
            return IVAStateCalcEarthMeanSolarTime.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcEarthMeanSolarTime.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{45C37D81-A752-4AA8-AC7D-7FAD78AA7763}", IVAStateCalcEarthMeanSolarTime)
agcls.AgTypeNameMap["IVAStateCalcEarthMeanSolarTime"] = IVAStateCalcEarthMeanSolarTime

class IVAStateCalcEarthMeanLocTimeAN(object):
    """Properties for an Earth Mean Local Time of Ascending Node calculation object."""
    _uuid = "{325E3769-FB5E-4B6B-AC89-48CD5A09C528}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateCalcEarthMeanLocTimeAN._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateCalcEarthMeanLocTimeAN from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateCalcEarthMeanLocTimeAN = agcom.GUID(IVAStateCalcEarthMeanLocTimeAN._uuid)
        vtable_offset_local = IVAStateCalcEarthMeanLocTimeAN._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcEarthMeanLocTimeAN, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAStateCalcEarthMeanLocTimeAN, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateCalcEarthMeanLocTimeAN.__dict__ and type(IVAStateCalcEarthMeanLocTimeAN.__dict__[attrname]) == property:
            return IVAStateCalcEarthMeanLocTimeAN.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateCalcEarthMeanLocTimeAN.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{325E3769-FB5E-4B6B-AC89-48CD5A09C528}", IVAStateCalcEarthMeanLocTimeAN)
agcls.AgTypeNameMap["IVAStateCalcEarthMeanLocTimeAN"] = IVAStateCalcEarthMeanLocTimeAN

class IVACentralBodyCollection(object):
    """The list of central bodies."""
    _uuid = "{6A2BFAF1-F26A-439B-AF23-AD83B82A0D4A}"
    _num_methods = 8
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_Add"] = _raise_uninitialized_error
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_RemoveAll"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVACentralBodyCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVACentralBodyCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVACentralBodyCollection = agcom.GUID(IVACentralBodyCollection._uuid)
        vtable_offset_local = IVACentralBodyCollection._vtable_offset - 1
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVACentralBodyCollection, vtable_offset_local+1, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVACentralBodyCollection, vtable_offset_local+2, POINTER(agcom.LONG))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVACentralBodyCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_Add"] = IAGFUNCTYPE(pUnk, IID_IVACentralBodyCollection, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IVACentralBodyCollection, vtable_offset_local+5, agcom.VARIANT)
        self.__dict__["_RemoveAll"] = IAGFUNCTYPE(pUnk, IID_IVACentralBodyCollection, vtable_offset_local+6, )
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IVACentralBodyCollection, vtable_offset_local+7, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IVACentralBodyCollection, vtable_offset_local+8, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVACentralBodyCollection.__dict__ and type(IVACentralBodyCollection.__dict__[attrname]) == property:
            return IVACentralBodyCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVACentralBodyCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVACentralBody":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Item(self, indexOrCbName:typing.Any) -> "IVACentralBody":
        """Allows you to iterate through the collection."""
        with agmarshall.VARIANT_arg(indexOrCbName) as arg_indexOrCbName, \
             agmarshall.AgInterface_out_arg() as arg_ppCentralBody:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrCbName.COM_val, byref(arg_ppCentralBody.COM_val)))
            return arg_ppCentralBody.python_val

    @property
    def Count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Iterates through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def Add(self, cbName:str) -> None:
        """Adds a central body to the collection."""
        with agmarshall.BSTR_arg(cbName) as arg_cbName:
            agcls.evaluate_hresult(self.__dict__["_Add"](arg_cbName.COM_val))

    def Remove(self, indexOrName:typing.Any) -> None:
        """Removes a central body from the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_indexOrName.COM_val))

    def RemoveAll(self) -> None:
        """Remove all central bodies from the collection."""
        agcls.evaluate_hresult(self.__dict__["_RemoveAll"]())

    def GetItemByIndex(self, index:int) -> "IVACentralBody":
        """Retrieves a central body from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppCentralBody:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppCentralBody.COM_val)))
            return arg_ppCentralBody.python_val

    def GetItemByName(self, cbName:str) -> "IVACentralBody":
        """Retrieves a central body from the collection by name."""
        with agmarshall.BSTR_arg(cbName) as arg_cbName, \
             agmarshall.AgInterface_out_arg() as arg_ppCentralBody:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_cbName.COM_val, byref(arg_ppCentralBody.COM_val)))
            return arg_ppCentralBody.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{6A2BFAF1-F26A-439B-AF23-AD83B82A0D4A}", IVACentralBodyCollection)
agcls.AgTypeNameMap["IVACentralBodyCollection"] = IVACentralBodyCollection

class IVACbEphemeris(object):
    """The central body ephemeris source."""
    _uuid = "{AE91748E-8A2D-4D9D-9C39-88017D0CB591}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVACbEphemeris._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVACbEphemeris from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVACbEphemeris = agcom.GUID(IVACbEphemeris._uuid)
        vtable_offset_local = IVACbEphemeris._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVACbEphemeris.__dict__ and type(IVACbEphemeris.__dict__[attrname]) == property:
            return IVACbEphemeris.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVACbEphemeris.")
    

agcls.AgClassCatalog.add_catalog_entry("{AE91748E-8A2D-4D9D-9C39-88017D0CB591}", IVACbEphemeris)
agcls.AgTypeNameMap["IVACbEphemeris"] = IVACbEphemeris

class IVACbGravityModel(object):
    """Properties for a central body gravity model."""
    _uuid = "{B20E4246-ED81-4131-82AF-C76FAD7C57A8}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetGravitationalParam"] = _raise_uninitialized_error
        self.__dict__["_SetGravitationalParam"] = _raise_uninitialized_error
        self.__dict__["_GetRefDistance"] = _raise_uninitialized_error
        self.__dict__["_SetRefDistance"] = _raise_uninitialized_error
        self.__dict__["_GetJ2"] = _raise_uninitialized_error
        self.__dict__["_SetJ2"] = _raise_uninitialized_error
        self.__dict__["_GetJ3"] = _raise_uninitialized_error
        self.__dict__["_SetJ3"] = _raise_uninitialized_error
        self.__dict__["_GetJ4"] = _raise_uninitialized_error
        self.__dict__["_SetJ4"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVACbGravityModel._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVACbGravityModel from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVACbGravityModel = agcom.GUID(IVACbGravityModel._uuid)
        vtable_offset_local = IVACbGravityModel._vtable_offset - 1
        self.__dict__["_GetGravitationalParam"] = IAGFUNCTYPE(pUnk, IID_IVACbGravityModel, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetGravitationalParam"] = IAGFUNCTYPE(pUnk, IID_IVACbGravityModel, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetRefDistance"] = IAGFUNCTYPE(pUnk, IID_IVACbGravityModel, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRefDistance"] = IAGFUNCTYPE(pUnk, IID_IVACbGravityModel, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetJ2"] = IAGFUNCTYPE(pUnk, IID_IVACbGravityModel, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetJ2"] = IAGFUNCTYPE(pUnk, IID_IVACbGravityModel, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetJ3"] = IAGFUNCTYPE(pUnk, IID_IVACbGravityModel, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetJ3"] = IAGFUNCTYPE(pUnk, IID_IVACbGravityModel, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetJ4"] = IAGFUNCTYPE(pUnk, IID_IVACbGravityModel, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetJ4"] = IAGFUNCTYPE(pUnk, IID_IVACbGravityModel, vtable_offset_local+10, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVACbGravityModel.__dict__ and type(IVACbGravityModel.__dict__[attrname]) == property:
            return IVACbGravityModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVACbGravityModel.")
    
    @property
    def GravitationalParam(self) -> float:
        """The gravitational parameter to be used for purposes of this gravity model. Uses Gravitational Param Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetGravitationalParam"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @GravitationalParam.setter
    def GravitationalParam(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetGravitationalParam"](arg_newVal.COM_val))

    @property
    def RefDistance(self) -> float:
        """Distance from the center of mass of the central body to its surface. Typically defaults to the Maximum Radius entered in the Shape frame of the Central Body parameters window. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRefDistance"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RefDistance.setter
    def RefDistance(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetRefDistance"](arg_newVal.COM_val))

    @property
    def J2(self) -> float:
        """The J2 property. Taking into account first order Earth oblateness effects. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetJ2"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @J2.setter
    def J2(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetJ2"](arg_newVal.COM_val))

    @property
    def J3(self) -> float:
        """The J3 property. Taking into account first order longitudinal variations of the Earth's shape. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetJ3"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @J3.setter
    def J3(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetJ3"](arg_newVal.COM_val))

    @property
    def J4(self) -> float:
        """The J4 property. Taking into account first and second order Earth oblateness effects. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetJ4"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @J4.setter
    def J4(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetJ4"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{B20E4246-ED81-4131-82AF-C76FAD7C57A8}", IVACbGravityModel)
agcls.AgTypeNameMap["IVACbGravityModel"] = IVACbGravityModel

class IVACbShape(object):
    """The central body shape."""
    _uuid = "{4DD8FE3F-7B64-4477-9D9E-97226A04584D}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVACbShape._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVACbShape from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVACbShape = agcom.GUID(IVACbShape._uuid)
        vtable_offset_local = IVACbShape._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVACbShape.__dict__ and type(IVACbShape.__dict__[attrname]) == property:
            return IVACbShape.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVACbShape.")
    

agcls.AgClassCatalog.add_catalog_entry("{4DD8FE3F-7B64-4477-9D9E-97226A04584D}", IVACbShape)
agcls.AgTypeNameMap["IVACbShape"] = IVACbShape

class IVACbShapeSphere(IVACbShape):
    """Properties for the central body sphere shape."""
    _uuid = "{BF7B6D1A-62E6-4897-8861-233465975488}"
    _num_methods = 2
    _vtable_offset = IVACbShape._vtable_offset + IVACbShape._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetRadius"] = _raise_uninitialized_error
        self.__dict__["_SetRadius"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVACbShapeSphere._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVACbShapeSphere from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVACbShape._private_init(self, pUnk)
        IID_IVACbShapeSphere = agcom.GUID(IVACbShapeSphere._uuid)
        vtable_offset_local = IVACbShapeSphere._vtable_offset - 1
        self.__dict__["_GetRadius"] = IAGFUNCTYPE(pUnk, IID_IVACbShapeSphere, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRadius"] = IAGFUNCTYPE(pUnk, IID_IVACbShapeSphere, vtable_offset_local+2, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVACbShapeSphere.__dict__ and type(IVACbShapeSphere.__dict__[attrname]) == property:
            return IVACbShapeSphere.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVACbShape.__setattr__(self, attrname, value)
    
    @property
    def Radius(self) -> float:
        """The radius. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRadius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Radius.setter
    def Radius(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetRadius"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{BF7B6D1A-62E6-4897-8861-233465975488}", IVACbShapeSphere)
agcls.AgTypeNameMap["IVACbShapeSphere"] = IVACbShapeSphere

class IVACbShapeOblateSpheroid(IVACbShape):
    """Properties for the central body oblate spheroid shape."""
    _uuid = "{583AE2E3-8639-4C1F-B188-3C6AF867F0CD}"
    _num_methods = 5
    _vtable_offset = IVACbShape._vtable_offset + IVACbShape._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetMinRadius"] = _raise_uninitialized_error
        self.__dict__["_SetMinRadius"] = _raise_uninitialized_error
        self.__dict__["_GetMaxRadius"] = _raise_uninitialized_error
        self.__dict__["_SetMaxRadius"] = _raise_uninitialized_error
        self.__dict__["_GetFlatteningCoefficient"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVACbShapeOblateSpheroid._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVACbShapeOblateSpheroid from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVACbShape._private_init(self, pUnk)
        IID_IVACbShapeOblateSpheroid = agcom.GUID(IVACbShapeOblateSpheroid._uuid)
        vtable_offset_local = IVACbShapeOblateSpheroid._vtable_offset - 1
        self.__dict__["_GetMinRadius"] = IAGFUNCTYPE(pUnk, IID_IVACbShapeOblateSpheroid, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMinRadius"] = IAGFUNCTYPE(pUnk, IID_IVACbShapeOblateSpheroid, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetMaxRadius"] = IAGFUNCTYPE(pUnk, IID_IVACbShapeOblateSpheroid, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaxRadius"] = IAGFUNCTYPE(pUnk, IID_IVACbShapeOblateSpheroid, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetFlatteningCoefficient"] = IAGFUNCTYPE(pUnk, IID_IVACbShapeOblateSpheroid, vtable_offset_local+5, POINTER(agcom.DOUBLE))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVACbShapeOblateSpheroid.__dict__ and type(IVACbShapeOblateSpheroid.__dict__[attrname]) == property:
            return IVACbShapeOblateSpheroid.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVACbShape.__setattr__(self, attrname, value)
    
    @property
    def MinRadius(self) -> float:
        """The minimum radius. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinRadius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MinRadius.setter
    def MinRadius(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetMinRadius"](arg_newVal.COM_val))

    @property
    def MaxRadius(self) -> float:
        """The maximum radius. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxRadius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxRadius.setter
    def MaxRadius(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxRadius"](arg_newVal.COM_val))

    @property
    def FlatteningCoefficient(self) -> float:
        """The flattening coefficient; automatically derived from the minimum and maximum radii. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetFlatteningCoefficient"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{583AE2E3-8639-4C1F-B188-3C6AF867F0CD}", IVACbShapeOblateSpheroid)
agcls.AgTypeNameMap["IVACbShapeOblateSpheroid"] = IVACbShapeOblateSpheroid

class IVACbShapeTriaxialEllipsoid(IVACbShape):
    """Properties for the central body triaxial ellipsoid shape."""
    _uuid = "{E446F44B-EDEB-4643-BEDA-6EA807C27882}"
    _num_methods = 6
    _vtable_offset = IVACbShape._vtable_offset + IVACbShape._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSemiMajorAxis"] = _raise_uninitialized_error
        self.__dict__["_SetSemiMajorAxis"] = _raise_uninitialized_error
        self.__dict__["_GetSemiMidAxis"] = _raise_uninitialized_error
        self.__dict__["_SetSemiMidAxis"] = _raise_uninitialized_error
        self.__dict__["_GetSemiMinorAxis"] = _raise_uninitialized_error
        self.__dict__["_SetSemiMinorAxis"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVACbShapeTriaxialEllipsoid._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVACbShapeTriaxialEllipsoid from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVACbShape._private_init(self, pUnk)
        IID_IVACbShapeTriaxialEllipsoid = agcom.GUID(IVACbShapeTriaxialEllipsoid._uuid)
        vtable_offset_local = IVACbShapeTriaxialEllipsoid._vtable_offset - 1
        self.__dict__["_GetSemiMajorAxis"] = IAGFUNCTYPE(pUnk, IID_IVACbShapeTriaxialEllipsoid, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetSemiMajorAxis"] = IAGFUNCTYPE(pUnk, IID_IVACbShapeTriaxialEllipsoid, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetSemiMidAxis"] = IAGFUNCTYPE(pUnk, IID_IVACbShapeTriaxialEllipsoid, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetSemiMidAxis"] = IAGFUNCTYPE(pUnk, IID_IVACbShapeTriaxialEllipsoid, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetSemiMinorAxis"] = IAGFUNCTYPE(pUnk, IID_IVACbShapeTriaxialEllipsoid, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetSemiMinorAxis"] = IAGFUNCTYPE(pUnk, IID_IVACbShapeTriaxialEllipsoid, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVACbShapeTriaxialEllipsoid.__dict__ and type(IVACbShapeTriaxialEllipsoid.__dict__[attrname]) == property:
            return IVACbShapeTriaxialEllipsoid.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVACbShape.__setattr__(self, attrname, value)
    
    @property
    def SemiMajorAxis(self) -> float:
        """The semi-major axis. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSemiMajorAxis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SemiMajorAxis.setter
    def SemiMajorAxis(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetSemiMajorAxis"](arg_newVal.COM_val))

    @property
    def SemiMidAxis(self) -> float:
        """The semi-mid axis. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSemiMidAxis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SemiMidAxis.setter
    def SemiMidAxis(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetSemiMidAxis"](arg_newVal.COM_val))

    @property
    def SemiMinorAxis(self) -> float:
        """The semi-minor axis. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSemiMinorAxis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SemiMinorAxis.setter
    def SemiMinorAxis(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetSemiMinorAxis"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E446F44B-EDEB-4643-BEDA-6EA807C27882}", IVACbShapeTriaxialEllipsoid)
agcls.AgTypeNameMap["IVACbShapeTriaxialEllipsoid"] = IVACbShapeTriaxialEllipsoid

class IVACbAttitude(object):
    """The central body attitude."""
    _uuid = "{DF0EB27A-4546-4A2C-B154-49E86527784D}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVACbAttitude._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVACbAttitude from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVACbAttitude = agcom.GUID(IVACbAttitude._uuid)
        vtable_offset_local = IVACbAttitude._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVACbAttitude.__dict__ and type(IVACbAttitude.__dict__[attrname]) == property:
            return IVACbAttitude.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVACbAttitude.")
    

agcls.AgClassCatalog.add_catalog_entry("{DF0EB27A-4546-4A2C-B154-49E86527784D}", IVACbAttitude)
agcls.AgTypeNameMap["IVACbAttitude"] = IVACbAttitude

class IVACbAttitudeRotationCoefficientsFile(IVACbAttitude):
    """Properties for a rotation coefficients file attitude definition."""
    _uuid = "{E0F3153F-7F2D-46B7-B317-99EDABD12360}"
    _num_methods = 2
    _vtable_offset = IVACbAttitude._vtable_offset + IVACbAttitude._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFilename"] = _raise_uninitialized_error
        self.__dict__["_SetFilename"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVACbAttitudeRotationCoefficientsFile._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVACbAttitudeRotationCoefficientsFile from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVACbAttitude._private_init(self, pUnk)
        IID_IVACbAttitudeRotationCoefficientsFile = agcom.GUID(IVACbAttitudeRotationCoefficientsFile._uuid)
        vtable_offset_local = IVACbAttitudeRotationCoefficientsFile._vtable_offset - 1
        self.__dict__["_GetFilename"] = IAGFUNCTYPE(pUnk, IID_IVACbAttitudeRotationCoefficientsFile, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetFilename"] = IAGFUNCTYPE(pUnk, IID_IVACbAttitudeRotationCoefficientsFile, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVACbAttitudeRotationCoefficientsFile.__dict__ and type(IVACbAttitudeRotationCoefficientsFile.__dict__[attrname]) == property:
            return IVACbAttitudeRotationCoefficientsFile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVACbAttitude.__setattr__(self, attrname, value)
    
    @property
    def Filename(self) -> str:
        """The name of the rotation coefficients file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Filename.setter
    def Filename(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetFilename"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E0F3153F-7F2D-46B7-B317-99EDABD12360}", IVACbAttitudeRotationCoefficientsFile)
agcls.AgTypeNameMap["IVACbAttitudeRotationCoefficientsFile"] = IVACbAttitudeRotationCoefficientsFile

class IVACbAttitudeIAU1994(IVACbAttitude):
    """Properties for an IAU1994 attitude definition."""
    _uuid = "{7F28E973-1139-4D02-8F8C-C0F68E3035A9}"
    _num_methods = 12
    _vtable_offset = IVACbAttitude._vtable_offset + IVACbAttitude._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetRightAscension"] = _raise_uninitialized_error
        self.__dict__["_SetRightAscension"] = _raise_uninitialized_error
        self.__dict__["_GetDeclination"] = _raise_uninitialized_error
        self.__dict__["_SetDeclination"] = _raise_uninitialized_error
        self.__dict__["_GetRightAscensionRate"] = _raise_uninitialized_error
        self.__dict__["_SetRightAscensionRate"] = _raise_uninitialized_error
        self.__dict__["_GetDeclinationRate"] = _raise_uninitialized_error
        self.__dict__["_SetDeclinationRate"] = _raise_uninitialized_error
        self.__dict__["_GetRotationOffset"] = _raise_uninitialized_error
        self.__dict__["_SetRotationOffset"] = _raise_uninitialized_error
        self.__dict__["_GetRotationRate"] = _raise_uninitialized_error
        self.__dict__["_SetRotationRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVACbAttitudeIAU1994._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVACbAttitudeIAU1994 from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVACbAttitude._private_init(self, pUnk)
        IID_IVACbAttitudeIAU1994 = agcom.GUID(IVACbAttitudeIAU1994._uuid)
        vtable_offset_local = IVACbAttitudeIAU1994._vtable_offset - 1
        self.__dict__["_GetRightAscension"] = IAGFUNCTYPE(pUnk, IID_IVACbAttitudeIAU1994, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_SetRightAscension"] = IAGFUNCTYPE(pUnk, IID_IVACbAttitudeIAU1994, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_GetDeclination"] = IAGFUNCTYPE(pUnk, IID_IVACbAttitudeIAU1994, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_SetDeclination"] = IAGFUNCTYPE(pUnk, IID_IVACbAttitudeIAU1994, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_GetRightAscensionRate"] = IAGFUNCTYPE(pUnk, IID_IVACbAttitudeIAU1994, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRightAscensionRate"] = IAGFUNCTYPE(pUnk, IID_IVACbAttitudeIAU1994, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetDeclinationRate"] = IAGFUNCTYPE(pUnk, IID_IVACbAttitudeIAU1994, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDeclinationRate"] = IAGFUNCTYPE(pUnk, IID_IVACbAttitudeIAU1994, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetRotationOffset"] = IAGFUNCTYPE(pUnk, IID_IVACbAttitudeIAU1994, vtable_offset_local+9, POINTER(agcom.VARIANT))
        self.__dict__["_SetRotationOffset"] = IAGFUNCTYPE(pUnk, IID_IVACbAttitudeIAU1994, vtable_offset_local+10, agcom.VARIANT)
        self.__dict__["_GetRotationRate"] = IAGFUNCTYPE(pUnk, IID_IVACbAttitudeIAU1994, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRotationRate"] = IAGFUNCTYPE(pUnk, IID_IVACbAttitudeIAU1994, vtable_offset_local+12, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVACbAttitudeIAU1994.__dict__ and type(IVACbAttitudeIAU1994.__dict__[attrname]) == property:
            return IVACbAttitudeIAU1994.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVACbAttitude.__setattr__(self, attrname, value)
    
    @property
    def RightAscension(self) -> typing.Any:
        """The right ascension; the angle measured in the inertial equatorial plane from the inertial X axis in a right-handed sense about the inertial Z axis to the spin axis -- the angle  in the drawing below. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRightAscension"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RightAscension.setter
    def RightAscension(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetRightAscension"](arg_newVal.COM_val))

    @property
    def Declination(self) -> typing.Any:
        """The declination; the angle from the X-Y plane of the coordinate system to the spin axis vector. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDeclination"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Declination.setter
    def Declination(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetDeclination"](arg_newVal.COM_val))

    @property
    def RightAscensionRate(self) -> float:
        """The right ascension rate; the rate of change in the right ascension. Uses AngleRate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRightAscensionRate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RightAscensionRate.setter
    def RightAscensionRate(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetRightAscensionRate"](arg_newVal.COM_val))

    @property
    def DeclinationRate(self) -> float:
        """The declination rate; the rate of change in the declination. Uses AngleRate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDeclinationRate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DeclinationRate.setter
    def DeclinationRate(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetDeclinationRate"](arg_newVal.COM_val))

    @property
    def RotationOffset(self) -> typing.Any:
        """The rotation offset; the angle from the inertially fixed reference direction to the body-fixed prime meridian (0 deg longitude) at the time of epoch. Uses AngleUnit Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRotationOffset"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RotationOffset.setter
    def RotationOffset(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetRotationOffset"](arg_newVal.COM_val))

    @property
    def RotationRate(self) -> float:
        """The rotation rate; the rate of the central body's rotation. Uses AngleRate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRotationRate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RotationRate.setter
    def RotationRate(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetRotationRate"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7F28E973-1139-4D02-8F8C-C0F68E3035A9}", IVACbAttitudeIAU1994)
agcls.AgTypeNameMap["IVACbAttitudeIAU1994"] = IVACbAttitudeIAU1994

class IVACbEphemerisAnalyticOrbit(IVACbEphemeris):
    """Properties for the Analytic Orbit ephemeris source."""
    _uuid = "{662F2BBE-2CFB-41F7-A928-26A4909C31AB}"
    _num_methods = 26
    _vtable_offset = IVACbEphemeris._vtable_offset + IVACbEphemeris._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetEpoch"] = _raise_uninitialized_error
        self.__dict__["_SetEpoch"] = _raise_uninitialized_error
        self.__dict__["_GetSemiMajorAxis"] = _raise_uninitialized_error
        self.__dict__["_SetSemiMajorAxis"] = _raise_uninitialized_error
        self.__dict__["_GetSemiMajorAxisRate"] = _raise_uninitialized_error
        self.__dict__["_SetSemiMajorAxisRate"] = _raise_uninitialized_error
        self.__dict__["_GetEccentricity"] = _raise_uninitialized_error
        self.__dict__["_SetEccentricity"] = _raise_uninitialized_error
        self.__dict__["_GetEccentricityRate"] = _raise_uninitialized_error
        self.__dict__["_SetEccentricityRate"] = _raise_uninitialized_error
        self.__dict__["_GetInclination"] = _raise_uninitialized_error
        self.__dict__["_SetInclination"] = _raise_uninitialized_error
        self.__dict__["_GetInclinationRate"] = _raise_uninitialized_error
        self.__dict__["_SetInclinationRate"] = _raise_uninitialized_error
        self.__dict__["_GetRAAN"] = _raise_uninitialized_error
        self.__dict__["_SetRAAN"] = _raise_uninitialized_error
        self.__dict__["_GetRAANRate"] = _raise_uninitialized_error
        self.__dict__["_SetRAANRate"] = _raise_uninitialized_error
        self.__dict__["_GetArgOfPeriapsis"] = _raise_uninitialized_error
        self.__dict__["_SetArgOfPeriapsis"] = _raise_uninitialized_error
        self.__dict__["_GetArgOfPeriapsisRate"] = _raise_uninitialized_error
        self.__dict__["_SetArgOfPeriapsisRate"] = _raise_uninitialized_error
        self.__dict__["_GetMeanLongitude"] = _raise_uninitialized_error
        self.__dict__["_SetMeanLongitude"] = _raise_uninitialized_error
        self.__dict__["_GetMeanLongitudeRate"] = _raise_uninitialized_error
        self.__dict__["_SetMeanLongitudeRate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVACbEphemerisAnalyticOrbit._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVACbEphemerisAnalyticOrbit from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVACbEphemeris._private_init(self, pUnk)
        IID_IVACbEphemerisAnalyticOrbit = agcom.GUID(IVACbEphemerisAnalyticOrbit._uuid)
        vtable_offset_local = IVACbEphemerisAnalyticOrbit._vtable_offset - 1
        self.__dict__["_GetEpoch"] = IAGFUNCTYPE(pUnk, IID_IVACbEphemerisAnalyticOrbit, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetEpoch"] = IAGFUNCTYPE(pUnk, IID_IVACbEphemerisAnalyticOrbit, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetSemiMajorAxis"] = IAGFUNCTYPE(pUnk, IID_IVACbEphemerisAnalyticOrbit, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetSemiMajorAxis"] = IAGFUNCTYPE(pUnk, IID_IVACbEphemerisAnalyticOrbit, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetSemiMajorAxisRate"] = IAGFUNCTYPE(pUnk, IID_IVACbEphemerisAnalyticOrbit, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetSemiMajorAxisRate"] = IAGFUNCTYPE(pUnk, IID_IVACbEphemerisAnalyticOrbit, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetEccentricity"] = IAGFUNCTYPE(pUnk, IID_IVACbEphemerisAnalyticOrbit, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetEccentricity"] = IAGFUNCTYPE(pUnk, IID_IVACbEphemerisAnalyticOrbit, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetEccentricityRate"] = IAGFUNCTYPE(pUnk, IID_IVACbEphemerisAnalyticOrbit, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetEccentricityRate"] = IAGFUNCTYPE(pUnk, IID_IVACbEphemerisAnalyticOrbit, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetInclination"] = IAGFUNCTYPE(pUnk, IID_IVACbEphemerisAnalyticOrbit, vtable_offset_local+11, POINTER(agcom.VARIANT))
        self.__dict__["_SetInclination"] = IAGFUNCTYPE(pUnk, IID_IVACbEphemerisAnalyticOrbit, vtable_offset_local+12, agcom.VARIANT)
        self.__dict__["_GetInclinationRate"] = IAGFUNCTYPE(pUnk, IID_IVACbEphemerisAnalyticOrbit, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetInclinationRate"] = IAGFUNCTYPE(pUnk, IID_IVACbEphemerisAnalyticOrbit, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetRAAN"] = IAGFUNCTYPE(pUnk, IID_IVACbEphemerisAnalyticOrbit, vtable_offset_local+15, POINTER(agcom.VARIANT))
        self.__dict__["_SetRAAN"] = IAGFUNCTYPE(pUnk, IID_IVACbEphemerisAnalyticOrbit, vtable_offset_local+16, agcom.VARIANT)
        self.__dict__["_GetRAANRate"] = IAGFUNCTYPE(pUnk, IID_IVACbEphemerisAnalyticOrbit, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRAANRate"] = IAGFUNCTYPE(pUnk, IID_IVACbEphemerisAnalyticOrbit, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_GetArgOfPeriapsis"] = IAGFUNCTYPE(pUnk, IID_IVACbEphemerisAnalyticOrbit, vtable_offset_local+19, POINTER(agcom.VARIANT))
        self.__dict__["_SetArgOfPeriapsis"] = IAGFUNCTYPE(pUnk, IID_IVACbEphemerisAnalyticOrbit, vtable_offset_local+20, agcom.VARIANT)
        self.__dict__["_GetArgOfPeriapsisRate"] = IAGFUNCTYPE(pUnk, IID_IVACbEphemerisAnalyticOrbit, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_SetArgOfPeriapsisRate"] = IAGFUNCTYPE(pUnk, IID_IVACbEphemerisAnalyticOrbit, vtable_offset_local+22, agcom.DOUBLE)
        self.__dict__["_GetMeanLongitude"] = IAGFUNCTYPE(pUnk, IID_IVACbEphemerisAnalyticOrbit, vtable_offset_local+23, POINTER(agcom.VARIANT))
        self.__dict__["_SetMeanLongitude"] = IAGFUNCTYPE(pUnk, IID_IVACbEphemerisAnalyticOrbit, vtable_offset_local+24, agcom.VARIANT)
        self.__dict__["_GetMeanLongitudeRate"] = IAGFUNCTYPE(pUnk, IID_IVACbEphemerisAnalyticOrbit, vtable_offset_local+25, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMeanLongitudeRate"] = IAGFUNCTYPE(pUnk, IID_IVACbEphemerisAnalyticOrbit, vtable_offset_local+26, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVACbEphemerisAnalyticOrbit.__dict__ and type(IVACbEphemerisAnalyticOrbit.__dict__[attrname]) == property:
            return IVACbEphemerisAnalyticOrbit.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVACbEphemeris.__setattr__(self, attrname, value)
    
    @property
    def Epoch(self) -> float:
        """The epoch. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEpoch"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Epoch.setter
    def Epoch(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEpoch"](arg_newVal.COM_val))

    @property
    def SemiMajorAxis(self) -> float:
        """The semi-major axis; one-half the distance along the long axis of the elliptical orbit. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSemiMajorAxis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SemiMajorAxis.setter
    def SemiMajorAxis(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetSemiMajorAxis"](arg_newVal.COM_val))

    @property
    def SemiMajorAxisRate(self) -> float:
        """The semi-major axis rate of change. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSemiMajorAxisRate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SemiMajorAxisRate.setter
    def SemiMajorAxisRate(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetSemiMajorAxisRate"](arg_newVal.COM_val))

    @property
    def Eccentricity(self) -> float:
        """The eccentricity; the ratio of the distance between the two foci of the ellipse and its major axis. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEccentricity"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Eccentricity.setter
    def Eccentricity(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEccentricity"](arg_newVal.COM_val))

    @property
    def EccentricityRate(self) -> float:
        """The eccentricity rate of change. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEccentricityRate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EccentricityRate.setter
    def EccentricityRate(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetEccentricityRate"](arg_newVal.COM_val))

    @property
    def Inclination(self) -> typing.Any:
        """The inclination; the angle from the Z axis of the inertial coordinate system to the orbit angular velocity vector. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetInclination"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Inclination.setter
    def Inclination(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetInclination"](arg_newVal.COM_val))

    @property
    def InclinationRate(self) -> float:
        """The inclination rate of change. Uses AngleRate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetInclinationRate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @InclinationRate.setter
    def InclinationRate(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetInclinationRate"](arg_newVal.COM_val))

    @property
    def RAAN(self) -> typing.Any:
        """The right ascension; the angle from the X axis of the inertial coordinate system to the point where the orbit crosses the X-Y plane in the +Z direction. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRAAN"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RAAN.setter
    def RAAN(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetRAAN"](arg_newVal.COM_val))

    @property
    def RAANRate(self) -> float:
        """The right ascension rate of change. Uses AngleRate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRAANRate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RAANRate.setter
    def RAANRate(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetRAANRate"](arg_newVal.COM_val))

    @property
    def ArgOfPeriapsis(self) -> typing.Any:
        """The argument of periapsis; The angle measured in direction of the body's orbital motion, and in the orbit plane, from the ascending node to the periapsis of the orbit. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetArgOfPeriapsis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ArgOfPeriapsis.setter
    def ArgOfPeriapsis(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetArgOfPeriapsis"](arg_newVal.COM_val))

    @property
    def ArgOfPeriapsisRate(self) -> float:
        """The argument of periapsis rate of change. Uses AngleRate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetArgOfPeriapsisRate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ArgOfPeriapsisRate.setter
    def ArgOfPeriapsisRate(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetArgOfPeriapsisRate"](arg_newVal.COM_val))

    @property
    def MeanLongitude(self) -> typing.Any:
        """The mean longitude; the sum of the Right Ascension of the Ascending Node, the Argument of Periapsis and the Mean Anomaly. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMeanLongitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MeanLongitude.setter
    def MeanLongitude(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetMeanLongitude"](arg_newVal.COM_val))

    @property
    def MeanLongitudeRate(self) -> float:
        """The mean longitude rate of change. Uses AngleRate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMeanLongitudeRate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MeanLongitudeRate.setter
    def MeanLongitudeRate(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetMeanLongitudeRate"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{662F2BBE-2CFB-41F7-A928-26A4909C31AB}", IVACbEphemerisAnalyticOrbit)
agcls.AgTypeNameMap["IVACbEphemerisAnalyticOrbit"] = IVACbEphemerisAnalyticOrbit

class IVACbEphemerisJPLSpice(IVACbEphemeris):
    """Properties for the JPL SPICE ephemeris source."""
    _uuid = "{B6A4A547-92B1-4584-B8E9-D3C12ED6CC9C}"
    _num_methods = 2
    _vtable_offset = IVACbEphemeris._vtable_offset + IVACbEphemeris._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetJPLSpiceId"] = _raise_uninitialized_error
        self.__dict__["_SetJPLSpiceId"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVACbEphemerisJPLSpice._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVACbEphemerisJPLSpice from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVACbEphemeris._private_init(self, pUnk)
        IID_IVACbEphemerisJPLSpice = agcom.GUID(IVACbEphemerisJPLSpice._uuid)
        vtable_offset_local = IVACbEphemerisJPLSpice._vtable_offset - 1
        self.__dict__["_GetJPLSpiceId"] = IAGFUNCTYPE(pUnk, IID_IVACbEphemerisJPLSpice, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetJPLSpiceId"] = IAGFUNCTYPE(pUnk, IID_IVACbEphemerisJPLSpice, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVACbEphemerisJPLSpice.__dict__ and type(IVACbEphemerisJPLSpice.__dict__[attrname]) == property:
            return IVACbEphemerisJPLSpice.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVACbEphemeris.__setattr__(self, attrname, value)
    
    @property
    def JPLSpiceId(self) -> str:
        """The SPICE file name."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetJPLSpiceId"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @JPLSpiceId.setter
    def JPLSpiceId(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetJPLSpiceId"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{B6A4A547-92B1-4584-B8E9-D3C12ED6CC9C}", IVACbEphemerisJPLSpice)
agcls.AgTypeNameMap["IVACbEphemerisJPLSpice"] = IVACbEphemerisJPLSpice

class IVACbEphemerisFile(IVACbEphemeris):
    """Properties for the Ephemeris File ephemeris source."""
    _uuid = "{8B38CE6C-B8E1-489F-8ED1-B3703A13D986}"
    _num_methods = 2
    _vtable_offset = IVACbEphemeris._vtable_offset + IVACbEphemeris._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetFilename"] = _raise_uninitialized_error
        self.__dict__["_SetFilename"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVACbEphemerisFile._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVACbEphemerisFile from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVACbEphemeris._private_init(self, pUnk)
        IID_IVACbEphemerisFile = agcom.GUID(IVACbEphemerisFile._uuid)
        vtable_offset_local = IVACbEphemerisFile._vtable_offset - 1
        self.__dict__["_GetFilename"] = IAGFUNCTYPE(pUnk, IID_IVACbEphemerisFile, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetFilename"] = IAGFUNCTYPE(pUnk, IID_IVACbEphemerisFile, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVACbEphemerisFile.__dict__ and type(IVACbEphemerisFile.__dict__[attrname]) == property:
            return IVACbEphemerisFile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVACbEphemeris.__setattr__(self, attrname, value)
    
    @property
    def Filename(self) -> str:
        """The ephemeris file name."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetFilename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Filename.setter
    def Filename(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetFilename"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{8B38CE6C-B8E1-489F-8ED1-B3703A13D986}", IVACbEphemerisFile)
agcls.AgTypeNameMap["IVACbEphemerisFile"] = IVACbEphemerisFile

class IVACbEphemerisJPLDE(IVACbEphemeris):
    """Properties for the JPL DE ephemeris source."""
    _uuid = "{FCD86AB9-0919-46BC-BF99-287F49837BD5}"
    _num_methods = 2
    _vtable_offset = IVACbEphemeris._vtable_offset + IVACbEphemeris._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetJPLDEFilename"] = _raise_uninitialized_error
        self.__dict__["_SetJPLDEFilename"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVACbEphemerisJPLDE._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVACbEphemerisJPLDE from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVACbEphemeris._private_init(self, pUnk)
        IID_IVACbEphemerisJPLDE = agcom.GUID(IVACbEphemerisJPLDE._uuid)
        vtable_offset_local = IVACbEphemerisJPLDE._vtable_offset - 1
        self.__dict__["_GetJPLDEFilename"] = IAGFUNCTYPE(pUnk, IID_IVACbEphemerisJPLDE, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetJPLDEFilename"] = IAGFUNCTYPE(pUnk, IID_IVACbEphemerisJPLDE, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVACbEphemerisJPLDE.__dict__ and type(IVACbEphemerisJPLDE.__dict__[attrname]) == property:
            return IVACbEphemerisJPLDE.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVACbEphemeris.__setattr__(self, attrname, value)
    
    @property
    def JPLDEFilename(self) -> str:
        """The DE file name."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetJPLDEFilename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @JPLDEFilename.setter
    def JPLDEFilename(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetJPLDEFilename"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{FCD86AB9-0919-46BC-BF99-287F49837BD5}", IVACbEphemerisJPLDE)
agcls.AgTypeNameMap["IVACbEphemerisJPLDE"] = IVACbEphemerisJPLDE

class IVACbEphemerisPlanetary(IVACbEphemeris):
    """Properties for the Planetary Ephemeris file ephemeris source."""
    _uuid = "{471AE49F-1C98-4572-9EDD-16060AFA9208}"
    _num_methods = 2
    _vtable_offset = IVACbEphemeris._vtable_offset + IVACbEphemeris._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPlanetaryFilename"] = _raise_uninitialized_error
        self.__dict__["_SetPlanetaryFilename"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVACbEphemerisPlanetary._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVACbEphemerisPlanetary from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVACbEphemeris._private_init(self, pUnk)
        IID_IVACbEphemerisPlanetary = agcom.GUID(IVACbEphemerisPlanetary._uuid)
        vtable_offset_local = IVACbEphemerisPlanetary._vtable_offset - 1
        self.__dict__["_GetPlanetaryFilename"] = IAGFUNCTYPE(pUnk, IID_IVACbEphemerisPlanetary, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetPlanetaryFilename"] = IAGFUNCTYPE(pUnk, IID_IVACbEphemerisPlanetary, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVACbEphemerisPlanetary.__dict__ and type(IVACbEphemerisPlanetary.__dict__[attrname]) == property:
            return IVACbEphemerisPlanetary.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IVACbEphemeris.__setattr__(self, attrname, value)
    
    @property
    def PlanetaryFilename(self) -> str:
        """The planetary ephemeris file name."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPlanetaryFilename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @PlanetaryFilename.setter
    def PlanetaryFilename(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetPlanetaryFilename"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{471AE49F-1C98-4572-9EDD-16060AFA9208}", IVACbEphemerisPlanetary)
agcls.AgTypeNameMap["IVACbEphemerisPlanetary"] = IVACbEphemerisPlanetary

class IVACentralBody(object):
    """General properties for a central body."""
    _uuid = "{5AA2ACF6-1764-4E46-BA4F-4619640CBC83}"
    _num_methods = 41
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetGravitationalParam"] = _raise_uninitialized_error
        self.__dict__["_SetGravitationalParam"] = _raise_uninitialized_error
        self.__dict__["_GetParentName"] = _raise_uninitialized_error
        self.__dict__["_SetParentName"] = _raise_uninitialized_error
        self.__dict__["_GetChildren"] = _raise_uninitialized_error
        self.__dict__["_GetDefaultGravityModelName"] = _raise_uninitialized_error
        self.__dict__["_SetDefaultGravityModelByName"] = _raise_uninitialized_error
        self.__dict__["_GetDefaultGravityModelData"] = _raise_uninitialized_error
        self.__dict__["_AddGravityModel"] = _raise_uninitialized_error
        self.__dict__["_RemoveGravityModelByName"] = _raise_uninitialized_error
        self.__dict__["_GetDefaultShapeName"] = _raise_uninitialized_error
        self.__dict__["_GetDefaultShapeData"] = _raise_uninitialized_error
        self.__dict__["_SetDefaultShapeByName"] = _raise_uninitialized_error
        self.__dict__["_AddShape"] = _raise_uninitialized_error
        self.__dict__["_RemoveShapeByName"] = _raise_uninitialized_error
        self.__dict__["_GetDefaultAttitudeName"] = _raise_uninitialized_error
        self.__dict__["_GetDefaultAttitudeData"] = _raise_uninitialized_error
        self.__dict__["_SetDefaultAttitudeByName"] = _raise_uninitialized_error
        self.__dict__["_AddAttitude"] = _raise_uninitialized_error
        self.__dict__["_RemoveAttitudeByName"] = _raise_uninitialized_error
        self.__dict__["_GetDefaultEphemerisName"] = _raise_uninitialized_error
        self.__dict__["_SetDefaultEphemerisByName"] = _raise_uninitialized_error
        self.__dict__["_GetDefaultEphemerisData"] = _raise_uninitialized_error
        self.__dict__["_AddEphemeris"] = _raise_uninitialized_error
        self.__dict__["_RemoveEphemerisByName"] = _raise_uninitialized_error
        self.__dict__["_CutGravityModelByName"] = _raise_uninitialized_error
        self.__dict__["_CopyGravityModelByName"] = _raise_uninitialized_error
        self.__dict__["_PasteGravityModel"] = _raise_uninitialized_error
        self.__dict__["_AddCopyOfGravityModel"] = _raise_uninitialized_error
        self.__dict__["_CutShapeByName"] = _raise_uninitialized_error
        self.__dict__["_CopyShapeByName"] = _raise_uninitialized_error
        self.__dict__["_PasteShape"] = _raise_uninitialized_error
        self.__dict__["_AddCopyOfShape"] = _raise_uninitialized_error
        self.__dict__["_CutAttitudeByName"] = _raise_uninitialized_error
        self.__dict__["_CopyAttitudeByName"] = _raise_uninitialized_error
        self.__dict__["_PasteAttitude"] = _raise_uninitialized_error
        self.__dict__["_AddCopyOfAttitude"] = _raise_uninitialized_error
        self.__dict__["_CutEphemerisByName"] = _raise_uninitialized_error
        self.__dict__["_CopyEphemerisByName"] = _raise_uninitialized_error
        self.__dict__["_PasteEphemeris"] = _raise_uninitialized_error
        self.__dict__["_AddCopyOfEphemeris"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVACentralBody._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVACentralBody from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVACentralBody = agcom.GUID(IVACentralBody._uuid)
        vtable_offset_local = IVACentralBody._vtable_offset - 1
        self.__dict__["_GetGravitationalParam"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetGravitationalParam"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetParentName"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetParentName"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_GetChildren"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_GetDefaultGravityModelName"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+6, POINTER(agcom.BSTR))
        self.__dict__["_SetDefaultGravityModelByName"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+7, agcom.BSTR)
        self.__dict__["_GetDefaultGravityModelData"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_AddGravityModel"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+9, agcom.LONG, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_RemoveGravityModelByName"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+10, agcom.BSTR)
        self.__dict__["_GetDefaultShapeName"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+11, POINTER(agcom.BSTR))
        self.__dict__["_GetDefaultShapeData"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+12, POINTER(agcom.PVOID))
        self.__dict__["_SetDefaultShapeByName"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+13, agcom.BSTR)
        self.__dict__["_AddShape"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+14, agcom.LONG, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_RemoveShapeByName"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+15, agcom.BSTR)
        self.__dict__["_GetDefaultAttitudeName"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+16, POINTER(agcom.BSTR))
        self.__dict__["_GetDefaultAttitudeData"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+17, POINTER(agcom.PVOID))
        self.__dict__["_SetDefaultAttitudeByName"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+18, agcom.BSTR)
        self.__dict__["_AddAttitude"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+19, agcom.LONG, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_RemoveAttitudeByName"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+20, agcom.BSTR)
        self.__dict__["_GetDefaultEphemerisName"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+21, POINTER(agcom.BSTR))
        self.__dict__["_SetDefaultEphemerisByName"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+22, agcom.BSTR)
        self.__dict__["_GetDefaultEphemerisData"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+23, POINTER(agcom.PVOID))
        self.__dict__["_AddEphemeris"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+24, agcom.LONG, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_RemoveEphemerisByName"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+25, agcom.BSTR)
        self.__dict__["_CutGravityModelByName"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+26, agcom.BSTR)
        self.__dict__["_CopyGravityModelByName"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+27, agcom.BSTR)
        self.__dict__["_PasteGravityModel"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+28, POINTER(agcom.PVOID))
        self.__dict__["_AddCopyOfGravityModel"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+29, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_CutShapeByName"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+30, agcom.BSTR)
        self.__dict__["_CopyShapeByName"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+31, agcom.BSTR)
        self.__dict__["_PasteShape"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+32, POINTER(agcom.PVOID))
        self.__dict__["_AddCopyOfShape"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+33, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_CutAttitudeByName"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+34, agcom.BSTR)
        self.__dict__["_CopyAttitudeByName"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+35, agcom.BSTR)
        self.__dict__["_PasteAttitude"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+36, POINTER(agcom.PVOID))
        self.__dict__["_AddCopyOfAttitude"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+37, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_CutEphemerisByName"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+38, agcom.BSTR)
        self.__dict__["_CopyEphemerisByName"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+39, agcom.BSTR)
        self.__dict__["_PasteEphemeris"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+40, POINTER(agcom.PVOID))
        self.__dict__["_AddCopyOfEphemeris"] = IAGFUNCTYPE(pUnk, IID_IVACentralBody, vtable_offset_local+41, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVACentralBody.__dict__ and type(IVACentralBody.__dict__[attrname]) == property:
            return IVACentralBody.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVACentralBody.")
    
    @property
    def GravitationalParam(self) -> float:
        """The gravitational parameter to be used. Uses Gravity Parameter Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetGravitationalParam"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @GravitationalParam.setter
    def GravitationalParam(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetGravitationalParam"](arg_newVal.COM_val))

    @property
    def ParentName(self) -> str:
        """The parent of this central body."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetParentName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ParentName.setter
    def ParentName(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_SetParentName"](arg_newVal.COM_val))

    @property
    def Children(self) -> "IVACentralBodyCollection":
        """The children of this central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppCentralBodyCollection:
            agcls.evaluate_hresult(self.__dict__["_GetChildren"](byref(arg_ppCentralBodyCollection.COM_val)))
            return arg_ppCentralBodyCollection.python_val

    @property
    def DefaultGravityModelName(self) -> str:
        """The gravity model."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDefaultGravityModelName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def SetDefaultGravityModelByName(self, gravityModelName:str) -> None:
        """Selects a gravity model"""
        with agmarshall.BSTR_arg(gravityModelName) as arg_gravityModelName:
            agcls.evaluate_hresult(self.__dict__["_SetDefaultGravityModelByName"](arg_gravityModelName.COM_val))

    @property
    def DefaultGravityModelData(self) -> "IVACbGravityModel":
        """The gravity model parameters."""
        with agmarshall.AgInterface_out_arg() as arg_ppCbGravityModel:
            agcls.evaluate_hresult(self.__dict__["_GetDefaultGravityModelData"](byref(arg_ppCbGravityModel.COM_val)))
            return arg_ppCbGravityModel.python_val

    def AddGravityModel(self, eGravityModel:"AgEVACbGravityModel", uniqueName:str) -> "IVACbGravityModel":
        """Adds a central body gravity model type."""
        with agmarshall.AgEnum_arg(AgEVACbGravityModel, eGravityModel) as arg_eGravityModel, \
             agmarshall.BSTR_arg(uniqueName) as arg_uniqueName, \
             agmarshall.AgInterface_out_arg() as arg_ppCbGravityModel:
            agcls.evaluate_hresult(self.__dict__["_AddGravityModel"](arg_eGravityModel.COM_val, arg_uniqueName.COM_val, byref(arg_ppCbGravityModel.COM_val)))
            return arg_ppCbGravityModel.python_val

    def RemoveGravityModelByName(self, gravityModelName:str) -> None:
        """Removes a central body gravity model type."""
        with agmarshall.BSTR_arg(gravityModelName) as arg_gravityModelName:
            agcls.evaluate_hresult(self.__dict__["_RemoveGravityModelByName"](arg_gravityModelName.COM_val))

    @property
    def DefaultShapeName(self) -> str:
        """The shape of the central body."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDefaultShapeName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def DefaultShapeData(self) -> "IVACbShape":
        """The parameters of the central body shape."""
        with agmarshall.AgInterface_out_arg() as arg_ppCbShape:
            agcls.evaluate_hresult(self.__dict__["_GetDefaultShapeData"](byref(arg_ppCbShape.COM_val)))
            return arg_ppCbShape.python_val

    def SetDefaultShapeByName(self, shapeName:str) -> None:
        """Selects a central body shape."""
        with agmarshall.BSTR_arg(shapeName) as arg_shapeName:
            agcls.evaluate_hresult(self.__dict__["_SetDefaultShapeByName"](arg_shapeName.COM_val))

    def AddShape(self, eShape:"AgEVACbShape", uniqueName:str) -> "IVACbShape":
        """Adds a central body shape type from the available types."""
        with agmarshall.AgEnum_arg(AgEVACbShape, eShape) as arg_eShape, \
             agmarshall.BSTR_arg(uniqueName) as arg_uniqueName, \
             agmarshall.AgInterface_out_arg() as arg_ppCbShape:
            agcls.evaluate_hresult(self.__dict__["_AddShape"](arg_eShape.COM_val, arg_uniqueName.COM_val, byref(arg_ppCbShape.COM_val)))
            return arg_ppCbShape.python_val

    def RemoveShapeByName(self, shapeName:str) -> None:
        """Removes a central body shape type."""
        with agmarshall.BSTR_arg(shapeName) as arg_shapeName:
            agcls.evaluate_hresult(self.__dict__["_RemoveShapeByName"](arg_shapeName.COM_val))

    @property
    def DefaultAttitudeName(self) -> str:
        """The attitude of the central body."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDefaultAttitudeName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def DefaultAttitudeData(self) -> "IVACbAttitude":
        """The parameters of the central body attitude."""
        with agmarshall.AgInterface_out_arg() as arg_ppCbAttitude:
            agcls.evaluate_hresult(self.__dict__["_GetDefaultAttitudeData"](byref(arg_ppCbAttitude.COM_val)))
            return arg_ppCbAttitude.python_val

    def SetDefaultAttitudeByName(self, attitudeName:str) -> None:
        """Selects a central body attitude."""
        with agmarshall.BSTR_arg(attitudeName) as arg_attitudeName:
            agcls.evaluate_hresult(self.__dict__["_SetDefaultAttitudeByName"](arg_attitudeName.COM_val))

    def AddAttitude(self, eAttitude:"AgEVACbAttitude", uniqueName:str) -> "IVACbAttitude":
        """Adds a central body attitude type from the available types."""
        with agmarshall.AgEnum_arg(AgEVACbAttitude, eAttitude) as arg_eAttitude, \
             agmarshall.BSTR_arg(uniqueName) as arg_uniqueName, \
             agmarshall.AgInterface_out_arg() as arg_ppCbAttitude:
            agcls.evaluate_hresult(self.__dict__["_AddAttitude"](arg_eAttitude.COM_val, arg_uniqueName.COM_val, byref(arg_ppCbAttitude.COM_val)))
            return arg_ppCbAttitude.python_val

    def RemoveAttitudeByName(self, attitudeName:str) -> None:
        """Removes a central body attitude type."""
        with agmarshall.BSTR_arg(attitudeName) as arg_attitudeName:
            agcls.evaluate_hresult(self.__dict__["_RemoveAttitudeByName"](arg_attitudeName.COM_val))

    @property
    def DefaultEphemerisName(self) -> str:
        """The ephemeris of the central body."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDefaultEphemerisName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def SetDefaultEphemerisByName(self, ephemerisName:str) -> None:
        """Selects an ephemeris type."""
        with agmarshall.BSTR_arg(ephemerisName) as arg_ephemerisName:
            agcls.evaluate_hresult(self.__dict__["_SetDefaultEphemerisByName"](arg_ephemerisName.COM_val))

    @property
    def DefaultEphemerisData(self) -> "IVACbEphemeris":
        """The  parameters of the central body ephemeris."""
        with agmarshall.AgInterface_out_arg() as arg_ppCbEphemeris:
            agcls.evaluate_hresult(self.__dict__["_GetDefaultEphemerisData"](byref(arg_ppCbEphemeris.COM_val)))
            return arg_ppCbEphemeris.python_val

    def AddEphemeris(self, eEphemeris:"AgEVACbEphemeris", uniqueName:str) -> "IVACbEphemeris":
        """Adds an ephemeris type from the available types."""
        with agmarshall.AgEnum_arg(AgEVACbEphemeris, eEphemeris) as arg_eEphemeris, \
             agmarshall.BSTR_arg(uniqueName) as arg_uniqueName, \
             agmarshall.AgInterface_out_arg() as arg_ppCbEphemeris:
            agcls.evaluate_hresult(self.__dict__["_AddEphemeris"](arg_eEphemeris.COM_val, arg_uniqueName.COM_val, byref(arg_ppCbEphemeris.COM_val)))
            return arg_ppCbEphemeris.python_val

    def RemoveEphemerisByName(self, ephemerisName:str) -> None:
        """Removes an ephemeris type."""
        with agmarshall.BSTR_arg(ephemerisName) as arg_ephemerisName:
            agcls.evaluate_hresult(self.__dict__["_RemoveEphemerisByName"](arg_ephemerisName.COM_val))

    def CutGravityModelByName(self, gravityModelName:str) -> None:
        """Copies a gravity model to the clipboard and removes it from the central body"""
        with agmarshall.BSTR_arg(gravityModelName) as arg_gravityModelName:
            agcls.evaluate_hresult(self.__dict__["_CutGravityModelByName"](arg_gravityModelName.COM_val))

    def CopyGravityModelByName(self, gravityModelName:str) -> None:
        """Copies a gravity model to the clipboard."""
        with agmarshall.BSTR_arg(gravityModelName) as arg_gravityModelName:
            agcls.evaluate_hresult(self.__dict__["_CopyGravityModelByName"](arg_gravityModelName.COM_val))

    def PasteGravityModel(self) -> "IVACbGravityModel":
        """Adds the gravity model in the clipboard to the central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppCbGravityModel:
            agcls.evaluate_hresult(self.__dict__["_PasteGravityModel"](byref(arg_ppCbGravityModel.COM_val)))
            return arg_ppCbGravityModel.python_val

    def AddCopyOfGravityModel(self, gravityModel:"IVACbGravityModel") -> "IVACbGravityModel":
        """Adds the gravity model to the central body"""
        with agmarshall.AgInterface_in_arg(gravityModel, IVACbGravityModel) as arg_gravityModel, \
             agmarshall.AgInterface_out_arg() as arg_ppCbGravityModel:
            agcls.evaluate_hresult(self.__dict__["_AddCopyOfGravityModel"](arg_gravityModel.COM_val, byref(arg_ppCbGravityModel.COM_val)))
            return arg_ppCbGravityModel.python_val

    def CutShapeByName(self, shapeName:str) -> None:
        """Copies a central body shape to the clipboard and removes it from the central body"""
        with agmarshall.BSTR_arg(shapeName) as arg_shapeName:
            agcls.evaluate_hresult(self.__dict__["_CutShapeByName"](arg_shapeName.COM_val))

    def CopyShapeByName(self, shapeName:str) -> None:
        """Copies a central body shape to the clipboard."""
        with agmarshall.BSTR_arg(shapeName) as arg_shapeName:
            agcls.evaluate_hresult(self.__dict__["_CopyShapeByName"](arg_shapeName.COM_val))

    def PasteShape(self) -> "IVACbShape":
        """Adds the central body shape in the clipboard to the central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppCbShape:
            agcls.evaluate_hresult(self.__dict__["_PasteShape"](byref(arg_ppCbShape.COM_val)))
            return arg_ppCbShape.python_val

    def AddCopyOfShape(self, shape:"IVACbShape") -> "IVACbShape":
        """Adds the central body shape to the central body"""
        with agmarshall.AgInterface_in_arg(shape, IVACbShape) as arg_shape, \
             agmarshall.AgInterface_out_arg() as arg_ppCbShape:
            agcls.evaluate_hresult(self.__dict__["_AddCopyOfShape"](arg_shape.COM_val, byref(arg_ppCbShape.COM_val)))
            return arg_ppCbShape.python_val

    def CutAttitudeByName(self, attitudeName:str) -> None:
        """Copies a central body attitude definition to the clipboard and removes it from the central body"""
        with agmarshall.BSTR_arg(attitudeName) as arg_attitudeName:
            agcls.evaluate_hresult(self.__dict__["_CutAttitudeByName"](arg_attitudeName.COM_val))

    def CopyAttitudeByName(self, attitudeName:str) -> None:
        """Copies a central body attitude definition to the clipboard."""
        with agmarshall.BSTR_arg(attitudeName) as arg_attitudeName:
            agcls.evaluate_hresult(self.__dict__["_CopyAttitudeByName"](arg_attitudeName.COM_val))

    def PasteAttitude(self) -> "IVACbAttitude":
        """Adds the central body attitude definition in the clipboard to the central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppCbAttitude:
            agcls.evaluate_hresult(self.__dict__["_PasteAttitude"](byref(arg_ppCbAttitude.COM_val)))
            return arg_ppCbAttitude.python_val

    def AddCopyOfAttitude(self, attitude:"IVACbAttitude") -> "IVACbAttitude":
        """Adds the central body attitude definition to the central body"""
        with agmarshall.AgInterface_in_arg(attitude, IVACbAttitude) as arg_attitude, \
             agmarshall.AgInterface_out_arg() as arg_ppCbAttitude:
            agcls.evaluate_hresult(self.__dict__["_AddCopyOfAttitude"](arg_attitude.COM_val, byref(arg_ppCbAttitude.COM_val)))
            return arg_ppCbAttitude.python_val

    def CutEphemerisByName(self, ephemerisName:str) -> None:
        """Copies a central body ephemeris definition to the clipboard and removes it from the central body"""
        with agmarshall.BSTR_arg(ephemerisName) as arg_ephemerisName:
            agcls.evaluate_hresult(self.__dict__["_CutEphemerisByName"](arg_ephemerisName.COM_val))

    def CopyEphemerisByName(self, ephemerisName:str) -> None:
        """Copies a central body ephemeris definition to the clipboard."""
        with agmarshall.BSTR_arg(ephemerisName) as arg_ephemerisName:
            agcls.evaluate_hresult(self.__dict__["_CopyEphemerisByName"](arg_ephemerisName.COM_val))

    def PasteEphemeris(self) -> "IVACbEphemeris":
        """Adds the central body ephemeris definition in the clipboard to the central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppCbEphemeris:
            agcls.evaluate_hresult(self.__dict__["_PasteEphemeris"](byref(arg_ppCbEphemeris.COM_val)))
            return arg_ppCbEphemeris.python_val

    def AddCopyOfEphemeris(self, ephemeris:"IVACbEphemeris") -> "IVACbEphemeris":
        """Adds the central body ephemeris definition to the central body"""
        with agmarshall.AgInterface_in_arg(ephemeris, IVACbEphemeris) as arg_ephemeris, \
             agmarshall.AgInterface_out_arg() as arg_ppCbEphemeris:
            agcls.evaluate_hresult(self.__dict__["_AddCopyOfEphemeris"](arg_ephemeris.COM_val, byref(arg_ppCbEphemeris.COM_val)))
            return arg_ppCbEphemeris.python_val


agcls.AgClassCatalog.add_catalog_entry("{5AA2ACF6-1764-4E46-BA4F-4619640CBC83}", IVACentralBody)
agcls.AgTypeNameMap["IVACentralBody"] = IVACentralBody

class IVAPowerInternal(object):
    """Properties for the Internal Power power source component."""
    _uuid = "{8ACB8A4A-52E8-4E71-8FD1-37B53E392858}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetGeneratedPower"] = _raise_uninitialized_error
        self.__dict__["_SetGeneratedPower"] = _raise_uninitialized_error
        self.__dict__["_GetPercentDegradationPerYear"] = _raise_uninitialized_error
        self.__dict__["_SetPercentDegradationPerYear"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceEpoch"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceEpoch"] = _raise_uninitialized_error
        self.__dict__["_EnableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_DisableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_IsControlParameterEnabled"] = _raise_uninitialized_error
        self.__dict__["_GetControlParametersAvailable"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAPowerInternal._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAPowerInternal from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAPowerInternal = agcom.GUID(IVAPowerInternal._uuid)
        vtable_offset_local = IVAPowerInternal._vtable_offset - 1
        self.__dict__["_GetGeneratedPower"] = IAGFUNCTYPE(pUnk, IID_IVAPowerInternal, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetGeneratedPower"] = IAGFUNCTYPE(pUnk, IID_IVAPowerInternal, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetPercentDegradationPerYear"] = IAGFUNCTYPE(pUnk, IID_IVAPowerInternal, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetPercentDegradationPerYear"] = IAGFUNCTYPE(pUnk, IID_IVAPowerInternal, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetReferenceEpoch"] = IAGFUNCTYPE(pUnk, IID_IVAPowerInternal, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_SetReferenceEpoch"] = IAGFUNCTYPE(pUnk, IID_IVAPowerInternal, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_EnableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAPowerInternal, vtable_offset_local+7, agcom.LONG)
        self.__dict__["_DisableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAPowerInternal, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_IsControlParameterEnabled"] = IAGFUNCTYPE(pUnk, IID_IVAPowerInternal, vtable_offset_local+9, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetControlParametersAvailable"] = IAGFUNCTYPE(pUnk, IID_IVAPowerInternal, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAPowerInternal.__dict__ and type(IVAPowerInternal.__dict__[attrname]) == property:
            return IVAPowerInternal.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAPowerInternal.")
    
    @property
    def GeneratedPower(self) -> float:
        """The power generated by the spacecraft from internal sources. Uses Power Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetGeneratedPower"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @GeneratedPower.setter
    def GeneratedPower(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetGeneratedPower"](arg_inVal.COM_val))

    @property
    def PercentDegradationPerYear(self) -> float:
        """The percent degradation per year; degradation factor is (1-x%/yr)^(timeSinceRefEpoch). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPercentDegradationPerYear"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @PercentDegradationPerYear.setter
    def PercentDegradationPerYear(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetPercentDegradationPerYear"](arg_inVal.COM_val))

    @property
    def ReferenceEpoch(self) -> typing.Any:
        """The date and Time used as reference epoch for degradation. Uses DateFormat Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceEpoch"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ReferenceEpoch.setter
    def ReferenceEpoch(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceEpoch"](arg_inVal.COM_val))

    def EnableControlParameter(self, param:"AgEVAControlPowerInternal") -> None:
        """Enables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlPowerInternal, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_EnableControlParameter"](arg_param.COM_val))

    def DisableControlParameter(self, param:"AgEVAControlPowerInternal") -> None:
        """Disables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlPowerInternal, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_DisableControlParameter"](arg_param.COM_val))

    def IsControlParameterEnabled(self, param:"AgEVAControlPowerInternal") -> bool:
        """Sees if the specified control is enabled."""
        with agmarshall.AgEnum_arg(AgEVAControlPowerInternal, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_IsControlParameterEnabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ControlParametersAvailable(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetControlParametersAvailable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{8ACB8A4A-52E8-4E71-8FD1-37B53E392858}", IVAPowerInternal)
agcls.AgTypeNameMap["IVAPowerInternal"] = IVAPowerInternal

class IVAPowerProcessed(object):
    """Properties for the Processed Power power source component."""
    _uuid = "{D3C19CA2-B73F-48BB-9B24-A7860136AE03}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetLoad"] = _raise_uninitialized_error
        self.__dict__["_SetLoad"] = _raise_uninitialized_error
        self.__dict__["_GetEfficiency"] = _raise_uninitialized_error
        self.__dict__["_SetEfficiency"] = _raise_uninitialized_error
        self.__dict__["_GetInputPowerSourceName"] = _raise_uninitialized_error
        self.__dict__["_SetInputPowerSourceName"] = _raise_uninitialized_error
        self.__dict__["_EnableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_DisableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_IsControlParameterEnabled"] = _raise_uninitialized_error
        self.__dict__["_GetControlParametersAvailable"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAPowerProcessed._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAPowerProcessed from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAPowerProcessed = agcom.GUID(IVAPowerProcessed._uuid)
        vtable_offset_local = IVAPowerProcessed._vtable_offset - 1
        self.__dict__["_GetLoad"] = IAGFUNCTYPE(pUnk, IID_IVAPowerProcessed, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetLoad"] = IAGFUNCTYPE(pUnk, IID_IVAPowerProcessed, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetEfficiency"] = IAGFUNCTYPE(pUnk, IID_IVAPowerProcessed, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetEfficiency"] = IAGFUNCTYPE(pUnk, IID_IVAPowerProcessed, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetInputPowerSourceName"] = IAGFUNCTYPE(pUnk, IID_IVAPowerProcessed, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_SetInputPowerSourceName"] = IAGFUNCTYPE(pUnk, IID_IVAPowerProcessed, vtable_offset_local+6, agcom.BSTR)
        self.__dict__["_EnableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAPowerProcessed, vtable_offset_local+7, agcom.LONG)
        self.__dict__["_DisableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAPowerProcessed, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_IsControlParameterEnabled"] = IAGFUNCTYPE(pUnk, IID_IVAPowerProcessed, vtable_offset_local+9, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetControlParametersAvailable"] = IAGFUNCTYPE(pUnk, IID_IVAPowerProcessed, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAPowerProcessed.__dict__ and type(IVAPowerProcessed.__dict__[attrname]) == property:
            return IVAPowerProcessed.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAPowerProcessed.")
    
    @property
    def Load(self) -> float:
        """The power diverted from power source and unavailable to PPU. Uses Power Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLoad"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Load.setter
    def Load(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetLoad"](arg_inVal.COM_val))

    @property
    def Efficiency(self) -> float:
        """The efficiency of the PPU unit. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEfficiency"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Efficiency.setter
    def Efficiency(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetEfficiency"](arg_inVal.COM_val))

    @property
    def InputPowerSourceName(self) -> str:
        """The source of power available to PPU."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetInputPowerSourceName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @InputPowerSourceName.setter
    def InputPowerSourceName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetInputPowerSourceName"](arg_inVal.COM_val))

    def EnableControlParameter(self, param:"AgEVAControlPowerProcessed") -> None:
        """Enables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlPowerProcessed, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_EnableControlParameter"](arg_param.COM_val))

    def DisableControlParameter(self, param:"AgEVAControlPowerProcessed") -> None:
        """Disables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlPowerProcessed, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_DisableControlParameter"](arg_param.COM_val))

    def IsControlParameterEnabled(self, param:"AgEVAControlPowerProcessed") -> bool:
        """Sees if the specified control is enabled."""
        with agmarshall.AgEnum_arg(AgEVAControlPowerProcessed, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_IsControlParameterEnabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ControlParametersAvailable(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetControlParametersAvailable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{D3C19CA2-B73F-48BB-9B24-A7860136AE03}", IVAPowerProcessed)
agcls.AgTypeNameMap["IVAPowerProcessed"] = IVAPowerProcessed

class IVAPowerSolarArray(object):
    """Properties for the Solar Array Power power source component."""
    _uuid = "{E8776401-2DE0-49E8-8080-FD0442E57701}"
    _num_methods = 29
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetArea"] = _raise_uninitialized_error
        self.__dict__["_SetArea"] = _raise_uninitialized_error
        self.__dict__["_GetConcentration"] = _raise_uninitialized_error
        self.__dict__["_SetConcentration"] = _raise_uninitialized_error
        self.__dict__["_GetCellEfficiencyPercent"] = _raise_uninitialized_error
        self.__dict__["_SetCellEfficiencyPercent"] = _raise_uninitialized_error
        self.__dict__["_GetArrayEfficiencyPercent"] = _raise_uninitialized_error
        self.__dict__["_SetArrayEfficiencyPercent"] = _raise_uninitialized_error
        self.__dict__["_GetPercentDegradationPerYear"] = _raise_uninitialized_error
        self.__dict__["_SetPercentDegradationPerYear"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceEpoch"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceEpoch"] = _raise_uninitialized_error
        self.__dict__["_GetInclinationToSunLine"] = _raise_uninitialized_error
        self.__dict__["_SetInclinationToSunLine"] = _raise_uninitialized_error
        self.__dict__["_GetC0"] = _raise_uninitialized_error
        self.__dict__["_SetC0"] = _raise_uninitialized_error
        self.__dict__["_GetC1"] = _raise_uninitialized_error
        self.__dict__["_SetC1"] = _raise_uninitialized_error
        self.__dict__["_GetC2"] = _raise_uninitialized_error
        self.__dict__["_SetC2"] = _raise_uninitialized_error
        self.__dict__["_GetC3"] = _raise_uninitialized_error
        self.__dict__["_SetC3"] = _raise_uninitialized_error
        self.__dict__["_GetC4"] = _raise_uninitialized_error
        self.__dict__["_SetC4"] = _raise_uninitialized_error
        self.__dict__["_GetApproximationFormula"] = _raise_uninitialized_error
        self.__dict__["_EnableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_DisableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_IsControlParameterEnabled"] = _raise_uninitialized_error
        self.__dict__["_GetControlParametersAvailable"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAPowerSolarArray._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAPowerSolarArray from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAPowerSolarArray = agcom.GUID(IVAPowerSolarArray._uuid)
        vtable_offset_local = IVAPowerSolarArray._vtable_offset - 1
        self.__dict__["_GetArea"] = IAGFUNCTYPE(pUnk, IID_IVAPowerSolarArray, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetArea"] = IAGFUNCTYPE(pUnk, IID_IVAPowerSolarArray, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetConcentration"] = IAGFUNCTYPE(pUnk, IID_IVAPowerSolarArray, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetConcentration"] = IAGFUNCTYPE(pUnk, IID_IVAPowerSolarArray, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetCellEfficiencyPercent"] = IAGFUNCTYPE(pUnk, IID_IVAPowerSolarArray, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetCellEfficiencyPercent"] = IAGFUNCTYPE(pUnk, IID_IVAPowerSolarArray, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetArrayEfficiencyPercent"] = IAGFUNCTYPE(pUnk, IID_IVAPowerSolarArray, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetArrayEfficiencyPercent"] = IAGFUNCTYPE(pUnk, IID_IVAPowerSolarArray, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetPercentDegradationPerYear"] = IAGFUNCTYPE(pUnk, IID_IVAPowerSolarArray, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetPercentDegradationPerYear"] = IAGFUNCTYPE(pUnk, IID_IVAPowerSolarArray, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetReferenceEpoch"] = IAGFUNCTYPE(pUnk, IID_IVAPowerSolarArray, vtable_offset_local+11, POINTER(agcom.VARIANT))
        self.__dict__["_SetReferenceEpoch"] = IAGFUNCTYPE(pUnk, IID_IVAPowerSolarArray, vtable_offset_local+12, agcom.VARIANT)
        self.__dict__["_GetInclinationToSunLine"] = IAGFUNCTYPE(pUnk, IID_IVAPowerSolarArray, vtable_offset_local+13, POINTER(agcom.VARIANT))
        self.__dict__["_SetInclinationToSunLine"] = IAGFUNCTYPE(pUnk, IID_IVAPowerSolarArray, vtable_offset_local+14, agcom.VARIANT)
        self.__dict__["_GetC0"] = IAGFUNCTYPE(pUnk, IID_IVAPowerSolarArray, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_SetC0"] = IAGFUNCTYPE(pUnk, IID_IVAPowerSolarArray, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_GetC1"] = IAGFUNCTYPE(pUnk, IID_IVAPowerSolarArray, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_SetC1"] = IAGFUNCTYPE(pUnk, IID_IVAPowerSolarArray, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_GetC2"] = IAGFUNCTYPE(pUnk, IID_IVAPowerSolarArray, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_SetC2"] = IAGFUNCTYPE(pUnk, IID_IVAPowerSolarArray, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_GetC3"] = IAGFUNCTYPE(pUnk, IID_IVAPowerSolarArray, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_SetC3"] = IAGFUNCTYPE(pUnk, IID_IVAPowerSolarArray, vtable_offset_local+22, agcom.DOUBLE)
        self.__dict__["_GetC4"] = IAGFUNCTYPE(pUnk, IID_IVAPowerSolarArray, vtable_offset_local+23, POINTER(agcom.DOUBLE))
        self.__dict__["_SetC4"] = IAGFUNCTYPE(pUnk, IID_IVAPowerSolarArray, vtable_offset_local+24, agcom.DOUBLE)
        self.__dict__["_GetApproximationFormula"] = IAGFUNCTYPE(pUnk, IID_IVAPowerSolarArray, vtable_offset_local+25, POINTER(agcom.BSTR))
        self.__dict__["_EnableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAPowerSolarArray, vtable_offset_local+26, agcom.LONG)
        self.__dict__["_DisableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAPowerSolarArray, vtable_offset_local+27, agcom.LONG)
        self.__dict__["_IsControlParameterEnabled"] = IAGFUNCTYPE(pUnk, IID_IVAPowerSolarArray, vtable_offset_local+28, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetControlParametersAvailable"] = IAGFUNCTYPE(pUnk, IID_IVAPowerSolarArray, vtable_offset_local+29, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAPowerSolarArray.__dict__ and type(IVAPowerSolarArray.__dict__[attrname]) == property:
            return IVAPowerSolarArray.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAPowerSolarArray.")
    
    @property
    def Area(self) -> float:
        """The solar array panel area. Uses Area Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetArea"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Area.setter
    def Area(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetArea"](arg_inVal.COM_val))

    @property
    def Concentration(self) -> float:
        """The solar array concentrator factor. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetConcentration"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Concentration.setter
    def Concentration(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetConcentration"](arg_inVal.COM_val))

    @property
    def CellEfficiencyPercent(self) -> float:
        """The cell efficiency in producing output power from incident sunlight. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCellEfficiencyPercent"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CellEfficiencyPercent.setter
    def CellEfficiencyPercent(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCellEfficiencyPercent"](arg_inVal.COM_val))

    @property
    def ArrayEfficiencyPercent(self) -> float:
        """The array efficiency in producing output power from a collection of cells. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetArrayEfficiencyPercent"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ArrayEfficiencyPercent.setter
    def ArrayEfficiencyPercent(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetArrayEfficiencyPercent"](arg_inVal.COM_val))

    @property
    def PercentDegradationPerYear(self) -> float:
        """The percent degradation per year; degradation factor is (1-x%/yr)^(timeSinceRefEpoch). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPercentDegradationPerYear"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @PercentDegradationPerYear.setter
    def PercentDegradationPerYear(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetPercentDegradationPerYear"](arg_inVal.COM_val))

    @property
    def ReferenceEpoch(self) -> typing.Any:
        """The date and Time used as reference epoch for degradation. Uses DateFormat Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceEpoch"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ReferenceEpoch.setter
    def ReferenceEpoch(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceEpoch"](arg_inVal.COM_val))

    @property
    def InclinationToSunLine(self) -> typing.Any:
        """The angle between the panel normal vector to the apparent sun line. Uses AngleUnit Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetInclinationToSunLine"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @InclinationToSunLine.setter
    def InclinationToSunLine(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetInclinationToSunLine"](arg_inVal.COM_val))

    @property
    def C0(self) -> float:
        """The ThermalModel.C0 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetC0"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @C0.setter
    def C0(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetC0"](arg_inVal.COM_val))

    @property
    def C1(self) -> float:
        """The ThermalModel.C1 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetC1"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @C1.setter
    def C1(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetC1"](arg_inVal.COM_val))

    @property
    def C2(self) -> float:
        """The ThermalModel.C2 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetC2"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @C2.setter
    def C2(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetC2"](arg_inVal.COM_val))

    @property
    def C3(self) -> float:
        """The ThermalModel.C3 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetC3"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @C3.setter
    def C3(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetC3"](arg_inVal.COM_val))

    @property
    def C4(self) -> float:
        """The ThermalModel.C4 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetC4"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @C4.setter
    def C4(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetC4"](arg_inVal.COM_val))

    @property
    def ApproximationFormula(self) -> str:
        """The thermal factor as function of distance (in AU) to Sun."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetApproximationFormula"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def EnableControlParameter(self, param:"AgEVAControlPowerSolarArray") -> None:
        """Enables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlPowerSolarArray, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_EnableControlParameter"](arg_param.COM_val))

    def DisableControlParameter(self, param:"AgEVAControlPowerSolarArray") -> None:
        """Disables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlPowerSolarArray, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_DisableControlParameter"](arg_param.COM_val))

    def IsControlParameterEnabled(self, param:"AgEVAControlPowerSolarArray") -> bool:
        """Sees if the specified control is enabled."""
        with agmarshall.AgEnum_arg(AgEVAControlPowerSolarArray, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_IsControlParameterEnabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ControlParametersAvailable(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetControlParametersAvailable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{E8776401-2DE0-49E8-8080-FD0442E57701}", IVAPowerSolarArray)
agcls.AgTypeNameMap["IVAPowerSolarArray"] = IVAPowerSolarArray

class IVAGeneralRelativityFunction(object):
    """Properties for the General Relativity propagator function."""
    _uuid = "{020E7294-1784-40AA-95C2-153F87CB086F}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAGeneralRelativityFunction._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAGeneralRelativityFunction from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAGeneralRelativityFunction = agcom.GUID(IVAGeneralRelativityFunction._uuid)
        vtable_offset_local = IVAGeneralRelativityFunction._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAGeneralRelativityFunction.__dict__ and type(IVAGeneralRelativityFunction.__dict__[attrname]) == property:
            return IVAGeneralRelativityFunction.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAGeneralRelativityFunction.")
    

agcls.AgClassCatalog.add_catalog_entry("{020E7294-1784-40AA-95C2-153F87CB086F}", IVAGeneralRelativityFunction)
agcls.AgTypeNameMap["IVAGeneralRelativityFunction"] = IVAGeneralRelativityFunction

class IVAStateTransFunction(object):
    """Properties for the State Transition propagator function."""
    _uuid = "{67F8B465-6BC4-4736-8A83-EC7E55D45177}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAStateTransFunction._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAStateTransFunction from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAStateTransFunction = agcom.GUID(IVAStateTransFunction._uuid)
        vtable_offset_local = IVAStateTransFunction._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAStateTransFunction.__dict__ and type(IVAStateTransFunction.__dict__[attrname]) == property:
            return IVAStateTransFunction.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAStateTransFunction.")
    

agcls.AgClassCatalog.add_catalog_entry("{67F8B465-6BC4-4736-8A83-EC7E55D45177}", IVAStateTransFunction)
agcls.AgTypeNameMap["IVAStateTransFunction"] = IVAStateTransFunction

class IVACR3BPFunc(object):
    """Properties for the CR3BP propagator function."""
    _uuid = "{1A2E3655-CF88-4272-8B52-257397D913BF}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetSecondaryName"] = _raise_uninitialized_error
        self.__dict__["_SetSecondaryName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVACR3BPFunc._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVACR3BPFunc from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVACR3BPFunc = agcom.GUID(IVACR3BPFunc._uuid)
        vtable_offset_local = IVACR3BPFunc._vtable_offset - 1
        self.__dict__["_GetSecondaryName"] = IAGFUNCTYPE(pUnk, IID_IVACR3BPFunc, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetSecondaryName"] = IAGFUNCTYPE(pUnk, IID_IVACR3BPFunc, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVACR3BPFunc.__dict__ and type(IVACR3BPFunc.__dict__[attrname]) == property:
            return IVACR3BPFunc.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVACR3BPFunc.")
    
    @property
    def SecondaryName(self) -> str:
        """The secondary body following CR3BP model definitions."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSecondaryName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SecondaryName.setter
    def SecondaryName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSecondaryName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{1A2E3655-CF88-4272-8B52-257397D913BF}", IVACR3BPFunc)
agcls.AgTypeNameMap["IVACR3BPFunc"] = IVACR3BPFunc

class IVARadiationPressureFunction(object):
    """Properties for the Radiation Pressure propagator function."""
    _uuid = "{CED70D8F-A1BF-402D-A767-E7A6E857507C}"
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIncludeAlbedo"] = _raise_uninitialized_error
        self.__dict__["_SetIncludeAlbedo"] = _raise_uninitialized_error
        self.__dict__["_GetIncludeThermalRadiationPressure"] = _raise_uninitialized_error
        self.__dict__["_SetIncludeThermalRadiationPressure"] = _raise_uninitialized_error
        self.__dict__["_GetGroundReflectionModelFilename"] = _raise_uninitialized_error
        self.__dict__["_SetGroundReflectionModelFilename"] = _raise_uninitialized_error
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetOverrideSegmentSettings"] = _raise_uninitialized_error
        self.__dict__["_SetOverrideSegmentSettings"] = _raise_uninitialized_error
        self.__dict__["_GetRadPressureCoeff"] = _raise_uninitialized_error
        self.__dict__["_SetRadPressureCoeff"] = _raise_uninitialized_error
        self.__dict__["_GetRadPressureArea"] = _raise_uninitialized_error
        self.__dict__["_SetRadPressureArea"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVARadiationPressureFunction._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVARadiationPressureFunction from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVARadiationPressureFunction = agcom.GUID(IVARadiationPressureFunction._uuid)
        vtable_offset_local = IVARadiationPressureFunction._vtable_offset - 1
        self.__dict__["_GetIncludeAlbedo"] = IAGFUNCTYPE(pUnk, IID_IVARadiationPressureFunction, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIncludeAlbedo"] = IAGFUNCTYPE(pUnk, IID_IVARadiationPressureFunction, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetIncludeThermalRadiationPressure"] = IAGFUNCTYPE(pUnk, IID_IVARadiationPressureFunction, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIncludeThermalRadiationPressure"] = IAGFUNCTYPE(pUnk, IID_IVARadiationPressureFunction, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_GetGroundReflectionModelFilename"] = IAGFUNCTYPE(pUnk, IID_IVARadiationPressureFunction, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_SetGroundReflectionModelFilename"] = IAGFUNCTYPE(pUnk, IID_IVARadiationPressureFunction, vtable_offset_local+6, agcom.BSTR)
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVARadiationPressureFunction, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_GetOverrideSegmentSettings"] = IAGFUNCTYPE(pUnk, IID_IVARadiationPressureFunction, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetOverrideSegmentSettings"] = IAGFUNCTYPE(pUnk, IID_IVARadiationPressureFunction, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_GetRadPressureCoeff"] = IAGFUNCTYPE(pUnk, IID_IVARadiationPressureFunction, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRadPressureCoeff"] = IAGFUNCTYPE(pUnk, IID_IVARadiationPressureFunction, vtable_offset_local+11, agcom.DOUBLE)
        self.__dict__["_GetRadPressureArea"] = IAGFUNCTYPE(pUnk, IID_IVARadiationPressureFunction, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRadPressureArea"] = IAGFUNCTYPE(pUnk, IID_IVARadiationPressureFunction, vtable_offset_local+13, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVARadiationPressureFunction.__dict__ and type(IVARadiationPressureFunction.__dict__[attrname]) == property:
            return IVARadiationPressureFunction.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVARadiationPressureFunction.")
    
    @property
    def IncludeAlbedo(self) -> bool:
        """True if including accelerations derived from albedo (reflected sunlight radiation from the central body)."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetIncludeAlbedo"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @IncludeAlbedo.setter
    def IncludeAlbedo(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetIncludeAlbedo"](arg_inVal.COM_val))

    @property
    def IncludeThermalRadiationPressure(self) -> bool:
        """True if including accelerations derived from thermal radiation pressure from the central body."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetIncludeThermalRadiationPressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @IncludeThermalRadiationPressure.setter
    def IncludeThermalRadiationPressure(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetIncludeThermalRadiationPressure"](arg_inVal.COM_val))

    @property
    def GroundReflectionModelFilename(self) -> str:
        """A file containing a ground reflection model used for albedo and thermal radiation pressure."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetGroundReflectionModelFilename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @GroundReflectionModelFilename.setter
    def GroundReflectionModelFilename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetGroundReflectionModelFilename"](arg_inVal.COM_val))

    @property
    def CentralBodyName(self) -> str:
        """Name of the central body."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def OverrideSegmentSettings(self) -> bool:
        """True to use Ck and area values defined on this component for radiation pressure computations, rather than those defined in the MCS segments."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetOverrideSegmentSettings"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @OverrideSegmentSettings.setter
    def OverrideSegmentSettings(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetOverrideSegmentSettings"](arg_inVal.COM_val))

    @property
    def RadPressureCoeff(self) -> float:
        """Coefficient, Ck, for use with radiation pressure computation."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRadPressureCoeff"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RadPressureCoeff.setter
    def RadPressureCoeff(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetRadPressureCoeff"](arg_inVal.COM_val))

    @property
    def RadPressureArea(self) -> float:
        """Area to be used for radiation pressure computations. Small area dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRadPressureArea"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RadPressureArea.setter
    def RadPressureArea(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetRadPressureArea"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{CED70D8F-A1BF-402D-A767-E7A6E857507C}", IVARadiationPressureFunction)
agcls.AgTypeNameMap["IVARadiationPressureFunction"] = IVARadiationPressureFunction

class IVAYarkovskyFunc(object):
    """Properties for the Yarkovsky Effect propagator function."""
    _uuid = "{AA6781B4-EACD-4100-8E23-C2771351BD7A}"
    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Getalpha"] = _raise_uninitialized_error
        self.__dict__["_Setalpha"] = _raise_uninitialized_error
        self.__dict__["_GetR0"] = _raise_uninitialized_error
        self.__dict__["_SetR0"] = _raise_uninitialized_error
        self.__dict__["_GetNM"] = _raise_uninitialized_error
        self.__dict__["_SetNM"] = _raise_uninitialized_error
        self.__dict__["_GetNN"] = _raise_uninitialized_error
        self.__dict__["_SetNN"] = _raise_uninitialized_error
        self.__dict__["_GetNK"] = _raise_uninitialized_error
        self.__dict__["_SetNK"] = _raise_uninitialized_error
        self.__dict__["_GetA1"] = _raise_uninitialized_error
        self.__dict__["_SetA1"] = _raise_uninitialized_error
        self.__dict__["_GetA2"] = _raise_uninitialized_error
        self.__dict__["_SetA2"] = _raise_uninitialized_error
        self.__dict__["_GetA3"] = _raise_uninitialized_error
        self.__dict__["_SetA3"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAYarkovskyFunc._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAYarkovskyFunc from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAYarkovskyFunc = agcom.GUID(IVAYarkovskyFunc._uuid)
        vtable_offset_local = IVAYarkovskyFunc._vtable_offset - 1
        self.__dict__["_Getalpha"] = IAGFUNCTYPE(pUnk, IID_IVAYarkovskyFunc, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_Setalpha"] = IAGFUNCTYPE(pUnk, IID_IVAYarkovskyFunc, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetR0"] = IAGFUNCTYPE(pUnk, IID_IVAYarkovskyFunc, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetR0"] = IAGFUNCTYPE(pUnk, IID_IVAYarkovskyFunc, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetNM"] = IAGFUNCTYPE(pUnk, IID_IVAYarkovskyFunc, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetNM"] = IAGFUNCTYPE(pUnk, IID_IVAYarkovskyFunc, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetNN"] = IAGFUNCTYPE(pUnk, IID_IVAYarkovskyFunc, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetNN"] = IAGFUNCTYPE(pUnk, IID_IVAYarkovskyFunc, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetNK"] = IAGFUNCTYPE(pUnk, IID_IVAYarkovskyFunc, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetNK"] = IAGFUNCTYPE(pUnk, IID_IVAYarkovskyFunc, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetA1"] = IAGFUNCTYPE(pUnk, IID_IVAYarkovskyFunc, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetA1"] = IAGFUNCTYPE(pUnk, IID_IVAYarkovskyFunc, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetA2"] = IAGFUNCTYPE(pUnk, IID_IVAYarkovskyFunc, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetA2"] = IAGFUNCTYPE(pUnk, IID_IVAYarkovskyFunc, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetA3"] = IAGFUNCTYPE(pUnk, IID_IVAYarkovskyFunc, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_SetA3"] = IAGFUNCTYPE(pUnk, IID_IVAYarkovskyFunc, vtable_offset_local+16, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAYarkovskyFunc.__dict__ and type(IVAYarkovskyFunc.__dict__[attrname]) == property:
            return IVAYarkovskyFunc.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAYarkovskyFunc.")
    
    @property
    def alpha(self) -> float:
        """Yarkovsky effect alpha constant. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_Getalpha"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @alpha.setter
    def alpha(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_Setalpha"](arg_inVal.COM_val))

    @property
    def R0(self) -> float:
        """Heliocentric sublimation distance. Uses distance dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetR0"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @R0.setter
    def R0(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetR0"](arg_inVal.COM_val))

    @property
    def NM(self) -> float:
        """Yarkovsky effect m exponent. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNM"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @NM.setter
    def NM(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetNM"](arg_inVal.COM_val))

    @property
    def NN(self) -> float:
        """Yarkovsky effect n exponent. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNN"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @NN.setter
    def NN(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetNN"](arg_inVal.COM_val))

    @property
    def NK(self) -> float:
        """Yarkovsky effect k exponent. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNK"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @NK.setter
    def NK(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetNK"](arg_inVal.COM_val))

    @property
    def A1(self) -> float:
        """Radial acceleration multiplier. Uses acceleration dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetA1"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @A1.setter
    def A1(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetA1"](arg_inVal.COM_val))

    @property
    def A2(self) -> float:
        """Velocity tangent acceleration multiplier. Uses acceleration dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetA2"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @A2.setter
    def A2(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetA2"](arg_inVal.COM_val))

    @property
    def A3(self) -> float:
        """Orbit normal acceleration multiplier. Uses acceleration dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetA3"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @A3.setter
    def A3(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetA3"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{AA6781B4-EACD-4100-8E23-C2771351BD7A}", IVAYarkovskyFunc)
agcls.AgTypeNameMap["IVAYarkovskyFunc"] = IVAYarkovskyFunc

class IVABlendedDensity(object):
    """Properties for the blended atmospheric density propagator function."""
    _uuid = "{E1951825-092B-48C8-88AE-7C878FBF40C3}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_AtmDensityModel"] = _raise_uninitialized_error
        self.__dict__["_LowAltAtmDensityModel"] = _raise_uninitialized_error
        self.__dict__["_GetDensityBlendingAltRange"] = _raise_uninitialized_error
        self.__dict__["_SetDensityBlendingAltRange"] = _raise_uninitialized_error
        self.__dict__["_GetAtmDensityModelName"] = _raise_uninitialized_error
        self.__dict__["_GetLowAltAtmDensityModelName"] = _raise_uninitialized_error
        self.__dict__["_GetUseApproxAltitude"] = _raise_uninitialized_error
        self.__dict__["_SetUseApproxAltitude"] = _raise_uninitialized_error
        self.__dict__["_GetLowerBoundUpperAtmModel"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVABlendedDensity._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVABlendedDensity from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVABlendedDensity = agcom.GUID(IVABlendedDensity._uuid)
        vtable_offset_local = IVABlendedDensity._vtable_offset - 1
        self.__dict__["_AtmDensityModel"] = IAGFUNCTYPE(pUnk, IID_IVABlendedDensity, vtable_offset_local+1, agcom.PVOID)
        self.__dict__["_LowAltAtmDensityModel"] = IAGFUNCTYPE(pUnk, IID_IVABlendedDensity, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_GetDensityBlendingAltRange"] = IAGFUNCTYPE(pUnk, IID_IVABlendedDensity, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDensityBlendingAltRange"] = IAGFUNCTYPE(pUnk, IID_IVABlendedDensity, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetAtmDensityModelName"] = IAGFUNCTYPE(pUnk, IID_IVABlendedDensity, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_GetLowAltAtmDensityModelName"] = IAGFUNCTYPE(pUnk, IID_IVABlendedDensity, vtable_offset_local+6, POINTER(agcom.BSTR))
        self.__dict__["_GetUseApproxAltitude"] = IAGFUNCTYPE(pUnk, IID_IVABlendedDensity, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseApproxAltitude"] = IAGFUNCTYPE(pUnk, IID_IVABlendedDensity, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_GetLowerBoundUpperAtmModel"] = IAGFUNCTYPE(pUnk, IID_IVABlendedDensity, vtable_offset_local+9, POINTER(agcom.DOUBLE))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVABlendedDensity.__dict__ and type(IVABlendedDensity.__dict__[attrname]) == property:
            return IVABlendedDensity.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVABlendedDensity.")
    
    def AtmDensityModel(self, pInVal:"IComponentInfo") -> None:
        """Embeds a nominal atmosphere model from the component browser."""
        with agmarshall.AgInterface_in_arg(pInVal, IComponentInfo) as arg_pInVal:
            agcls.evaluate_hresult(self.__dict__["_AtmDensityModel"](arg_pInVal.COM_val))

    def LowAltAtmDensityModel(self, pInVal:"IComponentInfo") -> None:
        """Embeds a low altitude atmosphere model from the component browser."""
        with agmarshall.AgInterface_in_arg(pInVal, IComponentInfo) as arg_pInVal:
            agcls.evaluate_hresult(self.__dict__["_LowAltAtmDensityModel"](arg_pInVal.COM_val))

    @property
    def DensityBlendingAltRange(self) -> float:
        """The blending range (distance dimension), begins at lower bound of upper model."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDensityBlendingAltRange"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DensityBlendingAltRange.setter
    def DensityBlendingAltRange(self, inVal:float) -> None:
        """Set the blending range."""
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDensityBlendingAltRange"](arg_inVal.COM_val))

    @property
    def AtmDensityModelName(self) -> str:
        """Returns the name of the embedded nominal atmospheric model."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmDensityModelName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def LowAltAtmDensityModelName(self) -> str:
        """Returns the name of the embedded low altitude atmospheric model."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLowAltAtmDensityModelName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def UseApproxAltitude(self) -> bool:
        """True if using approximate altitude formula (enforced on embedded models)."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseApproxAltitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseApproxAltitude.setter
    def UseApproxAltitude(self, pVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseApproxAltitude"](arg_pVal.COM_val))

    @property
    def LowerBoundUpperAtmModel(self) -> float:
        """The lowest valid altitude of the upper atmospheric density model."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLowerBoundUpperAtmModel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{E1951825-092B-48C8-88AE-7C878FBF40C3}", IVABlendedDensity)
agcls.AgTypeNameMap["IVABlendedDensity"] = IVABlendedDensity

class IVADragModelPlugin(object):
    """Properties for the Drag Model plugin."""
    _uuid = "{00D06156-07AD-4321-9741-9722A3D7BF85}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPluginIdentifier"] = _raise_uninitialized_error
        self.__dict__["_SetPluginIdentifier"] = _raise_uninitialized_error
        self.__dict__["_GetPluginConfig"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVADragModelPlugin._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVADragModelPlugin from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVADragModelPlugin = agcom.GUID(IVADragModelPlugin._uuid)
        vtable_offset_local = IVADragModelPlugin._vtable_offset - 1
        self.__dict__["_GetPluginIdentifier"] = IAGFUNCTYPE(pUnk, IID_IVADragModelPlugin, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetPluginIdentifier"] = IAGFUNCTYPE(pUnk, IID_IVADragModelPlugin, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetPluginConfig"] = IAGFUNCTYPE(pUnk, IID_IVADragModelPlugin, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVADragModelPlugin.__dict__ and type(IVADragModelPlugin.__dict__[attrname]) == property:
            return IVADragModelPlugin.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVADragModelPlugin.")
    
    @property
    def PluginIdentifier(self) -> str:
        """The plugin name."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPluginIdentifier"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @PluginIdentifier.setter
    def PluginIdentifier(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetPluginIdentifier"](arg_inVal.COM_val))

    @property
    def PluginConfig(self) -> "IVAPluginProperties":
        """The properties of the selected plugin."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPluginConfig"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{00D06156-07AD-4321-9741-9722A3D7BF85}", IVADragModelPlugin)
agcls.AgTypeNameMap["IVADragModelPlugin"] = IVADragModelPlugin

class IVACira72Function(object):
    """Properties for the CIRA 72 atmospheric model."""
    _uuid = "{9FFC517F-7B30-4780-8028-A3E309E5BAE4}"
    _num_methods = 29
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_SetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_GetComputesTemperature"] = _raise_uninitialized_error
        self.__dict__["_GetComputesPressure"] = _raise_uninitialized_error
        self.__dict__["_GetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_SetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataSource"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataSource"] = _raise_uninitialized_error
        self.__dict__["_GetF10p7"] = _raise_uninitialized_error
        self.__dict__["_SetF10p7"] = _raise_uninitialized_error
        self.__dict__["_GetF10p7Avg"] = _raise_uninitialized_error
        self.__dict__["_SetF10p7Avg"] = _raise_uninitialized_error
        self.__dict__["_GetKp"] = _raise_uninitialized_error
        self.__dict__["_SetKp"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataGeoMagneticFluxSource"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataGeoMagneticFluxSource"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataGeoMagneticFluxUpdateRate"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataGeoMagneticFluxUpdateRate"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataFilename"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataFilename"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPlugin"] = _raise_uninitialized_error
        self.__dict__["_GetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_SetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_GetNPlateDefinitionFile"] = _raise_uninitialized_error
        self.__dict__["_SetNPlateDefinitionFile"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVACira72Function._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVACira72Function from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVACira72Function = agcom.GUID(IVACira72Function._uuid)
        vtable_offset_local = IVACira72Function._vtable_offset - 1
        self.__dict__["_GetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVACira72Function, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVACira72Function, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetComputesTemperature"] = IAGFUNCTYPE(pUnk, IID_IVACira72Function, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetComputesPressure"] = IAGFUNCTYPE(pUnk, IID_IVACira72Function, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVACira72Function, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVACira72Function, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetAtmosDataSource"] = IAGFUNCTYPE(pUnk, IID_IVACira72Function, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetAtmosDataSource"] = IAGFUNCTYPE(pUnk, IID_IVACira72Function, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetF10p7"] = IAGFUNCTYPE(pUnk, IID_IVACira72Function, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetF10p7"] = IAGFUNCTYPE(pUnk, IID_IVACira72Function, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetF10p7Avg"] = IAGFUNCTYPE(pUnk, IID_IVACira72Function, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetF10p7Avg"] = IAGFUNCTYPE(pUnk, IID_IVACira72Function, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetKp"] = IAGFUNCTYPE(pUnk, IID_IVACira72Function, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetKp"] = IAGFUNCTYPE(pUnk, IID_IVACira72Function, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetAtmosDataGeoMagneticFluxSource"] = IAGFUNCTYPE(pUnk, IID_IVACira72Function, vtable_offset_local+15, POINTER(agcom.LONG))
        self.__dict__["_SetAtmosDataGeoMagneticFluxSource"] = IAGFUNCTYPE(pUnk, IID_IVACira72Function, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_GetAtmosDataGeoMagneticFluxUpdateRate"] = IAGFUNCTYPE(pUnk, IID_IVACira72Function, vtable_offset_local+17, POINTER(agcom.LONG))
        self.__dict__["_SetAtmosDataGeoMagneticFluxUpdateRate"] = IAGFUNCTYPE(pUnk, IID_IVACira72Function, vtable_offset_local+18, agcom.LONG)
        self.__dict__["_GetAtmosDataFilename"] = IAGFUNCTYPE(pUnk, IID_IVACira72Function, vtable_offset_local+19, POINTER(agcom.BSTR))
        self.__dict__["_SetAtmosDataFilename"] = IAGFUNCTYPE(pUnk, IID_IVACira72Function, vtable_offset_local+20, agcom.BSTR)
        self.__dict__["_GetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVACira72Function, vtable_offset_local+21, POINTER(agcom.LONG))
        self.__dict__["_SetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVACira72Function, vtable_offset_local+22, agcom.LONG)
        self.__dict__["_GetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVACira72Function, vtable_offset_local+23, POINTER(agcom.BSTR))
        self.__dict__["_SetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVACira72Function, vtable_offset_local+24, agcom.BSTR)
        self.__dict__["_GetDragModelPlugin"] = IAGFUNCTYPE(pUnk, IID_IVACira72Function, vtable_offset_local+25, POINTER(agcom.PVOID))
        self.__dict__["_GetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVACira72Function, vtable_offset_local+26, POINTER(agcom.BSTR))
        self.__dict__["_SetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVACira72Function, vtable_offset_local+27, agcom.BSTR)
        self.__dict__["_GetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVACira72Function, vtable_offset_local+28, POINTER(agcom.BSTR))
        self.__dict__["_SetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVACira72Function, vtable_offset_local+29, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVACira72Function.__dict__ and type(IVACira72Function.__dict__[attrname]) == property:
            return IVACira72Function.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVACira72Function.")
    
    @property
    def UseApproximateAltitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseApproximateAltitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseApproximateAltitude.setter
    def UseApproximateAltitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseApproximateAltitude"](arg_inVal.COM_val))

    @property
    def ComputesTemperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesTemperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ComputesPressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesPressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def SunPosition(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSunPosition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SunPosition.setter
    def SunPosition(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSunPosition"](arg_inVal.COM_val))

    @property
    def AtmosDataSource(self) -> "AgEVAAtmosDataSource":
        """The atmospheric model data source - data file or constant values."""
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataSource.setter
    def AtmosDataSource(self, inVal:"AgEVAAtmosDataSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataSource"](arg_inVal.COM_val))

    @property
    def F10p7(self) -> float:
        """Solar Flux (F10.7); the daily Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetF10p7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @F10p7.setter
    def F10p7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetF10p7"](arg_inVal.COM_val))

    @property
    def F10p7Avg(self) -> float:
        """Average solar Flux (F10.7); the 81-day averaged Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetF10p7Avg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @F10p7Avg.setter
    def F10p7Avg(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetF10p7Avg"](arg_inVal.COM_val))

    @property
    def Kp(self) -> float:
        """Geomagnetic Index (Kp). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetKp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Kp.setter
    def Kp(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetKp"](arg_inVal.COM_val))

    @property
    def AtmosDataGeoMagneticFluxSource(self) -> "AgEVAGeoMagneticFluxSource":
        """Whether to use Kp or Ap data from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataGeoMagneticFluxSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataGeoMagneticFluxSource.setter
    def AtmosDataGeoMagneticFluxSource(self, inVal:"AgEVAGeoMagneticFluxSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataGeoMagneticFluxSource"](arg_inVal.COM_val))

    @property
    def AtmosDataGeoMagneticFluxUpdateRate(self) -> "AgEVAGeoMagneticFluxUpdateRate":
        """The update rate of geomagnetic flux values from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataGeoMagneticFluxUpdateRate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataGeoMagneticFluxUpdateRate.setter
    def AtmosDataGeoMagneticFluxUpdateRate(self, inVal:"AgEVAGeoMagneticFluxUpdateRate") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataGeoMagneticFluxUpdateRate"](arg_inVal.COM_val))

    @property
    def AtmosDataFilename(self) -> str:
        """Flux file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataFilename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataFilename.setter
    def AtmosDataFilename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataFilename"](arg_inVal.COM_val))

    @property
    def DragModelType(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelType.setter
    def DragModelType(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelType"](arg_inVal.COM_val))

    @property
    def DragModelPluginName(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPluginName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelPluginName.setter
    def DragModelPluginName(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelPluginName"](arg_pVal.COM_val))

    @property
    def DragModelPlugin(self) -> "IVADragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPlugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VariableAreaHistoryFile(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVariableAreaHistoryFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VariableAreaHistoryFile.setter
    def VariableAreaHistoryFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVariableAreaHistoryFile"](arg_inVal.COM_val))

    @property
    def NPlateDefinitionFile(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNPlateDefinitionFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @NPlateDefinitionFile.setter
    def NPlateDefinitionFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetNPlateDefinitionFile"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{9FFC517F-7B30-4780-8028-A3E309E5BAE4}", IVACira72Function)
agcls.AgTypeNameMap["IVACira72Function"] = IVACira72Function

class IVAExponential(object):
    """Properties for the Exponential atmospheric model - a model that calculates atmospheric density using an equation involving a reference density, reference altitude, and scale altitude."""
    _uuid = "{987B718C-47F4-4638-900E-B87B0AAFEFBA}"
    _num_methods = 17
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_SetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceDensity"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceDensity"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceAltitude"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceAltitude"] = _raise_uninitialized_error
        self.__dict__["_GetScaleAltitude"] = _raise_uninitialized_error
        self.__dict__["_SetScaleAltitude"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPlugin"] = _raise_uninitialized_error
        self.__dict__["_GetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_SetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_GetNPlateDefinitionFile"] = _raise_uninitialized_error
        self.__dict__["_SetNPlateDefinitionFile"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAExponential._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAExponential from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAExponential = agcom.GUID(IVAExponential._uuid)
        vtable_offset_local = IVAExponential._vtable_offset - 1
        self.__dict__["_GetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAExponential, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAExponential, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetReferenceDensity"] = IAGFUNCTYPE(pUnk, IID_IVAExponential, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetReferenceDensity"] = IAGFUNCTYPE(pUnk, IID_IVAExponential, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetReferenceAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAExponential, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetReferenceAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAExponential, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetScaleAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAExponential, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetScaleAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAExponential, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVAExponential, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_SetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVAExponential, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_GetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVAExponential, vtable_offset_local+11, POINTER(agcom.BSTR))
        self.__dict__["_SetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVAExponential, vtable_offset_local+12, agcom.BSTR)
        self.__dict__["_GetDragModelPlugin"] = IAGFUNCTYPE(pUnk, IID_IVAExponential, vtable_offset_local+13, POINTER(agcom.PVOID))
        self.__dict__["_GetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVAExponential, vtable_offset_local+14, POINTER(agcom.BSTR))
        self.__dict__["_SetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVAExponential, vtable_offset_local+15, agcom.BSTR)
        self.__dict__["_GetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVAExponential, vtable_offset_local+16, POINTER(agcom.BSTR))
        self.__dict__["_SetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVAExponential, vtable_offset_local+17, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAExponential.__dict__ and type(IVAExponential.__dict__[attrname]) == property:
            return IVAExponential.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAExponential.")
    
    @property
    def UseApproximateAltitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseApproximateAltitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseApproximateAltitude.setter
    def UseApproximateAltitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseApproximateAltitude"](arg_inVal.COM_val))

    @property
    def ReferenceDensity(self) -> float:
        """The reference density. Uses Density Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceDensity"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ReferenceDensity.setter
    def ReferenceDensity(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceDensity"](arg_inVal.COM_val))

    @property
    def ReferenceAltitude(self) -> float:
        """The reference altitude. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceAltitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ReferenceAltitude.setter
    def ReferenceAltitude(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceAltitude"](arg_inVal.COM_val))

    @property
    def ScaleAltitude(self) -> float:
        """The scale altitude. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetScaleAltitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ScaleAltitude.setter
    def ScaleAltitude(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetScaleAltitude"](arg_inVal.COM_val))

    @property
    def DragModelType(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelType.setter
    def DragModelType(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelType"](arg_inVal.COM_val))

    @property
    def DragModelPluginName(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPluginName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelPluginName.setter
    def DragModelPluginName(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelPluginName"](arg_pVal.COM_val))

    @property
    def DragModelPlugin(self) -> "IVADragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPlugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VariableAreaHistoryFile(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVariableAreaHistoryFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VariableAreaHistoryFile.setter
    def VariableAreaHistoryFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVariableAreaHistoryFile"](arg_inVal.COM_val))

    @property
    def NPlateDefinitionFile(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNPlateDefinitionFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @NPlateDefinitionFile.setter
    def NPlateDefinitionFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetNPlateDefinitionFile"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{987B718C-47F4-4638-900E-B87B0AAFEFBA}", IVAExponential)
agcls.AgTypeNameMap["IVAExponential"] = IVAExponential

class IVAHarrisPriester(object):
    """Properties for the Harris-Priester atmospheric model - a model that takes into account a 10.7 cm solar flux level and diurnal bulge."""
    _uuid = "{4481139D-2D5D-48F0-9372-2385F8F95658}"
    _num_methods = 21
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_SetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_GetComputesTemperature"] = _raise_uninitialized_error
        self.__dict__["_GetComputesPressure"] = _raise_uninitialized_error
        self.__dict__["_GetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_SetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataSource"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataSource"] = _raise_uninitialized_error
        self.__dict__["_GetF10p7Avg"] = _raise_uninitialized_error
        self.__dict__["_SetF10p7Avg"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataFilename"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataFilename"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPlugin"] = _raise_uninitialized_error
        self.__dict__["_GetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_SetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_GetNPlateDefinitionFile"] = _raise_uninitialized_error
        self.__dict__["_SetNPlateDefinitionFile"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAHarrisPriester._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAHarrisPriester from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAHarrisPriester = agcom.GUID(IVAHarrisPriester._uuid)
        vtable_offset_local = IVAHarrisPriester._vtable_offset - 1
        self.__dict__["_GetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAHarrisPriester, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAHarrisPriester, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetComputesTemperature"] = IAGFUNCTYPE(pUnk, IID_IVAHarrisPriester, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetComputesPressure"] = IAGFUNCTYPE(pUnk, IID_IVAHarrisPriester, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVAHarrisPriester, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVAHarrisPriester, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetAtmosDataSource"] = IAGFUNCTYPE(pUnk, IID_IVAHarrisPriester, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetAtmosDataSource"] = IAGFUNCTYPE(pUnk, IID_IVAHarrisPriester, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetF10p7Avg"] = IAGFUNCTYPE(pUnk, IID_IVAHarrisPriester, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetF10p7Avg"] = IAGFUNCTYPE(pUnk, IID_IVAHarrisPriester, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetAtmosDataFilename"] = IAGFUNCTYPE(pUnk, IID_IVAHarrisPriester, vtable_offset_local+11, POINTER(agcom.BSTR))
        self.__dict__["_SetAtmosDataFilename"] = IAGFUNCTYPE(pUnk, IID_IVAHarrisPriester, vtable_offset_local+12, agcom.BSTR)
        self.__dict__["_GetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVAHarrisPriester, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_SetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVAHarrisPriester, vtable_offset_local+14, agcom.LONG)
        self.__dict__["_GetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVAHarrisPriester, vtable_offset_local+15, POINTER(agcom.BSTR))
        self.__dict__["_SetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVAHarrisPriester, vtable_offset_local+16, agcom.BSTR)
        self.__dict__["_GetDragModelPlugin"] = IAGFUNCTYPE(pUnk, IID_IVAHarrisPriester, vtable_offset_local+17, POINTER(agcom.PVOID))
        self.__dict__["_GetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVAHarrisPriester, vtable_offset_local+18, POINTER(agcom.BSTR))
        self.__dict__["_SetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVAHarrisPriester, vtable_offset_local+19, agcom.BSTR)
        self.__dict__["_GetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVAHarrisPriester, vtable_offset_local+20, POINTER(agcom.BSTR))
        self.__dict__["_SetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVAHarrisPriester, vtable_offset_local+21, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAHarrisPriester.__dict__ and type(IVAHarrisPriester.__dict__[attrname]) == property:
            return IVAHarrisPriester.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAHarrisPriester.")
    
    @property
    def UseApproximateAltitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseApproximateAltitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseApproximateAltitude.setter
    def UseApproximateAltitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseApproximateAltitude"](arg_inVal.COM_val))

    @property
    def ComputesTemperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesTemperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ComputesPressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesPressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def SunPosition(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSunPosition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SunPosition.setter
    def SunPosition(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSunPosition"](arg_inVal.COM_val))

    @property
    def AtmosDataSource(self) -> "AgEVAAtmosDataSource":
        """The atmospheric model data source - data file or constant values."""
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataSource.setter
    def AtmosDataSource(self, inVal:"AgEVAAtmosDataSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataSource"](arg_inVal.COM_val))

    @property
    def F10p7Avg(self) -> float:
        """Average solar Flux (F10.7); the 81-day averaged Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetF10p7Avg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @F10p7Avg.setter
    def F10p7Avg(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetF10p7Avg"](arg_inVal.COM_val))

    @property
    def AtmosDataFilename(self) -> str:
        """Flux file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataFilename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataFilename.setter
    def AtmosDataFilename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataFilename"](arg_inVal.COM_val))

    @property
    def DragModelType(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelType.setter
    def DragModelType(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelType"](arg_inVal.COM_val))

    @property
    def DragModelPluginName(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPluginName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelPluginName.setter
    def DragModelPluginName(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelPluginName"](arg_pVal.COM_val))

    @property
    def DragModelPlugin(self) -> "IVADragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPlugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VariableAreaHistoryFile(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVariableAreaHistoryFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VariableAreaHistoryFile.setter
    def VariableAreaHistoryFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVariableAreaHistoryFile"](arg_inVal.COM_val))

    @property
    def NPlateDefinitionFile(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNPlateDefinitionFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @NPlateDefinitionFile.setter
    def NPlateDefinitionFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetNPlateDefinitionFile"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4481139D-2D5D-48F0-9372-2385F8F95658}", IVAHarrisPriester)
agcls.AgTypeNameMap["IVAHarrisPriester"] = IVAHarrisPriester

class IVADensityModelPlugin(object):
    """Properties for the plugin atmospheric density model."""
    _uuid = "{FCE828BB-B2CE-4F2C-91EC-42ED00564FF4}"
    _num_methods = 51
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPluginIdentifier"] = _raise_uninitialized_error
        self.__dict__["_SetPluginIdentifier"] = _raise_uninitialized_error
        self.__dict__["_GetPluginConfig"] = _raise_uninitialized_error
        self.__dict__["_GetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_SetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_GetComputesTemperature"] = _raise_uninitialized_error
        self.__dict__["_GetComputesPressure"] = _raise_uninitialized_error
        self.__dict__["_GetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_SetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataSource"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataSource"] = _raise_uninitialized_error
        self.__dict__["_GetF10"] = _raise_uninitialized_error
        self.__dict__["_SetF10"] = _raise_uninitialized_error
        self.__dict__["_GetF10Avg"] = _raise_uninitialized_error
        self.__dict__["_SetF10Avg"] = _raise_uninitialized_error
        self.__dict__["_GetM10"] = _raise_uninitialized_error
        self.__dict__["_SetM10"] = _raise_uninitialized_error
        self.__dict__["_GetM10Avg"] = _raise_uninitialized_error
        self.__dict__["_SetM10Avg"] = _raise_uninitialized_error
        self.__dict__["_GetS10"] = _raise_uninitialized_error
        self.__dict__["_SetS10"] = _raise_uninitialized_error
        self.__dict__["_GetS10Avg"] = _raise_uninitialized_error
        self.__dict__["_SetS10Avg"] = _raise_uninitialized_error
        self.__dict__["_GetY10"] = _raise_uninitialized_error
        self.__dict__["_SetY10"] = _raise_uninitialized_error
        self.__dict__["_GetY10Avg"] = _raise_uninitialized_error
        self.__dict__["_SetY10Avg"] = _raise_uninitialized_error
        self.__dict__["_GetKp"] = _raise_uninitialized_error
        self.__dict__["_SetKp"] = _raise_uninitialized_error
        self.__dict__["_GetDstDTc"] = _raise_uninitialized_error
        self.__dict__["_SetDstDTc"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataGeoMagneticFluxSource"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataGeoMagneticFluxSource"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataGeoMagneticFluxUpdateRate"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataGeoMagneticFluxUpdateRate"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataFilename"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataFilename"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosAugDataFile"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosAugDataFile"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosAugDTCFile"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosAugDTCFile"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPlugin"] = _raise_uninitialized_error
        self.__dict__["_GetUsesAugmentedSpaceWeather"] = _raise_uninitialized_error
        self.__dict__["_GetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_SetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_GetNPlateDefinitionFile"] = _raise_uninitialized_error
        self.__dict__["_SetNPlateDefinitionFile"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVADensityModelPlugin._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVADensityModelPlugin from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVADensityModelPlugin = agcom.GUID(IVADensityModelPlugin._uuid)
        vtable_offset_local = IVADensityModelPlugin._vtable_offset - 1
        self.__dict__["_GetPluginIdentifier"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetPluginIdentifier"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetPluginConfig"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+5, agcom.VARIANT_BOOL)
        self.__dict__["_GetComputesTemperature"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+6, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetComputesPressure"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+8, POINTER(agcom.LONG))
        self.__dict__["_SetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+9, agcom.LONG)
        self.__dict__["_GetAtmosDataSource"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+10, POINTER(agcom.LONG))
        self.__dict__["_SetAtmosDataSource"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+11, agcom.LONG)
        self.__dict__["_GetF10"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_SetF10"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+13, agcom.DOUBLE)
        self.__dict__["_GetF10Avg"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+14, POINTER(agcom.DOUBLE))
        self.__dict__["_SetF10Avg"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+15, agcom.DOUBLE)
        self.__dict__["_GetM10"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+16, POINTER(agcom.DOUBLE))
        self.__dict__["_SetM10"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+17, agcom.DOUBLE)
        self.__dict__["_GetM10Avg"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+18, POINTER(agcom.DOUBLE))
        self.__dict__["_SetM10Avg"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+19, agcom.DOUBLE)
        self.__dict__["_GetS10"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+20, POINTER(agcom.DOUBLE))
        self.__dict__["_SetS10"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+21, agcom.DOUBLE)
        self.__dict__["_GetS10Avg"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+22, POINTER(agcom.DOUBLE))
        self.__dict__["_SetS10Avg"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+23, agcom.DOUBLE)
        self.__dict__["_GetY10"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+24, POINTER(agcom.DOUBLE))
        self.__dict__["_SetY10"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+25, agcom.DOUBLE)
        self.__dict__["_GetY10Avg"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+26, POINTER(agcom.DOUBLE))
        self.__dict__["_SetY10Avg"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+27, agcom.DOUBLE)
        self.__dict__["_GetKp"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+28, POINTER(agcom.DOUBLE))
        self.__dict__["_SetKp"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+29, agcom.DOUBLE)
        self.__dict__["_GetDstDTc"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+30, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDstDTc"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+31, agcom.DOUBLE)
        self.__dict__["_GetAtmosDataGeoMagneticFluxSource"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+32, POINTER(agcom.LONG))
        self.__dict__["_SetAtmosDataGeoMagneticFluxSource"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+33, agcom.LONG)
        self.__dict__["_GetAtmosDataGeoMagneticFluxUpdateRate"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+34, POINTER(agcom.LONG))
        self.__dict__["_SetAtmosDataGeoMagneticFluxUpdateRate"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+35, agcom.LONG)
        self.__dict__["_GetAtmosDataFilename"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+36, POINTER(agcom.BSTR))
        self.__dict__["_SetAtmosDataFilename"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+37, agcom.BSTR)
        self.__dict__["_GetAtmosAugDataFile"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+38, POINTER(agcom.BSTR))
        self.__dict__["_SetAtmosAugDataFile"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+39, agcom.BSTR)
        self.__dict__["_GetAtmosAugDTCFile"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+40, POINTER(agcom.BSTR))
        self.__dict__["_SetAtmosAugDTCFile"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+41, agcom.BSTR)
        self.__dict__["_GetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+42, POINTER(agcom.LONG))
        self.__dict__["_SetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+43, agcom.LONG)
        self.__dict__["_GetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+44, POINTER(agcom.BSTR))
        self.__dict__["_SetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+45, agcom.BSTR)
        self.__dict__["_GetDragModelPlugin"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+46, POINTER(agcom.PVOID))
        self.__dict__["_GetUsesAugmentedSpaceWeather"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+47, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+48, POINTER(agcom.BSTR))
        self.__dict__["_SetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+49, agcom.BSTR)
        self.__dict__["_GetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+50, POINTER(agcom.BSTR))
        self.__dict__["_SetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVADensityModelPlugin, vtable_offset_local+51, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVADensityModelPlugin.__dict__ and type(IVADensityModelPlugin.__dict__[attrname]) == property:
            return IVADensityModelPlugin.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVADensityModelPlugin.")
    
    @property
    def PluginIdentifier(self) -> str:
        """The plugin name."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPluginIdentifier"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @PluginIdentifier.setter
    def PluginIdentifier(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetPluginIdentifier"](arg_inVal.COM_val))

    @property
    def PluginConfig(self) -> "IVAPluginProperties":
        """The properties of the selected plugin."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPluginConfig"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def UseApproximateAltitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseApproximateAltitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseApproximateAltitude.setter
    def UseApproximateAltitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseApproximateAltitude"](arg_inVal.COM_val))

    @property
    def ComputesTemperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesTemperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ComputesPressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesPressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def SunPosition(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSunPosition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SunPosition.setter
    def SunPosition(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSunPosition"](arg_inVal.COM_val))

    @property
    def AtmosDataSource(self) -> "AgEVAAtmosDataSource":
        """The atmospheric model data source - data file or constant values."""
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataSource.setter
    def AtmosDataSource(self, inVal:"AgEVAAtmosDataSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataSource"](arg_inVal.COM_val))

    @property
    def F10(self) -> float:
        """Solar Flux (F10). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetF10"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @F10.setter
    def F10(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetF10"](arg_inVal.COM_val))

    @property
    def F10Avg(self) -> float:
        """Average solar Flux (F10). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetF10Avg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @F10Avg.setter
    def F10Avg(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetF10Avg"](arg_inVal.COM_val))

    @property
    def M10(self) -> float:
        """Solar Flux (M10). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetM10"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @M10.setter
    def M10(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetM10"](arg_inVal.COM_val))

    @property
    def M10Avg(self) -> float:
        """Average solar Flux (M10). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetM10Avg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @M10Avg.setter
    def M10Avg(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetM10Avg"](arg_inVal.COM_val))

    @property
    def S10(self) -> float:
        """Solar Flux (S10). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetS10"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @S10.setter
    def S10(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetS10"](arg_inVal.COM_val))

    @property
    def S10Avg(self) -> float:
        """Average solar Flux (S10). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetS10Avg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @S10Avg.setter
    def S10Avg(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetS10Avg"](arg_inVal.COM_val))

    @property
    def Y10(self) -> float:
        """Solar Flux (Y10). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetY10"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Y10.setter
    def Y10(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetY10"](arg_inVal.COM_val))

    @property
    def Y10Avg(self) -> float:
        """Average solar Flux (Y10). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetY10Avg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Y10Avg.setter
    def Y10Avg(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetY10Avg"](arg_inVal.COM_val))

    @property
    def Kp(self) -> float:
        """Geomagnetic Index (Kp). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetKp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Kp.setter
    def Kp(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetKp"](arg_inVal.COM_val))

    @property
    def DstDTc(self) -> float:
        """Temperature change calculated from disturbance storm time (DstDTc). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDstDTc"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DstDTc.setter
    def DstDTc(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDstDTc"](arg_inVal.COM_val))

    @property
    def AtmosDataGeoMagneticFluxSource(self) -> "AgEVAGeoMagneticFluxSource":
        """Whether to use Kp or Ap data from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataGeoMagneticFluxSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataGeoMagneticFluxSource.setter
    def AtmosDataGeoMagneticFluxSource(self, inVal:"AgEVAGeoMagneticFluxSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataGeoMagneticFluxSource"](arg_inVal.COM_val))

    @property
    def AtmosDataGeoMagneticFluxUpdateRate(self) -> "AgEVAGeoMagneticFluxUpdateRate":
        """The update rate for geomagnetic flux values from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataGeoMagneticFluxUpdateRate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataGeoMagneticFluxUpdateRate.setter
    def AtmosDataGeoMagneticFluxUpdateRate(self, inVal:"AgEVAGeoMagneticFluxUpdateRate") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataGeoMagneticFluxUpdateRate"](arg_inVal.COM_val))

    @property
    def AtmosDataFilename(self) -> str:
        """The atmospheric model data file path."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataFilename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataFilename.setter
    def AtmosDataFilename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataFilename"](arg_inVal.COM_val))

    @property
    def AtmosAugDataFile(self) -> str:
        """The atmospheric model augmented data file path."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosAugDataFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosAugDataFile.setter
    def AtmosAugDataFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosAugDataFile"](arg_inVal.COM_val))

    @property
    def AtmosAugDTCFile(self) -> str:
        """The atmospheric model augmented geomagnetic data file path."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosAugDTCFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosAugDTCFile.setter
    def AtmosAugDTCFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosAugDTCFile"](arg_inVal.COM_val))

    @property
    def DragModelType(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelType.setter
    def DragModelType(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelType"](arg_inVal.COM_val))

    @property
    def DragModelPluginName(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPluginName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelPluginName.setter
    def DragModelPluginName(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelPluginName"](arg_pVal.COM_val))

    @property
    def DragModelPlugin(self) -> "IVADragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPlugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def UsesAugmentedSpaceWeather(self) -> bool:
        """Flag indicates whether this model uses augmented flux data."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUsesAugmentedSpaceWeather"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def VariableAreaHistoryFile(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVariableAreaHistoryFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VariableAreaHistoryFile.setter
    def VariableAreaHistoryFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVariableAreaHistoryFile"](arg_inVal.COM_val))

    @property
    def NPlateDefinitionFile(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNPlateDefinitionFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @NPlateDefinitionFile.setter
    def NPlateDefinitionFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetNPlateDefinitionFile"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{FCE828BB-B2CE-4F2C-91EC-42ED00564FF4}", IVADensityModelPlugin)
agcls.AgTypeNameMap["IVADensityModelPlugin"] = IVADensityModelPlugin

class IVAJacchiaRoberts(object):
    """Properties for the Jacchia-Roberts atmospheric model - a model that is similar to Jacchia 1971 but uses analytical methods to improve performance."""
    _uuid = "{EEC62B17-9E4D-4527-AC53-B8A7180A4A65}"
    _num_methods = 29
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_SetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_GetComputesTemperature"] = _raise_uninitialized_error
        self.__dict__["_GetComputesPressure"] = _raise_uninitialized_error
        self.__dict__["_GetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_SetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataSource"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataSource"] = _raise_uninitialized_error
        self.__dict__["_GetF10p7"] = _raise_uninitialized_error
        self.__dict__["_SetF10p7"] = _raise_uninitialized_error
        self.__dict__["_GetF10p7Avg"] = _raise_uninitialized_error
        self.__dict__["_SetF10p7Avg"] = _raise_uninitialized_error
        self.__dict__["_GetKp"] = _raise_uninitialized_error
        self.__dict__["_SetKp"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataGeoMagneticFluxSource"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataGeoMagneticFluxSource"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataGeoMagneticFluxUpdateRate"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataGeoMagneticFluxUpdateRate"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataFilename"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataFilename"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPlugin"] = _raise_uninitialized_error
        self.__dict__["_GetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_SetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_GetNPlateDefinitionFile"] = _raise_uninitialized_error
        self.__dict__["_SetNPlateDefinitionFile"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAJacchiaRoberts._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAJacchiaRoberts from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAJacchiaRoberts = agcom.GUID(IVAJacchiaRoberts._uuid)
        vtable_offset_local = IVAJacchiaRoberts._vtable_offset - 1
        self.__dict__["_GetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaRoberts, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaRoberts, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetComputesTemperature"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaRoberts, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetComputesPressure"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaRoberts, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaRoberts, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaRoberts, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetAtmosDataSource"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaRoberts, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetAtmosDataSource"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaRoberts, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetF10p7"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaRoberts, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetF10p7"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaRoberts, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetF10p7Avg"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaRoberts, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetF10p7Avg"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaRoberts, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetKp"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaRoberts, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetKp"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaRoberts, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetAtmosDataGeoMagneticFluxSource"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaRoberts, vtable_offset_local+15, POINTER(agcom.LONG))
        self.__dict__["_SetAtmosDataGeoMagneticFluxSource"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaRoberts, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_GetAtmosDataGeoMagneticFluxUpdateRate"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaRoberts, vtable_offset_local+17, POINTER(agcom.LONG))
        self.__dict__["_SetAtmosDataGeoMagneticFluxUpdateRate"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaRoberts, vtable_offset_local+18, agcom.LONG)
        self.__dict__["_GetAtmosDataFilename"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaRoberts, vtable_offset_local+19, POINTER(agcom.BSTR))
        self.__dict__["_SetAtmosDataFilename"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaRoberts, vtable_offset_local+20, agcom.BSTR)
        self.__dict__["_GetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaRoberts, vtable_offset_local+21, POINTER(agcom.LONG))
        self.__dict__["_SetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaRoberts, vtable_offset_local+22, agcom.LONG)
        self.__dict__["_GetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaRoberts, vtable_offset_local+23, POINTER(agcom.BSTR))
        self.__dict__["_SetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaRoberts, vtable_offset_local+24, agcom.BSTR)
        self.__dict__["_GetDragModelPlugin"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaRoberts, vtable_offset_local+25, POINTER(agcom.PVOID))
        self.__dict__["_GetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaRoberts, vtable_offset_local+26, POINTER(agcom.BSTR))
        self.__dict__["_SetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaRoberts, vtable_offset_local+27, agcom.BSTR)
        self.__dict__["_GetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaRoberts, vtable_offset_local+28, POINTER(agcom.BSTR))
        self.__dict__["_SetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaRoberts, vtable_offset_local+29, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAJacchiaRoberts.__dict__ and type(IVAJacchiaRoberts.__dict__[attrname]) == property:
            return IVAJacchiaRoberts.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAJacchiaRoberts.")
    
    @property
    def UseApproximateAltitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseApproximateAltitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseApproximateAltitude.setter
    def UseApproximateAltitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseApproximateAltitude"](arg_inVal.COM_val))

    @property
    def ComputesTemperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesTemperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ComputesPressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesPressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def SunPosition(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSunPosition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SunPosition.setter
    def SunPosition(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSunPosition"](arg_inVal.COM_val))

    @property
    def AtmosDataSource(self) -> "AgEVAAtmosDataSource":
        """The atmospheric model data source - data file or constant values."""
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataSource.setter
    def AtmosDataSource(self, inVal:"AgEVAAtmosDataSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataSource"](arg_inVal.COM_val))

    @property
    def F10p7(self) -> float:
        """Solar Flux (F10.7); the daily Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetF10p7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @F10p7.setter
    def F10p7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetF10p7"](arg_inVal.COM_val))

    @property
    def F10p7Avg(self) -> float:
        """Average solar Flux (F10.7); the 81-day averaged Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetF10p7Avg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @F10p7Avg.setter
    def F10p7Avg(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetF10p7Avg"](arg_inVal.COM_val))

    @property
    def Kp(self) -> float:
        """Geomagnetic Index (Kp). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetKp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Kp.setter
    def Kp(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetKp"](arg_inVal.COM_val))

    @property
    def AtmosDataGeoMagneticFluxSource(self) -> "AgEVAGeoMagneticFluxSource":
        """Whether to use Kp or Ap data from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataGeoMagneticFluxSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataGeoMagneticFluxSource.setter
    def AtmosDataGeoMagneticFluxSource(self, inVal:"AgEVAGeoMagneticFluxSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataGeoMagneticFluxSource"](arg_inVal.COM_val))

    @property
    def AtmosDataGeoMagneticFluxUpdateRate(self) -> "AgEVAGeoMagneticFluxUpdateRate":
        """The update rate for geomagnetic flux values from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataGeoMagneticFluxUpdateRate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataGeoMagneticFluxUpdateRate.setter
    def AtmosDataGeoMagneticFluxUpdateRate(self, inVal:"AgEVAGeoMagneticFluxUpdateRate") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataGeoMagneticFluxUpdateRate"](arg_inVal.COM_val))

    @property
    def AtmosDataFilename(self) -> str:
        """The atmospheric model data file path."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataFilename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataFilename.setter
    def AtmosDataFilename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataFilename"](arg_inVal.COM_val))

    @property
    def DragModelType(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelType.setter
    def DragModelType(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelType"](arg_inVal.COM_val))

    @property
    def DragModelPluginName(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPluginName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelPluginName.setter
    def DragModelPluginName(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelPluginName"](arg_pVal.COM_val))

    @property
    def DragModelPlugin(self) -> "IVADragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPlugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VariableAreaHistoryFile(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVariableAreaHistoryFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VariableAreaHistoryFile.setter
    def VariableAreaHistoryFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVariableAreaHistoryFile"](arg_inVal.COM_val))

    @property
    def NPlateDefinitionFile(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNPlateDefinitionFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @NPlateDefinitionFile.setter
    def NPlateDefinitionFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetNPlateDefinitionFile"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{EEC62B17-9E4D-4527-AC53-B8A7180A4A65}", IVAJacchiaRoberts)
agcls.AgTypeNameMap["IVAJacchiaRoberts"] = IVAJacchiaRoberts

class IVAJacchiaBowman2008(object):
    """Properties for the Jacchia Bowman 2008 atmospheric density model."""
    _uuid = "{49B828F8-A541-4E9E-99DD-DF3708B3559F}"
    _num_methods = 37
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_SetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_GetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_SetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataSource"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataSource"] = _raise_uninitialized_error
        self.__dict__["_GetF10"] = _raise_uninitialized_error
        self.__dict__["_SetF10"] = _raise_uninitialized_error
        self.__dict__["_GetF10Avg"] = _raise_uninitialized_error
        self.__dict__["_SetF10Avg"] = _raise_uninitialized_error
        self.__dict__["_GetM10"] = _raise_uninitialized_error
        self.__dict__["_SetM10"] = _raise_uninitialized_error
        self.__dict__["_GetM10Avg"] = _raise_uninitialized_error
        self.__dict__["_SetM10Avg"] = _raise_uninitialized_error
        self.__dict__["_GetS10"] = _raise_uninitialized_error
        self.__dict__["_SetS10"] = _raise_uninitialized_error
        self.__dict__["_GetS10Avg"] = _raise_uninitialized_error
        self.__dict__["_SetS10Avg"] = _raise_uninitialized_error
        self.__dict__["_GetY10"] = _raise_uninitialized_error
        self.__dict__["_SetY10"] = _raise_uninitialized_error
        self.__dict__["_GetY10Avg"] = _raise_uninitialized_error
        self.__dict__["_SetY10Avg"] = _raise_uninitialized_error
        self.__dict__["_GetDstDTc"] = _raise_uninitialized_error
        self.__dict__["_SetDstDTc"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosAugDataFile"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosAugDataFile"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosAugDTCFile"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosAugDTCFile"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPlugin"] = _raise_uninitialized_error
        self.__dict__["_GetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_SetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_GetNPlateDefinitionFile"] = _raise_uninitialized_error
        self.__dict__["_SetNPlateDefinitionFile"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAJacchiaBowman2008._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAJacchiaBowman2008 from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAJacchiaBowman2008 = agcom.GUID(IVAJacchiaBowman2008._uuid)
        vtable_offset_local = IVAJacchiaBowman2008._vtable_offset - 1
        self.__dict__["_GetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaBowman2008, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaBowman2008, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaBowman2008, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaBowman2008, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetAtmosDataSource"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaBowman2008, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetAtmosDataSource"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaBowman2008, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetF10"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaBowman2008, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetF10"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaBowman2008, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetF10Avg"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaBowman2008, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetF10Avg"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaBowman2008, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetM10"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaBowman2008, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetM10"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaBowman2008, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetM10Avg"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaBowman2008, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetM10Avg"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaBowman2008, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetS10"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaBowman2008, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_SetS10"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaBowman2008, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_GetS10Avg"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaBowman2008, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_SetS10Avg"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaBowman2008, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_GetY10"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaBowman2008, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_SetY10"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaBowman2008, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_GetY10Avg"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaBowman2008, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_SetY10Avg"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaBowman2008, vtable_offset_local+22, agcom.DOUBLE)
        self.__dict__["_GetDstDTc"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaBowman2008, vtable_offset_local+23, POINTER(agcom.DOUBLE))
        self.__dict__["_SetDstDTc"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaBowman2008, vtable_offset_local+24, agcom.DOUBLE)
        self.__dict__["_GetAtmosAugDataFile"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaBowman2008, vtable_offset_local+25, POINTER(agcom.BSTR))
        self.__dict__["_SetAtmosAugDataFile"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaBowman2008, vtable_offset_local+26, agcom.BSTR)
        self.__dict__["_GetAtmosAugDTCFile"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaBowman2008, vtable_offset_local+27, POINTER(agcom.BSTR))
        self.__dict__["_SetAtmosAugDTCFile"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaBowman2008, vtable_offset_local+28, agcom.BSTR)
        self.__dict__["_GetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaBowman2008, vtable_offset_local+29, POINTER(agcom.LONG))
        self.__dict__["_SetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaBowman2008, vtable_offset_local+30, agcom.LONG)
        self.__dict__["_GetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaBowman2008, vtable_offset_local+31, POINTER(agcom.BSTR))
        self.__dict__["_SetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaBowman2008, vtable_offset_local+32, agcom.BSTR)
        self.__dict__["_GetDragModelPlugin"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaBowman2008, vtable_offset_local+33, POINTER(agcom.PVOID))
        self.__dict__["_GetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaBowman2008, vtable_offset_local+34, POINTER(agcom.BSTR))
        self.__dict__["_SetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaBowman2008, vtable_offset_local+35, agcom.BSTR)
        self.__dict__["_GetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaBowman2008, vtable_offset_local+36, POINTER(agcom.BSTR))
        self.__dict__["_SetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVAJacchiaBowman2008, vtable_offset_local+37, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAJacchiaBowman2008.__dict__ and type(IVAJacchiaBowman2008.__dict__[attrname]) == property:
            return IVAJacchiaBowman2008.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAJacchiaBowman2008.")
    
    @property
    def UseApproximateAltitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseApproximateAltitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseApproximateAltitude.setter
    def UseApproximateAltitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseApproximateAltitude"](arg_inVal.COM_val))

    @property
    def SunPosition(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSunPosition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SunPosition.setter
    def SunPosition(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSunPosition"](arg_inVal.COM_val))

    @property
    def AtmosDataSource(self) -> "AgEVAAtmosDataSource":
        """The atmospheric model data source - data file or constant values."""
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataSource.setter
    def AtmosDataSource(self, inVal:"AgEVAAtmosDataSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataSource"](arg_inVal.COM_val))

    @property
    def F10(self) -> float:
        """Solar Flux (F10). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetF10"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @F10.setter
    def F10(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetF10"](arg_inVal.COM_val))

    @property
    def F10Avg(self) -> float:
        """Average solar Flux (F10). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetF10Avg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @F10Avg.setter
    def F10Avg(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetF10Avg"](arg_inVal.COM_val))

    @property
    def M10(self) -> float:
        """Solar Flux (M10). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetM10"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @M10.setter
    def M10(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetM10"](arg_inVal.COM_val))

    @property
    def M10Avg(self) -> float:
        """Average solar Flux (M10). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetM10Avg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @M10Avg.setter
    def M10Avg(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetM10Avg"](arg_inVal.COM_val))

    @property
    def S10(self) -> float:
        """Solar Flux (S10). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetS10"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @S10.setter
    def S10(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetS10"](arg_inVal.COM_val))

    @property
    def S10Avg(self) -> float:
        """Average solar Flux (S10). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetS10Avg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @S10Avg.setter
    def S10Avg(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetS10Avg"](arg_inVal.COM_val))

    @property
    def Y10(self) -> float:
        """Solar Flux (Y10). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetY10"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Y10.setter
    def Y10(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetY10"](arg_inVal.COM_val))

    @property
    def Y10Avg(self) -> float:
        """Average solar Flux (Y10). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetY10Avg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Y10Avg.setter
    def Y10Avg(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetY10Avg"](arg_inVal.COM_val))

    @property
    def DstDTc(self) -> float:
        """Temperature change calculated from disturbance storm time (DstDTc). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDstDTc"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DstDTc.setter
    def DstDTc(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDstDTc"](arg_inVal.COM_val))

    @property
    def AtmosAugDataFile(self) -> str:
        """The atmospheric model space weather data file path."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosAugDataFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosAugDataFile.setter
    def AtmosAugDataFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosAugDataFile"](arg_inVal.COM_val))

    @property
    def AtmosAugDTCFile(self) -> str:
        """The atmospheric model DTC file path."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosAugDTCFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosAugDTCFile.setter
    def AtmosAugDTCFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosAugDTCFile"](arg_inVal.COM_val))

    @property
    def DragModelType(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelType.setter
    def DragModelType(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelType"](arg_inVal.COM_val))

    @property
    def DragModelPluginName(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPluginName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelPluginName.setter
    def DragModelPluginName(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelPluginName"](arg_pVal.COM_val))

    @property
    def DragModelPlugin(self) -> "IVADragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPlugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VariableAreaHistoryFile(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVariableAreaHistoryFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VariableAreaHistoryFile.setter
    def VariableAreaHistoryFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVariableAreaHistoryFile"](arg_inVal.COM_val))

    @property
    def NPlateDefinitionFile(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNPlateDefinitionFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @NPlateDefinitionFile.setter
    def NPlateDefinitionFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetNPlateDefinitionFile"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{49B828F8-A541-4E9E-99DD-DF3708B3559F}", IVAJacchiaBowman2008)
agcls.AgTypeNameMap["IVAJacchiaBowman2008"] = IVAJacchiaBowman2008

class IVAJacchia_1960(object):
    """Properties for the Jacchia 1960 atmospheric model - an outdated atmospheric model provided for making comparisons with other software."""
    _uuid = "{B32376D4-28EE-4D16-820F-A3A553103168}"
    _num_methods = 15
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_SetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_GetComputesTemperature"] = _raise_uninitialized_error
        self.__dict__["_GetComputesPressure"] = _raise_uninitialized_error
        self.__dict__["_GetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_SetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPlugin"] = _raise_uninitialized_error
        self.__dict__["_GetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_SetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_GetNPlateDefinitionFile"] = _raise_uninitialized_error
        self.__dict__["_SetNPlateDefinitionFile"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAJacchia_1960._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAJacchia_1960 from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAJacchia_1960 = agcom.GUID(IVAJacchia_1960._uuid)
        vtable_offset_local = IVAJacchia_1960._vtable_offset - 1
        self.__dict__["_GetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1960, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1960, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetComputesTemperature"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1960, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetComputesPressure"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1960, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1960, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1960, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1960, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1960, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1960, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_SetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1960, vtable_offset_local+10, agcom.BSTR)
        self.__dict__["_GetDragModelPlugin"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1960, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_GetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1960, vtable_offset_local+12, POINTER(agcom.BSTR))
        self.__dict__["_SetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1960, vtable_offset_local+13, agcom.BSTR)
        self.__dict__["_GetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1960, vtable_offset_local+14, POINTER(agcom.BSTR))
        self.__dict__["_SetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1960, vtable_offset_local+15, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAJacchia_1960.__dict__ and type(IVAJacchia_1960.__dict__[attrname]) == property:
            return IVAJacchia_1960.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAJacchia_1960.")
    
    @property
    def UseApproximateAltitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseApproximateAltitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseApproximateAltitude.setter
    def UseApproximateAltitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseApproximateAltitude"](arg_inVal.COM_val))

    @property
    def ComputesTemperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesTemperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ComputesPressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesPressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def SunPosition(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSunPosition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SunPosition.setter
    def SunPosition(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSunPosition"](arg_inVal.COM_val))

    @property
    def DragModelType(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelType.setter
    def DragModelType(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelType"](arg_inVal.COM_val))

    @property
    def DragModelPluginName(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPluginName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelPluginName.setter
    def DragModelPluginName(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelPluginName"](arg_pVal.COM_val))

    @property
    def DragModelPlugin(self) -> "IVADragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPlugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VariableAreaHistoryFile(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVariableAreaHistoryFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VariableAreaHistoryFile.setter
    def VariableAreaHistoryFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVariableAreaHistoryFile"](arg_inVal.COM_val))

    @property
    def NPlateDefinitionFile(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNPlateDefinitionFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @NPlateDefinitionFile.setter
    def NPlateDefinitionFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetNPlateDefinitionFile"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{B32376D4-28EE-4D16-820F-A3A553103168}", IVAJacchia_1960)
agcls.AgTypeNameMap["IVAJacchia_1960"] = IVAJacchia_1960

class IVAJacchia_1970(object):
    """Properties for the Jacchia 1970 atmospheric model - a model that computes atmospheric density based on the composition of the atmosphere, which depends on altitude as well as seasonal variation. Valid range is 100-2500 km."""
    _uuid = "{7308B6EE-F3DF-4B83-A9FB-F750AAE436F5}"
    _num_methods = 29
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_SetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_GetComputesTemperature"] = _raise_uninitialized_error
        self.__dict__["_GetComputesPressure"] = _raise_uninitialized_error
        self.__dict__["_GetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_SetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataSource"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataSource"] = _raise_uninitialized_error
        self.__dict__["_GetF10p7"] = _raise_uninitialized_error
        self.__dict__["_SetF10p7"] = _raise_uninitialized_error
        self.__dict__["_GetF10p7Avg"] = _raise_uninitialized_error
        self.__dict__["_SetF10p7Avg"] = _raise_uninitialized_error
        self.__dict__["_GetKp"] = _raise_uninitialized_error
        self.__dict__["_SetKp"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataGeoMagneticFluxSource"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataGeoMagneticFluxSource"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataGeoMagneticFluxUpdateRate"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataGeoMagneticFluxUpdateRate"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataFilename"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataFilename"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPlugin"] = _raise_uninitialized_error
        self.__dict__["_GetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_SetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_GetNPlateDefinitionFile"] = _raise_uninitialized_error
        self.__dict__["_SetNPlateDefinitionFile"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAJacchia_1970._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAJacchia_1970 from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAJacchia_1970 = agcom.GUID(IVAJacchia_1970._uuid)
        vtable_offset_local = IVAJacchia_1970._vtable_offset - 1
        self.__dict__["_GetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1970, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1970, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetComputesTemperature"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1970, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetComputesPressure"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1970, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1970, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1970, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetAtmosDataSource"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1970, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetAtmosDataSource"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1970, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetF10p7"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1970, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetF10p7"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1970, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetF10p7Avg"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1970, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetF10p7Avg"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1970, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetKp"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1970, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetKp"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1970, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetAtmosDataGeoMagneticFluxSource"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1970, vtable_offset_local+15, POINTER(agcom.LONG))
        self.__dict__["_SetAtmosDataGeoMagneticFluxSource"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1970, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_GetAtmosDataGeoMagneticFluxUpdateRate"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1970, vtable_offset_local+17, POINTER(agcom.LONG))
        self.__dict__["_SetAtmosDataGeoMagneticFluxUpdateRate"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1970, vtable_offset_local+18, agcom.LONG)
        self.__dict__["_GetAtmosDataFilename"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1970, vtable_offset_local+19, POINTER(agcom.BSTR))
        self.__dict__["_SetAtmosDataFilename"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1970, vtable_offset_local+20, agcom.BSTR)
        self.__dict__["_GetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1970, vtable_offset_local+21, POINTER(agcom.LONG))
        self.__dict__["_SetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1970, vtable_offset_local+22, agcom.LONG)
        self.__dict__["_GetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1970, vtable_offset_local+23, POINTER(agcom.BSTR))
        self.__dict__["_SetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1970, vtable_offset_local+24, agcom.BSTR)
        self.__dict__["_GetDragModelPlugin"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1970, vtable_offset_local+25, POINTER(agcom.PVOID))
        self.__dict__["_GetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1970, vtable_offset_local+26, POINTER(agcom.BSTR))
        self.__dict__["_SetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1970, vtable_offset_local+27, agcom.BSTR)
        self.__dict__["_GetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1970, vtable_offset_local+28, POINTER(agcom.BSTR))
        self.__dict__["_SetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1970, vtable_offset_local+29, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAJacchia_1970.__dict__ and type(IVAJacchia_1970.__dict__[attrname]) == property:
            return IVAJacchia_1970.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAJacchia_1970.")
    
    @property
    def UseApproximateAltitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseApproximateAltitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseApproximateAltitude.setter
    def UseApproximateAltitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseApproximateAltitude"](arg_inVal.COM_val))

    @property
    def ComputesTemperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesTemperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ComputesPressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesPressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def SunPosition(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSunPosition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SunPosition.setter
    def SunPosition(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSunPosition"](arg_inVal.COM_val))

    @property
    def AtmosDataSource(self) -> "AgEVAAtmosDataSource":
        """The atmospheric model data source - data file or constant values."""
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataSource.setter
    def AtmosDataSource(self, inVal:"AgEVAAtmosDataSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataSource"](arg_inVal.COM_val))

    @property
    def F10p7(self) -> float:
        """Solar Flux (F10.7); the daily Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetF10p7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @F10p7.setter
    def F10p7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetF10p7"](arg_inVal.COM_val))

    @property
    def F10p7Avg(self) -> float:
        """Average solar Flux (F10.7); the 81-day averaged Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetF10p7Avg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @F10p7Avg.setter
    def F10p7Avg(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetF10p7Avg"](arg_inVal.COM_val))

    @property
    def Kp(self) -> float:
        """Geomagnetic Index (Kp). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetKp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Kp.setter
    def Kp(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetKp"](arg_inVal.COM_val))

    @property
    def AtmosDataGeoMagneticFluxSource(self) -> "AgEVAGeoMagneticFluxSource":
        """Whether to use Kp or Ap data from the flux file"""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataGeoMagneticFluxSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataGeoMagneticFluxSource.setter
    def AtmosDataGeoMagneticFluxSource(self, inVal:"AgEVAGeoMagneticFluxSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataGeoMagneticFluxSource"](arg_inVal.COM_val))

    @property
    def AtmosDataGeoMagneticFluxUpdateRate(self) -> "AgEVAGeoMagneticFluxUpdateRate":
        """The update rate for geomagnetic flux values from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataGeoMagneticFluxUpdateRate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataGeoMagneticFluxUpdateRate.setter
    def AtmosDataGeoMagneticFluxUpdateRate(self, inVal:"AgEVAGeoMagneticFluxUpdateRate") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataGeoMagneticFluxUpdateRate"](arg_inVal.COM_val))

    @property
    def AtmosDataFilename(self) -> str:
        """The atmospheric model data file path."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataFilename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataFilename.setter
    def AtmosDataFilename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataFilename"](arg_inVal.COM_val))

    @property
    def DragModelType(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelType.setter
    def DragModelType(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelType"](arg_inVal.COM_val))

    @property
    def DragModelPluginName(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPluginName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelPluginName.setter
    def DragModelPluginName(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelPluginName"](arg_pVal.COM_val))

    @property
    def DragModelPlugin(self) -> "IVADragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPlugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VariableAreaHistoryFile(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVariableAreaHistoryFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VariableAreaHistoryFile.setter
    def VariableAreaHistoryFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVariableAreaHistoryFile"](arg_inVal.COM_val))

    @property
    def NPlateDefinitionFile(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNPlateDefinitionFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @NPlateDefinitionFile.setter
    def NPlateDefinitionFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetNPlateDefinitionFile"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7308B6EE-F3DF-4B83-A9FB-F750AAE436F5}", IVAJacchia_1970)
agcls.AgTypeNameMap["IVAJacchia_1970"] = IVAJacchia_1970

class IVAJacchia_1971(object):
    """Properties for the Jacchia 1971 atmospheric model - a model that is similar to Jacchia 1970, with improved treatment of certain solar effects."""
    _uuid = "{36089BD6-3BB0-4B0F-B8D8-81F6492E3309}"
    _num_methods = 29
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_SetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_GetComputesTemperature"] = _raise_uninitialized_error
        self.__dict__["_GetComputesPressure"] = _raise_uninitialized_error
        self.__dict__["_GetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_SetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataSource"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataSource"] = _raise_uninitialized_error
        self.__dict__["_GetF10p7"] = _raise_uninitialized_error
        self.__dict__["_SetF10p7"] = _raise_uninitialized_error
        self.__dict__["_GetF10p7Avg"] = _raise_uninitialized_error
        self.__dict__["_SetF10p7Avg"] = _raise_uninitialized_error
        self.__dict__["_GetKp"] = _raise_uninitialized_error
        self.__dict__["_SetKp"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataGeoMagneticFluxSource"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataGeoMagneticFluxSource"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataGeoMagneticFluxUpdateRate"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataGeoMagneticFluxUpdateRate"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataFilename"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataFilename"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPlugin"] = _raise_uninitialized_error
        self.__dict__["_GetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_SetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_GetNPlateDefinitionFile"] = _raise_uninitialized_error
        self.__dict__["_SetNPlateDefinitionFile"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAJacchia_1971._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAJacchia_1971 from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAJacchia_1971 = agcom.GUID(IVAJacchia_1971._uuid)
        vtable_offset_local = IVAJacchia_1971._vtable_offset - 1
        self.__dict__["_GetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1971, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1971, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetComputesTemperature"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1971, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetComputesPressure"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1971, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1971, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1971, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetAtmosDataSource"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1971, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetAtmosDataSource"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1971, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetF10p7"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1971, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetF10p7"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1971, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetF10p7Avg"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1971, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetF10p7Avg"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1971, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetKp"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1971, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetKp"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1971, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetAtmosDataGeoMagneticFluxSource"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1971, vtable_offset_local+15, POINTER(agcom.LONG))
        self.__dict__["_SetAtmosDataGeoMagneticFluxSource"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1971, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_GetAtmosDataGeoMagneticFluxUpdateRate"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1971, vtable_offset_local+17, POINTER(agcom.LONG))
        self.__dict__["_SetAtmosDataGeoMagneticFluxUpdateRate"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1971, vtable_offset_local+18, agcom.LONG)
        self.__dict__["_GetAtmosDataFilename"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1971, vtable_offset_local+19, POINTER(agcom.BSTR))
        self.__dict__["_SetAtmosDataFilename"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1971, vtable_offset_local+20, agcom.BSTR)
        self.__dict__["_GetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1971, vtable_offset_local+21, POINTER(agcom.LONG))
        self.__dict__["_SetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1971, vtable_offset_local+22, agcom.LONG)
        self.__dict__["_GetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1971, vtable_offset_local+23, POINTER(agcom.BSTR))
        self.__dict__["_SetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1971, vtable_offset_local+24, agcom.BSTR)
        self.__dict__["_GetDragModelPlugin"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1971, vtable_offset_local+25, POINTER(agcom.PVOID))
        self.__dict__["_GetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1971, vtable_offset_local+26, POINTER(agcom.BSTR))
        self.__dict__["_SetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1971, vtable_offset_local+27, agcom.BSTR)
        self.__dict__["_GetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1971, vtable_offset_local+28, POINTER(agcom.BSTR))
        self.__dict__["_SetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVAJacchia_1971, vtable_offset_local+29, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAJacchia_1971.__dict__ and type(IVAJacchia_1971.__dict__[attrname]) == property:
            return IVAJacchia_1971.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAJacchia_1971.")
    
    @property
    def UseApproximateAltitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseApproximateAltitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseApproximateAltitude.setter
    def UseApproximateAltitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseApproximateAltitude"](arg_inVal.COM_val))

    @property
    def ComputesTemperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesTemperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ComputesPressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesPressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def SunPosition(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSunPosition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SunPosition.setter
    def SunPosition(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSunPosition"](arg_inVal.COM_val))

    @property
    def AtmosDataSource(self) -> "AgEVAAtmosDataSource":
        """The atmospheric model data source - data file or constant values."""
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataSource.setter
    def AtmosDataSource(self, inVal:"AgEVAAtmosDataSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataSource"](arg_inVal.COM_val))

    @property
    def F10p7(self) -> float:
        """Solar Flux (F10.7); the daily Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetF10p7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @F10p7.setter
    def F10p7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetF10p7"](arg_inVal.COM_val))

    @property
    def F10p7Avg(self) -> float:
        """Average solar Flux (F10.7); the 81-day averaged Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetF10p7Avg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @F10p7Avg.setter
    def F10p7Avg(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetF10p7Avg"](arg_inVal.COM_val))

    @property
    def Kp(self) -> float:
        """Geomagnetic Index (Kp). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetKp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Kp.setter
    def Kp(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetKp"](arg_inVal.COM_val))

    @property
    def AtmosDataGeoMagneticFluxSource(self) -> "AgEVAGeoMagneticFluxSource":
        """Whether to use Kp or Ap data from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataGeoMagneticFluxSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataGeoMagneticFluxSource.setter
    def AtmosDataGeoMagneticFluxSource(self, inVal:"AgEVAGeoMagneticFluxSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataGeoMagneticFluxSource"](arg_inVal.COM_val))

    @property
    def AtmosDataGeoMagneticFluxUpdateRate(self) -> "AgEVAGeoMagneticFluxUpdateRate":
        """The update rate for geomagnetic flux values from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataGeoMagneticFluxUpdateRate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataGeoMagneticFluxUpdateRate.setter
    def AtmosDataGeoMagneticFluxUpdateRate(self, inVal:"AgEVAGeoMagneticFluxUpdateRate") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataGeoMagneticFluxUpdateRate"](arg_inVal.COM_val))

    @property
    def AtmosDataFilename(self) -> str:
        """The atmospheric model data file path."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataFilename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataFilename.setter
    def AtmosDataFilename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataFilename"](arg_inVal.COM_val))

    @property
    def DragModelType(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelType.setter
    def DragModelType(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelType"](arg_inVal.COM_val))

    @property
    def DragModelPluginName(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPluginName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelPluginName.setter
    def DragModelPluginName(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelPluginName"](arg_pVal.COM_val))

    @property
    def DragModelPlugin(self) -> "IVADragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPlugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VariableAreaHistoryFile(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVariableAreaHistoryFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VariableAreaHistoryFile.setter
    def VariableAreaHistoryFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVariableAreaHistoryFile"](arg_inVal.COM_val))

    @property
    def NPlateDefinitionFile(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNPlateDefinitionFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @NPlateDefinitionFile.setter
    def NPlateDefinitionFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetNPlateDefinitionFile"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{36089BD6-3BB0-4B0F-B8D8-81F6492E3309}", IVAJacchia_1971)
agcls.AgTypeNameMap["IVAJacchia_1971"] = IVAJacchia_1971

class IVAMSISE_1990(object):
    """Properties for the MSISE 1990 atmospheric model - an empirical density model developed by Hedin based on satellite data. Finds the total density by accounting for the contribution of N2, O, O2, He, Ar and H. 1990 version, valid range of 0-1000 km."""
    _uuid = "{C6AE62A3-103D-4E39-9F25-6AD5CCFF9530}"
    _num_methods = 29
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_SetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_GetComputesTemperature"] = _raise_uninitialized_error
        self.__dict__["_GetComputesPressure"] = _raise_uninitialized_error
        self.__dict__["_GetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_SetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataSource"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataSource"] = _raise_uninitialized_error
        self.__dict__["_GetF10p7"] = _raise_uninitialized_error
        self.__dict__["_SetF10p7"] = _raise_uninitialized_error
        self.__dict__["_GetF10p7Avg"] = _raise_uninitialized_error
        self.__dict__["_SetF10p7Avg"] = _raise_uninitialized_error
        self.__dict__["_GetKp"] = _raise_uninitialized_error
        self.__dict__["_SetKp"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataGeoMagneticFluxSource"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataGeoMagneticFluxSource"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataGeoMagneticFluxUpdateRate"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataGeoMagneticFluxUpdateRate"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataFilename"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataFilename"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPlugin"] = _raise_uninitialized_error
        self.__dict__["_GetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_SetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_GetNPlateDefinitionFile"] = _raise_uninitialized_error
        self.__dict__["_SetNPlateDefinitionFile"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAMSISE_1990._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAMSISE_1990 from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAMSISE_1990 = agcom.GUID(IVAMSISE_1990._uuid)
        vtable_offset_local = IVAMSISE_1990._vtable_offset - 1
        self.__dict__["_GetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAMSISE_1990, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAMSISE_1990, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetComputesTemperature"] = IAGFUNCTYPE(pUnk, IID_IVAMSISE_1990, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetComputesPressure"] = IAGFUNCTYPE(pUnk, IID_IVAMSISE_1990, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVAMSISE_1990, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVAMSISE_1990, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetAtmosDataSource"] = IAGFUNCTYPE(pUnk, IID_IVAMSISE_1990, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetAtmosDataSource"] = IAGFUNCTYPE(pUnk, IID_IVAMSISE_1990, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetF10p7"] = IAGFUNCTYPE(pUnk, IID_IVAMSISE_1990, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetF10p7"] = IAGFUNCTYPE(pUnk, IID_IVAMSISE_1990, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetF10p7Avg"] = IAGFUNCTYPE(pUnk, IID_IVAMSISE_1990, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetF10p7Avg"] = IAGFUNCTYPE(pUnk, IID_IVAMSISE_1990, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetKp"] = IAGFUNCTYPE(pUnk, IID_IVAMSISE_1990, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetKp"] = IAGFUNCTYPE(pUnk, IID_IVAMSISE_1990, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetAtmosDataGeoMagneticFluxSource"] = IAGFUNCTYPE(pUnk, IID_IVAMSISE_1990, vtable_offset_local+15, POINTER(agcom.LONG))
        self.__dict__["_SetAtmosDataGeoMagneticFluxSource"] = IAGFUNCTYPE(pUnk, IID_IVAMSISE_1990, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_GetAtmosDataGeoMagneticFluxUpdateRate"] = IAGFUNCTYPE(pUnk, IID_IVAMSISE_1990, vtable_offset_local+17, POINTER(agcom.LONG))
        self.__dict__["_SetAtmosDataGeoMagneticFluxUpdateRate"] = IAGFUNCTYPE(pUnk, IID_IVAMSISE_1990, vtable_offset_local+18, agcom.LONG)
        self.__dict__["_GetAtmosDataFilename"] = IAGFUNCTYPE(pUnk, IID_IVAMSISE_1990, vtable_offset_local+19, POINTER(agcom.BSTR))
        self.__dict__["_SetAtmosDataFilename"] = IAGFUNCTYPE(pUnk, IID_IVAMSISE_1990, vtable_offset_local+20, agcom.BSTR)
        self.__dict__["_GetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVAMSISE_1990, vtable_offset_local+21, POINTER(agcom.LONG))
        self.__dict__["_SetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVAMSISE_1990, vtable_offset_local+22, agcom.LONG)
        self.__dict__["_GetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVAMSISE_1990, vtable_offset_local+23, POINTER(agcom.BSTR))
        self.__dict__["_SetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVAMSISE_1990, vtable_offset_local+24, agcom.BSTR)
        self.__dict__["_GetDragModelPlugin"] = IAGFUNCTYPE(pUnk, IID_IVAMSISE_1990, vtable_offset_local+25, POINTER(agcom.PVOID))
        self.__dict__["_GetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVAMSISE_1990, vtable_offset_local+26, POINTER(agcom.BSTR))
        self.__dict__["_SetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVAMSISE_1990, vtable_offset_local+27, agcom.BSTR)
        self.__dict__["_GetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVAMSISE_1990, vtable_offset_local+28, POINTER(agcom.BSTR))
        self.__dict__["_SetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVAMSISE_1990, vtable_offset_local+29, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAMSISE_1990.__dict__ and type(IVAMSISE_1990.__dict__[attrname]) == property:
            return IVAMSISE_1990.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAMSISE_1990.")
    
    @property
    def UseApproximateAltitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseApproximateAltitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseApproximateAltitude.setter
    def UseApproximateAltitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseApproximateAltitude"](arg_inVal.COM_val))

    @property
    def ComputesTemperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesTemperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ComputesPressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesPressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def SunPosition(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSunPosition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SunPosition.setter
    def SunPosition(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSunPosition"](arg_inVal.COM_val))

    @property
    def AtmosDataSource(self) -> "AgEVAAtmosDataSource":
        """The atmospheric model data source - data file or constant values."""
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataSource.setter
    def AtmosDataSource(self, inVal:"AgEVAAtmosDataSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataSource"](arg_inVal.COM_val))

    @property
    def F10p7(self) -> float:
        """Solar Flux (F10.7); the daily Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetF10p7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @F10p7.setter
    def F10p7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetF10p7"](arg_inVal.COM_val))

    @property
    def F10p7Avg(self) -> float:
        """Average solar Flux (F10.7); the 81-day averaged Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetF10p7Avg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @F10p7Avg.setter
    def F10p7Avg(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetF10p7Avg"](arg_inVal.COM_val))

    @property
    def Kp(self) -> float:
        """Geomagnetic Index (Kp). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetKp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Kp.setter
    def Kp(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetKp"](arg_inVal.COM_val))

    @property
    def AtmosDataGeoMagneticFluxSource(self) -> "AgEVAGeoMagneticFluxSource":
        """Whether to use Kp or Ap data from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataGeoMagneticFluxSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataGeoMagneticFluxSource.setter
    def AtmosDataGeoMagneticFluxSource(self, inVal:"AgEVAGeoMagneticFluxSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataGeoMagneticFluxSource"](arg_inVal.COM_val))

    @property
    def AtmosDataGeoMagneticFluxUpdateRate(self) -> "AgEVAGeoMagneticFluxUpdateRate":
        """The update rate for geomagnetic flux values from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataGeoMagneticFluxUpdateRate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataGeoMagneticFluxUpdateRate.setter
    def AtmosDataGeoMagneticFluxUpdateRate(self, inVal:"AgEVAGeoMagneticFluxUpdateRate") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataGeoMagneticFluxUpdateRate"](arg_inVal.COM_val))

    @property
    def AtmosDataFilename(self) -> str:
        """The atmospheric model data file path."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataFilename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataFilename.setter
    def AtmosDataFilename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataFilename"](arg_inVal.COM_val))

    @property
    def DragModelType(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelType.setter
    def DragModelType(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelType"](arg_inVal.COM_val))

    @property
    def DragModelPluginName(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPluginName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelPluginName.setter
    def DragModelPluginName(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelPluginName"](arg_pVal.COM_val))

    @property
    def DragModelPlugin(self) -> "IVADragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPlugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VariableAreaHistoryFile(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVariableAreaHistoryFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VariableAreaHistoryFile.setter
    def VariableAreaHistoryFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVariableAreaHistoryFile"](arg_inVal.COM_val))

    @property
    def NPlateDefinitionFile(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNPlateDefinitionFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @NPlateDefinitionFile.setter
    def NPlateDefinitionFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetNPlateDefinitionFile"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{C6AE62A3-103D-4E39-9F25-6AD5CCFF9530}", IVAMSISE_1990)
agcls.AgTypeNameMap["IVAMSISE_1990"] = IVAMSISE_1990

class IVAMSIS_1986(object):
    """Properties for the MSIS 1986 atmospheric model - an empirical density model developed by Hedin based on satellite data. Finds the total density by accounting for the contribution of N2, O, O2, He, Ar and H. 1986 version, valid range of 90-1000 km."""
    _uuid = "{F7608E83-8539-4B2E-B0DB-F4F1010DDDED}"
    _num_methods = 29
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_SetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_GetComputesTemperature"] = _raise_uninitialized_error
        self.__dict__["_GetComputesPressure"] = _raise_uninitialized_error
        self.__dict__["_GetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_SetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataSource"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataSource"] = _raise_uninitialized_error
        self.__dict__["_GetF10p7"] = _raise_uninitialized_error
        self.__dict__["_SetF10p7"] = _raise_uninitialized_error
        self.__dict__["_GetF10p7Avg"] = _raise_uninitialized_error
        self.__dict__["_SetF10p7Avg"] = _raise_uninitialized_error
        self.__dict__["_GetKp"] = _raise_uninitialized_error
        self.__dict__["_SetKp"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataGeoMagneticFluxSource"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataGeoMagneticFluxSource"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataGeoMagneticFluxUpdateRate"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataGeoMagneticFluxUpdateRate"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataFilename"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataFilename"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPlugin"] = _raise_uninitialized_error
        self.__dict__["_GetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_SetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_GetNPlateDefinitionFile"] = _raise_uninitialized_error
        self.__dict__["_SetNPlateDefinitionFile"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAMSIS_1986._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAMSIS_1986 from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAMSIS_1986 = agcom.GUID(IVAMSIS_1986._uuid)
        vtable_offset_local = IVAMSIS_1986._vtable_offset - 1
        self.__dict__["_GetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAMSIS_1986, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAMSIS_1986, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetComputesTemperature"] = IAGFUNCTYPE(pUnk, IID_IVAMSIS_1986, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetComputesPressure"] = IAGFUNCTYPE(pUnk, IID_IVAMSIS_1986, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVAMSIS_1986, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVAMSIS_1986, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetAtmosDataSource"] = IAGFUNCTYPE(pUnk, IID_IVAMSIS_1986, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetAtmosDataSource"] = IAGFUNCTYPE(pUnk, IID_IVAMSIS_1986, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetF10p7"] = IAGFUNCTYPE(pUnk, IID_IVAMSIS_1986, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetF10p7"] = IAGFUNCTYPE(pUnk, IID_IVAMSIS_1986, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetF10p7Avg"] = IAGFUNCTYPE(pUnk, IID_IVAMSIS_1986, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetF10p7Avg"] = IAGFUNCTYPE(pUnk, IID_IVAMSIS_1986, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetKp"] = IAGFUNCTYPE(pUnk, IID_IVAMSIS_1986, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetKp"] = IAGFUNCTYPE(pUnk, IID_IVAMSIS_1986, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetAtmosDataGeoMagneticFluxSource"] = IAGFUNCTYPE(pUnk, IID_IVAMSIS_1986, vtable_offset_local+15, POINTER(agcom.LONG))
        self.__dict__["_SetAtmosDataGeoMagneticFluxSource"] = IAGFUNCTYPE(pUnk, IID_IVAMSIS_1986, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_GetAtmosDataGeoMagneticFluxUpdateRate"] = IAGFUNCTYPE(pUnk, IID_IVAMSIS_1986, vtable_offset_local+17, POINTER(agcom.LONG))
        self.__dict__["_SetAtmosDataGeoMagneticFluxUpdateRate"] = IAGFUNCTYPE(pUnk, IID_IVAMSIS_1986, vtable_offset_local+18, agcom.LONG)
        self.__dict__["_GetAtmosDataFilename"] = IAGFUNCTYPE(pUnk, IID_IVAMSIS_1986, vtable_offset_local+19, POINTER(agcom.BSTR))
        self.__dict__["_SetAtmosDataFilename"] = IAGFUNCTYPE(pUnk, IID_IVAMSIS_1986, vtable_offset_local+20, agcom.BSTR)
        self.__dict__["_GetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVAMSIS_1986, vtable_offset_local+21, POINTER(agcom.LONG))
        self.__dict__["_SetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVAMSIS_1986, vtable_offset_local+22, agcom.LONG)
        self.__dict__["_GetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVAMSIS_1986, vtable_offset_local+23, POINTER(agcom.BSTR))
        self.__dict__["_SetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVAMSIS_1986, vtable_offset_local+24, agcom.BSTR)
        self.__dict__["_GetDragModelPlugin"] = IAGFUNCTYPE(pUnk, IID_IVAMSIS_1986, vtable_offset_local+25, POINTER(agcom.PVOID))
        self.__dict__["_GetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVAMSIS_1986, vtable_offset_local+26, POINTER(agcom.BSTR))
        self.__dict__["_SetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVAMSIS_1986, vtable_offset_local+27, agcom.BSTR)
        self.__dict__["_GetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVAMSIS_1986, vtable_offset_local+28, POINTER(agcom.BSTR))
        self.__dict__["_SetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVAMSIS_1986, vtable_offset_local+29, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAMSIS_1986.__dict__ and type(IVAMSIS_1986.__dict__[attrname]) == property:
            return IVAMSIS_1986.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAMSIS_1986.")
    
    @property
    def UseApproximateAltitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseApproximateAltitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseApproximateAltitude.setter
    def UseApproximateAltitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseApproximateAltitude"](arg_inVal.COM_val))

    @property
    def ComputesTemperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesTemperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ComputesPressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesPressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def SunPosition(self) -> "AgEVASunPosition":
        """The sun position computation"""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSunPosition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SunPosition.setter
    def SunPosition(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSunPosition"](arg_inVal.COM_val))

    @property
    def AtmosDataSource(self) -> "AgEVAAtmosDataSource":
        """The atmospheric model data source - data file or constant values."""
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataSource.setter
    def AtmosDataSource(self, inVal:"AgEVAAtmosDataSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataSource"](arg_inVal.COM_val))

    @property
    def F10p7(self) -> float:
        """Solar Flux (F10.7); the daily Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetF10p7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @F10p7.setter
    def F10p7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetF10p7"](arg_inVal.COM_val))

    @property
    def F10p7Avg(self) -> float:
        """Average solar Flux (F10.7); the 81-day averaged Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetF10p7Avg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @F10p7Avg.setter
    def F10p7Avg(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetF10p7Avg"](arg_inVal.COM_val))

    @property
    def Kp(self) -> float:
        """Geomagnetic Index (Kp). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetKp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Kp.setter
    def Kp(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetKp"](arg_inVal.COM_val))

    @property
    def AtmosDataGeoMagneticFluxSource(self) -> "AgEVAGeoMagneticFluxSource":
        """Whether to use Kp or Ap data from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataGeoMagneticFluxSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataGeoMagneticFluxSource.setter
    def AtmosDataGeoMagneticFluxSource(self, inVal:"AgEVAGeoMagneticFluxSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataGeoMagneticFluxSource"](arg_inVal.COM_val))

    @property
    def AtmosDataGeoMagneticFluxUpdateRate(self) -> "AgEVAGeoMagneticFluxUpdateRate":
        """The update rate for geomagnetic flux values from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataGeoMagneticFluxUpdateRate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataGeoMagneticFluxUpdateRate.setter
    def AtmosDataGeoMagneticFluxUpdateRate(self, inVal:"AgEVAGeoMagneticFluxUpdateRate") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataGeoMagneticFluxUpdateRate"](arg_inVal.COM_val))

    @property
    def AtmosDataFilename(self) -> str:
        """The atmospheric model data file path."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataFilename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataFilename.setter
    def AtmosDataFilename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataFilename"](arg_inVal.COM_val))

    @property
    def DragModelType(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelType.setter
    def DragModelType(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelType"](arg_inVal.COM_val))

    @property
    def DragModelPluginName(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPluginName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelPluginName.setter
    def DragModelPluginName(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelPluginName"](arg_pVal.COM_val))

    @property
    def DragModelPlugin(self) -> "IVADragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPlugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VariableAreaHistoryFile(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVariableAreaHistoryFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VariableAreaHistoryFile.setter
    def VariableAreaHistoryFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVariableAreaHistoryFile"](arg_inVal.COM_val))

    @property
    def NPlateDefinitionFile(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNPlateDefinitionFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @NPlateDefinitionFile.setter
    def NPlateDefinitionFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetNPlateDefinitionFile"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{F7608E83-8539-4B2E-B0DB-F4F1010DDDED}", IVAMSIS_1986)
agcls.AgTypeNameMap["IVAMSIS_1986"] = IVAMSIS_1986

class IVANRLMSISE_2000(object):
    """Properties for the NRLMSISE 2000 atmospheric model."""
    _uuid = "{A2CAC8B0-74EF-4067-9B76-9B2D6938303D}"
    _num_methods = 29
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_SetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_GetComputesTemperature"] = _raise_uninitialized_error
        self.__dict__["_GetComputesPressure"] = _raise_uninitialized_error
        self.__dict__["_GetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_SetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataSource"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataSource"] = _raise_uninitialized_error
        self.__dict__["_GetF10p7"] = _raise_uninitialized_error
        self.__dict__["_SetF10p7"] = _raise_uninitialized_error
        self.__dict__["_GetF10p7Avg"] = _raise_uninitialized_error
        self.__dict__["_SetF10p7Avg"] = _raise_uninitialized_error
        self.__dict__["_GetKp"] = _raise_uninitialized_error
        self.__dict__["_SetKp"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataGeoMagneticFluxSource"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataGeoMagneticFluxSource"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataGeoMagneticFluxUpdateRate"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataGeoMagneticFluxUpdateRate"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataFilename"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataFilename"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPlugin"] = _raise_uninitialized_error
        self.__dict__["_GetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_SetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_GetNPlateDefinitionFile"] = _raise_uninitialized_error
        self.__dict__["_SetNPlateDefinitionFile"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVANRLMSISE_2000._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVANRLMSISE_2000 from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVANRLMSISE_2000 = agcom.GUID(IVANRLMSISE_2000._uuid)
        vtable_offset_local = IVANRLMSISE_2000._vtable_offset - 1
        self.__dict__["_GetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVANRLMSISE_2000, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVANRLMSISE_2000, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetComputesTemperature"] = IAGFUNCTYPE(pUnk, IID_IVANRLMSISE_2000, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetComputesPressure"] = IAGFUNCTYPE(pUnk, IID_IVANRLMSISE_2000, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVANRLMSISE_2000, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVANRLMSISE_2000, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetAtmosDataSource"] = IAGFUNCTYPE(pUnk, IID_IVANRLMSISE_2000, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetAtmosDataSource"] = IAGFUNCTYPE(pUnk, IID_IVANRLMSISE_2000, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetF10p7"] = IAGFUNCTYPE(pUnk, IID_IVANRLMSISE_2000, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetF10p7"] = IAGFUNCTYPE(pUnk, IID_IVANRLMSISE_2000, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetF10p7Avg"] = IAGFUNCTYPE(pUnk, IID_IVANRLMSISE_2000, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetF10p7Avg"] = IAGFUNCTYPE(pUnk, IID_IVANRLMSISE_2000, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetKp"] = IAGFUNCTYPE(pUnk, IID_IVANRLMSISE_2000, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetKp"] = IAGFUNCTYPE(pUnk, IID_IVANRLMSISE_2000, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetAtmosDataGeoMagneticFluxSource"] = IAGFUNCTYPE(pUnk, IID_IVANRLMSISE_2000, vtable_offset_local+15, POINTER(agcom.LONG))
        self.__dict__["_SetAtmosDataGeoMagneticFluxSource"] = IAGFUNCTYPE(pUnk, IID_IVANRLMSISE_2000, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_GetAtmosDataGeoMagneticFluxUpdateRate"] = IAGFUNCTYPE(pUnk, IID_IVANRLMSISE_2000, vtable_offset_local+17, POINTER(agcom.LONG))
        self.__dict__["_SetAtmosDataGeoMagneticFluxUpdateRate"] = IAGFUNCTYPE(pUnk, IID_IVANRLMSISE_2000, vtable_offset_local+18, agcom.LONG)
        self.__dict__["_GetAtmosDataFilename"] = IAGFUNCTYPE(pUnk, IID_IVANRLMSISE_2000, vtable_offset_local+19, POINTER(agcom.BSTR))
        self.__dict__["_SetAtmosDataFilename"] = IAGFUNCTYPE(pUnk, IID_IVANRLMSISE_2000, vtable_offset_local+20, agcom.BSTR)
        self.__dict__["_GetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVANRLMSISE_2000, vtable_offset_local+21, POINTER(agcom.LONG))
        self.__dict__["_SetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVANRLMSISE_2000, vtable_offset_local+22, agcom.LONG)
        self.__dict__["_GetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVANRLMSISE_2000, vtable_offset_local+23, POINTER(agcom.BSTR))
        self.__dict__["_SetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVANRLMSISE_2000, vtable_offset_local+24, agcom.BSTR)
        self.__dict__["_GetDragModelPlugin"] = IAGFUNCTYPE(pUnk, IID_IVANRLMSISE_2000, vtable_offset_local+25, POINTER(agcom.PVOID))
        self.__dict__["_GetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVANRLMSISE_2000, vtable_offset_local+26, POINTER(agcom.BSTR))
        self.__dict__["_SetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVANRLMSISE_2000, vtable_offset_local+27, agcom.BSTR)
        self.__dict__["_GetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVANRLMSISE_2000, vtable_offset_local+28, POINTER(agcom.BSTR))
        self.__dict__["_SetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVANRLMSISE_2000, vtable_offset_local+29, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVANRLMSISE_2000.__dict__ and type(IVANRLMSISE_2000.__dict__[attrname]) == property:
            return IVANRLMSISE_2000.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVANRLMSISE_2000.")
    
    @property
    def UseApproximateAltitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseApproximateAltitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseApproximateAltitude.setter
    def UseApproximateAltitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseApproximateAltitude"](arg_inVal.COM_val))

    @property
    def ComputesTemperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesTemperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ComputesPressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesPressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def SunPosition(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSunPosition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SunPosition.setter
    def SunPosition(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSunPosition"](arg_inVal.COM_val))

    @property
    def AtmosDataSource(self) -> "AgEVAAtmosDataSource":
        """The atmospheric model data source - data file or constant values."""
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataSource.setter
    def AtmosDataSource(self, inVal:"AgEVAAtmosDataSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataSource"](arg_inVal.COM_val))

    @property
    def F10p7(self) -> float:
        """Solar Flux (F10.7); the daily Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetF10p7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @F10p7.setter
    def F10p7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetF10p7"](arg_inVal.COM_val))

    @property
    def F10p7Avg(self) -> float:
        """Average solar Flux (F10.7); the 81-day averaged Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetF10p7Avg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @F10p7Avg.setter
    def F10p7Avg(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetF10p7Avg"](arg_inVal.COM_val))

    @property
    def Kp(self) -> float:
        """Geomagnetic Index (Kp). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetKp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Kp.setter
    def Kp(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetKp"](arg_inVal.COM_val))

    @property
    def AtmosDataGeoMagneticFluxSource(self) -> "AgEVAGeoMagneticFluxSource":
        """Whether to use Kp or Ap data from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataGeoMagneticFluxSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataGeoMagneticFluxSource.setter
    def AtmosDataGeoMagneticFluxSource(self, inVal:"AgEVAGeoMagneticFluxSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataGeoMagneticFluxSource"](arg_inVal.COM_val))

    @property
    def AtmosDataGeoMagneticFluxUpdateRate(self) -> "AgEVAGeoMagneticFluxUpdateRate":
        """The update rate for geomagnetic flux values from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataGeoMagneticFluxUpdateRate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataGeoMagneticFluxUpdateRate.setter
    def AtmosDataGeoMagneticFluxUpdateRate(self, inVal:"AgEVAGeoMagneticFluxUpdateRate") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataGeoMagneticFluxUpdateRate"](arg_inVal.COM_val))

    @property
    def AtmosDataFilename(self) -> str:
        """The atmospheric model data file path."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataFilename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataFilename.setter
    def AtmosDataFilename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataFilename"](arg_inVal.COM_val))

    @property
    def DragModelType(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelType.setter
    def DragModelType(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelType"](arg_inVal.COM_val))

    @property
    def DragModelPluginName(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPluginName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelPluginName.setter
    def DragModelPluginName(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelPluginName"](arg_pVal.COM_val))

    @property
    def DragModelPlugin(self) -> "IVADragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPlugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VariableAreaHistoryFile(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVariableAreaHistoryFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VariableAreaHistoryFile.setter
    def VariableAreaHistoryFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVariableAreaHistoryFile"](arg_inVal.COM_val))

    @property
    def NPlateDefinitionFile(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNPlateDefinitionFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @NPlateDefinitionFile.setter
    def NPlateDefinitionFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetNPlateDefinitionFile"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{A2CAC8B0-74EF-4067-9B76-9B2D6938303D}", IVANRLMSISE_2000)
agcls.AgTypeNameMap["IVANRLMSISE_2000"] = IVANRLMSISE_2000

class IVAUS_Standard_Atmosphere(object):
    """Properties for the US Standard Atmosphere atmospheric model."""
    _uuid = "{C1E85F74-4770-4D1F-B2D9-0AE42AC245EA}"
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_SetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_GetComputesTemperature"] = _raise_uninitialized_error
        self.__dict__["_GetComputesPressure"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPlugin"] = _raise_uninitialized_error
        self.__dict__["_GetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_SetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_GetNPlateDefinitionFile"] = _raise_uninitialized_error
        self.__dict__["_SetNPlateDefinitionFile"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAUS_Standard_Atmosphere._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAUS_Standard_Atmosphere from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAUS_Standard_Atmosphere = agcom.GUID(IVAUS_Standard_Atmosphere._uuid)
        vtable_offset_local = IVAUS_Standard_Atmosphere._vtable_offset - 1
        self.__dict__["_GetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAUS_Standard_Atmosphere, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAUS_Standard_Atmosphere, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetComputesTemperature"] = IAGFUNCTYPE(pUnk, IID_IVAUS_Standard_Atmosphere, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetComputesPressure"] = IAGFUNCTYPE(pUnk, IID_IVAUS_Standard_Atmosphere, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVAUS_Standard_Atmosphere, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVAUS_Standard_Atmosphere, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVAUS_Standard_Atmosphere, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_SetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVAUS_Standard_Atmosphere, vtable_offset_local+8, agcom.BSTR)
        self.__dict__["_GetDragModelPlugin"] = IAGFUNCTYPE(pUnk, IID_IVAUS_Standard_Atmosphere, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_GetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVAUS_Standard_Atmosphere, vtable_offset_local+10, POINTER(agcom.BSTR))
        self.__dict__["_SetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVAUS_Standard_Atmosphere, vtable_offset_local+11, agcom.BSTR)
        self.__dict__["_GetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVAUS_Standard_Atmosphere, vtable_offset_local+12, POINTER(agcom.BSTR))
        self.__dict__["_SetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVAUS_Standard_Atmosphere, vtable_offset_local+13, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAUS_Standard_Atmosphere.__dict__ and type(IVAUS_Standard_Atmosphere.__dict__[attrname]) == property:
            return IVAUS_Standard_Atmosphere.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAUS_Standard_Atmosphere.")
    
    @property
    def UseApproximateAltitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseApproximateAltitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseApproximateAltitude.setter
    def UseApproximateAltitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseApproximateAltitude"](arg_inVal.COM_val))

    @property
    def ComputesTemperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesTemperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ComputesPressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesPressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def DragModelType(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelType.setter
    def DragModelType(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelType"](arg_inVal.COM_val))

    @property
    def DragModelPluginName(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPluginName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelPluginName.setter
    def DragModelPluginName(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelPluginName"](arg_pVal.COM_val))

    @property
    def DragModelPlugin(self) -> "IVADragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPlugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VariableAreaHistoryFile(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVariableAreaHistoryFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VariableAreaHistoryFile.setter
    def VariableAreaHistoryFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVariableAreaHistoryFile"](arg_inVal.COM_val))

    @property
    def NPlateDefinitionFile(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNPlateDefinitionFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @NPlateDefinitionFile.setter
    def NPlateDefinitionFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetNPlateDefinitionFile"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{C1E85F74-4770-4D1F-B2D9-0AE42AC245EA}", IVAUS_Standard_Atmosphere)
agcls.AgTypeNameMap["IVAUS_Standard_Atmosphere"] = IVAUS_Standard_Atmosphere

class IVAMarsGRAM37(object):
    """Properties for the Mars-GRAM 3.7 atmospheric model."""
    _uuid = "{2855777F-3062-4699-AB5D-2FE73D161472}"
    _num_methods = 27
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_SetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_GetComputesTemperature"] = _raise_uninitialized_error
        self.__dict__["_GetComputesPressure"] = _raise_uninitialized_error
        self.__dict__["_GetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_SetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_GetDataDirectory"] = _raise_uninitialized_error
        self.__dict__["_SetDataDirectory"] = _raise_uninitialized_error
        self.__dict__["_GetNamelistFile"] = _raise_uninitialized_error
        self.__dict__["_SetNamelistFile"] = _raise_uninitialized_error
        self.__dict__["_GetDensityType"] = _raise_uninitialized_error
        self.__dict__["_SetDensityType"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataSource"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataSource"] = _raise_uninitialized_error
        self.__dict__["_GetF10p7"] = _raise_uninitialized_error
        self.__dict__["_SetF10p7"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataFilename"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataFilename"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPlugin"] = _raise_uninitialized_error
        self.__dict__["_GetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_SetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_GetNPlateDefinitionFile"] = _raise_uninitialized_error
        self.__dict__["_SetNPlateDefinitionFile"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAMarsGRAM37._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAMarsGRAM37 from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAMarsGRAM37 = agcom.GUID(IVAMarsGRAM37._uuid)
        vtable_offset_local = IVAMarsGRAM37._vtable_offset - 1
        self.__dict__["_GetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM37, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM37, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetComputesTemperature"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM37, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetComputesPressure"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM37, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM37, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM37, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetDataDirectory"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM37, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_SetDataDirectory"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM37, vtable_offset_local+8, agcom.BSTR)
        self.__dict__["_GetNamelistFile"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM37, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_SetNamelistFile"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM37, vtable_offset_local+10, agcom.BSTR)
        self.__dict__["_GetDensityType"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM37, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_SetDensityType"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM37, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_GetAtmosDataSource"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM37, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_SetAtmosDataSource"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM37, vtable_offset_local+14, agcom.LONG)
        self.__dict__["_GetF10p7"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM37, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_SetF10p7"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM37, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_GetAtmosDataFilename"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM37, vtable_offset_local+17, POINTER(agcom.BSTR))
        self.__dict__["_SetAtmosDataFilename"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM37, vtable_offset_local+18, agcom.BSTR)
        self.__dict__["_GetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM37, vtable_offset_local+19, POINTER(agcom.LONG))
        self.__dict__["_SetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM37, vtable_offset_local+20, agcom.LONG)
        self.__dict__["_GetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM37, vtable_offset_local+21, POINTER(agcom.BSTR))
        self.__dict__["_SetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM37, vtable_offset_local+22, agcom.BSTR)
        self.__dict__["_GetDragModelPlugin"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM37, vtable_offset_local+23, POINTER(agcom.PVOID))
        self.__dict__["_GetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM37, vtable_offset_local+24, POINTER(agcom.BSTR))
        self.__dict__["_SetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM37, vtable_offset_local+25, agcom.BSTR)
        self.__dict__["_GetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM37, vtable_offset_local+26, POINTER(agcom.BSTR))
        self.__dict__["_SetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM37, vtable_offset_local+27, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAMarsGRAM37.__dict__ and type(IVAMarsGRAM37.__dict__[attrname]) == property:
            return IVAMarsGRAM37.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAMarsGRAM37.")
    
    @property
    def UseApproximateAltitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseApproximateAltitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseApproximateAltitude.setter
    def UseApproximateAltitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseApproximateAltitude"](arg_inVal.COM_val))

    @property
    def ComputesTemperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesTemperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ComputesPressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesPressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def SunPosition(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSunPosition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SunPosition.setter
    def SunPosition(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSunPosition"](arg_inVal.COM_val))

    @property
    def DataDirectory(self) -> str:
        """Path to the data directory."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDataDirectory"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DataDirectory.setter
    def DataDirectory(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDataDirectory"](arg_inVal.COM_val))

    @property
    def NamelistFile(self) -> str:
        """Full path of namelist file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNamelistFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @NamelistFile.setter
    def NamelistFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetNamelistFile"](arg_inVal.COM_val))

    @property
    def DensityType(self) -> "AgEVAMarsGRAMDensityType":
        """Low, mean or high density type."""
        with agmarshall.AgEnum_arg(AgEVAMarsGRAMDensityType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDensityType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DensityType.setter
    def DensityType(self, inVal:"AgEVAMarsGRAMDensityType") -> None:
        with agmarshall.AgEnum_arg(AgEVAMarsGRAMDensityType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDensityType"](arg_inVal.COM_val))

    @property
    def AtmosDataSource(self) -> "AgEVAAtmosDataSource":
        """The atmospheric model data source - data file or constant values."""
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataSource.setter
    def AtmosDataSource(self, inVal:"AgEVAAtmosDataSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataSource"](arg_inVal.COM_val))

    @property
    def F10p7(self) -> float:
        """Solar Flux (F10.7); the daily Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetF10p7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @F10p7.setter
    def F10p7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetF10p7"](arg_inVal.COM_val))

    @property
    def AtmosDataFilename(self) -> str:
        """The atmospheric model data file path."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataFilename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataFilename.setter
    def AtmosDataFilename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataFilename"](arg_inVal.COM_val))

    @property
    def DragModelType(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelType.setter
    def DragModelType(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelType"](arg_inVal.COM_val))

    @property
    def DragModelPluginName(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPluginName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelPluginName.setter
    def DragModelPluginName(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelPluginName"](arg_pVal.COM_val))

    @property
    def DragModelPlugin(self) -> "IVADragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPlugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VariableAreaHistoryFile(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVariableAreaHistoryFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VariableAreaHistoryFile.setter
    def VariableAreaHistoryFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVariableAreaHistoryFile"](arg_inVal.COM_val))

    @property
    def NPlateDefinitionFile(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNPlateDefinitionFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @NPlateDefinitionFile.setter
    def NPlateDefinitionFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetNPlateDefinitionFile"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2855777F-3062-4699-AB5D-2FE73D161472}", IVAMarsGRAM37)
agcls.AgTypeNameMap["IVAMarsGRAM37"] = IVAMarsGRAM37

class IVAMarsGRAM2005(object):
    """Properties for the Mars-GRAM 2005 atmospheric model."""
    _uuid = "{E8649FED-5172-444A-9FC2-3B69586A8B91}"
    _num_methods = 27
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_SetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_GetComputesTemperature"] = _raise_uninitialized_error
        self.__dict__["_GetComputesPressure"] = _raise_uninitialized_error
        self.__dict__["_GetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_SetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_GetDataDirectory"] = _raise_uninitialized_error
        self.__dict__["_SetDataDirectory"] = _raise_uninitialized_error
        self.__dict__["_GetNamelistFile"] = _raise_uninitialized_error
        self.__dict__["_SetNamelistFile"] = _raise_uninitialized_error
        self.__dict__["_GetDensityType"] = _raise_uninitialized_error
        self.__dict__["_SetDensityType"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataSource"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataSource"] = _raise_uninitialized_error
        self.__dict__["_GetF10p7"] = _raise_uninitialized_error
        self.__dict__["_SetF10p7"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataFilename"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataFilename"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPlugin"] = _raise_uninitialized_error
        self.__dict__["_GetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_SetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_GetNPlateDefinitionFile"] = _raise_uninitialized_error
        self.__dict__["_SetNPlateDefinitionFile"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAMarsGRAM2005._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAMarsGRAM2005 from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAMarsGRAM2005 = agcom.GUID(IVAMarsGRAM2005._uuid)
        vtable_offset_local = IVAMarsGRAM2005._vtable_offset - 1
        self.__dict__["_GetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2005, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2005, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetComputesTemperature"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2005, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetComputesPressure"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2005, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2005, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2005, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetDataDirectory"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2005, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_SetDataDirectory"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2005, vtable_offset_local+8, agcom.BSTR)
        self.__dict__["_GetNamelistFile"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2005, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_SetNamelistFile"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2005, vtable_offset_local+10, agcom.BSTR)
        self.__dict__["_GetDensityType"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2005, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_SetDensityType"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2005, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_GetAtmosDataSource"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2005, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_SetAtmosDataSource"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2005, vtable_offset_local+14, agcom.LONG)
        self.__dict__["_GetF10p7"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2005, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_SetF10p7"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2005, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_GetAtmosDataFilename"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2005, vtable_offset_local+17, POINTER(agcom.BSTR))
        self.__dict__["_SetAtmosDataFilename"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2005, vtable_offset_local+18, agcom.BSTR)
        self.__dict__["_GetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2005, vtable_offset_local+19, POINTER(agcom.LONG))
        self.__dict__["_SetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2005, vtable_offset_local+20, agcom.LONG)
        self.__dict__["_GetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2005, vtable_offset_local+21, POINTER(agcom.BSTR))
        self.__dict__["_SetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2005, vtable_offset_local+22, agcom.BSTR)
        self.__dict__["_GetDragModelPlugin"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2005, vtable_offset_local+23, POINTER(agcom.PVOID))
        self.__dict__["_GetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2005, vtable_offset_local+24, POINTER(agcom.BSTR))
        self.__dict__["_SetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2005, vtable_offset_local+25, agcom.BSTR)
        self.__dict__["_GetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2005, vtable_offset_local+26, POINTER(agcom.BSTR))
        self.__dict__["_SetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2005, vtable_offset_local+27, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAMarsGRAM2005.__dict__ and type(IVAMarsGRAM2005.__dict__[attrname]) == property:
            return IVAMarsGRAM2005.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAMarsGRAM2005.")
    
    @property
    def UseApproximateAltitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseApproximateAltitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseApproximateAltitude.setter
    def UseApproximateAltitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseApproximateAltitude"](arg_inVal.COM_val))

    @property
    def ComputesTemperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesTemperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ComputesPressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesPressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def SunPosition(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSunPosition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SunPosition.setter
    def SunPosition(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSunPosition"](arg_inVal.COM_val))

    @property
    def DataDirectory(self) -> str:
        """Path to the data directory."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDataDirectory"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DataDirectory.setter
    def DataDirectory(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDataDirectory"](arg_inVal.COM_val))

    @property
    def NamelistFile(self) -> str:
        """Full path of namelist file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNamelistFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @NamelistFile.setter
    def NamelistFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetNamelistFile"](arg_inVal.COM_val))

    @property
    def DensityType(self) -> "AgEVAMarsGRAMDensityType":
        """Low, mean, high or randomly perturbed density type."""
        with agmarshall.AgEnum_arg(AgEVAMarsGRAMDensityType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDensityType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DensityType.setter
    def DensityType(self, inVal:"AgEVAMarsGRAMDensityType") -> None:
        with agmarshall.AgEnum_arg(AgEVAMarsGRAMDensityType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDensityType"](arg_inVal.COM_val))

    @property
    def AtmosDataSource(self) -> "AgEVAAtmosDataSource":
        """The atmospheric model data source - data file or constant values."""
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataSource.setter
    def AtmosDataSource(self, inVal:"AgEVAAtmosDataSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataSource"](arg_inVal.COM_val))

    @property
    def F10p7(self) -> float:
        """Solar Flux (F10.7); the daily Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetF10p7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @F10p7.setter
    def F10p7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetF10p7"](arg_inVal.COM_val))

    @property
    def AtmosDataFilename(self) -> str:
        """The atmospheric model data file path."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataFilename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataFilename.setter
    def AtmosDataFilename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataFilename"](arg_inVal.COM_val))

    @property
    def DragModelType(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelType.setter
    def DragModelType(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelType"](arg_inVal.COM_val))

    @property
    def DragModelPluginName(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPluginName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelPluginName.setter
    def DragModelPluginName(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelPluginName"](arg_pVal.COM_val))

    @property
    def DragModelPlugin(self) -> "IVADragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPlugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VariableAreaHistoryFile(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVariableAreaHistoryFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VariableAreaHistoryFile.setter
    def VariableAreaHistoryFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVariableAreaHistoryFile"](arg_inVal.COM_val))

    @property
    def NPlateDefinitionFile(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNPlateDefinitionFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @NPlateDefinitionFile.setter
    def NPlateDefinitionFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetNPlateDefinitionFile"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E8649FED-5172-444A-9FC2-3B69586A8B91}", IVAMarsGRAM2005)
agcls.AgTypeNameMap["IVAMarsGRAM2005"] = IVAMarsGRAM2005

class IVAVenusGRAM2005(object):
    """Properties for the Venus-GRAM 2005 atmospheric model."""
    _uuid = "{270C541C-FF9B-4E56-81B0-36CF43D3BE54}"
    _num_methods = 19
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_SetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_GetComputesTemperature"] = _raise_uninitialized_error
        self.__dict__["_GetComputesPressure"] = _raise_uninitialized_error
        self.__dict__["_GetDataDirectory"] = _raise_uninitialized_error
        self.__dict__["_SetDataDirectory"] = _raise_uninitialized_error
        self.__dict__["_GetNamelistFile"] = _raise_uninitialized_error
        self.__dict__["_SetNamelistFile"] = _raise_uninitialized_error
        self.__dict__["_GetDensityType"] = _raise_uninitialized_error
        self.__dict__["_SetDensityType"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPlugin"] = _raise_uninitialized_error
        self.__dict__["_GetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_SetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_GetNPlateDefinitionFile"] = _raise_uninitialized_error
        self.__dict__["_SetNPlateDefinitionFile"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAVenusGRAM2005._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAVenusGRAM2005 from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAVenusGRAM2005 = agcom.GUID(IVAVenusGRAM2005._uuid)
        vtable_offset_local = IVAVenusGRAM2005._vtable_offset - 1
        self.__dict__["_GetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAVenusGRAM2005, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAVenusGRAM2005, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetComputesTemperature"] = IAGFUNCTYPE(pUnk, IID_IVAVenusGRAM2005, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetComputesPressure"] = IAGFUNCTYPE(pUnk, IID_IVAVenusGRAM2005, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetDataDirectory"] = IAGFUNCTYPE(pUnk, IID_IVAVenusGRAM2005, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_SetDataDirectory"] = IAGFUNCTYPE(pUnk, IID_IVAVenusGRAM2005, vtable_offset_local+6, agcom.BSTR)
        self.__dict__["_GetNamelistFile"] = IAGFUNCTYPE(pUnk, IID_IVAVenusGRAM2005, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_SetNamelistFile"] = IAGFUNCTYPE(pUnk, IID_IVAVenusGRAM2005, vtable_offset_local+8, agcom.BSTR)
        self.__dict__["_GetDensityType"] = IAGFUNCTYPE(pUnk, IID_IVAVenusGRAM2005, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_SetDensityType"] = IAGFUNCTYPE(pUnk, IID_IVAVenusGRAM2005, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_GetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVAVenusGRAM2005, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_SetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVAVenusGRAM2005, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_GetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVAVenusGRAM2005, vtable_offset_local+13, POINTER(agcom.BSTR))
        self.__dict__["_SetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVAVenusGRAM2005, vtable_offset_local+14, agcom.BSTR)
        self.__dict__["_GetDragModelPlugin"] = IAGFUNCTYPE(pUnk, IID_IVAVenusGRAM2005, vtable_offset_local+15, POINTER(agcom.PVOID))
        self.__dict__["_GetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVAVenusGRAM2005, vtable_offset_local+16, POINTER(agcom.BSTR))
        self.__dict__["_SetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVAVenusGRAM2005, vtable_offset_local+17, agcom.BSTR)
        self.__dict__["_GetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVAVenusGRAM2005, vtable_offset_local+18, POINTER(agcom.BSTR))
        self.__dict__["_SetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVAVenusGRAM2005, vtable_offset_local+19, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAVenusGRAM2005.__dict__ and type(IVAVenusGRAM2005.__dict__[attrname]) == property:
            return IVAVenusGRAM2005.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAVenusGRAM2005.")
    
    @property
    def UseApproximateAltitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseApproximateAltitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseApproximateAltitude.setter
    def UseApproximateAltitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseApproximateAltitude"](arg_inVal.COM_val))

    @property
    def ComputesTemperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesTemperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ComputesPressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesPressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def DataDirectory(self) -> str:
        """Path to the data directory."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDataDirectory"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DataDirectory.setter
    def DataDirectory(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDataDirectory"](arg_inVal.COM_val))

    @property
    def NamelistFile(self) -> str:
        """Full path of namelist file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNamelistFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @NamelistFile.setter
    def NamelistFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetNamelistFile"](arg_inVal.COM_val))

    @property
    def DensityType(self) -> "AgEVAVenusGRAMDensityType":
        """Low, mean, high or randomly perturbed density type."""
        with agmarshall.AgEnum_arg(AgEVAVenusGRAMDensityType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDensityType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DensityType.setter
    def DensityType(self, inVal:"AgEVAVenusGRAMDensityType") -> None:
        with agmarshall.AgEnum_arg(AgEVAVenusGRAMDensityType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDensityType"](arg_inVal.COM_val))

    @property
    def DragModelType(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelType.setter
    def DragModelType(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelType"](arg_inVal.COM_val))

    @property
    def DragModelPluginName(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPluginName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelPluginName.setter
    def DragModelPluginName(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelPluginName"](arg_pVal.COM_val))

    @property
    def DragModelPlugin(self) -> "IVADragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPlugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VariableAreaHistoryFile(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVariableAreaHistoryFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VariableAreaHistoryFile.setter
    def VariableAreaHistoryFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVariableAreaHistoryFile"](arg_inVal.COM_val))

    @property
    def NPlateDefinitionFile(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNPlateDefinitionFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @NPlateDefinitionFile.setter
    def NPlateDefinitionFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetNPlateDefinitionFile"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{270C541C-FF9B-4E56-81B0-36CF43D3BE54}", IVAVenusGRAM2005)
agcls.AgTypeNameMap["IVAVenusGRAM2005"] = IVAVenusGRAM2005

class IVAMarsGRAM2010(object):
    """Properties for the Mars-GRAM 2010 atmospheric model."""
    _uuid = "{C9E4AA59-8B84-4AC1-938E-E5E92A12EC4F}"
    _num_methods = 27
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_SetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_GetComputesTemperature"] = _raise_uninitialized_error
        self.__dict__["_GetComputesPressure"] = _raise_uninitialized_error
        self.__dict__["_GetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_SetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_GetDataDirectory"] = _raise_uninitialized_error
        self.__dict__["_SetDataDirectory"] = _raise_uninitialized_error
        self.__dict__["_GetNamelistFile"] = _raise_uninitialized_error
        self.__dict__["_SetNamelistFile"] = _raise_uninitialized_error
        self.__dict__["_GetDensityType"] = _raise_uninitialized_error
        self.__dict__["_SetDensityType"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataSource"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataSource"] = _raise_uninitialized_error
        self.__dict__["_GetF10p7"] = _raise_uninitialized_error
        self.__dict__["_SetF10p7"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataFilename"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataFilename"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPlugin"] = _raise_uninitialized_error
        self.__dict__["_GetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_SetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_GetNPlateDefinitionFile"] = _raise_uninitialized_error
        self.__dict__["_SetNPlateDefinitionFile"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAMarsGRAM2010._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAMarsGRAM2010 from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAMarsGRAM2010 = agcom.GUID(IVAMarsGRAM2010._uuid)
        vtable_offset_local = IVAMarsGRAM2010._vtable_offset - 1
        self.__dict__["_GetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2010, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2010, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetComputesTemperature"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2010, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetComputesPressure"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2010, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2010, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2010, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetDataDirectory"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2010, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_SetDataDirectory"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2010, vtable_offset_local+8, agcom.BSTR)
        self.__dict__["_GetNamelistFile"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2010, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_SetNamelistFile"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2010, vtable_offset_local+10, agcom.BSTR)
        self.__dict__["_GetDensityType"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2010, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_SetDensityType"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2010, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_GetAtmosDataSource"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2010, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_SetAtmosDataSource"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2010, vtable_offset_local+14, agcom.LONG)
        self.__dict__["_GetF10p7"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2010, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_SetF10p7"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2010, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_GetAtmosDataFilename"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2010, vtable_offset_local+17, POINTER(agcom.BSTR))
        self.__dict__["_SetAtmosDataFilename"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2010, vtable_offset_local+18, agcom.BSTR)
        self.__dict__["_GetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2010, vtable_offset_local+19, POINTER(agcom.LONG))
        self.__dict__["_SetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2010, vtable_offset_local+20, agcom.LONG)
        self.__dict__["_GetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2010, vtable_offset_local+21, POINTER(agcom.BSTR))
        self.__dict__["_SetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2010, vtable_offset_local+22, agcom.BSTR)
        self.__dict__["_GetDragModelPlugin"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2010, vtable_offset_local+23, POINTER(agcom.PVOID))
        self.__dict__["_GetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2010, vtable_offset_local+24, POINTER(agcom.BSTR))
        self.__dict__["_SetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2010, vtable_offset_local+25, agcom.BSTR)
        self.__dict__["_GetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2010, vtable_offset_local+26, POINTER(agcom.BSTR))
        self.__dict__["_SetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2010, vtable_offset_local+27, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAMarsGRAM2010.__dict__ and type(IVAMarsGRAM2010.__dict__[attrname]) == property:
            return IVAMarsGRAM2010.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAMarsGRAM2010.")
    
    @property
    def UseApproximateAltitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseApproximateAltitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseApproximateAltitude.setter
    def UseApproximateAltitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseApproximateAltitude"](arg_inVal.COM_val))

    @property
    def ComputesTemperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesTemperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ComputesPressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesPressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def SunPosition(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSunPosition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SunPosition.setter
    def SunPosition(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSunPosition"](arg_inVal.COM_val))

    @property
    def DataDirectory(self) -> str:
        """Path to the data directory."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDataDirectory"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DataDirectory.setter
    def DataDirectory(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDataDirectory"](arg_inVal.COM_val))

    @property
    def NamelistFile(self) -> str:
        """Full path of namelist file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNamelistFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @NamelistFile.setter
    def NamelistFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetNamelistFile"](arg_inVal.COM_val))

    @property
    def DensityType(self) -> "AgEVAMarsGRAMDensityType":
        """Low, mean, high or randomly perturbed density type."""
        with agmarshall.AgEnum_arg(AgEVAMarsGRAMDensityType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDensityType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DensityType.setter
    def DensityType(self, inVal:"AgEVAMarsGRAMDensityType") -> None:
        with agmarshall.AgEnum_arg(AgEVAMarsGRAMDensityType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDensityType"](arg_inVal.COM_val))

    @property
    def AtmosDataSource(self) -> "AgEVAAtmosDataSource":
        """The atmospheric model data source - data file or constant values."""
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataSource.setter
    def AtmosDataSource(self, inVal:"AgEVAAtmosDataSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataSource"](arg_inVal.COM_val))

    @property
    def F10p7(self) -> float:
        """Solar Flux (F10.7); the daily Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetF10p7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @F10p7.setter
    def F10p7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetF10p7"](arg_inVal.COM_val))

    @property
    def AtmosDataFilename(self) -> str:
        """The atmospheric model data file path."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataFilename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataFilename.setter
    def AtmosDataFilename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataFilename"](arg_inVal.COM_val))

    @property
    def DragModelType(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelType.setter
    def DragModelType(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelType"](arg_inVal.COM_val))

    @property
    def DragModelPluginName(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPluginName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelPluginName.setter
    def DragModelPluginName(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelPluginName"](arg_pVal.COM_val))

    @property
    def DragModelPlugin(self) -> "IVADragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPlugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VariableAreaHistoryFile(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVariableAreaHistoryFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VariableAreaHistoryFile.setter
    def VariableAreaHistoryFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVariableAreaHistoryFile"](arg_inVal.COM_val))

    @property
    def NPlateDefinitionFile(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNPlateDefinitionFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @NPlateDefinitionFile.setter
    def NPlateDefinitionFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetNPlateDefinitionFile"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{C9E4AA59-8B84-4AC1-938E-E5E92A12EC4F}", IVAMarsGRAM2010)
agcls.AgTypeNameMap["IVAMarsGRAM2010"] = IVAMarsGRAM2010

class IVAMarsGRAM2001(object):
    """Properties for the Mars-GRAM 2001 atmospheric model."""
    _uuid = "{D9213F74-E8C9-4251-9BD6-FA0C0138AFCD}"
    _num_methods = 27
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_SetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_GetComputesTemperature"] = _raise_uninitialized_error
        self.__dict__["_GetComputesPressure"] = _raise_uninitialized_error
        self.__dict__["_GetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_SetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_GetDataDirectory"] = _raise_uninitialized_error
        self.__dict__["_SetDataDirectory"] = _raise_uninitialized_error
        self.__dict__["_GetNamelistFile"] = _raise_uninitialized_error
        self.__dict__["_SetNamelistFile"] = _raise_uninitialized_error
        self.__dict__["_GetDensityType"] = _raise_uninitialized_error
        self.__dict__["_SetDensityType"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataSource"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataSource"] = _raise_uninitialized_error
        self.__dict__["_GetF10p7"] = _raise_uninitialized_error
        self.__dict__["_SetF10p7"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataFilename"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataFilename"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPlugin"] = _raise_uninitialized_error
        self.__dict__["_GetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_SetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_GetNPlateDefinitionFile"] = _raise_uninitialized_error
        self.__dict__["_SetNPlateDefinitionFile"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAMarsGRAM2001._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAMarsGRAM2001 from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAMarsGRAM2001 = agcom.GUID(IVAMarsGRAM2001._uuid)
        vtable_offset_local = IVAMarsGRAM2001._vtable_offset - 1
        self.__dict__["_GetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2001, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2001, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetComputesTemperature"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2001, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetComputesPressure"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2001, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2001, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2001, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetDataDirectory"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2001, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_SetDataDirectory"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2001, vtable_offset_local+8, agcom.BSTR)
        self.__dict__["_GetNamelistFile"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2001, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_SetNamelistFile"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2001, vtable_offset_local+10, agcom.BSTR)
        self.__dict__["_GetDensityType"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2001, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_SetDensityType"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2001, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_GetAtmosDataSource"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2001, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_SetAtmosDataSource"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2001, vtable_offset_local+14, agcom.LONG)
        self.__dict__["_GetF10p7"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2001, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_SetF10p7"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2001, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_GetAtmosDataFilename"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2001, vtable_offset_local+17, POINTER(agcom.BSTR))
        self.__dict__["_SetAtmosDataFilename"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2001, vtable_offset_local+18, agcom.BSTR)
        self.__dict__["_GetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2001, vtable_offset_local+19, POINTER(agcom.LONG))
        self.__dict__["_SetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2001, vtable_offset_local+20, agcom.LONG)
        self.__dict__["_GetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2001, vtable_offset_local+21, POINTER(agcom.BSTR))
        self.__dict__["_SetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2001, vtable_offset_local+22, agcom.BSTR)
        self.__dict__["_GetDragModelPlugin"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2001, vtable_offset_local+23, POINTER(agcom.PVOID))
        self.__dict__["_GetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2001, vtable_offset_local+24, POINTER(agcom.BSTR))
        self.__dict__["_SetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2001, vtable_offset_local+25, agcom.BSTR)
        self.__dict__["_GetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2001, vtable_offset_local+26, POINTER(agcom.BSTR))
        self.__dict__["_SetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2001, vtable_offset_local+27, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAMarsGRAM2001.__dict__ and type(IVAMarsGRAM2001.__dict__[attrname]) == property:
            return IVAMarsGRAM2001.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAMarsGRAM2001.")
    
    @property
    def UseApproximateAltitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseApproximateAltitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseApproximateAltitude.setter
    def UseApproximateAltitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseApproximateAltitude"](arg_inVal.COM_val))

    @property
    def ComputesTemperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesTemperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ComputesPressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesPressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def SunPosition(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSunPosition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SunPosition.setter
    def SunPosition(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSunPosition"](arg_inVal.COM_val))

    @property
    def DataDirectory(self) -> str:
        """Path to the data directory."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDataDirectory"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DataDirectory.setter
    def DataDirectory(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDataDirectory"](arg_inVal.COM_val))

    @property
    def NamelistFile(self) -> str:
        """Path to namelist file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNamelistFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @NamelistFile.setter
    def NamelistFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetNamelistFile"](arg_inVal.COM_val))

    @property
    def DensityType(self) -> "AgEVAMarsGRAMDensityType":
        """Low, mean, high or randomly perturbed density type."""
        with agmarshall.AgEnum_arg(AgEVAMarsGRAMDensityType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDensityType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DensityType.setter
    def DensityType(self, inVal:"AgEVAMarsGRAMDensityType") -> None:
        with agmarshall.AgEnum_arg(AgEVAMarsGRAMDensityType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDensityType"](arg_inVal.COM_val))

    @property
    def AtmosDataSource(self) -> "AgEVAAtmosDataSource":
        """The atmospheric model data source - data file or constant values."""
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataSource.setter
    def AtmosDataSource(self, inVal:"AgEVAAtmosDataSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataSource"](arg_inVal.COM_val))

    @property
    def F10p7(self) -> float:
        """Solar Flux (F10.7); the daily Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetF10p7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @F10p7.setter
    def F10p7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetF10p7"](arg_inVal.COM_val))

    @property
    def AtmosDataFilename(self) -> str:
        """The atmospheric model data file path."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataFilename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataFilename.setter
    def AtmosDataFilename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataFilename"](arg_inVal.COM_val))

    @property
    def DragModelType(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelType.setter
    def DragModelType(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelType"](arg_inVal.COM_val))

    @property
    def DragModelPluginName(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPluginName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelPluginName.setter
    def DragModelPluginName(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelPluginName"](arg_pVal.COM_val))

    @property
    def DragModelPlugin(self) -> "IVADragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPlugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VariableAreaHistoryFile(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVariableAreaHistoryFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VariableAreaHistoryFile.setter
    def VariableAreaHistoryFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVariableAreaHistoryFile"](arg_inVal.COM_val))

    @property
    def NPlateDefinitionFile(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNPlateDefinitionFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @NPlateDefinitionFile.setter
    def NPlateDefinitionFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetNPlateDefinitionFile"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{D9213F74-E8C9-4251-9BD6-FA0C0138AFCD}", IVAMarsGRAM2001)
agcls.AgTypeNameMap["IVAMarsGRAM2001"] = IVAMarsGRAM2001

class IVAMarsGRAM2000(object):
    """Properties for the Mars-GRAM 2000 atmospheric model."""
    _uuid = "{E3458F58-63AD-4974-9EDA-524E9418A1DF}"
    _num_methods = 27
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_SetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_GetComputesTemperature"] = _raise_uninitialized_error
        self.__dict__["_GetComputesPressure"] = _raise_uninitialized_error
        self.__dict__["_GetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_SetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_GetDataDirectory"] = _raise_uninitialized_error
        self.__dict__["_SetDataDirectory"] = _raise_uninitialized_error
        self.__dict__["_GetNamelistFile"] = _raise_uninitialized_error
        self.__dict__["_SetNamelistFile"] = _raise_uninitialized_error
        self.__dict__["_GetDensityType"] = _raise_uninitialized_error
        self.__dict__["_SetDensityType"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataSource"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataSource"] = _raise_uninitialized_error
        self.__dict__["_GetF10p7"] = _raise_uninitialized_error
        self.__dict__["_SetF10p7"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataFilename"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataFilename"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPlugin"] = _raise_uninitialized_error
        self.__dict__["_GetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_SetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_GetNPlateDefinitionFile"] = _raise_uninitialized_error
        self.__dict__["_SetNPlateDefinitionFile"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAMarsGRAM2000._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAMarsGRAM2000 from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAMarsGRAM2000 = agcom.GUID(IVAMarsGRAM2000._uuid)
        vtable_offset_local = IVAMarsGRAM2000._vtable_offset - 1
        self.__dict__["_GetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2000, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2000, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetComputesTemperature"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2000, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetComputesPressure"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2000, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2000, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2000, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetDataDirectory"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2000, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_SetDataDirectory"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2000, vtable_offset_local+8, agcom.BSTR)
        self.__dict__["_GetNamelistFile"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2000, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_SetNamelistFile"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2000, vtable_offset_local+10, agcom.BSTR)
        self.__dict__["_GetDensityType"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2000, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_SetDensityType"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2000, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_GetAtmosDataSource"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2000, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_SetAtmosDataSource"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2000, vtable_offset_local+14, agcom.LONG)
        self.__dict__["_GetF10p7"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2000, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_SetF10p7"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2000, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_GetAtmosDataFilename"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2000, vtable_offset_local+17, POINTER(agcom.BSTR))
        self.__dict__["_SetAtmosDataFilename"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2000, vtable_offset_local+18, agcom.BSTR)
        self.__dict__["_GetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2000, vtable_offset_local+19, POINTER(agcom.LONG))
        self.__dict__["_SetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2000, vtable_offset_local+20, agcom.LONG)
        self.__dict__["_GetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2000, vtable_offset_local+21, POINTER(agcom.BSTR))
        self.__dict__["_SetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2000, vtable_offset_local+22, agcom.BSTR)
        self.__dict__["_GetDragModelPlugin"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2000, vtable_offset_local+23, POINTER(agcom.PVOID))
        self.__dict__["_GetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2000, vtable_offset_local+24, POINTER(agcom.BSTR))
        self.__dict__["_SetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2000, vtable_offset_local+25, agcom.BSTR)
        self.__dict__["_GetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2000, vtable_offset_local+26, POINTER(agcom.BSTR))
        self.__dict__["_SetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVAMarsGRAM2000, vtable_offset_local+27, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAMarsGRAM2000.__dict__ and type(IVAMarsGRAM2000.__dict__[attrname]) == property:
            return IVAMarsGRAM2000.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAMarsGRAM2000.")
    
    @property
    def UseApproximateAltitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseApproximateAltitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseApproximateAltitude.setter
    def UseApproximateAltitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseApproximateAltitude"](arg_inVal.COM_val))

    @property
    def ComputesTemperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesTemperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ComputesPressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesPressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def SunPosition(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSunPosition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SunPosition.setter
    def SunPosition(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSunPosition"](arg_inVal.COM_val))

    @property
    def DataDirectory(self) -> str:
        """Path to the data directory."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDataDirectory"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DataDirectory.setter
    def DataDirectory(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDataDirectory"](arg_inVal.COM_val))

    @property
    def NamelistFile(self) -> str:
        """Full path of namelist file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNamelistFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @NamelistFile.setter
    def NamelistFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetNamelistFile"](arg_inVal.COM_val))

    @property
    def DensityType(self) -> "AgEVAMarsGRAMDensityType":
        """Low, mean, high or randomly perturbed density type."""
        with agmarshall.AgEnum_arg(AgEVAMarsGRAMDensityType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDensityType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DensityType.setter
    def DensityType(self, inVal:"AgEVAMarsGRAMDensityType") -> None:
        with agmarshall.AgEnum_arg(AgEVAMarsGRAMDensityType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDensityType"](arg_inVal.COM_val))

    @property
    def AtmosDataSource(self) -> "AgEVAAtmosDataSource":
        """The atmospheric model data source - data file or constant values."""
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataSource.setter
    def AtmosDataSource(self, inVal:"AgEVAAtmosDataSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataSource"](arg_inVal.COM_val))

    @property
    def F10p7(self) -> float:
        """Solar Flux (F10.7); the daily Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetF10p7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @F10p7.setter
    def F10p7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetF10p7"](arg_inVal.COM_val))

    @property
    def AtmosDataFilename(self) -> str:
        """The atmospheric model data file path."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataFilename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataFilename.setter
    def AtmosDataFilename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataFilename"](arg_inVal.COM_val))

    @property
    def DragModelType(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelType.setter
    def DragModelType(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelType"](arg_inVal.COM_val))

    @property
    def DragModelPluginName(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPluginName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelPluginName.setter
    def DragModelPluginName(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelPluginName"](arg_pVal.COM_val))

    @property
    def DragModelPlugin(self) -> "IVADragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPlugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def VariableAreaHistoryFile(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVariableAreaHistoryFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VariableAreaHistoryFile.setter
    def VariableAreaHistoryFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVariableAreaHistoryFile"](arg_inVal.COM_val))

    @property
    def NPlateDefinitionFile(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNPlateDefinitionFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @NPlateDefinitionFile.setter
    def NPlateDefinitionFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetNPlateDefinitionFile"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E3458F58-63AD-4974-9EDA-524E9418A1DF}", IVAMarsGRAM2000)
agcls.AgTypeNameMap["IVAMarsGRAM2000"] = IVAMarsGRAM2000

class IVADTM2012(object):
    """Properties for the DTM 2012 atmospheric model."""
    _uuid = "{4840E65F-6197-4A64-A80A-E0DF1E1048E0}"
    _num_methods = 29
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_SetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_GetComputesTemperature"] = _raise_uninitialized_error
        self.__dict__["_GetComputesPressure"] = _raise_uninitialized_error
        self.__dict__["_GetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_SetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataSource"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataSource"] = _raise_uninitialized_error
        self.__dict__["_GetF10p7Avg"] = _raise_uninitialized_error
        self.__dict__["_SetF10p7Avg"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataFilename"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataFilename"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPlugin"] = _raise_uninitialized_error
        self.__dict__["_GetF10p7"] = _raise_uninitialized_error
        self.__dict__["_SetF10p7"] = _raise_uninitialized_error
        self.__dict__["_GetKp"] = _raise_uninitialized_error
        self.__dict__["_SetKp"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataGeoMagneticFluxSource"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataGeoMagneticFluxSource"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataGeoMagneticFluxUpdateRate"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataGeoMagneticFluxUpdateRate"] = _raise_uninitialized_error
        self.__dict__["_GetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_SetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_GetNPlateDefinitionFile"] = _raise_uninitialized_error
        self.__dict__["_SetNPlateDefinitionFile"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVADTM2012._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVADTM2012 from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVADTM2012 = agcom.GUID(IVADTM2012._uuid)
        vtable_offset_local = IVADTM2012._vtable_offset - 1
        self.__dict__["_GetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVADTM2012, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVADTM2012, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetComputesTemperature"] = IAGFUNCTYPE(pUnk, IID_IVADTM2012, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetComputesPressure"] = IAGFUNCTYPE(pUnk, IID_IVADTM2012, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVADTM2012, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVADTM2012, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetAtmosDataSource"] = IAGFUNCTYPE(pUnk, IID_IVADTM2012, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetAtmosDataSource"] = IAGFUNCTYPE(pUnk, IID_IVADTM2012, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetF10p7Avg"] = IAGFUNCTYPE(pUnk, IID_IVADTM2012, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetF10p7Avg"] = IAGFUNCTYPE(pUnk, IID_IVADTM2012, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetAtmosDataFilename"] = IAGFUNCTYPE(pUnk, IID_IVADTM2012, vtable_offset_local+11, POINTER(agcom.BSTR))
        self.__dict__["_SetAtmosDataFilename"] = IAGFUNCTYPE(pUnk, IID_IVADTM2012, vtable_offset_local+12, agcom.BSTR)
        self.__dict__["_GetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVADTM2012, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_SetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVADTM2012, vtable_offset_local+14, agcom.LONG)
        self.__dict__["_GetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVADTM2012, vtable_offset_local+15, POINTER(agcom.BSTR))
        self.__dict__["_SetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVADTM2012, vtable_offset_local+16, agcom.BSTR)
        self.__dict__["_GetDragModelPlugin"] = IAGFUNCTYPE(pUnk, IID_IVADTM2012, vtable_offset_local+17, POINTER(agcom.PVOID))
        self.__dict__["_GetF10p7"] = IAGFUNCTYPE(pUnk, IID_IVADTM2012, vtable_offset_local+18, POINTER(agcom.DOUBLE))
        self.__dict__["_SetF10p7"] = IAGFUNCTYPE(pUnk, IID_IVADTM2012, vtable_offset_local+19, agcom.DOUBLE)
        self.__dict__["_GetKp"] = IAGFUNCTYPE(pUnk, IID_IVADTM2012, vtable_offset_local+20, POINTER(agcom.DOUBLE))
        self.__dict__["_SetKp"] = IAGFUNCTYPE(pUnk, IID_IVADTM2012, vtable_offset_local+21, agcom.DOUBLE)
        self.__dict__["_GetAtmosDataGeoMagneticFluxSource"] = IAGFUNCTYPE(pUnk, IID_IVADTM2012, vtable_offset_local+22, POINTER(agcom.LONG))
        self.__dict__["_SetAtmosDataGeoMagneticFluxSource"] = IAGFUNCTYPE(pUnk, IID_IVADTM2012, vtable_offset_local+23, agcom.LONG)
        self.__dict__["_GetAtmosDataGeoMagneticFluxUpdateRate"] = IAGFUNCTYPE(pUnk, IID_IVADTM2012, vtable_offset_local+24, POINTER(agcom.LONG))
        self.__dict__["_SetAtmosDataGeoMagneticFluxUpdateRate"] = IAGFUNCTYPE(pUnk, IID_IVADTM2012, vtable_offset_local+25, agcom.LONG)
        self.__dict__["_GetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVADTM2012, vtable_offset_local+26, POINTER(agcom.BSTR))
        self.__dict__["_SetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVADTM2012, vtable_offset_local+27, agcom.BSTR)
        self.__dict__["_GetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVADTM2012, vtable_offset_local+28, POINTER(agcom.BSTR))
        self.__dict__["_SetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVADTM2012, vtable_offset_local+29, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVADTM2012.__dict__ and type(IVADTM2012.__dict__[attrname]) == property:
            return IVADTM2012.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVADTM2012.")
    
    @property
    def UseApproximateAltitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseApproximateAltitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseApproximateAltitude.setter
    def UseApproximateAltitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseApproximateAltitude"](arg_inVal.COM_val))

    @property
    def ComputesTemperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesTemperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ComputesPressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesPressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def SunPosition(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSunPosition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SunPosition.setter
    def SunPosition(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSunPosition"](arg_inVal.COM_val))

    @property
    def AtmosDataSource(self) -> "AgEVAAtmosDataSource":
        """The atmospheric model data source - data file or constant values."""
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataSource.setter
    def AtmosDataSource(self, inVal:"AgEVAAtmosDataSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataSource"](arg_inVal.COM_val))

    @property
    def F10p7Avg(self) -> float:
        """Average solar Flux (F10.7); the 81-day averaged Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetF10p7Avg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @F10p7Avg.setter
    def F10p7Avg(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetF10p7Avg"](arg_inVal.COM_val))

    @property
    def AtmosDataFilename(self) -> str:
        """Flux file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataFilename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataFilename.setter
    def AtmosDataFilename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataFilename"](arg_inVal.COM_val))

    @property
    def DragModelType(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelType.setter
    def DragModelType(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelType"](arg_inVal.COM_val))

    @property
    def DragModelPluginName(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPluginName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelPluginName.setter
    def DragModelPluginName(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelPluginName"](arg_pVal.COM_val))

    @property
    def DragModelPlugin(self) -> "IVADragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPlugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def F10p7(self) -> float:
        """Solar Flux (F10.7); the daily Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetF10p7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @F10p7.setter
    def F10p7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetF10p7"](arg_inVal.COM_val))

    @property
    def Kp(self) -> float:
        """Geomagnetic Index (Kp). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetKp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Kp.setter
    def Kp(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetKp"](arg_inVal.COM_val))

    @property
    def AtmosDataGeoMagneticFluxSource(self) -> "AgEVAGeoMagneticFluxSource":
        """Whether to use Kp or Ap data from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataGeoMagneticFluxSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataGeoMagneticFluxSource.setter
    def AtmosDataGeoMagneticFluxSource(self, inVal:"AgEVAGeoMagneticFluxSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataGeoMagneticFluxSource"](arg_inVal.COM_val))

    @property
    def AtmosDataGeoMagneticFluxUpdateRate(self) -> "AgEVAGeoMagneticFluxUpdateRate":
        """The update rate of geomagnetic flux values from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataGeoMagneticFluxUpdateRate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataGeoMagneticFluxUpdateRate.setter
    def AtmosDataGeoMagneticFluxUpdateRate(self, inVal:"AgEVAGeoMagneticFluxUpdateRate") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataGeoMagneticFluxUpdateRate"](arg_inVal.COM_val))

    @property
    def VariableAreaHistoryFile(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVariableAreaHistoryFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VariableAreaHistoryFile.setter
    def VariableAreaHistoryFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVariableAreaHistoryFile"](arg_inVal.COM_val))

    @property
    def NPlateDefinitionFile(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNPlateDefinitionFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @NPlateDefinitionFile.setter
    def NPlateDefinitionFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetNPlateDefinitionFile"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4840E65F-6197-4A64-A80A-E0DF1E1048E0}", IVADTM2012)
agcls.AgTypeNameMap["IVADTM2012"] = IVADTM2012

class IVADTM2020(object):
    """Properties for the DTM 2020 atmospheric model."""
    _uuid = "{50AA8B32-1905-416D-B45E-631E78F5F174}"
    _num_methods = 29
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_SetUseApproximateAltitude"] = _raise_uninitialized_error
        self.__dict__["_GetComputesTemperature"] = _raise_uninitialized_error
        self.__dict__["_GetComputesPressure"] = _raise_uninitialized_error
        self.__dict__["_GetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_SetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataSource"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataSource"] = _raise_uninitialized_error
        self.__dict__["_GetF10p7Avg"] = _raise_uninitialized_error
        self.__dict__["_SetF10p7Avg"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataFilename"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataFilename"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelType"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_SetDragModelPluginName"] = _raise_uninitialized_error
        self.__dict__["_GetDragModelPlugin"] = _raise_uninitialized_error
        self.__dict__["_GetF10p7"] = _raise_uninitialized_error
        self.__dict__["_SetF10p7"] = _raise_uninitialized_error
        self.__dict__["_GetKp"] = _raise_uninitialized_error
        self.__dict__["_SetKp"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataGeoMagneticFluxSource"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataGeoMagneticFluxSource"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosDataGeoMagneticFluxUpdateRate"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosDataGeoMagneticFluxUpdateRate"] = _raise_uninitialized_error
        self.__dict__["_GetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_SetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_GetNPlateDefinitionFile"] = _raise_uninitialized_error
        self.__dict__["_SetNPlateDefinitionFile"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVADTM2020._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVADTM2020 from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVADTM2020 = agcom.GUID(IVADTM2020._uuid)
        vtable_offset_local = IVADTM2020._vtable_offset - 1
        self.__dict__["_GetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVADTM2020, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseApproximateAltitude"] = IAGFUNCTYPE(pUnk, IID_IVADTM2020, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_GetComputesTemperature"] = IAGFUNCTYPE(pUnk, IID_IVADTM2020, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetComputesPressure"] = IAGFUNCTYPE(pUnk, IID_IVADTM2020, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVADTM2020, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVADTM2020, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetAtmosDataSource"] = IAGFUNCTYPE(pUnk, IID_IVADTM2020, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetAtmosDataSource"] = IAGFUNCTYPE(pUnk, IID_IVADTM2020, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetF10p7Avg"] = IAGFUNCTYPE(pUnk, IID_IVADTM2020, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetF10p7Avg"] = IAGFUNCTYPE(pUnk, IID_IVADTM2020, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetAtmosDataFilename"] = IAGFUNCTYPE(pUnk, IID_IVADTM2020, vtable_offset_local+11, POINTER(agcom.BSTR))
        self.__dict__["_SetAtmosDataFilename"] = IAGFUNCTYPE(pUnk, IID_IVADTM2020, vtable_offset_local+12, agcom.BSTR)
        self.__dict__["_GetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVADTM2020, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_SetDragModelType"] = IAGFUNCTYPE(pUnk, IID_IVADTM2020, vtable_offset_local+14, agcom.LONG)
        self.__dict__["_GetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVADTM2020, vtable_offset_local+15, POINTER(agcom.BSTR))
        self.__dict__["_SetDragModelPluginName"] = IAGFUNCTYPE(pUnk, IID_IVADTM2020, vtable_offset_local+16, agcom.BSTR)
        self.__dict__["_GetDragModelPlugin"] = IAGFUNCTYPE(pUnk, IID_IVADTM2020, vtable_offset_local+17, POINTER(agcom.PVOID))
        self.__dict__["_GetF10p7"] = IAGFUNCTYPE(pUnk, IID_IVADTM2020, vtable_offset_local+18, POINTER(agcom.DOUBLE))
        self.__dict__["_SetF10p7"] = IAGFUNCTYPE(pUnk, IID_IVADTM2020, vtable_offset_local+19, agcom.DOUBLE)
        self.__dict__["_GetKp"] = IAGFUNCTYPE(pUnk, IID_IVADTM2020, vtable_offset_local+20, POINTER(agcom.DOUBLE))
        self.__dict__["_SetKp"] = IAGFUNCTYPE(pUnk, IID_IVADTM2020, vtable_offset_local+21, agcom.DOUBLE)
        self.__dict__["_GetAtmosDataGeoMagneticFluxSource"] = IAGFUNCTYPE(pUnk, IID_IVADTM2020, vtable_offset_local+22, POINTER(agcom.LONG))
        self.__dict__["_SetAtmosDataGeoMagneticFluxSource"] = IAGFUNCTYPE(pUnk, IID_IVADTM2020, vtable_offset_local+23, agcom.LONG)
        self.__dict__["_GetAtmosDataGeoMagneticFluxUpdateRate"] = IAGFUNCTYPE(pUnk, IID_IVADTM2020, vtable_offset_local+24, POINTER(agcom.LONG))
        self.__dict__["_SetAtmosDataGeoMagneticFluxUpdateRate"] = IAGFUNCTYPE(pUnk, IID_IVADTM2020, vtable_offset_local+25, agcom.LONG)
        self.__dict__["_GetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVADTM2020, vtable_offset_local+26, POINTER(agcom.BSTR))
        self.__dict__["_SetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVADTM2020, vtable_offset_local+27, agcom.BSTR)
        self.__dict__["_GetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVADTM2020, vtable_offset_local+28, POINTER(agcom.BSTR))
        self.__dict__["_SetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVADTM2020, vtable_offset_local+29, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVADTM2020.__dict__ and type(IVADTM2020.__dict__[attrname]) == property:
            return IVADTM2020.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVADTM2020.")
    
    @property
    def UseApproximateAltitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseApproximateAltitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseApproximateAltitude.setter
    def UseApproximateAltitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseApproximateAltitude"](arg_inVal.COM_val))

    @property
    def ComputesTemperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesTemperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ComputesPressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetComputesPressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def SunPosition(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSunPosition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SunPosition.setter
    def SunPosition(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSunPosition"](arg_inVal.COM_val))

    @property
    def AtmosDataSource(self) -> "AgEVAAtmosDataSource":
        """The atmospheric model data source - data file or constant values."""
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataSource.setter
    def AtmosDataSource(self, inVal:"AgEVAAtmosDataSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataSource"](arg_inVal.COM_val))

    @property
    def F10p7Avg(self) -> float:
        """Average solar Flux (F10.7); the 81-day averaged Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetF10p7Avg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @F10p7Avg.setter
    def F10p7Avg(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetF10p7Avg"](arg_inVal.COM_val))

    @property
    def AtmosDataFilename(self) -> str:
        """Flux file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataFilename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataFilename.setter
    def AtmosDataFilename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataFilename"](arg_inVal.COM_val))

    @property
    def DragModelType(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelType.setter
    def DragModelType(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelType"](arg_inVal.COM_val))

    @property
    def DragModelPluginName(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPluginName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DragModelPluginName.setter
    def DragModelPluginName(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetDragModelPluginName"](arg_pVal.COM_val))

    @property
    def DragModelPlugin(self) -> "IVADragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetDragModelPlugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def F10p7(self) -> float:
        """Solar Flux (F10.7); the daily Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetF10p7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @F10p7.setter
    def F10p7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetF10p7"](arg_inVal.COM_val))

    @property
    def Kp(self) -> float:
        """Geomagnetic Index (Kp). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetKp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Kp.setter
    def Kp(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetKp"](arg_inVal.COM_val))

    @property
    def AtmosDataGeoMagneticFluxSource(self) -> "AgEVAGeoMagneticFluxSource":
        """Whether to use Kp or Ap data from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataGeoMagneticFluxSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataGeoMagneticFluxSource.setter
    def AtmosDataGeoMagneticFluxSource(self, inVal:"AgEVAGeoMagneticFluxSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataGeoMagneticFluxSource"](arg_inVal.COM_val))

    @property
    def AtmosDataGeoMagneticFluxUpdateRate(self) -> "AgEVAGeoMagneticFluxUpdateRate":
        """The update rate of geomagnetic flux values from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosDataGeoMagneticFluxUpdateRate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosDataGeoMagneticFluxUpdateRate.setter
    def AtmosDataGeoMagneticFluxUpdateRate(self, inVal:"AgEVAGeoMagneticFluxUpdateRate") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosDataGeoMagneticFluxUpdateRate"](arg_inVal.COM_val))

    @property
    def VariableAreaHistoryFile(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVariableAreaHistoryFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VariableAreaHistoryFile.setter
    def VariableAreaHistoryFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVariableAreaHistoryFile"](arg_inVal.COM_val))

    @property
    def NPlateDefinitionFile(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNPlateDefinitionFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @NPlateDefinitionFile.setter
    def NPlateDefinitionFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetNPlateDefinitionFile"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{50AA8B32-1905-416D-B45E-631E78F5F174}", IVADTM2020)
agcls.AgTypeNameMap["IVADTM2020"] = IVADTM2020

class IVAGravityFieldFunction(object):
    """Properties for the Gravitational Force gravity model - a complex gravitational force calculation, optionally including solid and ocean tide effects."""
    _uuid = "{B199E3B6-9964-4CAA-A824-1F106886E0DE}"
    _num_methods = 35
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetGravityFilename"] = _raise_uninitialized_error
        self.__dict__["_SetGravityFilename"] = _raise_uninitialized_error
        self.__dict__["_GetDegree"] = _raise_uninitialized_error
        self.__dict__["_SetDegree"] = _raise_uninitialized_error
        self.__dict__["_GetOrder"] = _raise_uninitialized_error
        self.__dict__["_SetOrder"] = _raise_uninitialized_error
        self.__dict__["_GetMaxDegreeText"] = _raise_uninitialized_error
        self.__dict__["_GetMaxOrderText"] = _raise_uninitialized_error
        self.__dict__["_GetIncludeTimeDependentSolidTides"] = _raise_uninitialized_error
        self.__dict__["_SetIncludeTimeDependentSolidTides"] = _raise_uninitialized_error
        self.__dict__["_GetSolidTideMinAmp"] = _raise_uninitialized_error
        self.__dict__["_SetSolidTideMinAmp"] = _raise_uninitialized_error
        self.__dict__["_GetUseOceanTides"] = _raise_uninitialized_error
        self.__dict__["_SetUseOceanTides"] = _raise_uninitialized_error
        self.__dict__["_GetOceanTideMinAmp"] = _raise_uninitialized_error
        self.__dict__["_SetOceanTideMinAmp"] = _raise_uninitialized_error
        self.__dict__["_GetMinRadiusPercent"] = _raise_uninitialized_error
        self.__dict__["_SetMinRadiusPercent"] = _raise_uninitialized_error
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetOceanTideMaxDegree"] = _raise_uninitialized_error
        self.__dict__["_SetOceanTideMaxDegree"] = _raise_uninitialized_error
        self.__dict__["_GetOceanTideMaxOrder"] = _raise_uninitialized_error
        self.__dict__["_SetOceanTideMaxOrder"] = _raise_uninitialized_error
        self.__dict__["_GetSolidTideType"] = _raise_uninitialized_error
        self.__dict__["_SetSolidTideType"] = _raise_uninitialized_error
        self.__dict__["_GetTruncateSolidTides"] = _raise_uninitialized_error
        self.__dict__["_SetTruncateSolidTides"] = _raise_uninitialized_error
        self.__dict__["_GetUseSecularVariations"] = _raise_uninitialized_error
        self.__dict__["_SetUseSecularVariations"] = _raise_uninitialized_error
        self.__dict__["_GetPartialsDegree"] = _raise_uninitialized_error
        self.__dict__["_SetPartialsDegree"] = _raise_uninitialized_error
        self.__dict__["_GetPartialsOrder"] = _raise_uninitialized_error
        self.__dict__["_SetPartialsOrder"] = _raise_uninitialized_error
        self.__dict__["_GetMaxPartialsDegreeText"] = _raise_uninitialized_error
        self.__dict__["_GetMaxPartialsOrderText"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAGravityFieldFunction._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAGravityFieldFunction from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAGravityFieldFunction = agcom.GUID(IVAGravityFieldFunction._uuid)
        vtable_offset_local = IVAGravityFieldFunction._vtable_offset - 1
        self.__dict__["_GetGravityFilename"] = IAGFUNCTYPE(pUnk, IID_IVAGravityFieldFunction, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetGravityFilename"] = IAGFUNCTYPE(pUnk, IID_IVAGravityFieldFunction, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetDegree"] = IAGFUNCTYPE(pUnk, IID_IVAGravityFieldFunction, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetDegree"] = IAGFUNCTYPE(pUnk, IID_IVAGravityFieldFunction, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetOrder"] = IAGFUNCTYPE(pUnk, IID_IVAGravityFieldFunction, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetOrder"] = IAGFUNCTYPE(pUnk, IID_IVAGravityFieldFunction, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetMaxDegreeText"] = IAGFUNCTYPE(pUnk, IID_IVAGravityFieldFunction, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_GetMaxOrderText"] = IAGFUNCTYPE(pUnk, IID_IVAGravityFieldFunction, vtable_offset_local+8, POINTER(agcom.BSTR))
        self.__dict__["_GetIncludeTimeDependentSolidTides"] = IAGFUNCTYPE(pUnk, IID_IVAGravityFieldFunction, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIncludeTimeDependentSolidTides"] = IAGFUNCTYPE(pUnk, IID_IVAGravityFieldFunction, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_GetSolidTideMinAmp"] = IAGFUNCTYPE(pUnk, IID_IVAGravityFieldFunction, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetSolidTideMinAmp"] = IAGFUNCTYPE(pUnk, IID_IVAGravityFieldFunction, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetUseOceanTides"] = IAGFUNCTYPE(pUnk, IID_IVAGravityFieldFunction, vtable_offset_local+13, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseOceanTides"] = IAGFUNCTYPE(pUnk, IID_IVAGravityFieldFunction, vtable_offset_local+14, agcom.VARIANT_BOOL)
        self.__dict__["_GetOceanTideMinAmp"] = IAGFUNCTYPE(pUnk, IID_IVAGravityFieldFunction, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_SetOceanTideMinAmp"] = IAGFUNCTYPE(pUnk, IID_IVAGravityFieldFunction, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_GetMinRadiusPercent"] = IAGFUNCTYPE(pUnk, IID_IVAGravityFieldFunction, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMinRadiusPercent"] = IAGFUNCTYPE(pUnk, IID_IVAGravityFieldFunction, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAGravityFieldFunction, vtable_offset_local+19, POINTER(agcom.BSTR))
        self.__dict__["_GetOceanTideMaxDegree"] = IAGFUNCTYPE(pUnk, IID_IVAGravityFieldFunction, vtable_offset_local+20, POINTER(agcom.LONG))
        self.__dict__["_SetOceanTideMaxDegree"] = IAGFUNCTYPE(pUnk, IID_IVAGravityFieldFunction, vtable_offset_local+21, agcom.LONG)
        self.__dict__["_GetOceanTideMaxOrder"] = IAGFUNCTYPE(pUnk, IID_IVAGravityFieldFunction, vtable_offset_local+22, POINTER(agcom.LONG))
        self.__dict__["_SetOceanTideMaxOrder"] = IAGFUNCTYPE(pUnk, IID_IVAGravityFieldFunction, vtable_offset_local+23, agcom.LONG)
        self.__dict__["_GetSolidTideType"] = IAGFUNCTYPE(pUnk, IID_IVAGravityFieldFunction, vtable_offset_local+24, POINTER(agcom.LONG))
        self.__dict__["_SetSolidTideType"] = IAGFUNCTYPE(pUnk, IID_IVAGravityFieldFunction, vtable_offset_local+25, agcom.LONG)
        self.__dict__["_GetTruncateSolidTides"] = IAGFUNCTYPE(pUnk, IID_IVAGravityFieldFunction, vtable_offset_local+26, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetTruncateSolidTides"] = IAGFUNCTYPE(pUnk, IID_IVAGravityFieldFunction, vtable_offset_local+27, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseSecularVariations"] = IAGFUNCTYPE(pUnk, IID_IVAGravityFieldFunction, vtable_offset_local+28, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseSecularVariations"] = IAGFUNCTYPE(pUnk, IID_IVAGravityFieldFunction, vtable_offset_local+29, agcom.VARIANT_BOOL)
        self.__dict__["_GetPartialsDegree"] = IAGFUNCTYPE(pUnk, IID_IVAGravityFieldFunction, vtable_offset_local+30, POINTER(agcom.LONG))
        self.__dict__["_SetPartialsDegree"] = IAGFUNCTYPE(pUnk, IID_IVAGravityFieldFunction, vtable_offset_local+31, agcom.LONG)
        self.__dict__["_GetPartialsOrder"] = IAGFUNCTYPE(pUnk, IID_IVAGravityFieldFunction, vtable_offset_local+32, POINTER(agcom.LONG))
        self.__dict__["_SetPartialsOrder"] = IAGFUNCTYPE(pUnk, IID_IVAGravityFieldFunction, vtable_offset_local+33, agcom.LONG)
        self.__dict__["_GetMaxPartialsDegreeText"] = IAGFUNCTYPE(pUnk, IID_IVAGravityFieldFunction, vtable_offset_local+34, POINTER(agcom.BSTR))
        self.__dict__["_GetMaxPartialsOrderText"] = IAGFUNCTYPE(pUnk, IID_IVAGravityFieldFunction, vtable_offset_local+35, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAGravityFieldFunction.__dict__ and type(IVAGravityFieldFunction.__dict__[attrname]) == property:
            return IVAGravityFieldFunction.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAGravityFieldFunction.")
    
    @property
    def GravityFilename(self) -> str:
        """The name of the file containing the gravity field."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetGravityFilename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @GravityFilename.setter
    def GravityFilename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetGravityFilename"](arg_inVal.COM_val))

    @property
    def Degree(self) -> int:
        """The degree of geopotential coefficients to be included for Central Body gravity computations. Valid range is from 0 to 90, depending on the gravity model. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDegree"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Degree.setter
    def Degree(self, inVal:int) -> None:
        with agmarshall.LONG_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDegree"](arg_inVal.COM_val))

    @property
    def Order(self) -> int:
        """The order of geopotential coefficients to be included for Central Body gravity computations. Valid range is from 0 to 90, depending on the gravity model. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetOrder"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Order.setter
    def Order(self, inVal:int) -> None:
        with agmarshall.LONG_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetOrder"](arg_inVal.COM_val))

    @property
    def MaxDegreeText(self) -> str:
        """Displays the maximum degree permissible for the gravity model."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxDegreeText"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def MaxOrderText(self) -> str:
        """Displays the maximum order permissible for the gravity model."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxOrderText"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def IncludeTimeDependentSolidTides(self) -> bool:
        """True if including time dependent solid tides."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetIncludeTimeDependentSolidTides"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @IncludeTimeDependentSolidTides.setter
    def IncludeTimeDependentSolidTides(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetIncludeTimeDependentSolidTides"](arg_inVal.COM_val))

    @property
    def SolidTideMinAmp(self) -> float:
        """The minimum amplitude for solid tides; contributors that are below the minimum amplitude will not be factored into the computation. Uses SmallDistance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSolidTideMinAmp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SolidTideMinAmp.setter
    def SolidTideMinAmp(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSolidTideMinAmp"](arg_inVal.COM_val))

    @property
    def UseOceanTides(self) -> bool:
        """True if using ocean tides/"""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseOceanTides"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseOceanTides.setter
    def UseOceanTides(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseOceanTides"](arg_inVal.COM_val))

    @property
    def OceanTideMinAmp(self) -> float:
        """The minimum amplitude for ocean tides; contributors that are below the minimum amplitude will not be factored into the computation. Uses SmallDistance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetOceanTideMinAmp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @OceanTideMinAmp.setter
    def OceanTideMinAmp(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetOceanTideMinAmp"](arg_inVal.COM_val))

    @property
    def MinRadiusPercent(self) -> float:
        """The percentage of the central body's minimum radius at which a modified force model (only the two-body force) will be used - provided there is no altitude stopping condition. Uses Percent Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinRadiusPercent"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MinRadiusPercent.setter
    def MinRadiusPercent(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMinRadiusPercent"](arg_inVal.COM_val))

    @property
    def CentralBodyName(self) -> str:
        """The name of the central body"""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def OceanTideMaxDegree(self) -> int:
        """The maximum degree for force contributions from ocean tides that will be included in the computation. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetOceanTideMaxDegree"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @OceanTideMaxDegree.setter
    def OceanTideMaxDegree(self, inVal:int) -> None:
        with agmarshall.LONG_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetOceanTideMaxDegree"](arg_inVal.COM_val))

    @property
    def OceanTideMaxOrder(self) -> int:
        """The maximum order for force contributions from ocean tides that will be included in the computation. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetOceanTideMaxOrder"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @OceanTideMaxOrder.setter
    def OceanTideMaxOrder(self, inVal:int) -> None:
        with agmarshall.LONG_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetOceanTideMaxOrder"](arg_inVal.COM_val))

    @property
    def SolidTideType(self) -> "AgESolidTide":
        """The type of solid tide contribution to be modeled."""
        with agmarshall.AgEnum_arg(AgESolidTide) as arg_pSolidTide:
            agcls.evaluate_hresult(self.__dict__["_GetSolidTideType"](byref(arg_pSolidTide.COM_val)))
            return arg_pSolidTide.python_val

    @SolidTideType.setter
    def SolidTideType(self, solidTide:"AgESolidTide") -> None:
        with agmarshall.AgEnum_arg(AgESolidTide, solidTide) as arg_solidTide:
            agcls.evaluate_hresult(self.__dict__["_SetSolidTideType"](arg_solidTide.COM_val))

    @property
    def TruncateSolidTides(self) -> bool:
        """True if solid tide terms (including permanent tide) won't be included beyond the degree and order selected for the gravity model."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTruncateSolidTides"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TruncateSolidTides.setter
    def TruncateSolidTides(self, pVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetTruncateSolidTides"](arg_pVal.COM_val))

    @property
    def UseSecularVariations(self) -> bool:
        """Opt whether to include or ignore secular variations defined by the gravity field model."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseSecularVariations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseSecularVariations.setter
    def UseSecularVariations(self, pVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseSecularVariations"](arg_pVal.COM_val))

    @property
    def PartialsDegree(self) -> int:
        """The degree of geopotential coefficients to be included for Central Body gravity state transition matrix computations. Valid range is from 0 to 90, depending on the gravity model and the degree used for state computations. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPartialsDegree"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @PartialsDegree.setter
    def PartialsDegree(self, inVal:int) -> None:
        with agmarshall.LONG_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetPartialsDegree"](arg_inVal.COM_val))

    @property
    def PartialsOrder(self) -> int:
        """The order of geopotential coefficients to be included for Central Body gravity state transition matrix computations. Valid range is from 0 to 90, depending on the gravity model and the order used for state computations. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPartialsOrder"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @PartialsOrder.setter
    def PartialsOrder(self, inVal:int) -> None:
        with agmarshall.LONG_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetPartialsOrder"](arg_inVal.COM_val))

    @property
    def MaxPartialsDegreeText(self) -> str:
        """Displays the maximum degree permissible for the gravity model partials used in the STM."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxPartialsDegreeText"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def MaxPartialsOrderText(self) -> str:
        """Displays the maximum order permissible for the gravity model partials used in the STM."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxPartialsOrderText"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{B199E3B6-9964-4CAA-A824-1F106886E0DE}", IVAGravityFieldFunction)
agcls.AgTypeNameMap["IVAGravityFieldFunction"] = IVAGravityFieldFunction

class IVAPointMassFunction(object):
    """Properties for the Point Mass Function."""
    _uuid = "{DF0A48DA-12AA-4BCF-A9E1-CDE80A2C89A3}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetGravSource"] = _raise_uninitialized_error
        self.__dict__["_SetGravSource"] = _raise_uninitialized_error
        self.__dict__["_GetMu"] = _raise_uninitialized_error
        self.__dict__["_SetMu"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAPointMassFunction._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAPointMassFunction from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAPointMassFunction = agcom.GUID(IVAPointMassFunction._uuid)
        vtable_offset_local = IVAPointMassFunction._vtable_offset - 1
        self.__dict__["_GetGravSource"] = IAGFUNCTYPE(pUnk, IID_IVAPointMassFunction, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetGravSource"] = IAGFUNCTYPE(pUnk, IID_IVAPointMassFunction, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetMu"] = IAGFUNCTYPE(pUnk, IID_IVAPointMassFunction, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMu"] = IAGFUNCTYPE(pUnk, IID_IVAPointMassFunction, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAPointMassFunction.__dict__ and type(IVAPointMassFunction.__dict__[attrname]) == property:
            return IVAPointMassFunction.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAPointMassFunction.")
    
    @property
    def GravSource(self) -> "AgEVAGravParamSource":
        """The source for the third body's gravitational parameter."""
        with agmarshall.AgEnum_arg(AgEVAGravParamSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetGravSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @GravSource.setter
    def GravSource(self, inVal:"AgEVAGravParamSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAGravParamSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetGravSource"](arg_inVal.COM_val))

    @property
    def Mu(self) -> float:
        """The gravitational parameter. Uses Gravity Param Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMu"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Mu.setter
    def Mu(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMu"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{DF0A48DA-12AA-4BCF-A9E1-CDE80A2C89A3}", IVAPointMassFunction)
agcls.AgTypeNameMap["IVAPointMassFunction"] = IVAPointMassFunction

class IVATwoBodyFunction(object):
    """Properties for the Two Body gravity model - a standard point mass model."""
    _uuid = "{827AF54A-9389-4151-8193-7B3FAE64E66D}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetGravSource"] = _raise_uninitialized_error
        self.__dict__["_SetGravSource"] = _raise_uninitialized_error
        self.__dict__["_GetMu"] = _raise_uninitialized_error
        self.__dict__["_SetMu"] = _raise_uninitialized_error
        self.__dict__["_GetMinRadiusPercent"] = _raise_uninitialized_error
        self.__dict__["_SetMinRadiusPercent"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVATwoBodyFunction._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVATwoBodyFunction from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVATwoBodyFunction = agcom.GUID(IVATwoBodyFunction._uuid)
        vtable_offset_local = IVATwoBodyFunction._vtable_offset - 1
        self.__dict__["_GetGravSource"] = IAGFUNCTYPE(pUnk, IID_IVATwoBodyFunction, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetGravSource"] = IAGFUNCTYPE(pUnk, IID_IVATwoBodyFunction, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetMu"] = IAGFUNCTYPE(pUnk, IID_IVATwoBodyFunction, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMu"] = IAGFUNCTYPE(pUnk, IID_IVATwoBodyFunction, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetMinRadiusPercent"] = IAGFUNCTYPE(pUnk, IID_IVATwoBodyFunction, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMinRadiusPercent"] = IAGFUNCTYPE(pUnk, IID_IVATwoBodyFunction, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVATwoBodyFunction.__dict__ and type(IVATwoBodyFunction.__dict__[attrname]) == property:
            return IVATwoBodyFunction.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVATwoBodyFunction.")
    
    @property
    def GravSource(self) -> "AgEVAGravParamSource":
        """The source for the gravitational parameter."""
        with agmarshall.AgEnum_arg(AgEVAGravParamSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetGravSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @GravSource.setter
    def GravSource(self, inVal:"AgEVAGravParamSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAGravParamSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetGravSource"](arg_inVal.COM_val))

    @property
    def Mu(self) -> float:
        """The gravitational parameter. Uses Gravity Param Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMu"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Mu.setter
    def Mu(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMu"](arg_inVal.COM_val))

    @property
    def MinRadiusPercent(self) -> float:
        """The percentage of the central body's minimum radius at which a modified force model (only the two-body force) will be used - provided there is no altitude stopping condition. Uses Percent Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinRadiusPercent"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MinRadiusPercent.setter
    def MinRadiusPercent(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMinRadiusPercent"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{827AF54A-9389-4151-8193-7B3FAE64E66D}", IVATwoBodyFunction)
agcls.AgTypeNameMap["IVATwoBodyFunction"] = IVATwoBodyFunction

class IVAHPOPPluginFunction(object):
    """Properties for the HPOP Plugin propagator function."""
    _uuid = "{53854E6C-8125-44F8-B0B3-8CB5175C8AE9}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPluginIdentifier"] = _raise_uninitialized_error
        self.__dict__["_SetPluginIdentifier"] = _raise_uninitialized_error
        self.__dict__["_GetPluginConfig"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAHPOPPluginFunction._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAHPOPPluginFunction from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAHPOPPluginFunction = agcom.GUID(IVAHPOPPluginFunction._uuid)
        vtable_offset_local = IVAHPOPPluginFunction._vtable_offset - 1
        self.__dict__["_GetPluginIdentifier"] = IAGFUNCTYPE(pUnk, IID_IVAHPOPPluginFunction, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetPluginIdentifier"] = IAGFUNCTYPE(pUnk, IID_IVAHPOPPluginFunction, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetPluginConfig"] = IAGFUNCTYPE(pUnk, IID_IVAHPOPPluginFunction, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAHPOPPluginFunction.__dict__ and type(IVAHPOPPluginFunction.__dict__[attrname]) == property:
            return IVAHPOPPluginFunction.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAHPOPPluginFunction.")
    
    @property
    def PluginIdentifier(self) -> str:
        """The plugin name."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPluginIdentifier"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @PluginIdentifier.setter
    def PluginIdentifier(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetPluginIdentifier"](arg_inVal.COM_val))

    @property
    def PluginConfig(self) -> "IVAPluginProperties":
        """The properties of the selected plugin."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPluginConfig"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{53854E6C-8125-44F8-B0B3-8CB5175C8AE9}", IVAHPOPPluginFunction)
agcls.AgTypeNameMap["IVAHPOPPluginFunction"] = IVAHPOPPluginFunction

class IVAEOMFuncPluginFunction(object):
    """Properties for the EOM Function Plugin propagator function."""
    _uuid = "{D652969D-D848-4AF2-91C9-8BD479D0F681}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPluginIdentifier"] = _raise_uninitialized_error
        self.__dict__["_SetPluginIdentifier"] = _raise_uninitialized_error
        self.__dict__["_GetPluginConfig"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAEOMFuncPluginFunction._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAEOMFuncPluginFunction from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAEOMFuncPluginFunction = agcom.GUID(IVAEOMFuncPluginFunction._uuid)
        vtable_offset_local = IVAEOMFuncPluginFunction._vtable_offset - 1
        self.__dict__["_GetPluginIdentifier"] = IAGFUNCTYPE(pUnk, IID_IVAEOMFuncPluginFunction, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetPluginIdentifier"] = IAGFUNCTYPE(pUnk, IID_IVAEOMFuncPluginFunction, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetPluginConfig"] = IAGFUNCTYPE(pUnk, IID_IVAEOMFuncPluginFunction, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAEOMFuncPluginFunction.__dict__ and type(IVAEOMFuncPluginFunction.__dict__[attrname]) == property:
            return IVAEOMFuncPluginFunction.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAEOMFuncPluginFunction.")
    
    @property
    def PluginIdentifier(self) -> str:
        """The plugin name."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPluginIdentifier"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @PluginIdentifier.setter
    def PluginIdentifier(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetPluginIdentifier"](arg_inVal.COM_val))

    @property
    def PluginConfig(self) -> "IVAPluginProperties":
        """The properties of the selected plugin."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPluginConfig"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{D652969D-D848-4AF2-91C9-8BD479D0F681}", IVAEOMFuncPluginFunction)
agcls.AgTypeNameMap["IVAEOMFuncPluginFunction"] = IVAEOMFuncPluginFunction

class IVASRPAeroT20(object):
    """Properties for the Aerospace T20 solar radiation pressure model for GPS block IIA."""
    _uuid = "{1B712154-4552-4453-B784-5C773A9F88C0}"
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAtmosAlt"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosAlt"] = _raise_uninitialized_error
        self.__dict__["_GetShadowModel"] = _raise_uninitialized_error
        self.__dict__["_SetShadowModel"] = _raise_uninitialized_error
        self.__dict__["_GetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_SetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_GetEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_GetIncludeBoundaryMitigation"] = _raise_uninitialized_error
        self.__dict__["_SetIncludeBoundaryMitigation"] = _raise_uninitialized_error
        self.__dict__["_GetUseSunCbFileValues"] = _raise_uninitialized_error
        self.__dict__["_SetUseSunCbFileValues"] = _raise_uninitialized_error
        self.__dict__["_GetSolarRadius"] = _raise_uninitialized_error
        self.__dict__["_SetSolarRadius"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVASRPAeroT20._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVASRPAeroT20 from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVASRPAeroT20 = agcom.GUID(IVASRPAeroT20._uuid)
        vtable_offset_local = IVASRPAeroT20._vtable_offset - 1
        self.__dict__["_GetAtmosAlt"] = IAGFUNCTYPE(pUnk, IID_IVASRPAeroT20, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAtmosAlt"] = IAGFUNCTYPE(pUnk, IID_IVASRPAeroT20, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetShadowModel"] = IAGFUNCTYPE(pUnk, IID_IVASRPAeroT20, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetShadowModel"] = IAGFUNCTYPE(pUnk, IID_IVASRPAeroT20, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVASRPAeroT20, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVASRPAeroT20, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_IVASRPAeroT20, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetIncludeBoundaryMitigation"] = IAGFUNCTYPE(pUnk, IID_IVASRPAeroT20, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIncludeBoundaryMitigation"] = IAGFUNCTYPE(pUnk, IID_IVASRPAeroT20, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseSunCbFileValues"] = IAGFUNCTYPE(pUnk, IID_IVASRPAeroT20, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseSunCbFileValues"] = IAGFUNCTYPE(pUnk, IID_IVASRPAeroT20, vtable_offset_local+11, agcom.VARIANT_BOOL)
        self.__dict__["_GetSolarRadius"] = IAGFUNCTYPE(pUnk, IID_IVASRPAeroT20, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_SetSolarRadius"] = IAGFUNCTYPE(pUnk, IID_IVASRPAeroT20, vtable_offset_local+13, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVASRPAeroT20.__dict__ and type(IVASRPAeroT20.__dict__[attrname]) == property:
            return IVASRPAeroT20.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVASRPAeroT20.")
    
    @property
    def AtmosAlt(self) -> float:
        """The atmospheric altitude for eclipse. A simple model to account for some measure of attenuation that simply increases the shape of the Earth by the defined altitude height, often taken to be 23 km. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosAlt"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosAlt.setter
    def AtmosAlt(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosAlt"](arg_inVal.COM_val))

    @property
    def ShadowModel(self) -> "AgEVAShadowModel":
        """The shadow model type."""
        with agmarshall.AgEnum_arg(AgEVAShadowModel) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetShadowModel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ShadowModel.setter
    def ShadowModel(self, inVal:"AgEVAShadowModel") -> None:
        with agmarshall.AgEnum_arg(AgEVAShadowModel, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetShadowModel"](arg_inVal.COM_val))

    @property
    def SunPosition(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSunPosition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SunPosition.setter
    def SunPosition(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSunPosition"](arg_inVal.COM_val))

    @property
    def EclipsingBodies(self) -> "IVACentralBodyCollection":
        """Other eclipsing bodies."""
        with agmarshall.AgInterface_out_arg() as arg_ppCentralBodyCollection:
            agcls.evaluate_hresult(self.__dict__["_GetEclipsingBodies"](byref(arg_ppCentralBodyCollection.COM_val)))
            return arg_ppCentralBodyCollection.python_val

    @property
    def IncludeBoundaryMitigation(self) -> bool:
        """True if shadow boundary mitigation should be performed; the state of the satellite after crossing a shadow boundary will be corrected for errors possibly caused by the sudden change in SRP which occurred during the integration step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pMitigation:
            agcls.evaluate_hresult(self.__dict__["_GetIncludeBoundaryMitigation"](byref(arg_pMitigation.COM_val)))
            return arg_pMitigation.python_val

    @IncludeBoundaryMitigation.setter
    def IncludeBoundaryMitigation(self, mitigation:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(mitigation) as arg_mitigation:
            agcls.evaluate_hresult(self.__dict__["_SetIncludeBoundaryMitigation"](arg_mitigation.COM_val))

    @property
    def UseSunCbFileValues(self) -> bool:
        """True if solar radius should come from the Sun.cb file."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseSunCbFileValues"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseSunCbFileValues.setter
    def UseSunCbFileValues(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseSunCbFileValues"](arg_inVal.COM_val))

    @property
    def SolarRadius(self) -> float:
        """The solar radius value to use in eclipse calculations.  Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSolarRadius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SolarRadius.setter
    def SolarRadius(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSolarRadius"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{1B712154-4552-4453-B784-5C773A9F88C0}", IVASRPAeroT20)
agcls.AgTypeNameMap["IVASRPAeroT20"] = IVASRPAeroT20

class IVASRPAeroT30(object):
    """Properties for the Aerospace T30 solar radiation pressure model for GPS block IIR."""
    _uuid = "{E29DBFD3-883F-465C-A4D4-D090A83F5EBC}"
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAtmosAlt"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosAlt"] = _raise_uninitialized_error
        self.__dict__["_GetShadowModel"] = _raise_uninitialized_error
        self.__dict__["_SetShadowModel"] = _raise_uninitialized_error
        self.__dict__["_GetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_SetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_GetEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_GetIncludeBoundaryMitigation"] = _raise_uninitialized_error
        self.__dict__["_SetIncludeBoundaryMitigation"] = _raise_uninitialized_error
        self.__dict__["_GetUseSunCbFileValues"] = _raise_uninitialized_error
        self.__dict__["_SetUseSunCbFileValues"] = _raise_uninitialized_error
        self.__dict__["_GetSolarRadius"] = _raise_uninitialized_error
        self.__dict__["_SetSolarRadius"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVASRPAeroT30._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVASRPAeroT30 from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVASRPAeroT30 = agcom.GUID(IVASRPAeroT30._uuid)
        vtable_offset_local = IVASRPAeroT30._vtable_offset - 1
        self.__dict__["_GetAtmosAlt"] = IAGFUNCTYPE(pUnk, IID_IVASRPAeroT30, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAtmosAlt"] = IAGFUNCTYPE(pUnk, IID_IVASRPAeroT30, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetShadowModel"] = IAGFUNCTYPE(pUnk, IID_IVASRPAeroT30, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetShadowModel"] = IAGFUNCTYPE(pUnk, IID_IVASRPAeroT30, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVASRPAeroT30, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVASRPAeroT30, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_IVASRPAeroT30, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetIncludeBoundaryMitigation"] = IAGFUNCTYPE(pUnk, IID_IVASRPAeroT30, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIncludeBoundaryMitigation"] = IAGFUNCTYPE(pUnk, IID_IVASRPAeroT30, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseSunCbFileValues"] = IAGFUNCTYPE(pUnk, IID_IVASRPAeroT30, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseSunCbFileValues"] = IAGFUNCTYPE(pUnk, IID_IVASRPAeroT30, vtable_offset_local+11, agcom.VARIANT_BOOL)
        self.__dict__["_GetSolarRadius"] = IAGFUNCTYPE(pUnk, IID_IVASRPAeroT30, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_SetSolarRadius"] = IAGFUNCTYPE(pUnk, IID_IVASRPAeroT30, vtable_offset_local+13, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVASRPAeroT30.__dict__ and type(IVASRPAeroT30.__dict__[attrname]) == property:
            return IVASRPAeroT30.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVASRPAeroT30.")
    
    @property
    def AtmosAlt(self) -> float:
        """The atmospheric altitude for eclipse. A simple model to account for some measure of attenuation that simply increases the shape of the Earth by the defined altitude height, often taken to be 23 km. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosAlt"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosAlt.setter
    def AtmosAlt(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosAlt"](arg_inVal.COM_val))

    @property
    def ShadowModel(self) -> "AgEVAShadowModel":
        """The shadow model type."""
        with agmarshall.AgEnum_arg(AgEVAShadowModel) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetShadowModel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ShadowModel.setter
    def ShadowModel(self, inVal:"AgEVAShadowModel") -> None:
        with agmarshall.AgEnum_arg(AgEVAShadowModel, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetShadowModel"](arg_inVal.COM_val))

    @property
    def SunPosition(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSunPosition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SunPosition.setter
    def SunPosition(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSunPosition"](arg_inVal.COM_val))

    @property
    def EclipsingBodies(self) -> "IVACentralBodyCollection":
        """Other eclipsing bodies."""
        with agmarshall.AgInterface_out_arg() as arg_ppCentralBodyCollection:
            agcls.evaluate_hresult(self.__dict__["_GetEclipsingBodies"](byref(arg_ppCentralBodyCollection.COM_val)))
            return arg_ppCentralBodyCollection.python_val

    @property
    def IncludeBoundaryMitigation(self) -> bool:
        """True if shadow boundary mitigation should be performed; the state of the satellite after crossing a shadow boundary will be corrected for errors possibly caused by the sudden change in SRP which occurred during the integration step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pMitigation:
            agcls.evaluate_hresult(self.__dict__["_GetIncludeBoundaryMitigation"](byref(arg_pMitigation.COM_val)))
            return arg_pMitigation.python_val

    @IncludeBoundaryMitigation.setter
    def IncludeBoundaryMitigation(self, mitigation:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(mitigation) as arg_mitigation:
            agcls.evaluate_hresult(self.__dict__["_SetIncludeBoundaryMitigation"](arg_mitigation.COM_val))

    @property
    def UseSunCbFileValues(self) -> bool:
        """True if solar radius should come from the Sun.cb file."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseSunCbFileValues"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseSunCbFileValues.setter
    def UseSunCbFileValues(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseSunCbFileValues"](arg_inVal.COM_val))

    @property
    def SolarRadius(self) -> float:
        """The solar radius value to use in eclipse calculations.  Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSolarRadius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SolarRadius.setter
    def SolarRadius(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSolarRadius"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E29DBFD3-883F-465C-A4D4-D090A83F5EBC}", IVASRPAeroT30)
agcls.AgTypeNameMap["IVASRPAeroT30"] = IVASRPAeroT30

class IVASRPGSPM04aIIA(object):
    """Properties for the Bar-Sever GPS Solar Pressure Model 04a for block IIA."""
    _uuid = "{73504326-18B8-40FB-A466-DB8908769B9D}"
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAtmosAlt"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosAlt"] = _raise_uninitialized_error
        self.__dict__["_GetShadowModel"] = _raise_uninitialized_error
        self.__dict__["_SetShadowModel"] = _raise_uninitialized_error
        self.__dict__["_GetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_SetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_GetEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_GetIncludeBoundaryMitigation"] = _raise_uninitialized_error
        self.__dict__["_SetIncludeBoundaryMitigation"] = _raise_uninitialized_error
        self.__dict__["_GetUseSunCbFileValues"] = _raise_uninitialized_error
        self.__dict__["_SetUseSunCbFileValues"] = _raise_uninitialized_error
        self.__dict__["_GetSolarRadius"] = _raise_uninitialized_error
        self.__dict__["_SetSolarRadius"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVASRPGSPM04aIIA._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVASRPGSPM04aIIA from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVASRPGSPM04aIIA = agcom.GUID(IVASRPGSPM04aIIA._uuid)
        vtable_offset_local = IVASRPGSPM04aIIA._vtable_offset - 1
        self.__dict__["_GetAtmosAlt"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aIIA, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAtmosAlt"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aIIA, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetShadowModel"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aIIA, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetShadowModel"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aIIA, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aIIA, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aIIA, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aIIA, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetIncludeBoundaryMitigation"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aIIA, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIncludeBoundaryMitigation"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aIIA, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseSunCbFileValues"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aIIA, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseSunCbFileValues"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aIIA, vtable_offset_local+11, agcom.VARIANT_BOOL)
        self.__dict__["_GetSolarRadius"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aIIA, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_SetSolarRadius"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aIIA, vtable_offset_local+13, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVASRPGSPM04aIIA.__dict__ and type(IVASRPGSPM04aIIA.__dict__[attrname]) == property:
            return IVASRPGSPM04aIIA.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVASRPGSPM04aIIA.")
    
    @property
    def AtmosAlt(self) -> float:
        """The atmospheric altitude for eclipse. A simple model to account for some measure of attenuation that simply increases the shape of the Earth by the defined altitude height, often taken to be 23 km. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosAlt"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosAlt.setter
    def AtmosAlt(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosAlt"](arg_inVal.COM_val))

    @property
    def ShadowModel(self) -> "AgEVAShadowModel":
        """The shadow model type."""
        with agmarshall.AgEnum_arg(AgEVAShadowModel) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetShadowModel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ShadowModel.setter
    def ShadowModel(self, inVal:"AgEVAShadowModel") -> None:
        with agmarshall.AgEnum_arg(AgEVAShadowModel, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetShadowModel"](arg_inVal.COM_val))

    @property
    def SunPosition(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSunPosition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SunPosition.setter
    def SunPosition(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSunPosition"](arg_inVal.COM_val))

    @property
    def EclipsingBodies(self) -> "IVACentralBodyCollection":
        """Other eclipsing bodies."""
        with agmarshall.AgInterface_out_arg() as arg_ppCentralBodyCollection:
            agcls.evaluate_hresult(self.__dict__["_GetEclipsingBodies"](byref(arg_ppCentralBodyCollection.COM_val)))
            return arg_ppCentralBodyCollection.python_val

    @property
    def IncludeBoundaryMitigation(self) -> bool:
        """True if shadow boundary mitigation should be performed; the state of the satellite after crossing a shadow boundary will be corrected for errors possibly caused by the sudden change in SRP which occurred during the integration step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pMitigation:
            agcls.evaluate_hresult(self.__dict__["_GetIncludeBoundaryMitigation"](byref(arg_pMitigation.COM_val)))
            return arg_pMitigation.python_val

    @IncludeBoundaryMitigation.setter
    def IncludeBoundaryMitigation(self, mitigation:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(mitigation) as arg_mitigation:
            agcls.evaluate_hresult(self.__dict__["_SetIncludeBoundaryMitigation"](arg_mitigation.COM_val))

    @property
    def UseSunCbFileValues(self) -> bool:
        """True if solar radius should come from the Sun.cb file."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseSunCbFileValues"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseSunCbFileValues.setter
    def UseSunCbFileValues(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseSunCbFileValues"](arg_inVal.COM_val))

    @property
    def SolarRadius(self) -> float:
        """The solar radius value to use in eclipse calculations.  Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSolarRadius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SolarRadius.setter
    def SolarRadius(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSolarRadius"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{73504326-18B8-40FB-A466-DB8908769B9D}", IVASRPGSPM04aIIA)
agcls.AgTypeNameMap["IVASRPGSPM04aIIA"] = IVASRPGSPM04aIIA

class IVASRPGSPM04aIIR(object):
    """Properties for the Bar-Sever GPS Solar Pressure Model 04a for block IIR."""
    _uuid = "{79FEA80C-9B5F-4FDE-9661-286B1DAFF645}"
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAtmosAlt"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosAlt"] = _raise_uninitialized_error
        self.__dict__["_GetShadowModel"] = _raise_uninitialized_error
        self.__dict__["_SetShadowModel"] = _raise_uninitialized_error
        self.__dict__["_GetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_SetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_GetEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_GetIncludeBoundaryMitigation"] = _raise_uninitialized_error
        self.__dict__["_SetIncludeBoundaryMitigation"] = _raise_uninitialized_error
        self.__dict__["_GetUseSunCbFileValues"] = _raise_uninitialized_error
        self.__dict__["_SetUseSunCbFileValues"] = _raise_uninitialized_error
        self.__dict__["_GetSolarRadius"] = _raise_uninitialized_error
        self.__dict__["_SetSolarRadius"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVASRPGSPM04aIIR._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVASRPGSPM04aIIR from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVASRPGSPM04aIIR = agcom.GUID(IVASRPGSPM04aIIR._uuid)
        vtable_offset_local = IVASRPGSPM04aIIR._vtable_offset - 1
        self.__dict__["_GetAtmosAlt"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aIIR, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAtmosAlt"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aIIR, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetShadowModel"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aIIR, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetShadowModel"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aIIR, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aIIR, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aIIR, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aIIR, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetIncludeBoundaryMitigation"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aIIR, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIncludeBoundaryMitigation"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aIIR, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseSunCbFileValues"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aIIR, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseSunCbFileValues"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aIIR, vtable_offset_local+11, agcom.VARIANT_BOOL)
        self.__dict__["_GetSolarRadius"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aIIR, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_SetSolarRadius"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aIIR, vtable_offset_local+13, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVASRPGSPM04aIIR.__dict__ and type(IVASRPGSPM04aIIR.__dict__[attrname]) == property:
            return IVASRPGSPM04aIIR.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVASRPGSPM04aIIR.")
    
    @property
    def AtmosAlt(self) -> float:
        """The atmospheric altitude for eclipse. A simple model to account for some measure of attenuation that simply increases the shape of the Earth by the defined altitude height, often taken to be 23 km. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosAlt"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosAlt.setter
    def AtmosAlt(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosAlt"](arg_inVal.COM_val))

    @property
    def ShadowModel(self) -> "AgEVAShadowModel":
        """The shadow model type."""
        with agmarshall.AgEnum_arg(AgEVAShadowModel) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetShadowModel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ShadowModel.setter
    def ShadowModel(self, inVal:"AgEVAShadowModel") -> None:
        with agmarshall.AgEnum_arg(AgEVAShadowModel, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetShadowModel"](arg_inVal.COM_val))

    @property
    def SunPosition(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSunPosition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SunPosition.setter
    def SunPosition(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSunPosition"](arg_inVal.COM_val))

    @property
    def EclipsingBodies(self) -> "IVACentralBodyCollection":
        """Other eclipsing bodies."""
        with agmarshall.AgInterface_out_arg() as arg_ppCentralBodyCollection:
            agcls.evaluate_hresult(self.__dict__["_GetEclipsingBodies"](byref(arg_ppCentralBodyCollection.COM_val)))
            return arg_ppCentralBodyCollection.python_val

    @property
    def IncludeBoundaryMitigation(self) -> bool:
        """True if shadow boundary mitigation should be performed; the state of the satellite after crossing a shadow boundary will be corrected for errors possibly caused by the sudden change in SRP which occurred during the integration step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pMitigation:
            agcls.evaluate_hresult(self.__dict__["_GetIncludeBoundaryMitigation"](byref(arg_pMitigation.COM_val)))
            return arg_pMitigation.python_val

    @IncludeBoundaryMitigation.setter
    def IncludeBoundaryMitigation(self, mitigation:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(mitigation) as arg_mitigation:
            agcls.evaluate_hresult(self.__dict__["_SetIncludeBoundaryMitigation"](arg_mitigation.COM_val))

    @property
    def UseSunCbFileValues(self) -> bool:
        """True if solar radius should come from the Sun.cb file."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseSunCbFileValues"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseSunCbFileValues.setter
    def UseSunCbFileValues(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseSunCbFileValues"](arg_inVal.COM_val))

    @property
    def SolarRadius(self) -> float:
        """The solar radius value to use in eclipse calculations.  Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSolarRadius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SolarRadius.setter
    def SolarRadius(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSolarRadius"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{79FEA80C-9B5F-4FDE-9661-286B1DAFF645}", IVASRPGSPM04aIIR)
agcls.AgTypeNameMap["IVASRPGSPM04aIIR"] = IVASRPGSPM04aIIR

class IVASRPGSPM04aeIIA(object):
    """Properties for the Bar-Sever GPS Solar Pressure Model 04ae for block IIA."""
    _uuid = "{3F99DF3B-1BC5-40F2-826D-751DCE4BB77C}"
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAtmosAlt"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosAlt"] = _raise_uninitialized_error
        self.__dict__["_GetShadowModel"] = _raise_uninitialized_error
        self.__dict__["_SetShadowModel"] = _raise_uninitialized_error
        self.__dict__["_GetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_SetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_GetEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_GetIncludeBoundaryMitigation"] = _raise_uninitialized_error
        self.__dict__["_SetIncludeBoundaryMitigation"] = _raise_uninitialized_error
        self.__dict__["_GetUseSunCbFileValues"] = _raise_uninitialized_error
        self.__dict__["_SetUseSunCbFileValues"] = _raise_uninitialized_error
        self.__dict__["_GetSolarRadius"] = _raise_uninitialized_error
        self.__dict__["_SetSolarRadius"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVASRPGSPM04aeIIA._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVASRPGSPM04aeIIA from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVASRPGSPM04aeIIA = agcom.GUID(IVASRPGSPM04aeIIA._uuid)
        vtable_offset_local = IVASRPGSPM04aeIIA._vtable_offset - 1
        self.__dict__["_GetAtmosAlt"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aeIIA, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAtmosAlt"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aeIIA, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetShadowModel"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aeIIA, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetShadowModel"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aeIIA, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aeIIA, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aeIIA, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aeIIA, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetIncludeBoundaryMitigation"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aeIIA, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIncludeBoundaryMitigation"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aeIIA, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseSunCbFileValues"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aeIIA, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseSunCbFileValues"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aeIIA, vtable_offset_local+11, agcom.VARIANT_BOOL)
        self.__dict__["_GetSolarRadius"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aeIIA, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_SetSolarRadius"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aeIIA, vtable_offset_local+13, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVASRPGSPM04aeIIA.__dict__ and type(IVASRPGSPM04aeIIA.__dict__[attrname]) == property:
            return IVASRPGSPM04aeIIA.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVASRPGSPM04aeIIA.")
    
    @property
    def AtmosAlt(self) -> float:
        """The atmospheric altitude for eclipse. A simple model to account for some measure of attenuation that simply increases the shape of the Earth by the defined altitude height, often taken to be 23 km. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosAlt"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosAlt.setter
    def AtmosAlt(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosAlt"](arg_inVal.COM_val))

    @property
    def ShadowModel(self) -> "AgEVAShadowModel":
        """The shadow model type."""
        with agmarshall.AgEnum_arg(AgEVAShadowModel) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetShadowModel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ShadowModel.setter
    def ShadowModel(self, inVal:"AgEVAShadowModel") -> None:
        with agmarshall.AgEnum_arg(AgEVAShadowModel, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetShadowModel"](arg_inVal.COM_val))

    @property
    def SunPosition(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSunPosition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SunPosition.setter
    def SunPosition(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSunPosition"](arg_inVal.COM_val))

    @property
    def EclipsingBodies(self) -> "IVACentralBodyCollection":
        """Other eclipsing bodies."""
        with agmarshall.AgInterface_out_arg() as arg_ppCentralBodyCollection:
            agcls.evaluate_hresult(self.__dict__["_GetEclipsingBodies"](byref(arg_ppCentralBodyCollection.COM_val)))
            return arg_ppCentralBodyCollection.python_val

    @property
    def IncludeBoundaryMitigation(self) -> bool:
        """True if shadow boundary mitigation should be performed; the state of the satellite after crossing a shadow boundary will be corrected for errors possibly caused by the sudden change in SRP which occurred during the integration step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pMitigation:
            agcls.evaluate_hresult(self.__dict__["_GetIncludeBoundaryMitigation"](byref(arg_pMitigation.COM_val)))
            return arg_pMitigation.python_val

    @IncludeBoundaryMitigation.setter
    def IncludeBoundaryMitigation(self, mitigation:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(mitigation) as arg_mitigation:
            agcls.evaluate_hresult(self.__dict__["_SetIncludeBoundaryMitigation"](arg_mitigation.COM_val))

    @property
    def UseSunCbFileValues(self) -> bool:
        """True if solar radius should come from the Sun.cb file."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseSunCbFileValues"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseSunCbFileValues.setter
    def UseSunCbFileValues(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseSunCbFileValues"](arg_inVal.COM_val))

    @property
    def SolarRadius(self) -> float:
        """The solar radius value to use in eclipse calculations.  Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSolarRadius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SolarRadius.setter
    def SolarRadius(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSolarRadius"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3F99DF3B-1BC5-40F2-826D-751DCE4BB77C}", IVASRPGSPM04aeIIA)
agcls.AgTypeNameMap["IVASRPGSPM04aeIIA"] = IVASRPGSPM04aeIIA

class IVASRPGSPM04aeIIR(object):
    """Properties for the Bar-Sever GPS Solar Pressure Model 04ae for block IIR."""
    _uuid = "{8A1CAF39-9680-4405-942D-A86D279EAE24}"
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAtmosAlt"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosAlt"] = _raise_uninitialized_error
        self.__dict__["_GetShadowModel"] = _raise_uninitialized_error
        self.__dict__["_SetShadowModel"] = _raise_uninitialized_error
        self.__dict__["_GetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_SetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_GetEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_GetIncludeBoundaryMitigation"] = _raise_uninitialized_error
        self.__dict__["_SetIncludeBoundaryMitigation"] = _raise_uninitialized_error
        self.__dict__["_GetUseSunCbFileValues"] = _raise_uninitialized_error
        self.__dict__["_SetUseSunCbFileValues"] = _raise_uninitialized_error
        self.__dict__["_GetSolarRadius"] = _raise_uninitialized_error
        self.__dict__["_SetSolarRadius"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVASRPGSPM04aeIIR._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVASRPGSPM04aeIIR from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVASRPGSPM04aeIIR = agcom.GUID(IVASRPGSPM04aeIIR._uuid)
        vtable_offset_local = IVASRPGSPM04aeIIR._vtable_offset - 1
        self.__dict__["_GetAtmosAlt"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aeIIR, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAtmosAlt"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aeIIR, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetShadowModel"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aeIIR, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetShadowModel"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aeIIR, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aeIIR, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aeIIR, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aeIIR, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetIncludeBoundaryMitigation"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aeIIR, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIncludeBoundaryMitigation"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aeIIR, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseSunCbFileValues"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aeIIR, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseSunCbFileValues"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aeIIR, vtable_offset_local+11, agcom.VARIANT_BOOL)
        self.__dict__["_GetSolarRadius"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aeIIR, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_SetSolarRadius"] = IAGFUNCTYPE(pUnk, IID_IVASRPGSPM04aeIIR, vtable_offset_local+13, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVASRPGSPM04aeIIR.__dict__ and type(IVASRPGSPM04aeIIR.__dict__[attrname]) == property:
            return IVASRPGSPM04aeIIR.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVASRPGSPM04aeIIR.")
    
    @property
    def AtmosAlt(self) -> float:
        """The atmospheric altitude for eclipse. A simple model to account for some measure of attenuation that simply increases the shape of the Earth by the defined altitude height, often taken to be 23 km. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosAlt"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosAlt.setter
    def AtmosAlt(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosAlt"](arg_inVal.COM_val))

    @property
    def ShadowModel(self) -> "AgEVAShadowModel":
        """The shadow model type."""
        with agmarshall.AgEnum_arg(AgEVAShadowModel) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetShadowModel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ShadowModel.setter
    def ShadowModel(self, inVal:"AgEVAShadowModel") -> None:
        with agmarshall.AgEnum_arg(AgEVAShadowModel, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetShadowModel"](arg_inVal.COM_val))

    @property
    def SunPosition(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSunPosition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SunPosition.setter
    def SunPosition(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSunPosition"](arg_inVal.COM_val))

    @property
    def EclipsingBodies(self) -> "IVACentralBodyCollection":
        """Other eclipsing bodies."""
        with agmarshall.AgInterface_out_arg() as arg_ppCentralBodyCollection:
            agcls.evaluate_hresult(self.__dict__["_GetEclipsingBodies"](byref(arg_ppCentralBodyCollection.COM_val)))
            return arg_ppCentralBodyCollection.python_val

    @property
    def IncludeBoundaryMitigation(self) -> bool:
        """True if shadow boundary mitigation should be performed; the state of the satellite after crossing a shadow boundary will be corrected for errors possibly caused by the sudden change in SRP which occurred during the integration step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pMitigation:
            agcls.evaluate_hresult(self.__dict__["_GetIncludeBoundaryMitigation"](byref(arg_pMitigation.COM_val)))
            return arg_pMitigation.python_val

    @IncludeBoundaryMitigation.setter
    def IncludeBoundaryMitigation(self, mitigation:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(mitigation) as arg_mitigation:
            agcls.evaluate_hresult(self.__dict__["_SetIncludeBoundaryMitigation"](arg_mitigation.COM_val))

    @property
    def UseSunCbFileValues(self) -> bool:
        """True if solar radius should come from the Sun.cb file."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseSunCbFileValues"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseSunCbFileValues.setter
    def UseSunCbFileValues(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseSunCbFileValues"](arg_inVal.COM_val))

    @property
    def SolarRadius(self) -> float:
        """The solar radius value to use in eclipse calculations.  Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSolarRadius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SolarRadius.setter
    def SolarRadius(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSolarRadius"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{8A1CAF39-9680-4405-942D-A86D279EAE24}", IVASRPGSPM04aeIIR)
agcls.AgTypeNameMap["IVASRPGSPM04aeIIR"] = IVASRPGSPM04aeIIR

class IVASRPSpherical(object):
    """Properties for the Spherical SRP model; assumes a spherical spacecraft. The equation used by STK is described in the Solar Radiation technical note."""
    _uuid = "{B8F7E804-16B0-447F-A75A-B75DF05287B0}"
    _num_methods = 19
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAtmosAlt"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosAlt"] = _raise_uninitialized_error
        self.__dict__["_GetShadowModel"] = _raise_uninitialized_error
        self.__dict__["_SetShadowModel"] = _raise_uninitialized_error
        self.__dict__["_GetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_SetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_GetEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_GetMeanFlux"] = _raise_uninitialized_error
        self.__dict__["_SetMeanFlux"] = _raise_uninitialized_error
        self.__dict__["_GetLuminosity"] = _raise_uninitialized_error
        self.__dict__["_SetLuminosity"] = _raise_uninitialized_error
        self.__dict__["_GetSolarForceMethod"] = _raise_uninitialized_error
        self.__dict__["_SetSolarForceMethod"] = _raise_uninitialized_error
        self.__dict__["_GetIncludeBoundaryMitigation"] = _raise_uninitialized_error
        self.__dict__["_SetIncludeBoundaryMitigation"] = _raise_uninitialized_error
        self.__dict__["_GetUseSunCbFileValues"] = _raise_uninitialized_error
        self.__dict__["_SetUseSunCbFileValues"] = _raise_uninitialized_error
        self.__dict__["_GetSolarRadius"] = _raise_uninitialized_error
        self.__dict__["_SetSolarRadius"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVASRPSpherical._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVASRPSpherical from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVASRPSpherical = agcom.GUID(IVASRPSpherical._uuid)
        vtable_offset_local = IVASRPSpherical._vtable_offset - 1
        self.__dict__["_GetAtmosAlt"] = IAGFUNCTYPE(pUnk, IID_IVASRPSpherical, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAtmosAlt"] = IAGFUNCTYPE(pUnk, IID_IVASRPSpherical, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetShadowModel"] = IAGFUNCTYPE(pUnk, IID_IVASRPSpherical, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetShadowModel"] = IAGFUNCTYPE(pUnk, IID_IVASRPSpherical, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVASRPSpherical, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVASRPSpherical, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_IVASRPSpherical, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetMeanFlux"] = IAGFUNCTYPE(pUnk, IID_IVASRPSpherical, vtable_offset_local+8, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMeanFlux"] = IAGFUNCTYPE(pUnk, IID_IVASRPSpherical, vtable_offset_local+9, agcom.DOUBLE)
        self.__dict__["_GetLuminosity"] = IAGFUNCTYPE(pUnk, IID_IVASRPSpherical, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_SetLuminosity"] = IAGFUNCTYPE(pUnk, IID_IVASRPSpherical, vtable_offset_local+11, agcom.DOUBLE)
        self.__dict__["_GetSolarForceMethod"] = IAGFUNCTYPE(pUnk, IID_IVASRPSpherical, vtable_offset_local+12, POINTER(agcom.LONG))
        self.__dict__["_SetSolarForceMethod"] = IAGFUNCTYPE(pUnk, IID_IVASRPSpherical, vtable_offset_local+13, agcom.LONG)
        self.__dict__["_GetIncludeBoundaryMitigation"] = IAGFUNCTYPE(pUnk, IID_IVASRPSpherical, vtable_offset_local+14, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIncludeBoundaryMitigation"] = IAGFUNCTYPE(pUnk, IID_IVASRPSpherical, vtable_offset_local+15, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseSunCbFileValues"] = IAGFUNCTYPE(pUnk, IID_IVASRPSpherical, vtable_offset_local+16, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseSunCbFileValues"] = IAGFUNCTYPE(pUnk, IID_IVASRPSpherical, vtable_offset_local+17, agcom.VARIANT_BOOL)
        self.__dict__["_GetSolarRadius"] = IAGFUNCTYPE(pUnk, IID_IVASRPSpherical, vtable_offset_local+18, POINTER(agcom.DOUBLE))
        self.__dict__["_SetSolarRadius"] = IAGFUNCTYPE(pUnk, IID_IVASRPSpherical, vtable_offset_local+19, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVASRPSpherical.__dict__ and type(IVASRPSpherical.__dict__[attrname]) == property:
            return IVASRPSpherical.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVASRPSpherical.")
    
    @property
    def AtmosAlt(self) -> float:
        """The atmospheric altitude for eclipse. A simple model to account for some measure of attenuation that simply increases the shape of the Earth by the defined altitude height, often taken to be 23 km. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosAlt"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosAlt.setter
    def AtmosAlt(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosAlt"](arg_inVal.COM_val))

    @property
    def ShadowModel(self) -> "AgEVAShadowModel":
        """The shadow model type."""
        with agmarshall.AgEnum_arg(AgEVAShadowModel) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetShadowModel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ShadowModel.setter
    def ShadowModel(self, inVal:"AgEVAShadowModel") -> None:
        with agmarshall.AgEnum_arg(AgEVAShadowModel, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetShadowModel"](arg_inVal.COM_val))

    @property
    def SunPosition(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSunPosition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SunPosition.setter
    def SunPosition(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSunPosition"](arg_inVal.COM_val))

    @property
    def EclipsingBodies(self) -> "IVACentralBodyCollection":
        """Other eclipsing bodies."""
        with agmarshall.AgInterface_out_arg() as arg_ppCentralBodyCollection:
            agcls.evaluate_hresult(self.__dict__["_GetEclipsingBodies"](byref(arg_ppCentralBodyCollection.COM_val)))
            return arg_ppCentralBodyCollection.python_val

    @property
    def MeanFlux(self) -> float:
        """The mean solar flux at 1 au (W/m^2)."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMeanFlux"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MeanFlux.setter
    def MeanFlux(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMeanFlux"](arg_inVal.COM_val))

    @property
    def Luminosity(self) -> float:
        """The luminosity of sun. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLuminosity"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Luminosity.setter
    def Luminosity(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetLuminosity"](arg_inVal.COM_val))

    @property
    def SolarForceMethod(self) -> "AgEVASolarForceMethod":
        """The solar force method"""
        with agmarshall.AgEnum_arg(AgEVASolarForceMethod) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSolarForceMethod"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SolarForceMethod.setter
    def SolarForceMethod(self, inVal:"AgEVASolarForceMethod") -> None:
        with agmarshall.AgEnum_arg(AgEVASolarForceMethod, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSolarForceMethod"](arg_inVal.COM_val))

    @property
    def IncludeBoundaryMitigation(self) -> bool:
        """True if shadow boundary mitigation should be performed; the state of the satellite after crossing a shadow boundary will be corrected for errors possibly caused by the sudden change in SRP which occurred during the integration step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pMitigation:
            agcls.evaluate_hresult(self.__dict__["_GetIncludeBoundaryMitigation"](byref(arg_pMitigation.COM_val)))
            return arg_pMitigation.python_val

    @IncludeBoundaryMitigation.setter
    def IncludeBoundaryMitigation(self, mitigation:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(mitigation) as arg_mitigation:
            agcls.evaluate_hresult(self.__dict__["_SetIncludeBoundaryMitigation"](arg_mitigation.COM_val))

    @property
    def UseSunCbFileValues(self) -> bool:
        """True if solar values should come from the Sun.cb file."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseSunCbFileValues"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseSunCbFileValues.setter
    def UseSunCbFileValues(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseSunCbFileValues"](arg_inVal.COM_val))

    @property
    def SolarRadius(self) -> float:
        """The solar radius value to use in eclipse calculations.  Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSolarRadius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SolarRadius.setter
    def SolarRadius(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSolarRadius"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{B8F7E804-16B0-447F-A75A-B75DF05287B0}", IVASRPSpherical)
agcls.AgTypeNameMap["IVASRPSpherical"] = IVASRPSpherical

class IVASRPNPlate(object):
    """Properties for the N-plate SRP model."""
    _uuid = "{5DE80C27-861E-4596-9461-414741A793D1}"
    _num_methods = 21
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAtmosAlt"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosAlt"] = _raise_uninitialized_error
        self.__dict__["_GetShadowModel"] = _raise_uninitialized_error
        self.__dict__["_SetShadowModel"] = _raise_uninitialized_error
        self.__dict__["_GetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_SetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_GetEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_GetMeanFlux"] = _raise_uninitialized_error
        self.__dict__["_SetMeanFlux"] = _raise_uninitialized_error
        self.__dict__["_GetLuminosity"] = _raise_uninitialized_error
        self.__dict__["_SetLuminosity"] = _raise_uninitialized_error
        self.__dict__["_GetSolarForceMethod"] = _raise_uninitialized_error
        self.__dict__["_SetSolarForceMethod"] = _raise_uninitialized_error
        self.__dict__["_GetIncludeBoundaryMitigation"] = _raise_uninitialized_error
        self.__dict__["_SetIncludeBoundaryMitigation"] = _raise_uninitialized_error
        self.__dict__["_GetUseSunCbFileValues"] = _raise_uninitialized_error
        self.__dict__["_SetUseSunCbFileValues"] = _raise_uninitialized_error
        self.__dict__["_GetSolarRadius"] = _raise_uninitialized_error
        self.__dict__["_SetSolarRadius"] = _raise_uninitialized_error
        self.__dict__["_GetNPlateDefinitionFile"] = _raise_uninitialized_error
        self.__dict__["_SetNPlateDefinitionFile"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVASRPNPlate._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVASRPNPlate from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVASRPNPlate = agcom.GUID(IVASRPNPlate._uuid)
        vtable_offset_local = IVASRPNPlate._vtable_offset - 1
        self.__dict__["_GetAtmosAlt"] = IAGFUNCTYPE(pUnk, IID_IVASRPNPlate, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAtmosAlt"] = IAGFUNCTYPE(pUnk, IID_IVASRPNPlate, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetShadowModel"] = IAGFUNCTYPE(pUnk, IID_IVASRPNPlate, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetShadowModel"] = IAGFUNCTYPE(pUnk, IID_IVASRPNPlate, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVASRPNPlate, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVASRPNPlate, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_IVASRPNPlate, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetMeanFlux"] = IAGFUNCTYPE(pUnk, IID_IVASRPNPlate, vtable_offset_local+8, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMeanFlux"] = IAGFUNCTYPE(pUnk, IID_IVASRPNPlate, vtable_offset_local+9, agcom.DOUBLE)
        self.__dict__["_GetLuminosity"] = IAGFUNCTYPE(pUnk, IID_IVASRPNPlate, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_SetLuminosity"] = IAGFUNCTYPE(pUnk, IID_IVASRPNPlate, vtable_offset_local+11, agcom.DOUBLE)
        self.__dict__["_GetSolarForceMethod"] = IAGFUNCTYPE(pUnk, IID_IVASRPNPlate, vtable_offset_local+12, POINTER(agcom.LONG))
        self.__dict__["_SetSolarForceMethod"] = IAGFUNCTYPE(pUnk, IID_IVASRPNPlate, vtable_offset_local+13, agcom.LONG)
        self.__dict__["_GetIncludeBoundaryMitigation"] = IAGFUNCTYPE(pUnk, IID_IVASRPNPlate, vtable_offset_local+14, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIncludeBoundaryMitigation"] = IAGFUNCTYPE(pUnk, IID_IVASRPNPlate, vtable_offset_local+15, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseSunCbFileValues"] = IAGFUNCTYPE(pUnk, IID_IVASRPNPlate, vtable_offset_local+16, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseSunCbFileValues"] = IAGFUNCTYPE(pUnk, IID_IVASRPNPlate, vtable_offset_local+17, agcom.VARIANT_BOOL)
        self.__dict__["_GetSolarRadius"] = IAGFUNCTYPE(pUnk, IID_IVASRPNPlate, vtable_offset_local+18, POINTER(agcom.DOUBLE))
        self.__dict__["_SetSolarRadius"] = IAGFUNCTYPE(pUnk, IID_IVASRPNPlate, vtable_offset_local+19, agcom.DOUBLE)
        self.__dict__["_GetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVASRPNPlate, vtable_offset_local+20, POINTER(agcom.BSTR))
        self.__dict__["_SetNPlateDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVASRPNPlate, vtable_offset_local+21, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVASRPNPlate.__dict__ and type(IVASRPNPlate.__dict__[attrname]) == property:
            return IVASRPNPlate.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVASRPNPlate.")
    
    @property
    def AtmosAlt(self) -> float:
        """The atmospheric altitude for eclipse. A simple model to account for some measure of attenuation that simply increases the shape of the Earth by the defined altitude height, often taken to be 23 km. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosAlt"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosAlt.setter
    def AtmosAlt(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosAlt"](arg_inVal.COM_val))

    @property
    def ShadowModel(self) -> "AgEVAShadowModel":
        """The shadow model type."""
        with agmarshall.AgEnum_arg(AgEVAShadowModel) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetShadowModel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ShadowModel.setter
    def ShadowModel(self, inVal:"AgEVAShadowModel") -> None:
        with agmarshall.AgEnum_arg(AgEVAShadowModel, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetShadowModel"](arg_inVal.COM_val))

    @property
    def SunPosition(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSunPosition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SunPosition.setter
    def SunPosition(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSunPosition"](arg_inVal.COM_val))

    @property
    def EclipsingBodies(self) -> "IVACentralBodyCollection":
        """Other eclipsing bodies."""
        with agmarshall.AgInterface_out_arg() as arg_ppCentralBodyCollection:
            agcls.evaluate_hresult(self.__dict__["_GetEclipsingBodies"](byref(arg_ppCentralBodyCollection.COM_val)))
            return arg_ppCentralBodyCollection.python_val

    @property
    def MeanFlux(self) -> float:
        """The mean solar flux at 1 au (W/m^2)."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMeanFlux"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MeanFlux.setter
    def MeanFlux(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMeanFlux"](arg_inVal.COM_val))

    @property
    def Luminosity(self) -> float:
        """The luminosity of sun. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLuminosity"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Luminosity.setter
    def Luminosity(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetLuminosity"](arg_inVal.COM_val))

    @property
    def SolarForceMethod(self) -> "AgEVASolarForceMethod":
        """The solar force method"""
        with agmarshall.AgEnum_arg(AgEVASolarForceMethod) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSolarForceMethod"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SolarForceMethod.setter
    def SolarForceMethod(self, inVal:"AgEVASolarForceMethod") -> None:
        with agmarshall.AgEnum_arg(AgEVASolarForceMethod, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSolarForceMethod"](arg_inVal.COM_val))

    @property
    def IncludeBoundaryMitigation(self) -> bool:
        """True if shadow boundary mitigation should be performed; the state of the satellite after crossing a shadow boundary will be corrected for errors possibly caused by the sudden change in SRP which occurred during the integration step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pMitigation:
            agcls.evaluate_hresult(self.__dict__["_GetIncludeBoundaryMitigation"](byref(arg_pMitigation.COM_val)))
            return arg_pMitigation.python_val

    @IncludeBoundaryMitigation.setter
    def IncludeBoundaryMitigation(self, mitigation:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(mitigation) as arg_mitigation:
            agcls.evaluate_hresult(self.__dict__["_SetIncludeBoundaryMitigation"](arg_mitigation.COM_val))

    @property
    def UseSunCbFileValues(self) -> bool:
        """True if solar values should come from the Sun.cb file."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseSunCbFileValues"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseSunCbFileValues.setter
    def UseSunCbFileValues(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseSunCbFileValues"](arg_inVal.COM_val))

    @property
    def SolarRadius(self) -> float:
        """The solar radius value to use in eclipse calculations.  Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSolarRadius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SolarRadius.setter
    def SolarRadius(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSolarRadius"](arg_inVal.COM_val))

    @property
    def NPlateDefinitionFile(self) -> str:
        """Full path of NPlate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNPlateDefinitionFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @NPlateDefinitionFile.setter
    def NPlateDefinitionFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetNPlateDefinitionFile"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{5DE80C27-861E-4596-9461-414741A793D1}", IVASRPNPlate)
agcls.AgTypeNameMap["IVASRPNPlate"] = IVASRPNPlate

class IVASRPTabAreaVec(object):
    """Properties for the tabulated area vector SRP model."""
    _uuid = "{796EAE38-5298-4315-AA74-29C810F2E3FE}"
    _num_methods = 23
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAtmosAlt"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosAlt"] = _raise_uninitialized_error
        self.__dict__["_GetShadowModel"] = _raise_uninitialized_error
        self.__dict__["_SetShadowModel"] = _raise_uninitialized_error
        self.__dict__["_GetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_SetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_GetEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_GetMeanFlux"] = _raise_uninitialized_error
        self.__dict__["_SetMeanFlux"] = _raise_uninitialized_error
        self.__dict__["_GetLuminosity"] = _raise_uninitialized_error
        self.__dict__["_SetLuminosity"] = _raise_uninitialized_error
        self.__dict__["_GetSolarForceMethod"] = _raise_uninitialized_error
        self.__dict__["_SetSolarForceMethod"] = _raise_uninitialized_error
        self.__dict__["_GetIncludeBoundaryMitigation"] = _raise_uninitialized_error
        self.__dict__["_SetIncludeBoundaryMitigation"] = _raise_uninitialized_error
        self.__dict__["_GetUseSunCbFileValues"] = _raise_uninitialized_error
        self.__dict__["_SetUseSunCbFileValues"] = _raise_uninitialized_error
        self.__dict__["_GetSolarRadius"] = _raise_uninitialized_error
        self.__dict__["_SetSolarRadius"] = _raise_uninitialized_error
        self.__dict__["_GetTabAreaVectorDefinitionFile"] = _raise_uninitialized_error
        self.__dict__["_SetTabAreaVectorDefinitionFile"] = _raise_uninitialized_error
        self.__dict__["_GetInterpolationMethod"] = _raise_uninitialized_error
        self.__dict__["_SetInterpolationMethod"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVASRPTabAreaVec._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVASRPTabAreaVec from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVASRPTabAreaVec = agcom.GUID(IVASRPTabAreaVec._uuid)
        vtable_offset_local = IVASRPTabAreaVec._vtable_offset - 1
        self.__dict__["_GetAtmosAlt"] = IAGFUNCTYPE(pUnk, IID_IVASRPTabAreaVec, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAtmosAlt"] = IAGFUNCTYPE(pUnk, IID_IVASRPTabAreaVec, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetShadowModel"] = IAGFUNCTYPE(pUnk, IID_IVASRPTabAreaVec, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetShadowModel"] = IAGFUNCTYPE(pUnk, IID_IVASRPTabAreaVec, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVASRPTabAreaVec, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVASRPTabAreaVec, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_IVASRPTabAreaVec, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetMeanFlux"] = IAGFUNCTYPE(pUnk, IID_IVASRPTabAreaVec, vtable_offset_local+8, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMeanFlux"] = IAGFUNCTYPE(pUnk, IID_IVASRPTabAreaVec, vtable_offset_local+9, agcom.DOUBLE)
        self.__dict__["_GetLuminosity"] = IAGFUNCTYPE(pUnk, IID_IVASRPTabAreaVec, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_SetLuminosity"] = IAGFUNCTYPE(pUnk, IID_IVASRPTabAreaVec, vtable_offset_local+11, agcom.DOUBLE)
        self.__dict__["_GetSolarForceMethod"] = IAGFUNCTYPE(pUnk, IID_IVASRPTabAreaVec, vtable_offset_local+12, POINTER(agcom.LONG))
        self.__dict__["_SetSolarForceMethod"] = IAGFUNCTYPE(pUnk, IID_IVASRPTabAreaVec, vtable_offset_local+13, agcom.LONG)
        self.__dict__["_GetIncludeBoundaryMitigation"] = IAGFUNCTYPE(pUnk, IID_IVASRPTabAreaVec, vtable_offset_local+14, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIncludeBoundaryMitigation"] = IAGFUNCTYPE(pUnk, IID_IVASRPTabAreaVec, vtable_offset_local+15, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseSunCbFileValues"] = IAGFUNCTYPE(pUnk, IID_IVASRPTabAreaVec, vtable_offset_local+16, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseSunCbFileValues"] = IAGFUNCTYPE(pUnk, IID_IVASRPTabAreaVec, vtable_offset_local+17, agcom.VARIANT_BOOL)
        self.__dict__["_GetSolarRadius"] = IAGFUNCTYPE(pUnk, IID_IVASRPTabAreaVec, vtable_offset_local+18, POINTER(agcom.DOUBLE))
        self.__dict__["_SetSolarRadius"] = IAGFUNCTYPE(pUnk, IID_IVASRPTabAreaVec, vtable_offset_local+19, agcom.DOUBLE)
        self.__dict__["_GetTabAreaVectorDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVASRPTabAreaVec, vtable_offset_local+20, POINTER(agcom.BSTR))
        self.__dict__["_SetTabAreaVectorDefinitionFile"] = IAGFUNCTYPE(pUnk, IID_IVASRPTabAreaVec, vtable_offset_local+21, agcom.BSTR)
        self.__dict__["_GetInterpolationMethod"] = IAGFUNCTYPE(pUnk, IID_IVASRPTabAreaVec, vtable_offset_local+22, POINTER(agcom.LONG))
        self.__dict__["_SetInterpolationMethod"] = IAGFUNCTYPE(pUnk, IID_IVASRPTabAreaVec, vtable_offset_local+23, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVASRPTabAreaVec.__dict__ and type(IVASRPTabAreaVec.__dict__[attrname]) == property:
            return IVASRPTabAreaVec.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVASRPTabAreaVec.")
    
    @property
    def AtmosAlt(self) -> float:
        """The atmospheric altitude for eclipse. A simple model to account for some measure of attenuation that simply increases the shape of the Earth by the defined altitude height, often taken to be 23 km. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosAlt"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosAlt.setter
    def AtmosAlt(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosAlt"](arg_inVal.COM_val))

    @property
    def ShadowModel(self) -> "AgEVAShadowModel":
        """The shadow model type."""
        with agmarshall.AgEnum_arg(AgEVAShadowModel) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetShadowModel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ShadowModel.setter
    def ShadowModel(self, inVal:"AgEVAShadowModel") -> None:
        with agmarshall.AgEnum_arg(AgEVAShadowModel, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetShadowModel"](arg_inVal.COM_val))

    @property
    def SunPosition(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSunPosition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SunPosition.setter
    def SunPosition(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSunPosition"](arg_inVal.COM_val))

    @property
    def EclipsingBodies(self) -> "IVACentralBodyCollection":
        """Other eclipsing bodies."""
        with agmarshall.AgInterface_out_arg() as arg_ppCentralBodyCollection:
            agcls.evaluate_hresult(self.__dict__["_GetEclipsingBodies"](byref(arg_ppCentralBodyCollection.COM_val)))
            return arg_ppCentralBodyCollection.python_val

    @property
    def MeanFlux(self) -> float:
        """The mean solar flux at 1 au (W/m^2)."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMeanFlux"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MeanFlux.setter
    def MeanFlux(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMeanFlux"](arg_inVal.COM_val))

    @property
    def Luminosity(self) -> float:
        """The luminosity of sun. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLuminosity"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Luminosity.setter
    def Luminosity(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetLuminosity"](arg_inVal.COM_val))

    @property
    def SolarForceMethod(self) -> "AgEVASolarForceMethod":
        """The solar force method"""
        with agmarshall.AgEnum_arg(AgEVASolarForceMethod) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSolarForceMethod"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SolarForceMethod.setter
    def SolarForceMethod(self, inVal:"AgEVASolarForceMethod") -> None:
        with agmarshall.AgEnum_arg(AgEVASolarForceMethod, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSolarForceMethod"](arg_inVal.COM_val))

    @property
    def IncludeBoundaryMitigation(self) -> bool:
        """True if shadow boundary mitigation should be performed; the state of the satellite after crossing a shadow boundary will be corrected for errors possibly caused by the sudden change in SRP which occurred during the integration step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pMitigation:
            agcls.evaluate_hresult(self.__dict__["_GetIncludeBoundaryMitigation"](byref(arg_pMitigation.COM_val)))
            return arg_pMitigation.python_val

    @IncludeBoundaryMitigation.setter
    def IncludeBoundaryMitigation(self, mitigation:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(mitigation) as arg_mitigation:
            agcls.evaluate_hresult(self.__dict__["_SetIncludeBoundaryMitigation"](arg_mitigation.COM_val))

    @property
    def UseSunCbFileValues(self) -> bool:
        """True if solar values should come from the Sun.cb file."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseSunCbFileValues"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseSunCbFileValues.setter
    def UseSunCbFileValues(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseSunCbFileValues"](arg_inVal.COM_val))

    @property
    def SolarRadius(self) -> float:
        """The solar radius value to use in eclipse calculations.  Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSolarRadius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SolarRadius.setter
    def SolarRadius(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSolarRadius"](arg_inVal.COM_val))

    @property
    def TabAreaVectorDefinitionFile(self) -> str:
        """Full path of the tabulated area vector definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTabAreaVectorDefinitionFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @TabAreaVectorDefinitionFile.setter
    def TabAreaVectorDefinitionFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetTabAreaVectorDefinitionFile"](arg_inVal.COM_val))

    @property
    def InterpolationMethod(self) -> "AgEVATabVecInterpMethod":
        """The file interpolation method."""
        with agmarshall.AgEnum_arg(AgEVATabVecInterpMethod) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetInterpolationMethod"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @InterpolationMethod.setter
    def InterpolationMethod(self, inVal:"AgEVATabVecInterpMethod") -> None:
        with agmarshall.AgEnum_arg(AgEVATabVecInterpMethod, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetInterpolationMethod"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{796EAE38-5298-4315-AA74-29C810F2E3FE}", IVASRPTabAreaVec)
agcls.AgTypeNameMap["IVASRPTabAreaVec"] = IVASRPTabAreaVec

class IVASRPVariableArea(object):
    """Properties for the Variable Area SRP model."""
    _uuid = "{4124EBC1-ABC6-4933-84D2-0F1232D8B630}"
    _num_methods = 21
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetAtmosAlt"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosAlt"] = _raise_uninitialized_error
        self.__dict__["_GetShadowModel"] = _raise_uninitialized_error
        self.__dict__["_SetShadowModel"] = _raise_uninitialized_error
        self.__dict__["_GetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_SetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_GetEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_GetMeanFlux"] = _raise_uninitialized_error
        self.__dict__["_SetMeanFlux"] = _raise_uninitialized_error
        self.__dict__["_GetLuminosity"] = _raise_uninitialized_error
        self.__dict__["_SetLuminosity"] = _raise_uninitialized_error
        self.__dict__["_GetSolarForceMethod"] = _raise_uninitialized_error
        self.__dict__["_SetSolarForceMethod"] = _raise_uninitialized_error
        self.__dict__["_GetIncludeBoundaryMitigation"] = _raise_uninitialized_error
        self.__dict__["_SetIncludeBoundaryMitigation"] = _raise_uninitialized_error
        self.__dict__["_GetUseSunCbFileValues"] = _raise_uninitialized_error
        self.__dict__["_SetUseSunCbFileValues"] = _raise_uninitialized_error
        self.__dict__["_GetSolarRadius"] = _raise_uninitialized_error
        self.__dict__["_SetSolarRadius"] = _raise_uninitialized_error
        self.__dict__["_GetVariableAreaHistoryFile"] = _raise_uninitialized_error
        self.__dict__["_SetVariableAreaHistoryFile"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVASRPVariableArea._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVASRPVariableArea from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVASRPVariableArea = agcom.GUID(IVASRPVariableArea._uuid)
        vtable_offset_local = IVASRPVariableArea._vtable_offset - 1
        self.__dict__["_GetAtmosAlt"] = IAGFUNCTYPE(pUnk, IID_IVASRPVariableArea, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAtmosAlt"] = IAGFUNCTYPE(pUnk, IID_IVASRPVariableArea, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetShadowModel"] = IAGFUNCTYPE(pUnk, IID_IVASRPVariableArea, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetShadowModel"] = IAGFUNCTYPE(pUnk, IID_IVASRPVariableArea, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVASRPVariableArea, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVASRPVariableArea, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_IVASRPVariableArea, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_GetMeanFlux"] = IAGFUNCTYPE(pUnk, IID_IVASRPVariableArea, vtable_offset_local+8, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMeanFlux"] = IAGFUNCTYPE(pUnk, IID_IVASRPVariableArea, vtable_offset_local+9, agcom.DOUBLE)
        self.__dict__["_GetLuminosity"] = IAGFUNCTYPE(pUnk, IID_IVASRPVariableArea, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_SetLuminosity"] = IAGFUNCTYPE(pUnk, IID_IVASRPVariableArea, vtable_offset_local+11, agcom.DOUBLE)
        self.__dict__["_GetSolarForceMethod"] = IAGFUNCTYPE(pUnk, IID_IVASRPVariableArea, vtable_offset_local+12, POINTER(agcom.LONG))
        self.__dict__["_SetSolarForceMethod"] = IAGFUNCTYPE(pUnk, IID_IVASRPVariableArea, vtable_offset_local+13, agcom.LONG)
        self.__dict__["_GetIncludeBoundaryMitigation"] = IAGFUNCTYPE(pUnk, IID_IVASRPVariableArea, vtable_offset_local+14, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIncludeBoundaryMitigation"] = IAGFUNCTYPE(pUnk, IID_IVASRPVariableArea, vtable_offset_local+15, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseSunCbFileValues"] = IAGFUNCTYPE(pUnk, IID_IVASRPVariableArea, vtable_offset_local+16, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseSunCbFileValues"] = IAGFUNCTYPE(pUnk, IID_IVASRPVariableArea, vtable_offset_local+17, agcom.VARIANT_BOOL)
        self.__dict__["_GetSolarRadius"] = IAGFUNCTYPE(pUnk, IID_IVASRPVariableArea, vtable_offset_local+18, POINTER(agcom.DOUBLE))
        self.__dict__["_SetSolarRadius"] = IAGFUNCTYPE(pUnk, IID_IVASRPVariableArea, vtable_offset_local+19, agcom.DOUBLE)
        self.__dict__["_GetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVASRPVariableArea, vtable_offset_local+20, POINTER(agcom.BSTR))
        self.__dict__["_SetVariableAreaHistoryFile"] = IAGFUNCTYPE(pUnk, IID_IVASRPVariableArea, vtable_offset_local+21, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVASRPVariableArea.__dict__ and type(IVASRPVariableArea.__dict__[attrname]) == property:
            return IVASRPVariableArea.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVASRPVariableArea.")
    
    @property
    def AtmosAlt(self) -> float:
        """The atmospheric altitude for eclipse. A simple model to account for some measure of attenuation that simply increases the shape of the Earth by the defined altitude height, often taken to be 23 km. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosAlt"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosAlt.setter
    def AtmosAlt(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosAlt"](arg_inVal.COM_val))

    @property
    def ShadowModel(self) -> "AgEVAShadowModel":
        """The shadow model type."""
        with agmarshall.AgEnum_arg(AgEVAShadowModel) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetShadowModel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ShadowModel.setter
    def ShadowModel(self, inVal:"AgEVAShadowModel") -> None:
        with agmarshall.AgEnum_arg(AgEVAShadowModel, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetShadowModel"](arg_inVal.COM_val))

    @property
    def SunPosition(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSunPosition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SunPosition.setter
    def SunPosition(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSunPosition"](arg_inVal.COM_val))

    @property
    def EclipsingBodies(self) -> "IVACentralBodyCollection":
        """Other eclipsing bodies."""
        with agmarshall.AgInterface_out_arg() as arg_ppCentralBodyCollection:
            agcls.evaluate_hresult(self.__dict__["_GetEclipsingBodies"](byref(arg_ppCentralBodyCollection.COM_val)))
            return arg_ppCentralBodyCollection.python_val

    @property
    def MeanFlux(self) -> float:
        """The mean solar flux at 1 au (W/m^2)."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMeanFlux"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MeanFlux.setter
    def MeanFlux(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMeanFlux"](arg_inVal.COM_val))

    @property
    def Luminosity(self) -> float:
        """The luminosity of sun. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLuminosity"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Luminosity.setter
    def Luminosity(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetLuminosity"](arg_inVal.COM_val))

    @property
    def SolarForceMethod(self) -> "AgEVASolarForceMethod":
        """The solar force method"""
        with agmarshall.AgEnum_arg(AgEVASolarForceMethod) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSolarForceMethod"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SolarForceMethod.setter
    def SolarForceMethod(self, inVal:"AgEVASolarForceMethod") -> None:
        with agmarshall.AgEnum_arg(AgEVASolarForceMethod, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSolarForceMethod"](arg_inVal.COM_val))

    @property
    def IncludeBoundaryMitigation(self) -> bool:
        """True if shadow boundary mitigation should be performed; the state of the satellite after crossing a shadow boundary will be corrected for errors possibly caused by the sudden change in SRP which occurred during the integration step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pMitigation:
            agcls.evaluate_hresult(self.__dict__["_GetIncludeBoundaryMitigation"](byref(arg_pMitigation.COM_val)))
            return arg_pMitigation.python_val

    @IncludeBoundaryMitigation.setter
    def IncludeBoundaryMitigation(self, mitigation:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(mitigation) as arg_mitigation:
            agcls.evaluate_hresult(self.__dict__["_SetIncludeBoundaryMitigation"](arg_mitigation.COM_val))

    @property
    def UseSunCbFileValues(self) -> bool:
        """True if solar values should come from the Sun.cb file."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseSunCbFileValues"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseSunCbFileValues.setter
    def UseSunCbFileValues(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseSunCbFileValues"](arg_inVal.COM_val))

    @property
    def SolarRadius(self) -> float:
        """The solar radius value to use in eclipse calculations.  Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSolarRadius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SolarRadius.setter
    def SolarRadius(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSolarRadius"](arg_inVal.COM_val))

    @property
    def VariableAreaHistoryFile(self) -> str:
        """Full path of the variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetVariableAreaHistoryFile"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @VariableAreaHistoryFile.setter
    def VariableAreaHistoryFile(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetVariableAreaHistoryFile"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4124EBC1-ABC6-4933-84D2-0F1232D8B630}", IVASRPVariableArea)
agcls.AgTypeNameMap["IVASRPVariableArea"] = IVASRPVariableArea

class IVAThirdBodyFunction(object):
    """Properties for a Third Body propagator function. The IAgComponentInfo object returned by the mode property can be cast to IAgVAGravityFieldFunction or IAgVAPointMassFunction depending on the selected ModeType."""
    _uuid = "{86FDAC1D-8E57-4915-AA9B-E6C35E06C9BC}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetThirdBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetThirdBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetEphemSource"] = _raise_uninitialized_error
        self.__dict__["_SetEphemSource"] = _raise_uninitialized_error
        self.__dict__["_GetMode"] = _raise_uninitialized_error
        self.__dict__["_SetModeType"] = _raise_uninitialized_error
        self.__dict__["_GetModeType"] = _raise_uninitialized_error
        self.__dict__["_GetEphemerisSourceWarning"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAThirdBodyFunction._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAThirdBodyFunction from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAThirdBodyFunction = agcom.GUID(IVAThirdBodyFunction._uuid)
        vtable_offset_local = IVAThirdBodyFunction._vtable_offset - 1
        self.__dict__["_GetThirdBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAThirdBodyFunction, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetThirdBodyName"] = IAGFUNCTYPE(pUnk, IID_IVAThirdBodyFunction, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetEphemSource"] = IAGFUNCTYPE(pUnk, IID_IVAThirdBodyFunction, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetEphemSource"] = IAGFUNCTYPE(pUnk, IID_IVAThirdBodyFunction, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetMode"] = IAGFUNCTYPE(pUnk, IID_IVAThirdBodyFunction, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_SetModeType"] = IAGFUNCTYPE(pUnk, IID_IVAThirdBodyFunction, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetModeType"] = IAGFUNCTYPE(pUnk, IID_IVAThirdBodyFunction, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_GetEphemerisSourceWarning"] = IAGFUNCTYPE(pUnk, IID_IVAThirdBodyFunction, vtable_offset_local+8, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAThirdBodyFunction.__dict__ and type(IVAThirdBodyFunction.__dict__[attrname]) == property:
            return IVAThirdBodyFunction.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAThirdBodyFunction.")
    
    @property
    def ThirdBodyName(self) -> str:
        """The selected third body model."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetThirdBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ThirdBodyName.setter
    def ThirdBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetThirdBodyName"](arg_inVal.COM_val))

    @property
    def EphemSource(self) -> "AgEVAEphemSource":
        """Source for the third body's ephemeris"""
        with agmarshall.AgEnum_arg(AgEVAEphemSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEphemSource"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EphemSource.setter
    def EphemSource(self, inVal:"AgEVAEphemSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAEphemSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetEphemSource"](arg_inVal.COM_val))

    @property
    def Mode(self) -> "IComponentInfo":
        """The third body gravity mode. The IAgComponentInfo object returned by this property can be cast to IAgVAGravityFieldFunction or IAgVAPointMassFunction depending on the selected ModeType."""
        with agmarshall.AgInterface_out_arg() as arg_ppComponent:
            agcls.evaluate_hresult(self.__dict__["_GetMode"](byref(arg_ppComponent.COM_val)))
            return arg_ppComponent.python_val

    def SetModeType(self, mode:"AgEVAThirdBodyMode") -> None:
        """The third body gravity mode."""
        with agmarshall.AgEnum_arg(AgEVAThirdBodyMode, mode) as arg_mode:
            agcls.evaluate_hresult(self.__dict__["_SetModeType"](arg_mode.COM_val))

    @property
    def ModeType(self) -> "AgEVAThirdBodyMode":
        """The third body gravity mode type."""
        with agmarshall.AgEnum_arg(AgEVAThirdBodyMode) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetModeType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def EphemerisSourceWarning(self) -> str:
        """Returns a warning message if the Ephemeris source and the gravity are not compatible"""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEphemerisSourceWarning"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{86FDAC1D-8E57-4915-AA9B-E6C35E06C9BC}", IVAThirdBodyFunction)
agcls.AgTypeNameMap["IVAThirdBodyFunction"] = IVAThirdBodyFunction

class IVASRPReflectionPlugin(object):
    """Properties for the plugin SRP Refelction."""
    _uuid = "{2DF13668-98B3-4E69-89CA-C8136EAE49D9}"
    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetPluginIdentifier"] = _raise_uninitialized_error
        self.__dict__["_SetPluginIdentifier"] = _raise_uninitialized_error
        self.__dict__["_GetPluginConfig"] = _raise_uninitialized_error
        self.__dict__["_GetAtmosAlt"] = _raise_uninitialized_error
        self.__dict__["_SetAtmosAlt"] = _raise_uninitialized_error
        self.__dict__["_GetShadowModel"] = _raise_uninitialized_error
        self.__dict__["_SetShadowModel"] = _raise_uninitialized_error
        self.__dict__["_GetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_SetSunPosition"] = _raise_uninitialized_error
        self.__dict__["_GetEclipsingBodies"] = _raise_uninitialized_error
        self.__dict__["_GetIncludeBoundaryMitigation"] = _raise_uninitialized_error
        self.__dict__["_SetIncludeBoundaryMitigation"] = _raise_uninitialized_error
        self.__dict__["_GetUseSunCbFileValues"] = _raise_uninitialized_error
        self.__dict__["_SetUseSunCbFileValues"] = _raise_uninitialized_error
        self.__dict__["_GetSolarRadius"] = _raise_uninitialized_error
        self.__dict__["_SetSolarRadius"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVASRPReflectionPlugin._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVASRPReflectionPlugin from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVASRPReflectionPlugin = agcom.GUID(IVASRPReflectionPlugin._uuid)
        vtable_offset_local = IVASRPReflectionPlugin._vtable_offset - 1
        self.__dict__["_GetPluginIdentifier"] = IAGFUNCTYPE(pUnk, IID_IVASRPReflectionPlugin, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetPluginIdentifier"] = IAGFUNCTYPE(pUnk, IID_IVASRPReflectionPlugin, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetPluginConfig"] = IAGFUNCTYPE(pUnk, IID_IVASRPReflectionPlugin, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetAtmosAlt"] = IAGFUNCTYPE(pUnk, IID_IVASRPReflectionPlugin, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAtmosAlt"] = IAGFUNCTYPE(pUnk, IID_IVASRPReflectionPlugin, vtable_offset_local+5, agcom.DOUBLE)
        self.__dict__["_GetShadowModel"] = IAGFUNCTYPE(pUnk, IID_IVASRPReflectionPlugin, vtable_offset_local+6, POINTER(agcom.LONG))
        self.__dict__["_SetShadowModel"] = IAGFUNCTYPE(pUnk, IID_IVASRPReflectionPlugin, vtable_offset_local+7, agcom.LONG)
        self.__dict__["_GetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVASRPReflectionPlugin, vtable_offset_local+8, POINTER(agcom.LONG))
        self.__dict__["_SetSunPosition"] = IAGFUNCTYPE(pUnk, IID_IVASRPReflectionPlugin, vtable_offset_local+9, agcom.LONG)
        self.__dict__["_GetEclipsingBodies"] = IAGFUNCTYPE(pUnk, IID_IVASRPReflectionPlugin, vtable_offset_local+10, POINTER(agcom.PVOID))
        self.__dict__["_GetIncludeBoundaryMitigation"] = IAGFUNCTYPE(pUnk, IID_IVASRPReflectionPlugin, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetIncludeBoundaryMitigation"] = IAGFUNCTYPE(pUnk, IID_IVASRPReflectionPlugin, vtable_offset_local+12, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseSunCbFileValues"] = IAGFUNCTYPE(pUnk, IID_IVASRPReflectionPlugin, vtable_offset_local+13, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseSunCbFileValues"] = IAGFUNCTYPE(pUnk, IID_IVASRPReflectionPlugin, vtable_offset_local+14, agcom.VARIANT_BOOL)
        self.__dict__["_GetSolarRadius"] = IAGFUNCTYPE(pUnk, IID_IVASRPReflectionPlugin, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_SetSolarRadius"] = IAGFUNCTYPE(pUnk, IID_IVASRPReflectionPlugin, vtable_offset_local+16, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVASRPReflectionPlugin.__dict__ and type(IVASRPReflectionPlugin.__dict__[attrname]) == property:
            return IVASRPReflectionPlugin.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVASRPReflectionPlugin.")
    
    @property
    def PluginIdentifier(self) -> str:
        """The plugin name."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPluginIdentifier"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @PluginIdentifier.setter
    def PluginIdentifier(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetPluginIdentifier"](arg_inVal.COM_val))

    @property
    def PluginConfig(self) -> "IVAPluginProperties":
        """The properties of the selected plugin."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPluginConfig"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def AtmosAlt(self) -> float:
        """The atmospheric altitude for eclipse. A simple model to account for some measure of attenuation that simply increases the shape of the Earth by the defined altitude height, often taken to be 23 km. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAtmosAlt"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @AtmosAlt.setter
    def AtmosAlt(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAtmosAlt"](arg_inVal.COM_val))

    @property
    def ShadowModel(self) -> "AgEVAShadowModel":
        """The shadow model type."""
        with agmarshall.AgEnum_arg(AgEVAShadowModel) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetShadowModel"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ShadowModel.setter
    def ShadowModel(self, inVal:"AgEVAShadowModel") -> None:
        with agmarshall.AgEnum_arg(AgEVAShadowModel, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetShadowModel"](arg_inVal.COM_val))

    @property
    def SunPosition(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSunPosition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SunPosition.setter
    def SunPosition(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSunPosition"](arg_inVal.COM_val))

    @property
    def EclipsingBodies(self) -> "IVACentralBodyCollection":
        """Other eclipsing bodies."""
        with agmarshall.AgInterface_out_arg() as arg_ppCentralBodyCollection:
            agcls.evaluate_hresult(self.__dict__["_GetEclipsingBodies"](byref(arg_ppCentralBodyCollection.COM_val)))
            return arg_ppCentralBodyCollection.python_val

    @property
    def IncludeBoundaryMitigation(self) -> bool:
        """True if shadow boundary mitigation should be performed; the state of the satellite after crossing a shadow boundary will be corrected for errors possibly caused by the sudden change in SRP which occurred during the integration step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pMitigation:
            agcls.evaluate_hresult(self.__dict__["_GetIncludeBoundaryMitigation"](byref(arg_pMitigation.COM_val)))
            return arg_pMitigation.python_val

    @IncludeBoundaryMitigation.setter
    def IncludeBoundaryMitigation(self, mitigation:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(mitigation) as arg_mitigation:
            agcls.evaluate_hresult(self.__dict__["_SetIncludeBoundaryMitigation"](arg_mitigation.COM_val))

    @property
    def UseSunCbFileValues(self) -> bool:
        """True if solar values should come from the Sun.cb file."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseSunCbFileValues"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseSunCbFileValues.setter
    def UseSunCbFileValues(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseSunCbFileValues"](arg_inVal.COM_val))

    @property
    def SolarRadius(self) -> float:
        """The solar radius value to use in eclipse calculations.  Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSolarRadius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SolarRadius.setter
    def SolarRadius(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSolarRadius"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2DF13668-98B3-4E69-89CA-C8136EAE49D9}", IVASRPReflectionPlugin)
agcls.AgTypeNameMap["IVASRPReflectionPlugin"] = IVASRPReflectionPlugin

class IVAEngineModelThrustCoefficients(object):
    """Thrust coefficient properties for engine definition."""
    _uuid = "{2F905CDC-4D91-497F-85E2-AE1E2F3A4FA3}"
    _num_methods = 32
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetC0"] = _raise_uninitialized_error
        self.__dict__["_SetC0"] = _raise_uninitialized_error
        self.__dict__["_GetC1"] = _raise_uninitialized_error
        self.__dict__["_SetC1"] = _raise_uninitialized_error
        self.__dict__["_GetC2"] = _raise_uninitialized_error
        self.__dict__["_SetC2"] = _raise_uninitialized_error
        self.__dict__["_GetC3"] = _raise_uninitialized_error
        self.__dict__["_SetC3"] = _raise_uninitialized_error
        self.__dict__["_GetC4"] = _raise_uninitialized_error
        self.__dict__["_SetC4"] = _raise_uninitialized_error
        self.__dict__["_GetC5"] = _raise_uninitialized_error
        self.__dict__["_SetC5"] = _raise_uninitialized_error
        self.__dict__["_GetC6"] = _raise_uninitialized_error
        self.__dict__["_SetC6"] = _raise_uninitialized_error
        self.__dict__["_GetC7"] = _raise_uninitialized_error
        self.__dict__["_SetC7"] = _raise_uninitialized_error
        self.__dict__["_GetE4"] = _raise_uninitialized_error
        self.__dict__["_SetE4"] = _raise_uninitialized_error
        self.__dict__["_GetE5"] = _raise_uninitialized_error
        self.__dict__["_SetE5"] = _raise_uninitialized_error
        self.__dict__["_GetE6"] = _raise_uninitialized_error
        self.__dict__["_SetE6"] = _raise_uninitialized_error
        self.__dict__["_GetE7"] = _raise_uninitialized_error
        self.__dict__["_SetE7"] = _raise_uninitialized_error
        self.__dict__["_GetB7"] = _raise_uninitialized_error
        self.__dict__["_SetB7"] = _raise_uninitialized_error
        self.__dict__["_GetK0"] = _raise_uninitialized_error
        self.__dict__["_SetK0"] = _raise_uninitialized_error
        self.__dict__["_GetK1"] = _raise_uninitialized_error
        self.__dict__["_SetK1"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceTemp"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceTemp"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAEngineModelThrustCoefficients._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAEngineModelThrustCoefficients from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAEngineModelThrustCoefficients = agcom.GUID(IVAEngineModelThrustCoefficients._uuid)
        vtable_offset_local = IVAEngineModelThrustCoefficients._vtable_offset - 1
        self.__dict__["_GetC0"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelThrustCoefficients, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetC0"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelThrustCoefficients, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetC1"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelThrustCoefficients, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetC1"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelThrustCoefficients, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetC2"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelThrustCoefficients, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetC2"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelThrustCoefficients, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetC3"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelThrustCoefficients, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetC3"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelThrustCoefficients, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetC4"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelThrustCoefficients, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetC4"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelThrustCoefficients, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetC5"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelThrustCoefficients, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetC5"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelThrustCoefficients, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetC6"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelThrustCoefficients, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetC6"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelThrustCoefficients, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetC7"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelThrustCoefficients, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_SetC7"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelThrustCoefficients, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_GetE4"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelThrustCoefficients, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_SetE4"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelThrustCoefficients, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_GetE5"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelThrustCoefficients, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_SetE5"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelThrustCoefficients, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_GetE6"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelThrustCoefficients, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_SetE6"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelThrustCoefficients, vtable_offset_local+22, agcom.DOUBLE)
        self.__dict__["_GetE7"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelThrustCoefficients, vtable_offset_local+23, POINTER(agcom.DOUBLE))
        self.__dict__["_SetE7"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelThrustCoefficients, vtable_offset_local+24, agcom.DOUBLE)
        self.__dict__["_GetB7"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelThrustCoefficients, vtable_offset_local+25, POINTER(agcom.DOUBLE))
        self.__dict__["_SetB7"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelThrustCoefficients, vtable_offset_local+26, agcom.DOUBLE)
        self.__dict__["_GetK0"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelThrustCoefficients, vtable_offset_local+27, POINTER(agcom.DOUBLE))
        self.__dict__["_SetK0"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelThrustCoefficients, vtable_offset_local+28, agcom.DOUBLE)
        self.__dict__["_GetK1"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelThrustCoefficients, vtable_offset_local+29, POINTER(agcom.DOUBLE))
        self.__dict__["_SetK1"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelThrustCoefficients, vtable_offset_local+30, agcom.DOUBLE)
        self.__dict__["_GetReferenceTemp"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelThrustCoefficients, vtable_offset_local+31, POINTER(agcom.DOUBLE))
        self.__dict__["_SetReferenceTemp"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelThrustCoefficients, vtable_offset_local+32, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAEngineModelThrustCoefficients.__dict__ and type(IVAEngineModelThrustCoefficients.__dict__[attrname]) == property:
            return IVAEngineModelThrustCoefficients.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAEngineModelThrustCoefficients.")
    
    @property
    def C0(self) -> float:
        """C0 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetC0"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @C0.setter
    def C0(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetC0"](arg_inVal.COM_val))

    @property
    def C1(self) -> float:
        """C1 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetC1"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @C1.setter
    def C1(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetC1"](arg_inVal.COM_val))

    @property
    def C2(self) -> float:
        """C2 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetC2"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @C2.setter
    def C2(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetC2"](arg_inVal.COM_val))

    @property
    def C3(self) -> float:
        """C3 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetC3"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @C3.setter
    def C3(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetC3"](arg_inVal.COM_val))

    @property
    def C4(self) -> float:
        """C4 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetC4"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @C4.setter
    def C4(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetC4"](arg_inVal.COM_val))

    @property
    def C5(self) -> float:
        """C5 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetC5"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @C5.setter
    def C5(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetC5"](arg_inVal.COM_val))

    @property
    def C6(self) -> float:
        """C6 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetC6"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @C6.setter
    def C6(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetC6"](arg_inVal.COM_val))

    @property
    def C7(self) -> float:
        """C7 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetC7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @C7.setter
    def C7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetC7"](arg_inVal.COM_val))

    @property
    def E4(self) -> float:
        """E4 exponent. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetE4"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @E4.setter
    def E4(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetE4"](arg_inVal.COM_val))

    @property
    def E5(self) -> float:
        """E5 exponent. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetE5"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @E5.setter
    def E5(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetE5"](arg_inVal.COM_val))

    @property
    def E6(self) -> float:
        """E6 exponent. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetE6"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @E6.setter
    def E6(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetE6"](arg_inVal.COM_val))

    @property
    def E7(self) -> float:
        """E7 exponent. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetE7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @E7.setter
    def E7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetE7"](arg_inVal.COM_val))

    @property
    def B7(self) -> float:
        """B7 base. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetB7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @B7.setter
    def B7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetB7"](arg_inVal.COM_val))

    @property
    def K0(self) -> float:
        """K0 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetK0"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @K0.setter
    def K0(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetK0"](arg_inVal.COM_val))

    @property
    def K1(self) -> float:
        """K1 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetK1"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @K1.setter
    def K1(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetK1"](arg_inVal.COM_val))

    @property
    def ReferenceTemp(self) -> float:
        """Reference temperature for data. Uses Temperature Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceTemp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ReferenceTemp.setter
    def ReferenceTemp(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceTemp"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2F905CDC-4D91-497F-85E2-AE1E2F3A4FA3}", IVAEngineModelThrustCoefficients)
agcls.AgTypeNameMap["IVAEngineModelThrustCoefficients"] = IVAEngineModelThrustCoefficients

class IVAEngineModelIspCoefficients(object):
    """Isp coefficient properties for engine definition."""
    _uuid = "{3D092FFB-ED99-4F4A-94E5-8BFA7CEF328C}"
    _num_methods = 32
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetC0"] = _raise_uninitialized_error
        self.__dict__["_SetC0"] = _raise_uninitialized_error
        self.__dict__["_GetC1"] = _raise_uninitialized_error
        self.__dict__["_SetC1"] = _raise_uninitialized_error
        self.__dict__["_GetC2"] = _raise_uninitialized_error
        self.__dict__["_SetC2"] = _raise_uninitialized_error
        self.__dict__["_GetC3"] = _raise_uninitialized_error
        self.__dict__["_SetC3"] = _raise_uninitialized_error
        self.__dict__["_GetC4"] = _raise_uninitialized_error
        self.__dict__["_SetC4"] = _raise_uninitialized_error
        self.__dict__["_GetC5"] = _raise_uninitialized_error
        self.__dict__["_SetC5"] = _raise_uninitialized_error
        self.__dict__["_GetC6"] = _raise_uninitialized_error
        self.__dict__["_SetC6"] = _raise_uninitialized_error
        self.__dict__["_GetC7"] = _raise_uninitialized_error
        self.__dict__["_SetC7"] = _raise_uninitialized_error
        self.__dict__["_GetE4"] = _raise_uninitialized_error
        self.__dict__["_SetE4"] = _raise_uninitialized_error
        self.__dict__["_GetE5"] = _raise_uninitialized_error
        self.__dict__["_SetE5"] = _raise_uninitialized_error
        self.__dict__["_GetE6"] = _raise_uninitialized_error
        self.__dict__["_SetE6"] = _raise_uninitialized_error
        self.__dict__["_GetE7"] = _raise_uninitialized_error
        self.__dict__["_SetE7"] = _raise_uninitialized_error
        self.__dict__["_GetB7"] = _raise_uninitialized_error
        self.__dict__["_SetB7"] = _raise_uninitialized_error
        self.__dict__["_GetK0"] = _raise_uninitialized_error
        self.__dict__["_SetK0"] = _raise_uninitialized_error
        self.__dict__["_GetK1"] = _raise_uninitialized_error
        self.__dict__["_SetK1"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceTemp"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceTemp"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAEngineModelIspCoefficients._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAEngineModelIspCoefficients from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAEngineModelIspCoefficients = agcom.GUID(IVAEngineModelIspCoefficients._uuid)
        vtable_offset_local = IVAEngineModelIspCoefficients._vtable_offset - 1
        self.__dict__["_GetC0"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelIspCoefficients, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetC0"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelIspCoefficients, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetC1"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelIspCoefficients, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetC1"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelIspCoefficients, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetC2"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelIspCoefficients, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetC2"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelIspCoefficients, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetC3"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelIspCoefficients, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetC3"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelIspCoefficients, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetC4"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelIspCoefficients, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetC4"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelIspCoefficients, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetC5"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelIspCoefficients, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetC5"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelIspCoefficients, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetC6"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelIspCoefficients, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetC6"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelIspCoefficients, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetC7"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelIspCoefficients, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_SetC7"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelIspCoefficients, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_GetE4"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelIspCoefficients, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_SetE4"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelIspCoefficients, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_GetE5"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelIspCoefficients, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_SetE5"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelIspCoefficients, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_GetE6"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelIspCoefficients, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_SetE6"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelIspCoefficients, vtable_offset_local+22, agcom.DOUBLE)
        self.__dict__["_GetE7"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelIspCoefficients, vtable_offset_local+23, POINTER(agcom.DOUBLE))
        self.__dict__["_SetE7"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelIspCoefficients, vtable_offset_local+24, agcom.DOUBLE)
        self.__dict__["_GetB7"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelIspCoefficients, vtable_offset_local+25, POINTER(agcom.DOUBLE))
        self.__dict__["_SetB7"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelIspCoefficients, vtable_offset_local+26, agcom.DOUBLE)
        self.__dict__["_GetK0"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelIspCoefficients, vtable_offset_local+27, POINTER(agcom.DOUBLE))
        self.__dict__["_SetK0"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelIspCoefficients, vtable_offset_local+28, agcom.DOUBLE)
        self.__dict__["_GetK1"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelIspCoefficients, vtable_offset_local+29, POINTER(agcom.DOUBLE))
        self.__dict__["_SetK1"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelIspCoefficients, vtable_offset_local+30, agcom.DOUBLE)
        self.__dict__["_GetReferenceTemp"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelIspCoefficients, vtable_offset_local+31, POINTER(agcom.DOUBLE))
        self.__dict__["_SetReferenceTemp"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelIspCoefficients, vtable_offset_local+32, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAEngineModelIspCoefficients.__dict__ and type(IVAEngineModelIspCoefficients.__dict__[attrname]) == property:
            return IVAEngineModelIspCoefficients.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAEngineModelIspCoefficients.")
    
    @property
    def C0(self) -> float:
        """C0 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetC0"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @C0.setter
    def C0(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetC0"](arg_inVal.COM_val))

    @property
    def C1(self) -> float:
        """C1 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetC1"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @C1.setter
    def C1(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetC1"](arg_inVal.COM_val))

    @property
    def C2(self) -> float:
        """C2 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetC2"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @C2.setter
    def C2(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetC2"](arg_inVal.COM_val))

    @property
    def C3(self) -> float:
        """C3 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetC3"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @C3.setter
    def C3(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetC3"](arg_inVal.COM_val))

    @property
    def C4(self) -> float:
        """C4 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetC4"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @C4.setter
    def C4(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetC4"](arg_inVal.COM_val))

    @property
    def C5(self) -> float:
        """C5 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetC5"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @C5.setter
    def C5(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetC5"](arg_inVal.COM_val))

    @property
    def C6(self) -> float:
        """C6 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetC6"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @C6.setter
    def C6(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetC6"](arg_inVal.COM_val))

    @property
    def C7(self) -> float:
        """C7 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetC7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @C7.setter
    def C7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetC7"](arg_inVal.COM_val))

    @property
    def E4(self) -> float:
        """E4 exponent. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetE4"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @E4.setter
    def E4(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetE4"](arg_inVal.COM_val))

    @property
    def E5(self) -> float:
        """E5 exponent. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetE5"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @E5.setter
    def E5(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetE5"](arg_inVal.COM_val))

    @property
    def E6(self) -> float:
        """E6 exponent. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetE6"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @E6.setter
    def E6(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetE6"](arg_inVal.COM_val))

    @property
    def E7(self) -> float:
        """E7 exponent. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetE7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @E7.setter
    def E7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetE7"](arg_inVal.COM_val))

    @property
    def B7(self) -> float:
        """B7 base. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetB7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @B7.setter
    def B7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetB7"](arg_inVal.COM_val))

    @property
    def K0(self) -> float:
        """K0 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetK0"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @K0.setter
    def K0(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetK0"](arg_inVal.COM_val))

    @property
    def K1(self) -> float:
        """K1 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetK1"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @K1.setter
    def K1(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetK1"](arg_inVal.COM_val))

    @property
    def ReferenceTemp(self) -> float:
        """Reference temperature for data. Uses Temperature Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceTemp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ReferenceTemp.setter
    def ReferenceTemp(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceTemp"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3D092FFB-ED99-4F4A-94E5-8BFA7CEF328C}", IVAEngineModelIspCoefficients)
agcls.AgTypeNameMap["IVAEngineModelIspCoefficients"] = IVAEngineModelIspCoefficients

class IVAEngineConstAcc(object):
    """Properties for a Constant Acceleration and Isp engine model."""
    _uuid = "{32A0554F-7D4A-4A7E-80B7-5B57ED17B9D2}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Getg"] = _raise_uninitialized_error
        self.__dict__["_Setg"] = _raise_uninitialized_error
        self.__dict__["_GetAcceleration"] = _raise_uninitialized_error
        self.__dict__["_SetAcceleration"] = _raise_uninitialized_error
        self.__dict__["_GetIsp"] = _raise_uninitialized_error
        self.__dict__["_SetIsp"] = _raise_uninitialized_error
        self.__dict__["_EnableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_DisableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_IsControlParameterEnabled"] = _raise_uninitialized_error
        self.__dict__["_GetControlParametersAvailable"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAEngineConstAcc._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAEngineConstAcc from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAEngineConstAcc = agcom.GUID(IVAEngineConstAcc._uuid)
        vtable_offset_local = IVAEngineConstAcc._vtable_offset - 1
        self.__dict__["_Getg"] = IAGFUNCTYPE(pUnk, IID_IVAEngineConstAcc, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_Setg"] = IAGFUNCTYPE(pUnk, IID_IVAEngineConstAcc, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetAcceleration"] = IAGFUNCTYPE(pUnk, IID_IVAEngineConstAcc, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetAcceleration"] = IAGFUNCTYPE(pUnk, IID_IVAEngineConstAcc, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetIsp"] = IAGFUNCTYPE(pUnk, IID_IVAEngineConstAcc, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetIsp"] = IAGFUNCTYPE(pUnk, IID_IVAEngineConstAcc, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_EnableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAEngineConstAcc, vtable_offset_local+7, agcom.LONG)
        self.__dict__["_DisableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAEngineConstAcc, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_IsControlParameterEnabled"] = IAGFUNCTYPE(pUnk, IID_IVAEngineConstAcc, vtable_offset_local+9, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetControlParametersAvailable"] = IAGFUNCTYPE(pUnk, IID_IVAEngineConstAcc, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAEngineConstAcc.__dict__ and type(IVAEngineConstAcc.__dict__[attrname]) == property:
            return IVAEngineConstAcc.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAEngineConstAcc.")
    
    @property
    def g(self) -> float:
        """The gravitational acceleration constant at sea level on the Earth. Uses Acceleration Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_Getg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @g.setter
    def g(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_Setg"](arg_inVal.COM_val))

    @property
    def Acceleration(self) -> float:
        """The acceleration for this engine. Uses Acceleration Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetAcceleration"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Acceleration.setter
    def Acceleration(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetAcceleration"](arg_inVal.COM_val))

    @property
    def Isp(self) -> float:
        """The specific impulse for this engine. Uses SpecificImpulse Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Isp.setter
    def Isp(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetIsp"](arg_inVal.COM_val))

    def EnableControlParameter(self, param:"AgEVAControlEngineConstAcc") -> None:
        """Enables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlEngineConstAcc, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_EnableControlParameter"](arg_param.COM_val))

    def DisableControlParameter(self, param:"AgEVAControlEngineConstAcc") -> None:
        """Disables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlEngineConstAcc, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_DisableControlParameter"](arg_param.COM_val))

    def IsControlParameterEnabled(self, param:"AgEVAControlEngineConstAcc") -> bool:
        """Sees if the specified control is enabled."""
        with agmarshall.AgEnum_arg(AgEVAControlEngineConstAcc, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_IsControlParameterEnabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ControlParametersAvailable(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetControlParametersAvailable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{32A0554F-7D4A-4A7E-80B7-5B57ED17B9D2}", IVAEngineConstAcc)
agcls.AgTypeNameMap["IVAEngineConstAcc"] = IVAEngineConstAcc

class IVAEngineConstant(object):
    """Properties for a Constant Thrust and Isp engine model."""
    _uuid = "{1BA84003-AFE1-4AD5-B36B-967D7B9FF8B0}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Getg"] = _raise_uninitialized_error
        self.__dict__["_Setg"] = _raise_uninitialized_error
        self.__dict__["_GetThrust"] = _raise_uninitialized_error
        self.__dict__["_SetThrust"] = _raise_uninitialized_error
        self.__dict__["_GetIsp"] = _raise_uninitialized_error
        self.__dict__["_SetIsp"] = _raise_uninitialized_error
        self.__dict__["_EnableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_DisableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_IsControlParameterEnabled"] = _raise_uninitialized_error
        self.__dict__["_GetControlParametersAvailable"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAEngineConstant._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAEngineConstant from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAEngineConstant = agcom.GUID(IVAEngineConstant._uuid)
        vtable_offset_local = IVAEngineConstant._vtable_offset - 1
        self.__dict__["_Getg"] = IAGFUNCTYPE(pUnk, IID_IVAEngineConstant, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_Setg"] = IAGFUNCTYPE(pUnk, IID_IVAEngineConstant, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetThrust"] = IAGFUNCTYPE(pUnk, IID_IVAEngineConstant, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetThrust"] = IAGFUNCTYPE(pUnk, IID_IVAEngineConstant, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetIsp"] = IAGFUNCTYPE(pUnk, IID_IVAEngineConstant, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetIsp"] = IAGFUNCTYPE(pUnk, IID_IVAEngineConstant, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_EnableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAEngineConstant, vtable_offset_local+7, agcom.LONG)
        self.__dict__["_DisableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAEngineConstant, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_IsControlParameterEnabled"] = IAGFUNCTYPE(pUnk, IID_IVAEngineConstant, vtable_offset_local+9, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetControlParametersAvailable"] = IAGFUNCTYPE(pUnk, IID_IVAEngineConstant, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAEngineConstant.__dict__ and type(IVAEngineConstant.__dict__[attrname]) == property:
            return IVAEngineConstant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAEngineConstant.")
    
    @property
    def g(self) -> float:
        """The gravitational acceleration constant at sea level on the Earth. Uses Acceleration Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_Getg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @g.setter
    def g(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_Setg"](arg_inVal.COM_val))

    @property
    def Thrust(self) -> float:
        """The thrust for this engine. Uses Force Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetThrust"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Thrust.setter
    def Thrust(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetThrust"](arg_inVal.COM_val))

    @property
    def Isp(self) -> float:
        """The specific impulse for this engine. Uses SpecificImpulse Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetIsp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Isp.setter
    def Isp(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetIsp"](arg_inVal.COM_val))

    def EnableControlParameter(self, param:"AgEVAControlEngineConstant") -> None:
        """Enables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlEngineConstant, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_EnableControlParameter"](arg_param.COM_val))

    def DisableControlParameter(self, param:"AgEVAControlEngineConstant") -> None:
        """Disables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlEngineConstant, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_DisableControlParameter"](arg_param.COM_val))

    def IsControlParameterEnabled(self, param:"AgEVAControlEngineConstant") -> bool:
        """Sees if the specified control is enabled."""
        with agmarshall.AgEnum_arg(AgEVAControlEngineConstant, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_IsControlParameterEnabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ControlParametersAvailable(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetControlParametersAvailable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{1BA84003-AFE1-4AD5-B36B-967D7B9FF8B0}", IVAEngineConstant)
agcls.AgTypeNameMap["IVAEngineConstant"] = IVAEngineConstant

class IVAEngineDefinition(object):
    """Properties for engine definition for an Ion engine model."""
    _uuid = "{74BF5209-9E9B-45E3-8AE0-E68971558447}"
    _num_methods = 42
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetIspC0"] = _raise_uninitialized_error
        self.__dict__["_SetIspC0"] = _raise_uninitialized_error
        self.__dict__["_GetIspC1"] = _raise_uninitialized_error
        self.__dict__["_SetIspC1"] = _raise_uninitialized_error
        self.__dict__["_GetIspC2"] = _raise_uninitialized_error
        self.__dict__["_SetIspC2"] = _raise_uninitialized_error
        self.__dict__["_GetIspC3"] = _raise_uninitialized_error
        self.__dict__["_SetIspC3"] = _raise_uninitialized_error
        self.__dict__["_GetMassFlowRateEquationType"] = _raise_uninitialized_error
        self.__dict__["_SetMassFlowRateEquationType"] = _raise_uninitialized_error
        self.__dict__["_GetMassFlowRateC0"] = _raise_uninitialized_error
        self.__dict__["_SetMassFlowRateC0"] = _raise_uninitialized_error
        self.__dict__["_GetMassFlowRateC1"] = _raise_uninitialized_error
        self.__dict__["_SetMassFlowRateC1"] = _raise_uninitialized_error
        self.__dict__["_GetMassFlowRateC2"] = _raise_uninitialized_error
        self.__dict__["_SetMassFlowRateC2"] = _raise_uninitialized_error
        self.__dict__["_GetMassFlowRateC3"] = _raise_uninitialized_error
        self.__dict__["_SetMassFlowRateC3"] = _raise_uninitialized_error
        self.__dict__["_GetMassFlowRateEquation"] = _raise_uninitialized_error
        self.__dict__["_GetMassFlowEfficiencyC0"] = _raise_uninitialized_error
        self.__dict__["_SetMassFlowEfficiencyC0"] = _raise_uninitialized_error
        self.__dict__["_GetMassFlowEfficiencyC1"] = _raise_uninitialized_error
        self.__dict__["_SetMassFlowEfficiencyC1"] = _raise_uninitialized_error
        self.__dict__["_GetMassFlowEfficiencyC2"] = _raise_uninitialized_error
        self.__dict__["_SetMassFlowEfficiencyC2"] = _raise_uninitialized_error
        self.__dict__["_GetMassFlowEfficiencyC3"] = _raise_uninitialized_error
        self.__dict__["_SetMassFlowEfficiencyC3"] = _raise_uninitialized_error
        self.__dict__["_GetMassFlowEfficiencyIndependentVar"] = _raise_uninitialized_error
        self.__dict__["_SetMassFlowEfficiencyIndependentVar"] = _raise_uninitialized_error
        self.__dict__["_GetMassFlowEfficiencyEquation"] = _raise_uninitialized_error
        self.__dict__["_GetPowerEfficiencyC0"] = _raise_uninitialized_error
        self.__dict__["_SetPowerEfficiencyC0"] = _raise_uninitialized_error
        self.__dict__["_GetPowerEfficiencyC1"] = _raise_uninitialized_error
        self.__dict__["_SetPowerEfficiencyC1"] = _raise_uninitialized_error
        self.__dict__["_GetPowerEfficiencyC2"] = _raise_uninitialized_error
        self.__dict__["_SetPowerEfficiencyC2"] = _raise_uninitialized_error
        self.__dict__["_GetPowerEfficiencyC3"] = _raise_uninitialized_error
        self.__dict__["_SetPowerEfficiencyC3"] = _raise_uninitialized_error
        self.__dict__["_GetPowerEfficiencyIndependentVar"] = _raise_uninitialized_error
        self.__dict__["_SetPowerEfficiencyIndependentVar"] = _raise_uninitialized_error
        self.__dict__["_GetPowerEfficiencyEquation"] = _raise_uninitialized_error
        self.__dict__["_GetInputPowerSourceName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAEngineDefinition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAEngineDefinition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAEngineDefinition = agcom.GUID(IVAEngineDefinition._uuid)
        vtable_offset_local = IVAEngineDefinition._vtable_offset - 1
        self.__dict__["_GetIspC0"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetIspC0"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetIspC1"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetIspC1"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetIspC2"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetIspC2"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetIspC3"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetIspC3"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetMassFlowRateEquationType"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_SetMassFlowRateEquationType"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_GetMassFlowRateC0"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMassFlowRateC0"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetMassFlowRateC1"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMassFlowRateC1"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetMassFlowRateC2"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMassFlowRateC2"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_GetMassFlowRateC3"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMassFlowRateC3"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_GetMassFlowRateEquation"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+19, POINTER(agcom.BSTR))
        self.__dict__["_GetMassFlowEfficiencyC0"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+20, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMassFlowEfficiencyC0"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+21, agcom.DOUBLE)
        self.__dict__["_GetMassFlowEfficiencyC1"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+22, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMassFlowEfficiencyC1"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+23, agcom.DOUBLE)
        self.__dict__["_GetMassFlowEfficiencyC2"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+24, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMassFlowEfficiencyC2"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+25, agcom.DOUBLE)
        self.__dict__["_GetMassFlowEfficiencyC3"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+26, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMassFlowEfficiencyC3"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+27, agcom.DOUBLE)
        self.__dict__["_GetMassFlowEfficiencyIndependentVar"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+28, POINTER(agcom.LONG))
        self.__dict__["_SetMassFlowEfficiencyIndependentVar"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+29, agcom.LONG)
        self.__dict__["_GetMassFlowEfficiencyEquation"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+30, POINTER(agcom.BSTR))
        self.__dict__["_GetPowerEfficiencyC0"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+31, POINTER(agcom.DOUBLE))
        self.__dict__["_SetPowerEfficiencyC0"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+32, agcom.DOUBLE)
        self.__dict__["_GetPowerEfficiencyC1"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+33, POINTER(agcom.DOUBLE))
        self.__dict__["_SetPowerEfficiencyC1"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+34, agcom.DOUBLE)
        self.__dict__["_GetPowerEfficiencyC2"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+35, POINTER(agcom.DOUBLE))
        self.__dict__["_SetPowerEfficiencyC2"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+36, agcom.DOUBLE)
        self.__dict__["_GetPowerEfficiencyC3"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+37, POINTER(agcom.DOUBLE))
        self.__dict__["_SetPowerEfficiencyC3"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+38, agcom.DOUBLE)
        self.__dict__["_GetPowerEfficiencyIndependentVar"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+39, POINTER(agcom.LONG))
        self.__dict__["_SetPowerEfficiencyIndependentVar"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+40, agcom.LONG)
        self.__dict__["_GetPowerEfficiencyEquation"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+41, POINTER(agcom.BSTR))
        self.__dict__["_GetInputPowerSourceName"] = IAGFUNCTYPE(pUnk, IID_IVAEngineDefinition, vtable_offset_local+42, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAEngineDefinition.__dict__ and type(IVAEngineDefinition.__dict__[attrname]) == property:
            return IVAEngineDefinition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAEngineDefinition.")
    
    @property
    def IspC0(self) -> float:
        """The constant coefficient (C0). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetIspC0"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @IspC0.setter
    def IspC0(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetIspC0"](arg_inVal.COM_val))

    @property
    def IspC1(self) -> float:
        """The linear coefficient (C1). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetIspC1"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @IspC1.setter
    def IspC1(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetIspC1"](arg_inVal.COM_val))

    @property
    def IspC2(self) -> float:
        """The quadratic coefficient (C2). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetIspC2"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @IspC2.setter
    def IspC2(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetIspC2"](arg_inVal.COM_val))

    @property
    def IspC3(self) -> float:
        """The cubic coefficient (C3). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetIspC3"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @IspC3.setter
    def IspC3(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetIspC3"](arg_inVal.COM_val))

    @property
    def MassFlowRateEquationType(self) -> "AgEVAEngineModelFunction":
        """The independent variable for the mass flow rate equation."""
        with agmarshall.AgEnum_arg(AgEVAEngineModelFunction) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMassFlowRateEquationType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MassFlowRateEquationType.setter
    def MassFlowRateEquationType(self, inVal:"AgEVAEngineModelFunction") -> None:
        with agmarshall.AgEnum_arg(AgEVAEngineModelFunction, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMassFlowRateEquationType"](arg_inVal.COM_val))

    @property
    def MassFlowRateC0(self) -> float:
        """The constant coefficient (C0). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMassFlowRateC0"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MassFlowRateC0.setter
    def MassFlowRateC0(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMassFlowRateC0"](arg_inVal.COM_val))

    @property
    def MassFlowRateC1(self) -> float:
        """The linear coefficient (C1). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMassFlowRateC1"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MassFlowRateC1.setter
    def MassFlowRateC1(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMassFlowRateC1"](arg_inVal.COM_val))

    @property
    def MassFlowRateC2(self) -> float:
        """The quadratic coefficient (C2). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMassFlowRateC2"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MassFlowRateC2.setter
    def MassFlowRateC2(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMassFlowRateC2"](arg_inVal.COM_val))

    @property
    def MassFlowRateC3(self) -> float:
        """The cubic coefficient (C3). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMassFlowRateC3"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MassFlowRateC3.setter
    def MassFlowRateC3(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMassFlowRateC3"](arg_inVal.COM_val))

    @property
    def MassFlowRateEquation(self) -> str:
        """The equation for mass flow rate."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMassFlowRateEquation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def MassFlowEfficiencyC0(self) -> float:
        """The constant coefficient (C0). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMassFlowEfficiencyC0"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MassFlowEfficiencyC0.setter
    def MassFlowEfficiencyC0(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMassFlowEfficiencyC0"](arg_inVal.COM_val))

    @property
    def MassFlowEfficiencyC1(self) -> float:
        """The linear coefficient (C1). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMassFlowEfficiencyC1"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MassFlowEfficiencyC1.setter
    def MassFlowEfficiencyC1(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMassFlowEfficiencyC1"](arg_inVal.COM_val))

    @property
    def MassFlowEfficiencyC2(self) -> float:
        """The quadratic coefficient (C2). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMassFlowEfficiencyC2"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MassFlowEfficiencyC2.setter
    def MassFlowEfficiencyC2(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMassFlowEfficiencyC2"](arg_inVal.COM_val))

    @property
    def MassFlowEfficiencyC3(self) -> float:
        """The cubic coefficient (C3). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMassFlowEfficiencyC3"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MassFlowEfficiencyC3.setter
    def MassFlowEfficiencyC3(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMassFlowEfficiencyC3"](arg_inVal.COM_val))

    @property
    def MassFlowEfficiencyIndependentVar(self) -> "AgEVAEngineModelFunction":
        """The independent variable for the mass flow efficiency equation."""
        with agmarshall.AgEnum_arg(AgEVAEngineModelFunction) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMassFlowEfficiencyIndependentVar"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MassFlowEfficiencyIndependentVar.setter
    def MassFlowEfficiencyIndependentVar(self, inVal:"AgEVAEngineModelFunction") -> None:
        with agmarshall.AgEnum_arg(AgEVAEngineModelFunction, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMassFlowEfficiencyIndependentVar"](arg_inVal.COM_val))

    @property
    def MassFlowEfficiencyEquation(self) -> str:
        """The equation for mass flow efficiency."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMassFlowEfficiencyEquation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def PowerEfficiencyC0(self) -> float:
        """The constant coefficient (C0). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPowerEfficiencyC0"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @PowerEfficiencyC0.setter
    def PowerEfficiencyC0(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetPowerEfficiencyC0"](arg_inVal.COM_val))

    @property
    def PowerEfficiencyC1(self) -> float:
        """The linear coefficient (C1). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPowerEfficiencyC1"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @PowerEfficiencyC1.setter
    def PowerEfficiencyC1(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetPowerEfficiencyC1"](arg_inVal.COM_val))

    @property
    def PowerEfficiencyC2(self) -> float:
        """The quadratic coefficient (C2). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPowerEfficiencyC2"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @PowerEfficiencyC2.setter
    def PowerEfficiencyC2(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetPowerEfficiencyC2"](arg_inVal.COM_val))

    @property
    def PowerEfficiencyC3(self) -> float:
        """The cubic coefficient (C3). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPowerEfficiencyC3"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @PowerEfficiencyC3.setter
    def PowerEfficiencyC3(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetPowerEfficiencyC3"](arg_inVal.COM_val))

    @property
    def PowerEfficiencyIndependentVar(self) -> "AgEVAEngineModelFunction":
        """The independent variable for the power efficiency equation."""
        with agmarshall.AgEnum_arg(AgEVAEngineModelFunction) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPowerEfficiencyIndependentVar"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @PowerEfficiencyIndependentVar.setter
    def PowerEfficiencyIndependentVar(self, inVal:"AgEVAEngineModelFunction") -> None:
        with agmarshall.AgEnum_arg(AgEVAEngineModelFunction, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetPowerEfficiencyIndependentVar"](arg_inVal.COM_val))

    @property
    def PowerEfficiencyEquation(self) -> str:
        """The equation for power efficiency."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPowerEfficiencyEquation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def InputPowerSourceName(self) -> str:
        """Object that computes the power input to the engine"""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetInputPowerSourceName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{74BF5209-9E9B-45E3-8AE0-E68971558447}", IVAEngineDefinition)
agcls.AgTypeNameMap["IVAEngineDefinition"] = IVAEngineDefinition

class IVAEngineThrottleTable(object):
    """Properties for engine parameters for a Throttle Table engine model"""
    _uuid = "{74EFDF26-3F92-4664-8CA1-47E86FCAB002}"
    _num_methods = 18
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetThrottleTableFilename"] = _raise_uninitialized_error
        self.__dict__["_SetThrottleTableFilename"] = _raise_uninitialized_error
        self.__dict__["_GetOperationModeDefinition"] = _raise_uninitialized_error
        self.__dict__["_SetOperationModeDefinition"] = _raise_uninitialized_error
        self.__dict__["_GetRegressionPolynomialDegree"] = _raise_uninitialized_error
        self.__dict__["_SetRegressionPolynomialDegree"] = _raise_uninitialized_error
        self.__dict__["_Getg"] = _raise_uninitialized_error
        self.__dict__["_Setg"] = _raise_uninitialized_error
        self.__dict__["_GetInputPowerSourceName"] = _raise_uninitialized_error
        self.__dict__["_SetInputPowerSourceName"] = _raise_uninitialized_error
        self.__dict__["_GetPercentDegradationPerYear"] = _raise_uninitialized_error
        self.__dict__["_SetPercentDegradationPerYear"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceEpoch"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceEpoch"] = _raise_uninitialized_error
        self.__dict__["_EnableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_DisableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_IsControlParameterEnabled"] = _raise_uninitialized_error
        self.__dict__["_GetControlParametersAvailable"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAEngineThrottleTable._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAEngineThrottleTable from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAEngineThrottleTable = agcom.GUID(IVAEngineThrottleTable._uuid)
        vtable_offset_local = IVAEngineThrottleTable._vtable_offset - 1
        self.__dict__["_GetThrottleTableFilename"] = IAGFUNCTYPE(pUnk, IID_IVAEngineThrottleTable, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetThrottleTableFilename"] = IAGFUNCTYPE(pUnk, IID_IVAEngineThrottleTable, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetOperationModeDefinition"] = IAGFUNCTYPE(pUnk, IID_IVAEngineThrottleTable, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_SetOperationModeDefinition"] = IAGFUNCTYPE(pUnk, IID_IVAEngineThrottleTable, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_GetRegressionPolynomialDegree"] = IAGFUNCTYPE(pUnk, IID_IVAEngineThrottleTable, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetRegressionPolynomialDegree"] = IAGFUNCTYPE(pUnk, IID_IVAEngineThrottleTable, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_Getg"] = IAGFUNCTYPE(pUnk, IID_IVAEngineThrottleTable, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_Setg"] = IAGFUNCTYPE(pUnk, IID_IVAEngineThrottleTable, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetInputPowerSourceName"] = IAGFUNCTYPE(pUnk, IID_IVAEngineThrottleTable, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_SetInputPowerSourceName"] = IAGFUNCTYPE(pUnk, IID_IVAEngineThrottleTable, vtable_offset_local+10, agcom.BSTR)
        self.__dict__["_GetPercentDegradationPerYear"] = IAGFUNCTYPE(pUnk, IID_IVAEngineThrottleTable, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetPercentDegradationPerYear"] = IAGFUNCTYPE(pUnk, IID_IVAEngineThrottleTable, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetReferenceEpoch"] = IAGFUNCTYPE(pUnk, IID_IVAEngineThrottleTable, vtable_offset_local+13, POINTER(agcom.VARIANT))
        self.__dict__["_SetReferenceEpoch"] = IAGFUNCTYPE(pUnk, IID_IVAEngineThrottleTable, vtable_offset_local+14, agcom.VARIANT)
        self.__dict__["_EnableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAEngineThrottleTable, vtable_offset_local+15, agcom.LONG)
        self.__dict__["_DisableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAEngineThrottleTable, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_IsControlParameterEnabled"] = IAGFUNCTYPE(pUnk, IID_IVAEngineThrottleTable, vtable_offset_local+17, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetControlParametersAvailable"] = IAGFUNCTYPE(pUnk, IID_IVAEngineThrottleTable, vtable_offset_local+18, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAEngineThrottleTable.__dict__ and type(IVAEngineThrottleTable.__dict__[attrname]) == property:
            return IVAEngineThrottleTable.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAEngineThrottleTable.")
    
    @property
    def ThrottleTableFilename(self) -> str:
        """A file containing the engine performance data in the tabular format."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetThrottleTableFilename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ThrottleTableFilename.setter
    def ThrottleTableFilename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetThrottleTableFilename"](arg_inVal.COM_val))

    @property
    def OperationModeDefinition(self) -> "AgEVAThrottleTableOperationMode":
        """The engine operation mode definition."""
        with agmarshall.AgEnum_arg(AgEVAThrottleTableOperationMode) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetOperationModeDefinition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @OperationModeDefinition.setter
    def OperationModeDefinition(self, inVal:"AgEVAThrottleTableOperationMode") -> None:
        with agmarshall.AgEnum_arg(AgEVAThrottleTableOperationMode, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetOperationModeDefinition"](arg_inVal.COM_val))

    @property
    def RegressionPolynomialDegree(self) -> int:
        """The degree of the regression polynomial. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRegressionPolynomialDegree"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RegressionPolynomialDegree.setter
    def RegressionPolynomialDegree(self, inVal:int) -> None:
        with agmarshall.LONG_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetRegressionPolynomialDegree"](arg_inVal.COM_val))

    @property
    def g(self) -> float:
        """The gravitational acceleration constant at sea level on the Earth. Uses Acceleration Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_Getg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @g.setter
    def g(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_Setg"](arg_inVal.COM_val))

    @property
    def InputPowerSourceName(self) -> str:
        """The object that computes the power input to the engine."""
        with agmarshall.BSTR_arg() as arg_pPowerSource:
            agcls.evaluate_hresult(self.__dict__["_GetInputPowerSourceName"](byref(arg_pPowerSource.COM_val)))
            return arg_pPowerSource.python_val

    @InputPowerSourceName.setter
    def InputPowerSourceName(self, powerSource:str) -> None:
        with agmarshall.BSTR_arg(powerSource) as arg_powerSource:
            agcls.evaluate_hresult(self.__dict__["_SetInputPowerSourceName"](arg_powerSource.COM_val))

    @property
    def PercentDegradationPerYear(self) -> float:
        """The degradation factor is (1-x%/yr)^(timeSinceRefEpoch)"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPercentDegradationPerYear"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @PercentDegradationPerYear.setter
    def PercentDegradationPerYear(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetPercentDegradationPerYear"](arg_inVal.COM_val))

    @property
    def ReferenceEpoch(self) -> typing.Any:
        """The date and Time used as reference epoch for degradation. Uses DateFormat Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceEpoch"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ReferenceEpoch.setter
    def ReferenceEpoch(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceEpoch"](arg_inVal.COM_val))

    def EnableControlParameter(self, param:"AgEVAControlEngineThrottleTable") -> None:
        """Enables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlEngineThrottleTable, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_EnableControlParameter"](arg_param.COM_val))

    def DisableControlParameter(self, param:"AgEVAControlEngineThrottleTable") -> None:
        """Disables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlEngineThrottleTable, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_DisableControlParameter"](arg_param.COM_val))

    def IsControlParameterEnabled(self, param:"AgEVAControlEngineThrottleTable") -> bool:
        """Sees if the specified control is enabled."""
        with agmarshall.AgEnum_arg(AgEVAControlEngineThrottleTable, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_IsControlParameterEnabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ControlParametersAvailable(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetControlParametersAvailable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{74EFDF26-3F92-4664-8CA1-47E86FCAB002}", IVAEngineThrottleTable)
agcls.AgTypeNameMap["IVAEngineThrottleTable"] = IVAEngineThrottleTable

class IVAEngineIon(object):
    """Properties for engine parameters for an Ion engine model"""
    _uuid = "{1A331BF6-2901-41F4-8A68-23DD4628A68D}"
    _num_methods = 19
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Getg"] = _raise_uninitialized_error
        self.__dict__["_Setg"] = _raise_uninitialized_error
        self.__dict__["_GetInputPowerSourceName"] = _raise_uninitialized_error
        self.__dict__["_SetInputPowerSourceName"] = _raise_uninitialized_error
        self.__dict__["_GetMinRequiredPower"] = _raise_uninitialized_error
        self.__dict__["_SetMinRequiredPower"] = _raise_uninitialized_error
        self.__dict__["_GetMaxInputPower"] = _raise_uninitialized_error
        self.__dict__["_SetMaxInputPower"] = _raise_uninitialized_error
        self.__dict__["_GetPercentDegradationPerYear"] = _raise_uninitialized_error
        self.__dict__["_SetPercentDegradationPerYear"] = _raise_uninitialized_error
        self.__dict__["_GetReferenceEpoch"] = _raise_uninitialized_error
        self.__dict__["_SetReferenceEpoch"] = _raise_uninitialized_error
        self.__dict__["_GetPercentThrottle"] = _raise_uninitialized_error
        self.__dict__["_SetPercentThrottle"] = _raise_uninitialized_error
        self.__dict__["_GetEngineDefinition"] = _raise_uninitialized_error
        self.__dict__["_EnableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_DisableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_IsControlParameterEnabled"] = _raise_uninitialized_error
        self.__dict__["_GetControlParametersAvailable"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAEngineIon._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAEngineIon from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAEngineIon = agcom.GUID(IVAEngineIon._uuid)
        vtable_offset_local = IVAEngineIon._vtable_offset - 1
        self.__dict__["_Getg"] = IAGFUNCTYPE(pUnk, IID_IVAEngineIon, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_Setg"] = IAGFUNCTYPE(pUnk, IID_IVAEngineIon, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetInputPowerSourceName"] = IAGFUNCTYPE(pUnk, IID_IVAEngineIon, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetInputPowerSourceName"] = IAGFUNCTYPE(pUnk, IID_IVAEngineIon, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_GetMinRequiredPower"] = IAGFUNCTYPE(pUnk, IID_IVAEngineIon, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMinRequiredPower"] = IAGFUNCTYPE(pUnk, IID_IVAEngineIon, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_GetMaxInputPower"] = IAGFUNCTYPE(pUnk, IID_IVAEngineIon, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaxInputPower"] = IAGFUNCTYPE(pUnk, IID_IVAEngineIon, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetPercentDegradationPerYear"] = IAGFUNCTYPE(pUnk, IID_IVAEngineIon, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetPercentDegradationPerYear"] = IAGFUNCTYPE(pUnk, IID_IVAEngineIon, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetReferenceEpoch"] = IAGFUNCTYPE(pUnk, IID_IVAEngineIon, vtable_offset_local+11, POINTER(agcom.VARIANT))
        self.__dict__["_SetReferenceEpoch"] = IAGFUNCTYPE(pUnk, IID_IVAEngineIon, vtable_offset_local+12, agcom.VARIANT)
        self.__dict__["_GetPercentThrottle"] = IAGFUNCTYPE(pUnk, IID_IVAEngineIon, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetPercentThrottle"] = IAGFUNCTYPE(pUnk, IID_IVAEngineIon, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetEngineDefinition"] = IAGFUNCTYPE(pUnk, IID_IVAEngineIon, vtable_offset_local+15, POINTER(agcom.PVOID))
        self.__dict__["_EnableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAEngineIon, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_DisableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAEngineIon, vtable_offset_local+17, agcom.LONG)
        self.__dict__["_IsControlParameterEnabled"] = IAGFUNCTYPE(pUnk, IID_IVAEngineIon, vtable_offset_local+18, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetControlParametersAvailable"] = IAGFUNCTYPE(pUnk, IID_IVAEngineIon, vtable_offset_local+19, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAEngineIon.__dict__ and type(IVAEngineIon.__dict__[attrname]) == property:
            return IVAEngineIon.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAEngineIon.")
    
    @property
    def g(self) -> float:
        """The gravitational acceleration constant at sea level on the Earth. Uses Acceleration Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_Getg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @g.setter
    def g(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_Setg"](arg_inVal.COM_val))

    @property
    def InputPowerSourceName(self) -> str:
        """The object that computes the power input to the engine."""
        with agmarshall.BSTR_arg() as arg_pPowerSource:
            agcls.evaluate_hresult(self.__dict__["_GetInputPowerSourceName"](byref(arg_pPowerSource.COM_val)))
            return arg_pPowerSource.python_val

    @InputPowerSourceName.setter
    def InputPowerSourceName(self, powerSource:str) -> None:
        with agmarshall.BSTR_arg(powerSource) as arg_powerSource:
            agcls.evaluate_hresult(self.__dict__["_SetInputPowerSourceName"](arg_powerSource.COM_val))

    @property
    def MinRequiredPower(self) -> float:
        """The minimum power required for engine to produce thrust. Uses Power Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinRequiredPower"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MinRequiredPower.setter
    def MinRequiredPower(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMinRequiredPower"](arg_inVal.COM_val))

    @property
    def MaxInputPower(self) -> float:
        """The maximum power that can be used by engine to produce thrust. Uses Power Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxInputPower"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxInputPower.setter
    def MaxInputPower(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxInputPower"](arg_inVal.COM_val))

    @property
    def PercentDegradationPerYear(self) -> float:
        """The degradation factor is (1-x%/yr)^(timeSinceRefEpoch)"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPercentDegradationPerYear"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @PercentDegradationPerYear.setter
    def PercentDegradationPerYear(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetPercentDegradationPerYear"](arg_inVal.COM_val))

    @property
    def ReferenceEpoch(self) -> typing.Any:
        """The date and Time used as reference epoch for degradation. Uses DateFormat Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetReferenceEpoch"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ReferenceEpoch.setter
    def ReferenceEpoch(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetReferenceEpoch"](arg_inVal.COM_val))

    @property
    def PercentThrottle(self) -> float:
        """The percentage of available thrust to use (100 is full on, 0 is off). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPercentThrottle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @PercentThrottle.setter
    def PercentThrottle(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetPercentThrottle"](arg_inVal.COM_val))

    @property
    def EngineDefinition(self) -> "IVAEngineDefinition":
        """The engine definition."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAEngineDefinition:
            agcls.evaluate_hresult(self.__dict__["_GetEngineDefinition"](byref(arg_ppVAEngineDefinition.COM_val)))
            return arg_ppVAEngineDefinition.python_val

    def EnableControlParameter(self, param:"AgEVAControlEngineIon") -> None:
        """Enables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlEngineIon, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_EnableControlParameter"](arg_param.COM_val))

    def DisableControlParameter(self, param:"AgEVAControlEngineIon") -> None:
        """Disables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlEngineIon, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_DisableControlParameter"](arg_param.COM_val))

    def IsControlParameterEnabled(self, param:"AgEVAControlEngineIon") -> bool:
        """Sees if the specified control is enabled."""
        with agmarshall.AgEnum_arg(AgEVAControlEngineIon, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_IsControlParameterEnabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ControlParametersAvailable(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetControlParametersAvailable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{1A331BF6-2901-41F4-8A68-23DD4628A68D}", IVAEngineIon)
agcls.AgTypeNameMap["IVAEngineIon"] = IVAEngineIon

class IVAEngineCustom(object):
    """Properties for a Custom engine model."""
    _uuid = "{E17088BF-A34C-4C6B-8BF2-CEA2D489B428}"
    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Getg"] = _raise_uninitialized_error
        self.__dict__["_Setg"] = _raise_uninitialized_error
        self.__dict__["_GetEvalFunctionName"] = _raise_uninitialized_error
        self.__dict__["_SetEvalFunctionName"] = _raise_uninitialized_error
        self.__dict__["_GetPostFunctionName"] = _raise_uninitialized_error
        self.__dict__["_SetPostFunctionName"] = _raise_uninitialized_error
        self.__dict__["_GetPreFunctionName"] = _raise_uninitialized_error
        self.__dict__["_SetPreFunctionName"] = _raise_uninitialized_error
        self.__dict__["_GetSegStartFunctionName"] = _raise_uninitialized_error
        self.__dict__["_SetSegStartFunctionName"] = _raise_uninitialized_error
        self.__dict__["_GetUpdateFunctionName"] = _raise_uninitialized_error
        self.__dict__["_SetUpdateFunctionName"] = _raise_uninitialized_error
        self.__dict__["_EnableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_DisableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_IsControlParameterEnabled"] = _raise_uninitialized_error
        self.__dict__["_GetControlParametersAvailable"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAEngineCustom._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAEngineCustom from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAEngineCustom = agcom.GUID(IVAEngineCustom._uuid)
        vtable_offset_local = IVAEngineCustom._vtable_offset - 1
        self.__dict__["_Getg"] = IAGFUNCTYPE(pUnk, IID_IVAEngineCustom, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_Setg"] = IAGFUNCTYPE(pUnk, IID_IVAEngineCustom, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetEvalFunctionName"] = IAGFUNCTYPE(pUnk, IID_IVAEngineCustom, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetEvalFunctionName"] = IAGFUNCTYPE(pUnk, IID_IVAEngineCustom, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_GetPostFunctionName"] = IAGFUNCTYPE(pUnk, IID_IVAEngineCustom, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_SetPostFunctionName"] = IAGFUNCTYPE(pUnk, IID_IVAEngineCustom, vtable_offset_local+6, agcom.BSTR)
        self.__dict__["_GetPreFunctionName"] = IAGFUNCTYPE(pUnk, IID_IVAEngineCustom, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_SetPreFunctionName"] = IAGFUNCTYPE(pUnk, IID_IVAEngineCustom, vtable_offset_local+8, agcom.BSTR)
        self.__dict__["_GetSegStartFunctionName"] = IAGFUNCTYPE(pUnk, IID_IVAEngineCustom, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_SetSegStartFunctionName"] = IAGFUNCTYPE(pUnk, IID_IVAEngineCustom, vtable_offset_local+10, agcom.BSTR)
        self.__dict__["_GetUpdateFunctionName"] = IAGFUNCTYPE(pUnk, IID_IVAEngineCustom, vtable_offset_local+11, POINTER(agcom.BSTR))
        self.__dict__["_SetUpdateFunctionName"] = IAGFUNCTYPE(pUnk, IID_IVAEngineCustom, vtable_offset_local+12, agcom.BSTR)
        self.__dict__["_EnableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAEngineCustom, vtable_offset_local+13, agcom.LONG)
        self.__dict__["_DisableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAEngineCustom, vtable_offset_local+14, agcom.LONG)
        self.__dict__["_IsControlParameterEnabled"] = IAGFUNCTYPE(pUnk, IID_IVAEngineCustom, vtable_offset_local+15, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetControlParametersAvailable"] = IAGFUNCTYPE(pUnk, IID_IVAEngineCustom, vtable_offset_local+16, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAEngineCustom.__dict__ and type(IVAEngineCustom.__dict__[attrname]) == property:
            return IVAEngineCustom.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAEngineCustom.")
    
    @property
    def g(self) -> float:
        """The earth surface gravity acceleration for Isp conversions. Uses Acceleration Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_Getg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @g.setter
    def g(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_Setg"](arg_inVal.COM_val))

    @property
    def EvalFunctionName(self) -> str:
        """The EvalFunction - custom function to call at every thrust evaluation."""
        with agmarshall.BSTR_arg() as arg_pEvalFunction:
            agcls.evaluate_hresult(self.__dict__["_GetEvalFunctionName"](byref(arg_pEvalFunction.COM_val)))
            return arg_pEvalFunction.python_val

    @EvalFunctionName.setter
    def EvalFunctionName(self, evalFunction:str) -> None:
        with agmarshall.BSTR_arg(evalFunction) as arg_evalFunction:
            agcls.evaluate_hresult(self.__dict__["_SetEvalFunctionName"](arg_evalFunction.COM_val))

    @property
    def PostFunctionName(self) -> str:
        """The PostFunction - custom function to call after all propagation ends."""
        with agmarshall.BSTR_arg() as arg_pPostFunction:
            agcls.evaluate_hresult(self.__dict__["_GetPostFunctionName"](byref(arg_pPostFunction.COM_val)))
            return arg_pPostFunction.python_val

    @PostFunctionName.setter
    def PostFunctionName(self, postFunction:str) -> None:
        with agmarshall.BSTR_arg(postFunction) as arg_postFunction:
            agcls.evaluate_hresult(self.__dict__["_SetPostFunctionName"](arg_postFunction.COM_val))

    @property
    def PreFunctionName(self) -> str:
        """The PreFunction - custom function to call before any propagation begins."""
        with agmarshall.BSTR_arg() as arg_pPreFunction:
            agcls.evaluate_hresult(self.__dict__["_GetPreFunctionName"](byref(arg_pPreFunction.COM_val)))
            return arg_pPreFunction.python_val

    @PreFunctionName.setter
    def PreFunctionName(self, preFunction:str) -> None:
        with agmarshall.BSTR_arg(preFunction) as arg_preFunction:
            agcls.evaluate_hresult(self.__dict__["_SetPreFunctionName"](arg_preFunction.COM_val))

    @property
    def SegStartFunctionName(self) -> str:
        """The SegStartFunction - custom function to call at the beginning of each segment."""
        with agmarshall.BSTR_arg() as arg_pSegStartFunction:
            agcls.evaluate_hresult(self.__dict__["_GetSegStartFunctionName"](byref(arg_pSegStartFunction.COM_val)))
            return arg_pSegStartFunction.python_val

    @SegStartFunctionName.setter
    def SegStartFunctionName(self, segStartFunction:str) -> None:
        with agmarshall.BSTR_arg(segStartFunction) as arg_segStartFunction:
            agcls.evaluate_hresult(self.__dict__["_SetSegStartFunctionName"](arg_segStartFunction.COM_val))

    @property
    def UpdateFunctionName(self) -> str:
        """The UpdateFunction - custom function to call at the beginning of each integration step."""
        with agmarshall.BSTR_arg() as arg_pUpdateFunction:
            agcls.evaluate_hresult(self.__dict__["_GetUpdateFunctionName"](byref(arg_pUpdateFunction.COM_val)))
            return arg_pUpdateFunction.python_val

    @UpdateFunctionName.setter
    def UpdateFunctionName(self, updateFunction:str) -> None:
        with agmarshall.BSTR_arg(updateFunction) as arg_updateFunction:
            agcls.evaluate_hresult(self.__dict__["_SetUpdateFunctionName"](arg_updateFunction.COM_val))

    def EnableControlParameter(self, param:"AgEVAControlEngineCustom") -> None:
        """Enables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlEngineCustom, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_EnableControlParameter"](arg_param.COM_val))

    def DisableControlParameter(self, param:"AgEVAControlEngineCustom") -> None:
        """Disables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlEngineCustom, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_DisableControlParameter"](arg_param.COM_val))

    def IsControlParameterEnabled(self, param:"AgEVAControlEngineCustom") -> bool:
        """Sees if the specified control is enabled."""
        with agmarshall.AgEnum_arg(AgEVAControlEngineCustom, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_IsControlParameterEnabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ControlParametersAvailable(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetControlParametersAvailable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{E17088BF-A34C-4C6B-8BF2-CEA2D489B428}", IVAEngineCustom)
agcls.AgTypeNameMap["IVAEngineCustom"] = IVAEngineCustom

class IVAEnginePlugin(object):
    """Properties for a Plugin engine model."""
    _uuid = "{68ED720F-ABB6-4891-A1B9-973719400161}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Getg"] = _raise_uninitialized_error
        self.__dict__["_Setg"] = _raise_uninitialized_error
        self.__dict__["_GetPluginIdentifier"] = _raise_uninitialized_error
        self.__dict__["_SetPluginIdentifier"] = _raise_uninitialized_error
        self.__dict__["_GetPluginConfig"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAEnginePlugin._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAEnginePlugin from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAEnginePlugin = agcom.GUID(IVAEnginePlugin._uuid)
        vtable_offset_local = IVAEnginePlugin._vtable_offset - 1
        self.__dict__["_Getg"] = IAGFUNCTYPE(pUnk, IID_IVAEnginePlugin, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_Setg"] = IAGFUNCTYPE(pUnk, IID_IVAEnginePlugin, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetPluginIdentifier"] = IAGFUNCTYPE(pUnk, IID_IVAEnginePlugin, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetPluginIdentifier"] = IAGFUNCTYPE(pUnk, IID_IVAEnginePlugin, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_GetPluginConfig"] = IAGFUNCTYPE(pUnk, IID_IVAEnginePlugin, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAEnginePlugin.__dict__ and type(IVAEnginePlugin.__dict__[attrname]) == property:
            return IVAEnginePlugin.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAEnginePlugin.")
    
    @property
    def g(self) -> float:
        """The gravitational acceleration constant at sea level on the Earth. Uses Acceleration Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_Getg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @g.setter
    def g(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_Setg"](arg_inVal.COM_val))

    @property
    def PluginIdentifier(self) -> str:
        """The PluginIdentifier - the ProgID of the COM component you are using for this model."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetPluginIdentifier"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @PluginIdentifier.setter
    def PluginIdentifier(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetPluginIdentifier"](arg_inVal.COM_val))

    @property
    def PluginConfig(self) -> "IVAPluginProperties":
        """The properties of the plugin."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetPluginConfig"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{68ED720F-ABB6-4891-A1B9-973719400161}", IVAEnginePlugin)
agcls.AgTypeNameMap["IVAEnginePlugin"] = IVAEnginePlugin

class IVAEngineModelPoly(object):
    """Properties for a Polynomial Thrust and Isp engine model."""
    _uuid = "{4AC9E570-FB42-4636-B6DA-F9FEF353165B}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Getg"] = _raise_uninitialized_error
        self.__dict__["_Setg"] = _raise_uninitialized_error
        self.__dict__["_GetThrustCoefficients"] = _raise_uninitialized_error
        self.__dict__["_GetIspCoefficients"] = _raise_uninitialized_error
        self.__dict__["_EnableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_DisableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_IsControlParameterEnabled"] = _raise_uninitialized_error
        self.__dict__["_GetControlParametersAvailable"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAEngineModelPoly._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAEngineModelPoly from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAEngineModelPoly = agcom.GUID(IVAEngineModelPoly._uuid)
        vtable_offset_local = IVAEngineModelPoly._vtable_offset - 1
        self.__dict__["_Getg"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelPoly, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_Setg"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelPoly, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetThrustCoefficients"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelPoly, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetIspCoefficients"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelPoly, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_EnableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelPoly, vtable_offset_local+5, agcom.LONG)
        self.__dict__["_DisableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelPoly, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_IsControlParameterEnabled"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelPoly, vtable_offset_local+7, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetControlParametersAvailable"] = IAGFUNCTYPE(pUnk, IID_IVAEngineModelPoly, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAEngineModelPoly.__dict__ and type(IVAEngineModelPoly.__dict__[attrname]) == property:
            return IVAEngineModelPoly.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAEngineModelPoly.")
    
    @property
    def g(self) -> float:
        """The gravitational acceleration constant at sea level on the Earth. Uses Acceleration Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_Getg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @g.setter
    def g(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_Setg"](arg_inVal.COM_val))

    @property
    def ThrustCoefficients(self) -> "IVAEngineModelThrustCoefficients":
        """The thrust Coefficients."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAEngineModelThrustCoefficients:
            agcls.evaluate_hresult(self.__dict__["_GetThrustCoefficients"](byref(arg_ppVAEngineModelThrustCoefficients.COM_val)))
            return arg_ppVAEngineModelThrustCoefficients.python_val

    @property
    def IspCoefficients(self) -> "IVAEngineModelIspCoefficients":
        """The Isp Coefficients."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAEngineModelIspCoefficients:
            agcls.evaluate_hresult(self.__dict__["_GetIspCoefficients"](byref(arg_ppVAEngineModelIspCoefficients.COM_val)))
            return arg_ppVAEngineModelIspCoefficients.python_val

    def EnableControlParameter(self, param:"AgEVAControlEngineModelPoly") -> None:
        """Enables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlEngineModelPoly, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_EnableControlParameter"](arg_param.COM_val))

    def DisableControlParameter(self, param:"AgEVAControlEngineModelPoly") -> None:
        """Disables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlEngineModelPoly, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_DisableControlParameter"](arg_param.COM_val))

    def IsControlParameterEnabled(self, param:"AgEVAControlEngineModelPoly") -> bool:
        """Sees if the specified control is enabled."""
        with agmarshall.AgEnum_arg(AgEVAControlEngineModelPoly, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_IsControlParameterEnabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ControlParametersAvailable(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetControlParametersAvailable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{4AC9E570-FB42-4636-B6DA-F9FEF353165B}", IVAEngineModelPoly)
agcls.AgTypeNameMap["IVAEngineModelPoly"] = IVAEngineModelPoly

class IVAThruster(object):
    """Properties for individual thrusters."""
    _uuid = "{61A386B1-675B-4DB6-85B9-078760AB8339}"
    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetName"] = _raise_uninitialized_error
        self.__dict__["_SetName"] = _raise_uninitialized_error
        self.__dict__["_GetUserComment"] = _raise_uninitialized_error
        self.__dict__["_SetUserComment"] = _raise_uninitialized_error
        self.__dict__["_Copy"] = _raise_uninitialized_error
        self.__dict__["_GetEngineModelName"] = _raise_uninitialized_error
        self.__dict__["_SetEngineModelName"] = _raise_uninitialized_error
        self.__dict__["_GetThrusterEfficiency"] = _raise_uninitialized_error
        self.__dict__["_SetThrusterEfficiency"] = _raise_uninitialized_error
        self.__dict__["_GetEquivalentOnTime"] = _raise_uninitialized_error
        self.__dict__["_SetEquivalentOnTime"] = _raise_uninitialized_error
        self.__dict__["_GetThrusterDirection"] = _raise_uninitialized_error
        self.__dict__["_EnableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_DisableControlParameter"] = _raise_uninitialized_error
        self.__dict__["_IsControlParameterEnabled"] = _raise_uninitialized_error
        self.__dict__["_GetControlParametersAvailable"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAThruster._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAThruster from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAThruster = agcom.GUID(IVAThruster._uuid)
        vtable_offset_local = IVAThruster._vtable_offset - 1
        self.__dict__["_GetName"] = IAGFUNCTYPE(pUnk, IID_IVAThruster, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetName"] = IAGFUNCTYPE(pUnk, IID_IVAThruster, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetUserComment"] = IAGFUNCTYPE(pUnk, IID_IVAThruster, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetUserComment"] = IAGFUNCTYPE(pUnk, IID_IVAThruster, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_Copy"] = IAGFUNCTYPE(pUnk, IID_IVAThruster, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_GetEngineModelName"] = IAGFUNCTYPE(pUnk, IID_IVAThruster, vtable_offset_local+6, POINTER(agcom.BSTR))
        self.__dict__["_SetEngineModelName"] = IAGFUNCTYPE(pUnk, IID_IVAThruster, vtable_offset_local+7, agcom.BSTR)
        self.__dict__["_GetThrusterEfficiency"] = IAGFUNCTYPE(pUnk, IID_IVAThruster, vtable_offset_local+8, POINTER(agcom.DOUBLE))
        self.__dict__["_SetThrusterEfficiency"] = IAGFUNCTYPE(pUnk, IID_IVAThruster, vtable_offset_local+9, agcom.DOUBLE)
        self.__dict__["_GetEquivalentOnTime"] = IAGFUNCTYPE(pUnk, IID_IVAThruster, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_SetEquivalentOnTime"] = IAGFUNCTYPE(pUnk, IID_IVAThruster, vtable_offset_local+11, agcom.DOUBLE)
        self.__dict__["_GetThrusterDirection"] = IAGFUNCTYPE(pUnk, IID_IVAThruster, vtable_offset_local+12, POINTER(agcom.PVOID))
        self.__dict__["_EnableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAThruster, vtable_offset_local+13, agcom.LONG)
        self.__dict__["_DisableControlParameter"] = IAGFUNCTYPE(pUnk, IID_IVAThruster, vtable_offset_local+14, agcom.LONG)
        self.__dict__["_IsControlParameterEnabled"] = IAGFUNCTYPE(pUnk, IID_IVAThruster, vtable_offset_local+15, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_GetControlParametersAvailable"] = IAGFUNCTYPE(pUnk, IID_IVAThruster, vtable_offset_local+16, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAThruster.__dict__ and type(IVAThruster.__dict__[attrname]) == property:
            return IVAThruster.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAThruster.")
    
    @property
    def Name(self) -> str:
        """The thruster name."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Name.setter
    def Name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetName"](arg_inVal.COM_val))

    @property
    def UserComment(self) -> str:
        """A user comment."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUserComment"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UserComment.setter
    def UserComment(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUserComment"](arg_inVal.COM_val))

    def Copy(self) -> "IVAThruster":
        """Makes a copy of the specified thruster."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAThruster:
            agcls.evaluate_hresult(self.__dict__["_Copy"](byref(arg_ppVAThruster.COM_val)))
            return arg_ppVAThruster.python_val

    @property
    def EngineModelName(self) -> str:
        """The engine model."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEngineModelName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EngineModelName.setter
    def EngineModelName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetEngineModelName"](arg_inVal.COM_val))

    @property
    def ThrusterEfficiency(self) -> float:
        """The thruster efficiency. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetThrusterEfficiency"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ThrusterEfficiency.setter
    def ThrusterEfficiency(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetThrusterEfficiency"](arg_inVal.COM_val))

    @property
    def EquivalentOnTime(self) -> float:
        """The equivalent on-time percentage is a factor multiplied by the thrust. The thrust is applied continuously throughout the maneuver and is reduced by the percentage. The mass flow rate is likewise reduced. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetEquivalentOnTime"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @EquivalentOnTime.setter
    def EquivalentOnTime(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetEquivalentOnTime"](arg_inVal.COM_val))

    @property
    def ThrusterDirection(self) -> "IDirection":
        """A thruster direction value."""
        with agmarshall.AgInterface_out_arg() as arg_ppDirection:
            agcls.evaluate_hresult(self.__dict__["_GetThrusterDirection"](byref(arg_ppDirection.COM_val)))
            return arg_ppDirection.python_val

    def EnableControlParameter(self, param:"AgEVAControlThrusters") -> None:
        """Enables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlThrusters, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_EnableControlParameter"](arg_param.COM_val))

    def DisableControlParameter(self, param:"AgEVAControlThrusters") -> None:
        """Disables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlThrusters, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_DisableControlParameter"](arg_param.COM_val))

    def IsControlParameterEnabled(self, param:"AgEVAControlThrusters") -> bool:
        """Sees if the specified control is enabled."""
        with agmarshall.AgEnum_arg(AgEVAControlThrusters, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_IsControlParameterEnabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ControlParametersAvailable(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetControlParametersAvailable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{61A386B1-675B-4DB6-85B9-078760AB8339}", IVAThruster)
agcls.AgTypeNameMap["IVAThruster"] = IVAThruster

class IVAThrusterSetCollection(object):
    """The list of thrusters in a thruster set."""
    _uuid = "{C60E997C-7AF3-477B-8B8A-8E1CA0D55681}"
    _num_methods = 11
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_Add"] = _raise_uninitialized_error
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_RemoveAll"] = _raise_uninitialized_error
        self.__dict__["_Cut"] = _raise_uninitialized_error
        self.__dict__["_Paste"] = _raise_uninitialized_error
        self.__dict__["_InsertCopy"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAThrusterSetCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAThrusterSetCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAThrusterSetCollection = agcom.GUID(IVAThrusterSetCollection._uuid)
        vtable_offset_local = IVAThrusterSetCollection._vtable_offset - 1
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVAThrusterSetCollection, vtable_offset_local+1, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVAThrusterSetCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVAThrusterSetCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_Add"] = IAGFUNCTYPE(pUnk, IID_IVAThrusterSetCollection, vtable_offset_local+4, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IVAThrusterSetCollection, vtable_offset_local+5, agcom.VARIANT)
        self.__dict__["_RemoveAll"] = IAGFUNCTYPE(pUnk, IID_IVAThrusterSetCollection, vtable_offset_local+6, )
        self.__dict__["_Cut"] = IAGFUNCTYPE(pUnk, IID_IVAThrusterSetCollection, vtable_offset_local+7, agcom.VARIANT)
        self.__dict__["_Paste"] = IAGFUNCTYPE(pUnk, IID_IVAThrusterSetCollection, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_InsertCopy"] = IAGFUNCTYPE(pUnk, IID_IVAThrusterSetCollection, vtable_offset_local+9, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IVAThrusterSetCollection, vtable_offset_local+10, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IVAThrusterSetCollection, vtable_offset_local+11, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAThrusterSetCollection.__dict__ and type(IVAThrusterSetCollection.__dict__[attrname]) == property:
            return IVAThrusterSetCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAThrusterSetCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IVAThruster":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Item(self, indexOrName:typing.Any) -> "IVAThruster":
        """A property that allows you to iterate through the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppVAThruster:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppVAThruster.COM_val)))
            return arg_ppVAThruster.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """A property that allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Count(self) -> int:
        """The number of thrusters in the set."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def Add(self, thrusterName:str) -> "IVAThruster":
        """Adds a new thruster."""
        with agmarshall.BSTR_arg(thrusterName) as arg_thrusterName, \
             agmarshall.AgInterface_out_arg() as arg_ppVAThruster:
            agcls.evaluate_hresult(self.__dict__["_Add"](arg_thrusterName.COM_val, byref(arg_ppVAThruster.COM_val)))
            return arg_ppVAThruster.python_val

    def Remove(self, indexOrName:typing.Any) -> None:
        """Removes a specified thruster."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_indexOrName.COM_val))

    def RemoveAll(self) -> None:
        """Removes all thrusters."""
        agcls.evaluate_hresult(self.__dict__["_RemoveAll"]())

    def Cut(self, indexOrName:typing.Any) -> None:
        """Copies a thruster to the clipboard and removes the thruster from the list."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_Cut"](arg_indexOrName.COM_val))

    def Paste(self) -> "IVAThruster":
        """Pastes a thruster from the clipboard into the list."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAThruster:
            agcls.evaluate_hresult(self.__dict__["_Paste"](byref(arg_ppVAThruster.COM_val)))
            return arg_ppVAThruster.python_val

    def InsertCopy(self, thruster:"IVAThruster") -> "IVAThruster":
        """Copies a thruster and inserts the copy into the list."""
        with agmarshall.AgInterface_in_arg(thruster, IVAThruster) as arg_thruster, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_InsertCopy"](arg_thruster.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "IVAThruster":
        """Retrieves a thruster from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppVAThruster:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppVAThruster.COM_val)))
            return arg_ppVAThruster.python_val

    def GetItemByName(self, name:str) -> "IVAThruster":
        """Retrieves a thruster from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppVAThruster:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppVAThruster.COM_val)))
            return arg_ppVAThruster.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{C60E997C-7AF3-477B-8B8A-8E1CA0D55681}", IVAThrusterSetCollection)
agcls.AgTypeNameMap["IVAThrusterSetCollection"] = IVAThrusterSetCollection

class IVAThrusterSet(object):
    """The properties of a thruster set."""
    _uuid = "{AA4BEFC3-C3E6-4888-B920-109F57621589}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetDirectionDefinition"] = _raise_uninitialized_error
        self.__dict__["_SetDirectionDefinition"] = _raise_uninitialized_error
        self.__dict__["_GetThrusters"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAThrusterSet._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAThrusterSet from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAThrusterSet = agcom.GUID(IVAThrusterSet._uuid)
        vtable_offset_local = IVAThrusterSet._vtable_offset - 1
        self.__dict__["_GetDirectionDefinition"] = IAGFUNCTYPE(pUnk, IID_IVAThrusterSet, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetDirectionDefinition"] = IAGFUNCTYPE(pUnk, IID_IVAThrusterSet, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetThrusters"] = IAGFUNCTYPE(pUnk, IID_IVAThrusterSet, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAThrusterSet.__dict__ and type(IVAThrusterSet.__dict__[attrname]) == property:
            return IVAThrusterSet.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAThrusterSet.")
    
    @property
    def DirectionDefinition(self) -> "AgEVAThrusterDirection":
        """The thruster set direction definition."""
        with agmarshall.AgEnum_arg(AgEVAThrusterDirection) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetDirectionDefinition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @DirectionDefinition.setter
    def DirectionDefinition(self, inVal:"AgEVAThrusterDirection") -> None:
        with agmarshall.AgEnum_arg(AgEVAThrusterDirection, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetDirectionDefinition"](arg_inVal.COM_val))

    @property
    def Thrusters(self) -> "IVAThrusterSetCollection":
        """The list of thrusters."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAThrusterSetCollection:
            agcls.evaluate_hresult(self.__dict__["_GetThrusters"](byref(arg_ppVAThrusterSetCollection.COM_val)))
            return arg_ppVAThrusterSetCollection.python_val


agcls.AgClassCatalog.add_catalog_entry("{AA4BEFC3-C3E6-4888-B920-109F57621589}", IVAThrusterSet)
agcls.AgTypeNameMap["IVAThrusterSet"] = IVAThrusterSet

class IVAAsTriggerCondition(object):
    """Properties for a constraint - an additional condition to be met to satisfy a stopping condition."""
    _uuid = "{5670AC34-2864-42ED-B32A-5572363C0CE7}"
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCriteria"] = _raise_uninitialized_error
        self.__dict__["_SetCriteria"] = _raise_uninitialized_error
        self.__dict__["_GetCalcObject"] = _raise_uninitialized_error
        self.__dict__["_SetCalcObject"] = _raise_uninitialized_error
        self.__dict__["_GetCalcObjectName"] = _raise_uninitialized_error
        self.__dict__["_SetCalcObjectName"] = _raise_uninitialized_error
        self.__dict__["_GetValue"] = _raise_uninitialized_error
        self.__dict__["_SetValue"] = _raise_uninitialized_error
        self.__dict__["_GetTolerance"] = _raise_uninitialized_error
        self.__dict__["_SetTolerance"] = _raise_uninitialized_error
        self.__dict__["_GetUseAbsoluteValue"] = _raise_uninitialized_error
        self.__dict__["_SetUseAbsoluteValue"] = _raise_uninitialized_error
        self.__dict__["_CopyCalcObjectToClipboard"] = _raise_uninitialized_error
        self.__dict__["_PasteCalcObjectFromClipboard"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAAsTriggerCondition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAAsTriggerCondition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAAsTriggerCondition = agcom.GUID(IVAAsTriggerCondition._uuid)
        vtable_offset_local = IVAAsTriggerCondition._vtable_offset - 1
        self.__dict__["_GetCriteria"] = IAGFUNCTYPE(pUnk, IID_IVAAsTriggerCondition, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_SetCriteria"] = IAGFUNCTYPE(pUnk, IID_IVAAsTriggerCondition, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_GetCalcObject"] = IAGFUNCTYPE(pUnk, IID_IVAAsTriggerCondition, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_SetCalcObject"] = IAGFUNCTYPE(pUnk, IID_IVAAsTriggerCondition, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_GetCalcObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAAsTriggerCondition, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_SetCalcObjectName"] = IAGFUNCTYPE(pUnk, IID_IVAAsTriggerCondition, vtable_offset_local+6, agcom.BSTR)
        self.__dict__["_GetValue"] = IAGFUNCTYPE(pUnk, IID_IVAAsTriggerCondition, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_SetValue"] = IAGFUNCTYPE(pUnk, IID_IVAAsTriggerCondition, vtable_offset_local+8, agcom.VARIANT)
        self.__dict__["_GetTolerance"] = IAGFUNCTYPE(pUnk, IID_IVAAsTriggerCondition, vtable_offset_local+9, POINTER(agcom.VARIANT))
        self.__dict__["_SetTolerance"] = IAGFUNCTYPE(pUnk, IID_IVAAsTriggerCondition, vtable_offset_local+10, agcom.VARIANT)
        self.__dict__["_GetUseAbsoluteValue"] = IAGFUNCTYPE(pUnk, IID_IVAAsTriggerCondition, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseAbsoluteValue"] = IAGFUNCTYPE(pUnk, IID_IVAAsTriggerCondition, vtable_offset_local+12, agcom.VARIANT_BOOL)
        self.__dict__["_CopyCalcObjectToClipboard"] = IAGFUNCTYPE(pUnk, IID_IVAAsTriggerCondition, vtable_offset_local+13, )
        self.__dict__["_PasteCalcObjectFromClipboard"] = IAGFUNCTYPE(pUnk, IID_IVAAsTriggerCondition, vtable_offset_local+14, )
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAAsTriggerCondition.__dict__ and type(IVAAsTriggerCondition.__dict__[attrname]) == property:
            return IVAAsTriggerCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAAsTriggerCondition.")
    
    @property
    def Criteria(self) -> "AgEVACriteria":
        """The criteria to be applied to the desired value."""
        with agmarshall.AgEnum_arg(AgEVACriteria) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCriteria"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Criteria.setter
    def Criteria(self, inVal:"AgEVACriteria") -> None:
        with agmarshall.AgEnum_arg(AgEVACriteria, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCriteria"](arg_inVal.COM_val))

    @property
    def CalcObject(self) -> "IComponentInfo":
        """The calculation object to perform calculation to evaluate condition."""
        with agmarshall.AgInterface_out_arg() as arg_ppComponent:
            agcls.evaluate_hresult(self.__dict__["_GetCalcObject"](byref(arg_ppComponent.COM_val)))
            return arg_ppComponent.python_val

    @CalcObject.setter
    def CalcObject(self, inVal:"IComponentInfo") -> None:
        with agmarshall.AgInterface_in_arg(inVal, IComponentInfo) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCalcObject"](arg_inVal.COM_val))

    @property
    def CalcObjectName(self) -> str:
        """The name of the calculation object to perform calculation to evaluate condition."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetCalcObjectName"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @CalcObjectName.setter
    def CalcObjectName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCalcObjectName"](arg_inVal.COM_val))

    @property
    def Value(self) -> typing.Any:
        """The value to satisfy the condition. Dimension depends on CalcObject."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetValue"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Value.setter
    def Value(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetValue"](arg_inVal.COM_val))

    @property
    def Tolerance(self) -> typing.Any:
        """How closely the test parameter must approximate the desired value for the constraint. Dimension depends on CalcObject."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_GetTolerance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @Tolerance.setter
    def Tolerance(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetTolerance"](arg_inVal.COM_val))

    @property
    def UseAbsoluteValue(self) -> bool:
        """Whether or not to take the absolute value of the calculation."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseAbsoluteValue"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseAbsoluteValue.setter
    def UseAbsoluteValue(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseAbsoluteValue"](arg_inVal.COM_val))

    def CopyCalcObjectToClipboard(self) -> None:
        """Copy calculation object to clipboard."""
        agcls.evaluate_hresult(self.__dict__["_CopyCalcObjectToClipboard"]())

    def PasteCalcObjectFromClipboard(self) -> None:
        """Replace calculation object with instance in clipboard."""
        agcls.evaluate_hresult(self.__dict__["_PasteCalcObjectFromClipboard"]())


agcls.AgClassCatalog.add_catalog_entry("{5670AC34-2864-42ED-B32A-5572363C0CE7}", IVAAsTriggerCondition)
agcls.AgTypeNameMap["IVAAsTriggerCondition"] = IVAAsTriggerCondition

class IVACustomFunctionScriptEngine(object):
    """Properties for custom functions."""
    _uuid = "{02AA62BC-AA81-400C-83A0-961729880708}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetScriptFilename"] = _raise_uninitialized_error
        self.__dict__["_SetScriptFilename"] = _raise_uninitialized_error
        self.__dict__["_GetFileExtensionName"] = _raise_uninitialized_error
        self.__dict__["_SetFileExtensionName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVACustomFunctionScriptEngine._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVACustomFunctionScriptEngine from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVACustomFunctionScriptEngine = agcom.GUID(IVACustomFunctionScriptEngine._uuid)
        vtable_offset_local = IVACustomFunctionScriptEngine._vtable_offset - 1
        self.__dict__["_GetScriptFilename"] = IAGFUNCTYPE(pUnk, IID_IVACustomFunctionScriptEngine, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetScriptFilename"] = IAGFUNCTYPE(pUnk, IID_IVACustomFunctionScriptEngine, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetFileExtensionName"] = IAGFUNCTYPE(pUnk, IID_IVACustomFunctionScriptEngine, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_SetFileExtensionName"] = IAGFUNCTYPE(pUnk, IID_IVACustomFunctionScriptEngine, vtable_offset_local+4, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVACustomFunctionScriptEngine.__dict__ and type(IVACustomFunctionScriptEngine.__dict__[attrname]) == property:
            return IVACustomFunctionScriptEngine.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVACustomFunctionScriptEngine.")
    
    @property
    def ScriptFilename(self) -> str:
        """The file containing the function to call."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetScriptFilename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ScriptFilename.setter
    def ScriptFilename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetScriptFilename"](arg_inVal.COM_val))

    @property
    def FileExtensionName(self) -> str:
        """The file extension."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetFileExtensionName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @FileExtensionName.setter
    def FileExtensionName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetFileExtensionName"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{02AA62BC-AA81-400C-83A0-961729880708}", IVACustomFunctionScriptEngine)
agcls.AgTypeNameMap["IVACustomFunctionScriptEngine"] = IVACustomFunctionScriptEngine

class IVANumericalIntegrator(object):
    """The type of numerical integrator to be used by the propagator."""
    _uuid = "{5E802B1E-D8EF-4190-B238-7E0F4AFCA355}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVANumericalIntegrator._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVANumericalIntegrator from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVANumericalIntegrator = agcom.GUID(IVANumericalIntegrator._uuid)
        vtable_offset_local = IVANumericalIntegrator._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVANumericalIntegrator.__dict__ and type(IVANumericalIntegrator.__dict__[attrname]) == property:
            return IVANumericalIntegrator.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVANumericalIntegrator.")
    

agcls.AgClassCatalog.add_catalog_entry("{5E802B1E-D8EF-4190-B238-7E0F4AFCA355}", IVANumericalIntegrator)
agcls.AgTypeNameMap["IVANumericalIntegrator"] = IVANumericalIntegrator

class IVAPropagatorFunctionCollection(object):
    """The list of propagator functions - affecting forces that you want to model for orbit propagation."""
    _uuid = "{373180B3-D083-4CB1-ACC8-9D6C738F19E6}"
    _num_methods = 11
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_Add"] = _raise_uninitialized_error
        self.__dict__["_Item"] = _raise_uninitialized_error
        self.__dict__["_Remove"] = _raise_uninitialized_error
        self.__dict__["_Get_NewEnum"] = _raise_uninitialized_error
        self.__dict__["_GetCount"] = _raise_uninitialized_error
        self.__dict__["_RemoveAll"] = _raise_uninitialized_error
        self.__dict__["_Cut"] = _raise_uninitialized_error
        self.__dict__["_Paste"] = _raise_uninitialized_error
        self.__dict__["_InsertCopy"] = _raise_uninitialized_error
        self.__dict__["_GetItemByIndex"] = _raise_uninitialized_error
        self.__dict__["_GetItemByName"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAPropagatorFunctionCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAPropagatorFunctionCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAPropagatorFunctionCollection = agcom.GUID(IVAPropagatorFunctionCollection._uuid)
        vtable_offset_local = IVAPropagatorFunctionCollection._vtable_offset - 1
        self.__dict__["_Add"] = IAGFUNCTYPE(pUnk, IID_IVAPropagatorFunctionCollection, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_Item"] = IAGFUNCTYPE(pUnk, IID_IVAPropagatorFunctionCollection, vtable_offset_local+2, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_Remove"] = IAGFUNCTYPE(pUnk, IID_IVAPropagatorFunctionCollection, vtable_offset_local+3, agcom.VARIANT)
        self.__dict__["_Get_NewEnum"] = IAGFUNCTYPE(pUnk, IID_IVAPropagatorFunctionCollection, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetCount"] = IAGFUNCTYPE(pUnk, IID_IVAPropagatorFunctionCollection, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_RemoveAll"] = IAGFUNCTYPE(pUnk, IID_IVAPropagatorFunctionCollection, vtable_offset_local+6, )
        self.__dict__["_Cut"] = IAGFUNCTYPE(pUnk, IID_IVAPropagatorFunctionCollection, vtable_offset_local+7, agcom.VARIANT)
        self.__dict__["_Paste"] = IAGFUNCTYPE(pUnk, IID_IVAPropagatorFunctionCollection, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_InsertCopy"] = IAGFUNCTYPE(pUnk, IID_IVAPropagatorFunctionCollection, vtable_offset_local+9, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByIndex"] = IAGFUNCTYPE(pUnk, IID_IVAPropagatorFunctionCollection, vtable_offset_local+10, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_GetItemByName"] = IAGFUNCTYPE(pUnk, IID_IVAPropagatorFunctionCollection, vtable_offset_local+11, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAPropagatorFunctionCollection.__dict__ and type(IVAPropagatorFunctionCollection.__dict__[attrname]) == property:
            return IVAPropagatorFunctionCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAPropagatorFunctionCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IComponentInfo":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval)
    
    def Add(self, resultName:str) -> "IComponentInfo":
        """Adds a function to the collection."""
        with agmarshall.BSTR_arg(resultName) as arg_resultName, \
             agmarshall.AgInterface_out_arg() as arg_ppComponent:
            agcls.evaluate_hresult(self.__dict__["_Add"](arg_resultName.COM_val, byref(arg_ppComponent.COM_val)))
            return arg_ppComponent.python_val

    def Item(self, indexOrName:typing.Any) -> "IComponentInfo":
        """Allows you to iterate through the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppComponent:
            agcls.evaluate_hresult(self.__dict__["_Item"](arg_indexOrName.COM_val, byref(arg_ppComponent.COM_val)))
            return arg_ppComponent.python_val

    def Remove(self, indexOrName:typing.Any) -> None:
        """Removes the specified function from the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_Remove"](arg_indexOrName.COM_val))

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_Get_NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def Count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCount"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def RemoveAll(self) -> None:
        """Removes all functions from the collection."""
        agcls.evaluate_hresult(self.__dict__["_RemoveAll"]())

    def Cut(self, indexOrName:typing.Any) -> None:
        """Copies a propagator function to the clipboard and removes the propagator function from the list."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_Cut"](arg_indexOrName.COM_val))

    def Paste(self) -> "IComponentInfo":
        """Pastes a propagator function from the clipboard into the list."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAPropFunc:
            agcls.evaluate_hresult(self.__dict__["_Paste"](byref(arg_ppVAPropFunc.COM_val)))
            return arg_ppVAPropFunc.python_val

    def InsertCopy(self, propFunc:"IComponentInfo") -> "IComponentInfo":
        """Copies a propagator function and inserts the copy into the list."""
        with agmarshall.AgInterface_in_arg(propFunc, IComponentInfo) as arg_propFunc, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_InsertCopy"](arg_propFunc.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def GetItemByIndex(self, index:int) -> "IComponentInfo":
        """Retrieves a propagator function from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppComponent:
            agcls.evaluate_hresult(self.__dict__["_GetItemByIndex"](arg_index.COM_val, byref(arg_ppComponent.COM_val)))
            return arg_ppComponent.python_val

    def GetItemByName(self, name:str) -> "IComponentInfo":
        """Retrieves a propagator function from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppComponent:
            agcls.evaluate_hresult(self.__dict__["_GetItemByName"](arg_name.COM_val, byref(arg_ppComponent.COM_val)))
            return arg_ppComponent.python_val

    __getitem__ = Item



agcls.AgClassCatalog.add_catalog_entry("{373180B3-D083-4CB1-ACC8-9D6C738F19E6}", IVAPropagatorFunctionCollection)
agcls.AgTypeNameMap["IVAPropagatorFunctionCollection"] = IVAPropagatorFunctionCollection

class IVANumericalPropagatorWrapper(object):
    """General properties for propagators."""
    _uuid = "{5E7589D9-478E-4C8F-A856-2E548833C9C5}"
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetUseVariationOfParameters"] = _raise_uninitialized_error
        self.__dict__["_SetUseVariationOfParameters"] = _raise_uninitialized_error
        self.__dict__["_GetUseRegularizedTime"] = _raise_uninitialized_error
        self.__dict__["_SetUseRegularizedTime"] = _raise_uninitialized_error
        self.__dict__["_GetRegularizedTimeExponent"] = _raise_uninitialized_error
        self.__dict__["_SetRegularizedTimeExponent"] = _raise_uninitialized_error
        self.__dict__["_GetRegularizedTimeStepsPerOrbit"] = _raise_uninitialized_error
        self.__dict__["_SetRegularizedTimeStepsPerOrbit"] = _raise_uninitialized_error
        self.__dict__["_GetPropagatorFunctions"] = _raise_uninitialized_error
        self.__dict__["_GetNumericalIntegrator"] = _raise_uninitialized_error
        self.__dict__["_GetNumericalIntegratorType"] = _raise_uninitialized_error
        self.__dict__["_SetNumericalIntegrator"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVANumericalPropagatorWrapper._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVANumericalPropagatorWrapper from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVANumericalPropagatorWrapper = agcom.GUID(IVANumericalPropagatorWrapper._uuid)
        vtable_offset_local = IVANumericalPropagatorWrapper._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVANumericalPropagatorWrapper, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVANumericalPropagatorWrapper, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetUseVariationOfParameters"] = IAGFUNCTYPE(pUnk, IID_IVANumericalPropagatorWrapper, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseVariationOfParameters"] = IAGFUNCTYPE(pUnk, IID_IVANumericalPropagatorWrapper, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseRegularizedTime"] = IAGFUNCTYPE(pUnk, IID_IVANumericalPropagatorWrapper, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseRegularizedTime"] = IAGFUNCTYPE(pUnk, IID_IVANumericalPropagatorWrapper, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetRegularizedTimeExponent"] = IAGFUNCTYPE(pUnk, IID_IVANumericalPropagatorWrapper, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_SetRegularizedTimeExponent"] = IAGFUNCTYPE(pUnk, IID_IVANumericalPropagatorWrapper, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_GetRegularizedTimeStepsPerOrbit"] = IAGFUNCTYPE(pUnk, IID_IVANumericalPropagatorWrapper, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_SetRegularizedTimeStepsPerOrbit"] = IAGFUNCTYPE(pUnk, IID_IVANumericalPropagatorWrapper, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_GetPropagatorFunctions"] = IAGFUNCTYPE(pUnk, IID_IVANumericalPropagatorWrapper, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_GetNumericalIntegrator"] = IAGFUNCTYPE(pUnk, IID_IVANumericalPropagatorWrapper, vtable_offset_local+12, POINTER(agcom.PVOID))
        self.__dict__["_GetNumericalIntegratorType"] = IAGFUNCTYPE(pUnk, IID_IVANumericalPropagatorWrapper, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_SetNumericalIntegrator"] = IAGFUNCTYPE(pUnk, IID_IVANumericalPropagatorWrapper, vtable_offset_local+14, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVANumericalPropagatorWrapper.__dict__ and type(IVANumericalPropagatorWrapper.__dict__[attrname]) == property:
            return IVANumericalPropagatorWrapper.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVANumericalPropagatorWrapper.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body for Propagation."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def UseVariationOfParameters(self) -> bool:
        """Whether or not to use a variation of parameters(VOP) in universal variables formulation of the equations of motion; related to numerical integrator."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseVariationOfParameters"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseVariationOfParameters.setter
    def UseVariationOfParameters(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseVariationOfParameters"](arg_inVal.COM_val))

    @property
    def UseRegularizedTime(self) -> bool:
        """Whether or not to use regularized time; related to numerical integrator."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseRegularizedTime"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseRegularizedTime.setter
    def UseRegularizedTime(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseRegularizedTime"](arg_inVal.COM_val))

    @property
    def RegularizedTimeExponent(self) -> float:
        """The exponent to use in regularized time; related to numerical integrator. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRegularizedTimeExponent"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RegularizedTimeExponent.setter
    def RegularizedTimeExponent(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetRegularizedTimeExponent"](arg_inVal.COM_val))

    @property
    def RegularizedTimeStepsPerOrbit(self) -> int:
        """The steps per orbit used in regularized time; related to numerical integrator. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetRegularizedTimeStepsPerOrbit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @RegularizedTimeStepsPerOrbit.setter
    def RegularizedTimeStepsPerOrbit(self, inVal:int) -> None:
        with agmarshall.LONG_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetRegularizedTimeStepsPerOrbit"](arg_inVal.COM_val))

    @property
    def PropagatorFunctions(self) -> "IVAPropagatorFunctionCollection":
        """The list of propagator functions."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAPropagatorFunctionCollection:
            agcls.evaluate_hresult(self.__dict__["_GetPropagatorFunctions"](byref(arg_ppVAPropagatorFunctionCollection.COM_val)))
            return arg_ppVAPropagatorFunctionCollection.python_val

    @property
    def NumericalIntegrator(self) -> "IVANumericalIntegrator":
        """The numerical integrator."""
        with agmarshall.AgInterface_out_arg() as arg_ppVANumericalIntegrator:
            agcls.evaluate_hresult(self.__dict__["_GetNumericalIntegrator"](byref(arg_ppVANumericalIntegrator.COM_val)))
            return arg_ppVANumericalIntegrator.python_val

    @property
    def NumericalIntegratorType(self) -> "AgEVANumericalIntegrator":
        """The single step integrator type."""
        with agmarshall.AgEnum_arg(AgEVANumericalIntegrator) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNumericalIntegratorType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def SetNumericalIntegrator(self, integrator:"AgEVANumericalIntegrator") -> None:
        """Changes the single step integrator."""
        with agmarshall.AgEnum_arg(AgEVANumericalIntegrator, integrator) as arg_integrator:
            agcls.evaluate_hresult(self.__dict__["_SetNumericalIntegrator"](arg_integrator.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{5E7589D9-478E-4C8F-A856-2E548833C9C5}", IVANumericalPropagatorWrapper)
agcls.AgTypeNameMap["IVANumericalPropagatorWrapper"] = IVANumericalPropagatorWrapper

class IVANumericalPropagatorWrapperCR3BP(object):
    """General properties for three-body problem propagators."""
    _uuid = "{C0662E79-7987-4363-B97D-2277A12A7B5B}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_SetCentralBodyName"] = _raise_uninitialized_error
        self.__dict__["_GetPropagatorFunctions"] = _raise_uninitialized_error
        self.__dict__["_GetNumericalIntegrator"] = _raise_uninitialized_error
        self.__dict__["_GetNumericalIntegratorType"] = _raise_uninitialized_error
        self.__dict__["_SetNumericalIntegrator"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVANumericalPropagatorWrapperCR3BP._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVANumericalPropagatorWrapperCR3BP from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVANumericalPropagatorWrapperCR3BP = agcom.GUID(IVANumericalPropagatorWrapperCR3BP._uuid)
        vtable_offset_local = IVANumericalPropagatorWrapperCR3BP._vtable_offset - 1
        self.__dict__["_GetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVANumericalPropagatorWrapperCR3BP, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_SetCentralBodyName"] = IAGFUNCTYPE(pUnk, IID_IVANumericalPropagatorWrapperCR3BP, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_GetPropagatorFunctions"] = IAGFUNCTYPE(pUnk, IID_IVANumericalPropagatorWrapperCR3BP, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_GetNumericalIntegrator"] = IAGFUNCTYPE(pUnk, IID_IVANumericalPropagatorWrapperCR3BP, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_GetNumericalIntegratorType"] = IAGFUNCTYPE(pUnk, IID_IVANumericalPropagatorWrapperCR3BP, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetNumericalIntegrator"] = IAGFUNCTYPE(pUnk, IID_IVANumericalPropagatorWrapperCR3BP, vtable_offset_local+6, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVANumericalPropagatorWrapperCR3BP.__dict__ and type(IVANumericalPropagatorWrapperCR3BP.__dict__[attrname]) == property:
            return IVANumericalPropagatorWrapperCR3BP.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVANumericalPropagatorWrapperCR3BP.")
    
    @property
    def CentralBodyName(self) -> str:
        """The central body for Propagation."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCentralBodyName"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CentralBodyName.setter
    def CentralBodyName(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCentralBodyName"](arg_inVal.COM_val))

    @property
    def PropagatorFunctions(self) -> "IVAPropagatorFunctionCollection":
        """The list of propagator functions."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAPropagatorFunctionCollection:
            agcls.evaluate_hresult(self.__dict__["_GetPropagatorFunctions"](byref(arg_ppVAPropagatorFunctionCollection.COM_val)))
            return arg_ppVAPropagatorFunctionCollection.python_val

    @property
    def NumericalIntegrator(self) -> "IVANumericalIntegrator":
        """The numerical integrator."""
        with agmarshall.AgInterface_out_arg() as arg_ppVANumericalIntegrator:
            agcls.evaluate_hresult(self.__dict__["_GetNumericalIntegrator"](byref(arg_ppVANumericalIntegrator.COM_val)))
            return arg_ppVANumericalIntegrator.python_val

    @property
    def NumericalIntegratorType(self) -> "AgEVANumericalIntegrator":
        """The numerical integrator type."""
        with agmarshall.AgEnum_arg(AgEVANumericalIntegrator) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetNumericalIntegratorType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def SetNumericalIntegrator(self, integrator:"AgEVANumericalIntegrator") -> None:
        """Changes the numerical integrator."""
        with agmarshall.AgEnum_arg(AgEVANumericalIntegrator, integrator) as arg_integrator:
            agcls.evaluate_hresult(self.__dict__["_SetNumericalIntegrator"](arg_integrator.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{C0662E79-7987-4363-B97D-2277A12A7B5B}", IVANumericalPropagatorWrapperCR3BP)
agcls.AgTypeNameMap["IVANumericalPropagatorWrapperCR3BP"] = IVANumericalPropagatorWrapperCR3BP

class IVABulirschStoerIntegrator(object):
    """Properties for the Bulirsch-Stoer numerical integrator."""
    _uuid = "{2A307A62-0365-405B-B493-5F11810DF50C}"
    _num_methods = 24
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetInitialStep"] = _raise_uninitialized_error
        self.__dict__["_SetInitialStep"] = _raise_uninitialized_error
        self.__dict__["_GetUseFixedStep"] = _raise_uninitialized_error
        self.__dict__["_SetUseFixedStep"] = _raise_uninitialized_error
        self.__dict__["_GetUseMaxStep"] = _raise_uninitialized_error
        self.__dict__["_SetUseMaxStep"] = _raise_uninitialized_error
        self.__dict__["_GetUseMinStep"] = _raise_uninitialized_error
        self.__dict__["_SetUseMinStep"] = _raise_uninitialized_error
        self.__dict__["_GetMaxStep"] = _raise_uninitialized_error
        self.__dict__["_SetMaxStep"] = _raise_uninitialized_error
        self.__dict__["_GetMinStep"] = _raise_uninitialized_error
        self.__dict__["_SetMinStep"] = _raise_uninitialized_error
        self.__dict__["_GetMaxRelErr"] = _raise_uninitialized_error
        self.__dict__["_SetMaxRelErr"] = _raise_uninitialized_error
        self.__dict__["_GetMaxSequences"] = _raise_uninitialized_error
        self.__dict__["_SetMaxSequences"] = _raise_uninitialized_error
        self.__dict__["_GetMaxIterations"] = _raise_uninitialized_error
        self.__dict__["_SetMaxIterations"] = _raise_uninitialized_error
        self.__dict__["_GetTolerance"] = _raise_uninitialized_error
        self.__dict__["_SetTolerance"] = _raise_uninitialized_error
        self.__dict__["_GetFirstSafetyCoefficient"] = _raise_uninitialized_error
        self.__dict__["_SetFirstSafetyCoefficient"] = _raise_uninitialized_error
        self.__dict__["_GetSecondSafetyCoefficient"] = _raise_uninitialized_error
        self.__dict__["_SetSecondSafetyCoefficient"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVABulirschStoerIntegrator._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVABulirschStoerIntegrator from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVABulirschStoerIntegrator = agcom.GUID(IVABulirschStoerIntegrator._uuid)
        vtable_offset_local = IVABulirschStoerIntegrator._vtable_offset - 1
        self.__dict__["_GetInitialStep"] = IAGFUNCTYPE(pUnk, IID_IVABulirschStoerIntegrator, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetInitialStep"] = IAGFUNCTYPE(pUnk, IID_IVABulirschStoerIntegrator, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetUseFixedStep"] = IAGFUNCTYPE(pUnk, IID_IVABulirschStoerIntegrator, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseFixedStep"] = IAGFUNCTYPE(pUnk, IID_IVABulirschStoerIntegrator, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseMaxStep"] = IAGFUNCTYPE(pUnk, IID_IVABulirschStoerIntegrator, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseMaxStep"] = IAGFUNCTYPE(pUnk, IID_IVABulirschStoerIntegrator, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseMinStep"] = IAGFUNCTYPE(pUnk, IID_IVABulirschStoerIntegrator, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseMinStep"] = IAGFUNCTYPE(pUnk, IID_IVABulirschStoerIntegrator, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_GetMaxStep"] = IAGFUNCTYPE(pUnk, IID_IVABulirschStoerIntegrator, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaxStep"] = IAGFUNCTYPE(pUnk, IID_IVABulirschStoerIntegrator, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetMinStep"] = IAGFUNCTYPE(pUnk, IID_IVABulirschStoerIntegrator, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMinStep"] = IAGFUNCTYPE(pUnk, IID_IVABulirschStoerIntegrator, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetMaxRelErr"] = IAGFUNCTYPE(pUnk, IID_IVABulirschStoerIntegrator, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaxRelErr"] = IAGFUNCTYPE(pUnk, IID_IVABulirschStoerIntegrator, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetMaxSequences"] = IAGFUNCTYPE(pUnk, IID_IVABulirschStoerIntegrator, vtable_offset_local+15, POINTER(agcom.LONG))
        self.__dict__["_SetMaxSequences"] = IAGFUNCTYPE(pUnk, IID_IVABulirschStoerIntegrator, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_GetMaxIterations"] = IAGFUNCTYPE(pUnk, IID_IVABulirschStoerIntegrator, vtable_offset_local+17, POINTER(agcom.LONG))
        self.__dict__["_SetMaxIterations"] = IAGFUNCTYPE(pUnk, IID_IVABulirschStoerIntegrator, vtable_offset_local+18, agcom.LONG)
        self.__dict__["_GetTolerance"] = IAGFUNCTYPE(pUnk, IID_IVABulirschStoerIntegrator, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_SetTolerance"] = IAGFUNCTYPE(pUnk, IID_IVABulirschStoerIntegrator, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_GetFirstSafetyCoefficient"] = IAGFUNCTYPE(pUnk, IID_IVABulirschStoerIntegrator, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_SetFirstSafetyCoefficient"] = IAGFUNCTYPE(pUnk, IID_IVABulirschStoerIntegrator, vtable_offset_local+22, agcom.DOUBLE)
        self.__dict__["_GetSecondSafetyCoefficient"] = IAGFUNCTYPE(pUnk, IID_IVABulirschStoerIntegrator, vtable_offset_local+23, POINTER(agcom.DOUBLE))
        self.__dict__["_SetSecondSafetyCoefficient"] = IAGFUNCTYPE(pUnk, IID_IVABulirschStoerIntegrator, vtable_offset_local+24, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVABulirschStoerIntegrator.__dict__ and type(IVABulirschStoerIntegrator.__dict__[attrname]) == property:
            return IVABulirschStoerIntegrator.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVABulirschStoerIntegrator.")
    
    @property
    def InitialStep(self) -> float:
        """The initial step. Uses time dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetInitialStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @InitialStep.setter
    def InitialStep(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetInitialStep"](arg_inVal.COM_val))

    @property
    def UseFixedStep(self) -> bool:
        """True if running in fixed-step mode."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseFixedStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseFixedStep.setter
    def UseFixedStep(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseFixedStep"](arg_inVal.COM_val))

    @property
    def UseMaxStep(self) -> bool:
        """Whether or not to enforce the maximum step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseMaxStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseMaxStep.setter
    def UseMaxStep(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseMaxStep"](arg_inVal.COM_val))

    @property
    def UseMinStep(self) -> bool:
        """Whether or not to enforce the minimum step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseMinStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseMinStep.setter
    def UseMinStep(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseMinStep"](arg_inVal.COM_val))

    @property
    def MaxStep(self) -> float:
        """The maximum step size to allow (absolute value). Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxStep.setter
    def MaxStep(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxStep"](arg_inVal.COM_val))

    @property
    def MinStep(self) -> float:
        """The minimum step size to allow (absolute value). Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MinStep.setter
    def MinStep(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMinStep"](arg_inVal.COM_val))

    @property
    def MaxRelErr(self) -> float:
        """The maximum relative error used to control step size. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxRelErr"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxRelErr.setter
    def MaxRelErr(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxRelErr"](arg_inVal.COM_val))

    @property
    def MaxSequences(self) -> int:
        """The maximum number of sequences. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxSequences"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxSequences.setter
    def MaxSequences(self, inVal:int) -> None:
        with agmarshall.LONG_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxSequences"](arg_inVal.COM_val))

    @property
    def MaxIterations(self) -> int:
        """The maximum number of iterations. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxIterations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxIterations.setter
    def MaxIterations(self, inVal:int) -> None:
        with agmarshall.LONG_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxIterations"](arg_inVal.COM_val))

    @property
    def Tolerance(self) -> float:
        """The error tolerance for step size control. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetTolerance"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @Tolerance.setter
    def Tolerance(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetTolerance"](arg_inVal.COM_val))

    @property
    def FirstSafetyCoefficient(self) -> float:
        """The first safety coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetFirstSafetyCoefficient"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @FirstSafetyCoefficient.setter
    def FirstSafetyCoefficient(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetFirstSafetyCoefficient"](arg_inVal.COM_val))

    @property
    def SecondSafetyCoefficient(self) -> float:
        """The second safety coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSecondSafetyCoefficient"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @SecondSafetyCoefficient.setter
    def SecondSafetyCoefficient(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetSecondSafetyCoefficient"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2A307A62-0365-405B-B493-5F11810DF50C}", IVABulirschStoerIntegrator)
agcls.AgTypeNameMap["IVABulirschStoerIntegrator"] = IVABulirschStoerIntegrator

class IVAGaussJacksonIntegrator(object):
    """Properties for the Gauss-Jackson numerical integrator."""
    _uuid = "{C68E6FDF-DA4F-4FA6-A313-3CA4EF865E0C}"
    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetInitialStep"] = _raise_uninitialized_error
        self.__dict__["_SetInitialStep"] = _raise_uninitialized_error
        self.__dict__["_GetMaxCorrectorRelErr"] = _raise_uninitialized_error
        self.__dict__["_SetMaxCorrectorRelErr"] = _raise_uninitialized_error
        self.__dict__["_GetCorrectorMode"] = _raise_uninitialized_error
        self.__dict__["_SetCorrectorMode"] = _raise_uninitialized_error
        self.__dict__["_GetMaxCorrectorIterations"] = _raise_uninitialized_error
        self.__dict__["_SetMaxCorrectorIterations"] = _raise_uninitialized_error
        self.__dict__["_GetSingleStepIntegrator"] = _raise_uninitialized_error
        self.__dict__["_GetSingleStepIntegratorType"] = _raise_uninitialized_error
        self.__dict__["_SetSingleStepIntegrator"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVAGaussJacksonIntegrator._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVAGaussJacksonIntegrator from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVAGaussJacksonIntegrator = agcom.GUID(IVAGaussJacksonIntegrator._uuid)
        vtable_offset_local = IVAGaussJacksonIntegrator._vtable_offset - 1
        self.__dict__["_GetInitialStep"] = IAGFUNCTYPE(pUnk, IID_IVAGaussJacksonIntegrator, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetInitialStep"] = IAGFUNCTYPE(pUnk, IID_IVAGaussJacksonIntegrator, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetMaxCorrectorRelErr"] = IAGFUNCTYPE(pUnk, IID_IVAGaussJacksonIntegrator, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaxCorrectorRelErr"] = IAGFUNCTYPE(pUnk, IID_IVAGaussJacksonIntegrator, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_GetCorrectorMode"] = IAGFUNCTYPE(pUnk, IID_IVAGaussJacksonIntegrator, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_SetCorrectorMode"] = IAGFUNCTYPE(pUnk, IID_IVAGaussJacksonIntegrator, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_GetMaxCorrectorIterations"] = IAGFUNCTYPE(pUnk, IID_IVAGaussJacksonIntegrator, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_SetMaxCorrectorIterations"] = IAGFUNCTYPE(pUnk, IID_IVAGaussJacksonIntegrator, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_GetSingleStepIntegrator"] = IAGFUNCTYPE(pUnk, IID_IVAGaussJacksonIntegrator, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_GetSingleStepIntegratorType"] = IAGFUNCTYPE(pUnk, IID_IVAGaussJacksonIntegrator, vtable_offset_local+10, POINTER(agcom.LONG))
        self.__dict__["_SetSingleStepIntegrator"] = IAGFUNCTYPE(pUnk, IID_IVAGaussJacksonIntegrator, vtable_offset_local+11, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVAGaussJacksonIntegrator.__dict__ and type(IVAGaussJacksonIntegrator.__dict__[attrname]) == property:
            return IVAGaussJacksonIntegrator.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVAGaussJacksonIntegrator.")
    
    @property
    def InitialStep(self) -> float:
        """The initial step. Uses time dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetInitialStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @InitialStep.setter
    def InitialStep(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetInitialStep"](arg_inVal.COM_val))

    @property
    def MaxCorrectorRelErr(self) -> float:
        """The maximum relative error between corrector iterations. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxCorrectorRelErr"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxCorrectorRelErr.setter
    def MaxCorrectorRelErr(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxCorrectorRelErr"](arg_inVal.COM_val))

    @property
    def CorrectorMode(self) -> "AgEVAPredictorCorrector":
        """The Predictor Corrector scheme."""
        with agmarshall.AgEnum_arg(AgEVAPredictorCorrector) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCorrectorMode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CorrectorMode.setter
    def CorrectorMode(self, inVal:"AgEVAPredictorCorrector") -> None:
        with agmarshall.AgEnum_arg(AgEVAPredictorCorrector, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCorrectorMode"](arg_inVal.COM_val))

    @property
    def MaxCorrectorIterations(self) -> int:
        """The maximum corrector iterations. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxCorrectorIterations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxCorrectorIterations.setter
    def MaxCorrectorIterations(self, inVal:int) -> None:
        with agmarshall.LONG_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxCorrectorIterations"](arg_inVal.COM_val))

    @property
    def SingleStepIntegrator(self) -> "IVANumericalIntegrator":
        """The stopping integrator; a single-step integrator."""
        with agmarshall.AgInterface_out_arg() as arg_ppVANumericalIntegrator:
            agcls.evaluate_hresult(self.__dict__["_GetSingleStepIntegrator"](byref(arg_ppVANumericalIntegrator.COM_val)))
            return arg_ppVANumericalIntegrator.python_val

    @property
    def SingleStepIntegratorType(self) -> "AgEVANumericalIntegrator":
        """The stopping integrator type."""
        with agmarshall.AgEnum_arg(AgEVANumericalIntegrator) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetSingleStepIntegratorType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def SetSingleStepIntegrator(self, integrator:"AgEVANumericalIntegrator") -> None:
        """Changes the stopping integrator."""
        with agmarshall.AgEnum_arg(AgEVANumericalIntegrator, integrator) as arg_integrator:
            agcls.evaluate_hresult(self.__dict__["_SetSingleStepIntegrator"](arg_integrator.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{C68E6FDF-DA4F-4FA6-A313-3CA4EF865E0C}", IVAGaussJacksonIntegrator)
agcls.AgTypeNameMap["IVAGaussJacksonIntegrator"] = IVAGaussJacksonIntegrator

class IVARK2nd3rd(object):
    """Properties for the RK2nd3rd numerical integrator."""
    _uuid = "{B45A629D-EAD2-45CB-9757-0AF4BBC0967A}"
    _num_methods = 24
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetInitialStep"] = _raise_uninitialized_error
        self.__dict__["_SetInitialStep"] = _raise_uninitialized_error
        self.__dict__["_GetUseFixedStep"] = _raise_uninitialized_error
        self.__dict__["_SetUseFixedStep"] = _raise_uninitialized_error
        self.__dict__["_GetUseMaxStep"] = _raise_uninitialized_error
        self.__dict__["_SetUseMaxStep"] = _raise_uninitialized_error
        self.__dict__["_GetUseMinStep"] = _raise_uninitialized_error
        self.__dict__["_SetUseMinStep"] = _raise_uninitialized_error
        self.__dict__["_GetMaxStep"] = _raise_uninitialized_error
        self.__dict__["_SetMaxStep"] = _raise_uninitialized_error
        self.__dict__["_GetMinStep"] = _raise_uninitialized_error
        self.__dict__["_SetMinStep"] = _raise_uninitialized_error
        self.__dict__["_GetMaxRelErr"] = _raise_uninitialized_error
        self.__dict__["_SetMaxRelErr"] = _raise_uninitialized_error
        self.__dict__["_GetMaxAbsErr"] = _raise_uninitialized_error
        self.__dict__["_SetMaxAbsErr"] = _raise_uninitialized_error
        self.__dict__["_GetHighSafetyCoefficient"] = _raise_uninitialized_error
        self.__dict__["_SetHighSafetyCoefficient"] = _raise_uninitialized_error
        self.__dict__["_GetLowSafetyCoefficient"] = _raise_uninitialized_error
        self.__dict__["_SetLowSafetyCoefficient"] = _raise_uninitialized_error
        self.__dict__["_GetErrorControl"] = _raise_uninitialized_error
        self.__dict__["_SetErrorControl"] = _raise_uninitialized_error
        self.__dict__["_GetMaxIterations"] = _raise_uninitialized_error
        self.__dict__["_SetMaxIterations"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVARK2nd3rd._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVARK2nd3rd from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVARK2nd3rd = agcom.GUID(IVARK2nd3rd._uuid)
        vtable_offset_local = IVARK2nd3rd._vtable_offset - 1
        self.__dict__["_GetInitialStep"] = IAGFUNCTYPE(pUnk, IID_IVARK2nd3rd, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetInitialStep"] = IAGFUNCTYPE(pUnk, IID_IVARK2nd3rd, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetUseFixedStep"] = IAGFUNCTYPE(pUnk, IID_IVARK2nd3rd, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseFixedStep"] = IAGFUNCTYPE(pUnk, IID_IVARK2nd3rd, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseMaxStep"] = IAGFUNCTYPE(pUnk, IID_IVARK2nd3rd, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseMaxStep"] = IAGFUNCTYPE(pUnk, IID_IVARK2nd3rd, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseMinStep"] = IAGFUNCTYPE(pUnk, IID_IVARK2nd3rd, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseMinStep"] = IAGFUNCTYPE(pUnk, IID_IVARK2nd3rd, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_GetMaxStep"] = IAGFUNCTYPE(pUnk, IID_IVARK2nd3rd, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaxStep"] = IAGFUNCTYPE(pUnk, IID_IVARK2nd3rd, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetMinStep"] = IAGFUNCTYPE(pUnk, IID_IVARK2nd3rd, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMinStep"] = IAGFUNCTYPE(pUnk, IID_IVARK2nd3rd, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetMaxRelErr"] = IAGFUNCTYPE(pUnk, IID_IVARK2nd3rd, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaxRelErr"] = IAGFUNCTYPE(pUnk, IID_IVARK2nd3rd, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetMaxAbsErr"] = IAGFUNCTYPE(pUnk, IID_IVARK2nd3rd, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaxAbsErr"] = IAGFUNCTYPE(pUnk, IID_IVARK2nd3rd, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_GetHighSafetyCoefficient"] = IAGFUNCTYPE(pUnk, IID_IVARK2nd3rd, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_SetHighSafetyCoefficient"] = IAGFUNCTYPE(pUnk, IID_IVARK2nd3rd, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_GetLowSafetyCoefficient"] = IAGFUNCTYPE(pUnk, IID_IVARK2nd3rd, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_SetLowSafetyCoefficient"] = IAGFUNCTYPE(pUnk, IID_IVARK2nd3rd, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_GetErrorControl"] = IAGFUNCTYPE(pUnk, IID_IVARK2nd3rd, vtable_offset_local+21, POINTER(agcom.LONG))
        self.__dict__["_SetErrorControl"] = IAGFUNCTYPE(pUnk, IID_IVARK2nd3rd, vtable_offset_local+22, agcom.LONG)
        self.__dict__["_GetMaxIterations"] = IAGFUNCTYPE(pUnk, IID_IVARK2nd3rd, vtable_offset_local+23, POINTER(agcom.LONG))
        self.__dict__["_SetMaxIterations"] = IAGFUNCTYPE(pUnk, IID_IVARK2nd3rd, vtable_offset_local+24, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVARK2nd3rd.__dict__ and type(IVARK2nd3rd.__dict__[attrname]) == property:
            return IVARK2nd3rd.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVARK2nd3rd.")
    
    @property
    def InitialStep(self) -> float:
        """The initial step. Uses time dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetInitialStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @InitialStep.setter
    def InitialStep(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetInitialStep"](arg_inVal.COM_val))

    @property
    def UseFixedStep(self) -> bool:
        """True if running in fixed-step mode."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseFixedStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseFixedStep.setter
    def UseFixedStep(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseFixedStep"](arg_inVal.COM_val))

    @property
    def UseMaxStep(self) -> bool:
        """Whether or not to enforce the maximum step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseMaxStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseMaxStep.setter
    def UseMaxStep(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseMaxStep"](arg_inVal.COM_val))

    @property
    def UseMinStep(self) -> bool:
        """Whether or not to enforce the minimum step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseMinStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseMinStep.setter
    def UseMinStep(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseMinStep"](arg_inVal.COM_val))

    @property
    def MaxStep(self) -> float:
        """The maximum step size to allow (absolute value). Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxStep.setter
    def MaxStep(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxStep"](arg_inVal.COM_val))

    @property
    def MinStep(self) -> float:
        """The minimum step size to allow (absolute value). Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MinStep.setter
    def MinStep(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMinStep"](arg_inVal.COM_val))

    @property
    def MaxRelErr(self) -> float:
        """The maximum relative error used to control step size. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxRelErr"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxRelErr.setter
    def MaxRelErr(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxRelErr"](arg_inVal.COM_val))

    @property
    def MaxAbsErr(self) -> float:
        """The maximum absolute error; Also used if relative scale is too small. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxAbsErr"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxAbsErr.setter
    def MaxAbsErr(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxAbsErr"](arg_inVal.COM_val))

    @property
    def HighSafetyCoefficient(self) -> float:
        """The 'safety' coefficient used to decrease step size if the error is too high. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetHighSafetyCoefficient"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @HighSafetyCoefficient.setter
    def HighSafetyCoefficient(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetHighSafetyCoefficient"](arg_inVal.COM_val))

    @property
    def LowSafetyCoefficient(self) -> float:
        """The 'safety' coefficient used to increase step size if the error is too low. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLowSafetyCoefficient"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @LowSafetyCoefficient.setter
    def LowSafetyCoefficient(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetLowSafetyCoefficient"](arg_inVal.COM_val))

    @property
    def ErrorControl(self) -> "AgEVAErrorControl":
        """The error control method."""
        with agmarshall.AgEnum_arg(AgEVAErrorControl) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetErrorControl"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ErrorControl.setter
    def ErrorControl(self, inVal:"AgEVAErrorControl") -> None:
        with agmarshall.AgEnum_arg(AgEVAErrorControl, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetErrorControl"](arg_inVal.COM_val))

    @property
    def MaxIterations(self) -> int:
        """The maximum iterations. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxIterations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxIterations.setter
    def MaxIterations(self, inVal:int) -> None:
        with agmarshall.LONG_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxIterations"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{B45A629D-EAD2-45CB-9757-0AF4BBC0967A}", IVARK2nd3rd)
agcls.AgTypeNameMap["IVARK2nd3rd"] = IVARK2nd3rd

class IVARK4th(object):
    """Properties for the RK4th numerical integrator."""
    _uuid = "{AC6ACE9D-D174-4A09-9E10-7EE104ED8E9C}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetInitialStep"] = _raise_uninitialized_error
        self.__dict__["_SetInitialStep"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVARK4th._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVARK4th from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVARK4th = agcom.GUID(IVARK4th._uuid)
        vtable_offset_local = IVARK4th._vtable_offset - 1
        self.__dict__["_GetInitialStep"] = IAGFUNCTYPE(pUnk, IID_IVARK4th, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetInitialStep"] = IAGFUNCTYPE(pUnk, IID_IVARK4th, vtable_offset_local+2, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVARK4th.__dict__ and type(IVARK4th.__dict__[attrname]) == property:
            return IVARK4th.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVARK4th.")
    
    @property
    def InitialStep(self) -> float:
        """The initial step. Uses time dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetInitialStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @InitialStep.setter
    def InitialStep(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetInitialStep"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{AC6ACE9D-D174-4A09-9E10-7EE104ED8E9C}", IVARK4th)
agcls.AgTypeNameMap["IVARK4th"] = IVARK4th

class IVARK4th5th(object):
    """Properties for the RK4th5th numerical integrator."""
    _uuid = "{F71F9E83-14BD-4BA3-BB99-AD7CDA3FCA40}"
    _num_methods = 24
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetInitialStep"] = _raise_uninitialized_error
        self.__dict__["_SetInitialStep"] = _raise_uninitialized_error
        self.__dict__["_GetUseFixedStep"] = _raise_uninitialized_error
        self.__dict__["_SetUseFixedStep"] = _raise_uninitialized_error
        self.__dict__["_GetUseMaxStep"] = _raise_uninitialized_error
        self.__dict__["_SetUseMaxStep"] = _raise_uninitialized_error
        self.__dict__["_GetUseMinStep"] = _raise_uninitialized_error
        self.__dict__["_SetUseMinStep"] = _raise_uninitialized_error
        self.__dict__["_GetMaxStep"] = _raise_uninitialized_error
        self.__dict__["_SetMaxStep"] = _raise_uninitialized_error
        self.__dict__["_GetMinStep"] = _raise_uninitialized_error
        self.__dict__["_SetMinStep"] = _raise_uninitialized_error
        self.__dict__["_GetMaxRelErr"] = _raise_uninitialized_error
        self.__dict__["_SetMaxRelErr"] = _raise_uninitialized_error
        self.__dict__["_GetMaxAbsErr"] = _raise_uninitialized_error
        self.__dict__["_SetMaxAbsErr"] = _raise_uninitialized_error
        self.__dict__["_GetHighSafetyCoefficient"] = _raise_uninitialized_error
        self.__dict__["_SetHighSafetyCoefficient"] = _raise_uninitialized_error
        self.__dict__["_GetLowSafetyCoefficient"] = _raise_uninitialized_error
        self.__dict__["_SetLowSafetyCoefficient"] = _raise_uninitialized_error
        self.__dict__["_GetErrorControl"] = _raise_uninitialized_error
        self.__dict__["_SetErrorControl"] = _raise_uninitialized_error
        self.__dict__["_GetMaxIterations"] = _raise_uninitialized_error
        self.__dict__["_SetMaxIterations"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVARK4th5th._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVARK4th5th from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVARK4th5th = agcom.GUID(IVARK4th5th._uuid)
        vtable_offset_local = IVARK4th5th._vtable_offset - 1
        self.__dict__["_GetInitialStep"] = IAGFUNCTYPE(pUnk, IID_IVARK4th5th, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetInitialStep"] = IAGFUNCTYPE(pUnk, IID_IVARK4th5th, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetUseFixedStep"] = IAGFUNCTYPE(pUnk, IID_IVARK4th5th, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseFixedStep"] = IAGFUNCTYPE(pUnk, IID_IVARK4th5th, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseMaxStep"] = IAGFUNCTYPE(pUnk, IID_IVARK4th5th, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseMaxStep"] = IAGFUNCTYPE(pUnk, IID_IVARK4th5th, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseMinStep"] = IAGFUNCTYPE(pUnk, IID_IVARK4th5th, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseMinStep"] = IAGFUNCTYPE(pUnk, IID_IVARK4th5th, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_GetMaxStep"] = IAGFUNCTYPE(pUnk, IID_IVARK4th5th, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaxStep"] = IAGFUNCTYPE(pUnk, IID_IVARK4th5th, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetMinStep"] = IAGFUNCTYPE(pUnk, IID_IVARK4th5th, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMinStep"] = IAGFUNCTYPE(pUnk, IID_IVARK4th5th, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetMaxRelErr"] = IAGFUNCTYPE(pUnk, IID_IVARK4th5th, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaxRelErr"] = IAGFUNCTYPE(pUnk, IID_IVARK4th5th, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetMaxAbsErr"] = IAGFUNCTYPE(pUnk, IID_IVARK4th5th, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaxAbsErr"] = IAGFUNCTYPE(pUnk, IID_IVARK4th5th, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_GetHighSafetyCoefficient"] = IAGFUNCTYPE(pUnk, IID_IVARK4th5th, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_SetHighSafetyCoefficient"] = IAGFUNCTYPE(pUnk, IID_IVARK4th5th, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_GetLowSafetyCoefficient"] = IAGFUNCTYPE(pUnk, IID_IVARK4th5th, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_SetLowSafetyCoefficient"] = IAGFUNCTYPE(pUnk, IID_IVARK4th5th, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_GetErrorControl"] = IAGFUNCTYPE(pUnk, IID_IVARK4th5th, vtable_offset_local+21, POINTER(agcom.LONG))
        self.__dict__["_SetErrorControl"] = IAGFUNCTYPE(pUnk, IID_IVARK4th5th, vtable_offset_local+22, agcom.LONG)
        self.__dict__["_GetMaxIterations"] = IAGFUNCTYPE(pUnk, IID_IVARK4th5th, vtable_offset_local+23, POINTER(agcom.LONG))
        self.__dict__["_SetMaxIterations"] = IAGFUNCTYPE(pUnk, IID_IVARK4th5th, vtable_offset_local+24, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVARK4th5th.__dict__ and type(IVARK4th5th.__dict__[attrname]) == property:
            return IVARK4th5th.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVARK4th5th.")
    
    @property
    def InitialStep(self) -> float:
        """The initial step. Uses time dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetInitialStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @InitialStep.setter
    def InitialStep(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetInitialStep"](arg_inVal.COM_val))

    @property
    def UseFixedStep(self) -> bool:
        """True if running in fixed-step mode."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseFixedStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseFixedStep.setter
    def UseFixedStep(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseFixedStep"](arg_inVal.COM_val))

    @property
    def UseMaxStep(self) -> bool:
        """Whether or not to enforce the maximum step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseMaxStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseMaxStep.setter
    def UseMaxStep(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseMaxStep"](arg_inVal.COM_val))

    @property
    def UseMinStep(self) -> bool:
        """Whether or not to enforce the minimum step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseMinStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseMinStep.setter
    def UseMinStep(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseMinStep"](arg_inVal.COM_val))

    @property
    def MaxStep(self) -> float:
        """The maximum step size to allow (absolute value). Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxStep.setter
    def MaxStep(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxStep"](arg_inVal.COM_val))

    @property
    def MinStep(self) -> float:
        """The minimum step size to allow (absolute value). Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MinStep.setter
    def MinStep(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMinStep"](arg_inVal.COM_val))

    @property
    def MaxRelErr(self) -> float:
        """The maximum relative error used to control step size. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxRelErr"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxRelErr.setter
    def MaxRelErr(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxRelErr"](arg_inVal.COM_val))

    @property
    def MaxAbsErr(self) -> float:
        """The maximum absolute error; Also used if relative scale is too small. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxAbsErr"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxAbsErr.setter
    def MaxAbsErr(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxAbsErr"](arg_inVal.COM_val))

    @property
    def HighSafetyCoefficient(self) -> float:
        """The 'safety' coefficient used to decrease step size if the error is too high. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetHighSafetyCoefficient"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @HighSafetyCoefficient.setter
    def HighSafetyCoefficient(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetHighSafetyCoefficient"](arg_inVal.COM_val))

    @property
    def LowSafetyCoefficient(self) -> float:
        """The 'safety' coefficient used to increase step size if the error is too low. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLowSafetyCoefficient"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @LowSafetyCoefficient.setter
    def LowSafetyCoefficient(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetLowSafetyCoefficient"](arg_inVal.COM_val))

    @property
    def ErrorControl(self) -> "AgEVAErrorControl":
        """The error control method."""
        with agmarshall.AgEnum_arg(AgEVAErrorControl) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetErrorControl"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ErrorControl.setter
    def ErrorControl(self, inVal:"AgEVAErrorControl") -> None:
        with agmarshall.AgEnum_arg(AgEVAErrorControl, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetErrorControl"](arg_inVal.COM_val))

    @property
    def MaxIterations(self) -> int:
        """The maximum iterations. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxIterations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxIterations.setter
    def MaxIterations(self, inVal:int) -> None:
        with agmarshall.LONG_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxIterations"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{F71F9E83-14BD-4BA3-BB99-AD7CDA3FCA40}", IVARK4th5th)
agcls.AgTypeNameMap["IVARK4th5th"] = IVARK4th5th

class IVARK4thAdapt(object):
    """Properties for the RK4thAdapt numerical integrator."""
    _uuid = "{2FD2C00D-0DB5-4933-99A1-759E7D0F6A85}"
    _num_methods = 24
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetInitialStep"] = _raise_uninitialized_error
        self.__dict__["_SetInitialStep"] = _raise_uninitialized_error
        self.__dict__["_GetUseFixedStep"] = _raise_uninitialized_error
        self.__dict__["_SetUseFixedStep"] = _raise_uninitialized_error
        self.__dict__["_GetUseMaxStep"] = _raise_uninitialized_error
        self.__dict__["_SetUseMaxStep"] = _raise_uninitialized_error
        self.__dict__["_GetUseMinStep"] = _raise_uninitialized_error
        self.__dict__["_SetUseMinStep"] = _raise_uninitialized_error
        self.__dict__["_GetMaxStep"] = _raise_uninitialized_error
        self.__dict__["_SetMaxStep"] = _raise_uninitialized_error
        self.__dict__["_GetMinStep"] = _raise_uninitialized_error
        self.__dict__["_SetMinStep"] = _raise_uninitialized_error
        self.__dict__["_GetMaxRelErr"] = _raise_uninitialized_error
        self.__dict__["_SetMaxRelErr"] = _raise_uninitialized_error
        self.__dict__["_GetMaxAbsErr"] = _raise_uninitialized_error
        self.__dict__["_SetMaxAbsErr"] = _raise_uninitialized_error
        self.__dict__["_GetHighSafetyCoefficient"] = _raise_uninitialized_error
        self.__dict__["_SetHighSafetyCoefficient"] = _raise_uninitialized_error
        self.__dict__["_GetLowSafetyCoefficient"] = _raise_uninitialized_error
        self.__dict__["_SetLowSafetyCoefficient"] = _raise_uninitialized_error
        self.__dict__["_GetErrorControl"] = _raise_uninitialized_error
        self.__dict__["_SetErrorControl"] = _raise_uninitialized_error
        self.__dict__["_GetMaxIterations"] = _raise_uninitialized_error
        self.__dict__["_SetMaxIterations"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVARK4thAdapt._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVARK4thAdapt from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVARK4thAdapt = agcom.GUID(IVARK4thAdapt._uuid)
        vtable_offset_local = IVARK4thAdapt._vtable_offset - 1
        self.__dict__["_GetInitialStep"] = IAGFUNCTYPE(pUnk, IID_IVARK4thAdapt, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetInitialStep"] = IAGFUNCTYPE(pUnk, IID_IVARK4thAdapt, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetUseFixedStep"] = IAGFUNCTYPE(pUnk, IID_IVARK4thAdapt, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseFixedStep"] = IAGFUNCTYPE(pUnk, IID_IVARK4thAdapt, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseMaxStep"] = IAGFUNCTYPE(pUnk, IID_IVARK4thAdapt, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseMaxStep"] = IAGFUNCTYPE(pUnk, IID_IVARK4thAdapt, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseMinStep"] = IAGFUNCTYPE(pUnk, IID_IVARK4thAdapt, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseMinStep"] = IAGFUNCTYPE(pUnk, IID_IVARK4thAdapt, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_GetMaxStep"] = IAGFUNCTYPE(pUnk, IID_IVARK4thAdapt, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaxStep"] = IAGFUNCTYPE(pUnk, IID_IVARK4thAdapt, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetMinStep"] = IAGFUNCTYPE(pUnk, IID_IVARK4thAdapt, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMinStep"] = IAGFUNCTYPE(pUnk, IID_IVARK4thAdapt, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetMaxRelErr"] = IAGFUNCTYPE(pUnk, IID_IVARK4thAdapt, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaxRelErr"] = IAGFUNCTYPE(pUnk, IID_IVARK4thAdapt, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetMaxAbsErr"] = IAGFUNCTYPE(pUnk, IID_IVARK4thAdapt, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaxAbsErr"] = IAGFUNCTYPE(pUnk, IID_IVARK4thAdapt, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_GetHighSafetyCoefficient"] = IAGFUNCTYPE(pUnk, IID_IVARK4thAdapt, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_SetHighSafetyCoefficient"] = IAGFUNCTYPE(pUnk, IID_IVARK4thAdapt, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_GetLowSafetyCoefficient"] = IAGFUNCTYPE(pUnk, IID_IVARK4thAdapt, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_SetLowSafetyCoefficient"] = IAGFUNCTYPE(pUnk, IID_IVARK4thAdapt, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_GetErrorControl"] = IAGFUNCTYPE(pUnk, IID_IVARK4thAdapt, vtable_offset_local+21, POINTER(agcom.LONG))
        self.__dict__["_SetErrorControl"] = IAGFUNCTYPE(pUnk, IID_IVARK4thAdapt, vtable_offset_local+22, agcom.LONG)
        self.__dict__["_GetMaxIterations"] = IAGFUNCTYPE(pUnk, IID_IVARK4thAdapt, vtable_offset_local+23, POINTER(agcom.LONG))
        self.__dict__["_SetMaxIterations"] = IAGFUNCTYPE(pUnk, IID_IVARK4thAdapt, vtable_offset_local+24, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVARK4thAdapt.__dict__ and type(IVARK4thAdapt.__dict__[attrname]) == property:
            return IVARK4thAdapt.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVARK4thAdapt.")
    
    @property
    def InitialStep(self) -> float:
        """The initial step. Uses time dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetInitialStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @InitialStep.setter
    def InitialStep(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetInitialStep"](arg_inVal.COM_val))

    @property
    def UseFixedStep(self) -> bool:
        """True if running in fixed-step mode."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseFixedStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseFixedStep.setter
    def UseFixedStep(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseFixedStep"](arg_inVal.COM_val))

    @property
    def UseMaxStep(self) -> bool:
        """Whether or not to enforce the maximum step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseMaxStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseMaxStep.setter
    def UseMaxStep(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseMaxStep"](arg_inVal.COM_val))

    @property
    def UseMinStep(self) -> bool:
        """Whether or not to enforce the minimum step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseMinStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseMinStep.setter
    def UseMinStep(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseMinStep"](arg_inVal.COM_val))

    @property
    def MaxStep(self) -> float:
        """The maximum step size to allow (absolute value). Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxStep.setter
    def MaxStep(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxStep"](arg_inVal.COM_val))

    @property
    def MinStep(self) -> float:
        """The minimum step size to allow (absolute value). Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MinStep.setter
    def MinStep(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMinStep"](arg_inVal.COM_val))

    @property
    def MaxRelErr(self) -> float:
        """The maximum relative error used to control step size. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxRelErr"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxRelErr.setter
    def MaxRelErr(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxRelErr"](arg_inVal.COM_val))

    @property
    def MaxAbsErr(self) -> float:
        """The maximum absolute error; Also used if relative scale is too small. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxAbsErr"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxAbsErr.setter
    def MaxAbsErr(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxAbsErr"](arg_inVal.COM_val))

    @property
    def HighSafetyCoefficient(self) -> float:
        """The 'safety' coefficient used to decrease step size if the error is too high. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetHighSafetyCoefficient"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @HighSafetyCoefficient.setter
    def HighSafetyCoefficient(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetHighSafetyCoefficient"](arg_inVal.COM_val))

    @property
    def LowSafetyCoefficient(self) -> float:
        """The 'safety' coefficient used to increase step size if the error is too low. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLowSafetyCoefficient"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @LowSafetyCoefficient.setter
    def LowSafetyCoefficient(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetLowSafetyCoefficient"](arg_inVal.COM_val))

    @property
    def ErrorControl(self) -> "AgEVAErrorControl":
        """The error control method."""
        with agmarshall.AgEnum_arg(AgEVAErrorControl) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetErrorControl"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ErrorControl.setter
    def ErrorControl(self, inVal:"AgEVAErrorControl") -> None:
        with agmarshall.AgEnum_arg(AgEVAErrorControl, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetErrorControl"](arg_inVal.COM_val))

    @property
    def MaxIterations(self) -> int:
        """The maximum iterations. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxIterations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxIterations.setter
    def MaxIterations(self, inVal:int) -> None:
        with agmarshall.LONG_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxIterations"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2FD2C00D-0DB5-4933-99A1-759E7D0F6A85}", IVARK4thAdapt)
agcls.AgTypeNameMap["IVARK4thAdapt"] = IVARK4thAdapt

class IVARKF7th8th(object):
    """Properties for the RK7th8th numerical integrator."""
    _uuid = "{05ADCD42-57F9-456E-B29A-AB3AADD9DB1C}"
    _num_methods = 24
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetInitialStep"] = _raise_uninitialized_error
        self.__dict__["_SetInitialStep"] = _raise_uninitialized_error
        self.__dict__["_GetUseFixedStep"] = _raise_uninitialized_error
        self.__dict__["_SetUseFixedStep"] = _raise_uninitialized_error
        self.__dict__["_GetUseMaxStep"] = _raise_uninitialized_error
        self.__dict__["_SetUseMaxStep"] = _raise_uninitialized_error
        self.__dict__["_GetUseMinStep"] = _raise_uninitialized_error
        self.__dict__["_SetUseMinStep"] = _raise_uninitialized_error
        self.__dict__["_GetMaxStep"] = _raise_uninitialized_error
        self.__dict__["_SetMaxStep"] = _raise_uninitialized_error
        self.__dict__["_GetMinStep"] = _raise_uninitialized_error
        self.__dict__["_SetMinStep"] = _raise_uninitialized_error
        self.__dict__["_GetMaxRelErr"] = _raise_uninitialized_error
        self.__dict__["_SetMaxRelErr"] = _raise_uninitialized_error
        self.__dict__["_GetMaxAbsErr"] = _raise_uninitialized_error
        self.__dict__["_SetMaxAbsErr"] = _raise_uninitialized_error
        self.__dict__["_GetHighSafetyCoefficient"] = _raise_uninitialized_error
        self.__dict__["_SetHighSafetyCoefficient"] = _raise_uninitialized_error
        self.__dict__["_GetLowSafetyCoefficient"] = _raise_uninitialized_error
        self.__dict__["_SetLowSafetyCoefficient"] = _raise_uninitialized_error
        self.__dict__["_GetErrorControl"] = _raise_uninitialized_error
        self.__dict__["_SetErrorControl"] = _raise_uninitialized_error
        self.__dict__["_GetMaxIterations"] = _raise_uninitialized_error
        self.__dict__["_SetMaxIterations"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVARKF7th8th._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVARKF7th8th from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVARKF7th8th = agcom.GUID(IVARKF7th8th._uuid)
        vtable_offset_local = IVARKF7th8th._vtable_offset - 1
        self.__dict__["_GetInitialStep"] = IAGFUNCTYPE(pUnk, IID_IVARKF7th8th, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetInitialStep"] = IAGFUNCTYPE(pUnk, IID_IVARKF7th8th, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetUseFixedStep"] = IAGFUNCTYPE(pUnk, IID_IVARKF7th8th, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseFixedStep"] = IAGFUNCTYPE(pUnk, IID_IVARKF7th8th, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseMaxStep"] = IAGFUNCTYPE(pUnk, IID_IVARKF7th8th, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseMaxStep"] = IAGFUNCTYPE(pUnk, IID_IVARKF7th8th, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseMinStep"] = IAGFUNCTYPE(pUnk, IID_IVARKF7th8th, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseMinStep"] = IAGFUNCTYPE(pUnk, IID_IVARKF7th8th, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_GetMaxStep"] = IAGFUNCTYPE(pUnk, IID_IVARKF7th8th, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaxStep"] = IAGFUNCTYPE(pUnk, IID_IVARKF7th8th, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetMinStep"] = IAGFUNCTYPE(pUnk, IID_IVARKF7th8th, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMinStep"] = IAGFUNCTYPE(pUnk, IID_IVARKF7th8th, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetMaxRelErr"] = IAGFUNCTYPE(pUnk, IID_IVARKF7th8th, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaxRelErr"] = IAGFUNCTYPE(pUnk, IID_IVARKF7th8th, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetMaxAbsErr"] = IAGFUNCTYPE(pUnk, IID_IVARKF7th8th, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaxAbsErr"] = IAGFUNCTYPE(pUnk, IID_IVARKF7th8th, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_GetHighSafetyCoefficient"] = IAGFUNCTYPE(pUnk, IID_IVARKF7th8th, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_SetHighSafetyCoefficient"] = IAGFUNCTYPE(pUnk, IID_IVARKF7th8th, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_GetLowSafetyCoefficient"] = IAGFUNCTYPE(pUnk, IID_IVARKF7th8th, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_SetLowSafetyCoefficient"] = IAGFUNCTYPE(pUnk, IID_IVARKF7th8th, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_GetErrorControl"] = IAGFUNCTYPE(pUnk, IID_IVARKF7th8th, vtable_offset_local+21, POINTER(agcom.LONG))
        self.__dict__["_SetErrorControl"] = IAGFUNCTYPE(pUnk, IID_IVARKF7th8th, vtable_offset_local+22, agcom.LONG)
        self.__dict__["_GetMaxIterations"] = IAGFUNCTYPE(pUnk, IID_IVARKF7th8th, vtable_offset_local+23, POINTER(agcom.LONG))
        self.__dict__["_SetMaxIterations"] = IAGFUNCTYPE(pUnk, IID_IVARKF7th8th, vtable_offset_local+24, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVARKF7th8th.__dict__ and type(IVARKF7th8th.__dict__[attrname]) == property:
            return IVARKF7th8th.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVARKF7th8th.")
    
    @property
    def InitialStep(self) -> float:
        """The initial step. Uses time dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetInitialStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @InitialStep.setter
    def InitialStep(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetInitialStep"](arg_inVal.COM_val))

    @property
    def UseFixedStep(self) -> bool:
        """True if running in fixed-step mode."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseFixedStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseFixedStep.setter
    def UseFixedStep(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseFixedStep"](arg_inVal.COM_val))

    @property
    def UseMaxStep(self) -> bool:
        """Whether or not to enforce the maximum step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseMaxStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseMaxStep.setter
    def UseMaxStep(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseMaxStep"](arg_inVal.COM_val))

    @property
    def UseMinStep(self) -> bool:
        """Whether or not to enforce the minimum step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseMinStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseMinStep.setter
    def UseMinStep(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseMinStep"](arg_inVal.COM_val))

    @property
    def MaxStep(self) -> float:
        """The maximum step size to allow (absolute value). Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxStep.setter
    def MaxStep(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxStep"](arg_inVal.COM_val))

    @property
    def MinStep(self) -> float:
        """The minimum step size to allow (absolute value). Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MinStep.setter
    def MinStep(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMinStep"](arg_inVal.COM_val))

    @property
    def MaxRelErr(self) -> float:
        """The maximum relative error used to control step size. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxRelErr"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxRelErr.setter
    def MaxRelErr(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxRelErr"](arg_inVal.COM_val))

    @property
    def MaxAbsErr(self) -> float:
        """The maximum absolute error; Also used if relative scale is too small. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxAbsErr"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxAbsErr.setter
    def MaxAbsErr(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxAbsErr"](arg_inVal.COM_val))

    @property
    def HighSafetyCoefficient(self) -> float:
        """The 'safety' coefficient used to decrease step size if the error is too high. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetHighSafetyCoefficient"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @HighSafetyCoefficient.setter
    def HighSafetyCoefficient(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetHighSafetyCoefficient"](arg_inVal.COM_val))

    @property
    def LowSafetyCoefficient(self) -> float:
        """The 'safety' coefficient used to increase step size if the error is too low. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLowSafetyCoefficient"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @LowSafetyCoefficient.setter
    def LowSafetyCoefficient(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetLowSafetyCoefficient"](arg_inVal.COM_val))

    @property
    def ErrorControl(self) -> "AgEVAErrorControl":
        """The error control method."""
        with agmarshall.AgEnum_arg(AgEVAErrorControl) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetErrorControl"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ErrorControl.setter
    def ErrorControl(self, inVal:"AgEVAErrorControl") -> None:
        with agmarshall.AgEnum_arg(AgEVAErrorControl, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetErrorControl"](arg_inVal.COM_val))

    @property
    def MaxIterations(self) -> int:
        """The maximum iterations. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxIterations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxIterations.setter
    def MaxIterations(self, inVal:int) -> None:
        with agmarshall.LONG_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxIterations"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{05ADCD42-57F9-456E-B29A-AB3AADD9DB1C}", IVARKF7th8th)
agcls.AgTypeNameMap["IVARKF7th8th"] = IVARKF7th8th

class IVARKV8th9th(object):
    """Properties for the RK8th9th numerical integrator."""
    _uuid = "{E4CEAA67-BE78-472F-B746-52878835E818}"
    _num_methods = 26
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_GetInitialStep"] = _raise_uninitialized_error
        self.__dict__["_SetInitialStep"] = _raise_uninitialized_error
        self.__dict__["_GetUseFixedStep"] = _raise_uninitialized_error
        self.__dict__["_SetUseFixedStep"] = _raise_uninitialized_error
        self.__dict__["_GetUseMaxStep"] = _raise_uninitialized_error
        self.__dict__["_SetUseMaxStep"] = _raise_uninitialized_error
        self.__dict__["_GetUseMinStep"] = _raise_uninitialized_error
        self.__dict__["_SetUseMinStep"] = _raise_uninitialized_error
        self.__dict__["_GetMaxStep"] = _raise_uninitialized_error
        self.__dict__["_SetMaxStep"] = _raise_uninitialized_error
        self.__dict__["_GetMinStep"] = _raise_uninitialized_error
        self.__dict__["_SetMinStep"] = _raise_uninitialized_error
        self.__dict__["_GetMaxRelErr"] = _raise_uninitialized_error
        self.__dict__["_SetMaxRelErr"] = _raise_uninitialized_error
        self.__dict__["_GetMaxAbsErr"] = _raise_uninitialized_error
        self.__dict__["_SetMaxAbsErr"] = _raise_uninitialized_error
        self.__dict__["_GetHighSafetyCoefficient"] = _raise_uninitialized_error
        self.__dict__["_SetHighSafetyCoefficient"] = _raise_uninitialized_error
        self.__dict__["_GetLowSafetyCoefficient"] = _raise_uninitialized_error
        self.__dict__["_SetLowSafetyCoefficient"] = _raise_uninitialized_error
        self.__dict__["_GetErrorControl"] = _raise_uninitialized_error
        self.__dict__["_SetErrorControl"] = _raise_uninitialized_error
        self.__dict__["_GetMaxIterations"] = _raise_uninitialized_error
        self.__dict__["_SetMaxIterations"] = _raise_uninitialized_error
        self.__dict__["_GetCoeffType"] = _raise_uninitialized_error
        self.__dict__["_SetCoeffType"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVARKV8th9th._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVARKV8th9th from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVARKV8th9th = agcom.GUID(IVARKV8th9th._uuid)
        vtable_offset_local = IVARKV8th9th._vtable_offset - 1
        self.__dict__["_GetInitialStep"] = IAGFUNCTYPE(pUnk, IID_IVARKV8th9th, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_SetInitialStep"] = IAGFUNCTYPE(pUnk, IID_IVARKV8th9th, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_GetUseFixedStep"] = IAGFUNCTYPE(pUnk, IID_IVARKV8th9th, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseFixedStep"] = IAGFUNCTYPE(pUnk, IID_IVARKV8th9th, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseMaxStep"] = IAGFUNCTYPE(pUnk, IID_IVARKV8th9th, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseMaxStep"] = IAGFUNCTYPE(pUnk, IID_IVARKV8th9th, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_GetUseMinStep"] = IAGFUNCTYPE(pUnk, IID_IVARKV8th9th, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_SetUseMinStep"] = IAGFUNCTYPE(pUnk, IID_IVARKV8th9th, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_GetMaxStep"] = IAGFUNCTYPE(pUnk, IID_IVARKV8th9th, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaxStep"] = IAGFUNCTYPE(pUnk, IID_IVARKV8th9th, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_GetMinStep"] = IAGFUNCTYPE(pUnk, IID_IVARKV8th9th, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMinStep"] = IAGFUNCTYPE(pUnk, IID_IVARKV8th9th, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_GetMaxRelErr"] = IAGFUNCTYPE(pUnk, IID_IVARKV8th9th, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaxRelErr"] = IAGFUNCTYPE(pUnk, IID_IVARKV8th9th, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_GetMaxAbsErr"] = IAGFUNCTYPE(pUnk, IID_IVARKV8th9th, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_SetMaxAbsErr"] = IAGFUNCTYPE(pUnk, IID_IVARKV8th9th, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_GetHighSafetyCoefficient"] = IAGFUNCTYPE(pUnk, IID_IVARKV8th9th, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_SetHighSafetyCoefficient"] = IAGFUNCTYPE(pUnk, IID_IVARKV8th9th, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_GetLowSafetyCoefficient"] = IAGFUNCTYPE(pUnk, IID_IVARKV8th9th, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_SetLowSafetyCoefficient"] = IAGFUNCTYPE(pUnk, IID_IVARKV8th9th, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_GetErrorControl"] = IAGFUNCTYPE(pUnk, IID_IVARKV8th9th, vtable_offset_local+21, POINTER(agcom.LONG))
        self.__dict__["_SetErrorControl"] = IAGFUNCTYPE(pUnk, IID_IVARKV8th9th, vtable_offset_local+22, agcom.LONG)
        self.__dict__["_GetMaxIterations"] = IAGFUNCTYPE(pUnk, IID_IVARKV8th9th, vtable_offset_local+23, POINTER(agcom.LONG))
        self.__dict__["_SetMaxIterations"] = IAGFUNCTYPE(pUnk, IID_IVARKV8th9th, vtable_offset_local+24, agcom.LONG)
        self.__dict__["_GetCoeffType"] = IAGFUNCTYPE(pUnk, IID_IVARKV8th9th, vtable_offset_local+25, POINTER(agcom.LONG))
        self.__dict__["_SetCoeffType"] = IAGFUNCTYPE(pUnk, IID_IVARKV8th9th, vtable_offset_local+26, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVARKV8th9th.__dict__ and type(IVARKV8th9th.__dict__[attrname]) == property:
            return IVARKV8th9th.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVARKV8th9th.")
    
    @property
    def InitialStep(self) -> float:
        """The initial step. Uses time dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetInitialStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @InitialStep.setter
    def InitialStep(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetInitialStep"](arg_inVal.COM_val))

    @property
    def UseFixedStep(self) -> bool:
        """True if running in fixed-step mode."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseFixedStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseFixedStep.setter
    def UseFixedStep(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseFixedStep"](arg_inVal.COM_val))

    @property
    def UseMaxStep(self) -> bool:
        """Whether or not to enforce the maximum step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseMaxStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseMaxStep.setter
    def UseMaxStep(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseMaxStep"](arg_inVal.COM_val))

    @property
    def UseMinStep(self) -> bool:
        """Whether or not to enforce the minimum step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetUseMinStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @UseMinStep.setter
    def UseMinStep(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetUseMinStep"](arg_inVal.COM_val))

    @property
    def MaxStep(self) -> float:
        """The maximum step size to allow (absolute value). Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxStep.setter
    def MaxStep(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxStep"](arg_inVal.COM_val))

    @property
    def MinStep(self) -> float:
        """The minimum step size to allow (absolute value). Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMinStep"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MinStep.setter
    def MinStep(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMinStep"](arg_inVal.COM_val))

    @property
    def MaxRelErr(self) -> float:
        """The maximum relative error used to control step size. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxRelErr"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxRelErr.setter
    def MaxRelErr(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxRelErr"](arg_inVal.COM_val))

    @property
    def MaxAbsErr(self) -> float:
        """The maximum absolute error; Also used if relative scale is too small. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxAbsErr"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxAbsErr.setter
    def MaxAbsErr(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxAbsErr"](arg_inVal.COM_val))

    @property
    def HighSafetyCoefficient(self) -> float:
        """The 'safety' coefficient used to decrease step size if the error is too high. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetHighSafetyCoefficient"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @HighSafetyCoefficient.setter
    def HighSafetyCoefficient(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetHighSafetyCoefficient"](arg_inVal.COM_val))

    @property
    def LowSafetyCoefficient(self) -> float:
        """The 'safety' coefficient used to increase step size if the error is too low. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetLowSafetyCoefficient"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @LowSafetyCoefficient.setter
    def LowSafetyCoefficient(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetLowSafetyCoefficient"](arg_inVal.COM_val))

    @property
    def ErrorControl(self) -> "AgEVAErrorControl":
        """The error control method."""
        with agmarshall.AgEnum_arg(AgEVAErrorControl) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetErrorControl"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ErrorControl.setter
    def ErrorControl(self, inVal:"AgEVAErrorControl") -> None:
        with agmarshall.AgEnum_arg(AgEVAErrorControl, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetErrorControl"](arg_inVal.COM_val))

    @property
    def MaxIterations(self) -> int:
        """The maximum iterations. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetMaxIterations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @MaxIterations.setter
    def MaxIterations(self, inVal:int) -> None:
        with agmarshall.LONG_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetMaxIterations"](arg_inVal.COM_val))

    @property
    def CoeffType(self) -> "AgEVACoeffRKV8th9th":
        """The set of coefficients to use."""
        with agmarshall.AgEnum_arg(AgEVACoeffRKV8th9th) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_GetCoeffType"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @CoeffType.setter
    def CoeffType(self, inVal:"AgEVACoeffRKV8th9th") -> None:
        with agmarshall.AgEnum_arg(AgEVACoeffRKV8th9th, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_SetCoeffType"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E4CEAA67-BE78-472F-B746-52878835E818}", IVARKV8th9th)
agcls.AgTypeNameMap["IVARKV8th9th"] = IVARKV8th9th



class VADriverMCS(IVADriverMCS, IVePropagator):
    """Basic properties of an Astrogator satellite."""
    def __init__(self, sourceObject=None):
        IVADriverMCS.__init__(self, sourceObject)
        IVePropagator.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVADriverMCS._private_init(self, pUnk)
        IVePropagator._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVADriverMCS._get_property(self, attrname) is not None: found_prop = IVADriverMCS._get_property(self, attrname)
        if IVePropagator._get_property(self, attrname) is not None: found_prop = IVePropagator._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VADriverMCS.")
        
agcls.AgClassCatalog.add_catalog_entry("{56D84C70-9D0D-4ACA-8CE5-C41E951E024C}", VADriverMCS)


class VAMCSSegmentCollection(IVAMCSSegmentCollection, IRuntimeTypeInfoProvider):
    """The Mission Control Sequence."""
    def __init__(self, sourceObject=None):
        IVAMCSSegmentCollection.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAMCSSegmentCollection._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAMCSSegmentCollection._get_property(self, attrname) is not None: found_prop = IVAMCSSegmentCollection._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAMCSSegmentCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{B2F91182-1E74-4422-A660-6250A42732C3}", VAMCSSegmentCollection)


class VAMCSEnd(IVAMCSEnd, IVAMCSSegment, IRuntimeTypeInfoProvider, IComponentInfo):
    """The End segment."""
    def __init__(self, sourceObject=None):
        IVAMCSEnd.__init__(self, sourceObject)
        IVAMCSSegment.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAMCSEnd._private_init(self, pUnk)
        IVAMCSSegment._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAMCSEnd._get_property(self, attrname) is not None: found_prop = IVAMCSEnd._get_property(self, attrname)
        if IVAMCSSegment._get_property(self, attrname) is not None: found_prop = IVAMCSSegment._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAMCSEnd.")
        
agcls.AgClassCatalog.add_catalog_entry("{048FE652-88E7-4000-B371-A2D708599F34}", VAMCSEnd)


class VAMCSInitialState(IVAMCSInitialState, IVAMCSSegment, IRuntimeTypeInfoProvider, IComponentInfo, ICloneable):
    """The Initial State segment."""
    def __init__(self, sourceObject=None):
        IVAMCSInitialState.__init__(self, sourceObject)
        IVAMCSSegment.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAMCSInitialState._private_init(self, pUnk)
        IVAMCSSegment._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAMCSInitialState._get_property(self, attrname) is not None: found_prop = IVAMCSInitialState._get_property(self, attrname)
        if IVAMCSSegment._get_property(self, attrname) is not None: found_prop = IVAMCSSegment._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAMCSInitialState.")
        
agcls.AgClassCatalog.add_catalog_entry("{E3010ADE-CB96-470C-B380-3C58B23173AC}", VAMCSInitialState)


class VASpacecraftParameters(IVASpacecraftParameters, IRuntimeTypeInfoProvider):
    """Spacecraft parameters."""
    def __init__(self, sourceObject=None):
        IVASpacecraftParameters.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVASpacecraftParameters._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVASpacecraftParameters._get_property(self, attrname) is not None: found_prop = IVASpacecraftParameters._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VASpacecraftParameters.")
        
agcls.AgClassCatalog.add_catalog_entry("{75F1E929-B0B9-4AE8-8C84-7273B9211771}", VASpacecraftParameters)


class VAFuelTank(IVAFuelTank, IRuntimeTypeInfoProvider):
    """Fuel Tank parameters."""
    def __init__(self, sourceObject=None):
        IVAFuelTank.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAFuelTank._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAFuelTank._get_property(self, attrname) is not None: found_prop = IVAFuelTank._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAFuelTank.")
        
agcls.AgClassCatalog.add_catalog_entry("{03CC0FE4-A9E2-4F80-8AC8-C510F9691D3B}", VAFuelTank)


class VAElementCartesian(IVAElementCartesian, IVAElement, IRuntimeTypeInfoProvider):
    """Cartesian elements."""
    def __init__(self, sourceObject=None):
        IVAElementCartesian.__init__(self, sourceObject)
        IVAElement.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAElementCartesian._private_init(self, pUnk)
        IVAElement._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAElementCartesian._get_property(self, attrname) is not None: found_prop = IVAElementCartesian._get_property(self, attrname)
        if IVAElement._get_property(self, attrname) is not None: found_prop = IVAElement._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAElementCartesian.")
        
agcls.AgClassCatalog.add_catalog_entry("{8C98158E-6B98-4C50-8500-7ABCE96A049E}", VAElementCartesian)


class VAElementKeplerian(IVAElementKeplerian, IVAElement):
    """Keplerian elements."""
    def __init__(self, sourceObject=None):
        IVAElementKeplerian.__init__(self, sourceObject)
        IVAElement.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAElementKeplerian._private_init(self, pUnk)
        IVAElement._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAElementKeplerian._get_property(self, attrname) is not None: found_prop = IVAElementKeplerian._get_property(self, attrname)
        if IVAElement._get_property(self, attrname) is not None: found_prop = IVAElement._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAElementKeplerian.")
        
agcls.AgClassCatalog.add_catalog_entry("{F34624C5-E351-4321-B16E-04DB098F9E29}", VAElementKeplerian)


class VAElementEquinoctial(IVAElementEquinoctial, IVAElement):
    """Equinoctial elements."""
    def __init__(self, sourceObject=None):
        IVAElementEquinoctial.__init__(self, sourceObject)
        IVAElement.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAElementEquinoctial._private_init(self, pUnk)
        IVAElement._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAElementEquinoctial._get_property(self, attrname) is not None: found_prop = IVAElementEquinoctial._get_property(self, attrname)
        if IVAElement._get_property(self, attrname) is not None: found_prop = IVAElement._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAElementEquinoctial.")
        
agcls.AgClassCatalog.add_catalog_entry("{5588137F-A05E-4011-A219-925F175F1447}", VAElementEquinoctial)


class VAElementDelaunay(IVAElementDelaunay, IVAElement):
    """Delaunay elements."""
    def __init__(self, sourceObject=None):
        IVAElementDelaunay.__init__(self, sourceObject)
        IVAElement.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAElementDelaunay._private_init(self, pUnk)
        IVAElement._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAElementDelaunay._get_property(self, attrname) is not None: found_prop = IVAElementDelaunay._get_property(self, attrname)
        if IVAElement._get_property(self, attrname) is not None: found_prop = IVAElement._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAElementDelaunay.")
        
agcls.AgClassCatalog.add_catalog_entry("{FDE891B2-2C91-48A8-B4C0-956BD55B8496}", VAElementDelaunay)


class VAElementMixedSpherical(IVAElementMixedSpherical, IVAElement):
    """Mixed Spherical elements."""
    def __init__(self, sourceObject=None):
        IVAElementMixedSpherical.__init__(self, sourceObject)
        IVAElement.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAElementMixedSpherical._private_init(self, pUnk)
        IVAElement._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAElementMixedSpherical._get_property(self, attrname) is not None: found_prop = IVAElementMixedSpherical._get_property(self, attrname)
        if IVAElement._get_property(self, attrname) is not None: found_prop = IVAElement._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAElementMixedSpherical.")
        
agcls.AgClassCatalog.add_catalog_entry("{C6E11D55-8708-4667-AC84-8FC413A32FF0}", VAElementMixedSpherical)


class VAElementSpherical(IVAElementSpherical, IVAElement):
    """Spherical elements."""
    def __init__(self, sourceObject=None):
        IVAElementSpherical.__init__(self, sourceObject)
        IVAElement.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAElementSpherical._private_init(self, pUnk)
        IVAElement._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAElementSpherical._get_property(self, attrname) is not None: found_prop = IVAElementSpherical._get_property(self, attrname)
        if IVAElement._get_property(self, attrname) is not None: found_prop = IVAElement._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAElementSpherical.")
        
agcls.AgClassCatalog.add_catalog_entry("{ECF59D66-A748-47DD-BD0E-C8FD0CD78D05}", VAElementSpherical)


class VAElementTargetVectorIncomingAsymptote(IVAElementTargetVectorIncomingAsymptote, IVAElement):
    """Target Vector Incoming Asymptote elements."""
    def __init__(self, sourceObject=None):
        IVAElementTargetVectorIncomingAsymptote.__init__(self, sourceObject)
        IVAElement.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAElementTargetVectorIncomingAsymptote._private_init(self, pUnk)
        IVAElement._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAElementTargetVectorIncomingAsymptote._get_property(self, attrname) is not None: found_prop = IVAElementTargetVectorIncomingAsymptote._get_property(self, attrname)
        if IVAElement._get_property(self, attrname) is not None: found_prop = IVAElement._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAElementTargetVectorIncomingAsymptote.")
        
agcls.AgClassCatalog.add_catalog_entry("{E05BEA68-902F-427F-9E65-A33FBE044A75}", VAElementTargetVectorIncomingAsymptote)


class VAElementTargetVectorOutgoingAsymptote(IVAElementTargetVectorOutgoingAsymptote, IVAElement):
    """Target Vector Outgoing Asymptote elements."""
    def __init__(self, sourceObject=None):
        IVAElementTargetVectorOutgoingAsymptote.__init__(self, sourceObject)
        IVAElement.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAElementTargetVectorOutgoingAsymptote._private_init(self, pUnk)
        IVAElement._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAElementTargetVectorOutgoingAsymptote._get_property(self, attrname) is not None: found_prop = IVAElementTargetVectorOutgoingAsymptote._get_property(self, attrname)
        if IVAElement._get_property(self, attrname) is not None: found_prop = IVAElement._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAElementTargetVectorOutgoingAsymptote.")
        
agcls.AgClassCatalog.add_catalog_entry("{95B24C8E-7781-4FA6-8A70-49443C5FFCF9}", VAElementTargetVectorOutgoingAsymptote)


class VAElementGeodetic(IVAElementGeodetic, IVAElement):
    """Geodetic elements."""
    def __init__(self, sourceObject=None):
        IVAElementGeodetic.__init__(self, sourceObject)
        IVAElement.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAElementGeodetic._private_init(self, pUnk)
        IVAElement._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAElementGeodetic._get_property(self, attrname) is not None: found_prop = IVAElementGeodetic._get_property(self, attrname)
        if IVAElement._get_property(self, attrname) is not None: found_prop = IVAElement._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAElementGeodetic.")
        
agcls.AgClassCatalog.add_catalog_entry("{6E74D006-FB3C-4085-810E-9B1E5AE73905}", VAElementGeodetic)


class VAElementBPlane(IVAElementBPlane, IVAElement):
    """Bplane elements."""
    def __init__(self, sourceObject=None):
        IVAElementBPlane.__init__(self, sourceObject)
        IVAElement.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAElementBPlane._private_init(self, pUnk)
        IVAElement._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAElementBPlane._get_property(self, attrname) is not None: found_prop = IVAElementBPlane._get_property(self, attrname)
        if IVAElement._get_property(self, attrname) is not None: found_prop = IVAElement._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAElementBPlane.")
        
agcls.AgClassCatalog.add_catalog_entry("{3F43BB61-B15A-479A-AE38-567C7FEE6A7B}", VAElementBPlane)


class VAMCSPropagate(IVAMCSSegment, IVAMCSPropagate, IComponentInfo, ICloneable, IRuntimeTypeInfoProvider):
    """The Propagate segment."""
    def __init__(self, sourceObject=None):
        IVAMCSSegment.__init__(self, sourceObject)
        IVAMCSPropagate.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAMCSSegment._private_init(self, pUnk)
        IVAMCSPropagate._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAMCSSegment._get_property(self, attrname) is not None: found_prop = IVAMCSSegment._get_property(self, attrname)
        if IVAMCSPropagate._get_property(self, attrname) is not None: found_prop = IVAMCSPropagate._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAMCSPropagate.")
        
agcls.AgClassCatalog.add_catalog_entry("{172B88CD-3CDC-4818-A03E-6538C4FD3B8D}", VAMCSPropagate)


class VAState(IVAState, IRuntimeTypeInfoProvider):
    """The orbit state."""
    def __init__(self, sourceObject=None):
        IVAState.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAState._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAState._get_property(self, attrname) is not None: found_prop = IVAState._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAState.")
        
agcls.AgClassCatalog.add_catalog_entry("{D09183D5-B72C-428B-B586-CD67D09B7BC1}", VAState)


class VAStoppingConditionCollection(IVAStoppingConditionCollection, IRuntimeTypeInfoProvider):
    """The stopping conditions collection."""
    def __init__(self, sourceObject=None):
        IVAStoppingConditionCollection.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAStoppingConditionCollection._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAStoppingConditionCollection._get_property(self, attrname) is not None: found_prop = IVAStoppingConditionCollection._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStoppingConditionCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{9301C787-450F-49B9-B5BD-E263F5DEF4AF}", VAStoppingConditionCollection)


class VAAccessStoppingCondition(IComponentInfo, ICloneable, IVAAccessStoppingCondition, IVAStoppingConditionComponent, IRuntimeTypeInfoProvider):
    """The Access stopping condition."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAAccessStoppingCondition.__init__(self, sourceObject)
        IVAStoppingConditionComponent.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAAccessStoppingCondition._private_init(self, pUnk)
        IVAStoppingConditionComponent._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAAccessStoppingCondition._get_property(self, attrname) is not None: found_prop = IVAAccessStoppingCondition._get_property(self, attrname)
        if IVAStoppingConditionComponent._get_property(self, attrname) is not None: found_prop = IVAStoppingConditionComponent._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAAccessStoppingCondition.")
        
agcls.AgClassCatalog.add_catalog_entry("{7526A10E-68CF-42C7-A1B6-DC58E4C83F8B}", VAAccessStoppingCondition)


class VALightingStoppingCondition(IComponentInfo, ICloneable, IVALightingStoppingCondition, IVAStoppingConditionComponent, IRuntimeTypeInfoProvider):
    """The Lighting stopping condition."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVALightingStoppingCondition.__init__(self, sourceObject)
        IVAStoppingConditionComponent.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVALightingStoppingCondition._private_init(self, pUnk)
        IVAStoppingConditionComponent._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVALightingStoppingCondition._get_property(self, attrname) is not None: found_prop = IVALightingStoppingCondition._get_property(self, attrname)
        if IVAStoppingConditionComponent._get_property(self, attrname) is not None: found_prop = IVAStoppingConditionComponent._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VALightingStoppingCondition.")
        
agcls.AgClassCatalog.add_catalog_entry("{9AE4C815-0880-4912-A024-7A326AF7F9BB}", VALightingStoppingCondition)


class VAStoppingCondition(IVAStoppingCondition, IComponentInfo, ICloneable, IVAStoppingConditionComponent, IRuntimeTypeInfoProvider):
    """A stopping condition."""
    def __init__(self, sourceObject=None):
        IVAStoppingCondition.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStoppingConditionComponent.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAStoppingCondition._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStoppingConditionComponent._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAStoppingCondition._get_property(self, attrname) is not None: found_prop = IVAStoppingCondition._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStoppingConditionComponent._get_property(self, attrname) is not None: found_prop = IVAStoppingConditionComponent._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStoppingCondition.")
        
agcls.AgClassCatalog.add_catalog_entry("{87FDFED8-E83F-4963-92BD-4F151BE3E5CA}", VAStoppingCondition)


class VAStoppingConditionElement(IVAStoppingConditionElement, IComponentInfo, IRuntimeTypeInfoProvider):
    """A stopping condition."""
    def __init__(self, sourceObject=None):
        IVAStoppingConditionElement.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAStoppingConditionElement._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAStoppingConditionElement._get_property(self, attrname) is not None: found_prop = IVAStoppingConditionElement._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStoppingConditionElement.")
        
agcls.AgClassCatalog.add_catalog_entry("{EBE02320-241C-462D-93F5-1BE2B72C8FB5}", VAStoppingConditionElement)


class VAMCSSequence(IVAMCSSegment, IRuntimeTypeInfoProvider, IVAMCSSequence, IComponentInfo, ICloneable):
    """The Sequence segment."""
    def __init__(self, sourceObject=None):
        IVAMCSSegment.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
        IVAMCSSequence.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAMCSSegment._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
        IVAMCSSequence._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAMCSSegment._get_property(self, attrname) is not None: found_prop = IVAMCSSegment._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if IVAMCSSequence._get_property(self, attrname) is not None: found_prop = IVAMCSSequence._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAMCSSequence.")
        
agcls.AgClassCatalog.add_catalog_entry("{9D98B9CE-047C-419E-9A58-5939ECD853EF}", VAMCSSequence)


class VAMCSBackwardSequence(IVAMCSSegment, IRuntimeTypeInfoProvider, IVAMCSBackwardSequence, IVAMCSSequence, IComponentInfo, ICloneable):
    """The Backward Sequence segment."""
    def __init__(self, sourceObject=None):
        IVAMCSSegment.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
        IVAMCSBackwardSequence.__init__(self, sourceObject)
        IVAMCSSequence.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAMCSSegment._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
        IVAMCSBackwardSequence._private_init(self, pUnk)
        IVAMCSSequence._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAMCSSegment._get_property(self, attrname) is not None: found_prop = IVAMCSSegment._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if IVAMCSBackwardSequence._get_property(self, attrname) is not None: found_prop = IVAMCSBackwardSequence._get_property(self, attrname)
        if IVAMCSSequence._get_property(self, attrname) is not None: found_prop = IVAMCSSequence._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAMCSBackwardSequence.")
        
agcls.AgClassCatalog.add_catalog_entry("{EDA33DE4-2AE3-4C19-87A4-2A3215ADB6FE}", VAMCSBackwardSequence)


class VAMCSLaunch(IVAMCSSegment, IRuntimeTypeInfoProvider, IVAMCSLaunch, IComponentInfo, ICloneable):
    """The Launch segment."""
    def __init__(self, sourceObject=None):
        IVAMCSSegment.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
        IVAMCSLaunch.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAMCSSegment._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
        IVAMCSLaunch._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAMCSSegment._get_property(self, attrname) is not None: found_prop = IVAMCSSegment._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if IVAMCSLaunch._get_property(self, attrname) is not None: found_prop = IVAMCSLaunch._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAMCSLaunch.")
        
agcls.AgClassCatalog.add_catalog_entry("{1540C136-4AA5-449B-A845-A822E99422E2}", VAMCSLaunch)


class VADisplaySystemGeodetic(IVADisplaySystemGeodetic, IVADisplaySystem):
    """The geodetic launch location."""
    def __init__(self, sourceObject=None):
        IVADisplaySystemGeodetic.__init__(self, sourceObject)
        IVADisplaySystem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVADisplaySystemGeodetic._private_init(self, pUnk)
        IVADisplaySystem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVADisplaySystemGeodetic._get_property(self, attrname) is not None: found_prop = IVADisplaySystemGeodetic._get_property(self, attrname)
        if IVADisplaySystem._get_property(self, attrname) is not None: found_prop = IVADisplaySystem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VADisplaySystemGeodetic.")
        
agcls.AgClassCatalog.add_catalog_entry("{792B26D7-7643-47F5-8BBD-B4FE0708F3AB}", VADisplaySystemGeodetic)


class VADisplaySystemGeocentric(IVADisplaySystemGeocentric, IVADisplaySystem):
    """The geocentric launch location."""
    def __init__(self, sourceObject=None):
        IVADisplaySystemGeocentric.__init__(self, sourceObject)
        IVADisplaySystem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVADisplaySystemGeocentric._private_init(self, pUnk)
        IVADisplaySystem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVADisplaySystemGeocentric._get_property(self, attrname) is not None: found_prop = IVADisplaySystemGeocentric._get_property(self, attrname)
        if IVADisplaySystem._get_property(self, attrname) is not None: found_prop = IVADisplaySystem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VADisplaySystemGeocentric.")
        
agcls.AgClassCatalog.add_catalog_entry("{32F981ED-81EA-4C65-87DF-DC725A979056}", VADisplaySystemGeocentric)


class VABurnoutGeodetic(IVABurnoutGeodetic, IVABurnout):
    """The geodetic burnout point."""
    def __init__(self, sourceObject=None):
        IVABurnoutGeodetic.__init__(self, sourceObject)
        IVABurnout.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVABurnoutGeodetic._private_init(self, pUnk)
        IVABurnout._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVABurnoutGeodetic._get_property(self, attrname) is not None: found_prop = IVABurnoutGeodetic._get_property(self, attrname)
        if IVABurnout._get_property(self, attrname) is not None: found_prop = IVABurnout._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VABurnoutGeodetic.")
        
agcls.AgClassCatalog.add_catalog_entry("{011100E5-8DE0-4CE1-BC6D-F66B77814B78}", VABurnoutGeodetic)


class VABurnoutCBFCartesian(IVABurnoutCBFCartesian, IVABurnout):
    """The burnout state in CBF Cartesian coordinates."""
    def __init__(self, sourceObject=None):
        IVABurnoutCBFCartesian.__init__(self, sourceObject)
        IVABurnout.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVABurnoutCBFCartesian._private_init(self, pUnk)
        IVABurnout._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVABurnoutCBFCartesian._get_property(self, attrname) is not None: found_prop = IVABurnoutCBFCartesian._get_property(self, attrname)
        if IVABurnout._get_property(self, attrname) is not None: found_prop = IVABurnout._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VABurnoutCBFCartesian.")
        
agcls.AgClassCatalog.add_catalog_entry("{3EE3ED29-6154-49CA-93C4-8623E801B58F}", VABurnoutCBFCartesian)


class VABurnoutGeocentric(IVABurnoutGeocentric, IVABurnout):
    """The geocentric burnout point."""
    def __init__(self, sourceObject=None):
        IVABurnoutGeocentric.__init__(self, sourceObject)
        IVABurnout.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVABurnoutGeocentric._private_init(self, pUnk)
        IVABurnout._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVABurnoutGeocentric._get_property(self, attrname) is not None: found_prop = IVABurnoutGeocentric._get_property(self, attrname)
        if IVABurnout._get_property(self, attrname) is not None: found_prop = IVABurnout._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VABurnoutGeocentric.")
        
agcls.AgClassCatalog.add_catalog_entry("{B7BD1F63-9D91-4DA5-9099-D6BE607F2702}", VABurnoutGeocentric)


class VABurnoutLaunchAzAlt(IVABurnoutLaunchAzAlt, IVABurnout):
    """The launch azimuth and altitude burnout point."""
    def __init__(self, sourceObject=None):
        IVABurnoutLaunchAzAlt.__init__(self, sourceObject)
        IVABurnout.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVABurnoutLaunchAzAlt._private_init(self, pUnk)
        IVABurnout._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVABurnoutLaunchAzAlt._get_property(self, attrname) is not None: found_prop = IVABurnoutLaunchAzAlt._get_property(self, attrname)
        if IVABurnout._get_property(self, attrname) is not None: found_prop = IVABurnout._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VABurnoutLaunchAzAlt.")
        
agcls.AgClassCatalog.add_catalog_entry("{E5A780AE-0173-4FF8-AD0F-43886E1FAE85}", VABurnoutLaunchAzAlt)


class VABurnoutLaunchAzRadius(IVABurnoutLaunchAzRadius, IVABurnout):
    """The launch azimuth and radius burnout point."""
    def __init__(self, sourceObject=None):
        IVABurnoutLaunchAzRadius.__init__(self, sourceObject)
        IVABurnout.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVABurnoutLaunchAzRadius._private_init(self, pUnk)
        IVABurnout._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVABurnoutLaunchAzRadius._get_property(self, attrname) is not None: found_prop = IVABurnoutLaunchAzRadius._get_property(self, attrname)
        if IVABurnout._get_property(self, attrname) is not None: found_prop = IVABurnout._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VABurnoutLaunchAzRadius.")
        
agcls.AgClassCatalog.add_catalog_entry("{ABC361CE-B104-427C-BDDB-CF77EBDC9B8E}", VABurnoutLaunchAzRadius)


class VABurnoutVelocity(IVABurnoutVelocity):
    """The burnout velocity."""
    def __init__(self, sourceObject=None):
        IVABurnoutVelocity.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVABurnoutVelocity._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVABurnoutVelocity._get_property(self, attrname) is not None: found_prop = IVABurnoutVelocity._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VABurnoutVelocity.")
        
agcls.AgClassCatalog.add_catalog_entry("{DFD439A9-42BD-4A59-9681-A70BBC94E083}", VABurnoutVelocity)


class VAMCSFollow(IVAMCSSegment, IRuntimeTypeInfoProvider, IVAMCSFollow, IComponentInfo, ICloneable):
    """The Follow segment."""
    def __init__(self, sourceObject=None):
        IVAMCSSegment.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
        IVAMCSFollow.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAMCSSegment._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
        IVAMCSFollow._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAMCSSegment._get_property(self, attrname) is not None: found_prop = IVAMCSSegment._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if IVAMCSFollow._get_property(self, attrname) is not None: found_prop = IVAMCSFollow._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAMCSFollow.")
        
agcls.AgClassCatalog.add_catalog_entry("{322FC7F6-FCDF-408B-A31C-F25A1F5456EB}", VAMCSFollow)


class VAMCSManeuver(IVAMCSSegment, IRuntimeTypeInfoProvider, IVAMCSManeuver, IComponentInfo, ICloneable):
    """The Maneuver segment."""
    def __init__(self, sourceObject=None):
        IVAMCSSegment.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
        IVAMCSManeuver.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAMCSSegment._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
        IVAMCSManeuver._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAMCSSegment._get_property(self, attrname) is not None: found_prop = IVAMCSSegment._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if IVAMCSManeuver._get_property(self, attrname) is not None: found_prop = IVAMCSManeuver._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAMCSManeuver.")
        
agcls.AgClassCatalog.add_catalog_entry("{1EE05100-A5B8-4820-9C6D-F4AE0639E1EE}", VAMCSManeuver)


class VAManeuverFinite(IVAManeuverFinite, IVAManeuver, IRuntimeTypeInfoProvider):
    """The Finite Maneuver."""
    def __init__(self, sourceObject=None):
        IVAManeuverFinite.__init__(self, sourceObject)
        IVAManeuver.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAManeuverFinite._private_init(self, pUnk)
        IVAManeuver._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAManeuverFinite._get_property(self, attrname) is not None: found_prop = IVAManeuverFinite._get_property(self, attrname)
        if IVAManeuver._get_property(self, attrname) is not None: found_prop = IVAManeuver._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAManeuverFinite.")
        
agcls.AgClassCatalog.add_catalog_entry("{22EAD08A-6355-48BA-96EC-5DD996A5D926}", VAManeuverFinite)


class VAManeuverImpulsive(IVAManeuverImpulsive, IVAManeuver, IRuntimeTypeInfoProvider):
    """The Impulsive Maneuver."""
    def __init__(self, sourceObject=None):
        IVAManeuverImpulsive.__init__(self, sourceObject)
        IVAManeuver.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAManeuverImpulsive._private_init(self, pUnk)
        IVAManeuver._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAManeuverImpulsive._get_property(self, attrname) is not None: found_prop = IVAManeuverImpulsive._get_property(self, attrname)
        if IVAManeuver._get_property(self, attrname) is not None: found_prop = IVAManeuver._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAManeuverImpulsive.")
        
agcls.AgClassCatalog.add_catalog_entry("{E4DCF8C5-987F-4739-9592-E4C49B9A827E}", VAManeuverImpulsive)


class VAAttitudeControlImpulsiveVelocityVector(IVAAttitudeControlImpulsiveVelocityVector, IVAAttitudeControlImpulsive, IVAAttitudeControl, IRuntimeTypeInfoProvider):
    """The velocity vector attitude control for an impulsive maneuver."""
    def __init__(self, sourceObject=None):
        IVAAttitudeControlImpulsiveVelocityVector.__init__(self, sourceObject)
        IVAAttitudeControlImpulsive.__init__(self, sourceObject)
        IVAAttitudeControl.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAAttitudeControlImpulsiveVelocityVector._private_init(self, pUnk)
        IVAAttitudeControlImpulsive._private_init(self, pUnk)
        IVAAttitudeControl._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAAttitudeControlImpulsiveVelocityVector._get_property(self, attrname) is not None: found_prop = IVAAttitudeControlImpulsiveVelocityVector._get_property(self, attrname)
        if IVAAttitudeControlImpulsive._get_property(self, attrname) is not None: found_prop = IVAAttitudeControlImpulsive._get_property(self, attrname)
        if IVAAttitudeControl._get_property(self, attrname) is not None: found_prop = IVAAttitudeControl._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAAttitudeControlImpulsiveVelocityVector.")
        
agcls.AgClassCatalog.add_catalog_entry("{C466E73A-E301-43C8-8402-700D0CE8DE41}", VAAttitudeControlImpulsiveVelocityVector)


class VAAttitudeControlImpulsiveAntiVelocityVector(IVAAttitudeControlImpulsiveAntiVelocityVector, IVAAttitudeControlImpulsive, IVAAttitudeControl, IRuntimeTypeInfoProvider):
    """The anti-velocity vector attitude control for an impulsive maneuver."""
    def __init__(self, sourceObject=None):
        IVAAttitudeControlImpulsiveAntiVelocityVector.__init__(self, sourceObject)
        IVAAttitudeControlImpulsive.__init__(self, sourceObject)
        IVAAttitudeControl.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAAttitudeControlImpulsiveAntiVelocityVector._private_init(self, pUnk)
        IVAAttitudeControlImpulsive._private_init(self, pUnk)
        IVAAttitudeControl._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAAttitudeControlImpulsiveAntiVelocityVector._get_property(self, attrname) is not None: found_prop = IVAAttitudeControlImpulsiveAntiVelocityVector._get_property(self, attrname)
        if IVAAttitudeControlImpulsive._get_property(self, attrname) is not None: found_prop = IVAAttitudeControlImpulsive._get_property(self, attrname)
        if IVAAttitudeControl._get_property(self, attrname) is not None: found_prop = IVAAttitudeControl._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAAttitudeControlImpulsiveAntiVelocityVector.")
        
agcls.AgClassCatalog.add_catalog_entry("{B51D8BDC-E2A5-484C-8CB8-88E4D1BBC5A1}", VAAttitudeControlImpulsiveAntiVelocityVector)


class VAAttitudeControlImpulsiveAttitude(IVAAttitudeControlImpulsiveAttitude, IVAAttitudeControlImpulsive, IVAAttitudeControl, IRuntimeTypeInfoProvider):
    """The attitude attitude control for an impulsive maneuver."""
    def __init__(self, sourceObject=None):
        IVAAttitudeControlImpulsiveAttitude.__init__(self, sourceObject)
        IVAAttitudeControlImpulsive.__init__(self, sourceObject)
        IVAAttitudeControl.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAAttitudeControlImpulsiveAttitude._private_init(self, pUnk)
        IVAAttitudeControlImpulsive._private_init(self, pUnk)
        IVAAttitudeControl._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAAttitudeControlImpulsiveAttitude._get_property(self, attrname) is not None: found_prop = IVAAttitudeControlImpulsiveAttitude._get_property(self, attrname)
        if IVAAttitudeControlImpulsive._get_property(self, attrname) is not None: found_prop = IVAAttitudeControlImpulsive._get_property(self, attrname)
        if IVAAttitudeControl._get_property(self, attrname) is not None: found_prop = IVAAttitudeControl._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAAttitudeControlImpulsiveAttitude.")
        
agcls.AgClassCatalog.add_catalog_entry("{8854FD36-7CEA-4FBC-B699-E47007BA7825}", VAAttitudeControlImpulsiveAttitude)


class VAAttitudeControlImpulsiveFile(IVAAttitudeControlImpulsiveFile, IVAAttitudeControlImpulsive, IVAAttitudeControl, IRuntimeTypeInfoProvider):
    """The file attitude control for an impulsive maneuver."""
    def __init__(self, sourceObject=None):
        IVAAttitudeControlImpulsiveFile.__init__(self, sourceObject)
        IVAAttitudeControlImpulsive.__init__(self, sourceObject)
        IVAAttitudeControl.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAAttitudeControlImpulsiveFile._private_init(self, pUnk)
        IVAAttitudeControlImpulsive._private_init(self, pUnk)
        IVAAttitudeControl._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAAttitudeControlImpulsiveFile._get_property(self, attrname) is not None: found_prop = IVAAttitudeControlImpulsiveFile._get_property(self, attrname)
        if IVAAttitudeControlImpulsive._get_property(self, attrname) is not None: found_prop = IVAAttitudeControlImpulsive._get_property(self, attrname)
        if IVAAttitudeControl._get_property(self, attrname) is not None: found_prop = IVAAttitudeControl._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAAttitudeControlImpulsiveFile.")
        
agcls.AgClassCatalog.add_catalog_entry("{18E769AB-177B-4575-A9E0-BBB5BEEA78AE}", VAAttitudeControlImpulsiveFile)


class VAAttitudeControlImpulsiveThrustVector(IVAAttitudeControlImpulsiveThrustVector, IVAAttitudeControlImpulsive, IVAAttitudeControl, IRuntimeTypeInfoProvider):
    """The thrust vector attitude control for an impulsive maneuver."""
    def __init__(self, sourceObject=None):
        IVAAttitudeControlImpulsiveThrustVector.__init__(self, sourceObject)
        IVAAttitudeControlImpulsive.__init__(self, sourceObject)
        IVAAttitudeControl.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAAttitudeControlImpulsiveThrustVector._private_init(self, pUnk)
        IVAAttitudeControlImpulsive._private_init(self, pUnk)
        IVAAttitudeControl._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAAttitudeControlImpulsiveThrustVector._get_property(self, attrname) is not None: found_prop = IVAAttitudeControlImpulsiveThrustVector._get_property(self, attrname)
        if IVAAttitudeControlImpulsive._get_property(self, attrname) is not None: found_prop = IVAAttitudeControlImpulsive._get_property(self, attrname)
        if IVAAttitudeControl._get_property(self, attrname) is not None: found_prop = IVAAttitudeControl._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAAttitudeControlImpulsiveThrustVector.")
        
agcls.AgClassCatalog.add_catalog_entry("{B17F3D0C-2021-4D60-80B7-1F55934FACAF}", VAAttitudeControlImpulsiveThrustVector)


class VAAttitudeControlFiniteAntiVelocityVector(IVAAttitudeControlFiniteAntiVelocityVector, IVAAttitudeControlFinite, IVAAttitudeControl, IRuntimeTypeInfoProvider):
    """The anti-velocity vector attitude control for a finite maneuver."""
    def __init__(self, sourceObject=None):
        IVAAttitudeControlFiniteAntiVelocityVector.__init__(self, sourceObject)
        IVAAttitudeControlFinite.__init__(self, sourceObject)
        IVAAttitudeControl.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAAttitudeControlFiniteAntiVelocityVector._private_init(self, pUnk)
        IVAAttitudeControlFinite._private_init(self, pUnk)
        IVAAttitudeControl._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAAttitudeControlFiniteAntiVelocityVector._get_property(self, attrname) is not None: found_prop = IVAAttitudeControlFiniteAntiVelocityVector._get_property(self, attrname)
        if IVAAttitudeControlFinite._get_property(self, attrname) is not None: found_prop = IVAAttitudeControlFinite._get_property(self, attrname)
        if IVAAttitudeControl._get_property(self, attrname) is not None: found_prop = IVAAttitudeControl._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAAttitudeControlFiniteAntiVelocityVector.")
        
agcls.AgClassCatalog.add_catalog_entry("{2C11B410-A573-446A-9637-A472B987A987}", VAAttitudeControlFiniteAntiVelocityVector)


class VAAttitudeControlFiniteAttitude(IVAAttitudeControlFiniteAttitude, IVAAttitudeControlFinite, IVAAttitudeControl, IRuntimeTypeInfoProvider):
    """The attitude attitude control for a finite maneuver."""
    def __init__(self, sourceObject=None):
        IVAAttitudeControlFiniteAttitude.__init__(self, sourceObject)
        IVAAttitudeControlFinite.__init__(self, sourceObject)
        IVAAttitudeControl.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAAttitudeControlFiniteAttitude._private_init(self, pUnk)
        IVAAttitudeControlFinite._private_init(self, pUnk)
        IVAAttitudeControl._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAAttitudeControlFiniteAttitude._get_property(self, attrname) is not None: found_prop = IVAAttitudeControlFiniteAttitude._get_property(self, attrname)
        if IVAAttitudeControlFinite._get_property(self, attrname) is not None: found_prop = IVAAttitudeControlFinite._get_property(self, attrname)
        if IVAAttitudeControl._get_property(self, attrname) is not None: found_prop = IVAAttitudeControl._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAAttitudeControlFiniteAttitude.")
        
agcls.AgClassCatalog.add_catalog_entry("{EA2C6994-7191-4CEF-9C8D-3BE0AA6BB756}", VAAttitudeControlFiniteAttitude)


class VAAttitudeControlFiniteFile(IVAAttitudeControlFiniteFile, IVAAttitudeControlFinite, IVAAttitudeControl, IRuntimeTypeInfoProvider):
    """The file attitude control for a finite maneuver."""
    def __init__(self, sourceObject=None):
        IVAAttitudeControlFiniteFile.__init__(self, sourceObject)
        IVAAttitudeControlFinite.__init__(self, sourceObject)
        IVAAttitudeControl.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAAttitudeControlFiniteFile._private_init(self, pUnk)
        IVAAttitudeControlFinite._private_init(self, pUnk)
        IVAAttitudeControl._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAAttitudeControlFiniteFile._get_property(self, attrname) is not None: found_prop = IVAAttitudeControlFiniteFile._get_property(self, attrname)
        if IVAAttitudeControlFinite._get_property(self, attrname) is not None: found_prop = IVAAttitudeControlFinite._get_property(self, attrname)
        if IVAAttitudeControl._get_property(self, attrname) is not None: found_prop = IVAAttitudeControl._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAAttitudeControlFiniteFile.")
        
agcls.AgClassCatalog.add_catalog_entry("{7F2333DC-4E2B-499C-9F14-A4F1932F9C62}", VAAttitudeControlFiniteFile)


class VAAttitudeControlFiniteThrustVector(IVAAttitudeControlFiniteThrustVector, IVAAttitudeControlFinite, IVAAttitudeControl, IRuntimeTypeInfoProvider):
    """The thrust vector attitude control for a finite maneuver."""
    def __init__(self, sourceObject=None):
        IVAAttitudeControlFiniteThrustVector.__init__(self, sourceObject)
        IVAAttitudeControlFinite.__init__(self, sourceObject)
        IVAAttitudeControl.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAAttitudeControlFiniteThrustVector._private_init(self, pUnk)
        IVAAttitudeControlFinite._private_init(self, pUnk)
        IVAAttitudeControl._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAAttitudeControlFiniteThrustVector._get_property(self, attrname) is not None: found_prop = IVAAttitudeControlFiniteThrustVector._get_property(self, attrname)
        if IVAAttitudeControlFinite._get_property(self, attrname) is not None: found_prop = IVAAttitudeControlFinite._get_property(self, attrname)
        if IVAAttitudeControl._get_property(self, attrname) is not None: found_prop = IVAAttitudeControl._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAAttitudeControlFiniteThrustVector.")
        
agcls.AgClassCatalog.add_catalog_entry("{9B31C16F-C862-498D-ADFB-5C4F50D45DF1}", VAAttitudeControlFiniteThrustVector)


class VAAttitudeControlFiniteTimeVarying(IVAAttitudeControlFiniteTimeVarying, IVAAttitudeControlFinite, IVAAttitudeControl, IRuntimeTypeInfoProvider):
    """The time varying attitude control for a finite maneuver."""
    def __init__(self, sourceObject=None):
        IVAAttitudeControlFiniteTimeVarying.__init__(self, sourceObject)
        IVAAttitudeControlFinite.__init__(self, sourceObject)
        IVAAttitudeControl.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAAttitudeControlFiniteTimeVarying._private_init(self, pUnk)
        IVAAttitudeControlFinite._private_init(self, pUnk)
        IVAAttitudeControl._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAAttitudeControlFiniteTimeVarying._get_property(self, attrname) is not None: found_prop = IVAAttitudeControlFiniteTimeVarying._get_property(self, attrname)
        if IVAAttitudeControlFinite._get_property(self, attrname) is not None: found_prop = IVAAttitudeControlFinite._get_property(self, attrname)
        if IVAAttitudeControl._get_property(self, attrname) is not None: found_prop = IVAAttitudeControl._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAAttitudeControlFiniteTimeVarying.")
        
agcls.AgClassCatalog.add_catalog_entry("{F28DCCA6-0AFE-4142-BDB1-0957F1B3CB6F}", VAAttitudeControlFiniteTimeVarying)


class VAAttitudeControlFiniteVelocityVector(IVAAttitudeControlFiniteVelocityVector, IVAAttitudeControlFinite, IVAAttitudeControl, IRuntimeTypeInfoProvider):
    """The velocity vector attitude control for a finite maneuver."""
    def __init__(self, sourceObject=None):
        IVAAttitudeControlFiniteVelocityVector.__init__(self, sourceObject)
        IVAAttitudeControlFinite.__init__(self, sourceObject)
        IVAAttitudeControl.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAAttitudeControlFiniteVelocityVector._private_init(self, pUnk)
        IVAAttitudeControlFinite._private_init(self, pUnk)
        IVAAttitudeControl._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAAttitudeControlFiniteVelocityVector._get_property(self, attrname) is not None: found_prop = IVAAttitudeControlFiniteVelocityVector._get_property(self, attrname)
        if IVAAttitudeControlFinite._get_property(self, attrname) is not None: found_prop = IVAAttitudeControlFinite._get_property(self, attrname)
        if IVAAttitudeControl._get_property(self, attrname) is not None: found_prop = IVAAttitudeControl._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAAttitudeControlFiniteVelocityVector.")
        
agcls.AgClassCatalog.add_catalog_entry("{90EE5B69-A270-4A1D-862F-C7A9A532F33F}", VAAttitudeControlFiniteVelocityVector)


class VAAttitudeControlFinitePlugin(IVAAttitudeControlFinitePlugin, IVAAttitudeControlFinite, IVAAttitudeControl, IRuntimeTypeInfoProvider):
    """The plugin attitude control for a finite maneuver."""
    def __init__(self, sourceObject=None):
        IVAAttitudeControlFinitePlugin.__init__(self, sourceObject)
        IVAAttitudeControlFinite.__init__(self, sourceObject)
        IVAAttitudeControl.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAAttitudeControlFinitePlugin._private_init(self, pUnk)
        IVAAttitudeControlFinite._private_init(self, pUnk)
        IVAAttitudeControl._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAAttitudeControlFinitePlugin._get_property(self, attrname) is not None: found_prop = IVAAttitudeControlFinitePlugin._get_property(self, attrname)
        if IVAAttitudeControlFinite._get_property(self, attrname) is not None: found_prop = IVAAttitudeControlFinite._get_property(self, attrname)
        if IVAAttitudeControl._get_property(self, attrname) is not None: found_prop = IVAAttitudeControl._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAAttitudeControlFinitePlugin.")
        
agcls.AgClassCatalog.add_catalog_entry("{41C29436-C581-4FD2-BFFB-090FCDA9C090}", VAAttitudeControlFinitePlugin)


class VAAttitudeControlOptimalFiniteLagrange(IVAAttitudeControlOptimalFiniteLagrange, IVAAttitudeControlOptimalFinite, IVAAttitudeControl, IRuntimeTypeInfoProvider):
    """The Lagrange Interpolation attitude control for a optimal finite maneuver."""
    def __init__(self, sourceObject=None):
        IVAAttitudeControlOptimalFiniteLagrange.__init__(self, sourceObject)
        IVAAttitudeControlOptimalFinite.__init__(self, sourceObject)
        IVAAttitudeControl.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAAttitudeControlOptimalFiniteLagrange._private_init(self, pUnk)
        IVAAttitudeControlOptimalFinite._private_init(self, pUnk)
        IVAAttitudeControl._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAAttitudeControlOptimalFiniteLagrange._get_property(self, attrname) is not None: found_prop = IVAAttitudeControlOptimalFiniteLagrange._get_property(self, attrname)
        if IVAAttitudeControlOptimalFinite._get_property(self, attrname) is not None: found_prop = IVAAttitudeControlOptimalFinite._get_property(self, attrname)
        if IVAAttitudeControl._get_property(self, attrname) is not None: found_prop = IVAAttitudeControl._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAAttitudeControlOptimalFiniteLagrange.")
        
agcls.AgClassCatalog.add_catalog_entry("{AE88E914-B911-41DB-9811-37CFBC7DAECC}", VAAttitudeControlOptimalFiniteLagrange)


class VAManeuverFinitePropagator(IVAManeuverFinitePropagator, IRuntimeTypeInfoProvider):
    """Propagation for a finite maneuver."""
    def __init__(self, sourceObject=None):
        IVAManeuverFinitePropagator.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAManeuverFinitePropagator._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAManeuverFinitePropagator._get_property(self, attrname) is not None: found_prop = IVAManeuverFinitePropagator._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAManeuverFinitePropagator.")
        
agcls.AgClassCatalog.add_catalog_entry("{4F2C7CA9-D775-4CE0-8297-A8806F56F094}", VAManeuverFinitePropagator)


class VAMCSHold(IVAMCSSegment, IRuntimeTypeInfoProvider, IVAMCSHold, IComponentInfo, ICloneable):
    """The Hold segment."""
    def __init__(self, sourceObject=None):
        IVAMCSSegment.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
        IVAMCSHold.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAMCSSegment._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
        IVAMCSHold._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAMCSSegment._get_property(self, attrname) is not None: found_prop = IVAMCSSegment._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if IVAMCSHold._get_property(self, attrname) is not None: found_prop = IVAMCSHold._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAMCSHold.")
        
agcls.AgClassCatalog.add_catalog_entry("{51159257-B7FD-45E5-AB02-7FEB20D924E5}", VAMCSHold)


class VAMCSUpdate(IVAMCSSegment, IRuntimeTypeInfoProvider, IVAMCSUpdate, IComponentInfo, ICloneable):
    """The Update segment."""
    def __init__(self, sourceObject=None):
        IVAMCSSegment.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
        IVAMCSUpdate.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAMCSSegment._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
        IVAMCSUpdate._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAMCSSegment._get_property(self, attrname) is not None: found_prop = IVAMCSSegment._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if IVAMCSUpdate._get_property(self, attrname) is not None: found_prop = IVAMCSUpdate._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAMCSUpdate.")
        
agcls.AgClassCatalog.add_catalog_entry("{3A975A07-EB14-4231-B8E7-C977B091D8B0}", VAMCSUpdate)


class VAMCSReturn(IVAMCSSegment, IRuntimeTypeInfoProvider, IVAMCSReturn, IComponentInfo, ICloneable):
    """The Return segment."""
    def __init__(self, sourceObject=None):
        IVAMCSSegment.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
        IVAMCSReturn.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAMCSSegment._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
        IVAMCSReturn._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAMCSSegment._get_property(self, attrname) is not None: found_prop = IVAMCSSegment._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if IVAMCSReturn._get_property(self, attrname) is not None: found_prop = IVAMCSReturn._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAMCSReturn.")
        
agcls.AgClassCatalog.add_catalog_entry("{0D4E769A-CBA7-4A17-89BA-F61B59F15D09}", VAMCSReturn)


class VAMCSStop(IVAMCSSegment, IRuntimeTypeInfoProvider, IVAMCSStop, IComponentInfo, ICloneable):
    """The Stop segment."""
    def __init__(self, sourceObject=None):
        IVAMCSSegment.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
        IVAMCSStop.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAMCSSegment._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
        IVAMCSStop._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAMCSSegment._get_property(self, attrname) is not None: found_prop = IVAMCSSegment._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if IVAMCSStop._get_property(self, attrname) is not None: found_prop = IVAMCSStop._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAMCSStop.")
        
agcls.AgClassCatalog.add_catalog_entry("{59CF0A59-0E77-4D5F-BE88-E151D8899331}", VAMCSStop)


class VAMCSTargetSequence(IVAMCSSegment, IRuntimeTypeInfoProvider, IVAMCSTargetSequence, IComponentInfo, ICloneable):
    """The Target Sequence segment."""
    def __init__(self, sourceObject=None):
        IVAMCSSegment.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
        IVAMCSTargetSequence.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAMCSSegment._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
        IVAMCSTargetSequence._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAMCSSegment._get_property(self, attrname) is not None: found_prop = IVAMCSSegment._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if IVAMCSTargetSequence._get_property(self, attrname) is not None: found_prop = IVAMCSTargetSequence._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAMCSTargetSequence.")
        
agcls.AgClassCatalog.add_catalog_entry("{DF528E2E-3CFD-4935-9A24-B9C9D8C0E727}", VAMCSTargetSequence)


class VAProfileCollection(IVAProfileCollection, IRuntimeTypeInfoProvider):
    """The Profiles of a Target Sequence."""
    def __init__(self, sourceObject=None):
        IVAProfileCollection.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAProfileCollection._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAProfileCollection._get_property(self, attrname) is not None: found_prop = IVAProfileCollection._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAProfileCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{37B58077-200F-4763-8ED2-C4B5AFA97B2E}", VAProfileCollection)


class VAMCSOptions(IVAMCSOptions):
    """The MCS Options."""
    def __init__(self, sourceObject=None):
        IVAMCSOptions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAMCSOptions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAMCSOptions._get_property(self, attrname) is not None: found_prop = IVAMCSOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAMCSOptions.")
        
agcls.AgClassCatalog.add_catalog_entry("{0A469F1B-225A-48E3-9B89-0EC63C95D705}", VAMCSOptions)


class VACalcObjectCollection(IVACalcObjectCollection):
    """The Calculation Object component folder."""
    def __init__(self, sourceObject=None):
        IVACalcObjectCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVACalcObjectCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVACalcObjectCollection._get_property(self, attrname) is not None: found_prop = IVACalcObjectCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VACalcObjectCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{9C6165FC-8537-4B53-AC20-66F2C670A7A9}", VACalcObjectCollection)


class VAConstraintCollection(IVAConstraintCollection):
    """The Constraint component folder."""
    def __init__(self, sourceObject=None):
        IVAConstraintCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAConstraintCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAConstraintCollection._get_property(self, attrname) is not None: found_prop = IVAConstraintCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAConstraintCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{D992E5D5-AE65-4041-B3A8-DF2244DE2068}", VAConstraintCollection)


class VAPluginProperties(IVAPluginProperties):
    """The plugin attitude control type."""
    def __init__(self, sourceObject=None):
        IVAPluginProperties.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAPluginProperties._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAPluginProperties._get_property(self, attrname) is not None: found_prop = IVAPluginProperties._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAPluginProperties.")
        
agcls.AgClassCatalog.add_catalog_entry("{A115E060-4BB8-430F-AB23-2BBE3C0C2087}", VAPluginProperties)


class VAProfileSearchPlugin(IVAProfileSearchPlugin, IVAProfile, IRuntimeTypeInfoProvider):
    """The plugin search profile."""
    def __init__(self, sourceObject=None):
        IVAProfileSearchPlugin.__init__(self, sourceObject)
        IVAProfile.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAProfileSearchPlugin._private_init(self, pUnk)
        IVAProfile._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAProfileSearchPlugin._get_property(self, attrname) is not None: found_prop = IVAProfileSearchPlugin._get_property(self, attrname)
        if IVAProfile._get_property(self, attrname) is not None: found_prop = IVAProfile._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAProfileSearchPlugin.")
        
agcls.AgClassCatalog.add_catalog_entry("{25E94763-B5B1-4964-B563-9AEED96D9D54}", VAProfileSearchPlugin)


class VATargeterGraph(IVATargeterGraph, IRuntimeTypeInfoProvider):
    """Targeter Graph."""
    def __init__(self, sourceObject=None):
        IVATargeterGraph.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVATargeterGraph._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVATargeterGraph._get_property(self, attrname) is not None: found_prop = IVATargeterGraph._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VATargeterGraph.")
        
agcls.AgClassCatalog.add_catalog_entry("{BF6E6956-1E2A-42E5-A56C-1BEF9EFB8A29}", VATargeterGraph)


class VATargeterGraphCollection(IVATargeterGraphCollection, IRuntimeTypeInfoProvider):
    """Targeter Graphs."""
    def __init__(self, sourceObject=None):
        IVATargeterGraphCollection.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVATargeterGraphCollection._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVATargeterGraphCollection._get_property(self, attrname) is not None: found_prop = IVATargeterGraphCollection._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VATargeterGraphCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{322FC0D0-8F69-4F4B-9247-2558D6AFF63F}", VATargeterGraphCollection)


class VATargeterGraphResultCollection(IVATargeterGraphResultCollection, IRuntimeTypeInfoProvider):
    """Targeter Graph Result Collection."""
    def __init__(self, sourceObject=None):
        IVATargeterGraphResultCollection.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVATargeterGraphResultCollection._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVATargeterGraphResultCollection._get_property(self, attrname) is not None: found_prop = IVATargeterGraphResultCollection._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VATargeterGraphResultCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{87090DB9-4866-40E4-BA58-BDF7C8EACCEB}", VATargeterGraphResultCollection)


class VATargeterGraphActiveControlCollection(IVATargeterGraphActiveControlCollection, IRuntimeTypeInfoProvider):
    """Targeter Graph Active Control Collection."""
    def __init__(self, sourceObject=None):
        IVATargeterGraphActiveControlCollection.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVATargeterGraphActiveControlCollection._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVATargeterGraphActiveControlCollection._get_property(self, attrname) is not None: found_prop = IVATargeterGraphActiveControlCollection._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VATargeterGraphActiveControlCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{7FB70374-2313-463C-A69E-C5111C4BC1E4}", VATargeterGraphActiveControlCollection)


class VATargeterGraphActiveControl(IVATargeterGraphActiveControl, IRuntimeTypeInfoProvider):
    """Targeter Graph Active Control."""
    def __init__(self, sourceObject=None):
        IVATargeterGraphActiveControl.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVATargeterGraphActiveControl._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVATargeterGraphActiveControl._get_property(self, attrname) is not None: found_prop = IVATargeterGraphActiveControl._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VATargeterGraphActiveControl.")
        
agcls.AgClassCatalog.add_catalog_entry("{E6457FA2-28BF-471B-9DCF-575B27BF588B}", VATargeterGraphActiveControl)


class VATargeterGraphResult(IVATargeterGraphResult, IRuntimeTypeInfoProvider):
    """Targeter Graph Result."""
    def __init__(self, sourceObject=None):
        IVATargeterGraphResult.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVATargeterGraphResult._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVATargeterGraphResult._get_property(self, attrname) is not None: found_prop = IVATargeterGraphResult._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VATargeterGraphResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{AB6CA723-1634-4A90-AD8C-4DB34D7A2925}", VATargeterGraphResult)


class VAProfileDifferentialCorrector(IVAProfileDifferentialCorrector, IVAProfile, IRuntimeTypeInfoProvider):
    """The Differential Corrector profile."""
    def __init__(self, sourceObject=None):
        IVAProfileDifferentialCorrector.__init__(self, sourceObject)
        IVAProfile.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAProfileDifferentialCorrector._private_init(self, pUnk)
        IVAProfile._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAProfileDifferentialCorrector._get_property(self, attrname) is not None: found_prop = IVAProfileDifferentialCorrector._get_property(self, attrname)
        if IVAProfile._get_property(self, attrname) is not None: found_prop = IVAProfile._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAProfileDifferentialCorrector.")
        
agcls.AgClassCatalog.add_catalog_entry("{4446E46E-A169-4F12-AE14-562D35A6BC60}", VAProfileDifferentialCorrector)


class VAProfileScriptingTool(IVAProfileScriptingTool, IVAProfile, IRuntimeTypeInfoProvider):
    """The Scripting Tool profile."""
    def __init__(self, sourceObject=None):
        IVAProfileScriptingTool.__init__(self, sourceObject)
        IVAProfile.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAProfileScriptingTool._private_init(self, pUnk)
        IVAProfile._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAProfileScriptingTool._get_property(self, attrname) is not None: found_prop = IVAProfileScriptingTool._get_property(self, attrname)
        if IVAProfile._get_property(self, attrname) is not None: found_prop = IVAProfile._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAProfileScriptingTool.")
        
agcls.AgClassCatalog.add_catalog_entry("{EC9D1E6F-4155-4685-AFE9-785DE109564A}", VAProfileScriptingTool)


class VADCControl(IVADCControl, IRuntimeTypeInfoProvider):
    """Control Parameters for a Target Sequence."""
    def __init__(self, sourceObject=None):
        IVADCControl.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVADCControl._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVADCControl._get_property(self, attrname) is not None: found_prop = IVADCControl._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VADCControl.")
        
agcls.AgClassCatalog.add_catalog_entry("{5D59626C-A2D6-4D23-91C8-43D3764115C9}", VADCControl)


class VADCResult(IVADCResult, IRuntimeTypeInfoProvider):
    """Differential Corrector equality constraints."""
    def __init__(self, sourceObject=None):
        IVADCResult.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVADCResult._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVADCResult._get_property(self, attrname) is not None: found_prop = IVADCResult._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VADCResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{1F4606B6-6EB5-4349-90AD-E607DBBC6AB5}", VADCResult)


class VADCControlCollection(IVADCControlCollection, IRuntimeTypeInfoProvider):
    """The collection of Control Parameters for a differential corrector profile."""
    def __init__(self, sourceObject=None):
        IVADCControlCollection.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVADCControlCollection._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVADCControlCollection._get_property(self, attrname) is not None: found_prop = IVADCControlCollection._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VADCControlCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{61729FE0-729A-461C-8C94-6816EC0F88E8}", VADCControlCollection)


class VADCResultCollection(IVADCResultCollection, IRuntimeTypeInfoProvider):
    """The collection of results for a differential corrector."""
    def __init__(self, sourceObject=None):
        IVADCResultCollection.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVADCResultCollection._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVADCResultCollection._get_property(self, attrname) is not None: found_prop = IVADCResultCollection._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VADCResultCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{703FFB61-063E-4B38-AC0A-968903E6E929}", VADCResultCollection)


class VASearchPluginControl(IVASearchPluginControl):
    """Control parameters for a plugin search profile."""
    def __init__(self, sourceObject=None):
        IVASearchPluginControl.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVASearchPluginControl._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVASearchPluginControl._get_property(self, attrname) is not None: found_prop = IVASearchPluginControl._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VASearchPluginControl.")
        
agcls.AgClassCatalog.add_catalog_entry("{C127E67D-2078-4605-BB16-BF4049CBDEF0}", VASearchPluginControl)


class VASearchPluginControlCollection(IVASearchPluginControlCollection):
    """The list of search plugin control parameters"""
    def __init__(self, sourceObject=None):
        IVASearchPluginControlCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVASearchPluginControlCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVASearchPluginControlCollection._get_property(self, attrname) is not None: found_prop = IVASearchPluginControlCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VASearchPluginControlCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{78A7975A-C0F5-434A-9902-411C3E975F7E}", VASearchPluginControlCollection)


class VASearchPluginResult(IVASearchPluginResult):
    """Equality constraints for a plugin search profile."""
    def __init__(self, sourceObject=None):
        IVASearchPluginResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVASearchPluginResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVASearchPluginResult._get_property(self, attrname) is not None: found_prop = IVASearchPluginResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VASearchPluginResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{7A3345FE-C088-4CFA-84BE-5E997BB15CF8}", VASearchPluginResult)


class VASearchPluginResultCollection(IVASearchPluginResultCollection):
    """The list of search plugin equality constraints."""
    def __init__(self, sourceObject=None):
        IVASearchPluginResultCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVASearchPluginResultCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVASearchPluginResultCollection._get_property(self, attrname) is not None: found_prop = IVASearchPluginResultCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VASearchPluginResultCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{8D37CDE6-2358-4419-9297-0032314ACB35}", VASearchPluginResultCollection)


class VAProfileChangeManeuverType(IVAProfileChangeManeuverType, IVAProfile, IRuntimeTypeInfoProvider):
    """The Change Maneuver Type profile."""
    def __init__(self, sourceObject=None):
        IVAProfileChangeManeuverType.__init__(self, sourceObject)
        IVAProfile.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAProfileChangeManeuverType._private_init(self, pUnk)
        IVAProfile._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAProfileChangeManeuverType._get_property(self, attrname) is not None: found_prop = IVAProfileChangeManeuverType._get_property(self, attrname)
        if IVAProfile._get_property(self, attrname) is not None: found_prop = IVAProfile._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAProfileChangeManeuverType.")
        
agcls.AgClassCatalog.add_catalog_entry("{8FCD3010-988A-4C88-A3E8-FB0D991B1DA3}", VAProfileChangeManeuverType)


class VAProfileChangeReturnSegment(IVAProfileChangeReturnSegment, IVAProfile, IRuntimeTypeInfoProvider):
    """The Change Return Segment profile."""
    def __init__(self, sourceObject=None):
        IVAProfileChangeReturnSegment.__init__(self, sourceObject)
        IVAProfile.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAProfileChangeReturnSegment._private_init(self, pUnk)
        IVAProfile._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAProfileChangeReturnSegment._get_property(self, attrname) is not None: found_prop = IVAProfileChangeReturnSegment._get_property(self, attrname)
        if IVAProfile._get_property(self, attrname) is not None: found_prop = IVAProfile._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAProfileChangeReturnSegment.")
        
agcls.AgClassCatalog.add_catalog_entry("{D7436885-84AD-41DE-9D0F-7A6F001A863B}", VAProfileChangeReturnSegment)


class VAProfileChangePropagator(IVAProfileChangePropagator, IVAProfile, IRuntimeTypeInfoProvider):
    """The Change Propagator profile."""
    def __init__(self, sourceObject=None):
        IVAProfileChangePropagator.__init__(self, sourceObject)
        IVAProfile.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAProfileChangePropagator._private_init(self, pUnk)
        IVAProfile._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAProfileChangePropagator._get_property(self, attrname) is not None: found_prop = IVAProfileChangePropagator._get_property(self, attrname)
        if IVAProfile._get_property(self, attrname) is not None: found_prop = IVAProfile._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAProfileChangePropagator.")
        
agcls.AgClassCatalog.add_catalog_entry("{3EB69307-370B-443E-AB4F-1463A80142CD}", VAProfileChangePropagator)


class VAProfileChangeStopSegment(IVAProfileChangeStopSegment, IVAProfile, IRuntimeTypeInfoProvider):
    """The Change Stop Segment profile."""
    def __init__(self, sourceObject=None):
        IVAProfileChangeStopSegment.__init__(self, sourceObject)
        IVAProfile.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAProfileChangeStopSegment._private_init(self, pUnk)
        IVAProfile._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAProfileChangeStopSegment._get_property(self, attrname) is not None: found_prop = IVAProfileChangeStopSegment._get_property(self, attrname)
        if IVAProfile._get_property(self, attrname) is not None: found_prop = IVAProfile._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAProfileChangeStopSegment.")
        
agcls.AgClassCatalog.add_catalog_entry("{73CD0F57-2A67-47D7-BFAD-4E07D5045AB1}", VAProfileChangeStopSegment)


class VAProfileChangeStoppingConditionState(IVAProfileChangeStoppingConditionState, IVAProfile, IRuntimeTypeInfoProvider):
    """The Change Stopping Condition State profile."""
    def __init__(self, sourceObject=None):
        IVAProfileChangeStoppingConditionState.__init__(self, sourceObject)
        IVAProfile.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAProfileChangeStoppingConditionState._private_init(self, pUnk)
        IVAProfile._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAProfileChangeStoppingConditionState._get_property(self, attrname) is not None: found_prop = IVAProfileChangeStoppingConditionState._get_property(self, attrname)
        if IVAProfile._get_property(self, attrname) is not None: found_prop = IVAProfile._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAProfileChangeStoppingConditionState.")
        
agcls.AgClassCatalog.add_catalog_entry("{593BF97D-DA25-40EC-832A-2514939CCCCB}", VAProfileChangeStoppingConditionState)


class VAProfileSeedFiniteManeuver(IVAProfileSeedFiniteManeuver, IVAProfile, IRuntimeTypeInfoProvider):
    """The Seed Finite Maneuver profile."""
    def __init__(self, sourceObject=None):
        IVAProfileSeedFiniteManeuver.__init__(self, sourceObject)
        IVAProfile.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAProfileSeedFiniteManeuver._private_init(self, pUnk)
        IVAProfile._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAProfileSeedFiniteManeuver._get_property(self, attrname) is not None: found_prop = IVAProfileSeedFiniteManeuver._get_property(self, attrname)
        if IVAProfile._get_property(self, attrname) is not None: found_prop = IVAProfile._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAProfileSeedFiniteManeuver.")
        
agcls.AgClassCatalog.add_catalog_entry("{4524367A-A29D-401A-8B98-82FB06E4D2B3}", VAProfileSeedFiniteManeuver)


class VAProfileRunOnce(IVAProfileRunOnce, IVAProfile, IRuntimeTypeInfoProvider):
    """The Run Once profile."""
    def __init__(self, sourceObject=None):
        IVAProfileRunOnce.__init__(self, sourceObject)
        IVAProfile.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAProfileRunOnce._private_init(self, pUnk)
        IVAProfile._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAProfileRunOnce._get_property(self, attrname) is not None: found_prop = IVAProfileRunOnce._get_property(self, attrname)
        if IVAProfile._get_property(self, attrname) is not None: found_prop = IVAProfile._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAProfileRunOnce.")
        
agcls.AgClassCatalog.add_catalog_entry("{6B7DC440-DAE4-4F68-BD3A-D431EF7460B4}", VAProfileRunOnce)


class VABPlaneCollection(IVABPlaneCollection):
    """The collection of B-Planes."""
    def __init__(self, sourceObject=None):
        IVABPlaneCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVABPlaneCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVABPlaneCollection._get_property(self, attrname) is not None: found_prop = IVABPlaneCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VABPlaneCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{4A33E12D-FC24-46EB-8AD4-752E5534168D}", VABPlaneCollection)


class VAStateCalcDamageFlux(IVAStateCalcDamageFlux, IComponentInfo, ICloneable):
    """CoClass StateCalcDamageFlux."""
    def __init__(self, sourceObject=None):
        IVAStateCalcDamageFlux.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAStateCalcDamageFlux._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAStateCalcDamageFlux._get_property(self, attrname) is not None: found_prop = IVAStateCalcDamageFlux._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcDamageFlux.")
        
agcls.AgClassCatalog.add_catalog_entry("{EFD8FBFA-6ACF-463D-9857-7C272440314F}", VAStateCalcDamageFlux)


class VAStateCalcDamageMassFlux(IVAStateCalcDamageMassFlux, IComponentInfo, ICloneable):
    """CoClass StateCalcDamageMassFlux."""
    def __init__(self, sourceObject=None):
        IVAStateCalcDamageMassFlux.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAStateCalcDamageMassFlux._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAStateCalcDamageMassFlux._get_property(self, attrname) is not None: found_prop = IVAStateCalcDamageMassFlux._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcDamageMassFlux.")
        
agcls.AgClassCatalog.add_catalog_entry("{05A46EDD-2B3D-4505-BD42-DB7516899060}", VAStateCalcDamageMassFlux)


class VAStateCalcMagFieldDipoleL(IVAStateCalcMagFieldDipoleL, IComponentInfo, ICloneable):
    """CoClass StateCalcMagFieldDipoleL."""
    def __init__(self, sourceObject=None):
        IVAStateCalcMagFieldDipoleL.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAStateCalcMagFieldDipoleL._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAStateCalcMagFieldDipoleL._get_property(self, attrname) is not None: found_prop = IVAStateCalcMagFieldDipoleL._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcMagFieldDipoleL.")
        
agcls.AgClassCatalog.add_catalog_entry("{C1FD9D99-42EF-40F2-9E53-AEBAEC1A5573}", VAStateCalcMagFieldDipoleL)


class VAStateCalcSEETMagFieldFieldLineSepAngle(IComponentInfo, ICloneable, IVAStateCalcSEETMagFieldFieldLineSepAngle):
    """SEETMagFieldFieldLineSepAngle Calc object."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcSEETMagFieldFieldLineSepAngle.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcSEETMagFieldFieldLineSepAngle._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcSEETMagFieldFieldLineSepAngle._get_property(self, attrname) is not None: found_prop = IVAStateCalcSEETMagFieldFieldLineSepAngle._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcSEETMagFieldFieldLineSepAngle.")
        
agcls.AgClassCatalog.add_catalog_entry("{585BF1E2-E8E0-4D8B-9101-7BDC793D6E68}", VAStateCalcSEETMagFieldFieldLineSepAngle)


class VAStateCalcImpactFlux(IVAStateCalcImpactFlux, IComponentInfo, ICloneable):
    """CoClass StateCalcImpactFlux."""
    def __init__(self, sourceObject=None):
        IVAStateCalcImpactFlux.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAStateCalcImpactFlux._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAStateCalcImpactFlux._get_property(self, attrname) is not None: found_prop = IVAStateCalcImpactFlux._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcImpactFlux.")
        
agcls.AgClassCatalog.add_catalog_entry("{2F537C47-80E4-483C-9C6F-A82F91EC5F24}", VAStateCalcImpactFlux)


class VAStateCalcImpactMassFlux(IVAStateCalcImpactMassFlux, IComponentInfo, ICloneable):
    """CoClass StateCalcImpactMassFlux."""
    def __init__(self, sourceObject=None):
        IVAStateCalcImpactMassFlux.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAStateCalcImpactMassFlux._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAStateCalcImpactMassFlux._get_property(self, attrname) is not None: found_prop = IVAStateCalcImpactMassFlux._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcImpactMassFlux.")
        
agcls.AgClassCatalog.add_catalog_entry("{9D64EF8C-63C9-4924-BE13-8176E3DAB180}", VAStateCalcImpactMassFlux)


class VAStateCalcSEETSAAFlux(IVAStateCalcSEETSAAFlux, IComponentInfo, ICloneable):
    """CoClass StateCalcSEETSAAFlux."""
    def __init__(self, sourceObject=None):
        IVAStateCalcSEETSAAFlux.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAStateCalcSEETSAAFlux._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAStateCalcSEETSAAFlux._get_property(self, attrname) is not None: found_prop = IVAStateCalcSEETSAAFlux._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcSEETSAAFlux.")
        
agcls.AgClassCatalog.add_catalog_entry("{3C766F5E-9727-4ACD-9E5D-D08684116A79}", VAStateCalcSEETSAAFlux)


class VAStateCalcSEETVehTemp(IVAStateCalcSEETVehTemp, IComponentInfo, ICloneable):
    """CoClass StateCalcSEETVehTemp."""
    def __init__(self, sourceObject=None):
        IVAStateCalcSEETVehTemp.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAStateCalcSEETVehTemp._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAStateCalcSEETVehTemp._get_property(self, attrname) is not None: found_prop = IVAStateCalcSEETVehTemp._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcSEETVehTemp.")
        
agcls.AgClassCatalog.add_catalog_entry("{082CAA56-3DB0-4BA5-BE14-B84D93A32504}", VAStateCalcSEETVehTemp)


class VAStateCalcEpoch(IComponentInfo, ICloneable, IVAStateCalcEpoch):
    """Epoch Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcEpoch.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcEpoch._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcEpoch._get_property(self, attrname) is not None: found_prop = IVAStateCalcEpoch._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcEpoch.")
        
agcls.AgClassCatalog.add_catalog_entry("{CC140708-1576-4CFA-9A28-BC454B33DE02}", VAStateCalcEpoch)


class VAStateCalcJacobiConstant(IComponentInfo, ICloneable, IVAStateCalcJacobiConstant):
    """Jacobi Constant Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcJacobiConstant.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcJacobiConstant._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcJacobiConstant._get_property(self, attrname) is not None: found_prop = IVAStateCalcJacobiConstant._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcJacobiConstant.")
        
agcls.AgClassCatalog.add_catalog_entry("{FFF1FA69-1E24-445E-A239-41E2AB0D373B}", VAStateCalcJacobiConstant)


class VAStateCalcCartesianElem(IComponentInfo, ICloneable, IVAStateCalcCartesianElem):
    """Cartesian Elements Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcCartesianElem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcCartesianElem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcCartesianElem._get_property(self, attrname) is not None: found_prop = IVAStateCalcCartesianElem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcCartesianElem.")
        
agcls.AgClassCatalog.add_catalog_entry("{AECA6CA7-7D04-4EB5-95D9-216BBCCD0EC1}", VAStateCalcCartesianElem)


class VAStateCalcCartSTMElem(IComponentInfo, ICloneable, IVAStateCalcCartSTMElem):
    """Cartesian STM Elements Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcCartSTMElem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcCartSTMElem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcCartSTMElem._get_property(self, attrname) is not None: found_prop = IVAStateCalcCartSTMElem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcCartSTMElem.")
        
agcls.AgClassCatalog.add_catalog_entry("{84EAF6DB-A535-421E-8CCF-95A142E3B2FE}", VAStateCalcCartSTMElem)


class VAStateCalcSTMEigenval(IComponentInfo, ICloneable, IVAStateCalcSTMEigenval):
    """Cartesian STM Eigenvalues Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcSTMEigenval.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcSTMEigenval._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcSTMEigenval._get_property(self, attrname) is not None: found_prop = IVAStateCalcSTMEigenval._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcSTMEigenval.")
        
agcls.AgClassCatalog.add_catalog_entry("{F3AC2C6F-7A0A-40CA-A7EC-230D9EC2D75E}", VAStateCalcSTMEigenval)


class VAStateCalcSTMEigenvecElem(IComponentInfo, ICloneable, IVAStateCalcSTMEigenvecElem):
    """Cartesian STM Eigenvector Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcSTMEigenvecElem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcSTMEigenvecElem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcSTMEigenvecElem._get_property(self, attrname) is not None: found_prop = IVAStateCalcSTMEigenvecElem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcSTMEigenvecElem.")
        
agcls.AgClassCatalog.add_catalog_entry("{53BF2ADA-8B4D-4E64-BC61-AFA201DAB3C7}", VAStateCalcSTMEigenvecElem)


class VAStateCalcEnvironment(IComponentInfo, ICloneable, IVAStateCalcEnvironment):
    """Environment Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcEnvironment.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcEnvironment._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcEnvironment._get_property(self, attrname) is not None: found_prop = IVAStateCalcEnvironment._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcEnvironment.")
        
agcls.AgClassCatalog.add_catalog_entry("{A8319DEC-F018-4890-AC98-9F7B2AF96DF6}", VAStateCalcEnvironment)


class VAStateCalcOrbitDelaunayG(IVAStateCalcOrbitDelaunayG, IComponentInfo, ICloneable):
    """CoClass AsStateCalcOrbitDelaunayG."""
    def __init__(self, sourceObject=None):
        IVAStateCalcOrbitDelaunayG.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAStateCalcOrbitDelaunayG._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAStateCalcOrbitDelaunayG._get_property(self, attrname) is not None: found_prop = IVAStateCalcOrbitDelaunayG._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcOrbitDelaunayG.")
        
agcls.AgClassCatalog.add_catalog_entry("{5DE99D8D-DB40-4107-9D79-03D51AEAA4E8}", VAStateCalcOrbitDelaunayG)


class VAStateCalcOrbitDelaunayH(IVAStateCalcOrbitDelaunayH, IComponentInfo, ICloneable):
    """CoClass AsStateCalcOrbitDelaunayH."""
    def __init__(self, sourceObject=None):
        IVAStateCalcOrbitDelaunayH.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAStateCalcOrbitDelaunayH._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAStateCalcOrbitDelaunayH._get_property(self, attrname) is not None: found_prop = IVAStateCalcOrbitDelaunayH._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcOrbitDelaunayH.")
        
agcls.AgClassCatalog.add_catalog_entry("{4C7CDC1F-79EA-412B-A1E3-7E519CCAA4F0}", VAStateCalcOrbitDelaunayH)


class VAStateCalcOrbitDelaunayL(IVAStateCalcOrbitDelaunayL, IComponentInfo, ICloneable):
    """CoClass AsStateCalcOrbitDelaunayL."""
    def __init__(self, sourceObject=None):
        IVAStateCalcOrbitDelaunayL.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAStateCalcOrbitDelaunayL._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAStateCalcOrbitDelaunayL._get_property(self, attrname) is not None: found_prop = IVAStateCalcOrbitDelaunayL._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcOrbitDelaunayL.")
        
agcls.AgClassCatalog.add_catalog_entry("{299A4FF6-0636-4A25-AC74-4FF7D0A33F30}", VAStateCalcOrbitDelaunayL)


class VAStateCalcOrbitSemiLatusRectum(IVAStateCalcOrbitSemiLatusRectum, IComponentInfo, ICloneable):
    """CoClass AsStateCalcOrbitSemiLatusRectum."""
    def __init__(self, sourceObject=None):
        IVAStateCalcOrbitSemiLatusRectum.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAStateCalcOrbitSemiLatusRectum._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAStateCalcOrbitSemiLatusRectum._get_property(self, attrname) is not None: found_prop = IVAStateCalcOrbitSemiLatusRectum._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcOrbitSemiLatusRectum.")
        
agcls.AgClassCatalog.add_catalog_entry("{9A0EF481-BE9B-47B7-81D5-CAFF636B8E31}", VAStateCalcOrbitSemiLatusRectum)


class VAStateCalcEquinoctialElem(IComponentInfo, ICloneable, IVAStateCalcEquinoctialElem):
    """Equinoctial Elements Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcEquinoctialElem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcEquinoctialElem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcEquinoctialElem._get_property(self, attrname) is not None: found_prop = IVAStateCalcEquinoctialElem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcEquinoctialElem.")
        
agcls.AgClassCatalog.add_catalog_entry("{5C90B745-3002-4AEC-9613-0FE8168F2903}", VAStateCalcEquinoctialElem)


class VAStateCalcCloseApproachBearing(IComponentInfo, ICloneable, IVAStateCalcCloseApproachBearing):
    """CloseApproachBearing Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcCloseApproachBearing.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcCloseApproachBearing._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcCloseApproachBearing._get_property(self, attrname) is not None: found_prop = IVAStateCalcCloseApproachBearing._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcCloseApproachBearing.")
        
agcls.AgClassCatalog.add_catalog_entry("{E0AD9FFF-8F9D-4EBD-A41D-2982A60968AB}", VAStateCalcCloseApproachBearing)


class VAStateCalcCloseApproachMag(IComponentInfo, ICloneable, IVAStateCalcCloseApproachMag):
    """CloseApproachMag Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcCloseApproachMag.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcCloseApproachMag._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcCloseApproachMag._get_property(self, attrname) is not None: found_prop = IVAStateCalcCloseApproachMag._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcCloseApproachMag.")
        
agcls.AgClassCatalog.add_catalog_entry("{70461F34-33C2-42B4-9591-5A2F2C5EB8D2}", VAStateCalcCloseApproachMag)


class VAStateCalcCloseApproachTheta(IComponentInfo, ICloneable, IVAStateCalcCloseApproachTheta):
    """CloseApproachTheta Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcCloseApproachTheta.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcCloseApproachTheta._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcCloseApproachTheta._get_property(self, attrname) is not None: found_prop = IVAStateCalcCloseApproachTheta._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcCloseApproachTheta.")
        
agcls.AgClassCatalog.add_catalog_entry("{950DA5FA-29AA-4422-B760-AD23CB6A33FB}", VAStateCalcCloseApproachTheta)


class VAStateCalcCloseApproachX(IComponentInfo, ICloneable, IVAStateCalcCloseApproachX):
    """CloseApproachX Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcCloseApproachX.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcCloseApproachX._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcCloseApproachX._get_property(self, attrname) is not None: found_prop = IVAStateCalcCloseApproachX._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcCloseApproachX.")
        
agcls.AgClassCatalog.add_catalog_entry("{FD980AD5-6212-4A4A-AC05-4453F9015301}", VAStateCalcCloseApproachX)


class VAStateCalcCloseApproachY(IComponentInfo, ICloneable, IVAStateCalcCloseApproachY):
    """CloseApproachY Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcCloseApproachY.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcCloseApproachY._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcCloseApproachY._get_property(self, attrname) is not None: found_prop = IVAStateCalcCloseApproachY._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcCloseApproachY.")
        
agcls.AgClassCatalog.add_catalog_entry("{D04565A4-C1F2-4A3D-A304-FB3CB2887087}", VAStateCalcCloseApproachY)


class VAStateCalcCloseApproachCosBearing(IComponentInfo, ICloneable, IVAStateCalcCloseApproachCosBearing):
    """CloseApproachCosBearing Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcCloseApproachCosBearing.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcCloseApproachCosBearing._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcCloseApproachCosBearing._get_property(self, attrname) is not None: found_prop = IVAStateCalcCloseApproachCosBearing._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcCloseApproachCosBearing.")
        
agcls.AgClassCatalog.add_catalog_entry("{EDAFFF24-75C9-4C68-9E4B-00DEFD89DAE1}", VAStateCalcCloseApproachCosBearing)


class VAStateCalcRelGroundTrackError(IComponentInfo, ICloneable, IVAStateCalcRelGroundTrackError):
    """RelGroundTrackError Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcRelGroundTrackError.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcRelGroundTrackError._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcRelGroundTrackError._get_property(self, attrname) is not None: found_prop = IVAStateCalcRelGroundTrackError._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcRelGroundTrackError.")
        
agcls.AgClassCatalog.add_catalog_entry("{42632E47-2FF5-4183-BB7F-9A3CDAB5E80D}", VAStateCalcRelGroundTrackError)


class VAStateCalcRelAtAOLMaster(IComponentInfo, ICloneable, IVAStateCalcRelAtAOLMaster):
    """RelAOLMaster Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcRelAtAOLMaster.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcRelAtAOLMaster._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcRelAtAOLMaster._get_property(self, attrname) is not None: found_prop = IVAStateCalcRelAtAOLMaster._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcRelAtAOLMaster.")
        
agcls.AgClassCatalog.add_catalog_entry("{4ADF0E11-ECD1-434B-AD01-57FD9F0A692A}", VAStateCalcRelAtAOLMaster)


class VAStateCalcDeltaFromMaster(IComponentInfo, ICloneable, IVAStateCalcDeltaFromMaster):
    """DeltaFromMaster Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcDeltaFromMaster.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcDeltaFromMaster._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcDeltaFromMaster._get_property(self, attrname) is not None: found_prop = IVAStateCalcDeltaFromMaster._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcDeltaFromMaster.")
        
agcls.AgClassCatalog.add_catalog_entry("{F88A3044-F12D-4147-8609-B71F3AD972F4}", VAStateCalcDeltaFromMaster)


class VAStateCalcLonDriftRate(IComponentInfo, ICloneable, IVAStateCalcLonDriftRate):
    """LongDriftRate Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcLonDriftRate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcLonDriftRate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcLonDriftRate._get_property(self, attrname) is not None: found_prop = IVAStateCalcLonDriftRate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcLonDriftRate.")
        
agcls.AgClassCatalog.add_catalog_entry("{87C78155-DC4F-42C1-B2A6-D48E10F79594}", VAStateCalcLonDriftRate)


class VAStateCalcMeanEarthLon(IComponentInfo, ICloneable, IVAStateCalcMeanEarthLon):
    """MeanEarthLon Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcMeanEarthLon.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcMeanEarthLon._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcMeanEarthLon._get_property(self, attrname) is not None: found_prop = IVAStateCalcMeanEarthLon._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcMeanEarthLon.")
        
agcls.AgClassCatalog.add_catalog_entry("{0D4E3AF8-45A3-4000-BB8A-B6D8323627AD}", VAStateCalcMeanEarthLon)


class VAStateCalcRectifiedLon(IComponentInfo, ICloneable, IVAStateCalcRectifiedLon):
    """RectifiedLongitude Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcRectifiedLon.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcRectifiedLon._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcRectifiedLon._get_property(self, attrname) is not None: found_prop = IVAStateCalcRectifiedLon._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcRectifiedLon.")
        
agcls.AgClassCatalog.add_catalog_entry("{ED61CCC5-71C7-4D2D-BB7D-BF177E6B9D7A}", VAStateCalcRectifiedLon)


class VAStateCalcHeightAboveTerrain(IVAStateCalcHeightAboveTerrain, IComponentInfo, ICloneable):
    """CoClass AsStateCalcHeightAboveTerrain."""
    def __init__(self, sourceObject=None):
        IVAStateCalcHeightAboveTerrain.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAStateCalcHeightAboveTerrain._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAStateCalcHeightAboveTerrain._get_property(self, attrname) is not None: found_prop = IVAStateCalcHeightAboveTerrain._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcHeightAboveTerrain.")
        
agcls.AgClassCatalog.add_catalog_entry("{3212361D-8A8B-4ED0-94C8-2D6F69BC3A12}", VAStateCalcHeightAboveTerrain)


class VAStateCalcGeodeticElem(IComponentInfo, ICloneable, IVAStateCalcGeodeticElem):
    """Geodetic Elements Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcGeodeticElem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcGeodeticElem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcGeodeticElem._get_property(self, attrname) is not None: found_prop = IVAStateCalcGeodeticElem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcGeodeticElem.")
        
agcls.AgClassCatalog.add_catalog_entry("{C22E7F23-171B-4A81-AF2B-6A3747D92FDA}", VAStateCalcGeodeticElem)


class VAStateCalcRepeatingGroundTrackErr(IComponentInfo, ICloneable, IVAStateCalcRepeatingGroundTrackErr):
    """RepeatingGrTrackErr Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcRepeatingGroundTrackErr.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcRepeatingGroundTrackErr._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcRepeatingGroundTrackErr._get_property(self, attrname) is not None: found_prop = IVAStateCalcRepeatingGroundTrackErr._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcRepeatingGroundTrackErr.")
        
agcls.AgClassCatalog.add_catalog_entry("{2D4ADF81-8403-42A7-9CD8-969B9C5FEF33}", VAStateCalcRepeatingGroundTrackErr)


class VAStateCalcAltOfApoapsis(IComponentInfo, ICloneable, IVAStateCalcAltOfApoapsis):
    """AltitudeOfApoapsis Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcAltOfApoapsis.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcAltOfApoapsis._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcAltOfApoapsis._get_property(self, attrname) is not None: found_prop = IVAStateCalcAltOfApoapsis._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcAltOfApoapsis.")
        
agcls.AgClassCatalog.add_catalog_entry("{A9398A62-DC62-40F2-8C71-C4D10D180C28}", VAStateCalcAltOfApoapsis)


class VAStateCalcAltOfPeriapsis(IComponentInfo, ICloneable, IVAStateCalcAltOfPeriapsis):
    """AltitudeOfPeriapsis Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcAltOfPeriapsis.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcAltOfPeriapsis._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcAltOfPeriapsis._get_property(self, attrname) is not None: found_prop = IVAStateCalcAltOfPeriapsis._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcAltOfPeriapsis.")
        
agcls.AgClassCatalog.add_catalog_entry("{700481E3-804B-4F43-B0AB-D58472F26302}", VAStateCalcAltOfPeriapsis)


class VAStateCalcArgOfLat(IComponentInfo, ICloneable, IVAStateCalcArgOfLat):
    """Argument of Latitude Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcArgOfLat.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcArgOfLat._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcArgOfLat._get_property(self, attrname) is not None: found_prop = IVAStateCalcArgOfLat._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcArgOfLat.")
        
agcls.AgClassCatalog.add_catalog_entry("{E3D0D3CF-1181-4F67-98D9-2CA6A5530372}", VAStateCalcArgOfLat)


class VAStateCalcArgOfPeriapsis(IComponentInfo, ICloneable, IVAStateCalcArgOfPeriapsis):
    """Argument of Periapsis Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcArgOfPeriapsis.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcArgOfPeriapsis._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcArgOfPeriapsis._get_property(self, attrname) is not None: found_prop = IVAStateCalcArgOfPeriapsis._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcArgOfPeriapsis.")
        
agcls.AgClassCatalog.add_catalog_entry("{64C0F0D2-889C-4EE2-BD26-B32BC6880733}", VAStateCalcArgOfPeriapsis)


class VAStateCalcEccAnomaly(IComponentInfo, ICloneable, IVAStateCalcEccAnomaly):
    """EccAnomaly Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcEccAnomaly.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcEccAnomaly._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcEccAnomaly._get_property(self, attrname) is not None: found_prop = IVAStateCalcEccAnomaly._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcEccAnomaly.")
        
agcls.AgClassCatalog.add_catalog_entry("{56C8EC47-95B0-4BF3-8D07-1F51630C285B}", VAStateCalcEccAnomaly)


class VAStateCalcLonOfAscNode(IComponentInfo, ICloneable, IVAStateCalcLonOfAscNode):
    """LongitudeOfAscendingNode Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcLonOfAscNode.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcLonOfAscNode._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcLonOfAscNode._get_property(self, attrname) is not None: found_prop = IVAStateCalcLonOfAscNode._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcLonOfAscNode.")
        
agcls.AgClassCatalog.add_catalog_entry("{2B606060-6816-4394-B4C5-C527490F9329}", VAStateCalcLonOfAscNode)


class VAStateCalcMeanMotion(IComponentInfo, ICloneable, IVAStateCalcMeanMotion):
    """MeanMotion Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcMeanMotion.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcMeanMotion._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcMeanMotion._get_property(self, attrname) is not None: found_prop = IVAStateCalcMeanMotion._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcMeanMotion.")
        
agcls.AgClassCatalog.add_catalog_entry("{B18119FD-D9C9-41E2-A7EB-46ACDA5CA8D5}", VAStateCalcMeanMotion)


class VAStateCalcOrbitPeriod(IComponentInfo, ICloneable, IVAStateCalcOrbitPeriod):
    """OrbitPeriod Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcOrbitPeriod.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcOrbitPeriod._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcOrbitPeriod._get_property(self, attrname) is not None: found_prop = IVAStateCalcOrbitPeriod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcOrbitPeriod.")
        
agcls.AgClassCatalog.add_catalog_entry("{D7563267-B5E5-43C5-8062-E07CCA0F2B84}", VAStateCalcOrbitPeriod)


class VAStateCalcNumRevs(IComponentInfo, ICloneable, IVAStateCalcNumRevs):
    """NumRevs Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcNumRevs.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcNumRevs._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcNumRevs._get_property(self, attrname) is not None: found_prop = IVAStateCalcNumRevs._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcNumRevs.")
        
agcls.AgClassCatalog.add_catalog_entry("{D0585F2A-3F22-472C-B134-5A6DE1873010}", VAStateCalcNumRevs)


class VAStateCalcRadOfApoapsis(IComponentInfo, ICloneable, IVAStateCalcRadOfApoapsis):
    """RadiusOfApoapsis Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcRadOfApoapsis.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcRadOfApoapsis._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcRadOfApoapsis._get_property(self, attrname) is not None: found_prop = IVAStateCalcRadOfApoapsis._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcRadOfApoapsis.")
        
agcls.AgClassCatalog.add_catalog_entry("{C0BE1DA2-4518-4DDC-9E9F-C270EECC9CD9}", VAStateCalcRadOfApoapsis)


class VAStateCalcRadOfPeriapsis(IComponentInfo, ICloneable, IVAStateCalcRadOfPeriapsis):
    """RadiusOfPeriapsis Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcRadOfPeriapsis.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcRadOfPeriapsis._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcRadOfPeriapsis._get_property(self, attrname) is not None: found_prop = IVAStateCalcRadOfPeriapsis._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcRadOfPeriapsis.")
        
agcls.AgClassCatalog.add_catalog_entry("{3992203A-6D30-4430-AB47-184058ADB753}", VAStateCalcRadOfPeriapsis)


class VAStateCalcSemiMajorAxis(IComponentInfo, ICloneable, IVAStateCalcSemiMajorAxis):
    """SemiMajorAxis Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcSemiMajorAxis.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcSemiMajorAxis._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcSemiMajorAxis._get_property(self, attrname) is not None: found_prop = IVAStateCalcSemiMajorAxis._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcSemiMajorAxis.")
        
agcls.AgClassCatalog.add_catalog_entry("{2E89613E-B6BE-4708-9642-8C1A7734E695}", VAStateCalcSemiMajorAxis)


class VAStateCalcTimePastAscNode(IComponentInfo, ICloneable, IVAStateCalcTimePastAscNode):
    """TimePastAscNode Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcTimePastAscNode.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcTimePastAscNode._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcTimePastAscNode._get_property(self, attrname) is not None: found_prop = IVAStateCalcTimePastAscNode._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcTimePastAscNode.")
        
agcls.AgClassCatalog.add_catalog_entry("{0D19A235-5062-4D39-9D24-5BE1951E8982}", VAStateCalcTimePastAscNode)


class VAStateCalcTimePastPeriapsis(IComponentInfo, ICloneable, IVAStateCalcTimePastPeriapsis):
    """TimePastPeriapsis Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcTimePastPeriapsis.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcTimePastPeriapsis._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcTimePastPeriapsis._get_property(self, attrname) is not None: found_prop = IVAStateCalcTimePastPeriapsis._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcTimePastPeriapsis.")
        
agcls.AgClassCatalog.add_catalog_entry("{98C81CE6-0D11-4B0B-A6E6-3BD36BBCB98E}", VAStateCalcTimePastPeriapsis)


class VAStateCalcTrueAnomaly(IComponentInfo, ICloneable, IVAStateCalcTrueAnomaly):
    """TrueAnomaly Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcTrueAnomaly.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcTrueAnomaly._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcTrueAnomaly._get_property(self, attrname) is not None: found_prop = IVAStateCalcTrueAnomaly._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcTrueAnomaly.")
        
agcls.AgClassCatalog.add_catalog_entry("{4F084E44-4214-46EF-B67C-0A0B160F6475}", VAStateCalcTrueAnomaly)


class VAStateCalcDeltaV(IComponentInfo, ICloneable, IVAStateCalcDeltaV):
    """DeltaV Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcDeltaV.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcDeltaV._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcDeltaV._get_property(self, attrname) is not None: found_prop = IVAStateCalcDeltaV._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcDeltaV.")
        
agcls.AgClassCatalog.add_catalog_entry("{1609A9CD-8AA8-4F97-A00F-35F014FCCE44}", VAStateCalcDeltaV)


class VAStateCalcDeltaVSquared(IComponentInfo, ICloneable, IVAStateCalcDeltaVSquared):
    """DeltaV Squared Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcDeltaVSquared.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcDeltaVSquared._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcDeltaVSquared._get_property(self, attrname) is not None: found_prop = IVAStateCalcDeltaVSquared._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcDeltaVSquared.")
        
agcls.AgClassCatalog.add_catalog_entry("{CF7792EC-113B-45A7-AD9E-ECC908EBE1FD}", VAStateCalcDeltaVSquared)


class VAStateCalcMCSDeltaV(IComponentInfo, ICloneable, IVAStateCalcMCSDeltaV):
    """MCS DeltaV Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcMCSDeltaV.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcMCSDeltaV._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcMCSDeltaV._get_property(self, attrname) is not None: found_prop = IVAStateCalcMCSDeltaV._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcMCSDeltaV.")
        
agcls.AgClassCatalog.add_catalog_entry("{8E6614E7-7F46-4A9C-B155-FD8ED6C08D94}", VAStateCalcMCSDeltaV)


class VAStateCalcMCSDeltaVSquared(IComponentInfo, ICloneable, IVAStateCalcMCSDeltaVSquared):
    """MCS DeltaV Squared Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcMCSDeltaVSquared.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcMCSDeltaVSquared._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcMCSDeltaVSquared._get_property(self, attrname) is not None: found_prop = IVAStateCalcMCSDeltaVSquared._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcMCSDeltaVSquared.")
        
agcls.AgClassCatalog.add_catalog_entry("{DA10B4C1-62C7-4E1C-8B86-A355667DF9AE}", VAStateCalcMCSDeltaVSquared)


class VAStateCalcSequenceDeltaV(IComponentInfo, ICloneable, IVAStateCalcSequenceDeltaV):
    """Sequence DeltaV Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcSequenceDeltaV.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcSequenceDeltaV._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcSequenceDeltaV._get_property(self, attrname) is not None: found_prop = IVAStateCalcSequenceDeltaV._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcSequenceDeltaV.")
        
agcls.AgClassCatalog.add_catalog_entry("{138B7BC6-2338-46BE-83E9-5099C4D45811}", VAStateCalcSequenceDeltaV)


class VAStateCalcSequenceDeltaVSquared(IComponentInfo, ICloneable, IVAStateCalcSequenceDeltaVSquared):
    """Sequence DeltaV Squared Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcSequenceDeltaVSquared.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcSequenceDeltaVSquared._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcSequenceDeltaVSquared._get_property(self, attrname) is not None: found_prop = IVAStateCalcSequenceDeltaVSquared._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcSequenceDeltaVSquared.")
        
agcls.AgClassCatalog.add_catalog_entry("{27E104DF-B5FF-4E24-B397-06D264C0EADA}", VAStateCalcSequenceDeltaVSquared)


class VAStateCalcFuelMass(IComponentInfo, ICloneable, IVAStateCalcFuelMass):
    """FuelMass Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcFuelMass.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcFuelMass._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcFuelMass._get_property(self, attrname) is not None: found_prop = IVAStateCalcFuelMass._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcFuelMass.")
        
agcls.AgClassCatalog.add_catalog_entry("{3C37AFCA-696D-4A00-9E7B-7DCE928F0E7E}", VAStateCalcFuelMass)


class VAStateCalcDensity(IComponentInfo, ICloneable, IVAStateCalcDensity):
    """Density  Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcDensity.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcDensity._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcDensity._get_property(self, attrname) is not None: found_prop = IVAStateCalcDensity._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcDensity.")
        
agcls.AgClassCatalog.add_catalog_entry("{61D869F6-7B1C-4B5D-A046-AE495AE0FA7E}", VAStateCalcDensity)


class VAStateCalcInertialDeltaVMag(IComponentInfo, ICloneable, IVAStateCalcInertialDeltaVMag):
    """InertialDeltaVMag Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcInertialDeltaVMag.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcInertialDeltaVMag._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcInertialDeltaVMag._get_property(self, attrname) is not None: found_prop = IVAStateCalcInertialDeltaVMag._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcInertialDeltaVMag.")
        
agcls.AgClassCatalog.add_catalog_entry("{E12A8E9C-C11A-43D1-AE06-C659B87574D3}", VAStateCalcInertialDeltaVMag)


class VAStateCalcInertialDeltaVx(IComponentInfo, ICloneable, IVAStateCalcInertialDeltaVx):
    """InertialDeltaVx Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcInertialDeltaVx.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcInertialDeltaVx._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcInertialDeltaVx._get_property(self, attrname) is not None: found_prop = IVAStateCalcInertialDeltaVx._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcInertialDeltaVx.")
        
agcls.AgClassCatalog.add_catalog_entry("{43875512-BFCF-42E9-ACC8-BA7AE9E498A9}", VAStateCalcInertialDeltaVx)


class VAStateCalcInertialDeltaVy(IComponentInfo, ICloneable, IVAStateCalcInertialDeltaVy):
    """InertialDeltaVy Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcInertialDeltaVy.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcInertialDeltaVy._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcInertialDeltaVy._get_property(self, attrname) is not None: found_prop = IVAStateCalcInertialDeltaVy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcInertialDeltaVy.")
        
agcls.AgClassCatalog.add_catalog_entry("{04689A0A-12D1-4362-B5C8-497CF2E4D72E}", VAStateCalcInertialDeltaVy)


class VAStateCalcInertialDeltaVz(IComponentInfo, ICloneable, IVAStateCalcInertialDeltaVz):
    """InertialDeltaVz Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcInertialDeltaVz.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcInertialDeltaVz._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcInertialDeltaVz._get_property(self, attrname) is not None: found_prop = IVAStateCalcInertialDeltaVz._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcInertialDeltaVz.")
        
agcls.AgClassCatalog.add_catalog_entry("{4A160495-31AE-42EE-8D2D-B945D10E86B8}", VAStateCalcInertialDeltaVz)


class VAStateCalcManeuverSpecificImpulse(IComponentInfo, ICloneable, IVAStateCalcManeuverSpecificImpulse):
    """ManeuverSpecificImpulse Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcManeuverSpecificImpulse.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcManeuverSpecificImpulse._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcManeuverSpecificImpulse._get_property(self, attrname) is not None: found_prop = IVAStateCalcManeuverSpecificImpulse._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcManeuverSpecificImpulse.")
        
agcls.AgClassCatalog.add_catalog_entry("{8FEFF2C1-6E15-4026-95B3-1985DB40C154}", VAStateCalcManeuverSpecificImpulse)


class VAStateCalcPressure(IComponentInfo, ICloneable, IVAStateCalcPressure):
    """Pressure Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcPressure.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcPressure._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcPressure._get_property(self, attrname) is not None: found_prop = IVAStateCalcPressure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcPressure.")
        
agcls.AgClassCatalog.add_catalog_entry("{B12DCC30-F655-428A-BDE1-6D46900A7152}", VAStateCalcPressure)


class VAStateCalcTemperature(IComponentInfo, ICloneable, IVAStateCalcTemperature):
    """Temperature Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcTemperature.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcTemperature._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcTemperature._get_property(self, attrname) is not None: found_prop = IVAStateCalcTemperature._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcTemperature.")
        
agcls.AgClassCatalog.add_catalog_entry("{130771EF-F7FE-4CD3-B547-DE13FDF54E94}", VAStateCalcTemperature)


class VAStateCalcVectorY(IComponentInfo, ICloneable, IVAStateCalcVectorY):
    """VectorY Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcVectorY.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcVectorY._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcVectorY._get_property(self, attrname) is not None: found_prop = IVAStateCalcVectorY._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcVectorY.")
        
agcls.AgClassCatalog.add_catalog_entry("{7DC4C32E-1F4B-4B3E-A11C-7ECACCC602F8}", VAStateCalcVectorY)


class VAStateCalcVectorZ(IComponentInfo, ICloneable, IVAStateCalcVectorZ):
    """VectorZ Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcVectorZ.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcVectorZ._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcVectorZ._get_property(self, attrname) is not None: found_prop = IVAStateCalcVectorZ._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcVectorZ.")
        
agcls.AgClassCatalog.add_catalog_entry("{32E8F7E7-ECDE-4864-B380-D5A293458898}", VAStateCalcVectorZ)


class VAStateCalcMass(IComponentInfo, ICloneable, IVAStateCalcMass):
    """Mass Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcMass.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcMass._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcMass._get_property(self, attrname) is not None: found_prop = IVAStateCalcMass._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcMass.")
        
agcls.AgClassCatalog.add_catalog_entry("{99DD4422-3EB6-455B-9FE8-459FD65D2431}", VAStateCalcMass)


class VAStateCalcManeuverTotalMassFlowRate(IComponentInfo, ICloneable, IVAStateCalcManeuverTotalMassFlowRate):
    """ManeuverTotalMassFlowRate Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcManeuverTotalMassFlowRate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcManeuverTotalMassFlowRate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcManeuverTotalMassFlowRate._get_property(self, attrname) is not None: found_prop = IVAStateCalcManeuverTotalMassFlowRate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcManeuverTotalMassFlowRate.")
        
agcls.AgClassCatalog.add_catalog_entry("{049DA4A7-E8EB-4C62-AF0F-FFF566CB662F}", VAStateCalcManeuverTotalMassFlowRate)


class VAStateCalcAbsoluteValue(IComponentInfo, ICloneable, IVAStateCalcAbsoluteValue):
    """AbsoluteValue Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcAbsoluteValue.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcAbsoluteValue._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcAbsoluteValue._get_property(self, attrname) is not None: found_prop = IVAStateCalcAbsoluteValue._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcAbsoluteValue.")
        
agcls.AgClassCatalog.add_catalog_entry("{9CA8D97F-2F2D-4E66-B141-D5F8E3524B56}", VAStateCalcAbsoluteValue)


class VAStateCalcDifference(IComponentInfo, ICloneable, IVAStateCalcDifference):
    """Difference Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcDifference.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcDifference._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcDifference._get_property(self, attrname) is not None: found_prop = IVAStateCalcDifference._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcDifference.")
        
agcls.AgClassCatalog.add_catalog_entry("{8D579CBD-FB96-4CA1-9276-0ECF1E8A2854}", VAStateCalcDifference)


class VAStateCalcDifferenceOtherSegment(IComponentInfo, ICloneable, IVAStateCalcDifferenceOtherSegment):
    """DifferenceOtherSegment Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcDifferenceOtherSegment.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcDifferenceOtherSegment._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcDifferenceOtherSegment._get_property(self, attrname) is not None: found_prop = IVAStateCalcDifferenceOtherSegment._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcDifferenceOtherSegment.")
        
agcls.AgClassCatalog.add_catalog_entry("{36A3C1BA-F2AB-4F4C-887C-CF81C4E2BE52}", VAStateCalcDifferenceOtherSegment)


class VAStateCalcPosDifferenceOtherSegment(IComponentInfo, ICloneable, IVAStateCalcPosDifferenceOtherSegment):
    """PosDifferenceOtherSegment Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcPosDifferenceOtherSegment.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcPosDifferenceOtherSegment._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcPosDifferenceOtherSegment._get_property(self, attrname) is not None: found_prop = IVAStateCalcPosDifferenceOtherSegment._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcPosDifferenceOtherSegment.")
        
agcls.AgClassCatalog.add_catalog_entry("{9C09C061-9C4A-4B14-A9DC-C802A44A8AF1}", VAStateCalcPosDifferenceOtherSegment)


class VAStateCalcVelDifferenceOtherSegment(IComponentInfo, ICloneable, IVAStateCalcVelDifferenceOtherSegment):
    """VelDifferenceOtherSegment Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcVelDifferenceOtherSegment.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcVelDifferenceOtherSegment._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcVelDifferenceOtherSegment._get_property(self, attrname) is not None: found_prop = IVAStateCalcVelDifferenceOtherSegment._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcVelDifferenceOtherSegment.")
        
agcls.AgClassCatalog.add_catalog_entry("{C884D996-39EF-413B-9CF7-A8C927291B66}", VAStateCalcVelDifferenceOtherSegment)


class VAStateCalcPosVelDifferenceOtherSegment(IComponentInfo, ICloneable, IVAStateCalcPosVelDifferenceOtherSegment):
    """PosVelDifferenceOtherSegment Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcPosVelDifferenceOtherSegment.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcPosVelDifferenceOtherSegment._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcPosVelDifferenceOtherSegment._get_property(self, attrname) is not None: found_prop = IVAStateCalcPosVelDifferenceOtherSegment._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcPosVelDifferenceOtherSegment.")
        
agcls.AgClassCatalog.add_catalog_entry("{C7AFF6F3-C2C7-4132-BEB5-9A714E763A11}", VAStateCalcPosVelDifferenceOtherSegment)


class VAStateCalcValueAtSegment(IComponentInfo, ICloneable, IVAStateCalcValueAtSegment):
    """ValueAtSegment Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcValueAtSegment.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcValueAtSegment._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcValueAtSegment._get_property(self, attrname) is not None: found_prop = IVAStateCalcValueAtSegment._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcValueAtSegment.")
        
agcls.AgClassCatalog.add_catalog_entry("{80E8AAA2-2782-4176-9656-61AC3485096B}", VAStateCalcValueAtSegment)


class VAStateCalcMaxValue(IComponentInfo, ICloneable, IVAStateCalcMaxValue):
    """MaximumValue Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcMaxValue.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcMaxValue._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcMaxValue._get_property(self, attrname) is not None: found_prop = IVAStateCalcMaxValue._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcMaxValue.")
        
agcls.AgClassCatalog.add_catalog_entry("{CC82EA8F-373C-4A0D-A753-96CFD4AE73CF}", VAStateCalcMaxValue)


class VAStateCalcMinValue(IComponentInfo, ICloneable, IVAStateCalcMinValue):
    """MinimumValue Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcMinValue.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcMinValue._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcMinValue._get_property(self, attrname) is not None: found_prop = IVAStateCalcMinValue._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcMinValue.")
        
agcls.AgClassCatalog.add_catalog_entry("{F9C57411-482D-49E9-BE13-CC93E34FB0D4}", VAStateCalcMinValue)


class VAStateCalcMeanValue(IComponentInfo, ICloneable, IVAStateCalcMeanValue):
    """MeanValue Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcMeanValue.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcMeanValue._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcMeanValue._get_property(self, attrname) is not None: found_prop = IVAStateCalcMeanValue._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcMeanValue.")
        
agcls.AgClassCatalog.add_catalog_entry("{9B5472A7-799A-43E6-BDE7-99CB2C8C6E0C}", VAStateCalcMeanValue)


class VAStateCalcMedianValue(IComponentInfo, ICloneable, IVAStateCalcMedianValue):
    """MedianValue Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcMedianValue.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcMedianValue._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcMedianValue._get_property(self, attrname) is not None: found_prop = IVAStateCalcMedianValue._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcMedianValue.")
        
agcls.AgClassCatalog.add_catalog_entry("{CE3A18D7-5A69-45A1-AA76-AD7C2CF5259A}", VAStateCalcMedianValue)


class VAStateCalcStandardDeviation(IComponentInfo, ICloneable, IVAStateCalcStandardDeviation):
    """StandardDeviation Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcStandardDeviation.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcStandardDeviation._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcStandardDeviation._get_property(self, attrname) is not None: found_prop = IVAStateCalcStandardDeviation._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcStandardDeviation.")
        
agcls.AgClassCatalog.add_catalog_entry("{B33D3070-060B-4F32-AF2A-1F9BDD57F365}", VAStateCalcStandardDeviation)


class VAStateCalcNegative(IComponentInfo, ICloneable, IVAStateCalcNegative):
    """Negative Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcNegative.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcNegative._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcNegative._get_property(self, attrname) is not None: found_prop = IVAStateCalcNegative._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcNegative.")
        
agcls.AgClassCatalog.add_catalog_entry("{3E13FEC3-D60F-4203-86F2-42BCBC8EAFDF}", VAStateCalcNegative)


class VAStateCalcEccentricity(IComponentInfo, ICloneable, IVAStateCalcEccentricity):
    """Eccentricity Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcEccentricity.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcEccentricity._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcEccentricity._get_property(self, attrname) is not None: found_prop = IVAStateCalcEccentricity._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcEccentricity.")
        
agcls.AgClassCatalog.add_catalog_entry("{A9D98D60-E73E-4C59-9328-DFC5A12EF52B}", VAStateCalcEccentricity)


class VAStateCalcMeanAnomaly(IComponentInfo, ICloneable, IVAStateCalcMeanAnomaly):
    """MeanAnomaly Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcMeanAnomaly.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcMeanAnomaly._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcMeanAnomaly._get_property(self, attrname) is not None: found_prop = IVAStateCalcMeanAnomaly._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcMeanAnomaly.")
        
agcls.AgClassCatalog.add_catalog_entry("{8787D9AA-FBE1-43E4-932F-CB7B98D23D5B}", VAStateCalcMeanAnomaly)


class VAStateCalcRAAN(IComponentInfo, ICloneable, IVAStateCalcRAAN):
    """RAAN Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcRAAN.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcRAAN._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcRAAN._get_property(self, attrname) is not None: found_prop = IVAStateCalcRAAN._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcRAAN.")
        
agcls.AgClassCatalog.add_catalog_entry("{05B5185A-C8F3-4B02-AE8B-B5D58744323C}", VAStateCalcRAAN)


class VABDotRCalc(IComponentInfo, ICloneable, IVABDotRCalc):
    """BDotR Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVABDotRCalc.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVABDotRCalc._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVABDotRCalc._get_property(self, attrname) is not None: found_prop = IVABDotRCalc._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VABDotRCalc.")
        
agcls.AgClassCatalog.add_catalog_entry("{18A16428-2959-4220-A4A2-571D1F5A67FC}", VABDotRCalc)


class VABDotTCalc(IComponentInfo, ICloneable, IVABDotTCalc):
    """BDotT Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVABDotTCalc.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVABDotTCalc._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVABDotTCalc._get_property(self, attrname) is not None: found_prop = IVABDotTCalc._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VABDotTCalc.")
        
agcls.AgClassCatalog.add_catalog_entry("{59ACA04A-9B85-43DF-82FF-B58CFD985158}", VABDotTCalc)


class VABMagCalc(IComponentInfo, ICloneable, IVABMagCalc):
    """BMag Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVABMagCalc.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVABMagCalc._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVABMagCalc._get_property(self, attrname) is not None: found_prop = IVABMagCalc._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VABMagCalc.")
        
agcls.AgClassCatalog.add_catalog_entry("{87EF9CCA-2D0E-4742-8354-79E977FFD067}", VABMagCalc)


class VABThetaCalc(IComponentInfo, ICloneable, IVABThetaCalc):
    """BTheta Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVABThetaCalc.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVABThetaCalc._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVABThetaCalc._get_property(self, attrname) is not None: found_prop = IVABThetaCalc._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VABThetaCalc.")
        
agcls.AgClassCatalog.add_catalog_entry("{C5C6EC0C-6F2D-4DAB-9DCD-2A8FD810C642}", VABThetaCalc)


class VAStateCalcDeltaDec(IComponentInfo, ICloneable, IVAStateCalcDeltaDec):
    """DeltaDec Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcDeltaDec.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcDeltaDec._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcDeltaDec._get_property(self, attrname) is not None: found_prop = IVAStateCalcDeltaDec._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcDeltaDec.")
        
agcls.AgClassCatalog.add_catalog_entry("{4EA9E58A-9900-41CF-BFA8-8BF7849C9187}", VAStateCalcDeltaDec)


class VAStateCalcDeltaRA(IComponentInfo, ICloneable, IVAStateCalcDeltaRA):
    """DeltaRA Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcDeltaRA.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcDeltaRA._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcDeltaRA._get_property(self, attrname) is not None: found_prop = IVAStateCalcDeltaRA._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcDeltaRA.")
        
agcls.AgClassCatalog.add_catalog_entry("{3B1EAA2E-8FA2-4EF2-B7AB-377157AD0505}", VAStateCalcDeltaRA)


class VAStateCalcBetaAngle(IComponentInfo, ICloneable, IVAStateCalcBetaAngle):
    """BetaAngle Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcBetaAngle.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcBetaAngle._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcBetaAngle._get_property(self, attrname) is not None: found_prop = IVAStateCalcBetaAngle._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcBetaAngle.")
        
agcls.AgClassCatalog.add_catalog_entry("{B51815A6-AEDE-468C-B282-EEA255DAF822}", VAStateCalcBetaAngle)


class VAStateCalcLocalApparentSolarLon(IComponentInfo, ICloneable, IVAStateCalcLocalApparentSolarLon):
    """LocalApparentSolarLon Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcLocalApparentSolarLon.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcLocalApparentSolarLon._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcLocalApparentSolarLon._get_property(self, attrname) is not None: found_prop = IVAStateCalcLocalApparentSolarLon._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcLocalApparentSolarLon.")
        
agcls.AgClassCatalog.add_catalog_entry("{E7AC3C2D-5E4C-447F-8A56-C9CFCDBB2143}", VAStateCalcLocalApparentSolarLon)


class VAStateCalcLonOfPeriapsis(IComponentInfo, ICloneable, IVAStateCalcLonOfPeriapsis):
    """LonOfPeriapsis Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcLonOfPeriapsis.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcLonOfPeriapsis._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcLonOfPeriapsis._get_property(self, attrname) is not None: found_prop = IVAStateCalcLonOfPeriapsis._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcLonOfPeriapsis.")
        
agcls.AgClassCatalog.add_catalog_entry("{3DBA2AA2-6A87-4ACE-9F8D-C03001E1DBD1}", VAStateCalcLonOfPeriapsis)


class VAStateCalcOrbitStateValue(IComponentInfo, ICloneable, IVAStateCalcOrbitStateValue):
    """OrbitStateValue Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcOrbitStateValue.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcOrbitStateValue._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcOrbitStateValue._get_property(self, attrname) is not None: found_prop = IVAStateCalcOrbitStateValue._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcOrbitStateValue.")
        
agcls.AgClassCatalog.add_catalog_entry("{10879C56-0D1C-4E8E-B7CA-F059FB935366}", VAStateCalcOrbitStateValue)


class VAStateCalcSignedEccentricity(IComponentInfo, ICloneable, IVAStateCalcSignedEccentricity):
    """SignedEccentricity Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcSignedEccentricity.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcSignedEccentricity._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcSignedEccentricity._get_property(self, attrname) is not None: found_prop = IVAStateCalcSignedEccentricity._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcSignedEccentricity.")
        
agcls.AgClassCatalog.add_catalog_entry("{469C3DB7-C322-480A-82E2-4763AD59E470}", VAStateCalcSignedEccentricity)


class VAStateCalcInclination(IComponentInfo, ICloneable, IVAStateCalcInclination):
    """Inclination Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcInclination.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcInclination._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcInclination._get_property(self, attrname) is not None: found_prop = IVAStateCalcInclination._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcInclination.")
        
agcls.AgClassCatalog.add_catalog_entry("{1B8A0935-D9A7-4710-8C02-8A827F7D85DF}", VAStateCalcInclination)


class VAStateCalcTrueLon(IComponentInfo, ICloneable, IVAStateCalcTrueLon):
    """TrueLong Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcTrueLon.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcTrueLon._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcTrueLon._get_property(self, attrname) is not None: found_prop = IVAStateCalcTrueLon._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcTrueLon.")
        
agcls.AgClassCatalog.add_catalog_entry("{E1D740A4-341A-40AA-83E8-4456207A0D98}", VAStateCalcTrueLon)


class VAStateCalcPower(IComponentInfo, ICloneable, IVAStateCalcPower):
    """Power Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcPower.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcPower._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcPower._get_property(self, attrname) is not None: found_prop = IVAStateCalcPower._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcPower.")
        
agcls.AgClassCatalog.add_catalog_entry("{AE828349-BB26-44C8-9603-ED89F108DF82}", VAStateCalcPower)


class VAStateCalcRelMotion(IComponentInfo, ICloneable, IVAStateCalcRelMotion):
    """Relative Motion Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcRelMotion.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcRelMotion._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcRelMotion._get_property(self, attrname) is not None: found_prop = IVAStateCalcRelMotion._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcRelMotion.")
        
agcls.AgClassCatalog.add_catalog_entry("{1BE88040-9A43-40B0-9A3F-28C1AE4FCC33}", VAStateCalcRelMotion)


class VAStateCalcSolarBetaAngle(IComponentInfo, ICloneable, IVAStateCalcSolarBetaAngle):
    """Solar Beta Angle objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcSolarBetaAngle.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcSolarBetaAngle._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcSolarBetaAngle._get_property(self, attrname) is not None: found_prop = IVAStateCalcSolarBetaAngle._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcSolarBetaAngle.")
        
agcls.AgClassCatalog.add_catalog_entry("{A2AFBF81-9B6D-4675-B8A3-2995530B257F}", VAStateCalcSolarBetaAngle)


class VAStateCalcSolarInPlaneAngle(IComponentInfo, ICloneable, IVAStateCalcSolarInPlaneAngle):
    """Solar In Plane Angle objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcSolarInPlaneAngle.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcSolarInPlaneAngle._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcSolarInPlaneAngle._get_property(self, attrname) is not None: found_prop = IVAStateCalcSolarInPlaneAngle._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcSolarInPlaneAngle.")
        
agcls.AgClassCatalog.add_catalog_entry("{AF76B597-61AE-41E7-B7F9-47AB9FA06A23}", VAStateCalcSolarInPlaneAngle)


class VAStateCalcRelPosDecAngle(IComponentInfo, ICloneable, IVAStateCalcRelPosDecAngle):
    """Relative Position Declination Angle objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcRelPosDecAngle.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcRelPosDecAngle._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcRelPosDecAngle._get_property(self, attrname) is not None: found_prop = IVAStateCalcRelPosDecAngle._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcRelPosDecAngle.")
        
agcls.AgClassCatalog.add_catalog_entry("{75D53DB6-15AE-43CE-8ABC-5B8568CEE035}", VAStateCalcRelPosDecAngle)


class VAStateCalcRelPosInPlaneAngle(IComponentInfo, ICloneable, IVAStateCalcRelPosInPlaneAngle):
    """Relative Position Declination Angle objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcRelPosInPlaneAngle.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcRelPosInPlaneAngle._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcRelPosInPlaneAngle._get_property(self, attrname) is not None: found_prop = IVAStateCalcRelPosInPlaneAngle._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcRelPosInPlaneAngle.")
        
agcls.AgClassCatalog.add_catalog_entry("{4F7C4C55-BAB3-484D-B110-4A34A6F1A006}", VAStateCalcRelPosInPlaneAngle)


class VAStateCalcRelativeInclination(IComponentInfo, ICloneable, IVAStateCalcRelativeInclination):
    """Relative Inclination Angle objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcRelativeInclination.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcRelativeInclination._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcRelativeInclination._get_property(self, attrname) is not None: found_prop = IVAStateCalcRelativeInclination._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcRelativeInclination.")
        
agcls.AgClassCatalog.add_catalog_entry("{B2BAF85F-8B05-4261-8E40-428FD9F6A237}", VAStateCalcRelativeInclination)


class VAStateCalcCurvilinearRelMotion(IComponentInfo, ICloneable, IVAStateCalcCurvilinearRelMotion):
    """Curvilinear Relative Motion objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcCurvilinearRelMotion.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcCurvilinearRelMotion._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcCurvilinearRelMotion._get_property(self, attrname) is not None: found_prop = IVAStateCalcCurvilinearRelMotion._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcCurvilinearRelMotion.")
        
agcls.AgClassCatalog.add_catalog_entry("{1FBB6D32-A2AD-4914-940D-30E548147C35}", VAStateCalcCurvilinearRelMotion)


class VAStateCalcCustomFunction(IComponentInfo, ICloneable, IVAStateCalcCustomFunction):
    """Custom Function Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcCustomFunction.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcCustomFunction._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcCustomFunction._get_property(self, attrname) is not None: found_prop = IVAStateCalcCustomFunction._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcCustomFunction.")
        
agcls.AgClassCatalog.add_catalog_entry("{85022653-0E1C-4116-AC71-AE8AE17AD8AB}", VAStateCalcCustomFunction)


class VAStateCalcScript(IComponentInfo, ICloneable, IVAStateCalcScript):
    """Script Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcScript.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcScript._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcScript._get_property(self, attrname) is not None: found_prop = IVAStateCalcScript._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcScript.")
        
agcls.AgClassCatalog.add_catalog_entry("{5D44239C-5296-4B55-B0A6-810D2A709B20}", VAStateCalcScript)


class VAStateCalcCd(IComponentInfo, ICloneable, IVAStateCalcCd):
    """Cd Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcCd.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcCd._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcCd._get_property(self, attrname) is not None: found_prop = IVAStateCalcCd._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcCd.")
        
agcls.AgClassCatalog.add_catalog_entry("{9672871F-3A83-41E8-851E-509DD513C3E3}", VAStateCalcCd)


class VAStateCalcCr(IComponentInfo, ICloneable, IVAStateCalcCr):
    """Cr Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcCr.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcCr._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcCr._get_property(self, attrname) is not None: found_prop = IVAStateCalcCr._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcCr.")
        
agcls.AgClassCatalog.add_catalog_entry("{1AAFF1B0-616E-4A1C-9CE0-075D24C3B170}", VAStateCalcCr)


class VAStateCalcDragArea(IComponentInfo, ICloneable, IVAStateCalcDragArea):
    """DragArea Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcDragArea.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcDragArea._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcDragArea._get_property(self, attrname) is not None: found_prop = IVAStateCalcDragArea._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcDragArea.")
        
agcls.AgClassCatalog.add_catalog_entry("{3ED247EF-6E67-4883-A2FE-B2A7BF19E14E}", VAStateCalcDragArea)


class VAStateCalcRadiationPressureArea(IComponentInfo, ICloneable, IVAStateCalcRadiationPressureArea):
    """RadPressureArea Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcRadiationPressureArea.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcRadiationPressureArea._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcRadiationPressureArea._get_property(self, attrname) is not None: found_prop = IVAStateCalcRadiationPressureArea._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcRadiationPressureArea.")
        
agcls.AgClassCatalog.add_catalog_entry("{C7973875-9EFC-41FC-98CF-CCB7AE0C611F}", VAStateCalcRadiationPressureArea)


class VAStateCalcRadiationPressureCoefficient(IComponentInfo, ICloneable, IVAStateCalcRadiationPressureCoefficient):
    """RadiationPressureCoefficient Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcRadiationPressureCoefficient.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcRadiationPressureCoefficient._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcRadiationPressureCoefficient._get_property(self, attrname) is not None: found_prop = IVAStateCalcRadiationPressureCoefficient._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcRadiationPressureCoefficient.")
        
agcls.AgClassCatalog.add_catalog_entry("{7FDC4AD9-E570-4820-BFB3-939EA5FF7D82}", VAStateCalcRadiationPressureCoefficient)


class VAStateCalcSRPArea(IComponentInfo, ICloneable, IVAStateCalcSRPArea):
    """SRPArea Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcSRPArea.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcSRPArea._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcSRPArea._get_property(self, attrname) is not None: found_prop = IVAStateCalcSRPArea._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcSRPArea.")
        
agcls.AgClassCatalog.add_catalog_entry("{6A0BF963-BD8C-46F9-8C87-F6E0FF16D057}", VAStateCalcSRPArea)


class VAStateCalcCosOfVerticalFPA(IComponentInfo, ICloneable, IVAStateCalcCosOfVerticalFPA):
    """CosineOfVerticalFPA Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcCosOfVerticalFPA.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcCosOfVerticalFPA._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcCosOfVerticalFPA._get_property(self, attrname) is not None: found_prop = IVAStateCalcCosOfVerticalFPA._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcCosOfVerticalFPA.")
        
agcls.AgClassCatalog.add_catalog_entry("{779C8E84-1667-442C-BFD9-F20271803FE5}", VAStateCalcCosOfVerticalFPA)


class VAStateCalcDec(IComponentInfo, ICloneable, IVAStateCalcDec):
    """Dec Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcDec.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcDec._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcDec._get_property(self, attrname) is not None: found_prop = IVAStateCalcDec._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcDec.")
        
agcls.AgClassCatalog.add_catalog_entry("{3F821D80-1156-46EB-950F-FF965EB54C3C}", VAStateCalcDec)


class VAStateCalcFPA(IComponentInfo, ICloneable, IVAStateCalcFPA):
    """FPA Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcFPA.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcFPA._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcFPA._get_property(self, attrname) is not None: found_prop = IVAStateCalcFPA._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcFPA.")
        
agcls.AgClassCatalog.add_catalog_entry("{BAB717ED-41A9-4D2A-ADB3-F2D0F5BD67D6}", VAStateCalcFPA)


class VAStateCalcRMag(IComponentInfo, ICloneable, IVAStateCalcRMag):
    """RMag Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcRMag.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcRMag._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcRMag._get_property(self, attrname) is not None: found_prop = IVAStateCalcRMag._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcRMag.")
        
agcls.AgClassCatalog.add_catalog_entry("{4EED7719-E95B-4482-936C-9940FF6EE774}", VAStateCalcRMag)


class VAStateCalcRA(IComponentInfo, ICloneable, IVAStateCalcRA):
    """RA Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcRA.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcRA._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcRA._get_property(self, attrname) is not None: found_prop = IVAStateCalcRA._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcRA.")
        
agcls.AgClassCatalog.add_catalog_entry("{2482280B-347A-49C7-BEEB-044CD8F8C899}", VAStateCalcRA)


class VAStateCalcVMag(IComponentInfo, ICloneable, IVAStateCalcVMag):
    """VMag Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcVMag.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcVMag._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcVMag._get_property(self, attrname) is not None: found_prop = IVAStateCalcVMag._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcVMag.")
        
agcls.AgClassCatalog.add_catalog_entry("{B2DD548E-6DD5-4C33-9EDC-8275A4711B70}", VAStateCalcVMag)


class VAStateCalcVelAz(IComponentInfo, ICloneable, IVAStateCalcVelAz):
    """Velocity Azimuth Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcVelAz.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcVelAz._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcVelAz._get_property(self, attrname) is not None: found_prop = IVAStateCalcVelAz._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcVelAz.")
        
agcls.AgClassCatalog.add_catalog_entry("{51BBAEBF-08A7-47B0-82A2-49DD3B47C0DA}", VAStateCalcVelAz)


class VAStateCalcC3Energy(IComponentInfo, ICloneable, IVAStateCalcC3Energy):
    """C3Energy Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcC3Energy.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcC3Energy._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcC3Energy._get_property(self, attrname) is not None: found_prop = IVAStateCalcC3Energy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcC3Energy.")
        
agcls.AgClassCatalog.add_catalog_entry("{3F05AC7C-3565-44C8-BD75-A9F26F5DEBE7}", VAStateCalcC3Energy)


class VAStateCalcInAsympDec(IComponentInfo, ICloneable, IVAStateCalcInAsympDec):
    """InAsymptoteDec Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcInAsympDec.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcInAsympDec._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcInAsympDec._get_property(self, attrname) is not None: found_prop = IVAStateCalcInAsympDec._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcInAsympDec.")
        
agcls.AgClassCatalog.add_catalog_entry("{74C3D08C-5CBE-4182-9C50-5607CFAE3C29}", VAStateCalcInAsympDec)


class VAStateCalcInAsympRA(IComponentInfo, ICloneable, IVAStateCalcInAsympRA):
    """InAsymptoteRA Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcInAsympRA.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcInAsympRA._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcInAsympRA._get_property(self, attrname) is not None: found_prop = IVAStateCalcInAsympRA._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcInAsympRA.")
        
agcls.AgClassCatalog.add_catalog_entry("{FA6F2B49-B25B-4726-A72B-EB01DA9A40FA}", VAStateCalcInAsympRA)


class VAStateCalcInVelAzAtPeriapsis(IComponentInfo, ICloneable, IVAStateCalcInVelAzAtPeriapsis):
    """InVelocityAzAtPeriapsis Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcInVelAzAtPeriapsis.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcInVelAzAtPeriapsis._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcInVelAzAtPeriapsis._get_property(self, attrname) is not None: found_prop = IVAStateCalcInVelAzAtPeriapsis._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcInVelAzAtPeriapsis.")
        
agcls.AgClassCatalog.add_catalog_entry("{F425CF2E-5BD8-47E0-86FB-8E6911450DC2}", VAStateCalcInVelAzAtPeriapsis)


class VAStateCalcOutAsympDec(IComponentInfo, ICloneable, IVAStateCalcOutAsympDec):
    """OutAsymptoteDec Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcOutAsympDec.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcOutAsympDec._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcOutAsympDec._get_property(self, attrname) is not None: found_prop = IVAStateCalcOutAsympDec._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcOutAsympDec.")
        
agcls.AgClassCatalog.add_catalog_entry("{E6479974-FCA0-4BB3-9218-5EA7FBC6B309}", VAStateCalcOutAsympDec)


class VAStateCalcOutAsympRA(IComponentInfo, ICloneable, IVAStateCalcOutAsympRA):
    """OutAsymptoteRA Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcOutAsympRA.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcOutAsympRA._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcOutAsympRA._get_property(self, attrname) is not None: found_prop = IVAStateCalcOutAsympRA._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcOutAsympRA.")
        
agcls.AgClassCatalog.add_catalog_entry("{5FD80B29-8811-4669-9830-E00AC6A65B7A}", VAStateCalcOutAsympRA)


class VAStateCalcOutVelAzAtPeriapsis(IComponentInfo, ICloneable, IVAStateCalcOutVelAzAtPeriapsis):
    """OutVelocityAzAtPeriapsis Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcOutVelAzAtPeriapsis.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcOutVelAzAtPeriapsis._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcOutVelAzAtPeriapsis._get_property(self, attrname) is not None: found_prop = IVAStateCalcOutVelAzAtPeriapsis._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcOutVelAzAtPeriapsis.")
        
agcls.AgClassCatalog.add_catalog_entry("{6FACAD87-7615-433A-BED5-B79F771BF045}", VAStateCalcOutVelAzAtPeriapsis)


class VAStateCalcDuration(IComponentInfo, ICloneable, IVAStateCalcDuration):
    """Duration Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcDuration.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcDuration._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcDuration._get_property(self, attrname) is not None: found_prop = IVAStateCalcDuration._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcDuration.")
        
agcls.AgClassCatalog.add_catalog_entry("{8A31F99F-B1EA-4818-B3F7-6485F142BEDA}", VAStateCalcDuration)


class VAStateCalcUserValue(IVAStateCalcUserValue, IComponentInfo, ICloneable):
    """CoClass StateCalcUserValue."""
    def __init__(self, sourceObject=None):
        IVAStateCalcUserValue.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAStateCalcUserValue._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAStateCalcUserValue._get_property(self, attrname) is not None: found_prop = IVAStateCalcUserValue._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcUserValue.")
        
agcls.AgClassCatalog.add_catalog_entry("{DF6CDC8E-3271-4671-851E-6D8916364D04}", VAStateCalcUserValue)


class VAStateCalcCrdnAngle(IComponentInfo, ICloneable, IVAStateCalcCrdnAngle):
    """Vector Geometry Tool Angle Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcCrdnAngle.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcCrdnAngle._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcCrdnAngle._get_property(self, attrname) is not None: found_prop = IVAStateCalcCrdnAngle._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcCrdnAngle.")
        
agcls.AgClassCatalog.add_catalog_entry("{382A3B1B-6CB2-4E54-A066-C0B62EF241C8}", VAStateCalcCrdnAngle)


class VAStateCalcAngle(IComponentInfo, ICloneable, IVAStateCalcAngle):
    """Angle Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcAngle.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcAngle._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcAngle._get_property(self, attrname) is not None: found_prop = IVAStateCalcAngle._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcAngle.")
        
agcls.AgClassCatalog.add_catalog_entry("{C19A5EF8-79AF-48F2-9D09-86AE97CC689A}", VAStateCalcAngle)


class VAStateCalcDotProduct(IComponentInfo, ICloneable, IVAStateCalcDotProduct):
    """DotProduct Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcDotProduct.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcDotProduct._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcDotProduct._get_property(self, attrname) is not None: found_prop = IVAStateCalcDotProduct._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcDotProduct.")
        
agcls.AgClassCatalog.add_catalog_entry("{B8E6B301-8959-44D9-B9EC-70FEA1B5B12D}", VAStateCalcDotProduct)


class VAStateCalcVectorDec(IComponentInfo, ICloneable, IVAStateCalcVectorDec):
    """VectorDec Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcVectorDec.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcVectorDec._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcVectorDec._get_property(self, attrname) is not None: found_prop = IVAStateCalcVectorDec._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcVectorDec.")
        
agcls.AgClassCatalog.add_catalog_entry("{F5F90539-F030-4840-A78F-7BFE9FE6852F}", VAStateCalcVectorDec)


class VAStateCalcVectorMag(IComponentInfo, ICloneable, IVAStateCalcVectorMag):
    """VectorMag Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcVectorMag.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcVectorMag._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcVectorMag._get_property(self, attrname) is not None: found_prop = IVAStateCalcVectorMag._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcVectorMag.")
        
agcls.AgClassCatalog.add_catalog_entry("{AE89CDB6-F735-4DAB-88D3-7F2DD834C1E4}", VAStateCalcVectorMag)


class VAStateCalcVectorRA(IComponentInfo, ICloneable, IVAStateCalcVectorRA):
    """VectorRA Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcVectorRA.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcVectorRA._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcVectorRA._get_property(self, attrname) is not None: found_prop = IVAStateCalcVectorRA._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcVectorRA.")
        
agcls.AgClassCatalog.add_catalog_entry("{CE22AAAD-F51C-4E90-8E74-5DCEE756020C}", VAStateCalcVectorRA)


class VAStateCalcVectorX(IComponentInfo, ICloneable, IVAStateCalcVectorX):
    """VectorX Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcVectorX.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcVectorX._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcVectorX._get_property(self, attrname) is not None: found_prop = IVAStateCalcVectorX._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcVectorX.")
        
agcls.AgClassCatalog.add_catalog_entry("{9CC56135-C9E6-4A99-B0E2-70EA81E9AB08}", VAStateCalcVectorX)


class VAStateCalcOnePtAccess(IComponentInfo, ICloneable, IVAStateCalcOnePtAccess):
    """Access Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcOnePtAccess.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcOnePtAccess._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcOnePtAccess._get_property(self, attrname) is not None: found_prop = IVAStateCalcOnePtAccess._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcOnePtAccess.")
        
agcls.AgClassCatalog.add_catalog_entry("{19CBB92F-B6BE-4F6B-A2F9-056AD2EF7940}", VAStateCalcOnePtAccess)


class VAStateCalcDifferenceAcrossSegmentsOtherSat(IComponentInfo, ICloneable, IVAStateCalcDifferenceAcrossSegmentsOtherSat):
    """DifferenceAcrossSegmentsOtherSat Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcDifferenceAcrossSegmentsOtherSat.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcDifferenceAcrossSegmentsOtherSat._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcDifferenceAcrossSegmentsOtherSat._get_property(self, attrname) is not None: found_prop = IVAStateCalcDifferenceAcrossSegmentsOtherSat._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcDifferenceAcrossSegmentsOtherSat.")
        
agcls.AgClassCatalog.add_catalog_entry("{83FAC79B-477F-4CD0-83AD-A0A2A9ECA782}", VAStateCalcDifferenceAcrossSegmentsOtherSat)


class VAStateCalcValueAtSegmentOtherSat(IComponentInfo, ICloneable, IVAStateCalcValueAtSegmentOtherSat):
    """ValueAtSegmentOtherSat Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcValueAtSegmentOtherSat.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcValueAtSegmentOtherSat._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcValueAtSegmentOtherSat._get_property(self, attrname) is not None: found_prop = IVAStateCalcValueAtSegmentOtherSat._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcValueAtSegmentOtherSat.")
        
agcls.AgClassCatalog.add_catalog_entry("{5F9F3194-5AC1-46C9-8FB9-F076747180E7}", VAStateCalcValueAtSegmentOtherSat)


class VAStateCalcRARate(IVAStateCalcRARate, IComponentInfo, ICloneable):
    """RightAscensionRate Calc objects."""
    def __init__(self, sourceObject=None):
        IVAStateCalcRARate.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAStateCalcRARate._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAStateCalcRARate._get_property(self, attrname) is not None: found_prop = IVAStateCalcRARate._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcRARate.")
        
agcls.AgClassCatalog.add_catalog_entry("{3B9AD865-10A2-4B52-BDC7-7BE11A2CD36D}", VAStateCalcRARate)


class VAStateCalcDecRate(IVAStateCalcDecRate, IComponentInfo, ICloneable):
    """DeclinationRate Calc objects."""
    def __init__(self, sourceObject=None):
        IVAStateCalcDecRate.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAStateCalcDecRate._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAStateCalcDecRate._get_property(self, attrname) is not None: found_prop = IVAStateCalcDecRate._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcDecRate.")
        
agcls.AgClassCatalog.add_catalog_entry("{CCE41365-840A-4B9A-967F-A7D1E761B2DF}", VAStateCalcDecRate)


class VAStateCalcGravitationalParameter(IVAStateCalcGravitationalParameter, IComponentInfo, ICloneable):
    """GravitationalParameter Calc objects."""
    def __init__(self, sourceObject=None):
        IVAStateCalcGravitationalParameter.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAStateCalcGravitationalParameter._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAStateCalcGravitationalParameter._get_property(self, attrname) is not None: found_prop = IVAStateCalcGravitationalParameter._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcGravitationalParameter.")
        
agcls.AgClassCatalog.add_catalog_entry("{0B3B8CA7-E0BC-4A0E-A0BE-026946EBF0A6}", VAStateCalcGravitationalParameter)


class VAStateCalcReferenceRadius(IVAStateCalcReferenceRadius, IComponentInfo, ICloneable):
    """Reference Radius Calc objects."""
    def __init__(self, sourceObject=None):
        IVAStateCalcReferenceRadius.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAStateCalcReferenceRadius._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAStateCalcReferenceRadius._get_property(self, attrname) is not None: found_prop = IVAStateCalcReferenceRadius._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcReferenceRadius.")
        
agcls.AgClassCatalog.add_catalog_entry("{C90B0911-1B88-4809-A9AD-B1F083E18808}", VAStateCalcReferenceRadius)


class VAStateCalcGravCoeff(IVAStateCalcGravCoeff, IComponentInfo, ICloneable):
    """Gravity Coefficient Calc objects."""
    def __init__(self, sourceObject=None):
        IVAStateCalcGravCoeff.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAStateCalcGravCoeff._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAStateCalcGravCoeff._get_property(self, attrname) is not None: found_prop = IVAStateCalcGravCoeff._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcGravCoeff.")
        
agcls.AgClassCatalog.add_catalog_entry("{30223DC9-7946-4480-8E8A-DB3393DFEFC8}", VAStateCalcGravCoeff)


class VAStateCalcSpeedOfLight(IVAStateCalcSpeedOfLight, IComponentInfo, ICloneable):
    """Speed Of Light Calc objects."""
    def __init__(self, sourceObject=None):
        IVAStateCalcSpeedOfLight.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAStateCalcSpeedOfLight._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAStateCalcSpeedOfLight._get_property(self, attrname) is not None: found_prop = IVAStateCalcSpeedOfLight._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcSpeedOfLight.")
        
agcls.AgClassCatalog.add_catalog_entry("{BB3D0551-655B-43D3-89BE-59816A9B2DF4}", VAStateCalcSpeedOfLight)


class VAStateCalcPi(IVAStateCalcPi, IComponentInfo, ICloneable):
    """Pi Calc objects."""
    def __init__(self, sourceObject=None):
        IVAStateCalcPi.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAStateCalcPi._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAStateCalcPi._get_property(self, attrname) is not None: found_prop = IVAStateCalcPi._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcPi.")
        
agcls.AgClassCatalog.add_catalog_entry("{81779742-2FD6-4E22-81C5-05F1D271944F}", VAStateCalcPi)


class VAStateCalcScalar(IVAStateCalcScalar, IComponentInfo, ICloneable):
    """Scalar Calc objects."""
    def __init__(self, sourceObject=None):
        IVAStateCalcScalar.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAStateCalcScalar._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAStateCalcScalar._get_property(self, attrname) is not None: found_prop = IVAStateCalcScalar._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcScalar.")
        
agcls.AgClassCatalog.add_catalog_entry("{C6136D77-3185-4A4C-83AA-90CC6713A07A}", VAStateCalcScalar)


class VAStateCalcApparentSolarTime(IComponentInfo, ICloneable, IVAStateCalcApparentSolarTime):
    """Apparent Solar Time Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcApparentSolarTime.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcApparentSolarTime._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcApparentSolarTime._get_property(self, attrname) is not None: found_prop = IVAStateCalcApparentSolarTime._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcApparentSolarTime.")
        
agcls.AgClassCatalog.add_catalog_entry("{EF933369-A9DC-4A8C-B361-615A7A8B852D}", VAStateCalcApparentSolarTime)


class VAStateCalcEarthMeanSolarTime(IComponentInfo, ICloneable, IVAStateCalcEarthMeanSolarTime):
    """EarthMeanSolarTime Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcEarthMeanSolarTime.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcEarthMeanSolarTime._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcEarthMeanSolarTime._get_property(self, attrname) is not None: found_prop = IVAStateCalcEarthMeanSolarTime._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcEarthMeanSolarTime.")
        
agcls.AgClassCatalog.add_catalog_entry("{A36F3E6D-DD64-4089-A0B9-CDDECA9F31BF}", VAStateCalcEarthMeanSolarTime)


class VAStateCalcEarthMeanLocTimeAN(IComponentInfo, ICloneable, IVAStateCalcEarthMeanLocTimeAN):
    """EarthMeanLocTimeAN Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IVAStateCalcEarthMeanLocTimeAN.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IVAStateCalcEarthMeanLocTimeAN._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IVAStateCalcEarthMeanLocTimeAN._get_property(self, attrname) is not None: found_prop = IVAStateCalcEarthMeanLocTimeAN._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateCalcEarthMeanLocTimeAN.")
        
agcls.AgClassCatalog.add_catalog_entry("{8B52530C-09B1-48BB-A644-2564B3F9A23F}", VAStateCalcEarthMeanLocTimeAN)


class VAAutomaticSequenceCollection(IVAAutomaticSequenceCollection):
    """Automatic Sequence Collection."""
    def __init__(self, sourceObject=None):
        IVAAutomaticSequenceCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAAutomaticSequenceCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAAutomaticSequenceCollection._get_property(self, attrname) is not None: found_prop = IVAAutomaticSequenceCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAAutomaticSequenceCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{364BDB62-ECD6-4661-A8EB-D6943F5BD5BF}", VAAutomaticSequenceCollection)


class VAAutomaticSequence(IVAAutomaticSequence):
    """Automatic Sequence."""
    def __init__(self, sourceObject=None):
        IVAAutomaticSequence.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAAutomaticSequence._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAAutomaticSequence._get_property(self, attrname) is not None: found_prop = IVAAutomaticSequence._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAAutomaticSequence.")
        
agcls.AgClassCatalog.add_catalog_entry("{8755DF12-EDDB-468E-92AF-D98C5C1B1534}", VAAutomaticSequence)


class VACentralBodyCollection(IVACentralBodyCollection):
    """Central Body Collection."""
    def __init__(self, sourceObject=None):
        IVACentralBodyCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVACentralBodyCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVACentralBodyCollection._get_property(self, attrname) is not None: found_prop = IVACentralBodyCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VACentralBodyCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{393D9C77-A9A2-4E5A-B285-9292EAF77559}", VACentralBodyCollection)


class VACentralBody(IVACentralBody, IComponentInfo, ICloneable):
    """Central Body."""
    def __init__(self, sourceObject=None):
        IVACentralBody.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVACentralBody._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVACentralBody._get_property(self, attrname) is not None: found_prop = IVACentralBody._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VACentralBody.")
        
agcls.AgClassCatalog.add_catalog_entry("{BB18EA4F-DF6E-44A3-B547-CD21EC10120C}", VACentralBody)


class VACbGravityModel(IVACbGravityModel):
    """Central Body Gravity Model."""
    def __init__(self, sourceObject=None):
        IVACbGravityModel.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVACbGravityModel._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVACbGravityModel._get_property(self, attrname) is not None: found_prop = IVACbGravityModel._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VACbGravityModel.")
        
agcls.AgClassCatalog.add_catalog_entry("{B235689A-958C-42EA-BACA-DF03ED880C5B}", VACbGravityModel)


class VACbShapeSphere(IVACbShapeSphere, IVACbShape):
    """Central Body Shape - Sphere."""
    def __init__(self, sourceObject=None):
        IVACbShapeSphere.__init__(self, sourceObject)
        IVACbShape.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVACbShapeSphere._private_init(self, pUnk)
        IVACbShape._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVACbShapeSphere._get_property(self, attrname) is not None: found_prop = IVACbShapeSphere._get_property(self, attrname)
        if IVACbShape._get_property(self, attrname) is not None: found_prop = IVACbShape._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VACbShapeSphere.")
        
agcls.AgClassCatalog.add_catalog_entry("{0AC87F61-8DFA-48FF-A1D2-D7DCD7133900}", VACbShapeSphere)


class VACbShapeOblateSpheroid(IVACbShapeOblateSpheroid, IVACbShape):
    """Central Body Shape - Spheroid."""
    def __init__(self, sourceObject=None):
        IVACbShapeOblateSpheroid.__init__(self, sourceObject)
        IVACbShape.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVACbShapeOblateSpheroid._private_init(self, pUnk)
        IVACbShape._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVACbShapeOblateSpheroid._get_property(self, attrname) is not None: found_prop = IVACbShapeOblateSpheroid._get_property(self, attrname)
        if IVACbShape._get_property(self, attrname) is not None: found_prop = IVACbShape._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VACbShapeOblateSpheroid.")
        
agcls.AgClassCatalog.add_catalog_entry("{1C606CEB-7C36-486E-A123-42AF0BCB2C8F}", VACbShapeOblateSpheroid)


class VACbShapeTriaxialEllipsoid(IVACbShapeTriaxialEllipsoid, IVACbShape):
    """Central Body Shape - Triaxial Ellipsoid."""
    def __init__(self, sourceObject=None):
        IVACbShapeTriaxialEllipsoid.__init__(self, sourceObject)
        IVACbShape.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVACbShapeTriaxialEllipsoid._private_init(self, pUnk)
        IVACbShape._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVACbShapeTriaxialEllipsoid._get_property(self, attrname) is not None: found_prop = IVACbShapeTriaxialEllipsoid._get_property(self, attrname)
        if IVACbShape._get_property(self, attrname) is not None: found_prop = IVACbShape._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VACbShapeTriaxialEllipsoid.")
        
agcls.AgClassCatalog.add_catalog_entry("{286452CC-4917-4618-B2B7-D4C4B226AEAE}", VACbShapeTriaxialEllipsoid)


class VACbAttitudeRotationCoefficientsFile(IVACbAttitudeRotationCoefficientsFile, IVACbAttitude):
    """Central Body Attitude - Rotation Coefficients File."""
    def __init__(self, sourceObject=None):
        IVACbAttitudeRotationCoefficientsFile.__init__(self, sourceObject)
        IVACbAttitude.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVACbAttitudeRotationCoefficientsFile._private_init(self, pUnk)
        IVACbAttitude._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVACbAttitudeRotationCoefficientsFile._get_property(self, attrname) is not None: found_prop = IVACbAttitudeRotationCoefficientsFile._get_property(self, attrname)
        if IVACbAttitude._get_property(self, attrname) is not None: found_prop = IVACbAttitude._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VACbAttitudeRotationCoefficientsFile.")
        
agcls.AgClassCatalog.add_catalog_entry("{BC7D0575-6607-4103-8957-0B791534526D}", VACbAttitudeRotationCoefficientsFile)


class VACbAttitudeIAU1994(IVACbAttitudeIAU1994, IVACbAttitude):
    """Central Body Attitude - IAU1994."""
    def __init__(self, sourceObject=None):
        IVACbAttitudeIAU1994.__init__(self, sourceObject)
        IVACbAttitude.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVACbAttitudeIAU1994._private_init(self, pUnk)
        IVACbAttitude._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVACbAttitudeIAU1994._get_property(self, attrname) is not None: found_prop = IVACbAttitudeIAU1994._get_property(self, attrname)
        if IVACbAttitude._get_property(self, attrname) is not None: found_prop = IVACbAttitude._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VACbAttitudeIAU1994.")
        
agcls.AgClassCatalog.add_catalog_entry("{147ABE46-6F5E-45D9-8279-5D01B0D78B88}", VACbAttitudeIAU1994)


class VACbEphemerisAnalyticOrbit(IVACbEphemerisAnalyticOrbit, IVACbEphemeris):
    """Central Body Ephemeris - Analytic Orbit."""
    def __init__(self, sourceObject=None):
        IVACbEphemerisAnalyticOrbit.__init__(self, sourceObject)
        IVACbEphemeris.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVACbEphemerisAnalyticOrbit._private_init(self, pUnk)
        IVACbEphemeris._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVACbEphemerisAnalyticOrbit._get_property(self, attrname) is not None: found_prop = IVACbEphemerisAnalyticOrbit._get_property(self, attrname)
        if IVACbEphemeris._get_property(self, attrname) is not None: found_prop = IVACbEphemeris._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VACbEphemerisAnalyticOrbit.")
        
agcls.AgClassCatalog.add_catalog_entry("{D2E09031-DB7F-480B-A361-73713F45EB70}", VACbEphemerisAnalyticOrbit)


class VACbEphemerisJPLSpice(IVACbEphemerisJPLSpice, IVACbEphemeris):
    """Central Body Ephemeris - JPLSpice."""
    def __init__(self, sourceObject=None):
        IVACbEphemerisJPLSpice.__init__(self, sourceObject)
        IVACbEphemeris.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVACbEphemerisJPLSpice._private_init(self, pUnk)
        IVACbEphemeris._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVACbEphemerisJPLSpice._get_property(self, attrname) is not None: found_prop = IVACbEphemerisJPLSpice._get_property(self, attrname)
        if IVACbEphemeris._get_property(self, attrname) is not None: found_prop = IVACbEphemeris._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VACbEphemerisJPLSpice.")
        
agcls.AgClassCatalog.add_catalog_entry("{A75A2A9B-F225-43D5-A259-30C9B0488EB8}", VACbEphemerisJPLSpice)


class VACbEphemerisFile(IVACbEphemerisFile, IVACbEphemeris):
    """Central Body Ephemeris - File."""
    def __init__(self, sourceObject=None):
        IVACbEphemerisFile.__init__(self, sourceObject)
        IVACbEphemeris.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVACbEphemerisFile._private_init(self, pUnk)
        IVACbEphemeris._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVACbEphemerisFile._get_property(self, attrname) is not None: found_prop = IVACbEphemerisFile._get_property(self, attrname)
        if IVACbEphemeris._get_property(self, attrname) is not None: found_prop = IVACbEphemeris._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VACbEphemerisFile.")
        
agcls.AgClassCatalog.add_catalog_entry("{063BA11E-7F73-40FA-B691-B12EC38DE29B}", VACbEphemerisFile)


class VACbEphemerisJPLDE(IVACbEphemerisJPLDE, IVACbEphemeris):
    """Central Body Ephemeris - JPL DE."""
    def __init__(self, sourceObject=None):
        IVACbEphemerisJPLDE.__init__(self, sourceObject)
        IVACbEphemeris.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVACbEphemerisJPLDE._private_init(self, pUnk)
        IVACbEphemeris._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVACbEphemerisJPLDE._get_property(self, attrname) is not None: found_prop = IVACbEphemerisJPLDE._get_property(self, attrname)
        if IVACbEphemeris._get_property(self, attrname) is not None: found_prop = IVACbEphemeris._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VACbEphemerisJPLDE.")
        
agcls.AgClassCatalog.add_catalog_entry("{6426E9EA-5ED2-46C9-95BB-447955306CA7}", VACbEphemerisJPLDE)


class VACbEphemerisPlanetary(IVACbEphemerisPlanetary, IVACbEphemeris):
    """Central Body Ephemeris - Planetary."""
    def __init__(self, sourceObject=None):
        IVACbEphemerisPlanetary.__init__(self, sourceObject)
        IVACbEphemeris.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVACbEphemerisPlanetary._private_init(self, pUnk)
        IVACbEphemeris._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVACbEphemerisPlanetary._get_property(self, attrname) is not None: found_prop = IVACbEphemerisPlanetary._get_property(self, attrname)
        if IVACbEphemeris._get_property(self, attrname) is not None: found_prop = IVACbEphemeris._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VACbEphemerisPlanetary.")
        
agcls.AgClassCatalog.add_catalog_entry("{B3946E55-049C-4314-B6E1-1B3E4BD4F660}", VACbEphemerisPlanetary)


class VAMCSSegmentProperties(IVAMCSSegmentProperties, IRuntimeTypeInfoProvider):
    """Segment Properties."""
    def __init__(self, sourceObject=None):
        IVAMCSSegmentProperties.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAMCSSegmentProperties._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAMCSSegmentProperties._get_property(self, attrname) is not None: found_prop = IVAMCSSegmentProperties._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAMCSSegmentProperties.")
        
agcls.AgClassCatalog.add_catalog_entry("{9740187E-A60E-4440-952F-46FCEF10879C}", VAMCSSegmentProperties)


class VAPowerInternal(IVAPowerInternal, IComponentInfo, ICloneable):
    """Power - Internal."""
    def __init__(self, sourceObject=None):
        IVAPowerInternal.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAPowerInternal._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAPowerInternal._get_property(self, attrname) is not None: found_prop = IVAPowerInternal._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAPowerInternal.")
        
agcls.AgClassCatalog.add_catalog_entry("{269F510C-DE85-4BD7-B09C-15B573F83F31}", VAPowerInternal)


class VAPowerProcessed(IVAPowerProcessed, IComponentInfo, ICloneable):
    """Power - Processed Power Unit."""
    def __init__(self, sourceObject=None):
        IVAPowerProcessed.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAPowerProcessed._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAPowerProcessed._get_property(self, attrname) is not None: found_prop = IVAPowerProcessed._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAPowerProcessed.")
        
agcls.AgClassCatalog.add_catalog_entry("{F9B2570A-E760-4C58-B95A-6654FA264F43}", VAPowerProcessed)


class VAPowerSolarArray(IVAPowerSolarArray, IComponentInfo, ICloneable):
    """Power - Solar Array."""
    def __init__(self, sourceObject=None):
        IVAPowerSolarArray.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAPowerSolarArray._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAPowerSolarArray._get_property(self, attrname) is not None: found_prop = IVAPowerSolarArray._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAPowerSolarArray.")
        
agcls.AgClassCatalog.add_catalog_entry("{EFF8A0BD-0BEA-4A4C-B486-3BC0DDA2B96E}", VAPowerSolarArray)


class VAGeneralRelativityFunction(IVAGeneralRelativityFunction, IComponentInfo, ICloneable):
    """General Relativity Propagator Function."""
    def __init__(self, sourceObject=None):
        IVAGeneralRelativityFunction.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAGeneralRelativityFunction._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAGeneralRelativityFunction._get_property(self, attrname) is not None: found_prop = IVAGeneralRelativityFunction._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAGeneralRelativityFunction.")
        
agcls.AgClassCatalog.add_catalog_entry("{2388EABA-68BE-4071-A6FC-5DF5E6913E09}", VAGeneralRelativityFunction)


class VAStateTransFunction(IVAStateTransFunction, IComponentInfo, ICloneable):
    """State Transition Propagator Function."""
    def __init__(self, sourceObject=None):
        IVAStateTransFunction.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAStateTransFunction._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAStateTransFunction._get_property(self, attrname) is not None: found_prop = IVAStateTransFunction._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAStateTransFunction.")
        
agcls.AgClassCatalog.add_catalog_entry("{BC9BCE93-D459-43A4-B996-0710520ECD35}", VAStateTransFunction)


class VACR3BPFunc(IVACR3BPFunc, IComponentInfo, ICloneable):
    """CR3BP Function."""
    def __init__(self, sourceObject=None):
        IVACR3BPFunc.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVACR3BPFunc._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVACR3BPFunc._get_property(self, attrname) is not None: found_prop = IVACR3BPFunc._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VACR3BPFunc.")
        
agcls.AgClassCatalog.add_catalog_entry("{0CB5F652-0A94-4493-8397-78E8B147A600}", VACR3BPFunc)


class VARadiationPressureFunction(IVARadiationPressureFunction, IComponentInfo, ICloneable):
    """Radiation Pressure Propagator Function."""
    def __init__(self, sourceObject=None):
        IVARadiationPressureFunction.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVARadiationPressureFunction._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVARadiationPressureFunction._get_property(self, attrname) is not None: found_prop = IVARadiationPressureFunction._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VARadiationPressureFunction.")
        
agcls.AgClassCatalog.add_catalog_entry("{129DFCA0-E241-4BF5-947C-34D311459876}", VARadiationPressureFunction)


class VAYarkovskyFunc(IVAYarkovskyFunc, IComponentInfo, ICloneable):
    """Yarkovsky Effect Propagator Function."""
    def __init__(self, sourceObject=None):
        IVAYarkovskyFunc.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAYarkovskyFunc._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAYarkovskyFunc._get_property(self, attrname) is not None: found_prop = IVAYarkovskyFunc._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAYarkovskyFunc.")
        
agcls.AgClassCatalog.add_catalog_entry("{991BA5B1-ED2F-4633-8493-5AD584CBD4FC}", VAYarkovskyFunc)


class VABlendedDensity(IVABlendedDensity, IComponentInfo, ICloneable):
    """Blended atmospheric density propagator function."""
    def __init__(self, sourceObject=None):
        IVABlendedDensity.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVABlendedDensity._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVABlendedDensity._get_property(self, attrname) is not None: found_prop = IVABlendedDensity._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VABlendedDensity.")
        
agcls.AgClassCatalog.add_catalog_entry("{8262277E-56CE-4780-8EF3-08324A1A06FD}", VABlendedDensity)


class VACira72Function(IVACira72Function, IComponentInfo, ICloneable):
    """Cira72 atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IVACira72Function.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVACira72Function._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVACira72Function._get_property(self, attrname) is not None: found_prop = IVACira72Function._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VACira72Function.")
        
agcls.AgClassCatalog.add_catalog_entry("{995263CD-4163-4EDA-8012-310821C8A332}", VACira72Function)


class VAExponential(IVAExponential, IComponentInfo, ICloneable):
    """Exponential atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IVAExponential.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAExponential._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAExponential._get_property(self, attrname) is not None: found_prop = IVAExponential._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAExponential.")
        
agcls.AgClassCatalog.add_catalog_entry("{701C6D24-1D0E-4D08-9A3B-61566AABDE02}", VAExponential)


class VAHarrisPriester(IVAHarrisPriester, IComponentInfo, ICloneable):
    """Harris-Priester atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IVAHarrisPriester.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAHarrisPriester._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAHarrisPriester._get_property(self, attrname) is not None: found_prop = IVAHarrisPriester._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAHarrisPriester.")
        
agcls.AgClassCatalog.add_catalog_entry("{2C45FE9A-0EE9-46B0-B0A5-79A052FDE189}", VAHarrisPriester)


class VADensityModelPlugin(IVADensityModelPlugin, IComponentInfo, ICloneable):
    """Plugin atmospheric density propagator function."""
    def __init__(self, sourceObject=None):
        IVADensityModelPlugin.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVADensityModelPlugin._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVADensityModelPlugin._get_property(self, attrname) is not None: found_prop = IVADensityModelPlugin._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VADensityModelPlugin.")
        
agcls.AgClassCatalog.add_catalog_entry("{5331D02B-13E5-4609-BFE6-9BF842E6096F}", VADensityModelPlugin)


class VAJacchiaRoberts(IVAJacchiaRoberts, IComponentInfo, ICloneable):
    """Jacchia Roberts atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IVAJacchiaRoberts.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAJacchiaRoberts._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAJacchiaRoberts._get_property(self, attrname) is not None: found_prop = IVAJacchiaRoberts._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAJacchiaRoberts.")
        
agcls.AgClassCatalog.add_catalog_entry("{6227B561-C892-4BB5-A835-9619EB144173}", VAJacchiaRoberts)


class VAJacchiaBowman2008(IVAJacchiaBowman2008, IComponentInfo, ICloneable):
    """Jacchia Bowman 2008 atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IVAJacchiaBowman2008.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAJacchiaBowman2008._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAJacchiaBowman2008._get_property(self, attrname) is not None: found_prop = IVAJacchiaBowman2008._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAJacchiaBowman2008.")
        
agcls.AgClassCatalog.add_catalog_entry("{19461979-5C67-4840-8DB9-902EC47E6105}", VAJacchiaBowman2008)


class VAJacchia_1960(IVAJacchia_1960, IComponentInfo, ICloneable):
    """Jacchia_1960 atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IVAJacchia_1960.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAJacchia_1960._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAJacchia_1960._get_property(self, attrname) is not None: found_prop = IVAJacchia_1960._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAJacchia_1960.")
        
agcls.AgClassCatalog.add_catalog_entry("{E803E9D5-31AB-4D5C-B93E-AB9975E2402B}", VAJacchia_1960)


class VAJacchia_1970(IVAJacchia_1970, IComponentInfo, ICloneable):
    """Jacchia_1970 atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IVAJacchia_1970.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAJacchia_1970._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAJacchia_1970._get_property(self, attrname) is not None: found_prop = IVAJacchia_1970._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAJacchia_1970.")
        
agcls.AgClassCatalog.add_catalog_entry("{9E716F44-73D2-4A22-97C9-04C20386D575}", VAJacchia_1970)


class VAJacchia_1971(IVAJacchia_1971, IComponentInfo, ICloneable):
    """Jacchia_1971 atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IVAJacchia_1971.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAJacchia_1971._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAJacchia_1971._get_property(self, attrname) is not None: found_prop = IVAJacchia_1971._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAJacchia_1971.")
        
agcls.AgClassCatalog.add_catalog_entry("{50FFBB4C-124F-4DC6-BEED-F2EC4930B4E7}", VAJacchia_1971)


class VAMSISE_1990(IVAMSISE_1990, IComponentInfo, ICloneable):
    """MSISE 1990 atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IVAMSISE_1990.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAMSISE_1990._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAMSISE_1990._get_property(self, attrname) is not None: found_prop = IVAMSISE_1990._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAMSISE_1990.")
        
agcls.AgClassCatalog.add_catalog_entry("{A46341F0-9384-4A1D-970A-77B1B683359D}", VAMSISE_1990)


class VAMSIS_1986(IVAMSIS_1986, IComponentInfo, ICloneable):
    """MSIS 1986 atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IVAMSIS_1986.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAMSIS_1986._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAMSIS_1986._get_property(self, attrname) is not None: found_prop = IVAMSIS_1986._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAMSIS_1986.")
        
agcls.AgClassCatalog.add_catalog_entry("{AFAC9D69-5B78-48BA-8CFA-5D6A30BBF371}", VAMSIS_1986)


class VANRLMSISE_2000(IVANRLMSISE_2000, IComponentInfo, ICloneable):
    """NRLMSISE 2000 atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IVANRLMSISE_2000.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVANRLMSISE_2000._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVANRLMSISE_2000._get_property(self, attrname) is not None: found_prop = IVANRLMSISE_2000._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VANRLMSISE_2000.")
        
agcls.AgClassCatalog.add_catalog_entry("{2EEE9C88-FF61-497A-AD40-2429DBA0A581}", VANRLMSISE_2000)


class VAUS_Standard_Atmosphere(IVAUS_Standard_Atmosphere, IComponentInfo, ICloneable):
    """US_Standard_Atmosphere atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IVAUS_Standard_Atmosphere.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAUS_Standard_Atmosphere._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAUS_Standard_Atmosphere._get_property(self, attrname) is not None: found_prop = IVAUS_Standard_Atmosphere._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAUS_Standard_Atmosphere.")
        
agcls.AgClassCatalog.add_catalog_entry("{14714C17-B360-42E1-86EE-99EB95C71B69}", VAUS_Standard_Atmosphere)


class VAMarsGRAM37(IVAMarsGRAM37, IComponentInfo, ICloneable):
    """Mars-GRAM 3.7 atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IVAMarsGRAM37.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAMarsGRAM37._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAMarsGRAM37._get_property(self, attrname) is not None: found_prop = IVAMarsGRAM37._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAMarsGRAM37.")
        
agcls.AgClassCatalog.add_catalog_entry("{69A9AE89-0133-4410-A486-1ADEFBE56F49}", VAMarsGRAM37)


class VAMarsGRAM2000(IVAMarsGRAM2000, IComponentInfo, ICloneable):
    """Mars-GRAM 2000 atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IVAMarsGRAM2000.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAMarsGRAM2000._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAMarsGRAM2000._get_property(self, attrname) is not None: found_prop = IVAMarsGRAM2000._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAMarsGRAM2000.")
        
agcls.AgClassCatalog.add_catalog_entry("{FB31A16E-8E6F-4F8F-8D2D-0E3D0C0020FC}", VAMarsGRAM2000)


class VAMarsGRAM2001(IVAMarsGRAM2001, IComponentInfo, ICloneable):
    """Mars-GRAM 2001 atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IVAMarsGRAM2001.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAMarsGRAM2001._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAMarsGRAM2001._get_property(self, attrname) is not None: found_prop = IVAMarsGRAM2001._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAMarsGRAM2001.")
        
agcls.AgClassCatalog.add_catalog_entry("{F7A3F4ED-100F-463F-A9F5-177F49E44BA9}", VAMarsGRAM2001)


class VAMarsGRAM2005(IVAMarsGRAM2005, IComponentInfo, ICloneable):
    """Mars-GRAM 2005 atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IVAMarsGRAM2005.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAMarsGRAM2005._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAMarsGRAM2005._get_property(self, attrname) is not None: found_prop = IVAMarsGRAM2005._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAMarsGRAM2005.")
        
agcls.AgClassCatalog.add_catalog_entry("{FD314E36-8513-484A-B46A-FC8794E939AC}", VAMarsGRAM2005)


class VAMarsGRAM2010(IVAMarsGRAM2010, IComponentInfo, ICloneable):
    """Mars-GRAM 2010 atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IVAMarsGRAM2010.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAMarsGRAM2010._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAMarsGRAM2010._get_property(self, attrname) is not None: found_prop = IVAMarsGRAM2010._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAMarsGRAM2010.")
        
agcls.AgClassCatalog.add_catalog_entry("{EE0F710B-25B2-4423-86BE-892E0F221376}", VAMarsGRAM2010)


class VAVenusGRAM2005(IVAVenusGRAM2005, IComponentInfo, ICloneable):
    """Venus-GRAM 2005 atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IVAVenusGRAM2005.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAVenusGRAM2005._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAVenusGRAM2005._get_property(self, attrname) is not None: found_prop = IVAVenusGRAM2005._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAVenusGRAM2005.")
        
agcls.AgClassCatalog.add_catalog_entry("{2360812C-F645-4237-889F-EF487FFC20D7}", VAVenusGRAM2005)


class VADTM2012(IVADTM2012, IComponentInfo, ICloneable):
    """DTM 2012 atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IVADTM2012.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVADTM2012._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVADTM2012._get_property(self, attrname) is not None: found_prop = IVADTM2012._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VADTM2012.")
        
agcls.AgClassCatalog.add_catalog_entry("{131D3F3F-8444-4017-B12F-D57DF1262F58}", VADTM2012)


class VADTM2020(IVADTM2020, IComponentInfo, ICloneable):
    """DTM 2020 atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IVADTM2020.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVADTM2020._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVADTM2020._get_property(self, attrname) is not None: found_prop = IVADTM2020._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VADTM2020.")
        
agcls.AgClassCatalog.add_catalog_entry("{68457876-1EF6-4DD4-9295-E72570C4F97B}", VADTM2020)


class VAGravityFieldFunction(IVAGravityFieldFunction, IComponentInfo, ICloneable):
    """Gravity Field gravity propagator function."""
    def __init__(self, sourceObject=None):
        IVAGravityFieldFunction.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAGravityFieldFunction._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAGravityFieldFunction._get_property(self, attrname) is not None: found_prop = IVAGravityFieldFunction._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAGravityFieldFunction.")
        
agcls.AgClassCatalog.add_catalog_entry("{C2C24055-1B50-4BD9-A7F7-0AA5FCE8969E}", VAGravityFieldFunction)


class VAPointMassFunction(IVAPointMassFunction, IComponentInfo, ICloneable):
    """Point Mass function."""
    def __init__(self, sourceObject=None):
        IVAPointMassFunction.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAPointMassFunction._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAPointMassFunction._get_property(self, attrname) is not None: found_prop = IVAPointMassFunction._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAPointMassFunction.")
        
agcls.AgClassCatalog.add_catalog_entry("{E0A1592D-68C0-43DB-A338-DE22A591872A}", VAPointMassFunction)


class VATwoBodyFunction(IVATwoBodyFunction, IComponentInfo, ICloneable):
    """Two Body gravity propagator function."""
    def __init__(self, sourceObject=None):
        IVATwoBodyFunction.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVATwoBodyFunction._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVATwoBodyFunction._get_property(self, attrname) is not None: found_prop = IVATwoBodyFunction._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VATwoBodyFunction.")
        
agcls.AgClassCatalog.add_catalog_entry("{5C71D8C2-4A14-4D93-A8E5-5384AAB05E92}", VATwoBodyFunction)


class VAHPOPPluginFunction(IVAHPOPPluginFunction, IComponentInfo, ICloneable):
    """HPOP Plugin propagator function."""
    def __init__(self, sourceObject=None):
        IVAHPOPPluginFunction.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAHPOPPluginFunction._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAHPOPPluginFunction._get_property(self, attrname) is not None: found_prop = IVAHPOPPluginFunction._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAHPOPPluginFunction.")
        
agcls.AgClassCatalog.add_catalog_entry("{01BF5EA2-376F-49B2-B6DF-3017F30D8205}", VAHPOPPluginFunction)


class VAEOMFuncPluginFunction(IVAEOMFuncPluginFunction, IComponentInfo, ICloneable):
    """EOM Function Plugin propagator function."""
    def __init__(self, sourceObject=None):
        IVAEOMFuncPluginFunction.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAEOMFuncPluginFunction._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAEOMFuncPluginFunction._get_property(self, attrname) is not None: found_prop = IVAEOMFuncPluginFunction._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAEOMFuncPluginFunction.")
        
agcls.AgClassCatalog.add_catalog_entry("{6FCCD724-B386-487C-A2AD-6153FF4756FF}", VAEOMFuncPluginFunction)


class VASRPAeroT20(IVASRPAeroT20, IComponentInfo, ICloneable):
    """AeroT20 SRP propagator function."""
    def __init__(self, sourceObject=None):
        IVASRPAeroT20.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVASRPAeroT20._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVASRPAeroT20._get_property(self, attrname) is not None: found_prop = IVASRPAeroT20._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VASRPAeroT20.")
        
agcls.AgClassCatalog.add_catalog_entry("{6DB3E760-F774-45F3-A6E5-EA2A7E34416F}", VASRPAeroT20)


class VASRPAeroT30(IVASRPAeroT30, IComponentInfo, ICloneable):
    """AeroT30 SRP propagator function."""
    def __init__(self, sourceObject=None):
        IVASRPAeroT30.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVASRPAeroT30._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVASRPAeroT30._get_property(self, attrname) is not None: found_prop = IVASRPAeroT30._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VASRPAeroT30.")
        
agcls.AgClassCatalog.add_catalog_entry("{E4DF0601-9442-4649-AE24-516F20E819EF}", VASRPAeroT30)


class VASRPGSPM04aIIA(IVASRPGSPM04aIIA, IComponentInfo, ICloneable):
    """GSPM04aIIA SRP propagator function."""
    def __init__(self, sourceObject=None):
        IVASRPGSPM04aIIA.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVASRPGSPM04aIIA._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVASRPGSPM04aIIA._get_property(self, attrname) is not None: found_prop = IVASRPGSPM04aIIA._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VASRPGSPM04aIIA.")
        
agcls.AgClassCatalog.add_catalog_entry("{F6767C08-2100-464C-B18A-0528243E37DC}", VASRPGSPM04aIIA)


class VASRPGSPM04aIIR(IVASRPGSPM04aIIR, IComponentInfo, ICloneable):
    """GSPM04aIIR SRP propagator function."""
    def __init__(self, sourceObject=None):
        IVASRPGSPM04aIIR.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVASRPGSPM04aIIR._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVASRPGSPM04aIIR._get_property(self, attrname) is not None: found_prop = IVASRPGSPM04aIIR._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VASRPGSPM04aIIR.")
        
agcls.AgClassCatalog.add_catalog_entry("{FFF24BB0-8E3E-479A-957A-06719DF68A56}", VASRPGSPM04aIIR)


class VASRPGSPM04aeIIA(IVASRPGSPM04aeIIA, IComponentInfo, ICloneable):
    """GSPM04aeIIA SRP propagator function."""
    def __init__(self, sourceObject=None):
        IVASRPGSPM04aeIIA.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVASRPGSPM04aeIIA._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVASRPGSPM04aeIIA._get_property(self, attrname) is not None: found_prop = IVASRPGSPM04aeIIA._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VASRPGSPM04aeIIA.")
        
agcls.AgClassCatalog.add_catalog_entry("{82530B89-B383-4148-8606-BBA0EBA825CE}", VASRPGSPM04aeIIA)


class VASRPGSPM04aeIIR(IVASRPGSPM04aeIIR, IComponentInfo, ICloneable):
    """GSPM04aeIIR SRP propagator function."""
    def __init__(self, sourceObject=None):
        IVASRPGSPM04aeIIR.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVASRPGSPM04aeIIR._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVASRPGSPM04aeIIR._get_property(self, attrname) is not None: found_prop = IVASRPGSPM04aeIIR._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VASRPGSPM04aeIIR.")
        
agcls.AgClassCatalog.add_catalog_entry("{17C9AD04-9981-4541-9515-59A597003348}", VASRPGSPM04aeIIR)


class VASRPSpherical(IVASRPSpherical, IComponentInfo, ICloneable):
    """Spherical SRP propagator function."""
    def __init__(self, sourceObject=None):
        IVASRPSpherical.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVASRPSpherical._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVASRPSpherical._get_property(self, attrname) is not None: found_prop = IVASRPSpherical._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VASRPSpherical.")
        
agcls.AgClassCatalog.add_catalog_entry("{4318B037-C619-4722-A0F5-4FFDFA7D9474}", VASRPSpherical)


class VASRPNPlate(IVASRPNPlate, IComponentInfo, ICloneable):
    """NPlate SRP propagator function."""
    def __init__(self, sourceObject=None):
        IVASRPNPlate.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVASRPNPlate._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVASRPNPlate._get_property(self, attrname) is not None: found_prop = IVASRPNPlate._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VASRPNPlate.")
        
agcls.AgClassCatalog.add_catalog_entry("{81962DC5-1A26-4077-AC39-E8E75145858A}", VASRPNPlate)


class VASRPTabAreaVec(IVASRPTabAreaVec, IComponentInfo, ICloneable):
    """Tabulated area vector SRP propagator function."""
    def __init__(self, sourceObject=None):
        IVASRPTabAreaVec.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVASRPTabAreaVec._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVASRPTabAreaVec._get_property(self, attrname) is not None: found_prop = IVASRPTabAreaVec._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VASRPTabAreaVec.")
        
agcls.AgClassCatalog.add_catalog_entry("{77FAE0BD-36AF-4140-B62E-7B2865841152}", VASRPTabAreaVec)


class VASRPVariableArea(IVASRPVariableArea, IComponentInfo, ICloneable):
    """Variable Area SRP propagator function."""
    def __init__(self, sourceObject=None):
        IVASRPVariableArea.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVASRPVariableArea._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVASRPVariableArea._get_property(self, attrname) is not None: found_prop = IVASRPVariableArea._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VASRPVariableArea.")
        
agcls.AgClassCatalog.add_catalog_entry("{193838B2-807F-4E24-A05D-2E0BAB03B497}", VASRPVariableArea)


class VAThirdBodyFunction(IVAThirdBodyFunction, IComponentInfo, ICloneable):
    """ThirdBody propagator function."""
    def __init__(self, sourceObject=None):
        IVAThirdBodyFunction.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAThirdBodyFunction._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAThirdBodyFunction._get_property(self, attrname) is not None: found_prop = IVAThirdBodyFunction._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAThirdBodyFunction.")
        
agcls.AgClassCatalog.add_catalog_entry("{7E7DF54F-A10B-4B57-9919-ACD123F69001}", VAThirdBodyFunction)


class VADragModelPlugin(IVADragModelPlugin, IComponentInfo, ICloneable):
    """Drag Model Plugin."""
    def __init__(self, sourceObject=None):
        IVADragModelPlugin.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVADragModelPlugin._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVADragModelPlugin._get_property(self, attrname) is not None: found_prop = IVADragModelPlugin._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VADragModelPlugin.")
        
agcls.AgClassCatalog.add_catalog_entry("{C48CB2A8-A6E1-4E7B-ABB2-179D1E06D541}", VADragModelPlugin)


class VASRPReflectionPlugin(IVASRPReflectionPlugin, IComponentInfo, ICloneable):
    """SRP Reflection Plugin."""
    def __init__(self, sourceObject=None):
        IVASRPReflectionPlugin.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVASRPReflectionPlugin._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVASRPReflectionPlugin._get_property(self, attrname) is not None: found_prop = IVASRPReflectionPlugin._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VASRPReflectionPlugin.")
        
agcls.AgClassCatalog.add_catalog_entry("{926296A2-EA6B-4FC8-A75C-15B9F24B85E5}", VASRPReflectionPlugin)


class VAEngineConstAcc(IVAEngineConstAcc, IComponentInfo, ICloneable):
    """Constant Acceleration engine model."""
    def __init__(self, sourceObject=None):
        IVAEngineConstAcc.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAEngineConstAcc._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAEngineConstAcc._get_property(self, attrname) is not None: found_prop = IVAEngineConstAcc._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAEngineConstAcc.")
        
agcls.AgClassCatalog.add_catalog_entry("{359488A0-BCA3-4739-8614-E99B675553AF}", VAEngineConstAcc)


class VAEngineConstant(IVAEngineConstant, IComponentInfo, ICloneable):
    """Constant Thrust engine model."""
    def __init__(self, sourceObject=None):
        IVAEngineConstant.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAEngineConstant._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAEngineConstant._get_property(self, attrname) is not None: found_prop = IVAEngineConstant._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAEngineConstant.")
        
agcls.AgClassCatalog.add_catalog_entry("{31105070-4B5A-4870-A45B-6F6CF13042DD}", VAEngineConstant)


class VAEngineIon(IVAEngineIon, IComponentInfo, ICloneable):
    """Ion Engine engine model."""
    def __init__(self, sourceObject=None):
        IVAEngineIon.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAEngineIon._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAEngineIon._get_property(self, attrname) is not None: found_prop = IVAEngineIon._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAEngineIon.")
        
agcls.AgClassCatalog.add_catalog_entry("{6AD7EC4F-2E59-4D7B-9FC2-9022CB8540B6}", VAEngineIon)


class VAEngineThrottleTable(IVAEngineThrottleTable, IComponentInfo, ICloneable):
    """Throttle Table engine model."""
    def __init__(self, sourceObject=None):
        IVAEngineThrottleTable.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAEngineThrottleTable._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAEngineThrottleTable._get_property(self, attrname) is not None: found_prop = IVAEngineThrottleTable._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAEngineThrottleTable.")
        
agcls.AgClassCatalog.add_catalog_entry("{FB947497-4C0D-4F39-9942-31A9A0D3025F}", VAEngineThrottleTable)


class VAEngineCustom(IVAEngineCustom, IComponentInfo, ICloneable):
    """Custom engine model."""
    def __init__(self, sourceObject=None):
        IVAEngineCustom.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAEngineCustom._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAEngineCustom._get_property(self, attrname) is not None: found_prop = IVAEngineCustom._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAEngineCustom.")
        
agcls.AgClassCatalog.add_catalog_entry("{5C0367CE-254E-4BDB-8056-ED27D584258E}", VAEngineCustom)


class VAEnginePlugin(IVAEnginePlugin, IComponentInfo, ICloneable):
    """Plugin engine model."""
    def __init__(self, sourceObject=None):
        IVAEnginePlugin.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAEnginePlugin._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAEnginePlugin._get_property(self, attrname) is not None: found_prop = IVAEnginePlugin._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAEnginePlugin.")
        
agcls.AgClassCatalog.add_catalog_entry("{D7755FC3-1A9F-4DB5-B735-030256F4AE24}", VAEnginePlugin)


class VAEngineModelPoly(IVAEngineModelPoly, IComponentInfo, ICloneable):
    """Polynomial Thrust and Isp engine model."""
    def __init__(self, sourceObject=None):
        IVAEngineModelPoly.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAEngineModelPoly._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAEngineModelPoly._get_property(self, attrname) is not None: found_prop = IVAEngineModelPoly._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAEngineModelPoly.")
        
agcls.AgClassCatalog.add_catalog_entry("{0D23F634-A8B8-4376-99AE-F8287C267EDC}", VAEngineModelPoly)


class VAEngineModelThrustCoefficients(IVAEngineModelThrustCoefficients):
    """Engine Model Thrust Coefficients."""
    def __init__(self, sourceObject=None):
        IVAEngineModelThrustCoefficients.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAEngineModelThrustCoefficients._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAEngineModelThrustCoefficients._get_property(self, attrname) is not None: found_prop = IVAEngineModelThrustCoefficients._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAEngineModelThrustCoefficients.")
        
agcls.AgClassCatalog.add_catalog_entry("{1B8E6E69-F100-4A4B-A24A-FFC3C8B0AF70}", VAEngineModelThrustCoefficients)


class VAEngineModelIspCoefficients(IVAEngineModelIspCoefficients):
    """Engine Model Isp Coefficients."""
    def __init__(self, sourceObject=None):
        IVAEngineModelIspCoefficients.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAEngineModelIspCoefficients._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAEngineModelIspCoefficients._get_property(self, attrname) is not None: found_prop = IVAEngineModelIspCoefficients._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAEngineModelIspCoefficients.")
        
agcls.AgClassCatalog.add_catalog_entry("{279B11AE-A5F8-4548-9401-95981B21C61C}", VAEngineModelIspCoefficients)


class VAEngineDefinition(IVAEngineDefinition):
    """Engine definition."""
    def __init__(self, sourceObject=None):
        IVAEngineDefinition.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAEngineDefinition._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAEngineDefinition._get_property(self, attrname) is not None: found_prop = IVAEngineDefinition._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAEngineDefinition.")
        
agcls.AgClassCatalog.add_catalog_entry("{F87429C7-51DC-4AD8-8481-468C14F38AB4}", VAEngineDefinition)


class VAThruster(IVAThruster):
    """Thruster definition."""
    def __init__(self, sourceObject=None):
        IVAThruster.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAThruster._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAThruster._get_property(self, attrname) is not None: found_prop = IVAThruster._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAThruster.")
        
agcls.AgClassCatalog.add_catalog_entry("{749FEA15-5BD9-4466-BADF-E917D640E6D8}", VAThruster)


class VAThrusterSetCollection(IVAThrusterSetCollection):
    """Thruster Set Collection."""
    def __init__(self, sourceObject=None):
        IVAThrusterSetCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAThrusterSetCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAThrusterSetCollection._get_property(self, attrname) is not None: found_prop = IVAThrusterSetCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAThrusterSetCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{8C1B379E-8092-48BE-A401-651464239B27}", VAThrusterSetCollection)


class VAThrusterSet(IVAThrusterSet, IComponentInfo, ICloneable):
    """Thruster Set."""
    def __init__(self, sourceObject=None):
        IVAThrusterSet.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAThrusterSet._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAThrusterSet._get_property(self, attrname) is not None: found_prop = IVAThrusterSet._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAThrusterSet.")
        
agcls.AgClassCatalog.add_catalog_entry("{00FB61C4-5A63-439B-A030-171588D7CFED}", VAThrusterSet)


class VAAsTriggerCondition(IVAAsTriggerCondition, IComponentInfo, ICloneable):
    """Constraint."""
    def __init__(self, sourceObject=None):
        IVAAsTriggerCondition.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAAsTriggerCondition._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAAsTriggerCondition._get_property(self, attrname) is not None: found_prop = IVAAsTriggerCondition._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAAsTriggerCondition.")
        
agcls.AgClassCatalog.add_catalog_entry("{32E146B0-C168-4BD3-A2D9-ECF7096687E5}", VAAsTriggerCondition)


class VACustomFunctionScriptEngine(IVACustomFunctionScriptEngine, IComponentInfo, ICloneable):
    """Custom Function Script Engine."""
    def __init__(self, sourceObject=None):
        IVACustomFunctionScriptEngine.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVACustomFunctionScriptEngine._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVACustomFunctionScriptEngine._get_property(self, attrname) is not None: found_prop = IVACustomFunctionScriptEngine._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VACustomFunctionScriptEngine.")
        
agcls.AgClassCatalog.add_catalog_entry("{F4CD79CC-CFAA-4EEE-A01A-0F846D6F6674}", VACustomFunctionScriptEngine)


class VANumericalPropagatorWrapper(IVANumericalPropagatorWrapper, IComponentInfo, ICloneable):
    """Numerical Propagator."""
    def __init__(self, sourceObject=None):
        IVANumericalPropagatorWrapper.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVANumericalPropagatorWrapper._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVANumericalPropagatorWrapper._get_property(self, attrname) is not None: found_prop = IVANumericalPropagatorWrapper._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VANumericalPropagatorWrapper.")
        
agcls.AgClassCatalog.add_catalog_entry("{6F733B37-D5A3-4D83-844B-34A35BA937CC}", VANumericalPropagatorWrapper)


class VANumericalPropagatorWrapperCR3BP(IVANumericalPropagatorWrapperCR3BP, IComponentInfo, ICloneable):
    """Numerical CR3BP Propagator."""
    def __init__(self, sourceObject=None):
        IVANumericalPropagatorWrapperCR3BP.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVANumericalPropagatorWrapperCR3BP._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVANumericalPropagatorWrapperCR3BP._get_property(self, attrname) is not None: found_prop = IVANumericalPropagatorWrapperCR3BP._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VANumericalPropagatorWrapperCR3BP.")
        
agcls.AgClassCatalog.add_catalog_entry("{C4823BEE-E898-47D3-8C29-9CCE6DB490FE}", VANumericalPropagatorWrapperCR3BP)


class VAPropagatorFunctionCollection(IVAPropagatorFunctionCollection):
    """Propagator Function Collection."""
    def __init__(self, sourceObject=None):
        IVAPropagatorFunctionCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAPropagatorFunctionCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAPropagatorFunctionCollection._get_property(self, attrname) is not None: found_prop = IVAPropagatorFunctionCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAPropagatorFunctionCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{41440862-0DA5-41B0-9A84-073FBC64D47A}", VAPropagatorFunctionCollection)


class VABulirschStoerIntegrator(IVABulirschStoerIntegrator, IVANumericalIntegrator):
    """Bulirsch-Stoer Numerical Integrator."""
    def __init__(self, sourceObject=None):
        IVABulirschStoerIntegrator.__init__(self, sourceObject)
        IVANumericalIntegrator.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVABulirschStoerIntegrator._private_init(self, pUnk)
        IVANumericalIntegrator._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVABulirschStoerIntegrator._get_property(self, attrname) is not None: found_prop = IVABulirschStoerIntegrator._get_property(self, attrname)
        if IVANumericalIntegrator._get_property(self, attrname) is not None: found_prop = IVANumericalIntegrator._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VABulirschStoerIntegrator.")
        
agcls.AgClassCatalog.add_catalog_entry("{B98456C5-48DE-41AB-867B-FD713A325418}", VABulirschStoerIntegrator)


class VAGaussJacksonIntegrator(IVAGaussJacksonIntegrator, IVANumericalIntegrator):
    """Gauss-Jackson Numerical Integrator."""
    def __init__(self, sourceObject=None):
        IVAGaussJacksonIntegrator.__init__(self, sourceObject)
        IVANumericalIntegrator.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAGaussJacksonIntegrator._private_init(self, pUnk)
        IVANumericalIntegrator._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAGaussJacksonIntegrator._get_property(self, attrname) is not None: found_prop = IVAGaussJacksonIntegrator._get_property(self, attrname)
        if IVANumericalIntegrator._get_property(self, attrname) is not None: found_prop = IVANumericalIntegrator._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAGaussJacksonIntegrator.")
        
agcls.AgClassCatalog.add_catalog_entry("{034F55EC-4D6E-4C22-9811-C3DEBC83ABD9}", VAGaussJacksonIntegrator)


class VARK2nd3rd(IVARK2nd3rd, IVANumericalIntegrator):
    """RK2nd3rd Numerical Integrator."""
    def __init__(self, sourceObject=None):
        IVARK2nd3rd.__init__(self, sourceObject)
        IVANumericalIntegrator.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVARK2nd3rd._private_init(self, pUnk)
        IVANumericalIntegrator._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVARK2nd3rd._get_property(self, attrname) is not None: found_prop = IVARK2nd3rd._get_property(self, attrname)
        if IVANumericalIntegrator._get_property(self, attrname) is not None: found_prop = IVANumericalIntegrator._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VARK2nd3rd.")
        
agcls.AgClassCatalog.add_catalog_entry("{F3511C10-B4F1-4592-81AC-41D387A9589B}", VARK2nd3rd)


class VARK4th(IVARK4th, IVANumericalIntegrator):
    """RK4th Numerical Integrator."""
    def __init__(self, sourceObject=None):
        IVARK4th.__init__(self, sourceObject)
        IVANumericalIntegrator.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVARK4th._private_init(self, pUnk)
        IVANumericalIntegrator._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVARK4th._get_property(self, attrname) is not None: found_prop = IVARK4th._get_property(self, attrname)
        if IVANumericalIntegrator._get_property(self, attrname) is not None: found_prop = IVANumericalIntegrator._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VARK4th.")
        
agcls.AgClassCatalog.add_catalog_entry("{019C798B-5AB2-42F1-847E-AC64438C8341}", VARK4th)


class VARK4th5th(IVARK4th5th, IVANumericalIntegrator):
    """RK4th5th Numerical Integrator."""
    def __init__(self, sourceObject=None):
        IVARK4th5th.__init__(self, sourceObject)
        IVANumericalIntegrator.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVARK4th5th._private_init(self, pUnk)
        IVANumericalIntegrator._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVARK4th5th._get_property(self, attrname) is not None: found_prop = IVARK4th5th._get_property(self, attrname)
        if IVANumericalIntegrator._get_property(self, attrname) is not None: found_prop = IVANumericalIntegrator._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VARK4th5th.")
        
agcls.AgClassCatalog.add_catalog_entry("{25B6537D-FF33-45E7-A314-F6E4EFA34CD5}", VARK4th5th)


class VARK4thAdapt(IVARK4thAdapt, IVANumericalIntegrator):
    """RK4thAdapt Numerical Integrator."""
    def __init__(self, sourceObject=None):
        IVARK4thAdapt.__init__(self, sourceObject)
        IVANumericalIntegrator.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVARK4thAdapt._private_init(self, pUnk)
        IVANumericalIntegrator._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVARK4thAdapt._get_property(self, attrname) is not None: found_prop = IVARK4thAdapt._get_property(self, attrname)
        if IVANumericalIntegrator._get_property(self, attrname) is not None: found_prop = IVANumericalIntegrator._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VARK4thAdapt.")
        
agcls.AgClassCatalog.add_catalog_entry("{03F69912-84E6-4209-8AF5-FD2C4B009C44}", VARK4thAdapt)


class VARKF7th8th(IVARKF7th8th, IVANumericalIntegrator):
    """RKF7th8th Numerical Integrator."""
    def __init__(self, sourceObject=None):
        IVARKF7th8th.__init__(self, sourceObject)
        IVANumericalIntegrator.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVARKF7th8th._private_init(self, pUnk)
        IVANumericalIntegrator._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVARKF7th8th._get_property(self, attrname) is not None: found_prop = IVARKF7th8th._get_property(self, attrname)
        if IVANumericalIntegrator._get_property(self, attrname) is not None: found_prop = IVANumericalIntegrator._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VARKF7th8th.")
        
agcls.AgClassCatalog.add_catalog_entry("{78A98F0E-B687-4D64-B0F6-5608105504CC}", VARKF7th8th)


class VARKV8th9th(IVARKV8th9th, IVANumericalIntegrator):
    """RKV8th9th Numerical Integrator."""
    def __init__(self, sourceObject=None):
        IVARKV8th9th.__init__(self, sourceObject)
        IVANumericalIntegrator.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVARKV8th9th._private_init(self, pUnk)
        IVANumericalIntegrator._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVARKV8th9th._get_property(self, attrname) is not None: found_prop = IVARKV8th9th._get_property(self, attrname)
        if IVANumericalIntegrator._get_property(self, attrname) is not None: found_prop = IVANumericalIntegrator._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VARKV8th9th.")
        
agcls.AgClassCatalog.add_catalog_entry("{26857B4B-40C9-4EC2-B5F7-AFEB6103128D}", VARKV8th9th)


class VAScriptingTool(IVAScriptingTool, IRuntimeTypeInfoProvider):
    """Scripting Tool."""
    def __init__(self, sourceObject=None):
        IVAScriptingTool.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAScriptingTool._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAScriptingTool._get_property(self, attrname) is not None: found_prop = IVAScriptingTool._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAScriptingTool.")
        
agcls.AgClassCatalog.add_catalog_entry("{1FB508B7-F4D9-4ABF-8EA8-B44AECAEE9C0}", VAScriptingTool)


class VAScriptingSegmentCollection(IVAScriptingSegmentCollection, IRuntimeTypeInfoProvider):
    """Scripting Segment Collection."""
    def __init__(self, sourceObject=None):
        IVAScriptingSegmentCollection.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAScriptingSegmentCollection._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAScriptingSegmentCollection._get_property(self, attrname) is not None: found_prop = IVAScriptingSegmentCollection._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAScriptingSegmentCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{2D397364-3CD3-4FC2-8B11-D74D7A348687}", VAScriptingSegmentCollection)


class VAScriptingSegment(IVAScriptingSegment, IRuntimeTypeInfoProvider):
    """Scripting Segment."""
    def __init__(self, sourceObject=None):
        IVAScriptingSegment.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAScriptingSegment._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAScriptingSegment._get_property(self, attrname) is not None: found_prop = IVAScriptingSegment._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAScriptingSegment.")
        
agcls.AgClassCatalog.add_catalog_entry("{FD68184D-BA0A-41EC-B03E-E63514058625}", VAScriptingSegment)


class VAScriptingParameterCollection(IVAScriptingParameterCollection, IRuntimeTypeInfoProvider):
    """Scripting Parameter Collection."""
    def __init__(self, sourceObject=None):
        IVAScriptingParameterCollection.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAScriptingParameterCollection._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAScriptingParameterCollection._get_property(self, attrname) is not None: found_prop = IVAScriptingParameterCollection._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAScriptingParameterCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{F7B45439-8E25-43DE-882F-844F8645F015}", VAScriptingParameterCollection)


class VAScriptingParameter(IVAScriptingParameter, IRuntimeTypeInfoProvider):
    """Scripting Parameter."""
    def __init__(self, sourceObject=None):
        IVAScriptingParameter.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAScriptingParameter._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAScriptingParameter._get_property(self, attrname) is not None: found_prop = IVAScriptingParameter._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAScriptingParameter.")
        
agcls.AgClassCatalog.add_catalog_entry("{92BFA902-938E-48E0-B402-C6DEE9169BEE}", VAScriptingParameter)


class VAScriptingCalcObject(IVAScriptingCalcObject):
    """Calc Object."""
    def __init__(self, sourceObject=None):
        IVAScriptingCalcObject.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAScriptingCalcObject._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAScriptingCalcObject._get_property(self, attrname) is not None: found_prop = IVAScriptingCalcObject._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAScriptingCalcObject.")
        
agcls.AgClassCatalog.add_catalog_entry("{D9895635-D8A5-497F-9C4D-E0A18AF49983}", VAScriptingCalcObject)


class VAScriptingCalcObjectCollection(IVAScriptingCalcObjectCollection):
    """Calc Object Collection."""
    def __init__(self, sourceObject=None):
        IVAScriptingCalcObjectCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAScriptingCalcObjectCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAScriptingCalcObjectCollection._get_property(self, attrname) is not None: found_prop = IVAScriptingCalcObjectCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAScriptingCalcObjectCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{9FC08736-F254-451E-9292-C003D5601780}", VAScriptingCalcObjectCollection)


class VAUserVariableDefinition(IVAUserVariableDefinition):
    """User Variable Definition"""
    def __init__(self, sourceObject=None):
        IVAUserVariableDefinition.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAUserVariableDefinition._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAUserVariableDefinition._get_property(self, attrname) is not None: found_prop = IVAUserVariableDefinition._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAUserVariableDefinition.")
        
agcls.AgClassCatalog.add_catalog_entry("{659E4C4D-E224-47D7-A899-C9B5DCF7241F}", VAUserVariableDefinition)


class VAUserVariable(IVAUserVariable):
    """User Variable"""
    def __init__(self, sourceObject=None):
        IVAUserVariable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAUserVariable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAUserVariable._get_property(self, attrname) is not None: found_prop = IVAUserVariable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAUserVariable.")
        
agcls.AgClassCatalog.add_catalog_entry("{437599F8-0E00-4984-81CA-B450200257BC}", VAUserVariable)


class VAUserVariableUpdate(IVAUserVariableUpdate):
    """User Variable Update"""
    def __init__(self, sourceObject=None):
        IVAUserVariableUpdate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAUserVariableUpdate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAUserVariableUpdate._get_property(self, attrname) is not None: found_prop = IVAUserVariableUpdate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAUserVariableUpdate.")
        
agcls.AgClassCatalog.add_catalog_entry("{EB1FC76A-82D7-43C1-919B-05F53CEFC2ED}", VAUserVariableUpdate)


class VAUserVariableDefinitionCollection(IVAUserVariableDefinitionCollection):
    """User Variable Definition Collection."""
    def __init__(self, sourceObject=None):
        IVAUserVariableDefinitionCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAUserVariableDefinitionCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAUserVariableDefinitionCollection._get_property(self, attrname) is not None: found_prop = IVAUserVariableDefinitionCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAUserVariableDefinitionCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{E1D09185-E7EC-4E3F-BFEF-52AC92FEEC75}", VAUserVariableDefinitionCollection)


class VAUserVariableCollection(IVAUserVariableCollection):
    """User Variable Initial Value Collection."""
    def __init__(self, sourceObject=None):
        IVAUserVariableCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAUserVariableCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAUserVariableCollection._get_property(self, attrname) is not None: found_prop = IVAUserVariableCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAUserVariableCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{801C61FA-C0FE-4BFD-8001-3335211F7328}", VAUserVariableCollection)


class VAUserVariableUpdateCollection(IVAUserVariableUpdateCollection):
    """User Variable Update Collection"""
    def __init__(self, sourceObject=None):
        IVAUserVariableUpdateCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAUserVariableUpdateCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAUserVariableUpdateCollection._get_property(self, attrname) is not None: found_prop = IVAUserVariableUpdateCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAUserVariableUpdateCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{FD7D6D39-4E5B-41E1-84E2-CBCAE8ECCF41}", VAUserVariableUpdateCollection)


class VACalculationGraphCollection(IVACalculationGraphCollection):
    """Calculation Graph Collection."""
    def __init__(self, sourceObject=None):
        IVACalculationGraphCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVACalculationGraphCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVACalculationGraphCollection._get_property(self, attrname) is not None: found_prop = IVACalculationGraphCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VACalculationGraphCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{40E20BE7-7961-468B-B396-8F6E980BE49E}", VACalculationGraphCollection)


class VAScriptingParameterEnumerationChoice(IVAScriptingParameterEnumerationChoice, IRuntimeTypeInfoProvider):
    """Scripting Parameter Enumeration Choice."""
    def __init__(self, sourceObject=None):
        IVAScriptingParameterEnumerationChoice.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAScriptingParameterEnumerationChoice._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAScriptingParameterEnumerationChoice._get_property(self, attrname) is not None: found_prop = IVAScriptingParameterEnumerationChoice._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAScriptingParameterEnumerationChoice.")
        
agcls.AgClassCatalog.add_catalog_entry("{82A982C2-A2AD-4FD8-AB46-A54866F56AEA}", VAScriptingParameterEnumerationChoice)


class VAScriptingParameterEnumerationChoiceCollection(IVAScriptingParameterEnumerationChoiceCollection, IRuntimeTypeInfoProvider):
    """Scripting Parameter Enumeration Choice Collection"""
    def __init__(self, sourceObject=None):
        IVAScriptingParameterEnumerationChoiceCollection.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAScriptingParameterEnumerationChoiceCollection._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAScriptingParameterEnumerationChoiceCollection._get_property(self, attrname) is not None: found_prop = IVAScriptingParameterEnumerationChoiceCollection._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAScriptingParameterEnumerationChoiceCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{E4F13182-12CE-420B-AC3A-8530CC46BE35}", VAScriptingParameterEnumerationChoiceCollection)


class VAProfileSNOPTOptimizer(IVAProfileSNOPTOptimizer, IVAProfile, IRuntimeTypeInfoProvider):
    """SNOPT optimizer profile"""
    def __init__(self, sourceObject=None):
        IVAProfileSNOPTOptimizer.__init__(self, sourceObject)
        IVAProfile.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAProfileSNOPTOptimizer._private_init(self, pUnk)
        IVAProfile._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAProfileSNOPTOptimizer._get_property(self, attrname) is not None: found_prop = IVAProfileSNOPTOptimizer._get_property(self, attrname)
        if IVAProfile._get_property(self, attrname) is not None: found_prop = IVAProfile._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAProfileSNOPTOptimizer.")
        
agcls.AgClassCatalog.add_catalog_entry("{6F7AFA8D-FC45-4955-BEFB-BDE94553C02E}", VAProfileSNOPTOptimizer)


class VASNOPTControl(IVASNOPTControl):
    """Control parameters for SNOPT optimizer profile"""
    def __init__(self, sourceObject=None):
        IVASNOPTControl.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVASNOPTControl._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVASNOPTControl._get_property(self, attrname) is not None: found_prop = IVASNOPTControl._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VASNOPTControl.")
        
agcls.AgClassCatalog.add_catalog_entry("{5CD8E3EB-8BCA-4D53-A361-484285E62C96}", VASNOPTControl)


class VASNOPTResult(IVASNOPTResult):
    """Properties for objecvtive and constraints of a SNOPT profile."""
    def __init__(self, sourceObject=None):
        IVASNOPTResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVASNOPTResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVASNOPTResult._get_property(self, attrname) is not None: found_prop = IVASNOPTResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VASNOPTResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{F739575C-EF90-4B58-917A-BD0C12C95055}", VASNOPTResult)


class VASNOPTControlCollection(IVASNOPTControlCollection):
    """Properties for the list of SNOPT control parameters."""
    def __init__(self, sourceObject=None):
        IVASNOPTControlCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVASNOPTControlCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVASNOPTControlCollection._get_property(self, attrname) is not None: found_prop = IVASNOPTControlCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VASNOPTControlCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{99EECA52-DE6C-4E2C-805E-725A3A009E4B}", VASNOPTControlCollection)


class VASNOPTResultCollection(IVASNOPTResultCollection):
    """SNOPT result collection."""
    def __init__(self, sourceObject=None):
        IVASNOPTResultCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVASNOPTResultCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVASNOPTResultCollection._get_property(self, attrname) is not None: found_prop = IVASNOPTResultCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VASNOPTResultCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{D27CBF33-3EC4-40A0-A138-5F41720B0B08}", VASNOPTResultCollection)


class VAProfileIPOPTOptimizer(IVAProfileIPOPTOptimizer, IVAProfile, IRuntimeTypeInfoProvider):
    """IPOPT optimizer profile"""
    def __init__(self, sourceObject=None):
        IVAProfileIPOPTOptimizer.__init__(self, sourceObject)
        IVAProfile.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAProfileIPOPTOptimizer._private_init(self, pUnk)
        IVAProfile._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAProfileIPOPTOptimizer._get_property(self, attrname) is not None: found_prop = IVAProfileIPOPTOptimizer._get_property(self, attrname)
        if IVAProfile._get_property(self, attrname) is not None: found_prop = IVAProfile._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAProfileIPOPTOptimizer.")
        
agcls.AgClassCatalog.add_catalog_entry("{59AB8108-2D2E-4D46-8B96-F1F43175CC77}", VAProfileIPOPTOptimizer)


class VAIPOPTControl(IVAIPOPTControl):
    """Control parameters for IPOPT optimizer profile"""
    def __init__(self, sourceObject=None):
        IVAIPOPTControl.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAIPOPTControl._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAIPOPTControl._get_property(self, attrname) is not None: found_prop = IVAIPOPTControl._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAIPOPTControl.")
        
agcls.AgClassCatalog.add_catalog_entry("{F7FF56DA-D284-4B28-88EC-BEE49D7E0CFD}", VAIPOPTControl)


class VAIPOPTResult(IVAIPOPTResult):
    """Properties for objecvtive and constraints of a IPOPT profile."""
    def __init__(self, sourceObject=None):
        IVAIPOPTResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAIPOPTResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAIPOPTResult._get_property(self, attrname) is not None: found_prop = IVAIPOPTResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAIPOPTResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{DCFD15D6-9ACF-4FCB-B968-CB74B5E95B33}", VAIPOPTResult)


class VAIPOPTControlCollection(IVAIPOPTControlCollection):
    """Properties for the list of IPOPT control parameters."""
    def __init__(self, sourceObject=None):
        IVAIPOPTControlCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAIPOPTControlCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAIPOPTControlCollection._get_property(self, attrname) is not None: found_prop = IVAIPOPTControlCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAIPOPTControlCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{522C81BC-6FFF-40FE-90C7-E4368FD1548D}", VAIPOPTControlCollection)


class VAIPOPTResultCollection(IVAIPOPTResultCollection):
    """IPOPT result collection."""
    def __init__(self, sourceObject=None):
        IVAIPOPTResultCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAIPOPTResultCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAIPOPTResultCollection._get_property(self, attrname) is not None: found_prop = IVAIPOPTResultCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAIPOPTResultCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{4A10E1B9-87A1-4370-AAD8-F7856B099B5C}", VAIPOPTResultCollection)


class VAManeuverOptimalFinite(IVAManeuverOptimalFinite, IVAManeuver, IRuntimeTypeInfoProvider):
    """The Optimal Finite Maneuver."""
    def __init__(self, sourceObject=None):
        IVAManeuverOptimalFinite.__init__(self, sourceObject)
        IVAManeuver.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAManeuverOptimalFinite._private_init(self, pUnk)
        IVAManeuver._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAManeuverOptimalFinite._get_property(self, attrname) is not None: found_prop = IVAManeuverOptimalFinite._get_property(self, attrname)
        if IVAManeuver._get_property(self, attrname) is not None: found_prop = IVAManeuver._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAManeuverOptimalFinite.")
        
agcls.AgClassCatalog.add_catalog_entry("{6666593F-246D-4263-A0E4-78EFD0C04C7B}", VAManeuverOptimalFinite)


class VAManeuverOptimalFiniteSNOPTOptimizer(IVAManeuverOptimalFiniteSNOPTOptimizer):
    """Properties of SNOPT Optimizer options for optimal finite maneuver."""
    def __init__(self, sourceObject=None):
        IVAManeuverOptimalFiniteSNOPTOptimizer.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAManeuverOptimalFiniteSNOPTOptimizer._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAManeuverOptimalFiniteSNOPTOptimizer._get_property(self, attrname) is not None: found_prop = IVAManeuverOptimalFiniteSNOPTOptimizer._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAManeuverOptimalFiniteSNOPTOptimizer.")
        
agcls.AgClassCatalog.add_catalog_entry("{54E41ADE-C090-4C19-8B09-94F5030260C6}", VAManeuverOptimalFiniteSNOPTOptimizer)


class VAManeuverOptimalFiniteInitialBoundaryConditions(IVAManeuverOptimalFiniteInitialBoundaryConditions):
    """Properties of initial boundary conditions for optimal finite maneuver."""
    def __init__(self, sourceObject=None):
        IVAManeuverOptimalFiniteInitialBoundaryConditions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAManeuverOptimalFiniteInitialBoundaryConditions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAManeuverOptimalFiniteInitialBoundaryConditions._get_property(self, attrname) is not None: found_prop = IVAManeuverOptimalFiniteInitialBoundaryConditions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAManeuverOptimalFiniteInitialBoundaryConditions.")
        
agcls.AgClassCatalog.add_catalog_entry("{3A8835CC-D4EF-4AFE-B198-FC4992E17D6B}", VAManeuverOptimalFiniteInitialBoundaryConditions)


class VAManeuverOptimalFiniteFinalBoundaryConditions(IVAManeuverOptimalFiniteFinalBoundaryConditions):
    """Properties of final boundary conditions for optimal finite maneuver."""
    def __init__(self, sourceObject=None):
        IVAManeuverOptimalFiniteFinalBoundaryConditions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAManeuverOptimalFiniteFinalBoundaryConditions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAManeuverOptimalFiniteFinalBoundaryConditions._get_property(self, attrname) is not None: found_prop = IVAManeuverOptimalFiniteFinalBoundaryConditions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAManeuverOptimalFiniteFinalBoundaryConditions.")
        
agcls.AgClassCatalog.add_catalog_entry("{FF880BEA-2B6E-40ED-B7BC-85ED2367FC9C}", VAManeuverOptimalFiniteFinalBoundaryConditions)


class VAManeuverOptimalFinitePathBoundaryConditions(IVAManeuverOptimalFinitePathBoundaryConditions):
    """Properties of path boundary conditions for optimal finite maneuver."""
    def __init__(self, sourceObject=None):
        IVAManeuverOptimalFinitePathBoundaryConditions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAManeuverOptimalFinitePathBoundaryConditions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAManeuverOptimalFinitePathBoundaryConditions._get_property(self, attrname) is not None: found_prop = IVAManeuverOptimalFinitePathBoundaryConditions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAManeuverOptimalFinitePathBoundaryConditions.")
        
agcls.AgClassCatalog.add_catalog_entry("{C8E16C04-1A5A-43F9-B770-A67666512F8A}", VAManeuverOptimalFinitePathBoundaryConditions)


class VAManeuverOptimalFiniteSteeringNodeElement(IVAManeuverOptimalFiniteSteeringNodeElement):
    """The elements of the steering node."""
    def __init__(self, sourceObject=None):
        IVAManeuverOptimalFiniteSteeringNodeElement.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAManeuverOptimalFiniteSteeringNodeElement._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAManeuverOptimalFiniteSteeringNodeElement._get_property(self, attrname) is not None: found_prop = IVAManeuverOptimalFiniteSteeringNodeElement._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAManeuverOptimalFiniteSteeringNodeElement.")
        
agcls.AgClassCatalog.add_catalog_entry("{AE276E86-B321-4F0D-B657-852143B3F3EE}", VAManeuverOptimalFiniteSteeringNodeElement)


class VAManeuverOptimalFiniteSteeringNodeCollection(IVAManeuverOptimalFiniteSteeringNodeCollection):
    """Steering/nodes collection."""
    def __init__(self, sourceObject=None):
        IVAManeuverOptimalFiniteSteeringNodeCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAManeuverOptimalFiniteSteeringNodeCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAManeuverOptimalFiniteSteeringNodeCollection._get_property(self, attrname) is not None: found_prop = IVAManeuverOptimalFiniteSteeringNodeCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAManeuverOptimalFiniteSteeringNodeCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{23249624-8EFC-4AD8-9E67-A564A49D2D67}", VAManeuverOptimalFiniteSteeringNodeCollection)


class VAManeuverOptimalFiniteBounds(IVAManeuverOptimalFiniteBounds):
    """The elements of the steering node."""
    def __init__(self, sourceObject=None):
        IVAManeuverOptimalFiniteBounds.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAManeuverOptimalFiniteBounds._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAManeuverOptimalFiniteBounds._get_property(self, attrname) is not None: found_prop = IVAManeuverOptimalFiniteBounds._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAManeuverOptimalFiniteBounds.")
        
agcls.AgClassCatalog.add_catalog_entry("{0F56E447-2391-476B-863C-8B8596486F03}", VAManeuverOptimalFiniteBounds)


class VAProfileLambertProfile(IVAProfileLambertProfile, IVAProfile, IRuntimeTypeInfoProvider):
    """The Lambert profile."""
    def __init__(self, sourceObject=None):
        IVAProfileLambertProfile.__init__(self, sourceObject)
        IVAProfile.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAProfileLambertProfile._private_init(self, pUnk)
        IVAProfile._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAProfileLambertProfile._get_property(self, attrname) is not None: found_prop = IVAProfileLambertProfile._get_property(self, attrname)
        if IVAProfile._get_property(self, attrname) is not None: found_prop = IVAProfile._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAProfileLambertProfile.")
        
agcls.AgClassCatalog.add_catalog_entry("{3FA3162E-C38E-46D8-8F7C-B8421110EEB2}", VAProfileLambertProfile)


class VAProfileLambertSearchProfile(IVAProfileLambertSearchProfile, IVAProfile, IRuntimeTypeInfoProvider):
    """The Lambert profile."""
    def __init__(self, sourceObject=None):
        IVAProfileLambertSearchProfile.__init__(self, sourceObject)
        IVAProfile.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAProfileLambertSearchProfile._private_init(self, pUnk)
        IVAProfile._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAProfileLambertSearchProfile._get_property(self, attrname) is not None: found_prop = IVAProfileLambertSearchProfile._get_property(self, attrname)
        if IVAProfile._get_property(self, attrname) is not None: found_prop = IVAProfile._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAProfileLambertSearchProfile.")
        
agcls.AgClassCatalog.add_catalog_entry("{9E98EFA2-5913-4BFA-8293-C294B80DFD4E}", VAProfileLambertSearchProfile)


class VAProfileGoldenSection(IVAProfileGoldenSection, IVAProfile, IRuntimeTypeInfoProvider):
    """The Golden Section profile."""
    def __init__(self, sourceObject=None):
        IVAProfileGoldenSection.__init__(self, sourceObject)
        IVAProfile.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAProfileGoldenSection._private_init(self, pUnk)
        IVAProfile._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAProfileGoldenSection._get_property(self, attrname) is not None: found_prop = IVAProfileGoldenSection._get_property(self, attrname)
        if IVAProfile._get_property(self, attrname) is not None: found_prop = IVAProfile._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAProfileGoldenSection.")
        
agcls.AgClassCatalog.add_catalog_entry("{8A0E8056-D72B-4C82-85F0-945A96AC4E2E}", VAProfileGoldenSection)


class VAGoldenSectionControlCollection(IVAGoldenSectionControlCollection):
    """Properties for the list of Golden Section control parameters."""
    def __init__(self, sourceObject=None):
        IVAGoldenSectionControlCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAGoldenSectionControlCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAGoldenSectionControlCollection._get_property(self, attrname) is not None: found_prop = IVAGoldenSectionControlCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAGoldenSectionControlCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{5E3FCD6D-E592-4610-9831-87D9ABD81889}", VAGoldenSectionControlCollection)


class VAGoldenSectionControl(IVAGoldenSectionControl):
    """Control parameters for Golden Section profile"""
    def __init__(self, sourceObject=None):
        IVAGoldenSectionControl.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAGoldenSectionControl._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAGoldenSectionControl._get_property(self, attrname) is not None: found_prop = IVAGoldenSectionControl._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAGoldenSectionControl.")
        
agcls.AgClassCatalog.add_catalog_entry("{00EBADDE-16F1-4FAC-8014-6952CBF0832E}", VAGoldenSectionControl)


class VAGoldenSectionResultCollection(IVAGoldenSectionResultCollection):
    """Properties for the list of Golden Section result parameters."""
    def __init__(self, sourceObject=None):
        IVAGoldenSectionResultCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAGoldenSectionResultCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAGoldenSectionResultCollection._get_property(self, attrname) is not None: found_prop = IVAGoldenSectionResultCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAGoldenSectionResultCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{72ADF8B9-9BE8-4112-B295-30B86DAF11F3}", VAGoldenSectionResultCollection)


class VAGoldenSectionResult(IVAGoldenSectionResult):
    """Result parameters for Golden Section profile"""
    def __init__(self, sourceObject=None):
        IVAGoldenSectionResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAGoldenSectionResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAGoldenSectionResult._get_property(self, attrname) is not None: found_prop = IVAGoldenSectionResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAGoldenSectionResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{A6F34FB1-1740-4EBB-B4FB-E6BB0B9EE427}", VAGoldenSectionResult)


class VAProfileGridSearch(IVAProfileGridSearch, IVAProfile, IRuntimeTypeInfoProvider):
    """The Grid Search profile."""
    def __init__(self, sourceObject=None):
        IVAProfileGridSearch.__init__(self, sourceObject)
        IVAProfile.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAProfileGridSearch._private_init(self, pUnk)
        IVAProfile._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAProfileGridSearch._get_property(self, attrname) is not None: found_prop = IVAProfileGridSearch._get_property(self, attrname)
        if IVAProfile._get_property(self, attrname) is not None: found_prop = IVAProfile._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAProfileGridSearch.")
        
agcls.AgClassCatalog.add_catalog_entry("{7C28EA98-702E-4CA9-8DE6-C49CEC2932E0}", VAProfileGridSearch)


class VAGridSearchControlCollection(IVAGridSearchControlCollection):
    """Properties for the list of Grid Search control parameters."""
    def __init__(self, sourceObject=None):
        IVAGridSearchControlCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAGridSearchControlCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAGridSearchControlCollection._get_property(self, attrname) is not None: found_prop = IVAGridSearchControlCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAGridSearchControlCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{0A1300B1-D35A-46C5-BE62-3AFB811157C5}", VAGridSearchControlCollection)


class VAGridSearchControl(IVAGridSearchControl):
    """Control parameters for Grid Search profile"""
    def __init__(self, sourceObject=None):
        IVAGridSearchControl.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAGridSearchControl._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAGridSearchControl._get_property(self, attrname) is not None: found_prop = IVAGridSearchControl._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAGridSearchControl.")
        
agcls.AgClassCatalog.add_catalog_entry("{DA10881F-2D20-41DF-88DD-F49F9A41BA76}", VAGridSearchControl)


class VAGridSearchResultCollection(IVAGridSearchResultCollection):
    """Properties for the list of Grid Search result parameters."""
    def __init__(self, sourceObject=None):
        IVAGridSearchResultCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAGridSearchResultCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAGridSearchResultCollection._get_property(self, attrname) is not None: found_prop = IVAGridSearchResultCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAGridSearchResultCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{E189AD76-0BE9-4922-8D76-3E28FAE74507}", VAGridSearchResultCollection)


class VAGridSearchResult(IVAGridSearchResult):
    """Result parameters for Grid Search profile"""
    def __init__(self, sourceObject=None):
        IVAGridSearchResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVAGridSearchResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVAGridSearchResult._get_property(self, attrname) is not None: found_prop = IVAGridSearchResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VAGridSearchResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{B37527F8-1781-4484-985E-4F2BE2E8810A}", VAGridSearchResult)


class VACalcObjectLinkEmbedControlCollection(IVACalcObjectLinkEmbedControlCollection):
    """The Calculation Object link/embed component folder."""
    def __init__(self, sourceObject=None):
        IVACalcObjectLinkEmbedControlCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVACalcObjectLinkEmbedControlCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVACalcObjectLinkEmbedControlCollection._get_property(self, attrname) is not None: found_prop = IVACalcObjectLinkEmbedControlCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VACalcObjectLinkEmbedControlCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{8EFFF2BC-B4AA-4F5E-BDF2-7218EBBE10FF}", VACalcObjectLinkEmbedControlCollection)



################################################################################
#          Copyright 2020-2020, Analytical Graphics, Inc.
################################################################################
