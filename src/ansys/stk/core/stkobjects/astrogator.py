################################################################################
#          Copyright 2020-2020, Analytical Graphics, Inc.
################################################################################ 

__all__ = ["AccessStoppingCondition", "AgEVAAccessCriterion", "AgEVAAscentType", "AgEVAAtmosDataSource", "AgEVAAttitudeControl", 
"AgEVAAttitudeUpdate", "AgEVABaseSelection", "AgEVABodyAxis", "AgEVABurnoutOptions", "AgEVABurnoutType", "AgEVACalcObjectAngleSign", 
"AgEVACalcObjectCentralBodyReference", "AgEVACalcObjectDirection", "AgEVACalcObjectElem", "AgEVACalcObjectLocationSource", 
"AgEVACalcObjectOrbitPlaneSource", "AgEVACalcObjectReference", "AgEVACalcObjectReferenceDirection", "AgEVACalcObjectReferenceEllipse", 
"AgEVACalcObjectRelativePosition", "AgEVACalcObjectSunPosition", "AgEVACbAttitude", "AgEVACbEphemeris", "AgEVACbGravityModel", 
"AgEVACbShape", "AgEVAClearEphemerisDirection", "AgEVACoeffRKV8th9th", "AgEVAComplexNumber", "AgEVAConstraintSign", "AgEVAControlAdvanced", 
"AgEVAControlEngineConstAcc", "AgEVAControlEngineConstant", "AgEVAControlEngineCustom", "AgEVAControlEngineIon", "AgEVAControlEngineModelPoly", 
"AgEVAControlEngineThrottleTable", "AgEVAControlFollow", "AgEVAControlInitState", "AgEVAControlLaunch", "AgEVAControlManeuver", 
"AgEVAControlOrbitStateValue", "AgEVAControlPowerInternal", "AgEVAControlPowerProcessed", "AgEVAControlPowerSolarArray", 
"AgEVAControlRepeatingGroundTrackErr", "AgEVAControlStoppingCondition", "AgEVAControlThrusters", "AgEVAControlUpdate", "AgEVAConvergenceCriteria", 
"AgEVACriteria", "AgEVACriterion", "AgEVACustomFunction", "AgEVADCScalingMethod", "AgEVADeriveCalcMethod", "AgEVADifferenceOrder", 
"AgEVADragModelType", "AgEVADrawPerturbation", "AgEVAEclipsingBodiesSource", "AgEVAElement", "AgEVAElementType", "AgEVAEngineModelFunction", 
"AgEVAEphemSource", "AgEVAErrorControl", "AgEVAFollowJoin", "AgEVAFollowSeparation", "AgEVAFollowSpacecraftAndFuelTank", 
"AgEVAFormulation", "AgEVAGeoMagneticFluxSource", "AgEVAGeoMagneticFluxUpdateRate", "AgEVAGeoStationaryDriftRateModel", 
"AgEVAGeoStationaryInclinationMag", "AgEVAGoldenSectionDesiredOperation", "AgEVAGraphOption", "AgEVAGravCoeffCoefficientType", 
"AgEVAGravCoeffNormalizationType", "AgEVAGravParamSource", "AgEVAGravitationalParameterSource", "AgEVAGridSearchDesiredOperation", 
"AgEVAIPOPTGoal", "AgEVAIdealOrbitRadius", "AgEVAImpDeltaVRep", "AgEVALambertDirectionOfMotionType", "AgEVALambertOrbitalEnergyType", 
"AgEVALambertSolutionOptionType", "AgEVALambertTargetCoordType", "AgEVALanguage", "AgEVALaunchDisplaySystem", "AgEVALightingCondition", 
"AgEVAManeuverType", "AgEVAMarsGRAMDensityType", "AgEVANumericalIntegrator", "AgEVAOptimalFiniteDiscretizationStrategy", 
"AgEVAOptimalFiniteExportNodesFormat", "AgEVAOptimalFiniteGuessMethod", "AgEVAOptimalFiniteRunMode", "AgEVAOptimalFiniteSNOPTObjective", 
"AgEVAOptimalFiniteSNOPTScaling", "AgEVAOptimalFiniteScalingOptions", "AgEVAOptimalFiniteSeedMethod", "AgEVAOptimalFiniteWorkingVariables", 
"AgEVAPredictorCorrector", "AgEVAPressureMode", "AgEVAProfile", "AgEVAProfileInsertDirection", "AgEVAProfileMode", "AgEVAProfilesFinish", 
"AgEVAPropulsionMethod", "AgEVAReferenceRadiusSource", "AgEVAReturnControl", "AgEVARootFindingAlgorithm", "AgEVARotatingCoordinateSystem", 
"AgEVARunCode", "AgEVASNOPTGoal", "AgEVASTMEigenNumber", "AgEVASTMPertVariables", "AgEVAScriptingParameterType", "AgEVASegmentDifferenceOrder", 
"AgEVASegmentState", "AgEVASegmentType", "AgEVASequenceStateToPass", "AgEVAShadowModel", "AgEVASmartRunMode", "AgEVASolarForceMethod", 
"AgEVASquaredType", "AgEVAState", "AgEVAStoppingCondition", "AgEVASunPosition", "AgEVATabVecInterpMethod", "AgEVATargetSeqAction", 
"AgEVAThirdBodyMode", "AgEVAThrottleTableOperationMode", "AgEVAThrustType", "AgEVAThrusterDirection", "AgEVAUpdateAction", 
"AgEVAUpdateParam", "AgEVAVenusGRAMDensityType", "AsTriggerCondition", "AstrogatorCentralBody", "AttitudeControlFiniteAntiVelocityVector", 
"AttitudeControlFiniteAttitude", "AttitudeControlFiniteFile", "AttitudeControlFinitePlugin", "AttitudeControlFiniteThrustVector", 
"AttitudeControlFiniteTimeVarying", "AttitudeControlFiniteVelocityVector", "AttitudeControlImpulsiveAntiVelocityVector", 
"AttitudeControlImpulsiveAttitude", "AttitudeControlImpulsiveFile", "AttitudeControlImpulsiveThrustVector", "AttitudeControlImpulsiveVelocityVector", 
"AttitudeControlOptimalFiniteLagrange", "AutomaticSequence", "AutomaticSequenceCollection", "BDotRCalc", "BDotTCalc", "BMagnitudeCalc", 
"BPlaneCollection", "BThetaCalc", "BisectionControl", "BisectionControlCollection", "BisectionResult", "BisectionResultCollection", 
"BlendedDensity", "BulirschStoerIntegrator", "BurnoutCBFCartesian", "BurnoutGeocentric", "BurnoutGeodetic", "BurnoutLaunchAzAltitude", 
"BurnoutLaunchAzRadius", "BurnoutVelocity", "CR3BPFunc", "CalcObjectCollection", "CalcObjectLinkEmbedControlCollection", 
"CalculationGraphCollection", "CentralBodyAttitudeIAU1994", "CentralBodyAttitudeRotationCoefficientsFile", "CentralBodyCollection", 
"CentralBodyEphemerisAnalyticOrbit", "CentralBodyEphemerisFile", "CentralBodyEphemerisJPLDesignExplorerOptimizer", "CentralBodyEphemerisJPLSpice", 
"CentralBodyEphemerisPlanetary", "CentralBodyGravityModel", "CentralBodyShapeOblateSpheroid", "CentralBodyShapeSphere", 
"CentralBodyShapeTriaxialEllipsoid", "Cira72Function", "ConstraintCollection", "CustomFunctionScriptEngine", "DTM2012", 
"DTM2020", "DensityModelPlugin", "DesignCR3BPObject", "DesignCR3BPObjectCollection", "DesignCR3BPSetup", "DifferentialCorrectorControl", 
"DifferentialCorrectorControlCollection", "DifferentialCorrectorResult", "DifferentialCorrectorResultCollection", "DisplaySystemGeocentric", 
"DisplaySystemGeodetic", "DragModelPlugin", "DriverMissionControlSequence", "EOMFuncPluginFunction", "ElementBPlane", "ElementCartesian", 
"ElementDelaunay", "ElementEquinoctial", "ElementGeodetic", "ElementKeplerian", "ElementMixedSpherical", "ElementSpherical", 
"ElementTargetVectorIncomingAsymptote", "ElementTargetVectorOutgoingAsymptote", "EngineConstAcc", "EngineConstant", "EngineCustom", 
"EngineDefinition", "EngineIon", "EngineModelIspCoefficients", "EngineModelPoly", "EngineModelThrustCoefficients", "EnginePlugin", 
"EngineThrottleTable", "Exponential", "FuelTank", "GaussJacksonIntegrator", "GeneralRelativityFunction", "GoldenSectionControl", 
"GoldenSectionControlCollection", "GoldenSectionResult", "GoldenSectionResultCollection", "GravityFieldFunction", "GridSearchControl", 
"GridSearchControlCollection", "GridSearchResult", "GridSearchResultCollection", "HPOPPluginFunction", "HarrisPriester", 
"IAccessStoppingCondition", "IAsTriggerCondition", "IAstrogatorCentralBody", "IAttitudeControl", "IAttitudeControlFinite", 
"IAttitudeControlFiniteAntiVelocityVector", "IAttitudeControlFiniteAttitude", "IAttitudeControlFiniteFile", "IAttitudeControlFinitePlugin", 
"IAttitudeControlFiniteThrustVector", "IAttitudeControlFiniteTimeVarying", "IAttitudeControlFiniteVelocityVector", "IAttitudeControlImpulsive", 
"IAttitudeControlImpulsiveAntiVelocityVector", "IAttitudeControlImpulsiveAttitude", "IAttitudeControlImpulsiveFile", "IAttitudeControlImpulsiveThrustVector", 
"IAttitudeControlImpulsiveVelocityVector", "IAttitudeControlOptimalFinite", "IAttitudeControlOptimalFiniteLagrange", "IAutomaticSequence", 
"IAutomaticSequenceCollection", "IBDotRCalc", "IBDotTCalc", "IBMagnitudeCalc", "IBPlaneCollection", "IBThetaCalc", "IBisectionControl", 
"IBisectionControlCollection", "IBisectionResult", "IBisectionResultCollection", "IBlendedDensity", "IBulirschStoerIntegrator", 
"IBurnout", "IBurnoutCBFCartesian", "IBurnoutGeocentric", "IBurnoutGeodetic", "IBurnoutLaunchAzAltitude", "IBurnoutLaunchAzRadius", 
"IBurnoutVelocity", "ICR3BPFunc", "ICalcObjectCollection", "ICalcObjectLinkEmbedControlCollection", "ICalculationGraphCollection", 
"ICentralBodyAttitude", "ICentralBodyAttitudeIAU1994", "ICentralBodyAttitudeRotationCoefficientsFile", "ICentralBodyCollection", 
"ICentralBodyEphemeris", "ICentralBodyEphemerisAnalyticOrbit", "ICentralBodyEphemerisFile", "ICentralBodyEphemerisJPLDesignExplorerOptimizer", 
"ICentralBodyEphemerisJPLSpice", "ICentralBodyEphemerisPlanetary", "ICentralBodyGravityModel", "ICentralBodyShape", "ICentralBodyShapeOblateSpheroid", 
"ICentralBodyShapeSphere", "ICentralBodyShapeTriaxialEllipsoid", "ICira72Function", "IConstraintCollection", "ICustomFunctionScriptEngine", 
"IDTM2012", "IDTM2020", "IDensityModelPlugin", "IDesignCR3BPObject", "IDesignCR3BPObjectCollection", "IDesignCR3BPSetup", 
"IDifferentialCorrectorControl", "IDifferentialCorrectorControlCollection", "IDifferentialCorrectorResult", "IDifferentialCorrectorResultCollection", 
"IDisplaySystem", "IDisplaySystemGeocentric", "IDisplaySystemGeodetic", "IDragModelPlugin", "IDriverMissionControlSequence", 
"IEOMFuncPluginFunction", "IElement", "IElementBPlane", "IElementCartesian", "IElementDelaunay", "IElementEquinoctial", 
"IElementGeodetic", "IElementKeplerian", "IElementMixedSpherical", "IElementSpherical", "IElementTargetVectorIncomingAsymptote", 
"IElementTargetVectorOutgoingAsymptote", "IEngineConstAcc", "IEngineConstant", "IEngineCustom", "IEngineDefinition", "IEngineIon", 
"IEngineModelIspCoefficients", "IEngineModelPoly", "IEngineModelThrustCoefficients", "IEnginePlugin", "IEngineThrottleTable", 
"IExponential", "IFuelTank", "IGaussJacksonIntegrator", "IGeneralRelativityFunction", "IGoldenSectionControl", "IGoldenSectionControlCollection", 
"IGoldenSectionResult", "IGoldenSectionResultCollection", "IGravityFieldFunction", "IGridSearchControl", "IGridSearchControlCollection", 
"IGridSearchResult", "IGridSearchResultCollection", "IHPOPPluginFunction", "IHarrisPriester", "IIPOPTControl", "IIPOPTControlCollection", 
"IIPOPTResult", "IIPOPTResultCollection", "IJacchiaBowman2008", "IJacchiaRoberts", "IJacchia_1960", "IJacchia_1970", "IJacchia_1971", 
"ILightingStoppingCondition", "IMSISE_1990", "IMSIS_1986", "IManeuver", "IManeuverFinite", "IManeuverFinitePropagator", 
"IManeuverImpulsive", "IManeuverOptimalFinite", "IManeuverOptimalFiniteBounds", "IManeuverOptimalFiniteFinalBoundaryConditions", 
"IManeuverOptimalFiniteInitialBoundaryConditions", "IManeuverOptimalFinitePathBoundaryConditions", "IManeuverOptimalFiniteSNOPTOptimizer", 
"IManeuverOptimalFiniteSteeringNodeCollection", "IManeuverOptimalFiniteSteeringNodeElement", "IMarsGRAM2000", "IMarsGRAM2001", 
"IMarsGRAM2005", "IMarsGRAM2010", "IMarsGRAM37", "IMissionControlSequenceBackwardSequence", "IMissionControlSequenceEnd", 
"IMissionControlSequenceFollow", "IMissionControlSequenceHold", "IMissionControlSequenceInitialState", "IMissionControlSequenceLaunch", 
"IMissionControlSequenceManeuver", "IMissionControlSequenceOptions", "IMissionControlSequencePropagate", "IMissionControlSequenceReturn", 
"IMissionControlSequenceSegment", "IMissionControlSequenceSegmentCollection", "IMissionControlSequenceSegmentProperties", 
"IMissionControlSequenceSequence", "IMissionControlSequenceStop", "IMissionControlSequenceTargetSequence", "IMissionControlSequenceUpdate", 
"INRLMSISE_2000", "INumericalIntegrator", "INumericalPropagatorWrapper", "INumericalPropagatorWrapperCR3BP", "IPOPTControl", 
"IPOPTControlCollection", "IPOPTResult", "IPOPTResultCollection", "IPluginProperties", "IPointMassFunction", "IPowerInternal", 
"IPowerProcessed", "IPowerSolarArray", "IProfile", "IProfileBisection", "IProfileChangeManeuverType", "IProfileChangePropagator", 
"IProfileChangeReturnSegment", "IProfileChangeStopSegment", "IProfileChangeStoppingConditionState", "IProfileCollection", 
"IProfileDifferentialCorrector", "IProfileGoldenSection", "IProfileGridSearch", "IProfileIPOPTOptimizer", "IProfileLambertProfile", 
"IProfileLambertSearchProfile", "IProfileRunOnce", "IProfileSNOPTOptimizer", "IProfileScriptingTool", "IProfileSearchPlugin", 
"IProfileSeedFiniteManeuver", "IPropagatorFunctionCollection", "IRadiationPressureFunction", "IRungeKutta2nd3rd", "IRungeKutta4th", 
"IRungeKutta4th5th", "IRungeKutta4thAdapt", "IRungeKuttaF7th8th", "IRungeKuttaV8th9th", "ISNOPTControl", "ISNOPTControlCollection", 
"ISNOPTResult", "ISNOPTResultCollection", "ISRPAeroT20", "ISRPAeroT30", "ISRPGSPM04aIIA", "ISRPGSPM04aIIR", "ISRPGSPM04aeIIA", 
"ISRPGSPM04aeIIR", "ISRPNPlate", "ISRPReflectionPlugin", "ISRPSpherical", "ISRPTabAreaVec", "ISRPVariableArea", "IScriptingCalcObject", 
"IScriptingCalcObjectCollection", "IScriptingParameter", "IScriptingParameterCollection", "IScriptingParameterEnumerationChoice", 
"IScriptingParameterEnumerationChoiceCollection", "IScriptingSegment", "IScriptingSegmentCollection", "IScriptingTool", 
"ISearchPluginControl", "ISearchPluginControlCollection", "ISearchPluginResult", "ISearchPluginResultCollection", "ISpacecraftParameters", 
"IState", "IStateCalcAbsoluteValue", "IStateCalcAltitudeOfApoapsis", "IStateCalcAltitudeOfPeriapsis", "IStateCalcAngle", 
"IStateCalcApparentSolarTime", "IStateCalcArgOfLat", "IStateCalcArgOfPeriapsis", "IStateCalcBetaAngle", "IStateCalcC3Energy", 
"IStateCalcCartSTMElem", "IStateCalcCartesianElem", "IStateCalcCd", "IStateCalcCloseApproachBearing", "IStateCalcCloseApproachCosBearing", 
"IStateCalcCloseApproachMagnitude", "IStateCalcCloseApproachTheta", "IStateCalcCloseApproachX", "IStateCalcCloseApproachY", 
"IStateCalcCosOfVerticalFPA", "IStateCalcCr", "IStateCalcCurvilinearRelMotion", "IStateCalcCustomFunction", "IStateCalcDamageFlux", 
"IStateCalcDamageMassFlux", "IStateCalcDec", "IStateCalcDecRate", "IStateCalcDeltaDec", "IStateCalcDeltaFromMaster", "IStateCalcDeltaRA", 
"IStateCalcDeltaV", "IStateCalcDeltaVSquared", "IStateCalcDensity", "IStateCalcDifference", "IStateCalcDifferenceAcrossSegmentsOtherSat", 
"IStateCalcDifferenceOtherSegment", "IStateCalcDotProduct", "IStateCalcDragArea", "IStateCalcDriftRateFactor", "IStateCalcDuration", 
"IStateCalcEarthMeanLocTimeAN", "IStateCalcEarthMeanSolarTime", "IStateCalcEccentricity", "IStateCalcEccentricityAnomaly", 
"IStateCalcEccentricityX", "IStateCalcEccentricityY", "IStateCalcEnvironment", "IStateCalcEpoch", "IStateCalcEquinoctialElem", 
"IStateCalcFPA", "IStateCalcFuelMass", "IStateCalcGeodeticElem", "IStateCalcGeodeticMeanRightAscension", "IStateCalcGeodeticTrueLongitude", 
"IStateCalcGeodeticTrueLongitudeAtTimeOfPerigee", "IStateCalcGravCoeff", "IStateCalcGravitationalParameter", "IStateCalcHeightAboveTerrain", 
"IStateCalcImpactFlux", "IStateCalcImpactMassFlux", "IStateCalcInAsympDec", "IStateCalcInAsympRA", "IStateCalcInVelAzAtPeriapsis", 
"IStateCalcInclination", "IStateCalcInclinationX", "IStateCalcInclinationY", "IStateCalcInertialDeltaVMagnitude", "IStateCalcInertialDeltaVx", 
"IStateCalcInertialDeltaVy", "IStateCalcInertialDeltaVz", "IStateCalcJacobiConstant", "IStateCalcLocalApparentSolarLon", 
"IStateCalcLonDriftRate", "IStateCalcLonOfAscNode", "IStateCalcLonOfPeriapsis", "IStateCalcMagnitudeFieldDipoleL", "IStateCalcManeuverSpecificImpulse", 
"IStateCalcManeuverTotalMassFlowRate", "IStateCalcMass", "IStateCalcMaxValue", "IStateCalcMeanAnomaly", "IStateCalcMeanEarthLon", 
"IStateCalcMeanMotion", "IStateCalcMeanRightAscension", "IStateCalcMeanValue", "IStateCalcMedianValue", "IStateCalcMinValue", 
"IStateCalcMissionControlSequenceDeltaV", "IStateCalcMissionControlSequenceDeltaVSquared", "IStateCalcNegative", "IStateCalcNumRevs", 
"IStateCalcOnePointAccess", "IStateCalcOrbitDelaunayG", "IStateCalcOrbitDelaunayH", "IStateCalcOrbitDelaunayL", "IStateCalcOrbitPeriod", 
"IStateCalcOrbitSemiLatusRectum", "IStateCalcOrbitStateValue", "IStateCalcOutAsympDec", "IStateCalcOutAsympRA", "IStateCalcOutVelAzAtPeriapsis", 
"IStateCalcPi", "IStateCalcPositionDifferenceOtherSegment", "IStateCalcPositionVelDifferenceOtherSegment", "IStateCalcPower", 
"IStateCalcPressure", "IStateCalcRA", "IStateCalcRAAN", "IStateCalcRARate", "IStateCalcRMagnitude", "IStateCalcRadOfApoapsis", 
"IStateCalcRadOfPeriapsis", "IStateCalcRadiationPressureArea", "IStateCalcRadiationPressureCoefficient", "IStateCalcRectifiedLon", 
"IStateCalcReferenceRadius", "IStateCalcRelAtAOLMaster", "IStateCalcRelGroundTrackError", "IStateCalcRelMotion", "IStateCalcRelPositionDecAngle", 
"IStateCalcRelPositionInPlaneAngle", "IStateCalcRelativeInclination", "IStateCalcRepeatingGroundTrackErr", "IStateCalcSEETMagnitudeFieldFieldLineSepAngle", 
"IStateCalcSEETSAAFlux", "IStateCalcSEETVehTemp", "IStateCalcSRPArea", "IStateCalcSTMEigenval", "IStateCalcSTMEigenvecElem", 
"IStateCalcScalar", "IStateCalcScript", "IStateCalcSemiMajorAxis", "IStateCalcSequenceDeltaV", "IStateCalcSequenceDeltaVSquared", 
"IStateCalcSignedEccentricity", "IStateCalcSolarBetaAngle", "IStateCalcSolarInPlaneAngle", "IStateCalcSpeedOfLight", "IStateCalcStandardDeviation", 
"IStateCalcTemperature", "IStateCalcTimePastAscNode", "IStateCalcTimePastPeriapsis", "IStateCalcTrueAnomaly", "IStateCalcTrueLon", 
"IStateCalcTrueLongitude", "IStateCalcTwoBodyDriftRate", "IStateCalcUnitAngularMomentumX", "IStateCalcUnitAngularMomentumY", 
"IStateCalcUnitAngularMomentumZ", "IStateCalcUserValue", "IStateCalcVMagnitude", "IStateCalcValueAtSegment", "IStateCalcValueAtSegmentOtherSat", 
"IStateCalcVectorDec", "IStateCalcVectorGeometryToolAngle", "IStateCalcVectorMagnitude", "IStateCalcVectorRA", "IStateCalcVectorX", 
"IStateCalcVectorY", "IStateCalcVectorZ", "IStateCalcVelAz", "IStateCalcVelDifferenceOtherSegment", "IStateTransformationFunction", 
"IStoppingCondition", "IStoppingConditionCollection", "IStoppingConditionComponent", "IStoppingConditionElement", "ITargeterGraph", 
"ITargeterGraphActiveControl", "ITargeterGraphActiveControlCollection", "ITargeterGraphCollection", "ITargeterGraphResult", 
"ITargeterGraphResultCollection", "IThirdBodyFunction", "IThruster", "IThrusterSet", "IThrusterSetCollection", "ITwoBodyFunction", 
"IUS_Standard_Atmosphere", "IUserVariable", "IUserVariableCollection", "IUserVariableDefinition", "IUserVariableDefinitionCollection", 
"IUserVariableUpdate", "IUserVariableUpdateCollection", "IVenusGRAM2005", "IYarkovskyFunc", "JacchiaBowman2008", "JacchiaRoberts", 
"Jacchia_1960", "Jacchia_1970", "Jacchia_1971", "LightingStoppingCondition", "MSISE_1990", "MSIS_1986", "ManeuverFinite", 
"ManeuverFinitePropagator", "ManeuverImpulsive", "ManeuverOptimalFinite", "ManeuverOptimalFiniteBounds", "ManeuverOptimalFiniteFinalBoundaryConditions", 
"ManeuverOptimalFiniteInitialBoundaryConditions", "ManeuverOptimalFinitePathBoundaryConditions", "ManeuverOptimalFiniteSNOPTOptimizer", 
"ManeuverOptimalFiniteSteeringNodeCollection", "ManeuverOptimalFiniteSteeringNodeElement", "MarsGRAM2000", "MarsGRAM2001", 
"MarsGRAM2005", "MarsGRAM2010", "MarsGRAM37", "MissionControlSequenceBackwardSequence", "MissionControlSequenceEnd", "MissionControlSequenceFollow", 
"MissionControlSequenceHold", "MissionControlSequenceInitialState", "MissionControlSequenceLaunch", "MissionControlSequenceManeuver", 
"MissionControlSequenceOptions", "MissionControlSequencePropagate", "MissionControlSequenceReturn", "MissionControlSequenceSegmentCollection", 
"MissionControlSequenceSegmentProperties", "MissionControlSequenceSequence", "MissionControlSequenceStop", "MissionControlSequenceTargetSequence", 
"MissionControlSequenceUpdate", "NRLMSISE_2000", "NumericalPropagatorWrapper", "NumericalPropagatorWrapperCR3BP", "PluginProperties", 
"PointMassFunction", "PowerInternal", "PowerProcessed", "PowerSolarArray", "ProfileBisection", "ProfileChangeManeuverType", 
"ProfileChangePropagator", "ProfileChangeReturnSegment", "ProfileChangeStopSegment", "ProfileChangeStoppingConditionState", 
"ProfileCollection", "ProfileDifferentialCorrector", "ProfileGoldenSection", "ProfileGridSearch", "ProfileIPOPTOptimizer", 
"ProfileLambertProfile", "ProfileLambertSearchProfile", "ProfileRunOnce", "ProfileSNOPTOptimizer", "ProfileScriptingTool", 
"ProfileSearchPlugin", "ProfileSeedFiniteManeuver", "PropagatorFunctionCollection", "RadiationPressureFunction", "RungeKutta2nd3rd", 
"RungeKutta4th", "RungeKutta4th5th", "RungeKutta4thAdapt", "RungeKuttaF7th8th", "RungeKuttaV8th9th", "SNOPTControl", "SNOPTControlCollection", 
"SNOPTResult", "SNOPTResultCollection", "SRPAeroT20", "SRPAeroT30", "SRPGSPM04aIIA", "SRPGSPM04aIIR", "SRPGSPM04aeIIA", 
"SRPGSPM04aeIIR", "SRPNPlate", "SRPReflectionPlugin", "SRPSpherical", "SRPTabAreaVec", "SRPVariableArea", "ScriptingCalcObject", 
"ScriptingCalcObjectCollection", "ScriptingParameter", "ScriptingParameterCollection", "ScriptingParameterEnumerationChoice", 
"ScriptingParameterEnumerationChoiceCollection", "ScriptingSegment", "ScriptingSegmentCollection", "ScriptingTool", "SearchPluginControl", 
"SearchPluginControlCollection", "SearchPluginResult", "SearchPluginResultCollection", "SpacecraftParameters", "State", 
"StateCalcAbsoluteValue", "StateCalcAltitudeOfApoapsis", "StateCalcAltitudeOfPeriapsis", "StateCalcAngle", "StateCalcApparentSolarTime", 
"StateCalcArgOfLat", "StateCalcArgOfPeriapsis", "StateCalcBetaAngle", "StateCalcC3Energy", "StateCalcCartSTMElem", "StateCalcCartesianElem", 
"StateCalcCd", "StateCalcCloseApproachBearing", "StateCalcCloseApproachCosBearing", "StateCalcCloseApproachMagnitude", "StateCalcCloseApproachTheta", 
"StateCalcCloseApproachX", "StateCalcCloseApproachY", "StateCalcCosOfVerticalFPA", "StateCalcCr", "StateCalcCurvilinearRelMotion", 
"StateCalcCustomFunction", "StateCalcDamageFlux", "StateCalcDamageMassFlux", "StateCalcDec", "StateCalcDecRate", "StateCalcDeltaDec", 
"StateCalcDeltaFromMaster", "StateCalcDeltaRA", "StateCalcDeltaV", "StateCalcDeltaVSquared", "StateCalcDensity", "StateCalcDifference", 
"StateCalcDifferenceAcrossSegmentsOtherSat", "StateCalcDifferenceOtherSegment", "StateCalcDotProduct", "StateCalcDragArea", 
"StateCalcDriftRateFactor", "StateCalcDuration", "StateCalcEarthMeanLocTimeAN", "StateCalcEarthMeanSolarTime", "StateCalcEccentricity", 
"StateCalcEccentricityAnomaly", "StateCalcEccentricityX", "StateCalcEccentricityY", "StateCalcEnvironment", "StateCalcEpoch", 
"StateCalcEquinoctialElem", "StateCalcFPA", "StateCalcFuelMass", "StateCalcGeodeticElem", "StateCalcGeodeticMeanRightAscension", 
"StateCalcGeodeticTrueLongitude", "StateCalcGeodeticTrueLongitudeAtTimeOfPerigee", "StateCalcGravCoeff", "StateCalcGravitationalParameter", 
"StateCalcHeightAboveTerrain", "StateCalcImpactFlux", "StateCalcImpactMassFlux", "StateCalcInAsympDec", "StateCalcInAsympRA", 
"StateCalcInVelAzAtPeriapsis", "StateCalcInclination", "StateCalcInclinationX", "StateCalcInclinationY", "StateCalcInertialDeltaVMagnitude", 
"StateCalcInertialDeltaVx", "StateCalcInertialDeltaVy", "StateCalcInertialDeltaVz", "StateCalcJacobiConstant", "StateCalcLocalApparentSolarLon", 
"StateCalcLonDriftRate", "StateCalcLonOfAscNode", "StateCalcLonOfPeriapsis", "StateCalcMagnitudeFieldDipoleL", "StateCalcManeuverSpecificImpulse", 
"StateCalcManeuverTotalMassFlowRate", "StateCalcMass", "StateCalcMaxValue", "StateCalcMeanAnomaly", "StateCalcMeanEarthLon", 
"StateCalcMeanMotion", "StateCalcMeanRightAscension", "StateCalcMeanValue", "StateCalcMedianValue", "StateCalcMinValue", 
"StateCalcMissionControlSequenceDeltaV", "StateCalcMissionControlSequenceDeltaVSquared", "StateCalcNegative", "StateCalcNumRevs", 
"StateCalcOnePointAccess", "StateCalcOrbitDelaunayG", "StateCalcOrbitDelaunayH", "StateCalcOrbitDelaunayL", "StateCalcOrbitPeriod", 
"StateCalcOrbitSemiLatusRectum", "StateCalcOrbitStateValue", "StateCalcOutAsympDec", "StateCalcOutAsympRA", "StateCalcOutVelAzAtPeriapsis", 
"StateCalcPi", "StateCalcPositionDifferenceOtherSegment", "StateCalcPositionVelDifferenceOtherSegment", "StateCalcPower", 
"StateCalcPressure", "StateCalcRA", "StateCalcRAAN", "StateCalcRARate", "StateCalcRMagnitude", "StateCalcRadOfApoapsis", 
"StateCalcRadOfPeriapsis", "StateCalcRadiationPressureArea", "StateCalcRadiationPressureCoefficient", "StateCalcRectifiedLon", 
"StateCalcReferenceRadius", "StateCalcRelAtAOLMaster", "StateCalcRelGroundTrackError", "StateCalcRelMotion", "StateCalcRelPositionDecAngle", 
"StateCalcRelPositionInPlaneAngle", "StateCalcRelativeInclination", "StateCalcRepeatingGroundTrackErr", "StateCalcSEETMagnitudeFieldFieldLineSepAngle", 
"StateCalcSEETSAAFlux", "StateCalcSEETVehTemp", "StateCalcSRPArea", "StateCalcSTMEigenval", "StateCalcSTMEigenvecElem", 
"StateCalcScalar", "StateCalcScript", "StateCalcSemiMajorAxis", "StateCalcSequenceDeltaV", "StateCalcSequenceDeltaVSquared", 
"StateCalcSignedEccentricity", "StateCalcSolarBetaAngle", "StateCalcSolarInPlaneAngle", "StateCalcSpeedOfLight", "StateCalcStandardDeviation", 
"StateCalcTemperature", "StateCalcTimePastAscNode", "StateCalcTimePastPeriapsis", "StateCalcTrueAnomaly", "StateCalcTrueLon", 
"StateCalcTrueLongitude", "StateCalcTwoBodyDriftRate", "StateCalcUnitAngularMomentumX", "StateCalcUnitAngularMomentumY", 
"StateCalcUnitAngularMomentumZ", "StateCalcUserValue", "StateCalcVMagnitude", "StateCalcValueAtSegment", "StateCalcValueAtSegmentOtherSat", 
"StateCalcVectorDec", "StateCalcVectorGeometryToolAngle", "StateCalcVectorMagnitude", "StateCalcVectorRA", "StateCalcVectorX", 
"StateCalcVectorY", "StateCalcVectorZ", "StateCalcVelAz", "StateCalcVelDifferenceOtherSegment", "StateTransformationFunction", 
"StoppingCondition", "StoppingConditionCollection", "StoppingConditionElement", "TargeterGraph", "TargeterGraphActiveControl", 
"TargeterGraphActiveControlCollection", "TargeterGraphCollection", "TargeterGraphResult", "TargeterGraphResultCollection", 
"ThirdBodyFunction", "Thruster", "ThrusterSet", "ThrusterSetCollection", "TwoBodyFunction", "US_Standard_Atmosphere", "UserVariable", 
"UserVariableCollection", "UserVariableDefinition", "UserVariableDefinitionCollection", "UserVariableUpdate", "UserVariableUpdateCollection", 
"VenusGRAM2005", "YarkovskyFunc"]

import typing

from ctypes   import byref, POINTER
from enum     import IntEnum

try:
    from numpy import ndarray # noqa
except ModuleNotFoundError:
    pass
    
try:
    from pandas import DataFrame # noqa
except ModuleNotFoundError:
    pass

from ..internal  import comutil          as agcom
from ..internal  import coclassutil      as agcls
from ..internal  import marshall         as agmarshall
from ..utilities import colors           as agcolor
from ..internal.comutil     import IUnknown, IDispatch, IAGFUNCTYPE, IEnumVARIANT
from ..internal.eventutil   import *
from ..utilities.exceptions import *

from ..stkutil import *
from ..stkobjects import *


def _raise_uninitialized_error(*args):
    raise STKRuntimeError("Valid STK object model classes are returned from STK methods and should not be created independently.")

class AgEVAGraphOption(IntEnum):
    """Mode that the mcs will run in."""
    # Don't graph.
    eVAGraphOptionNoGraph = 0
    # Graph the difference.
    eVAGraphOptionGraphDifference = 1
    # Graph the value.
    eVAGraphOptionGraphValue = 2

AgEVAGraphOption.eVAGraphOptionNoGraph.__doc__ = "Don't graph."
AgEVAGraphOption.eVAGraphOptionGraphDifference.__doc__ = "Graph the difference."
AgEVAGraphOption.eVAGraphOptionGraphValue.__doc__ = "Graph the value."

agcls.AgTypeNameMap["AgEVAGraphOption"] = AgEVAGraphOption

class AgEVASmartRunMode(IntEnum):
    """Mode that the mcs will run in."""
    # Run Entire Mission Control Sequence
    eVASmartRunModeEntireMCS = 0
    # Run Only Changed Segments
    eVASmartRunModeOnlyChanged = 1

AgEVASmartRunMode.eVASmartRunModeEntireMCS.__doc__ = "Run Entire Mission Control Sequence"
AgEVASmartRunMode.eVASmartRunModeOnlyChanged.__doc__ = "Run Only Changed Segments"

agcls.AgTypeNameMap["AgEVASmartRunMode"] = AgEVASmartRunMode

class AgEVAFormulation(IntEnum):
    """Equinoctial Formulation."""
    # Posigrade.
    eVAFormulationPosigrade = 0
    # Retrograde.
    eVAFormulationRetrograde = 1

AgEVAFormulation.eVAFormulationPosigrade.__doc__ = "Posigrade."
AgEVAFormulation.eVAFormulationRetrograde.__doc__ = "Retrograde."

agcls.AgTypeNameMap["AgEVAFormulation"] = AgEVAFormulation

class AgEVALightingCondition(IntEnum):
    """The criteria of a Lighting stopping condition."""
    # The Enter Direct Sun criterion.
    eVALightingCriterionEnterDirectSun = 0
    # The Exit Direct Sun criterion.
    eVALightingCriterionExitDirectSun = 1
    # The Enter Umbra criterion.
    eVALightingCriterionEnterUmbra = 2
    # The Exit Umbra criterion.
    eVALightingCriterionExitUmbra = 3

AgEVALightingCondition.eVALightingCriterionEnterDirectSun.__doc__ = "The Enter Direct Sun criterion."
AgEVALightingCondition.eVALightingCriterionExitDirectSun.__doc__ = "The Exit Direct Sun criterion."
AgEVALightingCondition.eVALightingCriterionEnterUmbra.__doc__ = "The Enter Umbra criterion."
AgEVALightingCondition.eVALightingCriterionExitUmbra.__doc__ = "The Exit Umbra criterion."

agcls.AgTypeNameMap["AgEVALightingCondition"] = AgEVALightingCondition

class AgEVAProfile(IntEnum):
    """Type of profile."""
    # Plugin search profile.
    eVAProfileSearchPlugin = 0
    # Differential corrector profile.
    eVAProfileDifferentialCorrector = 2
    # Change maneuver type profile.
    eVAProfileChangeManeuverType = 3
    # Scripting tool profile.
    eVAProfileScriptingTool = 4
    # Change return segment profile.
    eVAProfileChangeReturnSegment = 5
    # Change propagator profile.
    eVAProfileChangePropagator = 6
    # Change stop segment profile.
    eVAProfileChangeStopSegment = 7
    # Change stopping condition state profile.
    eVAProfileChangeStoppingConditionState = 8
    # Change seed finite maneuver profile.
    eVAProfileSeedFiniteManeuver = 9
    # Run once profile.
    eVAProfileRunOnce = 10
    # SNOPT Optimizer profile.
    eVAProfileSNOPTOptimizer = 11
    # IPOPT Optimizer profile.
    eVAProfileIPOPTOptimizer = 12
    # Lambert profile.
    eVAProfileLambertProfile = 13
    # Lambert Search profile.
    eVAProfileLambertSearchProfile = 14
    # Golden Section profile.
    eVAProfileGoldenSection = 15
    # grid Search profile.
    eVAProfileGridSearch = 16
    # Single Parameter Bisection profile.
    eVAProfileBisection = 17

AgEVAProfile.eVAProfileSearchPlugin.__doc__ = "Plugin search profile."
AgEVAProfile.eVAProfileDifferentialCorrector.__doc__ = "Differential corrector profile."
AgEVAProfile.eVAProfileChangeManeuverType.__doc__ = "Change maneuver type profile."
AgEVAProfile.eVAProfileScriptingTool.__doc__ = "Scripting tool profile."
AgEVAProfile.eVAProfileChangeReturnSegment.__doc__ = "Change return segment profile."
AgEVAProfile.eVAProfileChangePropagator.__doc__ = "Change propagator profile."
AgEVAProfile.eVAProfileChangeStopSegment.__doc__ = "Change stop segment profile."
AgEVAProfile.eVAProfileChangeStoppingConditionState.__doc__ = "Change stopping condition state profile."
AgEVAProfile.eVAProfileSeedFiniteManeuver.__doc__ = "Change seed finite maneuver profile."
AgEVAProfile.eVAProfileRunOnce.__doc__ = "Run once profile."
AgEVAProfile.eVAProfileSNOPTOptimizer.__doc__ = "SNOPT Optimizer profile."
AgEVAProfile.eVAProfileIPOPTOptimizer.__doc__ = "IPOPT Optimizer profile."
AgEVAProfile.eVAProfileLambertProfile.__doc__ = "Lambert profile."
AgEVAProfile.eVAProfileLambertSearchProfile.__doc__ = "Lambert Search profile."
AgEVAProfile.eVAProfileGoldenSection.__doc__ = "Golden Section profile."
AgEVAProfile.eVAProfileGridSearch.__doc__ = "grid Search profile."
AgEVAProfile.eVAProfileBisection.__doc__ = "Single Parameter Bisection profile."

agcls.AgTypeNameMap["AgEVAProfile"] = AgEVAProfile

class AgEVAAccessCriterion(IntEnum):
    """The criteria of an Access stopping condition."""
    # The Gain Access criterion.
    eVAAccessCriterionGain = 0
    # The Lose Access criterion.
    eVAAccessCriterionLose = 1
    # The Either criterion.
    eVAAccessCriterionEither = 2

AgEVAAccessCriterion.eVAAccessCriterionGain.__doc__ = "The Gain Access criterion."
AgEVAAccessCriterion.eVAAccessCriterionLose.__doc__ = "The Lose Access criterion."
AgEVAAccessCriterion.eVAAccessCriterionEither.__doc__ = "The Either criterion."

agcls.AgTypeNameMap["AgEVAAccessCriterion"] = AgEVAAccessCriterion

class AgEVAEclipsingBodiesSource(IntEnum):
    """The source types of the eclipsing bodies list."""
    # The eclipsing bodies list of the propagator's central body.
    eVAEclipsingBodiesPropagatorCb = 0
    # A user-defined eclipsing bodies list related to the propagator's central body.
    eVAEclipsingBodiesUserDefined = 1
    # The eclipsing bodies list of the vehicle's central body.
    eVAEclipsingBodiesVehicleCb = 2
    # A list of eclipsing bodies from the vehicle's Basic Properties->Eclipse Bodies list.
    eVAEclipsingBodiesVehicleUserDefined = 3

AgEVAEclipsingBodiesSource.eVAEclipsingBodiesPropagatorCb.__doc__ = "The eclipsing bodies list of the propagator's central body."
AgEVAEclipsingBodiesSource.eVAEclipsingBodiesUserDefined.__doc__ = "A user-defined eclipsing bodies list related to the propagator's central body."
AgEVAEclipsingBodiesSource.eVAEclipsingBodiesVehicleCb.__doc__ = "The eclipsing bodies list of the vehicle's central body."
AgEVAEclipsingBodiesSource.eVAEclipsingBodiesVehicleUserDefined.__doc__ = "A list of eclipsing bodies from the vehicle's Basic Properties->Eclipse Bodies list."

agcls.AgTypeNameMap["AgEVAEclipsingBodiesSource"] = AgEVAEclipsingBodiesSource

class AgEVACriterion(IntEnum):
    """The stopping condition criterion types."""
    # The Cross Decreasing criterion - the stopping condition is satisfied when the parameter reaches a value equal to the trip value while decreasing.
    eVACriterionCrossDecreasing = 0
    # The Cross Either criterion - the stopping condition is satisfied when either of the above situations occurs.
    eVACriterionCrossEither = 1
    # The Cross Increasing criterion - the stopping condition is satisfied when the parameter reaches a value equal to the trip value while increasing.
    eVACriterionCrossIncreasing = 2

AgEVACriterion.eVACriterionCrossDecreasing.__doc__ = "The Cross Decreasing criterion - the stopping condition is satisfied when the parameter reaches a value equal to the trip value while decreasing."
AgEVACriterion.eVACriterionCrossEither.__doc__ = "The Cross Either criterion - the stopping condition is satisfied when either of the above situations occurs."
AgEVACriterion.eVACriterionCrossIncreasing.__doc__ = "The Cross Increasing criterion - the stopping condition is satisfied when the parameter reaches a value equal to the trip value while increasing."

agcls.AgTypeNameMap["AgEVACriterion"] = AgEVACriterion

class AgEVACalcObjectReference(IntEnum):
    """The calculation object Reference Selection types."""
    # The Use Basic Reference type - uses the current satellite as the reference vehicle.
    eVACalcObjectReferenceBasic = 0
    # The UserSpecifiedReference type - uses a user specified vehicle object as the reference vehicle.
    eVACalcObjectReferenceSpecified = 1

AgEVACalcObjectReference.eVACalcObjectReferenceBasic.__doc__ = "The Use Basic Reference type - uses the current satellite as the reference vehicle."
AgEVACalcObjectReference.eVACalcObjectReferenceSpecified.__doc__ = "The UserSpecifiedReference type - uses a user specified vehicle object as the reference vehicle."

agcls.AgTypeNameMap["AgEVACalcObjectReference"] = AgEVACalcObjectReference

class AgEVACalcObjectCentralBodyReference(IntEnum):
    """The calculation object Central Body Reference Selection types."""
    # The Use Basic Reference type - uses the current satellite as the reference vehicle.
    eVACalcObjectCentralBodyReferenceSpecified = 0
    # The UserSpecifiedReference type - uses a user specified vehicle object as the reference vehicle.
    eVACalcObjectCentralBodyReferenceParent = 1

AgEVACalcObjectCentralBodyReference.eVACalcObjectCentralBodyReferenceSpecified.__doc__ = "The Use Basic Reference type - uses the current satellite as the reference vehicle."
AgEVACalcObjectCentralBodyReference.eVACalcObjectCentralBodyReferenceParent.__doc__ = "The UserSpecifiedReference type - uses a user specified vehicle object as the reference vehicle."

agcls.AgTypeNameMap["AgEVACalcObjectCentralBodyReference"] = AgEVACalcObjectCentralBodyReference

class AgEVACalcObjectElem(IntEnum):
    """The calculation object Element Types."""
    # Brouwer-Lyddane mean elements considering both the short and long period terms (i.e. resulting from averaging over the rotation of periapse). The perturbation terms are the J2, J3, J4 and J5 oblateness terms and it considers the term involving J2^2.
    eVACalcObjectElemBrouwerLyddaneMeanLong = 0
    # Brouwer-Lyddane Mean Short - Brouwer-Lyddane mean elements considering only the short period terms (i.e. those involving averaging over the period of the orbit) where the only perturbation force is the oblateness arising from the J2 gravity term.
    eVACalcObjectElemBrouwerLyddaneMeanShort = 1
    # Kozai-Izsak Mean - Kozai-Izsak mean elements for which only the short period terms (i.e. those involving averaging over the period of the orbit) are considered. The only perturbation force considered is the oblateness arising from the J2 gravity term.
    eVACalcObjectElemKozaiIzsakMean = 2
    # Osculating.
    eVACalcObjectElemOsculating = 3

AgEVACalcObjectElem.eVACalcObjectElemBrouwerLyddaneMeanLong.__doc__ = "Brouwer-Lyddane mean elements considering both the short and long period terms (i.e. resulting from averaging over the rotation of periapse). The perturbation terms are the J2, J3, J4 and J5 oblateness terms and it considers the term involving J2^2."
AgEVACalcObjectElem.eVACalcObjectElemBrouwerLyddaneMeanShort.__doc__ = "Brouwer-Lyddane Mean Short - Brouwer-Lyddane mean elements considering only the short period terms (i.e. those involving averaging over the period of the orbit) where the only perturbation force is the oblateness arising from the J2 gravity term."
AgEVACalcObjectElem.eVACalcObjectElemKozaiIzsakMean.__doc__ = "Kozai-Izsak Mean - Kozai-Izsak mean elements for which only the short period terms (i.e. those involving averaging over the period of the orbit) are considered. The only perturbation force considered is the oblateness arising from the J2 gravity term."
AgEVACalcObjectElem.eVACalcObjectElemOsculating.__doc__ = "Osculating."

agcls.AgTypeNameMap["AgEVACalcObjectElem"] = AgEVACalcObjectElem

class AgEVAProfileMode(IntEnum):
    """The Target Sequence profile modes."""
    # Iterate - the Target Sequence will run the profile as it is configured in an attempt to attain the desired solution.
    eVAProfileModeIterate = 0
    # Not Active - the Target Sequence will ignore the profile when running.
    eVAProfileModeNotActive = 1
    # Run Once - the Target Sequence will run the profile once according to its current configuration.
    eVAProfileModeRunOnce = 2
    # Active - the Target Sequence will apply the change that the profile passes when running.
    eVAProfileModeActive = 3

AgEVAProfileMode.eVAProfileModeIterate.__doc__ = "Iterate - the Target Sequence will run the profile as it is configured in an attempt to attain the desired solution."
AgEVAProfileMode.eVAProfileModeNotActive.__doc__ = "Not Active - the Target Sequence will ignore the profile when running."
AgEVAProfileMode.eVAProfileModeRunOnce.__doc__ = "Run Once - the Target Sequence will run the profile once according to its current configuration."
AgEVAProfileMode.eVAProfileModeActive.__doc__ = "Active - the Target Sequence will apply the change that the profile passes when running."

agcls.AgTypeNameMap["AgEVAProfileMode"] = AgEVAProfileMode

class AgEVAControlStoppingCondition(IntEnum):
    """The stopping condition control types."""
    # Trip - the value at which the stopping condition will be satisfied.
    eVAControlStoppingConditionTripValue = 0

AgEVAControlStoppingCondition.eVAControlStoppingConditionTripValue.__doc__ = "Trip - the value at which the stopping condition will be satisfied."

agcls.AgTypeNameMap["AgEVAControlStoppingCondition"] = AgEVAControlStoppingCondition

class AgEVAState(IntEnum):
    """The Stop segment state types."""
    # Enabled - the segment stops the run of the MCS.
    eVAStateEnabled = 0
    # Disabled - the MCS ignores this segment and continues to run.
    eVAStateDisabled = 1

AgEVAState.eVAStateEnabled.__doc__ = "Enabled - the segment stops the run of the MCS."
AgEVAState.eVAStateDisabled.__doc__ = "Disabled - the MCS ignores this segment and continues to run."

agcls.AgTypeNameMap["AgEVAState"] = AgEVAState

class AgEVAReturnControl(IntEnum):
    """The Return segment control types"""
    # Enable - returns control of the MCS run to the parent segment.
    eVAReturnControlEnable = 0
    # Disable - the MCS ignores this segment and continues to run.
    eVAReturnControlDisable = 1
    # Enable (except Profiles bypass)- functions as enabled except when run from a Target Sequence profile (e.g., a differential corrector), which will ignore it.
    eVAReturnControlEnableExceptProfilesBypass = 2

AgEVAReturnControl.eVAReturnControlEnable.__doc__ = "Enable - returns control of the MCS run to the parent segment."
AgEVAReturnControl.eVAReturnControlDisable.__doc__ = "Disable - the MCS ignores this segment and continues to run."
AgEVAReturnControl.eVAReturnControlEnableExceptProfilesBypass.__doc__ = "Enable (except Profiles bypass)- functions as enabled except when run from a Target Sequence profile (e.g., a differential corrector), which will ignore it."

agcls.AgTypeNameMap["AgEVAReturnControl"] = AgEVAReturnControl

class AgEVADrawPerturbation(IntEnum):
    """The Draw Perturbation types for a Differential Corrector profile."""
    # Segment Color - perturbations will be displayed in the trajectory color defined for the individual segments within the target sequence.
    eVADrawPerturbationSegmentColor = 0
    # Don't Draw - perturbations will not be drawn, which may decrease the run time of the target sequence.
    eVADrawPerturbationDontDraw = 1
    # Targeter Color - perturbations will be displayed in the trajectory color defined for the target sequence.
    eVADrawPerturbationTargeterColor = 2

AgEVADrawPerturbation.eVADrawPerturbationSegmentColor.__doc__ = "Segment Color - perturbations will be displayed in the trajectory color defined for the individual segments within the target sequence."
AgEVADrawPerturbation.eVADrawPerturbationDontDraw.__doc__ = "Don't Draw - perturbations will not be drawn, which may decrease the run time of the target sequence."
AgEVADrawPerturbation.eVADrawPerturbationTargeterColor.__doc__ = "Targeter Color - perturbations will be displayed in the trajectory color defined for the target sequence."

agcls.AgTypeNameMap["AgEVADrawPerturbation"] = AgEVADrawPerturbation

class AgEVADeriveCalcMethod(IntEnum):
    """The Derivative Calculation method types for a Differential Corrector profile."""
    # Forward Difference - (f(x + delta) - f(x))/ delta
    eVADeriveCalcMethodForward = 0
    # Central Difference - (f(x + delta) - f(x - delta)) / 2delta
    eVADeriveCalcMethodCentral = 1
    # Signed Difference - if x is positive, use the forward difference; if x is negative, use the backward difference.
    eVADeriveCalcMethodSigned = 2

AgEVADeriveCalcMethod.eVADeriveCalcMethodForward.__doc__ = "Forward Difference - (f(x + delta) - f(x))/ delta"
AgEVADeriveCalcMethod.eVADeriveCalcMethodCentral.__doc__ = "Central Difference - (f(x + delta) - f(x - delta)) / 2delta"
AgEVADeriveCalcMethod.eVADeriveCalcMethodSigned.__doc__ = "Signed Difference - if x is positive, use the forward difference; if x is negative, use the backward difference."

agcls.AgTypeNameMap["AgEVADeriveCalcMethod"] = AgEVADeriveCalcMethod

class AgEVAConvergenceCriteria(IntEnum):
    """The Convergence Criteria types for a Differential Corrector profile."""
    # Equality Constraints Satisfied - the differences between the achieved and desired equality constraint values must be within the specified tolerances for convergence.
    eVAConvergenceCriteriaEqualityConstraintWithinTolerance = 0
    # Equality Constraints Satisfied or Parameter Variations within Tolerance - the differences between the achieved and desired EC values must be within tolerances, or the last updates to the control parameters must be within tolerances for convergence.
    eVAConvervenceCriteriaEitherEqualityConstraintsOrControlParams = 1

AgEVAConvergenceCriteria.eVAConvergenceCriteriaEqualityConstraintWithinTolerance.__doc__ = "Equality Constraints Satisfied - the differences between the achieved and desired equality constraint values must be within the specified tolerances for convergence."
AgEVAConvergenceCriteria.eVAConvervenceCriteriaEitherEqualityConstraintsOrControlParams.__doc__ = "Equality Constraints Satisfied or Parameter Variations within Tolerance - the differences between the achieved and desired EC values must be within tolerances, or the last updates to the control parameters must be within tolerances for convergence."

agcls.AgTypeNameMap["AgEVAConvergenceCriteria"] = AgEVAConvergenceCriteria

class AgEVADCScalingMethod(IntEnum):
    """The Scaling Method types for a Differential Corrector profile."""
    # By initial value.
    eVADCScalingMethodInitialValue = 0
    # By one (no scaling).
    eVADCScalingMethodOneNoScaling = 1
    # By specified value.
    eVADCScalingMethodSpecifiedValue = 2
    # By tolerance.
    eVADCScalingMethodTolerance = 3

AgEVADCScalingMethod.eVADCScalingMethodInitialValue.__doc__ = "By initial value."
AgEVADCScalingMethod.eVADCScalingMethodOneNoScaling.__doc__ = "By one (no scaling)."
AgEVADCScalingMethod.eVADCScalingMethodSpecifiedValue.__doc__ = "By specified value."
AgEVADCScalingMethod.eVADCScalingMethodTolerance.__doc__ = "By tolerance."

agcls.AgTypeNameMap["AgEVADCScalingMethod"] = AgEVADCScalingMethod

class AgEVAControlUpdate(IntEnum):
    """Update segment properties that can be selected as control parameters for a Target Sequence."""
    # Drag Coefficient (Cd) - the dimensionless drag coefficient associated with the drag area.
    eVAControlUpdateCdVal = 100
    # Solar Radiation Pressure (Spherical) Coefficient (Cr) - the reflectivity of the spacecraft used for solar radiation pressure calculations, where 2.0 is fully reflective and 1.0 is not reflective at all.
    eVAControlUpdateCrVal = 101
    # Drag Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of motion, used for atmospheric drag calculations. Enter a value in the selected distance unit squared.
    eVAControlUpdateDragAreaVal = 102
    # Dry Mass - the mass of the spacecraft exclusive of propellant. Enter a value in the selected mass unit (e.g. kg).
    eVAControlUpdateDryMassVal = 103
    # Fuel Density - the density of the fuel tank. Enter a value in the selected mass unit per the selected distance unit cubed (e.g. kg/m^3).
    eVAControlUpdateFuelDensityVal = 104
    # Fuel Mass - the mass of the spacecraft propellant. Enter a value in the selected mass unit (e.g. kg).
    eVAControlUpdateFuelMassVal = 105
    # The cross-sectional area of the spacecraft assumed perpendicular to the direction of central body radiation, used for central body radiation (albedo / thermal pressure) calculations. Enter a value in the selected distance unit squared.
    eVAControlUpdateRadiationPressureAreaVal = 106
    # Radiation Pressure (Albedo/Thermal) Coefficient (Ck) - the reflectivity of the spacecraft used for central body radiation pressure (albedo / thermal pressure) calculations, where 2.0 is fully reflective and 1.0 is not reflective at all.
    eVAControlUpdateRadiationPressureCoefficientVal = 107
    # Solar Radiation Pressure (Spherical) Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of solar radiation, used for solar radiation calculations. Enter a value in the selected distance unit squared.
    eVAControlUpdateSRPAreaVal = 108
    # Tank Pressure - the fuel tank pressure. Enter a value in the selected pressure unit (e.g. Pa).
    eVAControlUpdateTankPressureVal = 109
    # Tank Temperature - the temperature of the fuel tank. Enter a value in the selected temperature unit.
    eVAControlUpdateTankTempVal = 110

AgEVAControlUpdate.eVAControlUpdateCdVal.__doc__ = "Drag Coefficient (Cd) - the dimensionless drag coefficient associated with the drag area."
AgEVAControlUpdate.eVAControlUpdateCrVal.__doc__ = "Solar Radiation Pressure (Spherical) Coefficient (Cr) - the reflectivity of the spacecraft used for solar radiation pressure calculations, where 2.0 is fully reflective and 1.0 is not reflective at all."
AgEVAControlUpdate.eVAControlUpdateDragAreaVal.__doc__ = "Drag Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of motion, used for atmospheric drag calculations. Enter a value in the selected distance unit squared."
AgEVAControlUpdate.eVAControlUpdateDryMassVal.__doc__ = "Dry Mass - the mass of the spacecraft exclusive of propellant. Enter a value in the selected mass unit (e.g. kg)."
AgEVAControlUpdate.eVAControlUpdateFuelDensityVal.__doc__ = "Fuel Density - the density of the fuel tank. Enter a value in the selected mass unit per the selected distance unit cubed (e.g. kg/m^3)."
AgEVAControlUpdate.eVAControlUpdateFuelMassVal.__doc__ = "Fuel Mass - the mass of the spacecraft propellant. Enter a value in the selected mass unit (e.g. kg)."
AgEVAControlUpdate.eVAControlUpdateRadiationPressureAreaVal.__doc__ = "The cross-sectional area of the spacecraft assumed perpendicular to the direction of central body radiation, used for central body radiation (albedo / thermal pressure) calculations. Enter a value in the selected distance unit squared."
AgEVAControlUpdate.eVAControlUpdateRadiationPressureCoefficientVal.__doc__ = "Radiation Pressure (Albedo/Thermal) Coefficient (Ck) - the reflectivity of the spacecraft used for central body radiation pressure (albedo / thermal pressure) calculations, where 2.0 is fully reflective and 1.0 is not reflective at all."
AgEVAControlUpdate.eVAControlUpdateSRPAreaVal.__doc__ = "Solar Radiation Pressure (Spherical) Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of solar radiation, used for solar radiation calculations. Enter a value in the selected distance unit squared."
AgEVAControlUpdate.eVAControlUpdateTankPressureVal.__doc__ = "Tank Pressure - the fuel tank pressure. Enter a value in the selected pressure unit (e.g. Pa)."
AgEVAControlUpdate.eVAControlUpdateTankTempVal.__doc__ = "Tank Temperature - the temperature of the fuel tank. Enter a value in the selected temperature unit."

agcls.AgTypeNameMap["AgEVAControlUpdate"] = AgEVAControlUpdate

class AgEVAControlFollow(IntEnum):
    """Follow segment properties that can be selected as control parameters for a Target Sequence."""
    # Fuel Mass - the mass of the spacecraft propellant. Enter a value in the selected mass unit (e.g. kg).
    eVAControlFollowFuelMass = 200
    # Drag Coefficient (Cd) - the dimensionless drag coefficient associated with the drag area.
    eVAControlFollowCd = 201
    # Solar Radiation Pressure (Spherical) Coefficient (Cr) - the reflectivity of the spacecraft used for solar radiation pressure calculations, where 2.0 is fully reflective and 1.0 is not reflective at all.
    eVAControlFollowCr = 202
    # Drag Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of motion, used for atmospheric drag calculations. Enter a value in the selected distance unit squared.
    eVAControlFollowDragArea = 203
    # Dry Mass - the mass of the spacecraft exclusive of propellant. Enter a value in the selected mass unit (e.g. kg).
    eVAControlFollowDryMass = 204
    # Fuel Density - the density of the fuel tank. Enter a value in the selected mass unit per the selected distance unit cubed (e.g. kg/m^3).
    eVAControlFollowFuelDensity = 205
    # GPS Solar Radiation Pressure K1 - if you are using a non-spherical SRP model, this field defines the model's K1 (scale) value.
    eVAControlFollowK1 = 206
    # GPS Solar Radiation Pressure K2 - if you are using a non-spherical SRP model, this field defines the model's K2 (Y bias) value.
    eVAControlFollowK2 = 207
    # The cross-sectional area of the spacecraft assumed perpendicular to the direction of central body radiation, used for central body radiation (albedo / thermal pressure) calculations. Enter a value in the selected distance unit squared.
    eVAControlFollowRadiationPressureArea = 208
    # Radiation Pressure (Albedo/Thermal) Coefficient (Ck) - the reflectivity of the spacecraft used for central body radiation pressure (albedo / thermal pressure) calculations, where 2.0 is fully reflective and 1.0 is not reflective at all.
    eVAControlFollowCk = 209
    # Solar Radiation Pressure (Spherical) Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of solar radiation, used for solar radiation calculations. Enter a value in the selected distance unit squared.
    eVAControlFollowSRPArea = 210
    # Tank Pressure - the fuel tank pressure. Enter a value in the selected pressure unit (e.g. Pa).
    eVAControlFollowTankPressure = 211
    # Tank Temperature - the temperature of the fuel tank. Enter a value in the selected temperature unit.
    eVAControlFollowTankTemp = 212
    # Maximum Fuel Mass - the maximum fuel mass of the spacecraft; this parameter specifically applies to Finite Maneuver segments that are being executed in Backward Sequences. Enter a value in the selected mass unit (e.g. kg).
    eVAControlFollowMaxFuelMass = 213
    # Tank Volume - the volume of the fuel tank. Enter a value in the selected distance unit cubed (e.g. m^3). The minimum value is 1e-019 m^3.
    eVAControlFollowTankVolume = 214
    # X Offset - the distance that the spacecraft will be offset from the leader's body frame along the X axis.
    eVAControlFollowXOffset = 215
    # Y Offset - the distance that the spacecraft will be offset from the leader's body frame along the Y axis.
    eVAControlFollowYOffset = 216
    # Z Offset - the distance that the spacecraft will be offset from the leader's body frame along the Z axis.
    eVAControlFollowZOffset = 217

AgEVAControlFollow.eVAControlFollowFuelMass.__doc__ = "Fuel Mass - the mass of the spacecraft propellant. Enter a value in the selected mass unit (e.g. kg)."
AgEVAControlFollow.eVAControlFollowCd.__doc__ = "Drag Coefficient (Cd) - the dimensionless drag coefficient associated with the drag area."
AgEVAControlFollow.eVAControlFollowCr.__doc__ = "Solar Radiation Pressure (Spherical) Coefficient (Cr) - the reflectivity of the spacecraft used for solar radiation pressure calculations, where 2.0 is fully reflective and 1.0 is not reflective at all."
AgEVAControlFollow.eVAControlFollowDragArea.__doc__ = "Drag Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of motion, used for atmospheric drag calculations. Enter a value in the selected distance unit squared."
AgEVAControlFollow.eVAControlFollowDryMass.__doc__ = "Dry Mass - the mass of the spacecraft exclusive of propellant. Enter a value in the selected mass unit (e.g. kg)."
AgEVAControlFollow.eVAControlFollowFuelDensity.__doc__ = "Fuel Density - the density of the fuel tank. Enter a value in the selected mass unit per the selected distance unit cubed (e.g. kg/m^3)."
AgEVAControlFollow.eVAControlFollowK1.__doc__ = "GPS Solar Radiation Pressure K1 - if you are using a non-spherical SRP model, this field defines the model's K1 (scale) value."
AgEVAControlFollow.eVAControlFollowK2.__doc__ = "GPS Solar Radiation Pressure K2 - if you are using a non-spherical SRP model, this field defines the model's K2 (Y bias) value."
AgEVAControlFollow.eVAControlFollowRadiationPressureArea.__doc__ = "The cross-sectional area of the spacecraft assumed perpendicular to the direction of central body radiation, used for central body radiation (albedo / thermal pressure) calculations. Enter a value in the selected distance unit squared."
AgEVAControlFollow.eVAControlFollowCk.__doc__ = "Radiation Pressure (Albedo/Thermal) Coefficient (Ck) - the reflectivity of the spacecraft used for central body radiation pressure (albedo / thermal pressure) calculations, where 2.0 is fully reflective and 1.0 is not reflective at all."
AgEVAControlFollow.eVAControlFollowSRPArea.__doc__ = "Solar Radiation Pressure (Spherical) Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of solar radiation, used for solar radiation calculations. Enter a value in the selected distance unit squared."
AgEVAControlFollow.eVAControlFollowTankPressure.__doc__ = "Tank Pressure - the fuel tank pressure. Enter a value in the selected pressure unit (e.g. Pa)."
AgEVAControlFollow.eVAControlFollowTankTemp.__doc__ = "Tank Temperature - the temperature of the fuel tank. Enter a value in the selected temperature unit."
AgEVAControlFollow.eVAControlFollowMaxFuelMass.__doc__ = "Maximum Fuel Mass - the maximum fuel mass of the spacecraft; this parameter specifically applies to Finite Maneuver segments that are being executed in Backward Sequences. Enter a value in the selected mass unit (e.g. kg)."
AgEVAControlFollow.eVAControlFollowTankVolume.__doc__ = "Tank Volume - the volume of the fuel tank. Enter a value in the selected distance unit cubed (e.g. m^3). The minimum value is 1e-019 m^3."
AgEVAControlFollow.eVAControlFollowXOffset.__doc__ = "X Offset - the distance that the spacecraft will be offset from the leader's body frame along the X axis."
AgEVAControlFollow.eVAControlFollowYOffset.__doc__ = "Y Offset - the distance that the spacecraft will be offset from the leader's body frame along the Y axis."
AgEVAControlFollow.eVAControlFollowZOffset.__doc__ = "Z Offset - the distance that the spacecraft will be offset from the leader's body frame along the Z axis."

agcls.AgTypeNameMap["AgEVAControlFollow"] = AgEVAControlFollow

class AgEVAControlInitState(IntEnum):
    """Initial State segment properties that can be selected as control parameters for a Target Sequence."""
    # Fuel Mass - the mass of the spacecraft propellant. Enter a value in the selected mass unit (e.g. kg).
    eVAControlInitStateFuelMass = 300
    # Vx Component - the X component of the spacecraft velocity vector.
    eVAControlInitStateCartesianVx = 301
    # Vy Component - the Y component of the spacecraft velocity vector.
    eVAControlInitStateCartesianVy = 302
    # Vz Component - the Z component of the spacecraft velocity vector.
    eVAControlInitStateCartesianVz = 303
    # X Component - the X component of the spacecraft position vector.
    eVAControlInitStateCartesianX = 304
    # Y Component - the Y component of the spacecraft position vector.
    eVAControlInitStateCartesianY = 305
    # Z Component - the Z component of the spacecraft position vector.
    eVAControlInitStateCartesianZ = 306
    # Drag Coefficient (Cd) - the dimensionless drag coefficient associated with the drag area.
    eVAControlInitStateCd = 307
    # Solar Radiation Pressure (Spherical) Coefficient (Cr) - the reflectivity of the spacecraft used for solar radiation pressure calculations, where 2.0 is fully reflective and 1.0 is not reflective at all.
    eVAControlInitStateCr = 308
    # Drag Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of motion, used for atmospheric drag calculations. Enter a value in the selected distance unit squared.
    eVAControlInitStateDragArea = 309
    # Dry Mass - the mass of the spacecraft exclusive of propellant. Enter a value in the selected mass unit (e.g. kg).
    eVAControlInitStateDryMass = 310
    # Epoch - the orbit epoch.
    eVAControlInitStateEpoch = 311
    # Fuel Density - the density of the fuel tank.
    eVAControlInitStateFuelDensity = 312
    # GPS Solar Radiation Pressure K1 - if you are using a non-spherical SRP model, this field defines the model's K1 (scale) value.
    eVAControlInitStateK1 = 313
    # GPS Solar Radiation Pressure K2 - if you are using a non-spherical SRP model, this field defines the model's K2 (Y bias) value.
    eVAControlInitStateK2 = 314
    # Eccentricity - the ratio of the distance between the foci to the major axis of the orbital ellipse. Dimensionless.
    eVAControlInitStateKeplerianEcc = 315
    # Inclination - the angle from the +Z axis of the coordinate system to the angular momentum vector of the spacecraft's orbit.
    eVAControlInitStateKeplerianInc = 316
    # Right Ascension of Ascending Node - the angle between the X direction of the coordinate system and the point where the orbit crosses the X-Y plane in the +Z direction.
    eVAControlInitStateKeplerianRAAN = 317
    # Semimajor Axis - half the length of the major (longest) axis of the orbital ellipse.
    eVAControlInitStateKeplerianSMA = 318
    # True Anomaly - the angle from the periapsis of the orbit to the spacecraft's position vector, measured in the direction of spacecraft motion.
    eVAControlInitStateKeplerianTA = 319
    # Argument of Periapsis - the angle measured in the direction of spacecraft motion, in the orbit plane, from the ascending node to the periapsis of the orbit.
    eVAControlInitStateKeplerianW = 320
    # Radiation Pressure (Albedo/Thermal) Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of central body radiation, used for central body radiation (albedo / thermal pressure) calculations.
    eVAControlInitStateRadiationPressureArea = 327
    # Radiation Pressure (Albedo/Thermal) Coefficient (Ck) - the reflectivity of the spacecraft used for central body radiation pressure (albedo / thermal pressure) calculations, where 2.0 is fully reflective and 1.0 is not reflective at all.
    eVAControlInitStateCk = 328
    # Velocity Azimuth - the angle in the spacecraft local horizontal plane between the projection of the velocity vector onto that plane and the local +Z direction measured as positive in the clockwise direction from north.
    eVAControlInitStateSphericalAz = 329
    # Declination - the angle from the X-Y plane of the coordinate system to the spacecraft position vector.
    eVAControlInitStateSphericalDec = 330
    # Horizontal Flight Path Angle - the complement of the angle between the spacecraft velocity vector and the radius vector (90 deg minus the vertical flight path angle).
    eVAControlInitStateSphericalHorizFPA = 331
    # Right Ascension - angle measured in the inertial equatorial plane from the inertial X axis in a right-handed sense about the inertial Z axis to the spacecraft position vector.
    eVAControlInitStateSphericalRA = 332
    # Radius Magnitude - the magnitude of the spacecraft position vector.
    eVAControlInitStateSphericalRMag = 333
    # Velocity Magnitude - the magnitude of the spacecraft velocity vector.
    eVAControlInitStateSphericalVMag = 334
    # Solar Radiation Pressure (Spherical) Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of solar radiation, used for solar radiation calculations.
    eVAControlInitStateSRPArea = 335
    # Tank Pressure - the fuel tank pressure.
    eVAControlInitStateTankPressure = 336
    # Tank Temperature - the temperature of the fuel tank.
    eVAControlInitStateTankTemp = 337
    # Declination of Incoming Asymptote - the declination of the incoming asymptote in the selected coordinate system.
    eVAControlInitStateTargetVecInAsympDec = 338
    # Right Ascension of Incoming Asymptote - the right ascension of the hyperbolic incoming asymptote in the selected coordinate system.
    eVAControlInitStateTargetVecInAsympRA = 339
    # Velocity Azimuth at Periapsis - the inertial flight path azimuth of the trajectory measured at periapsis.
    eVAControlInitStateTargetVecInVelAzAtPeriapsis = 340
    # C3 Energy - the energy of the orbit, computed as - mu / a, where mu is the gravity constant of the central body and a is the semimajor axis.
    eVAControlInitStateTargetVecInC3 = 341
    # Radius of Periapsis - distance from the center of mass of the central body to the periapsis of the hyperbolic orbit.
    eVAControlInitStateTargetVecInRadOfPeriapsis = 342
    # True Anomaly - the angle from the periapsis of the orbit to the spacecraft's position vector, measured in the direction of spacecraft motion.
    eVAControlInitStateTargetVecInTrueAnomaly = 343
    # Declination of Outgoing Asymptote - the declination of the outgoing asymptote in the selected coordinate system.
    eVAControlInitStateTargetVecOutAsympDec = 344
    # Right Ascension of Outgoing Asymptote - the right ascension of the hyperbolic outgoing asymptote in the selected coordinate system.
    eVAControlInitStateTargetVecOutAsympRA = 345
    # Velocity Azimuth at Periapsis - the inertial flight path azimuth of the trajectory measured at periapsis.
    eVAControlInitStateTargetVecOutVelAzAtPeriapsis = 346
    # C3 Energy - the energy of the orbit, computed as - mu / a, where mu is the gravity constant of the central body and a is the semimajor axis.
    eVAControlInitStateTargetVecOutC3 = 347
    # Radius of Periapsis - distance from the center of mass of the central body to the periapsis of the hyperbolic orbit.
    eVAControlInitStateTargetVecOutRadOfPeriapsis = 348
    # True Anomaly - the angle from the periapsis of the orbit to the spacecraft's position vector, measured in the direction of spacecraft motion.
    eVAControlInitStateTargetVecOutTrueAnomaly = 349
    # Maximum Fuel Mass - the maximum fuel mass of the spacecraft; this parameter specifically applies to Finite Maneuver segments that are being executed in Backward Sequences.
    eVAControlInitStateMaxFuelMass = 350
    # Tank Volume - the volume of the fuel tank.
    eVAControlInitStateTankVolume = 351
    # G - Magnitude of orbital angular momentum, sqrt(GM * p).
    eVAControlInitStateDelaunayG = 352
    # H - Z component of orbital angular momentum, G cos(inc).
    eVAControlInitStateDelaunayH = 353
    # Inclination - The angle between the angular momentum vector (perpendicular to the plane of the orbit) and the inertial Z axis.
    eVAControlInitStateDelaunayInc = 354
    # L - Related to two-body orbital energy, sqrt(GM * a)
    eVAControlInitStateDelaunayL = 355
    # Mean Anomaly - The angle from the eccentricity vector to a position vector where the satellite would be if it were always moving at its average angular rate.
    eVAControlInitStateDelaunayMeanAnomaly = 356
    # Right Ascension of Ascending Node - The angle from the inertial X axis to the ascending node measured in a right-handed sense about the inertial Z axis in the equatorial plane.
    eVAControlInitStateDelaunayRAAN = 357
    # Semi-latus Rectum - Distance from focus to orbit at true anomaly of 90 degrees
    eVAControlInitStateDelaunaySemiLatusRectum = 358
    # Semimajor Axis - Half the length of the major (longest) axis of the orbital ellipse.
    eVAControlInitStateDelaunaySMA = 359
    # Argument of Periapsis - The angle from the ascending node to the eccentricity vector measured in the direction of the satellite's motion and in the orbit plane.
    eVAControlInitStateDelaunayW = 360
    # H - With K, describe the shape and position of periapsis of the orbit, ecc * sin(RAAN + w)
    eVAControlInitStateEquinoctialH = 361
    # K - With H, describe the shape and position of periapsis of the orbit, ecc * cos(RAAN + w)
    eVAControlInitStateEquinoctialK = 362
    # Mean Longitude - RAAN + w + M
    eVAControlInitStateEquinoctialMeanLongitude = 363
    # Mean Motion - The number of orbits per day (86400 sec/period), based on assumed two-body motion.
    eVAControlInitStateEquinoctialMeanMotion = 364
    # P - With Q, describes the orientation of the orbit plane, tan(inc/2) * sin(RAAN)
    eVAControlInitStateEquinoctialP = 365
    # Q - With P, describes the orientation of the orbit plane, tan(inc/2) * cos(RAAN)
    eVAControlInitStateEquinoctialQ = 366
    # Semimajor Axis - Half the length of the major (longest) axis of the orbital ellipse.
    eVAControlInitStateEquinoctialSMA = 367
    # Altitude - The object's position above or below the reference ellipsoid. Altitude is measured along a normal to the surface of the reference ellipsoid.
    eVAControlInitStateMixedSphericalAltitude = 368
    # Azimuth - The angle in the satellite local horizontal plane between the projection of the inertial velocity vector onto this plane and the local north direction measured as positive in the clockwise direction.
    eVAControlInitStateMixedSphericalAzimuth = 369
    # Horizontal Flight Path Angle - The complement of the angle between the inertial velocity vector and the radius vector.
    eVAControlInitStateMixedSphericalHorizFPA = 370
    # Latitude - The geodetic latitude of a point is the angle between the normal to the reference ellipsoid that passes through the satellite position and the equatorial plane.
    eVAControlInitStateMixedSphericalLatitude = 371
    # Longitude
    eVAControlInitStateMixedSphericalLongitude = 372
    # Vertical Flight Path Angle -  The angle between the inertial velocity vector and the radius vector.
    eVAControlInitStateMixedSphericalVerticalFPA = 373
    # Velocity Magnitude - The magnitude of the inertial velocity vector.
    eVAControlInitStateMixedSphericalVMag = 374
    # Vertical Flight Path Angle -  The angle between the inertial velocity vector and the radius vector.
    eVAControlInitStateSphericalVerticalFPA = 375
    # Apoapsis Altitude - Shape Parameter - Distance from the surface of the central body to the point of maximum radius in the orbit.
    eVAControlInitStateKeplerianApoapsisAltShape = 376
    # Apoapsis Altitude - Size Parameter - Distance from the surface of the central body to the point of maximum radius in the orbit.
    eVAControlInitStateKeplerianApoapsisAltSize = 377
    # Apoapsis Radius - Shape Parameter - Distance from the center of the central body to the point of maximum radius in the orbit.
    eVAControlInitStateKeplerianApoapsisRadShape = 378
    # Apoapsis Radius - Size Parameter - Distance from the center of the central body to the point of maximum radius in the orbit.
    eVAControlInitStateKeplerianApoapsisRadSize = 379
    # Argument of Latitude - The sum of the True Anomaly and the Argument of Perigee.
    eVAControlInitStateKeplerianArgLat = 380
    # Eccentric Anomaly - Angle measured with an origin at the center of the ellipse from the direction of perigee to a point on a circumscribing circle from which a line perpendicular to the SMA intersects the position of the satellite on the ellipse.
    eVAControlInitStateKeplerianEccAnomaly = 381
    # Longitude of Ascending Node - Longitude of the Ascending Node is the Earth-fixed longitude where the satellite has crossed the inertial equator from south to north based on an assumption of two-body motion.
    eVAControlInitStateKeplerianLAN = 382
    # Mean Anomaly - The angle from the eccentricity vector to a position vector where the satellite would be if it were always moving at its average angular rate.
    eVAControlInitStateKeplerianMeanAnomaly = 383
    # Mean Motion - The number of orbits per day (86400 sec/period), based on assumed two-body motion.
    eVAControlInitStateKeplerianMeanMotion = 384
    # Periapsis Altitude - Shape Parameter - Distance from the surface of the central body to the point of minimum radius in the orbit.
    eVAControlInitStateKeplerianPeriapsisAltShape = 385
    # Periapsis Altitude - Size Parameter - Distance from the surface of the central body to the point of minimum radius in the orbit.
    eVAControlInitStateKeplerianPeriapsisAltSize = 386
    # Periapsis Radius - Shape Parameter - Distance from the center of the central body to the point of minimum radius in the orbit.
    eVAControlInitStateKeplerianPeriapsisRadShape = 387
    # Periapsis Radius - Size Parameter - Distance from the surface of the central body to the point of minimum radius in the orbit.
    eVAControlInitStateKeplerianPeriapsisRadSize = 388
    # Period - The duration of one orbit, based on assumed two-body motion.
    eVAControlInitStateKeplerianPeriod = 389
    # Time Past Ascending Node - The elapsed time since the last ascending node crossing based on assumed two-body motion.
    eVAControlInitStateKeplerianTimePastAN = 390
    # Time Past Periapsis - The elapsed time since the last perigee passage based on assumed two-body motion.
    eVAControlInitStateKeplerianTimePastPeriapsis = 391

AgEVAControlInitState.eVAControlInitStateFuelMass.__doc__ = "Fuel Mass - the mass of the spacecraft propellant. Enter a value in the selected mass unit (e.g. kg)."
AgEVAControlInitState.eVAControlInitStateCartesianVx.__doc__ = "Vx Component - the X component of the spacecraft velocity vector."
AgEVAControlInitState.eVAControlInitStateCartesianVy.__doc__ = "Vy Component - the Y component of the spacecraft velocity vector."
AgEVAControlInitState.eVAControlInitStateCartesianVz.__doc__ = "Vz Component - the Z component of the spacecraft velocity vector."
AgEVAControlInitState.eVAControlInitStateCartesianX.__doc__ = "X Component - the X component of the spacecraft position vector."
AgEVAControlInitState.eVAControlInitStateCartesianY.__doc__ = "Y Component - the Y component of the spacecraft position vector."
AgEVAControlInitState.eVAControlInitStateCartesianZ.__doc__ = "Z Component - the Z component of the spacecraft position vector."
AgEVAControlInitState.eVAControlInitStateCd.__doc__ = "Drag Coefficient (Cd) - the dimensionless drag coefficient associated with the drag area."
AgEVAControlInitState.eVAControlInitStateCr.__doc__ = "Solar Radiation Pressure (Spherical) Coefficient (Cr) - the reflectivity of the spacecraft used for solar radiation pressure calculations, where 2.0 is fully reflective and 1.0 is not reflective at all."
AgEVAControlInitState.eVAControlInitStateDragArea.__doc__ = "Drag Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of motion, used for atmospheric drag calculations. Enter a value in the selected distance unit squared."
AgEVAControlInitState.eVAControlInitStateDryMass.__doc__ = "Dry Mass - the mass of the spacecraft exclusive of propellant. Enter a value in the selected mass unit (e.g. kg)."
AgEVAControlInitState.eVAControlInitStateEpoch.__doc__ = "Epoch - the orbit epoch."
AgEVAControlInitState.eVAControlInitStateFuelDensity.__doc__ = "Fuel Density - the density of the fuel tank."
AgEVAControlInitState.eVAControlInitStateK1.__doc__ = "GPS Solar Radiation Pressure K1 - if you are using a non-spherical SRP model, this field defines the model's K1 (scale) value."
AgEVAControlInitState.eVAControlInitStateK2.__doc__ = "GPS Solar Radiation Pressure K2 - if you are using a non-spherical SRP model, this field defines the model's K2 (Y bias) value."
AgEVAControlInitState.eVAControlInitStateKeplerianEcc.__doc__ = "Eccentricity - the ratio of the distance between the foci to the major axis of the orbital ellipse. Dimensionless."
AgEVAControlInitState.eVAControlInitStateKeplerianInc.__doc__ = "Inclination - the angle from the +Z axis of the coordinate system to the angular momentum vector of the spacecraft's orbit."
AgEVAControlInitState.eVAControlInitStateKeplerianRAAN.__doc__ = "Right Ascension of Ascending Node - the angle between the X direction of the coordinate system and the point where the orbit crosses the X-Y plane in the +Z direction."
AgEVAControlInitState.eVAControlInitStateKeplerianSMA.__doc__ = "Semimajor Axis - half the length of the major (longest) axis of the orbital ellipse."
AgEVAControlInitState.eVAControlInitStateKeplerianTA.__doc__ = "True Anomaly - the angle from the periapsis of the orbit to the spacecraft's position vector, measured in the direction of spacecraft motion."
AgEVAControlInitState.eVAControlInitStateKeplerianW.__doc__ = "Argument of Periapsis - the angle measured in the direction of spacecraft motion, in the orbit plane, from the ascending node to the periapsis of the orbit."
AgEVAControlInitState.eVAControlInitStateRadiationPressureArea.__doc__ = "Radiation Pressure (Albedo/Thermal) Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of central body radiation, used for central body radiation (albedo / thermal pressure) calculations."
AgEVAControlInitState.eVAControlInitStateCk.__doc__ = "Radiation Pressure (Albedo/Thermal) Coefficient (Ck) - the reflectivity of the spacecraft used for central body radiation pressure (albedo / thermal pressure) calculations, where 2.0 is fully reflective and 1.0 is not reflective at all."
AgEVAControlInitState.eVAControlInitStateSphericalAz.__doc__ = "Velocity Azimuth - the angle in the spacecraft local horizontal plane between the projection of the velocity vector onto that plane and the local +Z direction measured as positive in the clockwise direction from north."
AgEVAControlInitState.eVAControlInitStateSphericalDec.__doc__ = "Declination - the angle from the X-Y plane of the coordinate system to the spacecraft position vector."
AgEVAControlInitState.eVAControlInitStateSphericalHorizFPA.__doc__ = "Horizontal Flight Path Angle - the complement of the angle between the spacecraft velocity vector and the radius vector (90 deg minus the vertical flight path angle)."
AgEVAControlInitState.eVAControlInitStateSphericalRA.__doc__ = "Right Ascension - angle measured in the inertial equatorial plane from the inertial X axis in a right-handed sense about the inertial Z axis to the spacecraft position vector."
AgEVAControlInitState.eVAControlInitStateSphericalRMag.__doc__ = "Radius Magnitude - the magnitude of the spacecraft position vector."
AgEVAControlInitState.eVAControlInitStateSphericalVMag.__doc__ = "Velocity Magnitude - the magnitude of the spacecraft velocity vector."
AgEVAControlInitState.eVAControlInitStateSRPArea.__doc__ = "Solar Radiation Pressure (Spherical) Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of solar radiation, used for solar radiation calculations."
AgEVAControlInitState.eVAControlInitStateTankPressure.__doc__ = "Tank Pressure - the fuel tank pressure."
AgEVAControlInitState.eVAControlInitStateTankTemp.__doc__ = "Tank Temperature - the temperature of the fuel tank."
AgEVAControlInitState.eVAControlInitStateTargetVecInAsympDec.__doc__ = "Declination of Incoming Asymptote - the declination of the incoming asymptote in the selected coordinate system."
AgEVAControlInitState.eVAControlInitStateTargetVecInAsympRA.__doc__ = "Right Ascension of Incoming Asymptote - the right ascension of the hyperbolic incoming asymptote in the selected coordinate system."
AgEVAControlInitState.eVAControlInitStateTargetVecInVelAzAtPeriapsis.__doc__ = "Velocity Azimuth at Periapsis - the inertial flight path azimuth of the trajectory measured at periapsis."
AgEVAControlInitState.eVAControlInitStateTargetVecInC3.__doc__ = "C3 Energy - the energy of the orbit, computed as - mu / a, where mu is the gravity constant of the central body and a is the semimajor axis."
AgEVAControlInitState.eVAControlInitStateTargetVecInRadOfPeriapsis.__doc__ = "Radius of Periapsis - distance from the center of mass of the central body to the periapsis of the hyperbolic orbit."
AgEVAControlInitState.eVAControlInitStateTargetVecInTrueAnomaly.__doc__ = "True Anomaly - the angle from the periapsis of the orbit to the spacecraft's position vector, measured in the direction of spacecraft motion."
AgEVAControlInitState.eVAControlInitStateTargetVecOutAsympDec.__doc__ = "Declination of Outgoing Asymptote - the declination of the outgoing asymptote in the selected coordinate system."
AgEVAControlInitState.eVAControlInitStateTargetVecOutAsympRA.__doc__ = "Right Ascension of Outgoing Asymptote - the right ascension of the hyperbolic outgoing asymptote in the selected coordinate system."
AgEVAControlInitState.eVAControlInitStateTargetVecOutVelAzAtPeriapsis.__doc__ = "Velocity Azimuth at Periapsis - the inertial flight path azimuth of the trajectory measured at periapsis."
AgEVAControlInitState.eVAControlInitStateTargetVecOutC3.__doc__ = "C3 Energy - the energy of the orbit, computed as - mu / a, where mu is the gravity constant of the central body and a is the semimajor axis."
AgEVAControlInitState.eVAControlInitStateTargetVecOutRadOfPeriapsis.__doc__ = "Radius of Periapsis - distance from the center of mass of the central body to the periapsis of the hyperbolic orbit."
AgEVAControlInitState.eVAControlInitStateTargetVecOutTrueAnomaly.__doc__ = "True Anomaly - the angle from the periapsis of the orbit to the spacecraft's position vector, measured in the direction of spacecraft motion."
AgEVAControlInitState.eVAControlInitStateMaxFuelMass.__doc__ = "Maximum Fuel Mass - the maximum fuel mass of the spacecraft; this parameter specifically applies to Finite Maneuver segments that are being executed in Backward Sequences."
AgEVAControlInitState.eVAControlInitStateTankVolume.__doc__ = "Tank Volume - the volume of the fuel tank."
AgEVAControlInitState.eVAControlInitStateDelaunayG.__doc__ = "G - Magnitude of orbital angular momentum, sqrt(GM * p)."
AgEVAControlInitState.eVAControlInitStateDelaunayH.__doc__ = "H - Z component of orbital angular momentum, G cos(inc)."
AgEVAControlInitState.eVAControlInitStateDelaunayInc.__doc__ = "Inclination - The angle between the angular momentum vector (perpendicular to the plane of the orbit) and the inertial Z axis."
AgEVAControlInitState.eVAControlInitStateDelaunayL.__doc__ = "L - Related to two-body orbital energy, sqrt(GM * a)"
AgEVAControlInitState.eVAControlInitStateDelaunayMeanAnomaly.__doc__ = "Mean Anomaly - The angle from the eccentricity vector to a position vector where the satellite would be if it were always moving at its average angular rate."
AgEVAControlInitState.eVAControlInitStateDelaunayRAAN.__doc__ = "Right Ascension of Ascending Node - The angle from the inertial X axis to the ascending node measured in a right-handed sense about the inertial Z axis in the equatorial plane."
AgEVAControlInitState.eVAControlInitStateDelaunaySemiLatusRectum.__doc__ = "Semi-latus Rectum - Distance from focus to orbit at true anomaly of 90 degrees"
AgEVAControlInitState.eVAControlInitStateDelaunaySMA.__doc__ = "Semimajor Axis - Half the length of the major (longest) axis of the orbital ellipse."
AgEVAControlInitState.eVAControlInitStateDelaunayW.__doc__ = "Argument of Periapsis - The angle from the ascending node to the eccentricity vector measured in the direction of the satellite's motion and in the orbit plane."
AgEVAControlInitState.eVAControlInitStateEquinoctialH.__doc__ = "H - With K, describe the shape and position of periapsis of the orbit, ecc * sin(RAAN + w)"
AgEVAControlInitState.eVAControlInitStateEquinoctialK.__doc__ = "K - With H, describe the shape and position of periapsis of the orbit, ecc * cos(RAAN + w)"
AgEVAControlInitState.eVAControlInitStateEquinoctialMeanLongitude.__doc__ = "Mean Longitude - RAAN + w + M"
AgEVAControlInitState.eVAControlInitStateEquinoctialMeanMotion.__doc__ = "Mean Motion - The number of orbits per day (86400 sec/period), based on assumed two-body motion."
AgEVAControlInitState.eVAControlInitStateEquinoctialP.__doc__ = "P - With Q, describes the orientation of the orbit plane, tan(inc/2) * sin(RAAN)"
AgEVAControlInitState.eVAControlInitStateEquinoctialQ.__doc__ = "Q - With P, describes the orientation of the orbit plane, tan(inc/2) * cos(RAAN)"
AgEVAControlInitState.eVAControlInitStateEquinoctialSMA.__doc__ = "Semimajor Axis - Half the length of the major (longest) axis of the orbital ellipse."
AgEVAControlInitState.eVAControlInitStateMixedSphericalAltitude.__doc__ = "Altitude - The object's position above or below the reference ellipsoid. Altitude is measured along a normal to the surface of the reference ellipsoid."
AgEVAControlInitState.eVAControlInitStateMixedSphericalAzimuth.__doc__ = "Azimuth - The angle in the satellite local horizontal plane between the projection of the inertial velocity vector onto this plane and the local north direction measured as positive in the clockwise direction."
AgEVAControlInitState.eVAControlInitStateMixedSphericalHorizFPA.__doc__ = "Horizontal Flight Path Angle - The complement of the angle between the inertial velocity vector and the radius vector."
AgEVAControlInitState.eVAControlInitStateMixedSphericalLatitude.__doc__ = "Latitude - The geodetic latitude of a point is the angle between the normal to the reference ellipsoid that passes through the satellite position and the equatorial plane."
AgEVAControlInitState.eVAControlInitStateMixedSphericalLongitude.__doc__ = "Longitude"
AgEVAControlInitState.eVAControlInitStateMixedSphericalVerticalFPA.__doc__ = "Vertical Flight Path Angle -  The angle between the inertial velocity vector and the radius vector."
AgEVAControlInitState.eVAControlInitStateMixedSphericalVMag.__doc__ = "Velocity Magnitude - The magnitude of the inertial velocity vector."
AgEVAControlInitState.eVAControlInitStateSphericalVerticalFPA.__doc__ = "Vertical Flight Path Angle -  The angle between the inertial velocity vector and the radius vector."
AgEVAControlInitState.eVAControlInitStateKeplerianApoapsisAltShape.__doc__ = "Apoapsis Altitude - Shape Parameter - Distance from the surface of the central body to the point of maximum radius in the orbit."
AgEVAControlInitState.eVAControlInitStateKeplerianApoapsisAltSize.__doc__ = "Apoapsis Altitude - Size Parameter - Distance from the surface of the central body to the point of maximum radius in the orbit."
AgEVAControlInitState.eVAControlInitStateKeplerianApoapsisRadShape.__doc__ = "Apoapsis Radius - Shape Parameter - Distance from the center of the central body to the point of maximum radius in the orbit."
AgEVAControlInitState.eVAControlInitStateKeplerianApoapsisRadSize.__doc__ = "Apoapsis Radius - Size Parameter - Distance from the center of the central body to the point of maximum radius in the orbit."
AgEVAControlInitState.eVAControlInitStateKeplerianArgLat.__doc__ = "Argument of Latitude - The sum of the True Anomaly and the Argument of Perigee."
AgEVAControlInitState.eVAControlInitStateKeplerianEccAnomaly.__doc__ = "Eccentric Anomaly - Angle measured with an origin at the center of the ellipse from the direction of perigee to a point on a circumscribing circle from which a line perpendicular to the SMA intersects the position of the satellite on the ellipse."
AgEVAControlInitState.eVAControlInitStateKeplerianLAN.__doc__ = "Longitude of Ascending Node - Longitude of the Ascending Node is the Earth-fixed longitude where the satellite has crossed the inertial equator from south to north based on an assumption of two-body motion."
AgEVAControlInitState.eVAControlInitStateKeplerianMeanAnomaly.__doc__ = "Mean Anomaly - The angle from the eccentricity vector to a position vector where the satellite would be if it were always moving at its average angular rate."
AgEVAControlInitState.eVAControlInitStateKeplerianMeanMotion.__doc__ = "Mean Motion - The number of orbits per day (86400 sec/period), based on assumed two-body motion."
AgEVAControlInitState.eVAControlInitStateKeplerianPeriapsisAltShape.__doc__ = "Periapsis Altitude - Shape Parameter - Distance from the surface of the central body to the point of minimum radius in the orbit."
AgEVAControlInitState.eVAControlInitStateKeplerianPeriapsisAltSize.__doc__ = "Periapsis Altitude - Size Parameter - Distance from the surface of the central body to the point of minimum radius in the orbit."
AgEVAControlInitState.eVAControlInitStateKeplerianPeriapsisRadShape.__doc__ = "Periapsis Radius - Shape Parameter - Distance from the center of the central body to the point of minimum radius in the orbit."
AgEVAControlInitState.eVAControlInitStateKeplerianPeriapsisRadSize.__doc__ = "Periapsis Radius - Size Parameter - Distance from the surface of the central body to the point of minimum radius in the orbit."
AgEVAControlInitState.eVAControlInitStateKeplerianPeriod.__doc__ = "Period - The duration of one orbit, based on assumed two-body motion."
AgEVAControlInitState.eVAControlInitStateKeplerianTimePastAN.__doc__ = "Time Past Ascending Node - The elapsed time since the last ascending node crossing based on assumed two-body motion."
AgEVAControlInitState.eVAControlInitStateKeplerianTimePastPeriapsis.__doc__ = "Time Past Periapsis - The elapsed time since the last perigee passage based on assumed two-body motion."

agcls.AgTypeNameMap["AgEVAControlInitState"] = AgEVAControlInitState

class AgEVAControlManeuver(IntEnum):
    """Maneuver segment properties that can be selected as control parameters for a Target Sequence."""
    # The Cartesian X component of the thrust vector.
    eVAControlManeuverFiniteCartesianX = 400
    # The Cartesian Y component of the thrust vector.
    eVAControlManeuverFiniteCartesianY = 401
    # The Cartesian Z component of the thrust vector.
    eVAControlManeuverFiniteCartesianZ = 402
    # The Euler A (Phi) component of the rotation from the reference axes to the body frame.
    eVAControlManeuverFiniteEulerAngles1 = 403
    # The Euler B (Theta) component of the rotation from the reference axes to the body frame.
    eVAControlManeuverFiniteEulerAngles2 = 404
    # The Euler C (Psi) component of the rotation from the reference axes to the body frame.
    eVAControlManeuverFiniteEulerAngles3 = 405
    # The spherical azimuth component of the thrust vector.
    eVAControlManeuverFiniteSphericalAz = 406
    # The spherical elevation component of the thrust vector.
    eVAControlManeuverFiniteSphericalElev = 407
    # The Cartesian X component of the thrust vector.
    eVAControlManeuverImpulsiveCartesianX = 408
    # The Cartesian Y component of the thrust vector.
    eVAControlManeuverImpulsiveCartesianY = 409
    # The Cartesian Z component of the thrust vector.
    eVAControlManeuverImpulsiveCartesianZ = 410
    # The Euler A (Phi) component of the rotation from the reference axes to the body frame.
    eVAControlManeuverImpulsiveEulerAngles1 = 411
    # The Euler B (Theta) component of the rotation from the reference axes to the body frame.
    eVAControlManeuverImpulsiveEulerAngles2 = 412
    # The Euler C (Psi) component of the rotation from the reference axes to the body frame.
    eVAControlManeuverImpulsiveEulerAngles3 = 413
    # The spherical azimuth component of the thrust vector.
    eVAControlManeuverImpulsiveSphericalAz = 414
    # The spherical elevation component of the thrust vector.
    eVAControlManeuverImpulsiveSphericalElev = 415
    # The spherical magnitude component of the thrust vector.
    eVAControlManeuverImpulsiveSphericalMag = 416
    # The burn center bias of the thrust.
    eVAControlManeuverFiniteBurnCenterBias = 417
    # The thrust efficiency value.
    eVAControlManeuverFiniteThrustEfficiency = 418
    # The time varying azimuth polynomial constant term.
    eVAControlManeuverFiniteAz0 = 419
    # The time varying azimuth polynomial linear term.
    eVAControlManeuverFiniteAz1 = 420
    # The time varying azimuth polynomial quadratic term.
    eVAControlManeuverFiniteAz2 = 421
    # The time varying azimuth polynomial cubic term.
    eVAControlManeuverFiniteAz3 = 422
    # The time varying azimuth polynomial quartic term.
    eVAControlManeuverFiniteAz4 = 423
    # The time varying azimuth sine amplitude term.
    eVAControlManeuverFiniteAzA = 424
    # The time varying azimuth sine frequency term.
    eVAControlManeuverFiniteAzF = 425
    # The time varying azimuth sine phase term.
    eVAControlManeuverFiniteAzP = 426
    # The time varying elevation polynomial constant term.
    eVAControlManeuverFiniteEl0 = 427
    # The time varying elevation polynomial linear term.
    eVAControlManeuverFiniteEl1 = 428
    # The time varying elevation polynomial quadratic term.
    eVAControlManeuverFiniteEl2 = 429
    # The time varying elevation polynomial cubic term.
    eVAControlManeuverFiniteEl3 = 430
    # The time varying elevation polynomial quartic term.
    eVAControlManeuverFiniteEl4 = 431
    # The time varying elevation sine amplitude term.
    eVAControlManeuverFiniteElA = 432
    # The time varying elevation sine frequency term.
    eVAControlManeuverFiniteElF = 433
    # The time varying elevation sine phase term.
    eVAControlManeuverFiniteElP = 434

AgEVAControlManeuver.eVAControlManeuverFiniteCartesianX.__doc__ = "The Cartesian X component of the thrust vector."
AgEVAControlManeuver.eVAControlManeuverFiniteCartesianY.__doc__ = "The Cartesian Y component of the thrust vector."
AgEVAControlManeuver.eVAControlManeuverFiniteCartesianZ.__doc__ = "The Cartesian Z component of the thrust vector."
AgEVAControlManeuver.eVAControlManeuverFiniteEulerAngles1.__doc__ = "The Euler A (Phi) component of the rotation from the reference axes to the body frame."
AgEVAControlManeuver.eVAControlManeuverFiniteEulerAngles2.__doc__ = "The Euler B (Theta) component of the rotation from the reference axes to the body frame."
AgEVAControlManeuver.eVAControlManeuverFiniteEulerAngles3.__doc__ = "The Euler C (Psi) component of the rotation from the reference axes to the body frame."
AgEVAControlManeuver.eVAControlManeuverFiniteSphericalAz.__doc__ = "The spherical azimuth component of the thrust vector."
AgEVAControlManeuver.eVAControlManeuverFiniteSphericalElev.__doc__ = "The spherical elevation component of the thrust vector."
AgEVAControlManeuver.eVAControlManeuverImpulsiveCartesianX.__doc__ = "The Cartesian X component of the thrust vector."
AgEVAControlManeuver.eVAControlManeuverImpulsiveCartesianY.__doc__ = "The Cartesian Y component of the thrust vector."
AgEVAControlManeuver.eVAControlManeuverImpulsiveCartesianZ.__doc__ = "The Cartesian Z component of the thrust vector."
AgEVAControlManeuver.eVAControlManeuverImpulsiveEulerAngles1.__doc__ = "The Euler A (Phi) component of the rotation from the reference axes to the body frame."
AgEVAControlManeuver.eVAControlManeuverImpulsiveEulerAngles2.__doc__ = "The Euler B (Theta) component of the rotation from the reference axes to the body frame."
AgEVAControlManeuver.eVAControlManeuverImpulsiveEulerAngles3.__doc__ = "The Euler C (Psi) component of the rotation from the reference axes to the body frame."
AgEVAControlManeuver.eVAControlManeuverImpulsiveSphericalAz.__doc__ = "The spherical azimuth component of the thrust vector."
AgEVAControlManeuver.eVAControlManeuverImpulsiveSphericalElev.__doc__ = "The spherical elevation component of the thrust vector."
AgEVAControlManeuver.eVAControlManeuverImpulsiveSphericalMag.__doc__ = "The spherical magnitude component of the thrust vector."
AgEVAControlManeuver.eVAControlManeuverFiniteBurnCenterBias.__doc__ = "The burn center bias of the thrust."
AgEVAControlManeuver.eVAControlManeuverFiniteThrustEfficiency.__doc__ = "The thrust efficiency value."
AgEVAControlManeuver.eVAControlManeuverFiniteAz0.__doc__ = "The time varying azimuth polynomial constant term."
AgEVAControlManeuver.eVAControlManeuverFiniteAz1.__doc__ = "The time varying azimuth polynomial linear term."
AgEVAControlManeuver.eVAControlManeuverFiniteAz2.__doc__ = "The time varying azimuth polynomial quadratic term."
AgEVAControlManeuver.eVAControlManeuverFiniteAz3.__doc__ = "The time varying azimuth polynomial cubic term."
AgEVAControlManeuver.eVAControlManeuverFiniteAz4.__doc__ = "The time varying azimuth polynomial quartic term."
AgEVAControlManeuver.eVAControlManeuverFiniteAzA.__doc__ = "The time varying azimuth sine amplitude term."
AgEVAControlManeuver.eVAControlManeuverFiniteAzF.__doc__ = "The time varying azimuth sine frequency term."
AgEVAControlManeuver.eVAControlManeuverFiniteAzP.__doc__ = "The time varying azimuth sine phase term."
AgEVAControlManeuver.eVAControlManeuverFiniteEl0.__doc__ = "The time varying elevation polynomial constant term."
AgEVAControlManeuver.eVAControlManeuverFiniteEl1.__doc__ = "The time varying elevation polynomial linear term."
AgEVAControlManeuver.eVAControlManeuverFiniteEl2.__doc__ = "The time varying elevation polynomial quadratic term."
AgEVAControlManeuver.eVAControlManeuverFiniteEl3.__doc__ = "The time varying elevation polynomial cubic term."
AgEVAControlManeuver.eVAControlManeuverFiniteEl4.__doc__ = "The time varying elevation polynomial quartic term."
AgEVAControlManeuver.eVAControlManeuverFiniteElA.__doc__ = "The time varying elevation sine amplitude term."
AgEVAControlManeuver.eVAControlManeuverFiniteElF.__doc__ = "The time varying elevation sine frequency term."
AgEVAControlManeuver.eVAControlManeuverFiniteElP.__doc__ = "The time varying elevation sine phase term."

agcls.AgTypeNameMap["AgEVAControlManeuver"] = AgEVAControlManeuver

class AgEVAControlLaunch(IntEnum):
    """Launch segment properties that can be selected as control parameters for a Target Sequence."""
    # The date and time of the launch.
    eVAControlLaunchEpoch = 500
    # The geodetic latitude of the launch location.
    eVAControlLaunchGeodeticLat = 501
    # The geodetic longitude of the launch location.
    eVAControlLaunchGeodeticLon = 502
    # The geodetic altitude of the launch location.
    eVAControlLaunchGeodeticAlt = 503
    # The geocentric latitude of the launch location.
    eVAControlLaunchGeocentricLat = 504
    # The geocentric longitude of the launch location.
    eVAControlLaunchGeocentricLon = 505
    # The geocentric radius of the launch location.
    eVAControlLaunchGeocentricRad = 506
    # The time of flight, from launch until burnout.
    eVAControlLaunchTimeOfFlight = 507
    # The geocentric latitude of the burnout point.
    eVAControlLaunchBurnoutGeocentricLat = 508
    # The geocentric longitude of the burnout point.
    eVAControlLaunchBurnoutGeocentricLon = 509
    # The geocentric radius of the burnout point.
    eVAControlLaunchBurnoutGeocentricRad = 510
    # The geodetic latitude of the burnout point.
    eVAControlLaunchBurnoutGeodeticLat = 511
    # The geodetic longitude of the burnout point.
    eVAControlLaunchBurnoutGeodeticLon = 512
    # The geodetic altitude of the burnout point.
    eVAControlLaunchBurnoutGeodeticAlt = 513
    # The geodetic azimuth of the launch trajectory.
    eVAControlLaunchBurnoutAzAltAz = 514
    # The geodetic downrange distance of the burnout point.
    eVAControlLaunchBurnoutAzAltDownrangeDist = 515
    # The geodetic altitude of the burnout point.
    eVAControlLaunchBurnoutAzAltAlt = 516
    # The geocentric azimuth of the launch trajectory.
    eVAControlLaunchBurnoutAzRadAz = 517
    # The geocentric downrange distance of the burnout point.
    eVAControlLaunchBurnoutAzRadDownrangeDist = 518
    # The geocentric radius of the burnout point.
    eVAControlLaunchBurnoutAzRadRad = 519
    # The burnout velocity in the fixed frame.
    eVAControlLaunchBurnoutFixedVelocity = 520
    # The burnout velocity in the inertial frame.
    eVAControlLaunchBurnoutInertialVelocity = 521
    # Inertial Velocity Azimuth - the angle from the projection of north in the local horizontal plane to the inertial velocity vector, right handed.
    eVAControlLaunchBurnoutInertialVelocityAzimuth = 522
    # Inertial Horizontal FPA - the angle from the local horizontal to the inertial velocity vector, positive towards radius. It is also 90 degrees minus vertical flight path angle.
    eVAControlLaunchBurnoutInertialHorizontalFPA = 523
    # Dry Mass - the mass of the spacecraft exclusive of propellant.
    eVAControlLaunchDryMass = 524
    # Drag Coefficient (Cd) - the dimensionless drag coefficient associated with the drag area.
    eVAControlLaunchCd = 525
    # Drag Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of motion, used for atmospheric drag calculations.
    eVAControlLaunchDragArea = 526
    # Solar Radiation Pressure (Spherical) Coefficient (Cr) - the reflectivity of the spacecraft used for solar radiation pressure calculations, where 2.0 is fully reflective and 1.0 is not reflective at all.
    eVAControlLaunchCr = 527
    # Solar Radiation Pressure (Spherical) Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of solar radiation, used for solar radiation calculations.
    eVAControlLaunchSRPArea = 528
    # Radiation Pressure (Albedo/Thermal) Coefficient (Ck) - the reflectivity of the spacecraft used for central body radiation pressure (albedo / thermal pressure) calculations, where 2.0 is fully reflective and 1.0 is not reflective at all.
    eVAControlLaunchCk = 529
    # Radiation Pressure (Albedo/Thermal) Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of central body radiation, used for central body radiation (albedo / thermal pressure) calculations.
    eVAControlLaunchRadiationPressureArea = 530
    # GPS Solar Radiation Pressure K1 - if you are using a non-spherical SRP model, this field defines the model's K1 (scale) value.
    eVAControlLaunchK1 = 531
    # GPS Solar Radiation Pressure K2 - if you are using a non-spherical SRP model, this field defines the model's K2 (scale) value.
    eVAControlLaunchK2 = 532
    # The fuel tank pressure.
    eVAControlLaunchTankPressure = 533
    # The volume of the fuel tank.
    eVAControlLaunchTankVolume = 534
    # The fuel tank temperature.
    eVAControlLaunchTankTemp = 535
    # The density of the fuel tank.
    eVAControlLaunchFuelDensity = 536
    # The mass of the spacecraft propellant.
    eVAControlLaunchFuelMass = 537
    # Maximum Fuel Mass - the maximum fuel mass of the spacecraft; this parameter specifically applies to Finite Maneuver segments that are being executed in Backward Sequences.
    eVAControlLaunchMaxFuelMass = 538

AgEVAControlLaunch.eVAControlLaunchEpoch.__doc__ = "The date and time of the launch."
AgEVAControlLaunch.eVAControlLaunchGeodeticLat.__doc__ = "The geodetic latitude of the launch location."
AgEVAControlLaunch.eVAControlLaunchGeodeticLon.__doc__ = "The geodetic longitude of the launch location."
AgEVAControlLaunch.eVAControlLaunchGeodeticAlt.__doc__ = "The geodetic altitude of the launch location."
AgEVAControlLaunch.eVAControlLaunchGeocentricLat.__doc__ = "The geocentric latitude of the launch location."
AgEVAControlLaunch.eVAControlLaunchGeocentricLon.__doc__ = "The geocentric longitude of the launch location."
AgEVAControlLaunch.eVAControlLaunchGeocentricRad.__doc__ = "The geocentric radius of the launch location."
AgEVAControlLaunch.eVAControlLaunchTimeOfFlight.__doc__ = "The time of flight, from launch until burnout."
AgEVAControlLaunch.eVAControlLaunchBurnoutGeocentricLat.__doc__ = "The geocentric latitude of the burnout point."
AgEVAControlLaunch.eVAControlLaunchBurnoutGeocentricLon.__doc__ = "The geocentric longitude of the burnout point."
AgEVAControlLaunch.eVAControlLaunchBurnoutGeocentricRad.__doc__ = "The geocentric radius of the burnout point."
AgEVAControlLaunch.eVAControlLaunchBurnoutGeodeticLat.__doc__ = "The geodetic latitude of the burnout point."
AgEVAControlLaunch.eVAControlLaunchBurnoutGeodeticLon.__doc__ = "The geodetic longitude of the burnout point."
AgEVAControlLaunch.eVAControlLaunchBurnoutGeodeticAlt.__doc__ = "The geodetic altitude of the burnout point."
AgEVAControlLaunch.eVAControlLaunchBurnoutAzAltAz.__doc__ = "The geodetic azimuth of the launch trajectory."
AgEVAControlLaunch.eVAControlLaunchBurnoutAzAltDownrangeDist.__doc__ = "The geodetic downrange distance of the burnout point."
AgEVAControlLaunch.eVAControlLaunchBurnoutAzAltAlt.__doc__ = "The geodetic altitude of the burnout point."
AgEVAControlLaunch.eVAControlLaunchBurnoutAzRadAz.__doc__ = "The geocentric azimuth of the launch trajectory."
AgEVAControlLaunch.eVAControlLaunchBurnoutAzRadDownrangeDist.__doc__ = "The geocentric downrange distance of the burnout point."
AgEVAControlLaunch.eVAControlLaunchBurnoutAzRadRad.__doc__ = "The geocentric radius of the burnout point."
AgEVAControlLaunch.eVAControlLaunchBurnoutFixedVelocity.__doc__ = "The burnout velocity in the fixed frame."
AgEVAControlLaunch.eVAControlLaunchBurnoutInertialVelocity.__doc__ = "The burnout velocity in the inertial frame."
AgEVAControlLaunch.eVAControlLaunchBurnoutInertialVelocityAzimuth.__doc__ = "Inertial Velocity Azimuth - the angle from the projection of north in the local horizontal plane to the inertial velocity vector, right handed."
AgEVAControlLaunch.eVAControlLaunchBurnoutInertialHorizontalFPA.__doc__ = "Inertial Horizontal FPA - the angle from the local horizontal to the inertial velocity vector, positive towards radius. It is also 90 degrees minus vertical flight path angle."
AgEVAControlLaunch.eVAControlLaunchDryMass.__doc__ = "Dry Mass - the mass of the spacecraft exclusive of propellant."
AgEVAControlLaunch.eVAControlLaunchCd.__doc__ = "Drag Coefficient (Cd) - the dimensionless drag coefficient associated with the drag area."
AgEVAControlLaunch.eVAControlLaunchDragArea.__doc__ = "Drag Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of motion, used for atmospheric drag calculations."
AgEVAControlLaunch.eVAControlLaunchCr.__doc__ = "Solar Radiation Pressure (Spherical) Coefficient (Cr) - the reflectivity of the spacecraft used for solar radiation pressure calculations, where 2.0 is fully reflective and 1.0 is not reflective at all."
AgEVAControlLaunch.eVAControlLaunchSRPArea.__doc__ = "Solar Radiation Pressure (Spherical) Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of solar radiation, used for solar radiation calculations."
AgEVAControlLaunch.eVAControlLaunchCk.__doc__ = "Radiation Pressure (Albedo/Thermal) Coefficient (Ck) - the reflectivity of the spacecraft used for central body radiation pressure (albedo / thermal pressure) calculations, where 2.0 is fully reflective and 1.0 is not reflective at all."
AgEVAControlLaunch.eVAControlLaunchRadiationPressureArea.__doc__ = "Radiation Pressure (Albedo/Thermal) Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of central body radiation, used for central body radiation (albedo / thermal pressure) calculations."
AgEVAControlLaunch.eVAControlLaunchK1.__doc__ = "GPS Solar Radiation Pressure K1 - if you are using a non-spherical SRP model, this field defines the model's K1 (scale) value."
AgEVAControlLaunch.eVAControlLaunchK2.__doc__ = "GPS Solar Radiation Pressure K2 - if you are using a non-spherical SRP model, this field defines the model's K2 (scale) value."
AgEVAControlLaunch.eVAControlLaunchTankPressure.__doc__ = "The fuel tank pressure."
AgEVAControlLaunch.eVAControlLaunchTankVolume.__doc__ = "The volume of the fuel tank."
AgEVAControlLaunch.eVAControlLaunchTankTemp.__doc__ = "The fuel tank temperature."
AgEVAControlLaunch.eVAControlLaunchFuelDensity.__doc__ = "The density of the fuel tank."
AgEVAControlLaunch.eVAControlLaunchFuelMass.__doc__ = "The mass of the spacecraft propellant."
AgEVAControlLaunch.eVAControlLaunchMaxFuelMass.__doc__ = "Maximum Fuel Mass - the maximum fuel mass of the spacecraft; this parameter specifically applies to Finite Maneuver segments that are being executed in Backward Sequences."

agcls.AgTypeNameMap["AgEVAControlLaunch"] = AgEVAControlLaunch

class AgEVAControlAdvanced(IntEnum):
    """Propagate segment properties that can be selected as control parameters for a Target Sequence."""
    # The maximum propagation time, after which the segment will end regardless of whether the stopping conditions have been satisfied.
    eVAControlPropagateMaxPropTime = 600
    # The minimum propagation time - minimum time that must elapse from the beginning of the segment until Astrogator will begin checking stopping conditions for satisfaction.
    eVAControlPropagateMinPropTime = 601

AgEVAControlAdvanced.eVAControlPropagateMaxPropTime.__doc__ = "The maximum propagation time, after which the segment will end regardless of whether the stopping conditions have been satisfied."
AgEVAControlAdvanced.eVAControlPropagateMinPropTime.__doc__ = "The minimum propagation time - minimum time that must elapse from the beginning of the segment until Astrogator will begin checking stopping conditions for satisfaction."

agcls.AgTypeNameMap["AgEVAControlAdvanced"] = AgEVAControlAdvanced

class AgEVATargetSeqAction(IntEnum):
    """Action options for Target Sequence profiles."""
    # Run Nominal Sequence - runs the mission control sequence.
    eVATargetSeqActionRunNominalSeq = 0
    # Run Active Profiles - runs the mission control sequence allowing the active profiles to operate.
    eVATargetSeqActionRunActiveProfiles = 1
    # Run Active Profiles Once - runs the profile with corrections applied to control parameters.
    eVATargetSeqActionRunActiveProfilesOnce = 2

AgEVATargetSeqAction.eVATargetSeqActionRunNominalSeq.__doc__ = "Run Nominal Sequence - runs the mission control sequence."
AgEVATargetSeqAction.eVATargetSeqActionRunActiveProfiles.__doc__ = "Run Active Profiles - runs the mission control sequence allowing the active profiles to operate."
AgEVATargetSeqAction.eVATargetSeqActionRunActiveProfilesOnce.__doc__ = "Run Active Profiles Once - runs the profile with corrections applied to control parameters."

agcls.AgTypeNameMap["AgEVATargetSeqAction"] = AgEVATargetSeqAction

class AgEVAProfilesFinish(IntEnum):
    """Action options for Target Sequence profiles convergence."""
    # Run To Return And Continue - run to the first Return segment in the sequence, then pass control to the next segment after this target sequence. Often, the only Return is at the end of the target sequence.
    eVAProfilesFinishRunToReturnAndContinue = 0
    # Run To Return And Stop - run the target sequence to the first Return segment, and then stop running the MCS altogether.
    eVAProfilesFinishRunToReturnAndStop = 1
    # Stop - stop the MCS as soon as the target sequence has converged.
    eVAProfilesFinishStop = 2

AgEVAProfilesFinish.eVAProfilesFinishRunToReturnAndContinue.__doc__ = "Run To Return And Continue - run to the first Return segment in the sequence, then pass control to the next segment after this target sequence. Often, the only Return is at the end of the target sequence."
AgEVAProfilesFinish.eVAProfilesFinishRunToReturnAndStop.__doc__ = "Run To Return And Stop - run the target sequence to the first Return segment, and then stop running the MCS altogether."
AgEVAProfilesFinish.eVAProfilesFinishStop.__doc__ = "Stop - stop the MCS as soon as the target sequence has converged."

agcls.AgTypeNameMap["AgEVAProfilesFinish"] = AgEVAProfilesFinish

class AgEVAUpdateParam(IntEnum):
    """Spacecraft parameters that can be modified by an Update segment."""
    # Drag Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of motion, used for atmospheric drag calculations.
    eVAUpdateParamDragArea = 0
    # Solar Radiation Pressure (Spherical) Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of solar radiation, used for solar radiation calculations.
    eVAUpdateParamSRPArea = 1
    # Dry Mass - the mass of the spacecraft exclusive of propellant.
    eVAUpdateParamDryMass = 2
    # The mass of the spacecraft propellant.
    eVAUpdateParamFuelMass = 3
    # The density of the fuel tank.
    eVAUpdateParamFuelDensity = 4
    # The fuel tank pressure.
    eVAUpdateParamTankPressure = 5
    # The temperature of the fuel tank.
    eVAUpdateParamTankTemp = 6
    # Solar Radiation Pressure (Spherical) Coefficient (Cr) - the reflectivity of the spacecraft used for solar radiation pressure calculations, where 2.0 is fully reflective and 1.0 is not reflective at all.
    eVAUpdateParamCr = 7
    # Drag Coefficient (Cd) - the dimensionless drag coefficient associated with the drag area.
    eVAUpdateParamCd = 8
    # Radiation Pressure (Albedo/Thermal) Coefficient (Ck) - the reflectivity of the spacecraft used for central body radiation pressure (albedo / thermal pressure) calculations, where 2.0 is fully reflective and 1.0 is not reflective at all.
    eVAUpdateParamCk = 9
    # Radiation Pressure (Albedo/Thermal) Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of central body radiation, used for central body radiation (albedo / thermal pressure) calculations.
    eVAUpdateParamRadiationPressureArea = 10

AgEVAUpdateParam.eVAUpdateParamDragArea.__doc__ = "Drag Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of motion, used for atmospheric drag calculations."
AgEVAUpdateParam.eVAUpdateParamSRPArea.__doc__ = "Solar Radiation Pressure (Spherical) Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of solar radiation, used for solar radiation calculations."
AgEVAUpdateParam.eVAUpdateParamDryMass.__doc__ = "Dry Mass - the mass of the spacecraft exclusive of propellant."
AgEVAUpdateParam.eVAUpdateParamFuelMass.__doc__ = "The mass of the spacecraft propellant."
AgEVAUpdateParam.eVAUpdateParamFuelDensity.__doc__ = "The density of the fuel tank."
AgEVAUpdateParam.eVAUpdateParamTankPressure.__doc__ = "The fuel tank pressure."
AgEVAUpdateParam.eVAUpdateParamTankTemp.__doc__ = "The temperature of the fuel tank."
AgEVAUpdateParam.eVAUpdateParamCr.__doc__ = "Solar Radiation Pressure (Spherical) Coefficient (Cr) - the reflectivity of the spacecraft used for solar radiation pressure calculations, where 2.0 is fully reflective and 1.0 is not reflective at all."
AgEVAUpdateParam.eVAUpdateParamCd.__doc__ = "Drag Coefficient (Cd) - the dimensionless drag coefficient associated with the drag area."
AgEVAUpdateParam.eVAUpdateParamCk.__doc__ = "Radiation Pressure (Albedo/Thermal) Coefficient (Ck) - the reflectivity of the spacecraft used for central body radiation pressure (albedo / thermal pressure) calculations, where 2.0 is fully reflective and 1.0 is not reflective at all."
AgEVAUpdateParam.eVAUpdateParamRadiationPressureArea.__doc__ = "Radiation Pressure (Albedo/Thermal) Area - the cross-sectional area of the spacecraft assumed perpendicular to the direction of central body radiation, used for central body radiation (albedo / thermal pressure) calculations."

agcls.AgTypeNameMap["AgEVAUpdateParam"] = AgEVAUpdateParam

class AgEVAUpdateAction(IntEnum):
    """Actions for the Update segment."""
    # No change in value - leave the current value for this parameter unchanged (ignoring any quantity that may appear in the Value column).
    eVAUpdateActionNoChange = 0
    # Add value - add the quantity entered in the Value column to the current value for this parameter.
    eVAUpdateActionAddValue = 1
    # Subtract value - subtract the quantity entered in the Value column from the current value for this parameter.
    eVAUpdateActionSubtractValue = 2
    # Set to new value - replace the current value for this parameter with the quantity entered in the Value column.
    eVAUpdateActionSetToNewValue = 3

AgEVAUpdateAction.eVAUpdateActionNoChange.__doc__ = "No change in value - leave the current value for this parameter unchanged (ignoring any quantity that may appear in the Value column)."
AgEVAUpdateAction.eVAUpdateActionAddValue.__doc__ = "Add value - add the quantity entered in the Value column to the current value for this parameter."
AgEVAUpdateAction.eVAUpdateActionSubtractValue.__doc__ = "Subtract value - subtract the quantity entered in the Value column from the current value for this parameter."
AgEVAUpdateAction.eVAUpdateActionSetToNewValue.__doc__ = "Set to new value - replace the current value for this parameter with the quantity entered in the Value column."

agcls.AgTypeNameMap["AgEVAUpdateAction"] = AgEVAUpdateAction

class AgEVAPressureMode(IntEnum):
    """Pressure Mode options."""
    # Blow-Down - pressure decreases as propellant is consumed and the volume occupied by the pressurant gas consequently increases. This is based on the ideal gas law.
    eVAPressureModeBlowDown = 0
    # Pressure-Regulated - constant pressure is maintained in the fuel tank through some pressurization mechanism as the propellant mass decreases.
    eVAPressureModePressureRegulated = 1

AgEVAPressureMode.eVAPressureModeBlowDown.__doc__ = "Blow-Down - pressure decreases as propellant is consumed and the volume occupied by the pressurant gas consequently increases. This is based on the ideal gas law."
AgEVAPressureMode.eVAPressureModePressureRegulated.__doc__ = "Pressure-Regulated - constant pressure is maintained in the fuel tank through some pressurization mechanism as the propellant mass decreases."

agcls.AgTypeNameMap["AgEVAPressureMode"] = AgEVAPressureMode

class AgEVAThrustType(IntEnum):
    """Thrust options."""
    # Affects Acceleration and Mass Flow Calculations - may represent an inefficiency in the propulsion tanks and feed lines.
    eVAThrustTypeAffectsAccelAndMassFlow = 0
    # Affects Acceleration Only - an efficiency of 0.98 means that only 98% of the fuel will be spent to get 98% thrust. For example, a thrust efficiency affecting acceleration only may represent some problem in the combustion chamber.
    eVAThrustTypeAffectsAccelOnly = 1

AgEVAThrustType.eVAThrustTypeAffectsAccelAndMassFlow.__doc__ = "Affects Acceleration and Mass Flow Calculations - may represent an inefficiency in the propulsion tanks and feed lines."
AgEVAThrustType.eVAThrustTypeAffectsAccelOnly.__doc__ = "Affects Acceleration Only - an efficiency of 0.98 means that only 98% of the fuel will be spent to get 98% thrust. For example, a thrust efficiency affecting acceleration only may represent some problem in the combustion chamber."

agcls.AgTypeNameMap["AgEVAThrustType"] = AgEVAThrustType

class AgEVAAttitudeUpdate(IntEnum):
    """Attitude Update."""
    # Update during burn - updated throughout the maneuver so as to maintain the required thrust direction. This forces the thrust vector to the specified direction at every instant throughout the burn.
    eVAAttitudeUpdateDuringBurn = 0
    # Inertial at ignition - specified by Attitude Control at ignition and remains the same throughout the maneuver. This fixes the thrust direction in the inertial direction calculated at the beginning of the burn and is used for inertially fixed spacecraft.
    eVAAttitudeUpdateInertialAtIgnition = 1
    # Inertial at start - specified by Attitude Control at the beginning of the maneuver segment and remains the same throughout the maneuver.
    eVAAttitudeUpdateInertialAtStart = 2

AgEVAAttitudeUpdate.eVAAttitudeUpdateDuringBurn.__doc__ = "Update during burn - updated throughout the maneuver so as to maintain the required thrust direction. This forces the thrust vector to the specified direction at every instant throughout the burn."
AgEVAAttitudeUpdate.eVAAttitudeUpdateInertialAtIgnition.__doc__ = "Inertial at ignition - specified by Attitude Control at ignition and remains the same throughout the maneuver. This fixes the thrust direction in the inertial direction calculated at the beginning of the burn and is used for inertially fixed spacecraft."
AgEVAAttitudeUpdate.eVAAttitudeUpdateInertialAtStart.__doc__ = "Inertial at start - specified by Attitude Control at the beginning of the maneuver segment and remains the same throughout the maneuver."

agcls.AgTypeNameMap["AgEVAAttitudeUpdate"] = AgEVAAttitudeUpdate

class AgEVAPropulsionMethod(IntEnum):
    """Propulsion method options."""
    # Engine Model - can be used to quickly model the firing of a single engine.
    eVAPropulsionMethodEngineModel = 0
    # Thruster Set - used to fire multiple engines simultaneously, and to simulate off-pulsing or complex engine pointing.
    eVAPropulsionMethodThrusterSet = 1

AgEVAPropulsionMethod.eVAPropulsionMethodEngineModel.__doc__ = "Engine Model - can be used to quickly model the firing of a single engine."
AgEVAPropulsionMethod.eVAPropulsionMethodThrusterSet.__doc__ = "Thruster Set - used to fire multiple engines simultaneously, and to simulate off-pulsing or complex engine pointing."

agcls.AgTypeNameMap["AgEVAPropulsionMethod"] = AgEVAPropulsionMethod

class AgEVACustomFunction(IntEnum):
    """Attitude definition options for other STK functions."""
    # Use attitude page definition for other STK functions - the actual attitude during the maneuver is ignored and the satellite is considered to always be in the attitude specified by the page for all other calculations in STK.
    eVAEnablePageDefinition = 0
    # Maneuver attitude will be used for the satellite during the time at the maneuver, and during the specified lead and trail times. This attitude will also show up in reports, graphs, sensor access calculations, and in the 3D Graphics window.
    eVAEnableManeuverAttitude = 1

AgEVACustomFunction.eVAEnablePageDefinition.__doc__ = "Use attitude page definition for other STK functions - the actual attitude during the maneuver is ignored and the satellite is considered to always be in the attitude specified by the page for all other calculations in STK."
AgEVACustomFunction.eVAEnableManeuverAttitude.__doc__ = "Maneuver attitude will be used for the satellite during the time at the maneuver, and during the specified lead and trail times. This attitude will also show up in reports, graphs, sensor access calculations, and in the 3D Graphics window."

agcls.AgTypeNameMap["AgEVACustomFunction"] = AgEVACustomFunction

class AgEVABodyAxis(IntEnum):
    """Attitude body axis options."""
    # The positive X engine acceleration direction.
    eVABodyAxisPlusX = 0
    # The positive Y engine acceleration direction.
    eVABodyAxisPlusY = 1
    # The positive Z engine acceleration direction.
    eVABodyAxisPlusZ = 2
    # The negative X engine acceleration direction.
    eVABodyAxisMinusX = 3
    # The negative Y engine acceleration direction.
    eVABodyAxisMinusY = 4
    # The negative Z engine acceleration direction.
    eVABodyAxisMinusZ = 5

AgEVABodyAxis.eVABodyAxisPlusX.__doc__ = "The positive X engine acceleration direction."
AgEVABodyAxis.eVABodyAxisPlusY.__doc__ = "The positive Y engine acceleration direction."
AgEVABodyAxis.eVABodyAxisPlusZ.__doc__ = "The positive Z engine acceleration direction."
AgEVABodyAxis.eVABodyAxisMinusX.__doc__ = "The negative X engine acceleration direction."
AgEVABodyAxis.eVABodyAxisMinusY.__doc__ = "The negative Y engine acceleration direction."
AgEVABodyAxis.eVABodyAxisMinusZ.__doc__ = "The negative Z engine acceleration direction."

agcls.AgTypeNameMap["AgEVABodyAxis"] = AgEVABodyAxis

class AgEVAConstraintSign(IntEnum):
    """Constraint vector sign options."""
    # Positive.
    eVAConstraintSignPlus = 0
    # Negative.
    eVAConstraintSignMinus = 1

AgEVAConstraintSign.eVAConstraintSignPlus.__doc__ = "Positive."
AgEVAConstraintSign.eVAConstraintSignMinus.__doc__ = "Negative."

agcls.AgTypeNameMap["AgEVAConstraintSign"] = AgEVAConstraintSign

class AgEVAAttitudeControl(IntEnum):
    """Attitude Control options."""
    # Along Velocity Vector (impulsive/finite) - the total thrust vector is aligned with the spacecraft's velocity vector.
    eVAAttitudeControlVelocityVector = 0
    # Anti-Velocity Vector (impulsive/finite) - the total thrust vector is opposite to the spacecraft's velocity vector.
    eVAAttitudeControlAntiVelocityVector = 1
    # Attitude (impulsive/finite) - the thrust vector direction is defined using Euler Angles or a Quaternion. 
    eVAAttitudeControlAttitude = 2
    # File (impulsive/finite) - uses an attitude file to set the thrust vector direction.
    eVAAttitudeControlFile = 3
    # Thrust Vector (impulsive/finite) - the total thrust vector is explicitly specified in Cartesian or spherical form with respect to the thrust axes.
    eVAAttitudeControlThrustVector = 4
    # Plugin (finite) - thrust vector direction is defined using a COM plugin.
    eVAAttitudeControlPlugin = 5
    # Time Varying (finite) - polynomial and sine representations for the azimuth and elevation of the thrust vector.
    eVAAttitudeControlTimeVarying = 6
    # Lagrange Interpolation (optimal finite, always set) - supports the 'Run current nodes' execution mode of the Optimal Finite Maneuver.
    eVAAttitudeControlLagrangeInterpolation = 7

AgEVAAttitudeControl.eVAAttitudeControlVelocityVector.__doc__ = "Along Velocity Vector (impulsive/finite) - the total thrust vector is aligned with the spacecraft's velocity vector."
AgEVAAttitudeControl.eVAAttitudeControlAntiVelocityVector.__doc__ = "Anti-Velocity Vector (impulsive/finite) - the total thrust vector is opposite to the spacecraft's velocity vector."
AgEVAAttitudeControl.eVAAttitudeControlAttitude.__doc__ = "Attitude (impulsive/finite) - the thrust vector direction is defined using Euler Angles or a Quaternion. "
AgEVAAttitudeControl.eVAAttitudeControlFile.__doc__ = "File (impulsive/finite) - uses an attitude file to set the thrust vector direction."
AgEVAAttitudeControl.eVAAttitudeControlThrustVector.__doc__ = "Thrust Vector (impulsive/finite) - the total thrust vector is explicitly specified in Cartesian or spherical form with respect to the thrust axes."
AgEVAAttitudeControl.eVAAttitudeControlPlugin.__doc__ = "Plugin (finite) - thrust vector direction is defined using a COM plugin."
AgEVAAttitudeControl.eVAAttitudeControlTimeVarying.__doc__ = "Time Varying (finite) - polynomial and sine representations for the azimuth and elevation of the thrust vector."
AgEVAAttitudeControl.eVAAttitudeControlLagrangeInterpolation.__doc__ = "Lagrange Interpolation (optimal finite, always set) - supports the 'Run current nodes' execution mode of the Optimal Finite Maneuver."

agcls.AgTypeNameMap["AgEVAAttitudeControl"] = AgEVAAttitudeControl

class AgEVAFollowJoin(IntEnum):
    """Joining options for the Follow segment."""
    # Specify Joining Conditions - specify joining conditions to define when the spacecraft will begin to follow the leader. Joining conditions will become apparent on a new tab - Joining.
    eVAFollowJoinSpecify = 0
    # Join at Beginning of Leader's Ephemeris - the spacecraft will follow the leader from the beginning of the leader's ephemeris.
    eVAFollowJoinAtBeginning = 1
    # Join at End of Leader's Ephemeris - the spacecraft will use the leader's final ephemeris point as the initial and final state of the Follow segment; the separation parameter will automatically be set to 'Separate at End of Leader's Ephemeris'.
    eVAFollowJoinAtEnd = 2
    # Join at Final Epoch of Previous Segment - the spacecraft will follow the leader from the final epoch at the end of the previous segment.
    eVAFollowJoinAtFinalEpochOfPreviousSeg = 3

AgEVAFollowJoin.eVAFollowJoinSpecify.__doc__ = "Specify Joining Conditions - specify joining conditions to define when the spacecraft will begin to follow the leader. Joining conditions will become apparent on a new tab - Joining."
AgEVAFollowJoin.eVAFollowJoinAtBeginning.__doc__ = "Join at Beginning of Leader's Ephemeris - the spacecraft will follow the leader from the beginning of the leader's ephemeris."
AgEVAFollowJoin.eVAFollowJoinAtEnd.__doc__ = "Join at End of Leader's Ephemeris - the spacecraft will use the leader's final ephemeris point as the initial and final state of the Follow segment; the separation parameter will automatically be set to 'Separate at End of Leader's Ephemeris'."
AgEVAFollowJoin.eVAFollowJoinAtFinalEpochOfPreviousSeg.__doc__ = "Join at Final Epoch of Previous Segment - the spacecraft will follow the leader from the final epoch at the end of the previous segment."

agcls.AgTypeNameMap["AgEVAFollowJoin"] = AgEVAFollowJoin

class AgEVAFollowSeparation(IntEnum):
    """Separation options for the Follow segment."""
    # Specify Separation Conditions - specify separation conditions to define when the spacecraft will stop following the leader. Separation conditions will become apparent on a new tab - Separation.
    eVAFollowSeparationSpecify = 0
    # Separate at End of Leader's Ephemeris - the spacecraft will follow the leader to the end of the leader's ephemeris and then separate.
    eVAFollowSeparationAtEndOfLeadersEphem = 1

AgEVAFollowSeparation.eVAFollowSeparationSpecify.__doc__ = "Specify Separation Conditions - specify separation conditions to define when the spacecraft will stop following the leader. Separation conditions will become apparent on a new tab - Separation."
AgEVAFollowSeparation.eVAFollowSeparationAtEndOfLeadersEphem.__doc__ = "Separate at End of Leader's Ephemeris - the spacecraft will follow the leader to the end of the leader's ephemeris and then separate."

agcls.AgTypeNameMap["AgEVAFollowSeparation"] = AgEVAFollowSeparation

class AgEVAFollowSpacecraftAndFuelTank(IntEnum):
    """Spacecraft parameter options for the Follow segment."""
    # Specify Spacecraft Configuration - manually define the spacecraft for this segment. Spacecraft physical parameters will become apparent on new tabs - Spacecraft Parameters and Fuel Tank.
    eVAFollowSpacecraftAndFuelTankSpecify = 0
    # Inherit Spacecraft Configuration From Previous Segment - the spacecraft will be defined by its configuration at the end of the previous segment. The configuration will not be changed by the Follow segment.
    eVAFollowSpacecraftAndFuelTankInherit = 1
    # Inherit Spacecraft Configuration From Leader - if leader is an Astrogator satellite, configuration will be defined by the leader's configuration.
    eVAFollowSpacecraftAndFuelTankLeader = 2

AgEVAFollowSpacecraftAndFuelTank.eVAFollowSpacecraftAndFuelTankSpecify.__doc__ = "Specify Spacecraft Configuration - manually define the spacecraft for this segment. Spacecraft physical parameters will become apparent on new tabs - Spacecraft Parameters and Fuel Tank."
AgEVAFollowSpacecraftAndFuelTank.eVAFollowSpacecraftAndFuelTankInherit.__doc__ = "Inherit Spacecraft Configuration From Previous Segment - the spacecraft will be defined by its configuration at the end of the previous segment. The configuration will not be changed by the Follow segment."
AgEVAFollowSpacecraftAndFuelTank.eVAFollowSpacecraftAndFuelTankLeader.__doc__ = "Inherit Spacecraft Configuration From Leader - if leader is an Astrogator satellite, configuration will be defined by the leader's configuration."

agcls.AgTypeNameMap["AgEVAFollowSpacecraftAndFuelTank"] = AgEVAFollowSpacecraftAndFuelTank

class AgEVABurnoutOptions(IntEnum):
    """Burnout options for the Launch segment."""
    # Use Fixed Velocity - the inclination of the final state of the launch segment is determined by the arc between the launch and insertion positions, and the horizontal flight path angle is set to zero.
    eVABurnoutOptionsFixedVelocity = 0
    # Use Inertial Velocity - the final state of the launch segment is solely and completely determined by the burnout position and velocity.
    eVABurnoutOptionsInertialVelocity = 1

AgEVABurnoutOptions.eVABurnoutOptionsFixedVelocity.__doc__ = "Use Fixed Velocity - the inclination of the final state of the launch segment is determined by the arc between the launch and insertion positions, and the horizontal flight path angle is set to zero."
AgEVABurnoutOptions.eVABurnoutOptionsInertialVelocity.__doc__ = "Use Inertial Velocity - the final state of the launch segment is solely and completely determined by the burnout position and velocity."

agcls.AgTypeNameMap["AgEVABurnoutOptions"] = AgEVABurnoutOptions

class AgEVABurnoutType(IntEnum):
    """Burnout point definition types for the Launch segment."""
    # Geocentric (Planetocentric) - the burnout point is measured from the center of mass of the Earth or other central body.
    eVABurnoutTypeGeocentric = 0
    # Geodetic (Planetodetic) - the burnout point is measured along the normal to the surface of an ellipsoid defined with reference to the Earth (or other central body).
    eVABurnoutTypeGeodetic = 1
    # Launch Az / Radius - the burnout point is defined in reference to distance downrange along an azimuth, measured from the center of mass of the Earth or other central body.
    eVABurnoutTypeLaunchAzRad = 2
    # Launch Az / Alt - the burnout point is defined in reference to distance downrange along an azimuth, measured from the surface of the Earth or other central body.
    eVABurnoutTypeLaunchAzAlt = 3
    # Central Body Fixed Cartesian - the burnout state is specified in the central-body-fixed Cartesian coordinate system.
    eVABurnoutTypeCBFCartesian = 4

AgEVABurnoutType.eVABurnoutTypeGeocentric.__doc__ = "Geocentric (Planetocentric) - the burnout point is measured from the center of mass of the Earth or other central body."
AgEVABurnoutType.eVABurnoutTypeGeodetic.__doc__ = "Geodetic (Planetodetic) - the burnout point is measured along the normal to the surface of an ellipsoid defined with reference to the Earth (or other central body)."
AgEVABurnoutType.eVABurnoutTypeLaunchAzRad.__doc__ = "Launch Az / Radius - the burnout point is defined in reference to distance downrange along an azimuth, measured from the center of mass of the Earth or other central body."
AgEVABurnoutType.eVABurnoutTypeLaunchAzAlt.__doc__ = "Launch Az / Alt - the burnout point is defined in reference to distance downrange along an azimuth, measured from the surface of the Earth or other central body."
AgEVABurnoutType.eVABurnoutTypeCBFCartesian.__doc__ = "Central Body Fixed Cartesian - the burnout state is specified in the central-body-fixed Cartesian coordinate system."

agcls.AgTypeNameMap["AgEVABurnoutType"] = AgEVABurnoutType

class AgEVAAscentType(IntEnum):
    """Ascent types for the Launch segment."""
    # Ellipse: Cubic Motion - the motion is computed on the basis of given positions and velocities.
    eVAAscentTypeEllipseCubicMotion = 0
    # Ellipse: Quartic Motion - the motion is computed on the basis of given positions and velocities and initial acceleration.
    eVAAscentTypeEllipseQuarticMotion = 1

AgEVAAscentType.eVAAscentTypeEllipseCubicMotion.__doc__ = "Ellipse: Cubic Motion - the motion is computed on the basis of given positions and velocities."
AgEVAAscentType.eVAAscentTypeEllipseQuarticMotion.__doc__ = "Ellipse: Quartic Motion - the motion is computed on the basis of given positions and velocities and initial acceleration."

agcls.AgTypeNameMap["AgEVAAscentType"] = AgEVAAscentType

class AgEVALaunchDisplaySystem(IntEnum):
    """Launch location coordinate types for the Launch segment."""
    # Geocentric (Planetocentric) - the location is measured from the center of mass of the Earth or other central body.
    eVADisplaySystemGeodetic = 0
    # Geodetic (Planetodetic) - the location is measured along the normal to the surface of an ellipsoid defined with reference to the Earth (or other central body).
    eVADisplaySystemGeocentric = 1

AgEVALaunchDisplaySystem.eVADisplaySystemGeodetic.__doc__ = "Geocentric (Planetocentric) - the location is measured from the center of mass of the Earth or other central body."
AgEVALaunchDisplaySystem.eVADisplaySystemGeocentric.__doc__ = "Geodetic (Planetodetic) - the location is measured along the normal to the surface of an ellipsoid defined with reference to the Earth (or other central body)."

agcls.AgTypeNameMap["AgEVALaunchDisplaySystem"] = AgEVALaunchDisplaySystem

class AgEVARunCode(IntEnum):
    """The run code returned after the MCS is run."""
    # Marching - a segment has run successfully.
    eVARunCodeMarching = 0
    # Profile Failure - a search profile failed to converge.
    eVARunCodeProfileFailure = 1
    # Error - encountered an error.
    eVARunCodeError = 2
    # Stopped - encountered a stop segment.
    eVARunCodeStopped = 3
    # Returned - encountered a return segment.
    eVARunCodeReturned = 4
    # Cancelled - cancelled by user.
    eVARunCodeCancelled = 5
    # Global Stop - hit a global stopping condition.
    eVARunCodeHitGlobalStop = 6

AgEVARunCode.eVARunCodeMarching.__doc__ = "Marching - a segment has run successfully."
AgEVARunCode.eVARunCodeProfileFailure.__doc__ = "Profile Failure - a search profile failed to converge."
AgEVARunCode.eVARunCodeError.__doc__ = "Error - encountered an error."
AgEVARunCode.eVARunCodeStopped.__doc__ = "Stopped - encountered a stop segment."
AgEVARunCode.eVARunCodeReturned.__doc__ = "Returned - encountered a return segment."
AgEVARunCode.eVARunCodeCancelled.__doc__ = "Cancelled - cancelled by user."
AgEVARunCode.eVARunCodeHitGlobalStop.__doc__ = "Global Stop - hit a global stopping condition."

agcls.AgTypeNameMap["AgEVARunCode"] = AgEVARunCode

class AgEVASequenceStateToPass(IntEnum):
    """State To Pass options for the Sequence segment."""
    # The initial state of the sequence.
    eVASequenceStateToPassInitial = 0
    # The final state of the sequence.
    eVASequenceStateToPassFinal = 1

AgEVASequenceStateToPass.eVASequenceStateToPassInitial.__doc__ = "The initial state of the sequence."
AgEVASequenceStateToPass.eVASequenceStateToPassFinal.__doc__ = "The final state of the sequence."

agcls.AgTypeNameMap["AgEVASequenceStateToPass"] = AgEVASequenceStateToPass

class AgEVAManeuverType(IntEnum):
    """Maneuver types for the maneuver segment."""
    # Impulsive - calculates a state by adding the defined delta-V vector to the velocity of the final state of the previous segment, adds this new state to the ephemeris, and passes it to the next segment.
    eVAManeuverTypeImpulsive = 0
    # Finite - effectively a Propagate segment with thrust. Like Propagate segments, each point calculated by the propagator is added to the ephemeris, and propagation continues until a stopping condition is met.
    eVAManeuverTypeFinite = 1
    # Optimal Finite
    eVAManeuverTypeOptimalFinite = 2

AgEVAManeuverType.eVAManeuverTypeImpulsive.__doc__ = "Impulsive - calculates a state by adding the defined delta-V vector to the velocity of the final state of the previous segment, adds this new state to the ephemeris, and passes it to the next segment."
AgEVAManeuverType.eVAManeuverTypeFinite.__doc__ = "Finite - effectively a Propagate segment with thrust. Like Propagate segments, each point calculated by the propagator is added to the ephemeris, and propagation continues until a stopping condition is met."
AgEVAManeuverType.eVAManeuverTypeOptimalFinite.__doc__ = "Optimal Finite"

agcls.AgTypeNameMap["AgEVAManeuverType"] = AgEVAManeuverType

class AgEVASegmentType(IntEnum):
    """Segment types."""
    # Initial State - can be used to define the initial conditions of your MCS, or of a subsequence within the MCS.
    eVASegmentTypeInitialState = 0
    # Launch - can be used to model a simple spacecraft launch from Earth or another central body.
    eVASegmentTypeLaunch = 1
    # Maneuver - can be used to model a spacecraft maneuver.
    eVASegmentTypeManeuver = 2
    # Follow - can be used to set the spacecraft to follow another vehicle (Satellite, Launch Vehicle, Missile, Aircraft, Ship, or Ground Vehicle) at a specified offset, and to separate from that vehicle upon meeting specified conditions.
    eVASegmentTypeFollow = 3
    # Hold - can be used to model landing or rendezvous operations by setting the spacecraft to maintain a fixed position in reference to another object or body, until meeting specified conditions.
    eVASegmentTypeHold = 4
    # Propagate - can be used to model the movement of the spacecraft along its current trajectory until meeting specified stopping conditions.
    eVASegmentTypePropagate = 5
    # Sequence - can be used to organize segments and define the nature of the results that are passed on to the next segment or sequence in the MCS.
    eVASegmentTypeSequence = 6
    # Return - can be used to control the execution of the Mission Control Sequence by returning control to its parent segment.
    eVASegmentTypeReturn = 7
    # Target Sequence - can be used to define maneuvers and propagations in terms of the goals they are intended to achieve.
    eVASegmentTypeTargetSequence = 8
    # Stop - can be used to control the execution of the Mission Control Sequence by halting execution of the MCS.
    eVASegmentTypeStop = 9
    # Update - can be used to modify some of the satellite properties to reflect changes that occur during the mission.
    eVASegmentTypeUpdate = 10
    # Backward Sequence - can be used to organize segments and define the nature of the results that are passed on to the next segment or sequence in the MCS.
    eVASegmentTypeBackwardSequence = 11
    # End - The End segment is a default segment of the MCS that functions similarly to a Return segment; it returns control to the beginning of the MCS. The End segment cannot be disabled or deleted, nor can any segments be inserted into the MCS after it.
    eVASegmentTypeEnd = 12

AgEVASegmentType.eVASegmentTypeInitialState.__doc__ = "Initial State - can be used to define the initial conditions of your MCS, or of a subsequence within the MCS."
AgEVASegmentType.eVASegmentTypeLaunch.__doc__ = "Launch - can be used to model a simple spacecraft launch from Earth or another central body."
AgEVASegmentType.eVASegmentTypeManeuver.__doc__ = "Maneuver - can be used to model a spacecraft maneuver."
AgEVASegmentType.eVASegmentTypeFollow.__doc__ = "Follow - can be used to set the spacecraft to follow another vehicle (Satellite, Launch Vehicle, Missile, Aircraft, Ship, or Ground Vehicle) at a specified offset, and to separate from that vehicle upon meeting specified conditions."
AgEVASegmentType.eVASegmentTypeHold.__doc__ = "Hold - can be used to model landing or rendezvous operations by setting the spacecraft to maintain a fixed position in reference to another object or body, until meeting specified conditions."
AgEVASegmentType.eVASegmentTypePropagate.__doc__ = "Propagate - can be used to model the movement of the spacecraft along its current trajectory until meeting specified stopping conditions."
AgEVASegmentType.eVASegmentTypeSequence.__doc__ = "Sequence - can be used to organize segments and define the nature of the results that are passed on to the next segment or sequence in the MCS."
AgEVASegmentType.eVASegmentTypeReturn.__doc__ = "Return - can be used to control the execution of the Mission Control Sequence by returning control to its parent segment."
AgEVASegmentType.eVASegmentTypeTargetSequence.__doc__ = "Target Sequence - can be used to define maneuvers and propagations in terms of the goals they are intended to achieve."
AgEVASegmentType.eVASegmentTypeStop.__doc__ = "Stop - can be used to control the execution of the Mission Control Sequence by halting execution of the MCS."
AgEVASegmentType.eVASegmentTypeUpdate.__doc__ = "Update - can be used to modify some of the satellite properties to reflect changes that occur during the mission."
AgEVASegmentType.eVASegmentTypeBackwardSequence.__doc__ = "Backward Sequence - can be used to organize segments and define the nature of the results that are passed on to the next segment or sequence in the MCS."
AgEVASegmentType.eVASegmentTypeEnd.__doc__ = "End - The End segment is a default segment of the MCS that functions similarly to a Return segment; it returns control to the beginning of the MCS. The End segment cannot be disabled or deleted, nor can any segments be inserted into the MCS after it."

agcls.AgTypeNameMap["AgEVASegmentType"] = AgEVASegmentType

class AgEVAElementType(IntEnum):
    """Types of orbit element sets."""
    # Cartesian - specifying an orbit by three position elements and three velocity elements in a rectangular coordinate system.
    eVAElementTypeCartesian = 0
    # Keplerian - the classical system, specifying an orbit by six elements describing its size, shape and three-dimensional orientation in space.
    eVAElementTypeKeplerian = 1
    # Spherical - a system in which positions are specified as a radial distance from the origin and two angles relative to a fundamental plane.
    eVAElementTypeSpherical = 3
    # Target Vector Incoming Asymptote - used for hyperbolic arrival trajectories.
    eVAElementTypeTargetVectorIncomingAsymptote = 4
    # Target Vector Outgoing Asymptote - used for hyperbolic departure trajectories.
    eVAElementTypeTargetVectorOutgoingAsymptote = 5
    # Mixed Spherical.
    eVAElementTypeMixedSpherical = 6
    # Delaunay.
    eVAElementTypeDelaunay = 7
    # Equinoctial.
    eVAElementTypeEquinoctial = 8
    # Geodetic.
    eVAElementTypeGeodetic = 9
    # BPlane.
    eVAElementTypeBPlane = 10

AgEVAElementType.eVAElementTypeCartesian.__doc__ = "Cartesian - specifying an orbit by three position elements and three velocity elements in a rectangular coordinate system."
AgEVAElementType.eVAElementTypeKeplerian.__doc__ = "Keplerian - the classical system, specifying an orbit by six elements describing its size, shape and three-dimensional orientation in space."
AgEVAElementType.eVAElementTypeSpherical.__doc__ = "Spherical - a system in which positions are specified as a radial distance from the origin and two angles relative to a fundamental plane."
AgEVAElementType.eVAElementTypeTargetVectorIncomingAsymptote.__doc__ = "Target Vector Incoming Asymptote - used for hyperbolic arrival trajectories."
AgEVAElementType.eVAElementTypeTargetVectorOutgoingAsymptote.__doc__ = "Target Vector Outgoing Asymptote - used for hyperbolic departure trajectories."
AgEVAElementType.eVAElementTypeMixedSpherical.__doc__ = "Mixed Spherical."
AgEVAElementType.eVAElementTypeDelaunay.__doc__ = "Delaunay."
AgEVAElementType.eVAElementTypeEquinoctial.__doc__ = "Equinoctial."
AgEVAElementType.eVAElementTypeGeodetic.__doc__ = "Geodetic."
AgEVAElementType.eVAElementTypeBPlane.__doc__ = "BPlane."

agcls.AgTypeNameMap["AgEVAElementType"] = AgEVAElementType

class AgEVALanguage(IntEnum):
    """Scripting language types for the Scripting Tool."""
    # VBScript.
    eVALanguageVBScript = 0
    # JScript.
    eVALanguageJScript = 1
    # MATLAB.
    eVALanguageMATLAB = 2

AgEVALanguage.eVALanguageVBScript.__doc__ = "VBScript."
AgEVALanguage.eVALanguageJScript.__doc__ = "JScript."
AgEVALanguage.eVALanguageMATLAB.__doc__ = "MATLAB."

agcls.AgTypeNameMap["AgEVALanguage"] = AgEVALanguage

class AgEVAStoppingCondition(IntEnum):
    """Type of stopping condition."""
    # Basic Stopping Condition.
    eVAStoppingConditionBasic = 0
    # Before Stopping Condition.
    eVAStoppingConditionBefore = 1
    # One Point Access Stopping Condition.
    eVAStoppingConditionOnePtAccess = 2
    # Lighting Stopping Condition.
    eVAStoppingConditionLighting = 3

AgEVAStoppingCondition.eVAStoppingConditionBasic.__doc__ = "Basic Stopping Condition."
AgEVAStoppingCondition.eVAStoppingConditionBefore.__doc__ = "Before Stopping Condition."
AgEVAStoppingCondition.eVAStoppingConditionOnePtAccess.__doc__ = "One Point Access Stopping Condition."
AgEVAStoppingCondition.eVAStoppingConditionLighting.__doc__ = "Lighting Stopping Condition."

agcls.AgTypeNameMap["AgEVAStoppingCondition"] = AgEVAStoppingCondition

class AgEVAClearEphemerisDirection(IntEnum):
    """Direction in which to clear ephemeris."""
    # Clear ephemeris before selected time or state.
    eVAClearEphemerisBefore = -1
    # Do not clear ephemeris.
    eVAClearEphemerisNoClear = 0
    # Clear ephemeris after selected time or state.
    eVAClearEphemerisAfter = 1

AgEVAClearEphemerisDirection.eVAClearEphemerisBefore.__doc__ = "Clear ephemeris before selected time or state."
AgEVAClearEphemerisDirection.eVAClearEphemerisNoClear.__doc__ = "Do not clear ephemeris."
AgEVAClearEphemerisDirection.eVAClearEphemerisAfter.__doc__ = "Clear ephemeris after selected time or state."

agcls.AgTypeNameMap["AgEVAClearEphemerisDirection"] = AgEVAClearEphemerisDirection

class AgEVAProfileInsertDirection(IntEnum):
    """Direction to insert profile."""
    # Insert profile before reference profile.
    eVAProfileInsertBefore = 0
    # Insert profile after reference profile.
    eVAProfileInsertAfter = 1

AgEVAProfileInsertDirection.eVAProfileInsertBefore.__doc__ = "Insert profile before reference profile."
AgEVAProfileInsertDirection.eVAProfileInsertAfter.__doc__ = "Insert profile after reference profile."

agcls.AgTypeNameMap["AgEVAProfileInsertDirection"] = AgEVAProfileInsertDirection

class AgEVARootFindingAlgorithm(IntEnum):
    """Root-finding algorithms."""
    # Secant method.
    eVASecantMethod = 0
    # Newton-Raphson method.
    eVANewtonRaphsonMethod = 1

AgEVARootFindingAlgorithm.eVASecantMethod.__doc__ = "Secant method."
AgEVARootFindingAlgorithm.eVANewtonRaphsonMethod.__doc__ = "Newton-Raphson method."

agcls.AgTypeNameMap["AgEVARootFindingAlgorithm"] = AgEVARootFindingAlgorithm

class AgEVAScriptingParameterType(IntEnum):
    """Scripting Tool parameter type."""
    # Double.
    eVAScriptingParameterTypeDouble = 0
    # Quantity.
    eVAScriptingParameterTypeQuantity = 1
    # Date.
    eVAScriptingParameterTypeDate = 2
    # String.
    eVAScriptingParameterTypeString = 3
    # Boolean.
    eVAScriptingParameterTypeBoolean = 4
    # Integer.
    eVAScriptingParameterTypeInteger = 5
    # Enumeration.
    eVAScriptingParameterTypeEnumeration = 6

AgEVAScriptingParameterType.eVAScriptingParameterTypeDouble.__doc__ = "Double."
AgEVAScriptingParameterType.eVAScriptingParameterTypeQuantity.__doc__ = "Quantity."
AgEVAScriptingParameterType.eVAScriptingParameterTypeDate.__doc__ = "Date."
AgEVAScriptingParameterType.eVAScriptingParameterTypeString.__doc__ = "String."
AgEVAScriptingParameterType.eVAScriptingParameterTypeBoolean.__doc__ = "Boolean."
AgEVAScriptingParameterType.eVAScriptingParameterTypeInteger.__doc__ = "Integer."
AgEVAScriptingParameterType.eVAScriptingParameterTypeEnumeration.__doc__ = "Enumeration."

agcls.AgTypeNameMap["AgEVAScriptingParameterType"] = AgEVAScriptingParameterType

class AgEVASNOPTGoal(IntEnum):
    """The Goal types for a SNOPT profile."""
    # Minimize
    eVASNOPTGoalMinimize = 0
    # Bound
    eVASNOPTGoalBound = 1

AgEVASNOPTGoal.eVASNOPTGoalMinimize.__doc__ = "Minimize"
AgEVASNOPTGoal.eVASNOPTGoalBound.__doc__ = "Bound"

agcls.AgTypeNameMap["AgEVASNOPTGoal"] = AgEVASNOPTGoal

class AgEVAIPOPTGoal(IntEnum):
    """The Goal types for a IPOPT profile."""
    # Minimize
    eVAIPOPTGoalMinimize = 0
    # Bound
    eVAIPOPTGoalBound = 1

AgEVAIPOPTGoal.eVAIPOPTGoalMinimize.__doc__ = "Minimize"
AgEVAIPOPTGoal.eVAIPOPTGoalBound.__doc__ = "Bound"

agcls.AgTypeNameMap["AgEVAIPOPTGoal"] = AgEVAIPOPTGoal

class AgEVAOptimalFiniteSeedMethod(IntEnum):
    """Seed methods."""
    # Seed initial guess from file.
    eVAOptimalFiniteSeedMethodInitialGuessFile = 0
    # Seed initial guess from finite maneuver.
    eVAOptimalFiniteSeedMethodFiniteManeuver = 1

AgEVAOptimalFiniteSeedMethod.eVAOptimalFiniteSeedMethodInitialGuessFile.__doc__ = "Seed initial guess from file."
AgEVAOptimalFiniteSeedMethod.eVAOptimalFiniteSeedMethodFiniteManeuver.__doc__ = "Seed initial guess from finite maneuver."

agcls.AgTypeNameMap["AgEVAOptimalFiniteSeedMethod"] = AgEVAOptimalFiniteSeedMethod

class AgEVAOptimalFiniteRunMode(IntEnum):
    """Run modes."""
    # Run current nodes.
    eVAOptimalFiniteRunModeRunCurrentNodes = 0
    # Optimize via direct transcription.
    eVAOptimalFiniteRunModeOptimizeViaDirectTranscription = 1

AgEVAOptimalFiniteRunMode.eVAOptimalFiniteRunModeRunCurrentNodes.__doc__ = "Run current nodes."
AgEVAOptimalFiniteRunMode.eVAOptimalFiniteRunModeOptimizeViaDirectTranscription.__doc__ = "Optimize via direct transcription."

agcls.AgTypeNameMap["AgEVAOptimalFiniteRunMode"] = AgEVAOptimalFiniteRunMode

class AgEVAOptimalFiniteDiscretizationStrategy(IntEnum):
    """Discretization Strategy."""
    # The Legendre-Gauss-Lobatto quadrature rule
    eVAOptimalFiniteDiscretizationStrategyLegendreGaussLobatto = 0
    # The Legendre-Gauss-Radau quadrature rule.
    eVAOptimalFiniteDiscretizationStrategyLegendreGaussRadau = 1

AgEVAOptimalFiniteDiscretizationStrategy.eVAOptimalFiniteDiscretizationStrategyLegendreGaussLobatto.__doc__ = "The Legendre-Gauss-Lobatto quadrature rule"
AgEVAOptimalFiniteDiscretizationStrategy.eVAOptimalFiniteDiscretizationStrategyLegendreGaussRadau.__doc__ = "The Legendre-Gauss-Radau quadrature rule."

agcls.AgTypeNameMap["AgEVAOptimalFiniteDiscretizationStrategy"] = AgEVAOptimalFiniteDiscretizationStrategy

class AgEVAOptimalFiniteWorkingVariables(IntEnum):
    """Working Variables."""
    # Standard inertial equinoctial coordinates.
    eVAOptimalFiniteWorkingVariablesEquinoctial = 0
    # Use semi-latus rectum instead of SMA and true longitude instead of mean longitude.
    eVAOptimalFiniteWorkingVariablesModifiedEquinoctial = 1

AgEVAOptimalFiniteWorkingVariables.eVAOptimalFiniteWorkingVariablesEquinoctial.__doc__ = "Standard inertial equinoctial coordinates."
AgEVAOptimalFiniteWorkingVariables.eVAOptimalFiniteWorkingVariablesModifiedEquinoctial.__doc__ = "Use semi-latus rectum instead of SMA and true longitude instead of mean longitude."

agcls.AgTypeNameMap["AgEVAOptimalFiniteWorkingVariables"] = AgEVAOptimalFiniteWorkingVariables

class AgEVAOptimalFiniteScalingOptions(IntEnum):
    """Scaling Options."""
    # No scaling.
    eVAOptimalFiniteScalingOptionsNoScaling = 0
    # Scale based on canonical units.
    eVAOptimalFiniteScalingOptionsCanonicalUnits = 1
    # Scale based on the initial state.
    eVAOptimalFiniteScalingOptionsInitialStateBased = 2

AgEVAOptimalFiniteScalingOptions.eVAOptimalFiniteScalingOptionsNoScaling.__doc__ = "No scaling."
AgEVAOptimalFiniteScalingOptions.eVAOptimalFiniteScalingOptionsCanonicalUnits.__doc__ = "Scale based on canonical units."
AgEVAOptimalFiniteScalingOptions.eVAOptimalFiniteScalingOptionsInitialStateBased.__doc__ = "Scale based on the initial state."

agcls.AgTypeNameMap["AgEVAOptimalFiniteScalingOptions"] = AgEVAOptimalFiniteScalingOptions

class AgEVAOptimalFiniteSNOPTObjective(IntEnum):
    """Optimal Finite SNOPT objective."""
    # Minimize the total TOF along the collocation arc.
    eVAOptimalFiniteSNOPTObjectiveMinimizeTOF = 0
    # Minimize the total calculated DeltaV along the collocation arc.
    eVAOptimalFiniteSNOPTObjectiveMaximizeFinalRad = 1
    # Maximize the final mass after the collocation arc.
    eVAOptimalFiniteSNOPTObjectiveMinimizePropellantUse = 2

AgEVAOptimalFiniteSNOPTObjective.eVAOptimalFiniteSNOPTObjectiveMinimizeTOF.__doc__ = "Minimize the total TOF along the collocation arc."
AgEVAOptimalFiniteSNOPTObjective.eVAOptimalFiniteSNOPTObjectiveMaximizeFinalRad.__doc__ = "Minimize the total calculated DeltaV along the collocation arc."
AgEVAOptimalFiniteSNOPTObjective.eVAOptimalFiniteSNOPTObjectiveMinimizePropellantUse.__doc__ = "Maximize the final mass after the collocation arc."

agcls.AgTypeNameMap["AgEVAOptimalFiniteSNOPTObjective"] = AgEVAOptimalFiniteSNOPTObjective

class AgEVAOptimalFiniteSNOPTScaling(IntEnum):
    """Optimal Finite SNOPT scaling option."""
    # No scaling.
    eVAOptimalFiniteSNOPTScalingNone = 0
    # Scale linear constraints and variables.
    eVAOptimalFiniteSNOPTScalingLinear = 1
    # Scale all constraints and variables.
    eVAOptimalFiniteSNOPTScalingAll = 2

AgEVAOptimalFiniteSNOPTScaling.eVAOptimalFiniteSNOPTScalingNone.__doc__ = "No scaling."
AgEVAOptimalFiniteSNOPTScaling.eVAOptimalFiniteSNOPTScalingLinear.__doc__ = "Scale linear constraints and variables."
AgEVAOptimalFiniteSNOPTScaling.eVAOptimalFiniteSNOPTScalingAll.__doc__ = "Scale all constraints and variables."

agcls.AgTypeNameMap["AgEVAOptimalFiniteSNOPTScaling"] = AgEVAOptimalFiniteSNOPTScaling

class AgEVAOptimalFiniteExportNodesFormat(IntEnum):
    """Steering nodes export format."""
    # Export controls as Az/El = Ra/Dec angles.
    eVAOptimalFiniteExportNodesFormatAzimuthElevation = 0
    # Export controls as unit vectors = direction cosines.
    eVAOptimalFiniteExportNodesFormatUnitVector = 1

AgEVAOptimalFiniteExportNodesFormat.eVAOptimalFiniteExportNodesFormatAzimuthElevation.__doc__ = "Export controls as Az/El = Ra/Dec angles."
AgEVAOptimalFiniteExportNodesFormat.eVAOptimalFiniteExportNodesFormatUnitVector.__doc__ = "Export controls as unit vectors = direction cosines."

agcls.AgTypeNameMap["AgEVAOptimalFiniteExportNodesFormat"] = AgEVAOptimalFiniteExportNodesFormat

class AgEVAOptimalFiniteGuessMethod(IntEnum):
    """Guess interpolation method."""
    # Lagrange polynomial method.
    eVAOptimalFiniteGuessMethodLagrangePolynomial = 0
    # Piecewise linear method.
    eVAOptimalFiniteGuessMethodPiecewiseLinear = 1

AgEVAOptimalFiniteGuessMethod.eVAOptimalFiniteGuessMethodLagrangePolynomial.__doc__ = "Lagrange polynomial method."
AgEVAOptimalFiniteGuessMethod.eVAOptimalFiniteGuessMethodPiecewiseLinear.__doc__ = "Piecewise linear method."

agcls.AgTypeNameMap["AgEVAOptimalFiniteGuessMethod"] = AgEVAOptimalFiniteGuessMethod

class AgEVAImpDeltaVRep(IntEnum):
    """Vector representations for impulsive DeltaV specification"""
    # Cartesian - specify the impulsive DeltaV in Cartesian coordinates (X, Y, Z).
    eVACartesianImpDeltaV = 0
    # Spherical - specify the impulsive DeltaV in spherical coordinates (Azimuth, Elevation, Magnitude).
    eVASphericalImpDeltaV = 1

AgEVAImpDeltaVRep.eVACartesianImpDeltaV.__doc__ = "Cartesian - specify the impulsive DeltaV in Cartesian coordinates (X, Y, Z)."
AgEVAImpDeltaVRep.eVASphericalImpDeltaV.__doc__ = "Spherical - specify the impulsive DeltaV in spherical coordinates (Azimuth, Elevation, Magnitude)."

agcls.AgTypeNameMap["AgEVAImpDeltaVRep"] = AgEVAImpDeltaVRep

class AgEVALambertTargetCoordType(IntEnum):
    """Lambert Target CoordType."""
    # Cartesian - specifying an orbit by three position elements and three velocity elements in a rectangular coordinate system.
    eVALambertTargetCoordTypeCartesian = 0
    # Keplerian - the classical system, specifying an orbit by six elements describing its size, shape and three-dimensional orientation in space.
    eVALambertTargetCoordTypeKeplerian = 1

AgEVALambertTargetCoordType.eVALambertTargetCoordTypeCartesian.__doc__ = "Cartesian - specifying an orbit by three position elements and three velocity elements in a rectangular coordinate system."
AgEVALambertTargetCoordType.eVALambertTargetCoordTypeKeplerian.__doc__ = "Keplerian - the classical system, specifying an orbit by six elements describing its size, shape and three-dimensional orientation in space."

agcls.AgTypeNameMap["AgEVALambertTargetCoordType"] = AgEVALambertTargetCoordType

class AgEVALambertSolutionOptionType(IntEnum):
    """Lambert Solution Option Type."""
    # Fixed time - The type of Lambert solution to calculate.
    eAgEVALambertSolutionOptionFixedTime = 0
    # Minimum Eccentricity - The type of Lambert solution to calculate.
    eAgEVALambertSolutionOptionMinEccentricity = 1
    # Minimum Energy - The type of Lambert solution to calculate.
    eAgEVALambertSolutionOptionMinEnergy = 2

AgEVALambertSolutionOptionType.eAgEVALambertSolutionOptionFixedTime.__doc__ = "Fixed time - The type of Lambert solution to calculate."
AgEVALambertSolutionOptionType.eAgEVALambertSolutionOptionMinEccentricity.__doc__ = "Minimum Eccentricity - The type of Lambert solution to calculate."
AgEVALambertSolutionOptionType.eAgEVALambertSolutionOptionMinEnergy.__doc__ = "Minimum Energy - The type of Lambert solution to calculate."

agcls.AgTypeNameMap["AgEVALambertSolutionOptionType"] = AgEVALambertSolutionOptionType

class AgEVALambertOrbitalEnergyType(IntEnum):
    """Lambert Orbital Energy Type."""
    # Low energy- This is the orbital energy for the Lambert solution that corresponds to the smaller semimajor axis solution.
    eAgEVALambertOrbitalEnergyLow = 0
    # High energy- This is the orbital energy for the Lambert solution that corresponds to the larger semimajor axis solution.
    eAgEVALambertOrbitalEnergyHigh = 1

AgEVALambertOrbitalEnergyType.eAgEVALambertOrbitalEnergyLow.__doc__ = "Low energy- This is the orbital energy for the Lambert solution that corresponds to the smaller semimajor axis solution."
AgEVALambertOrbitalEnergyType.eAgEVALambertOrbitalEnergyHigh.__doc__ = "High energy- This is the orbital energy for the Lambert solution that corresponds to the larger semimajor axis solution."

agcls.AgTypeNameMap["AgEVALambertOrbitalEnergyType"] = AgEVALambertOrbitalEnergyType

class AgEVALambertDirectionOfMotionType(IntEnum):
    """Lambert Direction Of Motion Type."""
    # The short direction of motion for the Lambert solution.
    eAgEVALambertDirectionOfMotionShort = 0
    # The long direction of motion for the Lambert solution.
    eAgEVALambertDirectionOfMotionLong = 1

AgEVALambertDirectionOfMotionType.eAgEVALambertDirectionOfMotionShort.__doc__ = "The short direction of motion for the Lambert solution."
AgEVALambertDirectionOfMotionType.eAgEVALambertDirectionOfMotionLong.__doc__ = "The long direction of motion for the Lambert solution."

agcls.AgTypeNameMap["AgEVALambertDirectionOfMotionType"] = AgEVALambertDirectionOfMotionType

class AgEVAGoldenSectionDesiredOperation(IntEnum):
    """The types for Desired Operation/Objective of golden section profile."""
    # Minimize value
    eVAGoldenSectionDesiredOpMinimizeValue = 0
    # Maximize value
    eVAGoldenSectionDesiredOpMaximizeValue = 1

AgEVAGoldenSectionDesiredOperation.eVAGoldenSectionDesiredOpMinimizeValue.__doc__ = "Minimize value"
AgEVAGoldenSectionDesiredOperation.eVAGoldenSectionDesiredOpMaximizeValue.__doc__ = "Maximize value"

agcls.AgTypeNameMap["AgEVAGoldenSectionDesiredOperation"] = AgEVAGoldenSectionDesiredOperation

class AgEVAGridSearchDesiredOperation(IntEnum):
    """The types for Desired Operation/Objective of Grid Search profile."""
    # Minimize value
    eVAGridSearchDesiredOpMinimizeValue = 0
    # Maximize value
    eVAGridSearchDesiredOpMaximizeValue = 1

AgEVAGridSearchDesiredOperation.eVAGridSearchDesiredOpMinimizeValue.__doc__ = "Minimize value"
AgEVAGridSearchDesiredOperation.eVAGridSearchDesiredOpMaximizeValue.__doc__ = "Maximize value"

agcls.AgTypeNameMap["AgEVAGridSearchDesiredOperation"] = AgEVAGridSearchDesiredOperation

class AgEVAElement(IntEnum):
    """Which type of elements (osculating or mean)"""
    # Osculating.
    eVAElementOsculating = 0
    # Kozai-Izsak Mean.
    eVAElementKozaiIzsakMean = 1
    # Brouwer-Lyddane Mean Long.
    eVAElementBrouwerLyddaneMeanLong = 2
    # Brouwer-Lyddane Mean Short.
    eVAElementBrouwerLyddaneMeanShort = 3

AgEVAElement.eVAElementOsculating.__doc__ = "Osculating."
AgEVAElement.eVAElementKozaiIzsakMean.__doc__ = "Kozai-Izsak Mean."
AgEVAElement.eVAElementBrouwerLyddaneMeanLong.__doc__ = "Brouwer-Lyddane Mean Long."
AgEVAElement.eVAElementBrouwerLyddaneMeanShort.__doc__ = "Brouwer-Lyddane Mean Short."

agcls.AgTypeNameMap["AgEVAElement"] = AgEVAElement

class AgEVABaseSelection(IntEnum):
    """Access base object selections types."""
    # An object in the current scenario.
    eVABaseSelectionSpecify = 0
    # The current satellite.
    eVABaseSelectionCurrentSatellite = 1

AgEVABaseSelection.eVABaseSelectionSpecify.__doc__ = "An object in the current scenario."
AgEVABaseSelection.eVABaseSelectionCurrentSatellite.__doc__ = "The current satellite."

agcls.AgTypeNameMap["AgEVABaseSelection"] = AgEVABaseSelection

class AgEVAControlOrbitStateValue(IntEnum):
    """Orbit State Value properties that can be selected as control parameters for a Target Sequence."""
    # The Vx velocity component of the orbit state.
    eVAControlOrbitStateValueVx = 0
    # The Vy velocity component of the orbit state.
    eVAControlOrbitStateValueVy = 1
    # The Vz velocity component of the orbit state.
    eVAControlOrbitStateValueVz = 2
    # The x position component of the orbit state.
    eVAControlOrbitStateValueX = 3
    # The y position component of the orbit state.
    eVAControlOrbitStateValueY = 4
    # The z position component of the orbit state.
    eVAControlOrbitStateValueZ = 5

AgEVAControlOrbitStateValue.eVAControlOrbitStateValueVx.__doc__ = "The Vx velocity component of the orbit state."
AgEVAControlOrbitStateValue.eVAControlOrbitStateValueVy.__doc__ = "The Vy velocity component of the orbit state."
AgEVAControlOrbitStateValue.eVAControlOrbitStateValueVz.__doc__ = "The Vz velocity component of the orbit state."
AgEVAControlOrbitStateValue.eVAControlOrbitStateValueX.__doc__ = "The x position component of the orbit state."
AgEVAControlOrbitStateValue.eVAControlOrbitStateValueY.__doc__ = "The y position component of the orbit state."
AgEVAControlOrbitStateValue.eVAControlOrbitStateValueZ.__doc__ = "The z position component of the orbit state."

agcls.AgTypeNameMap["AgEVAControlOrbitStateValue"] = AgEVAControlOrbitStateValue

class AgEVASegmentState(IntEnum):
    """Segment state to use types."""
    # The segment initial state.
    eVASegmentStateInitial = 0
    # The segment final state.
    eVASegmentStateFinal = 1

AgEVASegmentState.eVASegmentStateInitial.__doc__ = "The segment initial state."
AgEVASegmentState.eVASegmentStateFinal.__doc__ = "The segment final state."

agcls.AgTypeNameMap["AgEVASegmentState"] = AgEVASegmentState

class AgEVADifferenceOrder(IntEnum):
    """The Difference order types."""
    # The initial minus current difference.
    eVADifferenceOrderInitialMinusCurrent = 0
    # The current minus initial difference.
    eVADifferenceOrderCurrentMinusInitial = 1

AgEVADifferenceOrder.eVADifferenceOrderInitialMinusCurrent.__doc__ = "The initial minus current difference."
AgEVADifferenceOrder.eVADifferenceOrderCurrentMinusInitial.__doc__ = "The current minus initial difference."

agcls.AgTypeNameMap["AgEVADifferenceOrder"] = AgEVADifferenceOrder

class AgEVASegmentDifferenceOrder(IntEnum):
    """The Difference Across Segments order types."""
    # The current minus segment difference.
    eVASegmentDifferenceOrderCurrentMinusSegment = 0
    # The segment minus current difference.
    eVASegmentDifferenceOrderSegmentMinusCurrent = 1

AgEVASegmentDifferenceOrder.eVASegmentDifferenceOrderCurrentMinusSegment.__doc__ = "The current minus segment difference."
AgEVASegmentDifferenceOrder.eVASegmentDifferenceOrderSegmentMinusCurrent.__doc__ = "The segment minus current difference."

agcls.AgTypeNameMap["AgEVASegmentDifferenceOrder"] = AgEVASegmentDifferenceOrder

class AgEVAControlRepeatingGroundTrackErr(IntEnum):
    """Repeating Ground Track Equator Error properties that can be selected as control parameters for a Target Sequence."""
    # The reference longitude.
    eVAControlRepeatingGroundTrackErrRefLon = 0
    # The repeat count.
    eVAControlRepeatingGroundTrackErrRepeatCount = 1

AgEVAControlRepeatingGroundTrackErr.eVAControlRepeatingGroundTrackErrRefLon.__doc__ = "The reference longitude."
AgEVAControlRepeatingGroundTrackErr.eVAControlRepeatingGroundTrackErrRepeatCount.__doc__ = "The repeat count."

agcls.AgTypeNameMap["AgEVAControlRepeatingGroundTrackErr"] = AgEVAControlRepeatingGroundTrackErr

class AgEVACalcObjectDirection(IntEnum):
    """The direction to search for a desired value."""
    # Search in the direction of the next calculation object.
    eVACalcObjectDirectionNext = 0
    # Search in the direction of the previous calculation object.
    eVACalcObjectDirectionPrevious = 1

AgEVACalcObjectDirection.eVACalcObjectDirectionNext.__doc__ = "Search in the direction of the next calculation object."
AgEVACalcObjectDirection.eVACalcObjectDirectionPrevious.__doc__ = "Search in the direction of the previous calculation object."

agcls.AgTypeNameMap["AgEVACalcObjectDirection"] = AgEVACalcObjectDirection

class AgEVACalcObjectOrbitPlaneSource(IntEnum):
    """The calculation object orbit plane source Types."""
    # Use the reference satellite to generate the orbit plane.
    eAgEVACalcObjectOrbitPlaneSourceReferenceSatellite = 0
    # Use the satellite to generate the orbit plane.
    eAgEVACalcObjectOrbitPlaneSourceSatellite = 1

AgEVACalcObjectOrbitPlaneSource.eAgEVACalcObjectOrbitPlaneSourceReferenceSatellite.__doc__ = "Use the reference satellite to generate the orbit plane."
AgEVACalcObjectOrbitPlaneSource.eAgEVACalcObjectOrbitPlaneSourceSatellite.__doc__ = "Use the satellite to generate the orbit plane."

agcls.AgTypeNameMap["AgEVACalcObjectOrbitPlaneSource"] = AgEVACalcObjectOrbitPlaneSource

class AgEVACalcObjectSunPosition(IntEnum):
    """The calculation object sun location Types."""
    # Use the sun location apparent from satellite.
    eAgEVACalcObjectSunPositionApparentFromSatellite = 0
    # Use the sun location apparent from reference satellite.
    eAgEVACalcObjectSunPositionApparentFromRefSatellite = 1
    # Use the sun location true from satellite.
    eAgEVACalcObjectSunPositionTrueFromSatellite = 2
    # Use the sun location true from reference satellite.
    eAgEVACalcObjectSunPositionTrueFromRefSatellite = 3

AgEVACalcObjectSunPosition.eAgEVACalcObjectSunPositionApparentFromSatellite.__doc__ = "Use the sun location apparent from satellite."
AgEVACalcObjectSunPosition.eAgEVACalcObjectSunPositionApparentFromRefSatellite.__doc__ = "Use the sun location apparent from reference satellite."
AgEVACalcObjectSunPosition.eAgEVACalcObjectSunPositionTrueFromSatellite.__doc__ = "Use the sun location true from satellite."
AgEVACalcObjectSunPosition.eAgEVACalcObjectSunPositionTrueFromRefSatellite.__doc__ = "Use the sun location true from reference satellite."

agcls.AgTypeNameMap["AgEVACalcObjectSunPosition"] = AgEVACalcObjectSunPosition

class AgEVACalcObjectAngleSign(IntEnum):
    """The sign of the angle when the relative position has a component along the orbit normal."""
    # Use the positive sign for the angle when the relative position has a positive component along the orbit normal.
    eAgEVACalcObjectAngleSignPositive = 0
    # Use the negative sign for the angle when the relative position does not have a positive component along the orbit normal.
    eAgEVACalcObjectAngleSignNegative = 1

AgEVACalcObjectAngleSign.eAgEVACalcObjectAngleSignPositive.__doc__ = "Use the positive sign for the angle when the relative position has a positive component along the orbit normal."
AgEVACalcObjectAngleSign.eAgEVACalcObjectAngleSignNegative.__doc__ = "Use the negative sign for the angle when the relative position does not have a positive component along the orbit normal."

agcls.AgTypeNameMap["AgEVACalcObjectAngleSign"] = AgEVACalcObjectAngleSign

class AgEVACalcObjectReferenceDirection(IntEnum):
    """Direction that establishes the zero value when projected into the orbit plane."""
    # Use the reference satellite position when projected into the orbit plane.
    eAgEVACalcObjectReferenceDirectionReferenceSatellitePosition = 0
    # Use the satellite position when projected into the orbit plane.
    eAgEVACalcObjectReferenceDirectionSatellitePosition = 1
    # Use the reference satellite nadir (centric) when projected into the orbit plane.
    eAgEVACalcObjectReferenceDirectionReferenceSatelliteNadir = 2
    # Use the satellite nadir (centric) position when projected into the orbit plane.
    eAgEVACalcObjectReferenceDirectionSatelliteNadir = 3

AgEVACalcObjectReferenceDirection.eAgEVACalcObjectReferenceDirectionReferenceSatellitePosition.__doc__ = "Use the reference satellite position when projected into the orbit plane."
AgEVACalcObjectReferenceDirection.eAgEVACalcObjectReferenceDirectionSatellitePosition.__doc__ = "Use the satellite position when projected into the orbit plane."
AgEVACalcObjectReferenceDirection.eAgEVACalcObjectReferenceDirectionReferenceSatelliteNadir.__doc__ = "Use the reference satellite nadir (centric) when projected into the orbit plane."
AgEVACalcObjectReferenceDirection.eAgEVACalcObjectReferenceDirectionSatelliteNadir.__doc__ = "Use the satellite nadir (centric) position when projected into the orbit plane."

agcls.AgTypeNameMap["AgEVACalcObjectReferenceDirection"] = AgEVACalcObjectReferenceDirection

class AgEVACalcObjectRelativePosition(IntEnum):
    """The calculation object relative position Types."""
    # Use the relative position satellite to reference satellite.
    eAgEVACalcObjectRelativePositionSatelliteToRefSatellite = 0
    # Use the relative position reference satellite to satellite.
    eAgEVACalcObjectRelativePositionRefSatelliteToSatellite = 1

AgEVACalcObjectRelativePosition.eAgEVACalcObjectRelativePositionSatelliteToRefSatellite.__doc__ = "Use the relative position satellite to reference satellite."
AgEVACalcObjectRelativePosition.eAgEVACalcObjectRelativePositionRefSatelliteToSatellite.__doc__ = "Use the relative position reference satellite to satellite."

agcls.AgTypeNameMap["AgEVACalcObjectRelativePosition"] = AgEVACalcObjectRelativePosition

class AgEVACalcObjectReferenceEllipse(IntEnum):
    """The calculation object reference ellipse Types."""
    # Use the reference satellite orbit.
    eAgEVACalcObjectReferenceEllipseRefSatOrbit = 0
    # Use the satellite orbit.
    eAgEVACalcObjectReferenceEllipseSatelliteOrbit = 1

AgEVACalcObjectReferenceEllipse.eAgEVACalcObjectReferenceEllipseRefSatOrbit.__doc__ = "Use the reference satellite orbit."
AgEVACalcObjectReferenceEllipse.eAgEVACalcObjectReferenceEllipseSatelliteOrbit.__doc__ = "Use the satellite orbit."

agcls.AgTypeNameMap["AgEVACalcObjectReferenceEllipse"] = AgEVACalcObjectReferenceEllipse

class AgEVACalcObjectLocationSource(IntEnum):
    """The calculation object location source Types."""
    # Use the reference satellite.
    eAgEVACalcObjectLocationSourceRefSat = 0
    # Use the satellite.
    eAgEVACalcObjectLocationSourceSatellite = 1

AgEVACalcObjectLocationSource.eAgEVACalcObjectLocationSourceRefSat.__doc__ = "Use the reference satellite."
AgEVACalcObjectLocationSource.eAgEVACalcObjectLocationSourceSatellite.__doc__ = "Use the satellite."

agcls.AgTypeNameMap["AgEVACalcObjectLocationSource"] = AgEVACalcObjectLocationSource

class AgEVAGravitationalParameterSource(IntEnum):
    """The source of the gravitational parameter for a CStateCalcGravitationalParameter calculation object."""
    # Cb File.
    eVAGravitationalParameterSourceCbFile = 0
    # Cb File -  System.
    eVAGravitationalParameterSourceCbFileSystem = 1
    # DE File.
    eVAGravitationalParameterSourceDEFile = 2
    # Gravity File.
    eVAGravitationalParameterSourceGravityFile = 3

AgEVAGravitationalParameterSource.eVAGravitationalParameterSourceCbFile.__doc__ = "Cb File."
AgEVAGravitationalParameterSource.eVAGravitationalParameterSourceCbFileSystem.__doc__ = "Cb File -  System."
AgEVAGravitationalParameterSource.eVAGravitationalParameterSourceDEFile.__doc__ = "DE File."
AgEVAGravitationalParameterSource.eVAGravitationalParameterSourceGravityFile.__doc__ = "Gravity File."

agcls.AgTypeNameMap["AgEVAGravitationalParameterSource"] = AgEVAGravitationalParameterSource

class AgEVAReferenceRadiusSource(IntEnum):
    """The source of the reference radius for a CStateCalcReferenceRadius calculation object."""
    # Cb File.
    eVAReferenceRadiusSourceCbFile = 0
    # Gravity File.
    eVAReferenceRadiusSourceGravityFile = 1

AgEVAReferenceRadiusSource.eVAReferenceRadiusSourceCbFile.__doc__ = "Cb File."
AgEVAReferenceRadiusSource.eVAReferenceRadiusSourceGravityFile.__doc__ = "Gravity File."

agcls.AgTypeNameMap["AgEVAReferenceRadiusSource"] = AgEVAReferenceRadiusSource

class AgEVAGravCoeffNormalizationType(IntEnum):
    """The normalization type for the CStateCalcGravCoeff calculation object."""
    # Normalized.
    eVAGravCoeffNormalized = 0
    # Unnormalized.
    eVAGravCoeffUnnormalized = 1

AgEVAGravCoeffNormalizationType.eVAGravCoeffNormalized.__doc__ = "Normalized."
AgEVAGravCoeffNormalizationType.eVAGravCoeffUnnormalized.__doc__ = "Unnormalized."

agcls.AgTypeNameMap["AgEVAGravCoeffNormalizationType"] = AgEVAGravCoeffNormalizationType

class AgEVAGravCoeffCoefficientType(IntEnum):
    """The coefficient type for the CStateCalcGravCoeff calculation object."""
    # Zonal.
    eVAGravCoeffCoefficientTypeZonal = 0
    # Cosine.
    eVAGravCoeffCoefficientTypeCosine = 1
    # Sine.
    eVAGravCoeffCoefficientTypeSine = 2

AgEVAGravCoeffCoefficientType.eVAGravCoeffCoefficientTypeZonal.__doc__ = "Zonal."
AgEVAGravCoeffCoefficientType.eVAGravCoeffCoefficientTypeCosine.__doc__ = "Cosine."
AgEVAGravCoeffCoefficientType.eVAGravCoeffCoefficientTypeSine.__doc__ = "Sine."

agcls.AgTypeNameMap["AgEVAGravCoeffCoefficientType"] = AgEVAGravCoeffCoefficientType

class AgEVASTMPertVariables(IntEnum):
    """The initial and final Cartesian variational variables that describe an STM element."""
    # Designates the initial or final variation in the 'x' component of position.
    eVASTMPertVariablePosX = 0
    # Designates the initial or final variation in the 'y' component of position.
    eVASTMPertVariablePosY = 1
    # Designates the initial or final variation in the 'z' component of position.
    eVASTMPertVariablePosZ = 2
    # Designates the initial or final variation in the 'x' component of velocity.
    eVASTMPertVariableVelX = 3
    # Designates the initial or final variation in the 'y' component of velocity.
    eVASTMPertVariableVelY = 4
    # Designates the initial or final variation in the 'z' component of velocity.
    eVASTMPertVariableVelZ = 5

AgEVASTMPertVariables.eVASTMPertVariablePosX.__doc__ = "Designates the initial or final variation in the 'x' component of position."
AgEVASTMPertVariables.eVASTMPertVariablePosY.__doc__ = "Designates the initial or final variation in the 'y' component of position."
AgEVASTMPertVariables.eVASTMPertVariablePosZ.__doc__ = "Designates the initial or final variation in the 'z' component of position."
AgEVASTMPertVariables.eVASTMPertVariableVelX.__doc__ = "Designates the initial or final variation in the 'x' component of velocity."
AgEVASTMPertVariables.eVASTMPertVariableVelY.__doc__ = "Designates the initial or final variation in the 'y' component of velocity."
AgEVASTMPertVariables.eVASTMPertVariableVelZ.__doc__ = "Designates the initial or final variation in the 'z' component of velocity."

agcls.AgTypeNameMap["AgEVASTMPertVariables"] = AgEVASTMPertVariables

class AgEVASTMEigenNumber(IntEnum):
    """The number that describes one of the 6 STM Eigenvalues or Eigenvectors."""
    # Designates the first Eigenvalue or Eigenvector.
    eVASTMEigenNumber1 = 0
    # Designates the second Eigenvalue or Eigenvector.
    eVASTMEigenNumber2 = 1
    # Designates the third Eigenvalue or Eigenvector.
    eVASTMEigenNumber3 = 2
    # Designates the fourth Eigenvalue or Eigenvector.
    eVASTMEigenNumber4 = 3
    # Designates the fifth Eigenvalue or Eigenvector.
    eVASTMEigenNumber5 = 4
    # Designates the sixth Eigenvalue or Eigenvector.
    eVASTMEigenNumber6 = 5

AgEVASTMEigenNumber.eVASTMEigenNumber1.__doc__ = "Designates the first Eigenvalue or Eigenvector."
AgEVASTMEigenNumber.eVASTMEigenNumber2.__doc__ = "Designates the second Eigenvalue or Eigenvector."
AgEVASTMEigenNumber.eVASTMEigenNumber3.__doc__ = "Designates the third Eigenvalue or Eigenvector."
AgEVASTMEigenNumber.eVASTMEigenNumber4.__doc__ = "Designates the fourth Eigenvalue or Eigenvector."
AgEVASTMEigenNumber.eVASTMEigenNumber5.__doc__ = "Designates the fifth Eigenvalue or Eigenvector."
AgEVASTMEigenNumber.eVASTMEigenNumber6.__doc__ = "Designates the sixth Eigenvalue or Eigenvector."

agcls.AgTypeNameMap["AgEVASTMEigenNumber"] = AgEVASTMEigenNumber

class AgEVAComplexNumber(IntEnum):
    """Whether a value represents the real or imaginary portion of a number."""
    # Designates the value as the real part.
    eVAComplexNumberReal = 0
    # Designates the value as the imaginary part.
    eVAComplexNumberImaginary = 1

AgEVAComplexNumber.eVAComplexNumberReal.__doc__ = "Designates the value as the real part."
AgEVAComplexNumber.eVAComplexNumberImaginary.__doc__ = "Designates the value as the imaginary part."

agcls.AgTypeNameMap["AgEVAComplexNumber"] = AgEVAComplexNumber

class AgEVASquaredType(IntEnum):
    """Whether to calculate the value as the square of the sum of each component or the sum of the squares."""
    # Designates the calculation to be the sum of the squares.
    eVASumOfSquares = 0
    # Designates the calculation to be the square of the sum.
    eVASquareOfSum = 1

AgEVASquaredType.eVASumOfSquares.__doc__ = "Designates the calculation to be the sum of the squares."
AgEVASquaredType.eVASquareOfSum.__doc__ = "Designates the calculation to be the square of the sum."

agcls.AgTypeNameMap["AgEVASquaredType"] = AgEVASquaredType

class AgEVAGeoStationaryDriftRateModel(IntEnum):
    """Gravity models used to compute geostationary drift rate."""
    # Computes drift rate using two-body point mass gravity model.
    eVAGeoStationaryDriftRatePointMass = 0
    # Computes drift rate using gravity model that includes point mass plus secular effect of J2.
    eVAGeoStationaryDriftRatePointMassPlusJ2 = 1

AgEVAGeoStationaryDriftRateModel.eVAGeoStationaryDriftRatePointMass.__doc__ = "Computes drift rate using two-body point mass gravity model."
AgEVAGeoStationaryDriftRateModel.eVAGeoStationaryDriftRatePointMassPlusJ2.__doc__ = "Computes drift rate using gravity model that includes point mass plus secular effect of J2."

agcls.AgTypeNameMap["AgEVAGeoStationaryDriftRateModel"] = AgEVAGeoStationaryDriftRateModel

class AgEVAGeoStationaryInclinationMag(IntEnum):
    """Magnitude to use when computing the inclination vector."""
    # Computes inclination vector magnitude as the inclination angle itself (in radins).
    AgEVAGeoStationaryInclinationMagInclinationAngle = 0
    # Computes inclination vector magnitude as sin(inclination).
    AgEVAGeoStationaryInclinationMagSinInclination = 1
    # Computes inclination vector magnitude as sin(0.5*inclination).
    AgEVAGeoStationaryInclinationMagSinHalfInclination = 2
    # Computes inclination vector magnitude as 2*sin(0.5*inclination).
    AgEVAGeoStationaryInclinationMagTwiceSinHalfInclination = 3
    # Computes inclination vector magnitude as tan(0.5*inclination).
    AgEVAGeoStationaryInclinationMagTanHalfInclination = 4
    # Computes inclination vector magnitude as 2*tan(0.5*inclination).
    AgEVAGeoStationaryInclinationMagTwiceTanHalfInclination = 5

AgEVAGeoStationaryInclinationMag.AgEVAGeoStationaryInclinationMagInclinationAngle.__doc__ = "Computes inclination vector magnitude as the inclination angle itself (in radins)."
AgEVAGeoStationaryInclinationMag.AgEVAGeoStationaryInclinationMagSinInclination.__doc__ = "Computes inclination vector magnitude as sin(inclination)."
AgEVAGeoStationaryInclinationMag.AgEVAGeoStationaryInclinationMagSinHalfInclination.__doc__ = "Computes inclination vector magnitude as sin(0.5*inclination)."
AgEVAGeoStationaryInclinationMag.AgEVAGeoStationaryInclinationMagTwiceSinHalfInclination.__doc__ = "Computes inclination vector magnitude as 2*sin(0.5*inclination)."
AgEVAGeoStationaryInclinationMag.AgEVAGeoStationaryInclinationMagTanHalfInclination.__doc__ = "Computes inclination vector magnitude as tan(0.5*inclination)."
AgEVAGeoStationaryInclinationMag.AgEVAGeoStationaryInclinationMagTwiceTanHalfInclination.__doc__ = "Computes inclination vector magnitude as 2*tan(0.5*inclination)."

agcls.AgTypeNameMap["AgEVAGeoStationaryInclinationMag"] = AgEVAGeoStationaryInclinationMag

class AgEVACbGravityModel(IntEnum):
    """The gravity model."""
    # ZonalsToJ4 - (various) Gravity model for all central bodies except Sun, Earth and Moon.
    eVACbGravityModelZonalsToJ4 = 0
    # Earth Simple gravity model.
    eVACbGravityModelEarthSimple = 1
    # WGS84 - (Earth) World Geodetic System 1984; WGS 84 was created by the Defense Mapping Agency (DMA).
    eVACbGravityModelWGS84 = 2
    # EGM96 - (Earth) Earth Gravity Model 1996, a geopotential model of the Earth consisting of spherical harmonic coefficients complete to degree and order 360. Developed jointly by NGA (formerly known as NIMA), NASA Goddard and Ohio State University.
    eVACbGravityModelEGM96 = 3
    # GEMT1 - (Earth) Goddard Earth Model T1.
    eVACbGravityModelGEMT1 = 4
    # JGM2 - (Earth) Joint Gravity Model version 2, a model that describes the Earth gravity field up to degree and order 70, developed by NASA/GSFC Space Geodesy Branch, the University of Texas Center for Space Research and CNES.
    eVACbGravityModelJGM2 = 5
    # JGM3 - (Earth) Joint Gravity Model version 3, a model that describes the Earth gravity field up to degree and order 70, developed by the University of Texas and NASA/GSFC.
    eVACbGravityModelJGM3 = 6
    # WGS84 EGM96 - (Earth) Uses the coefficients from EGM96 with the shape model of WGS84. This model is the recommended gravity model of the WGS84 definition document: NIMA TR8350.2, Third Edition, 4 July 1997.
    eVACbGravityModelWSG84EGM96 = 7
    # WGS84 old - (Earth) Old version of WGS84.
    eVACbGravityModelWGS84Old = 8
    # GLGM2 - (Moon) GM = 4.9028029535968e+12, reference distance = 1,738,000 m.
    eVACbGravityModelGLGM2 = 9
    # LP165P - (Moon) GM = 4.902801056E+12, reference distance = 1,738,000.0 m.
    eVACbGravityModelLP165P = 10
    # Icarus1987 - (Mercury) GM = 2.203209e+013, reference distance = 2,439,000 m. Reference: Anderson, J. J., Colombo, G., Esposito, P. B., Lau E. L., and Trager, G. B. 'The Mass, Gravity Field, and Ephemeris of Mercury', Icarus 71, 337-349, 1987.
    eVACbGravityModelIcarus1987 = 11
    # MGNP180U - (Venus) GM = 3.248585920790000E+14, reference distance = 6,051,000.0 m.
    eVACbGravityModelMGNP180U = 12
    # GMM1 - (Mars) GM = 4.28283579647735e+13, reference distance = 3,394,200.0 m.
    eVACbGravityModelGMM1 = 13
    # GMM2B - (Mars) GM = 4.28283719012840e+13, reference distance = 3,397,000 m. Reference: These numbers came from the GMM-2B model published at `NASA <https://www.nasa.gov/>`_ and were gotten from Journal of Geophysical Research, November 2000.
    eVACbGravityModelGMM2B = 14
    # Mars50c - (Mars) GM = 4.2828370371000e+13, reference distance = 3,394,200 m.
    eVACbGravityModelMars50c = 15
    # JUP230 - (Jupiter) GM = 1.26686535e+017, reference distance = 71,492,000 m. Reference: Jacobson, R. A. The JUP230 orbit solution, 2003.
    eVACbGravityModelJUP230 = 16
    # Astron2004 - (Saturn) GM = 3.7931284e+016, reference distance = 60,330,000 m.
    eVACbGravityModelAstron2004 = 17
    # AstronAstro1991 - (Neptune) GM = 6.835107e+015, reference distance = 25,225,000 m.
    eVACbGravityModelAstronAstro1991 = 18
    # Icarus2001 - (Callisto) GM = 7.179292e+12, reference distance = 2,410,300 m.
    eVACbGravityModelIcarus2001 = 19
    # Science1998 - (Europa) GM =3.20272e+012, reference distance = 1,565,000 m.
    eVACbGravityModelScience1998 = 20
    # Nature1996 - (Ganymede) GM = 9.8866e+12, reference distance = 2,634,000 m.
    eVACbGravityModelNature1996 = 21
    # JGeoRes2001 - (Io) GM = 5.96e+12, reference distance = 1,821,600 m.
    eVACbGravityModelJGeoRes2001 = 22
    # GGM01C - (Earth)
    eVACbGravityModelGGM01C = 23
    # GGM02C - (Earth)
    eVACbGravityModelGGM02C = 24
    # WGS72 ZonalsToJ4 - (Earth)
    eVACbGravityModelWGS72ZonalsToJ4 = 25
    # LP100J - (Moon)
    eVACbGravityModelLP100J = 26
    # LP100K - (Moon)
    eVACbGravityModelLP100K = 27
    # LP150Q - (Moon)
    eVACbGravityModelLP150Q = 28
    # LP75G - (Moon)
    eVACbGravityModelLP75G = 29

AgEVACbGravityModel.eVACbGravityModelZonalsToJ4.__doc__ = "ZonalsToJ4 - (various) Gravity model for all central bodies except Sun, Earth and Moon."
AgEVACbGravityModel.eVACbGravityModelEarthSimple.__doc__ = "Earth Simple gravity model."
AgEVACbGravityModel.eVACbGravityModelWGS84.__doc__ = "WGS84 - (Earth) World Geodetic System 1984; WGS 84 was created by the Defense Mapping Agency (DMA)."
AgEVACbGravityModel.eVACbGravityModelEGM96.__doc__ = "EGM96 - (Earth) Earth Gravity Model 1996, a geopotential model of the Earth consisting of spherical harmonic coefficients complete to degree and order 360. Developed jointly by NGA (formerly known as NIMA), NASA Goddard and Ohio State University."
AgEVACbGravityModel.eVACbGravityModelGEMT1.__doc__ = "GEMT1 - (Earth) Goddard Earth Model T1."
AgEVACbGravityModel.eVACbGravityModelJGM2.__doc__ = "JGM2 - (Earth) Joint Gravity Model version 2, a model that describes the Earth gravity field up to degree and order 70, developed by NASA/GSFC Space Geodesy Branch, the University of Texas Center for Space Research and CNES."
AgEVACbGravityModel.eVACbGravityModelJGM3.__doc__ = "JGM3 - (Earth) Joint Gravity Model version 3, a model that describes the Earth gravity field up to degree and order 70, developed by the University of Texas and NASA/GSFC."
AgEVACbGravityModel.eVACbGravityModelWSG84EGM96.__doc__ = "WGS84 EGM96 - (Earth) Uses the coefficients from EGM96 with the shape model of WGS84. This model is the recommended gravity model of the WGS84 definition document: NIMA TR8350.2, Third Edition, 4 July 1997."
AgEVACbGravityModel.eVACbGravityModelWGS84Old.__doc__ = "WGS84 old - (Earth) Old version of WGS84."
AgEVACbGravityModel.eVACbGravityModelGLGM2.__doc__ = "GLGM2 - (Moon) GM = 4.9028029535968e+12, reference distance = 1,738,000 m."
AgEVACbGravityModel.eVACbGravityModelLP165P.__doc__ = "LP165P - (Moon) GM = 4.902801056E+12, reference distance = 1,738,000.0 m."
AgEVACbGravityModel.eVACbGravityModelIcarus1987.__doc__ = "Icarus1987 - (Mercury) GM = 2.203209e+013, reference distance = 2,439,000 m. Reference: Anderson, J. J., Colombo, G., Esposito, P. B., Lau E. L., and Trager, G. B. 'The Mass, Gravity Field, and Ephemeris of Mercury', Icarus 71, 337-349, 1987."
AgEVACbGravityModel.eVACbGravityModelMGNP180U.__doc__ = "MGNP180U - (Venus) GM = 3.248585920790000E+14, reference distance = 6,051,000.0 m."
AgEVACbGravityModel.eVACbGravityModelGMM1.__doc__ = "GMM1 - (Mars) GM = 4.28283579647735e+13, reference distance = 3,394,200.0 m."
AgEVACbGravityModel.eVACbGravityModelGMM2B.__doc__ = "GMM2B - (Mars) GM = 4.28283719012840e+13, reference distance = 3,397,000 m. Reference: These numbers came from the GMM-2B model published at `NASA <https://www.nasa.gov/>`_ and were gotten from Journal of Geophysical Research, November 2000."
AgEVACbGravityModel.eVACbGravityModelMars50c.__doc__ = "Mars50c - (Mars) GM = 4.2828370371000e+13, reference distance = 3,394,200 m."
AgEVACbGravityModel.eVACbGravityModelJUP230.__doc__ = "JUP230 - (Jupiter) GM = 1.26686535e+017, reference distance = 71,492,000 m. Reference: Jacobson, R. A. The JUP230 orbit solution, 2003."
AgEVACbGravityModel.eVACbGravityModelAstron2004.__doc__ = "Astron2004 - (Saturn) GM = 3.7931284e+016, reference distance = 60,330,000 m."
AgEVACbGravityModel.eVACbGravityModelAstronAstro1991.__doc__ = "AstronAstro1991 - (Neptune) GM = 6.835107e+015, reference distance = 25,225,000 m."
AgEVACbGravityModel.eVACbGravityModelIcarus2001.__doc__ = "Icarus2001 - (Callisto) GM = 7.179292e+12, reference distance = 2,410,300 m."
AgEVACbGravityModel.eVACbGravityModelScience1998.__doc__ = "Science1998 - (Europa) GM =3.20272e+012, reference distance = 1,565,000 m."
AgEVACbGravityModel.eVACbGravityModelNature1996.__doc__ = "Nature1996 - (Ganymede) GM = 9.8866e+12, reference distance = 2,634,000 m."
AgEVACbGravityModel.eVACbGravityModelJGeoRes2001.__doc__ = "JGeoRes2001 - (Io) GM = 5.96e+12, reference distance = 1,821,600 m."
AgEVACbGravityModel.eVACbGravityModelGGM01C.__doc__ = "GGM01C - (Earth)"
AgEVACbGravityModel.eVACbGravityModelGGM02C.__doc__ = "GGM02C - (Earth)"
AgEVACbGravityModel.eVACbGravityModelWGS72ZonalsToJ4.__doc__ = "WGS72 ZonalsToJ4 - (Earth)"
AgEVACbGravityModel.eVACbGravityModelLP100J.__doc__ = "LP100J - (Moon)"
AgEVACbGravityModel.eVACbGravityModelLP100K.__doc__ = "LP100K - (Moon)"
AgEVACbGravityModel.eVACbGravityModelLP150Q.__doc__ = "LP150Q - (Moon)"
AgEVACbGravityModel.eVACbGravityModelLP75G.__doc__ = "LP75G - (Moon)"

agcls.AgTypeNameMap["AgEVACbGravityModel"] = AgEVACbGravityModel

class AgEVACbShape(IntEnum):
    """The central body shape types."""
    # A triaxial ellipsoid defined by a semi-major axis, semi-mid axis and semi-minor axis.
    eVACbShapeTriaxialEllipsoid = 0
    # An oblate spheroid defined by a minimum and maximum radii, and a derived flattening coefficient.
    eVACbShapeOblateSpheroid = 1
    # A sphere defined by a radius.
    eVACbShapeSphere = 2

AgEVACbShape.eVACbShapeTriaxialEllipsoid.__doc__ = "A triaxial ellipsoid defined by a semi-major axis, semi-mid axis and semi-minor axis."
AgEVACbShape.eVACbShapeOblateSpheroid.__doc__ = "An oblate spheroid defined by a minimum and maximum radii, and a derived flattening coefficient."
AgEVACbShape.eVACbShapeSphere.__doc__ = "A sphere defined by a radius."

agcls.AgTypeNameMap["AgEVACbShape"] = AgEVACbShape

class AgEVACbAttitude(IntEnum):
    """The central body attitude types."""
    # An IAU 1994 attitude definition.
    eVACbAttitudeIAU1994 = 0
    # A rotation coefficient file.
    eVACbAttitudeRotationCoefficientsFile = 1

AgEVACbAttitude.eVACbAttitudeIAU1994.__doc__ = "An IAU 1994 attitude definition."
AgEVACbAttitude.eVACbAttitudeRotationCoefficientsFile.__doc__ = "A rotation coefficient file."

agcls.AgTypeNameMap["AgEVACbAttitude"] = AgEVACbAttitude

class AgEVACbEphemeris(IntEnum):
    """The central body ephemeris types."""
    # Specified values and rates of change for the classical orbital elements.
    eVACbEphemerisAnalyticOrbit = 0
    # An external ephemeris (.e) file.
    eVACbEphemerisFile = 1
    # Ephemerides from the Jet Propulsion Laboratory's JPL DE set are used.
    eVACbEphemerisJPLDE = 2
    # The SPICE propagator reads ephemeris from binary files that are in a standard format produced by the Jet Propulsion Laboratory for ephemeris for celestial bodies but can be used for spacecraft.
    eVACbEphemerisJPLSPICE = 3
    # A planetary ephemeris (.pe) file.
    eVACbEphemerisPlanetary = 4

AgEVACbEphemeris.eVACbEphemerisAnalyticOrbit.__doc__ = "Specified values and rates of change for the classical orbital elements."
AgEVACbEphemeris.eVACbEphemerisFile.__doc__ = "An external ephemeris (.e) file."
AgEVACbEphemeris.eVACbEphemerisJPLDE.__doc__ = "Ephemerides from the Jet Propulsion Laboratory's JPL DE set are used."
AgEVACbEphemeris.eVACbEphemerisJPLSPICE.__doc__ = "The SPICE propagator reads ephemeris from binary files that are in a standard format produced by the Jet Propulsion Laboratory for ephemeris for celestial bodies but can be used for spacecraft."
AgEVACbEphemeris.eVACbEphemerisPlanetary.__doc__ = "A planetary ephemeris (.pe) file."

agcls.AgTypeNameMap["AgEVACbEphemeris"] = AgEVACbEphemeris

class AgEVAControlPowerInternal(IntEnum):
    """Internal Power properties that can be selected as control parameters for a Target Sequence."""
    # The power generated by the spacecraft from internal sources.
    eVAControlPowerInternalGeneratedPower = 0
    # The percent degradation per year; degradation factor is (1 - x%/yr)timeSinceRefEpoch.
    eVAControlPowerInternalPercentDegradation = 1
    # The date and time used as a reference epoch for degradation.
    eVAControlPowerInternalEpoch = 2

AgEVAControlPowerInternal.eVAControlPowerInternalGeneratedPower.__doc__ = "The power generated by the spacecraft from internal sources."
AgEVAControlPowerInternal.eVAControlPowerInternalPercentDegradation.__doc__ = "The percent degradation per year; degradation factor is (1 - x%/yr)timeSinceRefEpoch."
AgEVAControlPowerInternal.eVAControlPowerInternalEpoch.__doc__ = "The date and time used as a reference epoch for degradation."

agcls.AgTypeNameMap["AgEVAControlPowerInternal"] = AgEVAControlPowerInternal

class AgEVAControlPowerProcessed(IntEnum):
    """Processed Power properties that can be selected as control parameters for a Target Sequence."""
    # The efficiency of the power processing unit(PPU).
    eVAControlPowerProcessedEfficiency = 0
    # The power diverted from the power source and unavailable to the power processing unit(PPU).
    eVAControlPowerProcessedLoad = 1

AgEVAControlPowerProcessed.eVAControlPowerProcessedEfficiency.__doc__ = "The efficiency of the power processing unit(PPU)."
AgEVAControlPowerProcessed.eVAControlPowerProcessedLoad.__doc__ = "The power diverted from the power source and unavailable to the power processing unit(PPU)."

agcls.AgTypeNameMap["AgEVAControlPowerProcessed"] = AgEVAControlPowerProcessed

class AgEVAControlPowerSolarArray(IntEnum):
    """Solar Array Power properties that can be selected as control parameters for a Target Sequence."""
    # The ThermalModel.C0 coefficient.
    eVAControlPowerSolarArrayC0 = 0
    # The ThermalModel.C1 coefficient.
    eVAControlPowerSolarArrayC1 = 1
    # The ThermalModel.C2 coefficient.
    eVAControlPowerSolarArrayC2 = 2
    # The ThermalModel.C3 coefficient.
    eVAControlPowerSolarArrayC3 = 3
    # The ThermalModel.C4 coefficient.
    eVAControlPowerSolarArrayC4 = 4
    # The solar array panel area.
    eVAControlPowerSolarArrayArea = 5
    # The array efficiency in producing output power from a collection of cells.
    eVAControlPowerSolarArrayEfficiency = 6
    # The cell efficiency in producing output power from incident sunlight.
    eVAControlPowerSolarArrayCellEfficiency = 7
    # The solar array concentration factor.
    eVAControlPowerSolarArrayConcentration = 8
    # The angle from the panel normal vector to the apparent sun line.
    eVAControlPowerSolarArrayInclinationToSunLine = 9
    # The percent degradation per year; degradation factor is (1 - x%/yr)timeSinceRefEpoch.
    eVAControlPowerSolarArrayPercentDegradation = 10
    # The date and time used as a reference epoch for degradation.
    eVAControlPowerSolarArrayEpoch = 11

AgEVAControlPowerSolarArray.eVAControlPowerSolarArrayC0.__doc__ = "The ThermalModel.C0 coefficient."
AgEVAControlPowerSolarArray.eVAControlPowerSolarArrayC1.__doc__ = "The ThermalModel.C1 coefficient."
AgEVAControlPowerSolarArray.eVAControlPowerSolarArrayC2.__doc__ = "The ThermalModel.C2 coefficient."
AgEVAControlPowerSolarArray.eVAControlPowerSolarArrayC3.__doc__ = "The ThermalModel.C3 coefficient."
AgEVAControlPowerSolarArray.eVAControlPowerSolarArrayC4.__doc__ = "The ThermalModel.C4 coefficient."
AgEVAControlPowerSolarArray.eVAControlPowerSolarArrayArea.__doc__ = "The solar array panel area."
AgEVAControlPowerSolarArray.eVAControlPowerSolarArrayEfficiency.__doc__ = "The array efficiency in producing output power from a collection of cells."
AgEVAControlPowerSolarArray.eVAControlPowerSolarArrayCellEfficiency.__doc__ = "The cell efficiency in producing output power from incident sunlight."
AgEVAControlPowerSolarArray.eVAControlPowerSolarArrayConcentration.__doc__ = "The solar array concentration factor."
AgEVAControlPowerSolarArray.eVAControlPowerSolarArrayInclinationToSunLine.__doc__ = "The angle from the panel normal vector to the apparent sun line."
AgEVAControlPowerSolarArray.eVAControlPowerSolarArrayPercentDegradation.__doc__ = "The percent degradation per year; degradation factor is (1 - x%/yr)timeSinceRefEpoch."
AgEVAControlPowerSolarArray.eVAControlPowerSolarArrayEpoch.__doc__ = "The date and time used as a reference epoch for degradation."

agcls.AgTypeNameMap["AgEVAControlPowerSolarArray"] = AgEVAControlPowerSolarArray

class AgEVAThirdBodyMode(IntEnum):
    """The third body gravity mode."""
    # Defines the gravitational effect as a full Gravitational Force model
    eVAThirdBodyModeGravityField = 0
    # Defines the gravitational effect as a third body point mass effect.
    eVAThirdBodyModePointMass = 1

AgEVAThirdBodyMode.eVAThirdBodyModeGravityField.__doc__ = "Defines the gravitational effect as a full Gravitational Force model"
AgEVAThirdBodyMode.eVAThirdBodyModePointMass.__doc__ = "Defines the gravitational effect as a third body point mass effect."

agcls.AgTypeNameMap["AgEVAThirdBodyMode"] = AgEVAThirdBodyMode

class AgEVAGravParamSource(IntEnum):
    """The gravity parameter source."""
    # The Cb file provided with STK; uses the default, body centered gravity source for the central body.
    eVAGravParamSourceCbFile = 0
    # A DE file; body centered for the inner planets and barycentered for the outer planets.
    eVAGravParamSourceDEFile = 1
    # User defined; requires you to specify the mu value of the Gravitational Parameter.
    eVAGravParamSourceUser = 2
    # The Cb file provided with STK; uses the default, barycentered gravity source for the central body.
    eVAGravParamSourceCbFileSystem = 3

AgEVAGravParamSource.eVAGravParamSourceCbFile.__doc__ = "The Cb file provided with STK; uses the default, body centered gravity source for the central body."
AgEVAGravParamSource.eVAGravParamSourceDEFile.__doc__ = "A DE file; body centered for the inner planets and barycentered for the outer planets."
AgEVAGravParamSource.eVAGravParamSourceUser.__doc__ = "User defined; requires you to specify the mu value of the Gravitational Parameter."
AgEVAGravParamSource.eVAGravParamSourceCbFileSystem.__doc__ = "The Cb file provided with STK; uses the default, barycentered gravity source for the central body."

agcls.AgTypeNameMap["AgEVAGravParamSource"] = AgEVAGravParamSource

class AgEVAEphemSource(IntEnum):
    """The ephemeris source type."""
    # The Cb file provided with STK; uses the default ephemeris source for that central body.
    eVAEphemSourceCbFile = 0
    # A DE file; body centered for the inner planets and barycentered for the outer planets.
    eVAEphemSourceDEFile = 1
    # A SPICE file, barycentered; uses the entire planetary system as a single effect, with the system center as the point mass.
    eVAEphemSourceSPICEBary = 2
    # A SPICE file, body centered; uses only the planet as the effect, with the planet's center as the point mass.
    eVAEphemSourceSPICEBody = 3

AgEVAEphemSource.eVAEphemSourceCbFile.__doc__ = "The Cb file provided with STK; uses the default ephemeris source for that central body."
AgEVAEphemSource.eVAEphemSourceDEFile.__doc__ = "A DE file; body centered for the inner planets and barycentered for the outer planets."
AgEVAEphemSource.eVAEphemSourceSPICEBary.__doc__ = "A SPICE file, barycentered; uses the entire planetary system as a single effect, with the system center as the point mass."
AgEVAEphemSource.eVAEphemSourceSPICEBody.__doc__ = "A SPICE file, body centered; uses only the planet as the effect, with the planet's center as the point mass."

agcls.AgTypeNameMap["AgEVAEphemSource"] = AgEVAEphemSource

class AgEVASolarForceMethod(IntEnum):
    """The solar force method type for a spherical or N-plate SRP model."""
    # Luminosity - used as the value for solar flux at 1 AU in the Solar Radiation computation.
    eVASolarForceMethodLuminosity = 0
    # Mean Flux - used as the value for solar flux at 1 AU in the Solar Radiation computation.
    eVASolarForceMethodMeanFlux = 1

AgEVASolarForceMethod.eVASolarForceMethodLuminosity.__doc__ = "Luminosity - used as the value for solar flux at 1 AU in the Solar Radiation computation."
AgEVASolarForceMethod.eVASolarForceMethodMeanFlux.__doc__ = "Mean Flux - used as the value for solar flux at 1 AU in the Solar Radiation computation."

agcls.AgTypeNameMap["AgEVASolarForceMethod"] = AgEVASolarForceMethod

class AgEVAShadowModel(IntEnum):
    """The shadow model type."""
    # Cylindrical - assumes the Sun to be at infinite distance so that all light coming from the Sun moves in a direction parallel to the Sun to satellite vector.
    eVAShadowModelCylindrical = 0
    # Dual Cone - uses the actual size and distance of the Sun to model regions of full, partial (penumbra) and zero (umbra) sunlight. The visible fraction of the solar disk is used to compute the acceleration during penumbra.
    eVAShadowModelDualCone = 1
    # None - turns off all shadowing of the satellite.
    eVAShadowModelNone = 2

AgEVAShadowModel.eVAShadowModelCylindrical.__doc__ = "Cylindrical - assumes the Sun to be at infinite distance so that all light coming from the Sun moves in a direction parallel to the Sun to satellite vector."
AgEVAShadowModel.eVAShadowModelDualCone.__doc__ = "Dual Cone - uses the actual size and distance of the Sun to model regions of full, partial (penumbra) and zero (umbra) sunlight. The visible fraction of the solar disk is used to compute the acceleration during penumbra."
AgEVAShadowModel.eVAShadowModelNone.__doc__ = "None - turns off all shadowing of the satellite."

agcls.AgTypeNameMap["AgEVAShadowModel"] = AgEVAShadowModel

class AgEVASunPosition(IntEnum):
    """The sun position type."""
    # Apparent - takes into account the time required for light to travel from the sun to the position of the spacecraft.
    eVASunPositionApparent = 0
    # Apparent Sun to True Cb - takes into account the time required for light to travel from the sun to the central body.
    eVASunPositionApparentToTrueCb = 1
    # True - assumes that light from the sun reaches the spacecraft instantaneously.
    eVASunPositionTrue = 2

AgEVASunPosition.eVASunPositionApparent.__doc__ = "Apparent - takes into account the time required for light to travel from the sun to the position of the spacecraft."
AgEVASunPosition.eVASunPositionApparentToTrueCb.__doc__ = "Apparent Sun to True Cb - takes into account the time required for light to travel from the sun to the central body."
AgEVASunPosition.eVASunPositionTrue.__doc__ = "True - assumes that light from the sun reaches the spacecraft instantaneously."

agcls.AgTypeNameMap["AgEVASunPosition"] = AgEVASunPosition

class AgEVAAtmosDataSource(IntEnum):
    """The Atmospheric data source type."""
    # Constant Atmospheric data source.
    eVAAtmosDataSourceConstant = 0
    # Atmopsheric data source from file.
    eVAAtmosDataSourceFile = 1

AgEVAAtmosDataSource.eVAAtmosDataSourceConstant.__doc__ = "Constant Atmospheric data source."
AgEVAAtmosDataSource.eVAAtmosDataSourceFile.__doc__ = "Atmopsheric data source from file."

agcls.AgTypeNameMap["AgEVAAtmosDataSource"] = AgEVAAtmosDataSource

class AgEVAGeoMagneticFluxSource(IntEnum):
    """Whether to use Kp or Ap data from the flux file."""
    # Read Ap from file.
    eVAGeoMagneticFluxSourceAp = 0
    # Read Kp from file.
    eVAGeoMagneticFluxSourceKp = 1

AgEVAGeoMagneticFluxSource.eVAGeoMagneticFluxSourceAp.__doc__ = "Read Ap from file."
AgEVAGeoMagneticFluxSource.eVAGeoMagneticFluxSourceKp.__doc__ = "Read Kp from file."

agcls.AgTypeNameMap["AgEVAGeoMagneticFluxSource"] = AgEVAGeoMagneticFluxSource

class AgEVAGeoMagneticFluxUpdateRate(IntEnum):
    """Method for using geomagnetic flux values from the flux file."""
    # Three hourly
    eVAGeoMagneticFluxUpdateRate3Hourly = 0
    # Three hourly cubic spline
    eVAGeoMagneticFluxUpdateRate3HourlyCubicSpline = 1
    # Three hourly interpolated
    eVAGeoMagneticFluxUpdateRate3HourlyInterpolated = 2
    # Daily
    eVAGeoMagneticFluxUpdateRateDaily = 3

AgEVAGeoMagneticFluxUpdateRate.eVAGeoMagneticFluxUpdateRate3Hourly.__doc__ = "Three hourly"
AgEVAGeoMagneticFluxUpdateRate.eVAGeoMagneticFluxUpdateRate3HourlyCubicSpline.__doc__ = "Three hourly cubic spline"
AgEVAGeoMagneticFluxUpdateRate.eVAGeoMagneticFluxUpdateRate3HourlyInterpolated.__doc__ = "Three hourly interpolated"
AgEVAGeoMagneticFluxUpdateRate.eVAGeoMagneticFluxUpdateRateDaily.__doc__ = "Daily"

agcls.AgTypeNameMap["AgEVAGeoMagneticFluxUpdateRate"] = AgEVAGeoMagneticFluxUpdateRate

class AgEVADragModelType(IntEnum):
    """Type of Drag Model."""
    # Spherical
    eVADragModelTypeSpherical = 0
    # Plugin
    eVADragModelTypePlugin = 1
    # Variable Area
    eVADragModelTypeVariableArea = 2
    # N-Plate
    eVADragModelTypeNPlate = 3

AgEVADragModelType.eVADragModelTypeSpherical.__doc__ = "Spherical"
AgEVADragModelType.eVADragModelTypePlugin.__doc__ = "Plugin"
AgEVADragModelType.eVADragModelTypeVariableArea.__doc__ = "Variable Area"
AgEVADragModelType.eVADragModelTypeNPlate.__doc__ = "N-Plate"

agcls.AgTypeNameMap["AgEVADragModelType"] = AgEVADragModelType

class AgEVAMarsGRAMDensityType(IntEnum):
    """Density Type for MarsGRAM Density Models"""
    # Low density
    eVAMarsGRAMDensityTypeLow = 0
    # Mean density
    eVAMarsGRAMDensityTypeMean = 1
    # High density
    eVAMarsGRAMDensityTypeHigh = 2
    # Randomly perturbed density
    eVAMarsGRAMDensityTypeRandomlyPerturbed = 3

AgEVAMarsGRAMDensityType.eVAMarsGRAMDensityTypeLow.__doc__ = "Low density"
AgEVAMarsGRAMDensityType.eVAMarsGRAMDensityTypeMean.__doc__ = "Mean density"
AgEVAMarsGRAMDensityType.eVAMarsGRAMDensityTypeHigh.__doc__ = "High density"
AgEVAMarsGRAMDensityType.eVAMarsGRAMDensityTypeRandomlyPerturbed.__doc__ = "Randomly perturbed density"

agcls.AgTypeNameMap["AgEVAMarsGRAMDensityType"] = AgEVAMarsGRAMDensityType

class AgEVAVenusGRAMDensityType(IntEnum):
    """Density Type for VenusGRAM Density Models"""
    # Low density
    eVAVenusGRAMDensityTypeLow = 0
    # Mean density
    eVAVenusGRAMDensityTypeMean = 1
    # High density
    eVAVenusGRAMDensityTypeHigh = 2
    # Randomly perturbed density
    eVAVenusGRAMDensityTypeRandomlyPerturbed = 3

AgEVAVenusGRAMDensityType.eVAVenusGRAMDensityTypeLow.__doc__ = "Low density"
AgEVAVenusGRAMDensityType.eVAVenusGRAMDensityTypeMean.__doc__ = "Mean density"
AgEVAVenusGRAMDensityType.eVAVenusGRAMDensityTypeHigh.__doc__ = "High density"
AgEVAVenusGRAMDensityType.eVAVenusGRAMDensityTypeRandomlyPerturbed.__doc__ = "Randomly perturbed density"

agcls.AgTypeNameMap["AgEVAVenusGRAMDensityType"] = AgEVAVenusGRAMDensityType

class AgEVATabVecInterpMethod(IntEnum):
    """The interpolation method for tabulated area vector file."""
    # Bilinear interpolation on the Cartesian grid.
    eVATabVecCartesianInterpolation = 0
    # Bilinear interpolation in magnitude and direction space.
    eVATabVecMagDirInterpolation = 1

AgEVATabVecInterpMethod.eVATabVecCartesianInterpolation.__doc__ = "Bilinear interpolation on the Cartesian grid."
AgEVATabVecInterpMethod.eVATabVecMagDirInterpolation.__doc__ = "Bilinear interpolation in magnitude and direction space."

agcls.AgTypeNameMap["AgEVATabVecInterpMethod"] = AgEVATabVecInterpMethod

class AgEVAControlEngineConstAcc(IntEnum):
    """Constant Acceleration and Isp engine model properties that can be selected as control parameters for a Target Sequence."""
    # The gravitational acceleration constant at sea level on the Earth.
    eVAControlEngineConstAccGrav = 0
    # The acceleration for the engine.
    eVAControlEngineConstAccAcceleration = 1
    # The specific impulse for the engine.
    eVAControlEngineConstAccIsp = 2

AgEVAControlEngineConstAcc.eVAControlEngineConstAccGrav.__doc__ = "The gravitational acceleration constant at sea level on the Earth."
AgEVAControlEngineConstAcc.eVAControlEngineConstAccAcceleration.__doc__ = "The acceleration for the engine."
AgEVAControlEngineConstAcc.eVAControlEngineConstAccIsp.__doc__ = "The specific impulse for the engine."

agcls.AgTypeNameMap["AgEVAControlEngineConstAcc"] = AgEVAControlEngineConstAcc

class AgEVAControlEngineConstant(IntEnum):
    """Constant Thrust and Isp engine model properties that can be selected as control parameters for a Target Sequence."""
    # The gravitational acceleration constant at sea level on the Earth.
    eVAControlEngineConstantGrav = 0
    # The thrust for the engine.
    eVAControlEngineConstantThrust = 1
    # The specific impulse for the engine.
    eVAControlEngineConstantIsp = 2

AgEVAControlEngineConstant.eVAControlEngineConstantGrav.__doc__ = "The gravitational acceleration constant at sea level on the Earth."
AgEVAControlEngineConstant.eVAControlEngineConstantThrust.__doc__ = "The thrust for the engine."
AgEVAControlEngineConstant.eVAControlEngineConstantIsp.__doc__ = "The specific impulse for the engine."

agcls.AgTypeNameMap["AgEVAControlEngineConstant"] = AgEVAControlEngineConstant

class AgEVAControlEngineCustom(IntEnum):
    """Custom engine model properties that can be selected as control parameters for a Target Sequence."""
    # Earth surface gravity acceleration for Isp conversions.
    eVAControlEngineCustomGrav = 0

AgEVAControlEngineCustom.eVAControlEngineCustomGrav.__doc__ = "Earth surface gravity acceleration for Isp conversions."

agcls.AgTypeNameMap["AgEVAControlEngineCustom"] = AgEVAControlEngineCustom

class AgEVAControlEngineThrottleTable(IntEnum):
    """Throttle table engine model properties that can be selected as control parameters for a Target Sequence."""
    # Gravitational acceleration constant at sea level on the Earth.
    eVAControlEngineThrottleTableGrav = 0
    # The degradation factor is (1 - x)n, where n is the time since epoch in years, and x is the percent degradation per year.
    eVAControlEngineThrottleTablePercentDegradationPerYear = 1
    # The date and time used as a reference epoch for degradation.
    eVAControlEngineThrottleTableReferenceEpoch = 2

AgEVAControlEngineThrottleTable.eVAControlEngineThrottleTableGrav.__doc__ = "Gravitational acceleration constant at sea level on the Earth."
AgEVAControlEngineThrottleTable.eVAControlEngineThrottleTablePercentDegradationPerYear.__doc__ = "The degradation factor is (1 - x)n, where n is the time since epoch in years, and x is the percent degradation per year."
AgEVAControlEngineThrottleTable.eVAControlEngineThrottleTableReferenceEpoch.__doc__ = "The date and time used as a reference epoch for degradation."

agcls.AgTypeNameMap["AgEVAControlEngineThrottleTable"] = AgEVAControlEngineThrottleTable

class AgEVAControlEngineIon(IntEnum):
    """Ion engine model properties that can be selected as control parameters for a Target Sequence."""
    # FlowRateModel.C0 - the constant coefficient.
    eVAControlEngineIonFlowRateC0 = 0
    # FlowRateModel.C1 - the linear coefficient.
    eVAControlEngineIonFlowRateC1 = 1
    # FlowRateModel.C2 - the quadratic coefficient.
    eVAControlEngineIonFlowRateC2 = 2
    # FlowRateModel.C3 - the cubic coefficient.
    eVAControlEngineIonFlowRateC3 = 3
    # Gravitational acceleration constant at sea level on the Earth.
    eVAControlEngineIonGrav = 4
    # IspModel.C0 - the constant coefficient.
    eVAControlEngineIonIspC0 = 5
    # IspModel.C1 - the linear coefficient.
    eVAControlEngineIonIspC1 = 6
    # IspModel.C2 - the quadratic coefficient.
    eVAControlEngineIonIspC2 = 7
    # IspModel.C3 - the cubic coefficient.
    eVAControlEngineIonIspC3 = 8
    # MassFlowEfficiencyModel.C0 - the constant coefficient.
    eVAControlEngineIonMassFlowEfficiencyC0 = 9
    # MassFlowEfficiencyModel.C1 - the linear coefficient.
    eVAControlEngineIonMassFlowEfficiencyC1 = 10
    # MassFlowEfficiencyModel.C2 - the quadratic coefficient.
    eVAControlEngineIonMassFlowEfficiencyC2 = 11
    # MassFlowEfficiencyModel.C3 - the cubic coefficient.
    eVAControlEngineIonMassFlowEfficiencyC3 = 12
    # Minimum power required for the engine to produce thrust. 
    eVAControlEngineIonMaxInputPower = 13
    # Maximum power that can be used by the engine to produce thrust.
    eVAControlEngineIonMinRequiredPower = 14
    # The degradation factor is (1 - x)n, where n is the time since epoch in years, and x is the percent degradation per year.
    eVAControlEngineIonPercentDegradationPerYear = 15
    # Percentage of available thrust to use (100 is full on, 0 is off).
    eVAControlEngineIonPercentThrottle = 16
    # PowerEfficiencyModel.C0 - the constant coefficient.
    eVAControlEngineIonPowerEfficiencyC0 = 17
    # PowerEfficiencyModel.C1 - the linear coefficient.
    eVAControlEngineIonPowerEfficiencyC1 = 18
    # PowerEfficiencyModel.C2 - the quadratic coefficient.
    eVAControlEngineIonPowerEfficiencyC2 = 19
    # PowerEfficiencyModel.C3 - the cubic coefficient.
    eVAControlEngineIonPowerEfficiencyC3 = 20
    # The date and time used as a reference epoch for degradation.
    eVAControlEngineIonReferenceEpoch = 21

AgEVAControlEngineIon.eVAControlEngineIonFlowRateC0.__doc__ = "FlowRateModel.C0 - the constant coefficient."
AgEVAControlEngineIon.eVAControlEngineIonFlowRateC1.__doc__ = "FlowRateModel.C1 - the linear coefficient."
AgEVAControlEngineIon.eVAControlEngineIonFlowRateC2.__doc__ = "FlowRateModel.C2 - the quadratic coefficient."
AgEVAControlEngineIon.eVAControlEngineIonFlowRateC3.__doc__ = "FlowRateModel.C3 - the cubic coefficient."
AgEVAControlEngineIon.eVAControlEngineIonGrav.__doc__ = "Gravitational acceleration constant at sea level on the Earth."
AgEVAControlEngineIon.eVAControlEngineIonIspC0.__doc__ = "IspModel.C0 - the constant coefficient."
AgEVAControlEngineIon.eVAControlEngineIonIspC1.__doc__ = "IspModel.C1 - the linear coefficient."
AgEVAControlEngineIon.eVAControlEngineIonIspC2.__doc__ = "IspModel.C2 - the quadratic coefficient."
AgEVAControlEngineIon.eVAControlEngineIonIspC3.__doc__ = "IspModel.C3 - the cubic coefficient."
AgEVAControlEngineIon.eVAControlEngineIonMassFlowEfficiencyC0.__doc__ = "MassFlowEfficiencyModel.C0 - the constant coefficient."
AgEVAControlEngineIon.eVAControlEngineIonMassFlowEfficiencyC1.__doc__ = "MassFlowEfficiencyModel.C1 - the linear coefficient."
AgEVAControlEngineIon.eVAControlEngineIonMassFlowEfficiencyC2.__doc__ = "MassFlowEfficiencyModel.C2 - the quadratic coefficient."
AgEVAControlEngineIon.eVAControlEngineIonMassFlowEfficiencyC3.__doc__ = "MassFlowEfficiencyModel.C3 - the cubic coefficient."
AgEVAControlEngineIon.eVAControlEngineIonMaxInputPower.__doc__ = "Minimum power required for the engine to produce thrust. "
AgEVAControlEngineIon.eVAControlEngineIonMinRequiredPower.__doc__ = "Maximum power that can be used by the engine to produce thrust."
AgEVAControlEngineIon.eVAControlEngineIonPercentDegradationPerYear.__doc__ = "The degradation factor is (1 - x)n, where n is the time since epoch in years, and x is the percent degradation per year."
AgEVAControlEngineIon.eVAControlEngineIonPercentThrottle.__doc__ = "Percentage of available thrust to use (100 is full on, 0 is off)."
AgEVAControlEngineIon.eVAControlEngineIonPowerEfficiencyC0.__doc__ = "PowerEfficiencyModel.C0 - the constant coefficient."
AgEVAControlEngineIon.eVAControlEngineIonPowerEfficiencyC1.__doc__ = "PowerEfficiencyModel.C1 - the linear coefficient."
AgEVAControlEngineIon.eVAControlEngineIonPowerEfficiencyC2.__doc__ = "PowerEfficiencyModel.C2 - the quadratic coefficient."
AgEVAControlEngineIon.eVAControlEngineIonPowerEfficiencyC3.__doc__ = "PowerEfficiencyModel.C3 - the cubic coefficient."
AgEVAControlEngineIon.eVAControlEngineIonReferenceEpoch.__doc__ = "The date and time used as a reference epoch for degradation."

agcls.AgTypeNameMap["AgEVAControlEngineIon"] = AgEVAControlEngineIon

class AgEVAControlEngineModelPoly(IntEnum):
    """Polynomial Thrust and Isp engine model properties that can be selected as control parameters for a Target Sequence."""
    # The thrust C0 coefficient.
    eVAControlEngineModelPolyThrustC0 = 0
    # The thrust C1 coefficient.
    eVAControlEngineModelPolyThrustC1 = 1
    # The thrust C2 coefficient.
    eVAControlEngineModelPolyThrustC2 = 2
    # The thrust C3 coefficient.
    eVAControlEngineModelPolyThrustC3 = 3
    # The thrust C4 coefficient.
    eVAControlEngineModelPolyThrustC4 = 4
    # The thrust C5 coefficient.
    eVAControlEngineModelPolyThrustC5 = 5
    # The thrust C6 coefficient.
    eVAControlEngineModelPolyThrustC6 = 6
    # The thrust C7 coefficient.
    eVAControlEngineModelPolyThrustC7 = 7
    # The thrust B7 coefficient.
    eVAControlEngineModelPolyThrustB7 = 8
    # The thrust E4 coefficient.
    eVAControlEngineModelPolyThrustE4 = 9
    # The thrust E5 coefficient.
    eVAControlEngineModelPolyThrustE5 = 10
    # The thrust E6 coefficient.
    eVAControlEngineModelPolyThrustE6 = 11
    # The thrust E7 coefficient.
    eVAControlEngineModelPolyThrustE7 = 12
    # The thrust K0 coefficient.
    eVAControlEngineModelPolyThrustK0 = 13
    # The thrust K1 coefficient.
    eVAControlEngineModelPolyThrustK1 = 14
    # The thrust reference temperature, Tr.
    eVAControlEngineModelPolyThrustReferenceTemp = 15
    # The specific impulse C0 coefficient.
    eVAControlEngineModelPolyIspC0 = 16
    # The specific impulse C1 coefficient.
    eVAControlEngineModelPolyIspC1 = 17
    # The specific impulse C2 coefficient.
    eVAControlEngineModelPolyIspC2 = 18
    # The specific impulse C3 coefficient.
    eVAControlEngineModelPolyIspC3 = 19
    # The specific impulse C4 coefficient.
    eVAControlEngineModelPolyIspC4 = 20
    # The specific impulse C5 coefficient.
    eVAControlEngineModelPolyIspC5 = 21
    # The specific impulse C6 coefficient.
    eVAControlEngineModelPolyIspC6 = 22
    # The specific impulse C7 coefficient.
    eVAControlEngineModelPolyIspC7 = 23
    # The specific impulse B7 coefficient.
    eVAControlEngineModelPolyIspB7 = 24
    # The specific impulse E4 coefficient.
    eVAControlEngineModelPolyIspE4 = 25
    # The specific impulse E5 coefficient.
    eVAControlEngineModelPolyIspE5 = 26
    # The specific impulse E6 coefficient.
    eVAControlEngineModelPolyIspE6 = 27
    # The specific impulse E7 coefficient.
    eVAControlEngineModelPolyIspE7 = 28
    # The specific impulse K0 coefficient.
    eVAControlEngineModelPolyIspK0 = 29
    # The specific impulse K1 coefficient.
    eVAControlEngineModelPolyIspK1 = 30
    # The specific impulse reference temperature, Tr.
    eVAControlEngineModelPolyIspReferenceTemp = 31
    # The gravitational acceleration constant at sea level on the Earth.
    eVAControlEngineModelPolyGrav = 32

AgEVAControlEngineModelPoly.eVAControlEngineModelPolyThrustC0.__doc__ = "The thrust C0 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyThrustC1.__doc__ = "The thrust C1 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyThrustC2.__doc__ = "The thrust C2 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyThrustC3.__doc__ = "The thrust C3 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyThrustC4.__doc__ = "The thrust C4 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyThrustC5.__doc__ = "The thrust C5 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyThrustC6.__doc__ = "The thrust C6 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyThrustC7.__doc__ = "The thrust C7 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyThrustB7.__doc__ = "The thrust B7 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyThrustE4.__doc__ = "The thrust E4 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyThrustE5.__doc__ = "The thrust E5 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyThrustE6.__doc__ = "The thrust E6 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyThrustE7.__doc__ = "The thrust E7 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyThrustK0.__doc__ = "The thrust K0 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyThrustK1.__doc__ = "The thrust K1 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyThrustReferenceTemp.__doc__ = "The thrust reference temperature, Tr."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyIspC0.__doc__ = "The specific impulse C0 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyIspC1.__doc__ = "The specific impulse C1 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyIspC2.__doc__ = "The specific impulse C2 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyIspC3.__doc__ = "The specific impulse C3 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyIspC4.__doc__ = "The specific impulse C4 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyIspC5.__doc__ = "The specific impulse C5 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyIspC6.__doc__ = "The specific impulse C6 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyIspC7.__doc__ = "The specific impulse C7 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyIspB7.__doc__ = "The specific impulse B7 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyIspE4.__doc__ = "The specific impulse E4 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyIspE5.__doc__ = "The specific impulse E5 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyIspE6.__doc__ = "The specific impulse E6 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyIspE7.__doc__ = "The specific impulse E7 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyIspK0.__doc__ = "The specific impulse K0 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyIspK1.__doc__ = "The specific impulse K1 coefficient."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyIspReferenceTemp.__doc__ = "The specific impulse reference temperature, Tr."
AgEVAControlEngineModelPoly.eVAControlEngineModelPolyGrav.__doc__ = "The gravitational acceleration constant at sea level on the Earth."

agcls.AgTypeNameMap["AgEVAControlEngineModelPoly"] = AgEVAControlEngineModelPoly

class AgEVAEngineModelFunction(IntEnum):
    """The engine model function types."""
    # Isp as an independent variable of an equation.
    eVAEngineModelFunctionIsp = 0
    # Power as an independent variable of an equation.
    eVAEngineModelFunctionPower = 1
    # Isp and Power as independent variables of an equation.
    eVAEngineModelFunctionIspAndPower = 2

AgEVAEngineModelFunction.eVAEngineModelFunctionIsp.__doc__ = "Isp as an independent variable of an equation."
AgEVAEngineModelFunction.eVAEngineModelFunctionPower.__doc__ = "Power as an independent variable of an equation."
AgEVAEngineModelFunction.eVAEngineModelFunctionIspAndPower.__doc__ = "Isp and Power as independent variables of an equation."

agcls.AgTypeNameMap["AgEVAEngineModelFunction"] = AgEVAEngineModelFunction

class AgEVAThrottleTableOperationMode(IntEnum):
    """Engine operation mode."""
    # Interpolation of engine performance data based on a regression polynomial model.
    eVAEngineOperationRegPoly = 0
    # Interpolation of engine performance data based on a piecewise linear model.
    eVAEngineOperationPiecewiseLinear = 1
    # Discrete engine operation: piecewise constant engine performance as a function of available power.
    eVAEngineOperationDiscrete = 2

AgEVAThrottleTableOperationMode.eVAEngineOperationRegPoly.__doc__ = "Interpolation of engine performance data based on a regression polynomial model."
AgEVAThrottleTableOperationMode.eVAEngineOperationPiecewiseLinear.__doc__ = "Interpolation of engine performance data based on a piecewise linear model."
AgEVAThrottleTableOperationMode.eVAEngineOperationDiscrete.__doc__ = "Discrete engine operation: piecewise constant engine performance as a function of available power."

agcls.AgTypeNameMap["AgEVAThrottleTableOperationMode"] = AgEVAThrottleTableOperationMode

class AgEVAIdealOrbitRadius(IntEnum):
    """Ideal Orbit Radius."""
    # Epoch centered average source radius.
    eVAIdealOrbitEpochCenteredAvgSourceRadius = 0
    # Instantanous characteristic distance.
    eVAIdealOrbitRadiusInstantCharDistance = 1

AgEVAIdealOrbitRadius.eVAIdealOrbitEpochCenteredAvgSourceRadius.__doc__ = "Epoch centered average source radius."
AgEVAIdealOrbitRadius.eVAIdealOrbitRadiusInstantCharDistance.__doc__ = "Instantanous characteristic distance."

agcls.AgTypeNameMap["AgEVAIdealOrbitRadius"] = AgEVAIdealOrbitRadius

class AgEVARotatingCoordinateSystem(IntEnum):
    """Barycenter centered rotating system."""
    # Barycenter centered rotating system.
    eVARotatingCoordinateSystemBarycenterCentered = 0
    # Primary centered rotating system.
    eVARotatingCoordinateSystemPrimaryCentered = 1
    # Secondary centered rotating system.
    eVARotatingCoordinateSystemSecondaryCentered = 2
    # L1 centered rotating system.
    eVARotatingCoordinateSystemL1Centered = 3
    # L2 centered rotating system.
    eVARotatingCoordinateSystemL2Centered = 4
    # L3 centered rotating system.
    eVARotatingCoordinateSystemL3Centered = 5
    # L4 centered rotating system.
    eVARotatingCoordinateSystemL4Centered = 6
    # L5 centered rotating system.
    eVARotatingCoordinateSystemL5Centered = 7

AgEVARotatingCoordinateSystem.eVARotatingCoordinateSystemBarycenterCentered.__doc__ = "Barycenter centered rotating system."
AgEVARotatingCoordinateSystem.eVARotatingCoordinateSystemPrimaryCentered.__doc__ = "Primary centered rotating system."
AgEVARotatingCoordinateSystem.eVARotatingCoordinateSystemSecondaryCentered.__doc__ = "Secondary centered rotating system."
AgEVARotatingCoordinateSystem.eVARotatingCoordinateSystemL1Centered.__doc__ = "L1 centered rotating system."
AgEVARotatingCoordinateSystem.eVARotatingCoordinateSystemL2Centered.__doc__ = "L2 centered rotating system."
AgEVARotatingCoordinateSystem.eVARotatingCoordinateSystemL3Centered.__doc__ = "L3 centered rotating system."
AgEVARotatingCoordinateSystem.eVARotatingCoordinateSystemL4Centered.__doc__ = "L4 centered rotating system."
AgEVARotatingCoordinateSystem.eVARotatingCoordinateSystemL5Centered.__doc__ = "L5 centered rotating system."

agcls.AgTypeNameMap["AgEVARotatingCoordinateSystem"] = AgEVARotatingCoordinateSystem

class AgEVAControlThrusters(IntEnum):
    """Thruster properties that can be selected as control parameters for a Target Sequence."""
    # The equivalent on-time percentage is a factor multiplied by the thrust. The thrust is applied continuously throughout the maneuver and is reduced by the percentage. The mass flow rate is likewise reduced.
    eVAControlThrustersEquivOnTime = 0
    # The thruster efficiency.
    eVAControlThrustersThrustEfficiency = 1
    # Thruster direction defined as a vector in the body frame. Spherical azimuth value.
    eVAControlThrustersSphericalAzimuth = 2
    # Thruster direction defined as a vector in the body frame. Spherical elevation value.
    eVAControlThrustersSphericalElevation = 3
    # Thruster direction defined as a vector in the body frame. Cartesian X value.
    eVAControlThrustersCartesianX = 4
    # Thruster direction defined as a vector in the body frame. Cartesian Y value.
    eVAControlThrustersCartesianY = 5
    # Thruster direction defined as a vector in the body frame. Cartesian Z value.
    eVAControlThrustersCartesianZ = 6

AgEVAControlThrusters.eVAControlThrustersEquivOnTime.__doc__ = "The equivalent on-time percentage is a factor multiplied by the thrust. The thrust is applied continuously throughout the maneuver and is reduced by the percentage. The mass flow rate is likewise reduced."
AgEVAControlThrusters.eVAControlThrustersThrustEfficiency.__doc__ = "The thruster efficiency."
AgEVAControlThrusters.eVAControlThrustersSphericalAzimuth.__doc__ = "Thruster direction defined as a vector in the body frame. Spherical azimuth value."
AgEVAControlThrusters.eVAControlThrustersSphericalElevation.__doc__ = "Thruster direction defined as a vector in the body frame. Spherical elevation value."
AgEVAControlThrusters.eVAControlThrustersCartesianX.__doc__ = "Thruster direction defined as a vector in the body frame. Cartesian X value."
AgEVAControlThrusters.eVAControlThrustersCartesianY.__doc__ = "Thruster direction defined as a vector in the body frame. Cartesian Y value."
AgEVAControlThrusters.eVAControlThrustersCartesianZ.__doc__ = "Thruster direction defined as a vector in the body frame. Cartesian Z value."

agcls.AgTypeNameMap["AgEVAControlThrusters"] = AgEVAControlThrusters

class AgEVAThrusterDirection(IntEnum):
    """The thruster direction type."""
    # The direction that is opposite the direction of the exhaust.
    eVAThrusterDirectionAcceleration = 0
    # The direction of engine exhaust.
    eVAThrusterDirectionExhaust = 1

AgEVAThrusterDirection.eVAThrusterDirectionAcceleration.__doc__ = "The direction that is opposite the direction of the exhaust."
AgEVAThrusterDirection.eVAThrusterDirectionExhaust.__doc__ = "The direction of engine exhaust."

agcls.AgTypeNameMap["AgEVAThrusterDirection"] = AgEVAThrusterDirection

class AgEVACriteria(IntEnum):
    """The criteria type."""
    # The test parameter must be equal (within the specified tolerance) to the specified value.
    eVACriteriaEquals = 0
    # The test parameter must be greater than the specified value.
    eVACriteriaGreaterThan = 1
    # The current value for the calculation object is greater by the specified tolerance than the minimum reached by that object during the segment.
    eVACriteriaGreaterThanMinimum = 2
    # The test parameter must be less than the specified value.
    eVACriteriaLessThan = 3
    # The current value for the calculation object is less by the specified tolerance than the maximum reached by that object during the segment.
    eVACriteriaLessThanMaximum = 4
    # The test parameter must be not equal (within the specified tolerance) to the specified value.
    eVACriteriaNotEqualTo = 5

AgEVACriteria.eVACriteriaEquals.__doc__ = "The test parameter must be equal (within the specified tolerance) to the specified value."
AgEVACriteria.eVACriteriaGreaterThan.__doc__ = "The test parameter must be greater than the specified value."
AgEVACriteria.eVACriteriaGreaterThanMinimum.__doc__ = "The current value for the calculation object is greater by the specified tolerance than the minimum reached by that object during the segment."
AgEVACriteria.eVACriteriaLessThan.__doc__ = "The test parameter must be less than the specified value."
AgEVACriteria.eVACriteriaLessThanMaximum.__doc__ = "The current value for the calculation object is less by the specified tolerance than the maximum reached by that object during the segment."
AgEVACriteria.eVACriteriaNotEqualTo.__doc__ = "The test parameter must be not equal (within the specified tolerance) to the specified value."

agcls.AgTypeNameMap["AgEVACriteria"] = AgEVACriteria

class AgEVAErrorControl(IntEnum):
    """Error Control for the numerical integrator."""
    # The error estimate of each integrated component is compared to the absolute error tolerance. Error control with this method is based on absolute values, e.g. in meters for position, m/sec for velocity, etc.
    eVAErrorControlAbsolute = 0
    # The error estimate of each element being integrated relative to the element's value at the start of the step is compared to the relative error tolerance, and the absolute error estimate of each element is compared to the absolute error tolerance.
    eVAErrorControlRelativeByComponent = 1
    # Relative to State error control.
    eVAErrorControlRelativeToState = 2
    # Error estimate of each integrated component relative to the element's change in value over the step is compared to the relative error tolerance, and the absolute error estimate of each integrated component is compared to the absolute error tolerance.
    eVAErrorControlRelativeToStep = 3

AgEVAErrorControl.eVAErrorControlAbsolute.__doc__ = "The error estimate of each integrated component is compared to the absolute error tolerance. Error control with this method is based on absolute values, e.g. in meters for position, m/sec for velocity, etc."
AgEVAErrorControl.eVAErrorControlRelativeByComponent.__doc__ = "The error estimate of each element being integrated relative to the element's value at the start of the step is compared to the relative error tolerance, and the absolute error estimate of each element is compared to the absolute error tolerance."
AgEVAErrorControl.eVAErrorControlRelativeToState.__doc__ = "Relative to State error control."
AgEVAErrorControl.eVAErrorControlRelativeToStep.__doc__ = "Error estimate of each integrated component relative to the element's change in value over the step is compared to the relative error tolerance, and the absolute error estimate of each integrated component is compared to the absolute error tolerance."

agcls.AgTypeNameMap["AgEVAErrorControl"] = AgEVAErrorControl

class AgEVAPredictorCorrector(IntEnum):
    """Predictor corrector scheme for the numerical integrator."""
    # All force models are re-evaluated at each corrector step.
    eVAPredictorCorrectorFull = 0
    # Only the two-body acceleration is re-evaluated at each corrector step.
    eVAPredictorCorrectorPseudo = 1

AgEVAPredictorCorrector.eVAPredictorCorrectorFull.__doc__ = "All force models are re-evaluated at each corrector step."
AgEVAPredictorCorrector.eVAPredictorCorrectorPseudo.__doc__ = "Only the two-body acceleration is re-evaluated at each corrector step."

agcls.AgTypeNameMap["AgEVAPredictorCorrector"] = AgEVAPredictorCorrector

class AgEVANumericalIntegrator(IntEnum):
    """Numerical integrator type."""
    # A 4th order Runge-Kutta integrator, adapting step size by comparing one full step to two half steps. Although this technique can be quite slow compared to the other algorithms, it is very common and can be used for comparison.
    eVANumericalIntegratorRK4thAdapt = 0
    # A 7th order Runge-Kutta-Fehlberg integrator with 8th order error control. This is the default integrator used in the HPOP propagator.
    eVANumericalIntegratorRKF7th8th = 1
    # A 9th order Runge-Kutta-Verner integrator with 8th order error control.
    eVANumericalIntegratorRKV8th9th = 2
    # An integrator based on Richardson extrapolation with automatic step size control.
    eVANumericalIntegratorBulirschStoer = 3
    # A 12th order Gauss-Jackson integrator for second order ODEs. There is currently no error control implemented for this method, meaning that a fixed step size is used.
    eVANumericalIntegratorGaussJackson = 4
    # A 2nd order Runge-Kutta integrator with 3rd order error control, using Bogacki and Shampine coefficients.
    eVANumericalIntegratorRK2nd3rd = 5
    # A 4th order Runge-Kutta integrator with 5th order error control, using Cash-Karp coefficients.
    eVANumericalIntegratorRK4th5th = 6
    # A 4th order Runge-Kutta integrator that does not employ error control.
    eVANumericalIntegratorRK4th = 7

AgEVANumericalIntegrator.eVANumericalIntegratorRK4thAdapt.__doc__ = "A 4th order Runge-Kutta integrator, adapting step size by comparing one full step to two half steps. Although this technique can be quite slow compared to the other algorithms, it is very common and can be used for comparison."
AgEVANumericalIntegrator.eVANumericalIntegratorRKF7th8th.__doc__ = "A 7th order Runge-Kutta-Fehlberg integrator with 8th order error control. This is the default integrator used in the HPOP propagator."
AgEVANumericalIntegrator.eVANumericalIntegratorRKV8th9th.__doc__ = "A 9th order Runge-Kutta-Verner integrator with 8th order error control."
AgEVANumericalIntegrator.eVANumericalIntegratorBulirschStoer.__doc__ = "An integrator based on Richardson extrapolation with automatic step size control."
AgEVANumericalIntegrator.eVANumericalIntegratorGaussJackson.__doc__ = "A 12th order Gauss-Jackson integrator for second order ODEs. There is currently no error control implemented for this method, meaning that a fixed step size is used."
AgEVANumericalIntegrator.eVANumericalIntegratorRK2nd3rd.__doc__ = "A 2nd order Runge-Kutta integrator with 3rd order error control, using Bogacki and Shampine coefficients."
AgEVANumericalIntegrator.eVANumericalIntegratorRK4th5th.__doc__ = "A 4th order Runge-Kutta integrator with 5th order error control, using Cash-Karp coefficients."
AgEVANumericalIntegrator.eVANumericalIntegratorRK4th.__doc__ = "A 4th order Runge-Kutta integrator that does not employ error control."

agcls.AgTypeNameMap["AgEVANumericalIntegrator"] = AgEVANumericalIntegrator

class AgEVACoeffRKV8th9th(IntEnum):
    """Coefficient sets for RKV8th(9th) integrator."""
    # SIAM 1978.
    eVACoeffRKV8th9th1978 = 0
    # Efficient.
    eVACoeffRKV8th9thEfficient = 1

AgEVACoeffRKV8th9th.eVACoeffRKV8th9th1978.__doc__ = "SIAM 1978."
AgEVACoeffRKV8th9th.eVACoeffRKV8th9thEfficient.__doc__ = "Efficient."

agcls.AgTypeNameMap["AgEVACoeffRKV8th9th"] = AgEVACoeffRKV8th9th


class IUserVariableDefinitionCollection(object):
    """The list of User Variables accessed through the Driver."""
    _uuid = "{4D460A14-D8C8-4BEB-A4D0-D387079AF0BC}"
    _num_methods = 8
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_add"] = _raise_uninitialized_error
        self.__dict__["_remove"] = _raise_uninitialized_error
        self.__dict__["_remove_all"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_index"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IUserVariableDefinitionCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IUserVariableDefinitionCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IUserVariableDefinitionCollection = agcom.GUID(IUserVariableDefinitionCollection._uuid)
        vtable_offset_local = IUserVariableDefinitionCollection._vtable_offset - 1
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IUserVariableDefinitionCollection, vtable_offset_local+1, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_add"] = IAGFUNCTYPE(pUnk, IID_IUserVariableDefinitionCollection, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_remove"] = IAGFUNCTYPE(pUnk, IID_IUserVariableDefinitionCollection, vtable_offset_local+3, agcom.VARIANT)
        self.__dict__["_remove_all"] = IAGFUNCTYPE(pUnk, IID_IUserVariableDefinitionCollection, vtable_offset_local+4, )
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IUserVariableDefinitionCollection, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IUserVariableDefinitionCollection, vtable_offset_local+6, POINTER(agcom.LONG))
        self.__dict__["_get_item_by_index"] = IAGFUNCTYPE(pUnk, IID_IUserVariableDefinitionCollection, vtable_offset_local+7, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_get_item_by_name"] = IAGFUNCTYPE(pUnk, IID_IUserVariableDefinitionCollection, vtable_offset_local+8, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IUserVariableDefinitionCollection.__dict__ and type(IUserVariableDefinitionCollection.__dict__[attrname]) == property:
            return IUserVariableDefinitionCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IUserVariableDefinitionCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IUserVariableDefinition":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def item(self, indexOrName:typing.Any) -> "IUserVariableDefinition":
        """Allows you to iterate through the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppVAUserVariableDefinition:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_indexOrName.COM_val, byref(arg_ppVAUserVariableDefinition.COM_val)))
            return arg_ppVAUserVariableDefinition.python_val

    def add(self, parameterName:str) -> "IUserVariableDefinition":
        """Adds a user variable to the collection."""
        with agmarshall.BSTR_arg(parameterName) as arg_parameterName, \
             agmarshall.AgInterface_out_arg() as arg_ppVAUserVariableDefinition:
            agcls.evaluate_hresult(self.__dict__["_add"](arg_parameterName.COM_val, byref(arg_ppVAUserVariableDefinition.COM_val)))
            return arg_ppVAUserVariableDefinition.python_val

    def remove(self, indexOrName:typing.Any) -> None:
        """Removes a user variable."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_remove"](arg_indexOrName.COM_val))

    def remove_all(self) -> None:
        """Removes all user variables."""
        agcls.evaluate_hresult(self.__dict__["_remove_all"]())

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def get_item_by_index(self, index:int) -> "IUserVariableDefinition":
        """Retrieves a user variable definition in the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppVAUserVariableDefinition:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_index"](arg_index.COM_val, byref(arg_ppVAUserVariableDefinition.COM_val)))
            return arg_ppVAUserVariableDefinition.python_val

    def get_item_by_name(self, name:str) -> "IUserVariableDefinition":
        """Retrieves a user variable definition in the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppVAUserVariableDefinition:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_name"](arg_name.COM_val, byref(arg_ppVAUserVariableDefinition.COM_val)))
            return arg_ppVAUserVariableDefinition.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{4D460A14-D8C8-4BEB-A4D0-D387079AF0BC}", IUserVariableDefinitionCollection)
agcls.AgTypeNameMap["IUserVariableDefinitionCollection"] = IUserVariableDefinitionCollection

class IUserVariableCollection(object):
    """The list of User Variables accessed through a segment that sets initial conditions."""
    _uuid = "{1BB5F3BC-51E2-4F2D-93E2-61322E3F65BE}"
    _num_methods = 5
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_index"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IUserVariableCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IUserVariableCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IUserVariableCollection = agcom.GUID(IUserVariableCollection._uuid)
        vtable_offset_local = IUserVariableCollection._vtable_offset - 1
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IUserVariableCollection, vtable_offset_local+1, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IUserVariableCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IUserVariableCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_get_item_by_index"] = IAGFUNCTYPE(pUnk, IID_IUserVariableCollection, vtable_offset_local+4, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_get_item_by_name"] = IAGFUNCTYPE(pUnk, IID_IUserVariableCollection, vtable_offset_local+5, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IUserVariableCollection.__dict__ and type(IUserVariableCollection.__dict__[attrname]) == property:
            return IUserVariableCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IUserVariableCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IUserVariable":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def item(self, indexOrName:typing.Any) -> "IUserVariable":
        """Allows you to iterate through the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppVAUserVariable:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_indexOrName.COM_val, byref(arg_ppVAUserVariable.COM_val)))
            return arg_ppVAUserVariable.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def get_item_by_index(self, index:int) -> "IUserVariable":
        """Retrieves a user variable in the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppVAUserVariable:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_index"](arg_index.COM_val, byref(arg_ppVAUserVariable.COM_val)))
            return arg_ppVAUserVariable.python_val

    def get_item_by_name(self, name:str) -> "IUserVariable":
        """Retrieves a user variable in the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppVAUserVariable:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_name"](arg_name.COM_val, byref(arg_ppVAUserVariable.COM_val)))
            return arg_ppVAUserVariable.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{1BB5F3BC-51E2-4F2D-93E2-61322E3F65BE}", IUserVariableCollection)
agcls.AgTypeNameMap["IUserVariableCollection"] = IUserVariableCollection

class IUserVariableUpdateCollection(object):
    """The list of User Variables accessed through an Update segment"""
    _uuid = "{7DC1728B-C032-4810-BE7B-7801C5CF906C}"
    _num_methods = 5
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_index"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IUserVariableUpdateCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IUserVariableUpdateCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IUserVariableUpdateCollection = agcom.GUID(IUserVariableUpdateCollection._uuid)
        vtable_offset_local = IUserVariableUpdateCollection._vtable_offset - 1
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IUserVariableUpdateCollection, vtable_offset_local+1, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IUserVariableUpdateCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IUserVariableUpdateCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_get_item_by_index"] = IAGFUNCTYPE(pUnk, IID_IUserVariableUpdateCollection, vtable_offset_local+4, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_get_item_by_name"] = IAGFUNCTYPE(pUnk, IID_IUserVariableUpdateCollection, vtable_offset_local+5, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IUserVariableUpdateCollection.__dict__ and type(IUserVariableUpdateCollection.__dict__[attrname]) == property:
            return IUserVariableUpdateCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IUserVariableUpdateCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IUserVariableUpdate":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def item(self, indexOrName:typing.Any) -> "IUserVariableUpdate":
        """Allows you to iterate through the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppVAUserVariableUpdate:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_indexOrName.COM_val, byref(arg_ppVAUserVariableUpdate.COM_val)))
            return arg_ppVAUserVariableUpdate.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def get_item_by_index(self, index:int) -> "IUserVariableUpdate":
        """Retrieves a user variable update in the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppVAUserVariableUpdate:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_index"](arg_index.COM_val, byref(arg_ppVAUserVariableUpdate.COM_val)))
            return arg_ppVAUserVariableUpdate.python_val

    def get_item_by_name(self, name:str) -> "IUserVariableUpdate":
        """Retrieves a user variable update in the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppVAUserVariableUpdate:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_name"](arg_name.COM_val, byref(arg_ppVAUserVariableUpdate.COM_val)))
            return arg_ppVAUserVariableUpdate.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{7DC1728B-C032-4810-BE7B-7801C5CF906C}", IUserVariableUpdateCollection)
agcls.AgTypeNameMap["IUserVariableUpdateCollection"] = IUserVariableUpdateCollection

class ICalculationGraphCollection(object):
    """The list of Calculations Graphs to display."""
    _uuid = "{77FD67C8-A85F-42F8-8546-9E1B944FF7F9}"
    _num_methods = 6
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_add"] = _raise_uninitialized_error
        self.__dict__["_remove"] = _raise_uninitialized_error
        self.__dict__["_remove_all"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalculationGraphCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalculationGraphCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalculationGraphCollection = agcom.GUID(ICalculationGraphCollection._uuid)
        vtable_offset_local = ICalculationGraphCollection._vtable_offset - 1
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_ICalculationGraphCollection, vtable_offset_local+1, agcom.LONG, POINTER(agcom.BSTR))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_ICalculationGraphCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_add"] = IAGFUNCTYPE(pUnk, IID_ICalculationGraphCollection, vtable_offset_local+3, agcom.BSTR)
        self.__dict__["_remove"] = IAGFUNCTYPE(pUnk, IID_ICalculationGraphCollection, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_remove_all"] = IAGFUNCTYPE(pUnk, IID_ICalculationGraphCollection, vtable_offset_local+5, )
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_ICalculationGraphCollection, vtable_offset_local+6, POINTER(agcom.LONG))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalculationGraphCollection.__dict__ and type(ICalculationGraphCollection.__dict__[attrname]) == property:
            return ICalculationGraphCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalculationGraphCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> str:
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def item(self, index:int) -> str:
        """Allows you to iterate through the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_index.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def add(self, graphName:str) -> None:
        """Adds a calculation graph"""
        with agmarshall.BSTR_arg(graphName) as arg_graphName:
            agcls.evaluate_hresult(self.__dict__["_add"](arg_graphName.COM_val))

    def remove(self, graphName:str) -> None:
        """Removes a parameter."""
        with agmarshall.BSTR_arg(graphName) as arg_graphName:
            agcls.evaluate_hresult(self.__dict__["_remove"](arg_graphName.COM_val))

    def remove_all(self) -> None:
        """Removes all parameters."""
        agcls.evaluate_hresult(self.__dict__["_remove_all"]())

    @property
    def count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{77FD67C8-A85F-42F8-8546-9E1B944FF7F9}", ICalculationGraphCollection)
agcls.AgTypeNameMap["ICalculationGraphCollection"] = ICalculationGraphCollection

class IConstraintCollection(object):
    """The list of constraints assigned to a stopping condition."""
    _uuid = "{055FF747-D60B-4AE2-82CE-B1FA61F85A3E}"
    _num_methods = 10
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_add"] = _raise_uninitialized_error
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_remove"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_cut"] = _raise_uninitialized_error
        self.__dict__["_paste"] = _raise_uninitialized_error
        self.__dict__["_insert_copy"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_index"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IConstraintCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IConstraintCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IConstraintCollection = agcom.GUID(IConstraintCollection._uuid)
        vtable_offset_local = IConstraintCollection._vtable_offset - 1
        self.__dict__["_add"] = IAGFUNCTYPE(pUnk, IID_IConstraintCollection, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IConstraintCollection, vtable_offset_local+2, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_remove"] = IAGFUNCTYPE(pUnk, IID_IConstraintCollection, vtable_offset_local+3, agcom.VARIANT)
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IConstraintCollection, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IConstraintCollection, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_cut"] = IAGFUNCTYPE(pUnk, IID_IConstraintCollection, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_paste"] = IAGFUNCTYPE(pUnk, IID_IConstraintCollection, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_insert_copy"] = IAGFUNCTYPE(pUnk, IID_IConstraintCollection, vtable_offset_local+8, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_get_item_by_index"] = IAGFUNCTYPE(pUnk, IID_IConstraintCollection, vtable_offset_local+9, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_get_item_by_name"] = IAGFUNCTYPE(pUnk, IID_IConstraintCollection, vtable_offset_local+10, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IConstraintCollection.__dict__ and type(IConstraintCollection.__dict__[attrname]) == property:
            return IConstraintCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IConstraintCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IAsTriggerCondition":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def add(self, resultName:str) -> "IAsTriggerCondition":
        """Adds a constraint to the collection."""
        with agmarshall.BSTR_arg(resultName) as arg_resultName, \
             agmarshall.AgInterface_out_arg() as arg_ppResult:
            agcls.evaluate_hresult(self.__dict__["_add"](arg_resultName.COM_val, byref(arg_ppResult.COM_val)))
            return arg_ppResult.python_val

    def item(self, indexOrName:typing.Any) -> "IAsTriggerCondition":
        """A property that allows you to iterate through the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppComponent:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_indexOrName.COM_val, byref(arg_ppComponent.COM_val)))
            return arg_ppComponent.python_val

    def remove(self, indexOrName:typing.Any) -> None:
        """Removes a specified constraint from the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_remove"](arg_indexOrName.COM_val))

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """A property that allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def cut(self, indexOrName:typing.Any) -> None:
        """Copies the constraint into the clipboard and removes the constraint from the list."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_cut"](arg_indexOrName.COM_val))

    def paste(self) -> "IAsTriggerCondition":
        """Pastes the constraint from the clipboard and inserts into the list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_paste"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def insert_copy(self, cond:"IAsTriggerCondition") -> "IAsTriggerCondition":
        """Copies the constraint and inserts the copy into the list."""
        with agmarshall.AgInterface_in_arg(cond, IAsTriggerCondition) as arg_cond, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_insert_copy"](arg_cond.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def get_item_by_index(self, index:int) -> "IAsTriggerCondition":
        """Retrieves a constraint from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppComponent:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_index"](arg_index.COM_val, byref(arg_ppComponent.COM_val)))
            return arg_ppComponent.python_val

    def get_item_by_name(self, name:str) -> "IAsTriggerCondition":
        """Retrieves a constraint from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppComponent:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_name"](arg_name.COM_val, byref(arg_ppComponent.COM_val)))
            return arg_ppComponent.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{055FF747-D60B-4AE2-82CE-B1FA61F85A3E}", IConstraintCollection)
agcls.AgTypeNameMap["IConstraintCollection"] = IConstraintCollection

class IPluginProperties(object):
    """Properties of a plugin attitude control."""
    _uuid = "{E4AEB83C-8A8A-48F2-8DB8-BA2F4299CC97}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_property"] = _raise_uninitialized_error
        self.__dict__["_set_property"] = _raise_uninitialized_error
        self.__dict__["_get_available_properties"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPluginProperties._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPluginProperties from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPluginProperties = agcom.GUID(IPluginProperties._uuid)
        vtable_offset_local = IPluginProperties._vtable_offset - 1
        self.__dict__["_get_property"] = IAGFUNCTYPE(pUnk, IID_IPluginProperties, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.VARIANT))
        self.__dict__["_set_property"] = IAGFUNCTYPE(pUnk, IID_IPluginProperties, vtable_offset_local+2, agcom.BSTR, agcom.VARIANT)
        self.__dict__["_get_available_properties"] = IAGFUNCTYPE(pUnk, IID_IPluginProperties, vtable_offset_local+3, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPluginProperties.__dict__ and type(IPluginProperties.__dict__[attrname]) == property:
            return IPluginProperties.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPluginProperties.")
    
    def get_property(self, path:str) -> typing.Any:
        """Method to get a property."""
        with agmarshall.BSTR_arg(path) as arg_path, \
             agmarshall.VARIANT_arg() as arg_pPropertyValue:
            agcls.evaluate_hresult(self.__dict__["_get_property"](arg_path.COM_val, byref(arg_pPropertyValue.COM_val)))
            return arg_pPropertyValue.python_val

    def set_property(self, path:str, propertyValue:typing.Any) -> None:
        """Method to set a property."""
        with agmarshall.BSTR_arg(path) as arg_path, \
             agmarshall.VARIANT_arg(propertyValue) as arg_propertyValue:
            agcls.evaluate_hresult(self.__dict__["_set_property"](arg_path.COM_val, arg_propertyValue.COM_val))

    @property
    def available_properties(self) -> list:
        """Returns an array of all available properties."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_available_properties"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{E4AEB83C-8A8A-48F2-8DB8-BA2F4299CC97}", IPluginProperties)
agcls.AgTypeNameMap["IPluginProperties"] = IPluginProperties

class ISNOPTControlCollection(object):
    """Properties for the list of SNOPT control parameters."""
    _uuid = "{2E9D2998-066F-4DC6-9672-8EDF9F604351}"
    _num_methods = 4
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_get_control_by_paths"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISNOPTControlCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISNOPTControlCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISNOPTControlCollection = agcom.GUID(ISNOPTControlCollection._uuid)
        vtable_offset_local = ISNOPTControlCollection._vtable_offset - 1
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_ISNOPTControlCollection, vtable_offset_local+1, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_ISNOPTControlCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_ISNOPTControlCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_get_control_by_paths"] = IAGFUNCTYPE(pUnk, IID_ISNOPTControlCollection, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISNOPTControlCollection.__dict__ and type(ISNOPTControlCollection.__dict__[attrname]) == property:
            return ISNOPTControlCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISNOPTControlCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ISNOPTControl":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def item(self, index:int) -> "ISNOPTControl":
        """Allows you to iterate through the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_sNOPTControl:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_index.COM_val, byref(arg_sNOPTControl.COM_val)))
            return arg_sNOPTControl.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def get_control_by_paths(self, objectPath:str, controlPath:str) -> "ISNOPTControl":
        """Returns the control specified by the object/control path."""
        with agmarshall.BSTR_arg(objectPath) as arg_objectPath, \
             agmarshall.BSTR_arg(controlPath) as arg_controlPath, \
             agmarshall.AgInterface_out_arg() as arg_sNOPTControl:
            agcls.evaluate_hresult(self.__dict__["_get_control_by_paths"](arg_objectPath.COM_val, arg_controlPath.COM_val, byref(arg_sNOPTControl.COM_val)))
            return arg_sNOPTControl.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{2E9D2998-066F-4DC6-9672-8EDF9F604351}", ISNOPTControlCollection)
agcls.AgTypeNameMap["ISNOPTControlCollection"] = ISNOPTControlCollection

class ISNOPTResultCollection(object):
    """SNOPT result collection."""
    _uuid = "{53F7183C-7957-4C6F-8987-399A3F4C2A26}"
    _num_methods = 4
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_get_result_by_paths"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISNOPTResultCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISNOPTResultCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISNOPTResultCollection = agcom.GUID(ISNOPTResultCollection._uuid)
        vtable_offset_local = ISNOPTResultCollection._vtable_offset - 1
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_ISNOPTResultCollection, vtable_offset_local+1, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_ISNOPTResultCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_ISNOPTResultCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_get_result_by_paths"] = IAGFUNCTYPE(pUnk, IID_ISNOPTResultCollection, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISNOPTResultCollection.__dict__ and type(ISNOPTResultCollection.__dict__[attrname]) == property:
            return ISNOPTResultCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISNOPTResultCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ISNOPTResult":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def item(self, index:int) -> "ISNOPTResult":
        """Allows you to iterate through the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_sNOPTResult:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_index.COM_val, byref(arg_sNOPTResult.COM_val)))
            return arg_sNOPTResult.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def get_result_by_paths(self, objectPath:str, resultPath:str) -> "ISNOPTResult":
        """Returns the result specified by the object/result names."""
        with agmarshall.BSTR_arg(objectPath) as arg_objectPath, \
             agmarshall.BSTR_arg(resultPath) as arg_resultPath, \
             agmarshall.AgInterface_out_arg() as arg_sNOPTResult:
            agcls.evaluate_hresult(self.__dict__["_get_result_by_paths"](arg_objectPath.COM_val, arg_resultPath.COM_val, byref(arg_sNOPTResult.COM_val)))
            return arg_sNOPTResult.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{53F7183C-7957-4C6F-8987-399A3F4C2A26}", ISNOPTResultCollection)
agcls.AgTypeNameMap["ISNOPTResultCollection"] = ISNOPTResultCollection

class IIPOPTControlCollection(object):
    """Properties for the list of IPOPT control parameters."""
    _uuid = "{CAF26432-D3B9-4A8B-A9A2-9147DD520BBB}"
    _num_methods = 4
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_get_control_by_paths"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IIPOPTControlCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IIPOPTControlCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IIPOPTControlCollection = agcom.GUID(IIPOPTControlCollection._uuid)
        vtable_offset_local = IIPOPTControlCollection._vtable_offset - 1
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IIPOPTControlCollection, vtable_offset_local+1, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IIPOPTControlCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IIPOPTControlCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_get_control_by_paths"] = IAGFUNCTYPE(pUnk, IID_IIPOPTControlCollection, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IIPOPTControlCollection.__dict__ and type(IIPOPTControlCollection.__dict__[attrname]) == property:
            return IIPOPTControlCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IIPOPTControlCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IIPOPTControl":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def item(self, index:int) -> "IIPOPTControl":
        """Allows you to iterate through the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_iPOPTControl:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_index.COM_val, byref(arg_iPOPTControl.COM_val)))
            return arg_iPOPTControl.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def get_control_by_paths(self, objectPath:str, controlPath:str) -> "IIPOPTControl":
        """Returns the control specified by the object/control path."""
        with agmarshall.BSTR_arg(objectPath) as arg_objectPath, \
             agmarshall.BSTR_arg(controlPath) as arg_controlPath, \
             agmarshall.AgInterface_out_arg() as arg_iPOPTControl:
            agcls.evaluate_hresult(self.__dict__["_get_control_by_paths"](arg_objectPath.COM_val, arg_controlPath.COM_val, byref(arg_iPOPTControl.COM_val)))
            return arg_iPOPTControl.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{CAF26432-D3B9-4A8B-A9A2-9147DD520BBB}", IIPOPTControlCollection)
agcls.AgTypeNameMap["IIPOPTControlCollection"] = IIPOPTControlCollection

class IIPOPTResultCollection(object):
    """IPOPT result collection."""
    _uuid = "{DC5D0BFD-1459-4DAA-81B9-06790B157ED2}"
    _num_methods = 4
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_get_result_by_paths"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IIPOPTResultCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IIPOPTResultCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IIPOPTResultCollection = agcom.GUID(IIPOPTResultCollection._uuid)
        vtable_offset_local = IIPOPTResultCollection._vtable_offset - 1
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IIPOPTResultCollection, vtable_offset_local+1, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IIPOPTResultCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IIPOPTResultCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_get_result_by_paths"] = IAGFUNCTYPE(pUnk, IID_IIPOPTResultCollection, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IIPOPTResultCollection.__dict__ and type(IIPOPTResultCollection.__dict__[attrname]) == property:
            return IIPOPTResultCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IIPOPTResultCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IIPOPTResult":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def item(self, index:int) -> "IIPOPTResult":
        """Allows you to iterate through the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_iPOPTResult:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_index.COM_val, byref(arg_iPOPTResult.COM_val)))
            return arg_iPOPTResult.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def get_result_by_paths(self, objectPath:str, resultPath:str) -> "IIPOPTResult":
        """Returns the result specified by the object/result names."""
        with agmarshall.BSTR_arg(objectPath) as arg_objectPath, \
             agmarshall.BSTR_arg(resultPath) as arg_resultPath, \
             agmarshall.AgInterface_out_arg() as arg_iPOPTResult:
            agcls.evaluate_hresult(self.__dict__["_get_result_by_paths"](arg_objectPath.COM_val, arg_resultPath.COM_val, byref(arg_iPOPTResult.COM_val)))
            return arg_iPOPTResult.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{DC5D0BFD-1459-4DAA-81B9-06790B157ED2}", IIPOPTResultCollection)
agcls.AgTypeNameMap["IIPOPTResultCollection"] = IIPOPTResultCollection

class IManeuverOptimalFiniteSNOPTOptimizer(object):
    """Properties of SNOPT Optimizer options for optimal finite maneuver."""
    _uuid = "{176AB7BE-90C8-4558-8E24-9E9862CE18FD}"
    _num_methods = 21
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_objective"] = _raise_uninitialized_error
        self.__dict__["_set_objective"] = _raise_uninitialized_error
        self.__dict__["_get_max_major_iterations"] = _raise_uninitialized_error
        self.__dict__["_set_max_major_iterations"] = _raise_uninitialized_error
        self.__dict__["_get_tolerance_on_major_feasibility"] = _raise_uninitialized_error
        self.__dict__["_set_tolerance_on_major_feasibility"] = _raise_uninitialized_error
        self.__dict__["_get_tolerance_on_major_optimality"] = _raise_uninitialized_error
        self.__dict__["_set_tolerance_on_major_optimality"] = _raise_uninitialized_error
        self.__dict__["_get_max_minor_iterations"] = _raise_uninitialized_error
        self.__dict__["_set_max_minor_iterations"] = _raise_uninitialized_error
        self.__dict__["_get_tolerance_on_minor_feasibility"] = _raise_uninitialized_error
        self.__dict__["_set_tolerance_on_minor_feasibility"] = _raise_uninitialized_error
        self.__dict__["_get_options_filename"] = _raise_uninitialized_error
        self.__dict__["_set_options_filename"] = _raise_uninitialized_error
        self.__dict__["_get_provide_runtime_type_info"] = _raise_uninitialized_error
        self.__dict__["_get_use_console_monitor"] = _raise_uninitialized_error
        self.__dict__["_set_use_console_monitor"] = _raise_uninitialized_error
        self.__dict__["_get_allow_internal_primal_infeasibility_measure_normalization"] = _raise_uninitialized_error
        self.__dict__["_set_allow_internal_primal_infeasibility_measure_normalization"] = _raise_uninitialized_error
        self.__dict__["_get_snopt_scaling"] = _raise_uninitialized_error
        self.__dict__["_set_snopt_scaling"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IManeuverOptimalFiniteSNOPTOptimizer._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IManeuverOptimalFiniteSNOPTOptimizer from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IManeuverOptimalFiniteSNOPTOptimizer = agcom.GUID(IManeuverOptimalFiniteSNOPTOptimizer._uuid)
        vtable_offset_local = IManeuverOptimalFiniteSNOPTOptimizer._vtable_offset - 1
        self.__dict__["_get_objective"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_objective"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_max_major_iterations"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_max_major_iterations"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_tolerance_on_major_feasibility"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_tolerance_on_major_feasibility"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_tolerance_on_major_optimality"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_tolerance_on_major_optimality"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_max_minor_iterations"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_set_max_minor_iterations"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_get_tolerance_on_minor_feasibility"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_tolerance_on_minor_feasibility"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_options_filename"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+13, POINTER(agcom.BSTR))
        self.__dict__["_set_options_filename"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+14, agcom.BSTR)
        self.__dict__["_get_provide_runtime_type_info"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+15, POINTER(agcom.PVOID))
        self.__dict__["_get_use_console_monitor"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+16, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_console_monitor"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+17, agcom.VARIANT_BOOL)
        self.__dict__["_get_allow_internal_primal_infeasibility_measure_normalization"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+18, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_allow_internal_primal_infeasibility_measure_normalization"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+19, agcom.VARIANT_BOOL)
        self.__dict__["_get_snopt_scaling"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+20, POINTER(agcom.LONG))
        self.__dict__["_set_snopt_scaling"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSNOPTOptimizer, vtable_offset_local+21, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IManeuverOptimalFiniteSNOPTOptimizer.__dict__ and type(IManeuverOptimalFiniteSNOPTOptimizer.__dict__[attrname]) == property:
            return IManeuverOptimalFiniteSNOPTOptimizer.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IManeuverOptimalFiniteSNOPTOptimizer.")
    
    @property
    def objective(self) -> "AgEVAOptimalFiniteSNOPTObjective":
        """Objective."""
        with agmarshall.AgEnum_arg(AgEVAOptimalFiniteSNOPTObjective) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_objective"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @objective.setter
    def objective(self, newVal:"AgEVAOptimalFiniteSNOPTObjective") -> None:
        with agmarshall.AgEnum_arg(AgEVAOptimalFiniteSNOPTObjective, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_objective"](arg_newVal.COM_val))

    @property
    def max_major_iterations(self) -> int:
        """The maximum number of major iterations allowed."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_major_iterations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_major_iterations.setter
    def max_major_iterations(self, newVal:int) -> None:
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_major_iterations"](arg_newVal.COM_val))

    @property
    def tolerance_on_major_feasibility(self) -> float:
        """Specifies how accurately the nonlinear constraints should be satisfied."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_tolerance_on_major_feasibility"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @tolerance_on_major_feasibility.setter
    def tolerance_on_major_feasibility(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_tolerance_on_major_feasibility"](arg_newVal.COM_val))

    @property
    def tolerance_on_major_optimality(self) -> float:
        """Specifies the final accuracy of the dual variables."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_tolerance_on_major_optimality"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @tolerance_on_major_optimality.setter
    def tolerance_on_major_optimality(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_tolerance_on_major_optimality"](arg_newVal.COM_val))

    @property
    def max_minor_iterations(self) -> int:
        """The maximum number of iterations for the QP subproblem allowed during a single major iteration."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_minor_iterations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_minor_iterations.setter
    def max_minor_iterations(self, newVal:int) -> None:
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_minor_iterations"](arg_newVal.COM_val))

    @property
    def tolerance_on_minor_feasibility(self) -> float:
        """The tolerance which the QP subproblem must meet before being considered feasible."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_tolerance_on_minor_feasibility"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @tolerance_on_minor_feasibility.setter
    def tolerance_on_minor_feasibility(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_tolerance_on_minor_feasibility"](arg_newVal.COM_val))

    @property
    def options_filename(self) -> str:
        """If used, the associated SNOPT specifications file may define any of the various SNOPT options. Options in the file that conflict with options specified elsewhere will take precedence."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_options_filename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @options_filename.setter
    def options_filename(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_options_filename"](arg_newVal.COM_val))

    @property
    def provide_runtime_type_info(self) -> "IRuntimeTypeInfo":
        """Returns the IRuntimeTypeInfo interface to access properties at runtime."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_provide_runtime_type_info"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def use_console_monitor(self) -> bool:
        """Whether to use the out-of-process console monitor for the optimizer."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_console_monitor"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_console_monitor.setter
    def use_console_monitor(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_console_monitor"](arg_newVal.COM_val))

    @property
    def allow_internal_primal_infeasibility_measure_normalization(self) -> bool:
        """Whether to allow internal normalization of the primal infeasibility measure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_allow_internal_primal_infeasibility_measure_normalization"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @allow_internal_primal_infeasibility_measure_normalization.setter
    def allow_internal_primal_infeasibility_measure_normalization(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_allow_internal_primal_infeasibility_measure_normalization"](arg_newVal.COM_val))

    @property
    def snopt_scaling(self) -> "AgEVAOptimalFiniteSNOPTScaling":
        """SNOPT scaling option."""
        with agmarshall.AgEnum_arg(AgEVAOptimalFiniteSNOPTScaling) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_snopt_scaling"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @snopt_scaling.setter
    def snopt_scaling(self, newVal:"AgEVAOptimalFiniteSNOPTScaling") -> None:
        with agmarshall.AgEnum_arg(AgEVAOptimalFiniteSNOPTScaling, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_snopt_scaling"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{176AB7BE-90C8-4558-8E24-9E9862CE18FD}", IManeuverOptimalFiniteSNOPTOptimizer)
agcls.AgTypeNameMap["IManeuverOptimalFiniteSNOPTOptimizer"] = IManeuverOptimalFiniteSNOPTOptimizer

class IManeuverOptimalFiniteInitialBoundaryConditions(object):
    """Properties of initial boundary conditions for optimal finite maneuver."""
    _uuid = "{872A109F-710B-49D4-9A7D-544E7044530B}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_set_from_initial_guess"] = _raise_uninitialized_error
        self.__dict__["_set_set_from_initial_guess"] = _raise_uninitialized_error
        self.__dict__["_get_a"] = _raise_uninitialized_error
        self.__dict__["_get_h"] = _raise_uninitialized_error
        self.__dict__["_get_k"] = _raise_uninitialized_error
        self.__dict__["_get_p"] = _raise_uninitialized_error
        self.__dict__["_get_q"] = _raise_uninitialized_error
        self.__dict__["_get_l"] = _raise_uninitialized_error
        self.__dict__["_get_provide_runtime_type_info"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IManeuverOptimalFiniteInitialBoundaryConditions._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IManeuverOptimalFiniteInitialBoundaryConditions from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IManeuverOptimalFiniteInitialBoundaryConditions = agcom.GUID(IManeuverOptimalFiniteInitialBoundaryConditions._uuid)
        vtable_offset_local = IManeuverOptimalFiniteInitialBoundaryConditions._vtable_offset - 1
        self.__dict__["_get_set_from_initial_guess"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteInitialBoundaryConditions, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_set_from_initial_guess"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteInitialBoundaryConditions, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_a"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteInitialBoundaryConditions, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_h"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteInitialBoundaryConditions, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_k"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteInitialBoundaryConditions, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_p"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteInitialBoundaryConditions, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_get_q"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteInitialBoundaryConditions, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_get_l"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteInitialBoundaryConditions, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_get_provide_runtime_type_info"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteInitialBoundaryConditions, vtable_offset_local+9, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IManeuverOptimalFiniteInitialBoundaryConditions.__dict__ and type(IManeuverOptimalFiniteInitialBoundaryConditions.__dict__[attrname]) == property:
            return IManeuverOptimalFiniteInitialBoundaryConditions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IManeuverOptimalFiniteInitialBoundaryConditions.")
    
    @property
    def set_from_initial_guess(self) -> bool:
        """Set initial boundary condiitons from initial guess."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_set_from_initial_guess"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @set_from_initial_guess.setter
    def set_from_initial_guess(self, newVal:bool) -> None:
        """Set initial boundary condiitons from initial guess."""
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_set_from_initial_guess"](arg_newVal.COM_val))

    @property
    def a(self) -> "IManeuverOptimalFiniteBounds":
        """Bound limits for element a."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteBounds:
            agcls.evaluate_hresult(self.__dict__["_get_a"](byref(arg_ppAgVAManeuverOptimalFiniteBounds.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteBounds.python_val

    @property
    def h(self) -> "IManeuverOptimalFiniteBounds":
        """Bound limits for element h."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteBounds:
            agcls.evaluate_hresult(self.__dict__["_get_h"](byref(arg_ppAgVAManeuverOptimalFiniteBounds.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteBounds.python_val

    @property
    def k(self) -> "IManeuverOptimalFiniteBounds":
        """Bound limits for element k."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteBounds:
            agcls.evaluate_hresult(self.__dict__["_get_k"](byref(arg_ppAgVAManeuverOptimalFiniteBounds.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteBounds.python_val

    @property
    def p(self) -> "IManeuverOptimalFiniteBounds":
        """Bound limits for element p."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteBounds:
            agcls.evaluate_hresult(self.__dict__["_get_p"](byref(arg_ppAgVAManeuverOptimalFiniteBounds.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteBounds.python_val

    @property
    def q(self) -> "IManeuverOptimalFiniteBounds":
        """Bound limits for element q."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteBounds:
            agcls.evaluate_hresult(self.__dict__["_get_q"](byref(arg_ppAgVAManeuverOptimalFiniteBounds.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteBounds.python_val

    @property
    def l(self) -> "IManeuverOptimalFiniteBounds":
        """Bound limits for element L."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteBounds:
            agcls.evaluate_hresult(self.__dict__["_get_l"](byref(arg_ppAgVAManeuverOptimalFiniteBounds.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteBounds.python_val

    @property
    def provide_runtime_type_info(self) -> "IRuntimeTypeInfo":
        """Returns the IRuntimeTypeInfo interface to access properties at runtime."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_provide_runtime_type_info"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{872A109F-710B-49D4-9A7D-544E7044530B}", IManeuverOptimalFiniteInitialBoundaryConditions)
agcls.AgTypeNameMap["IManeuverOptimalFiniteInitialBoundaryConditions"] = IManeuverOptimalFiniteInitialBoundaryConditions

class IManeuverOptimalFiniteFinalBoundaryConditions(object):
    """Properties of final boundary conditions for optimal finite maneuver."""
    _uuid = "{476E5210-09E8-4DD7-ABCC-AF09E67DB21D}"
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_set_from_final_guess"] = _raise_uninitialized_error
        self.__dict__["_set_set_from_final_guess"] = _raise_uninitialized_error
        self.__dict__["_get_a"] = _raise_uninitialized_error
        self.__dict__["_get_h"] = _raise_uninitialized_error
        self.__dict__["_get_k"] = _raise_uninitialized_error
        self.__dict__["_get_p"] = _raise_uninitialized_error
        self.__dict__["_get_q"] = _raise_uninitialized_error
        self.__dict__["_get_l"] = _raise_uninitialized_error
        self.__dict__["_get_lower_delta_final_time"] = _raise_uninitialized_error
        self.__dict__["_set_lower_delta_final_time"] = _raise_uninitialized_error
        self.__dict__["_get_upper_delta_final_time"] = _raise_uninitialized_error
        self.__dict__["_set_upper_delta_final_time"] = _raise_uninitialized_error
        self.__dict__["_get_provide_runtime_type_info"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IManeuverOptimalFiniteFinalBoundaryConditions._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IManeuverOptimalFiniteFinalBoundaryConditions from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IManeuverOptimalFiniteFinalBoundaryConditions = agcom.GUID(IManeuverOptimalFiniteFinalBoundaryConditions._uuid)
        vtable_offset_local = IManeuverOptimalFiniteFinalBoundaryConditions._vtable_offset - 1
        self.__dict__["_get_set_from_final_guess"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteFinalBoundaryConditions, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_set_from_final_guess"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteFinalBoundaryConditions, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_a"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteFinalBoundaryConditions, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_h"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteFinalBoundaryConditions, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_k"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteFinalBoundaryConditions, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_p"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteFinalBoundaryConditions, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_get_q"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteFinalBoundaryConditions, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_get_l"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteFinalBoundaryConditions, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_get_lower_delta_final_time"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteFinalBoundaryConditions, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_lower_delta_final_time"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteFinalBoundaryConditions, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_upper_delta_final_time"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteFinalBoundaryConditions, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_upper_delta_final_time"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteFinalBoundaryConditions, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_provide_runtime_type_info"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteFinalBoundaryConditions, vtable_offset_local+13, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IManeuverOptimalFiniteFinalBoundaryConditions.__dict__ and type(IManeuverOptimalFiniteFinalBoundaryConditions.__dict__[attrname]) == property:
            return IManeuverOptimalFiniteFinalBoundaryConditions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IManeuverOptimalFiniteFinalBoundaryConditions.")
    
    @property
    def set_from_final_guess(self) -> bool:
        """Set initial boundary conditions from initial guess."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_set_from_final_guess"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @set_from_final_guess.setter
    def set_from_final_guess(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_set_from_final_guess"](arg_newVal.COM_val))

    @property
    def a(self) -> "IManeuverOptimalFiniteBounds":
        """Bound limits for element a."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteBounds:
            agcls.evaluate_hresult(self.__dict__["_get_a"](byref(arg_ppAgVAManeuverOptimalFiniteBounds.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteBounds.python_val

    @property
    def h(self) -> "IManeuverOptimalFiniteBounds":
        """Bound limits for element h."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteBounds:
            agcls.evaluate_hresult(self.__dict__["_get_h"](byref(arg_ppAgVAManeuverOptimalFiniteBounds.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteBounds.python_val

    @property
    def k(self) -> "IManeuverOptimalFiniteBounds":
        """Bound limits for element k."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteBounds:
            agcls.evaluate_hresult(self.__dict__["_get_k"](byref(arg_ppAgVAManeuverOptimalFiniteBounds.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteBounds.python_val

    @property
    def p(self) -> "IManeuverOptimalFiniteBounds":
        """Bound limits for element p."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteBounds:
            agcls.evaluate_hresult(self.__dict__["_get_p"](byref(arg_ppAgVAManeuverOptimalFiniteBounds.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteBounds.python_val

    @property
    def q(self) -> "IManeuverOptimalFiniteBounds":
        """Bound limits for element q."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteBounds:
            agcls.evaluate_hresult(self.__dict__["_get_q"](byref(arg_ppAgVAManeuverOptimalFiniteBounds.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteBounds.python_val

    @property
    def l(self) -> "IManeuverOptimalFiniteBounds":
        """Bound limits for element L."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteBounds:
            agcls.evaluate_hresult(self.__dict__["_get_l"](byref(arg_ppAgVAManeuverOptimalFiniteBounds.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteBounds.python_val

    @property
    def lower_delta_final_time(self) -> float:
        """Lower delta for final time"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_lower_delta_final_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @lower_delta_final_time.setter
    def lower_delta_final_time(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_lower_delta_final_time"](arg_newVal.COM_val))

    @property
    def upper_delta_final_time(self) -> float:
        """Upper delta for final time"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_upper_delta_final_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @upper_delta_final_time.setter
    def upper_delta_final_time(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_upper_delta_final_time"](arg_newVal.COM_val))

    @property
    def provide_runtime_type_info(self) -> "IRuntimeTypeInfo":
        """Returns the IRuntimeTypeInfo interface to access properties at runtime."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_provide_runtime_type_info"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{476E5210-09E8-4DD7-ABCC-AF09E67DB21D}", IManeuverOptimalFiniteFinalBoundaryConditions)
agcls.AgTypeNameMap["IManeuverOptimalFiniteFinalBoundaryConditions"] = IManeuverOptimalFiniteFinalBoundaryConditions

class IManeuverOptimalFinitePathBoundaryConditions(object):
    """Properties of path boundary conditions for optimal finite maneuver."""
    _uuid = "{BF41B9E6-80DE-4E15-8E36-00D735E7B40D}"
    _num_methods = 17
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_compute_from_initial_guess"] = _raise_uninitialized_error
        self.__dict__["_set_compute_from_initial_guess"] = _raise_uninitialized_error
        self.__dict__["_get_a"] = _raise_uninitialized_error
        self.__dict__["_get_h"] = _raise_uninitialized_error
        self.__dict__["_get_k"] = _raise_uninitialized_error
        self.__dict__["_get_p"] = _raise_uninitialized_error
        self.__dict__["_get_q"] = _raise_uninitialized_error
        self.__dict__["_get_l"] = _raise_uninitialized_error
        self.__dict__["_get_lower_bound_azimuth"] = _raise_uninitialized_error
        self.__dict__["_set_lower_bound_azimuth"] = _raise_uninitialized_error
        self.__dict__["_get_upper_bound_azimuth"] = _raise_uninitialized_error
        self.__dict__["_set_upper_bound_azimuth"] = _raise_uninitialized_error
        self.__dict__["_get_lower_bound_elevation"] = _raise_uninitialized_error
        self.__dict__["_set_lower_bound_elevation"] = _raise_uninitialized_error
        self.__dict__["_get_upper_bound_elevation"] = _raise_uninitialized_error
        self.__dict__["_set_upper_bound_elevation"] = _raise_uninitialized_error
        self.__dict__["_get_provide_runtime_type_info"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IManeuverOptimalFinitePathBoundaryConditions._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IManeuverOptimalFinitePathBoundaryConditions from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IManeuverOptimalFinitePathBoundaryConditions = agcom.GUID(IManeuverOptimalFinitePathBoundaryConditions._uuid)
        vtable_offset_local = IManeuverOptimalFinitePathBoundaryConditions._vtable_offset - 1
        self.__dict__["_get_compute_from_initial_guess"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinitePathBoundaryConditions, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_compute_from_initial_guess"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinitePathBoundaryConditions, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_a"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinitePathBoundaryConditions, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_h"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinitePathBoundaryConditions, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_k"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinitePathBoundaryConditions, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_p"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinitePathBoundaryConditions, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_get_q"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinitePathBoundaryConditions, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_get_l"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinitePathBoundaryConditions, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_get_lower_bound_azimuth"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinitePathBoundaryConditions, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_lower_bound_azimuth"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinitePathBoundaryConditions, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_upper_bound_azimuth"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinitePathBoundaryConditions, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_upper_bound_azimuth"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinitePathBoundaryConditions, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_lower_bound_elevation"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinitePathBoundaryConditions, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_lower_bound_elevation"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinitePathBoundaryConditions, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_upper_bound_elevation"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinitePathBoundaryConditions, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_upper_bound_elevation"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinitePathBoundaryConditions, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_provide_runtime_type_info"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinitePathBoundaryConditions, vtable_offset_local+17, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IManeuverOptimalFinitePathBoundaryConditions.__dict__ and type(IManeuverOptimalFinitePathBoundaryConditions.__dict__[attrname]) == property:
            return IManeuverOptimalFinitePathBoundaryConditions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IManeuverOptimalFinitePathBoundaryConditions.")
    
    @property
    def compute_from_initial_guess(self) -> bool:
        """Compute path boundary condiitons from initial guess."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_compute_from_initial_guess"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @compute_from_initial_guess.setter
    def compute_from_initial_guess(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_compute_from_initial_guess"](arg_newVal.COM_val))

    @property
    def a(self) -> "IManeuverOptimalFiniteBounds":
        """Bound limits for element a."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteBounds:
            agcls.evaluate_hresult(self.__dict__["_get_a"](byref(arg_ppAgVAManeuverOptimalFiniteBounds.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteBounds.python_val

    @property
    def h(self) -> "IManeuverOptimalFiniteBounds":
        """Bound limits for element h."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteBounds:
            agcls.evaluate_hresult(self.__dict__["_get_h"](byref(arg_ppAgVAManeuverOptimalFiniteBounds.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteBounds.python_val

    @property
    def k(self) -> "IManeuverOptimalFiniteBounds":
        """Bound limits for element k."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteBounds:
            agcls.evaluate_hresult(self.__dict__["_get_k"](byref(arg_ppAgVAManeuverOptimalFiniteBounds.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteBounds.python_val

    @property
    def p(self) -> "IManeuverOptimalFiniteBounds":
        """Bound limits for element p."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteBounds:
            agcls.evaluate_hresult(self.__dict__["_get_p"](byref(arg_ppAgVAManeuverOptimalFiniteBounds.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteBounds.python_val

    @property
    def q(self) -> "IManeuverOptimalFiniteBounds":
        """Bound limits for element q."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteBounds:
            agcls.evaluate_hresult(self.__dict__["_get_q"](byref(arg_ppAgVAManeuverOptimalFiniteBounds.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteBounds.python_val

    @property
    def l(self) -> "IManeuverOptimalFiniteBounds":
        """Bound limits for element L."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteBounds:
            agcls.evaluate_hresult(self.__dict__["_get_l"](byref(arg_ppAgVAManeuverOptimalFiniteBounds.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteBounds.python_val

    @property
    def lower_bound_azimuth(self) -> float:
        """Thrust direction azimuth lower bound along the path"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_lower_bound_azimuth"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @lower_bound_azimuth.setter
    def lower_bound_azimuth(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_lower_bound_azimuth"](arg_newVal.COM_val))

    @property
    def upper_bound_azimuth(self) -> float:
        """Thrust direction azimuth upper bound along the path"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_upper_bound_azimuth"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @upper_bound_azimuth.setter
    def upper_bound_azimuth(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_upper_bound_azimuth"](arg_newVal.COM_val))

    @property
    def lower_bound_elevation(self) -> float:
        """Thrust direction elevation lower bound along the path"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_lower_bound_elevation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @lower_bound_elevation.setter
    def lower_bound_elevation(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_lower_bound_elevation"](arg_newVal.COM_val))

    @property
    def upper_bound_elevation(self) -> float:
        """Thrust direction elevation upper bound along the path"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_upper_bound_elevation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @upper_bound_elevation.setter
    def upper_bound_elevation(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_upper_bound_elevation"](arg_newVal.COM_val))

    @property
    def provide_runtime_type_info(self) -> "IRuntimeTypeInfo":
        """Returns the IRuntimeTypeInfo interface to access properties at runtime."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_provide_runtime_type_info"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{BF41B9E6-80DE-4E15-8E36-00D735E7B40D}", IManeuverOptimalFinitePathBoundaryConditions)
agcls.AgTypeNameMap["IManeuverOptimalFinitePathBoundaryConditions"] = IManeuverOptimalFinitePathBoundaryConditions

class IManeuverOptimalFiniteSteeringNodeCollection(object):
    """Steering/nodes collection."""
    _uuid = "{1808D2D6-FAB4-4750-AE06-B37D95779815}"
    _num_methods = 3
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IManeuverOptimalFiniteSteeringNodeCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IManeuverOptimalFiniteSteeringNodeCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IManeuverOptimalFiniteSteeringNodeCollection = agcom.GUID(IManeuverOptimalFiniteSteeringNodeCollection._uuid)
        vtable_offset_local = IManeuverOptimalFiniteSteeringNodeCollection._vtable_offset - 1
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSteeringNodeCollection, vtable_offset_local+1, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSteeringNodeCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSteeringNodeCollection, vtable_offset_local+3, POINTER(agcom.LONG))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IManeuverOptimalFiniteSteeringNodeCollection.__dict__ and type(IManeuverOptimalFiniteSteeringNodeCollection.__dict__[attrname]) == property:
            return IManeuverOptimalFiniteSteeringNodeCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IManeuverOptimalFiniteSteeringNodeCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IManeuverOptimalFiniteSteeringNodeElement":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def item(self, index:int) -> "IManeuverOptimalFiniteSteeringNodeElement":
        """Allows you to iterate through the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_steeringNodeElement:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_index.COM_val, byref(arg_steeringNodeElement.COM_val)))
            return arg_steeringNodeElement.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{1808D2D6-FAB4-4750-AE06-B37D95779815}", IManeuverOptimalFiniteSteeringNodeCollection)
agcls.AgTypeNameMap["IManeuverOptimalFiniteSteeringNodeCollection"] = IManeuverOptimalFiniteSteeringNodeCollection

class IManeuverOptimalFiniteBounds(object):
    """The bounds for boundary interfaces."""
    _uuid = "{E2B960BB-5091-43DE-91DD-53D6E0EFA61D}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_lower_bound"] = _raise_uninitialized_error
        self.__dict__["_set_lower_bound"] = _raise_uninitialized_error
        self.__dict__["_get_upper_bound"] = _raise_uninitialized_error
        self.__dict__["_set_upper_bound"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IManeuverOptimalFiniteBounds._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IManeuverOptimalFiniteBounds from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IManeuverOptimalFiniteBounds = agcom.GUID(IManeuverOptimalFiniteBounds._uuid)
        vtable_offset_local = IManeuverOptimalFiniteBounds._vtable_offset - 1
        self.__dict__["_get_lower_bound"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteBounds, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_lower_bound"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteBounds, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_upper_bound"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteBounds, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_upper_bound"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteBounds, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IManeuverOptimalFiniteBounds.__dict__ and type(IManeuverOptimalFiniteBounds.__dict__[attrname]) == property:
            return IManeuverOptimalFiniteBounds.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IManeuverOptimalFiniteBounds.")
    
    @property
    def lower_bound(self) -> float:
        """Lower bound for a boundary element."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_lower_bound"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @lower_bound.setter
    def lower_bound(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_lower_bound"](arg_newVal.COM_val))

    @property
    def upper_bound(self) -> float:
        """Upper bound for a boundary element."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_upper_bound"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @upper_bound.setter
    def upper_bound(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_upper_bound"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E2B960BB-5091-43DE-91DD-53D6E0EFA61D}", IManeuverOptimalFiniteBounds)
agcls.AgTypeNameMap["IManeuverOptimalFiniteBounds"] = IManeuverOptimalFiniteBounds

class IGoldenSectionControlCollection(object):
    """Properties for the list of Golden Section control parameters."""
    _uuid = "{1E3A8FAA-05F5-4519-A63A-C793CCE4C27A}"
    _num_methods = 4
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_get_control_by_paths"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IGoldenSectionControlCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IGoldenSectionControlCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IGoldenSectionControlCollection = agcom.GUID(IGoldenSectionControlCollection._uuid)
        vtable_offset_local = IGoldenSectionControlCollection._vtable_offset - 1
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IGoldenSectionControlCollection, vtable_offset_local+1, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IGoldenSectionControlCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IGoldenSectionControlCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_get_control_by_paths"] = IAGFUNCTYPE(pUnk, IID_IGoldenSectionControlCollection, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IGoldenSectionControlCollection.__dict__ and type(IGoldenSectionControlCollection.__dict__[attrname]) == property:
            return IGoldenSectionControlCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IGoldenSectionControlCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IGoldenSectionControl":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def item(self, index:int) -> "IGoldenSectionControl":
        """Allows you to iterate through the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_goldenSectionControl:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_index.COM_val, byref(arg_goldenSectionControl.COM_val)))
            return arg_goldenSectionControl.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def get_control_by_paths(self, objectPath:str, controlPath:str) -> "IGoldenSectionControl":
        """Returns the control specified by the object/control path."""
        with agmarshall.BSTR_arg(objectPath) as arg_objectPath, \
             agmarshall.BSTR_arg(controlPath) as arg_controlPath, \
             agmarshall.AgInterface_out_arg() as arg_goldenSectionControl:
            agcls.evaluate_hresult(self.__dict__["_get_control_by_paths"](arg_objectPath.COM_val, arg_controlPath.COM_val, byref(arg_goldenSectionControl.COM_val)))
            return arg_goldenSectionControl.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{1E3A8FAA-05F5-4519-A63A-C793CCE4C27A}", IGoldenSectionControlCollection)
agcls.AgTypeNameMap["IGoldenSectionControlCollection"] = IGoldenSectionControlCollection

class IGoldenSectionControl(object):
    """Properties for control parameters of a Golden Section profile."""
    _uuid = "{91407E31-8792-460C-AE98-32CF4690D53F}"
    _num_methods = 15
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_enable"] = _raise_uninitialized_error
        self.__dict__["_set_enable"] = _raise_uninitialized_error
        self.__dict__["_get_name"] = _raise_uninitialized_error
        self.__dict__["_get_parent_name"] = _raise_uninitialized_error
        self.__dict__["_get_current_value"] = _raise_uninitialized_error
        self.__dict__["_get_lower_bound"] = _raise_uninitialized_error
        self.__dict__["_set_lower_bound"] = _raise_uninitialized_error
        self.__dict__["_get_upper_bound"] = _raise_uninitialized_error
        self.__dict__["_set_upper_bound"] = _raise_uninitialized_error
        self.__dict__["_get_use_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_set_use_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_get_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_set_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_get_tolerance"] = _raise_uninitialized_error
        self.__dict__["_set_tolerance"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IGoldenSectionControl._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IGoldenSectionControl from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IGoldenSectionControl = agcom.GUID(IGoldenSectionControl._uuid)
        vtable_offset_local = IGoldenSectionControl._vtable_offset - 1
        self.__dict__["_get_enable"] = IAGFUNCTYPE(pUnk, IID_IGoldenSectionControl, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable"] = IAGFUNCTYPE(pUnk, IID_IGoldenSectionControl, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_name"] = IAGFUNCTYPE(pUnk, IID_IGoldenSectionControl, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_get_parent_name"] = IAGFUNCTYPE(pUnk, IID_IGoldenSectionControl, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_get_current_value"] = IAGFUNCTYPE(pUnk, IID_IGoldenSectionControl, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_get_lower_bound"] = IAGFUNCTYPE(pUnk, IID_IGoldenSectionControl, vtable_offset_local+6, POINTER(agcom.VARIANT))
        self.__dict__["_set_lower_bound"] = IAGFUNCTYPE(pUnk, IID_IGoldenSectionControl, vtable_offset_local+7, agcom.VARIANT)
        self.__dict__["_get_upper_bound"] = IAGFUNCTYPE(pUnk, IID_IGoldenSectionControl, vtable_offset_local+8, POINTER(agcom.VARIANT))
        self.__dict__["_set_upper_bound"] = IAGFUNCTYPE(pUnk, IID_IGoldenSectionControl, vtable_offset_local+9, agcom.VARIANT)
        self.__dict__["_get_use_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IGoldenSectionControl, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IGoldenSectionControl, vtable_offset_local+11, agcom.VARIANT_BOOL)
        self.__dict__["_get_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IGoldenSectionControl, vtable_offset_local+12, POINTER(agcom.BSTR))
        self.__dict__["_set_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IGoldenSectionControl, vtable_offset_local+13, agcom.BSTR)
        self.__dict__["_get_tolerance"] = IAGFUNCTYPE(pUnk, IID_IGoldenSectionControl, vtable_offset_local+14, POINTER(agcom.VARIANT))
        self.__dict__["_set_tolerance"] = IAGFUNCTYPE(pUnk, IID_IGoldenSectionControl, vtable_offset_local+15, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IGoldenSectionControl.__dict__ and type(IGoldenSectionControl.__dict__[attrname]) == property:
            return IGoldenSectionControl.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IGoldenSectionControl.")
    
    @property
    def enable(self) -> bool:
        """If true, the variable is being used."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable.setter
    def enable(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable"](arg_newVal.COM_val))

    @property
    def name(self) -> str:
        """The name of the parameter."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def parent_name(self) -> str:
        """The name of the segment to which the parameter belongs."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_parent_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def current_value(self) -> typing.Any:
        """The value of the independent variable after the last targeter run."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_current_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def lower_bound(self) -> typing.Any:
        """Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_lower_bound"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @lower_bound.setter
    def lower_bound(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_lower_bound"](arg_newVal.COM_val))

    @property
    def upper_bound(self) -> typing.Any:
        """Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_upper_bound"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @upper_bound.setter
    def upper_bound(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_upper_bound"](arg_newVal.COM_val))

    @property
    def use_custom_display_unit(self) -> bool:
        """If true, allows display of values in another unit."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_custom_display_unit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_custom_display_unit.setter
    def use_custom_display_unit(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_custom_display_unit"](arg_newVal.COM_val))

    @property
    def custom_display_unit(self) -> str:
        """The unit in which the value will be displayed in the GUI."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_custom_display_unit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @custom_display_unit.setter
    def custom_display_unit(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_custom_display_unit"](arg_newVal.COM_val))

    @property
    def tolerance(self) -> typing.Any:
        """How close the targeter should come to the desired. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_tolerance"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @tolerance.setter
    def tolerance(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_tolerance"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{91407E31-8792-460C-AE98-32CF4690D53F}", IGoldenSectionControl)
agcls.AgTypeNameMap["IGoldenSectionControl"] = IGoldenSectionControl

class IGoldenSectionResultCollection(object):
    """Properties for the list of Golden Section result parameters."""
    _uuid = "{50AD7420-2926-4B14-8C99-88E1942EF754}"
    _num_methods = 4
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_get_result_by_paths"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IGoldenSectionResultCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IGoldenSectionResultCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IGoldenSectionResultCollection = agcom.GUID(IGoldenSectionResultCollection._uuid)
        vtable_offset_local = IGoldenSectionResultCollection._vtable_offset - 1
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IGoldenSectionResultCollection, vtable_offset_local+1, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IGoldenSectionResultCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IGoldenSectionResultCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_get_result_by_paths"] = IAGFUNCTYPE(pUnk, IID_IGoldenSectionResultCollection, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IGoldenSectionResultCollection.__dict__ and type(IGoldenSectionResultCollection.__dict__[attrname]) == property:
            return IGoldenSectionResultCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IGoldenSectionResultCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IGoldenSectionResult":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def item(self, index:int) -> "IGoldenSectionResult":
        """Allows you to iterate through the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_goldenSectionControl:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_index.COM_val, byref(arg_goldenSectionControl.COM_val)))
            return arg_goldenSectionControl.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def get_result_by_paths(self, objectPath:str, resultPath:str) -> "IGoldenSectionResult":
        """Returns the result specified by the object/result path."""
        with agmarshall.BSTR_arg(objectPath) as arg_objectPath, \
             agmarshall.BSTR_arg(resultPath) as arg_resultPath, \
             agmarshall.AgInterface_out_arg() as arg_goldenSectionResult:
            agcls.evaluate_hresult(self.__dict__["_get_result_by_paths"](arg_objectPath.COM_val, arg_resultPath.COM_val, byref(arg_goldenSectionResult.COM_val)))
            return arg_goldenSectionResult.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{50AD7420-2926-4B14-8C99-88E1942EF754}", IGoldenSectionResultCollection)
agcls.AgTypeNameMap["IGoldenSectionResultCollection"] = IGoldenSectionResultCollection

class IGoldenSectionResult(object):
    """Properties for result parameters of a Golden Section profile."""
    _uuid = "{67461697-37E6-4342-978D-9C6143528607}"
    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_enable"] = _raise_uninitialized_error
        self.__dict__["_set_enable"] = _raise_uninitialized_error
        self.__dict__["_get_name"] = _raise_uninitialized_error
        self.__dict__["_get_parent_name"] = _raise_uninitialized_error
        self.__dict__["_get_current_value"] = _raise_uninitialized_error
        self.__dict__["_get_desired_operation"] = _raise_uninitialized_error
        self.__dict__["_set_desired_operation"] = _raise_uninitialized_error
        self.__dict__["_get_use_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_set_use_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_get_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_set_custom_display_unit"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IGoldenSectionResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IGoldenSectionResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IGoldenSectionResult = agcom.GUID(IGoldenSectionResult._uuid)
        vtable_offset_local = IGoldenSectionResult._vtable_offset - 1
        self.__dict__["_get_enable"] = IAGFUNCTYPE(pUnk, IID_IGoldenSectionResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable"] = IAGFUNCTYPE(pUnk, IID_IGoldenSectionResult, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_name"] = IAGFUNCTYPE(pUnk, IID_IGoldenSectionResult, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_get_parent_name"] = IAGFUNCTYPE(pUnk, IID_IGoldenSectionResult, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_get_current_value"] = IAGFUNCTYPE(pUnk, IID_IGoldenSectionResult, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_get_desired_operation"] = IAGFUNCTYPE(pUnk, IID_IGoldenSectionResult, vtable_offset_local+6, POINTER(agcom.LONG))
        self.__dict__["_set_desired_operation"] = IAGFUNCTYPE(pUnk, IID_IGoldenSectionResult, vtable_offset_local+7, agcom.LONG)
        self.__dict__["_get_use_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IGoldenSectionResult, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IGoldenSectionResult, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_get_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IGoldenSectionResult, vtable_offset_local+10, POINTER(agcom.BSTR))
        self.__dict__["_set_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IGoldenSectionResult, vtable_offset_local+11, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IGoldenSectionResult.__dict__ and type(IGoldenSectionResult.__dict__[attrname]) == property:
            return IGoldenSectionResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IGoldenSectionResult.")
    
    @property
    def enable(self) -> bool:
        """If true, the variable is being used."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable.setter
    def enable(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable"](arg_newVal.COM_val))

    @property
    def name(self) -> str:
        """The name of the parameter."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def parent_name(self) -> str:
        """The name of the segment to which the parameter belongs."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_parent_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def current_value(self) -> typing.Any:
        """The value of the independent variable after the last targeter run."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_current_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def desired_operation(self) -> "AgEVAGoldenSectionDesiredOperation":
        """The Desired Operation/Objective of golden section."""
        with agmarshall.AgEnum_arg(AgEVAGoldenSectionDesiredOperation) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_desired_operation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @desired_operation.setter
    def desired_operation(self, inVal:"AgEVAGoldenSectionDesiredOperation") -> None:
        with agmarshall.AgEnum_arg(AgEVAGoldenSectionDesiredOperation, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_desired_operation"](arg_inVal.COM_val))

    @property
    def use_custom_display_unit(self) -> bool:
        """If true, allows display of values in another unit."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_custom_display_unit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_custom_display_unit.setter
    def use_custom_display_unit(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_custom_display_unit"](arg_newVal.COM_val))

    @property
    def custom_display_unit(self) -> str:
        """The unit in which the value will be displayed in the GUI."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_custom_display_unit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @custom_display_unit.setter
    def custom_display_unit(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_custom_display_unit"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{67461697-37E6-4342-978D-9C6143528607}", IGoldenSectionResult)
agcls.AgTypeNameMap["IGoldenSectionResult"] = IGoldenSectionResult

class IGridSearchControlCollection(object):
    """Properties for the list of Grid Search control parameters."""
    _uuid = "{BD562D00-ABDC-411B-813D-84C1E3597CEF}"
    _num_methods = 4
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_get_control_by_paths"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IGridSearchControlCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IGridSearchControlCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IGridSearchControlCollection = agcom.GUID(IGridSearchControlCollection._uuid)
        vtable_offset_local = IGridSearchControlCollection._vtable_offset - 1
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IGridSearchControlCollection, vtable_offset_local+1, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IGridSearchControlCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IGridSearchControlCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_get_control_by_paths"] = IAGFUNCTYPE(pUnk, IID_IGridSearchControlCollection, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IGridSearchControlCollection.__dict__ and type(IGridSearchControlCollection.__dict__[attrname]) == property:
            return IGridSearchControlCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IGridSearchControlCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IGridSearchControl":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def item(self, index:int) -> "IGridSearchControl":
        """Allows you to iterate through the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_gridSearchControl:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_index.COM_val, byref(arg_gridSearchControl.COM_val)))
            return arg_gridSearchControl.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def get_control_by_paths(self, objectPath:str, controlPath:str) -> "IGridSearchControl":
        """Returns the control specified by the object/control path."""
        with agmarshall.BSTR_arg(objectPath) as arg_objectPath, \
             agmarshall.BSTR_arg(controlPath) as arg_controlPath, \
             agmarshall.AgInterface_out_arg() as arg_gridSearchControl:
            agcls.evaluate_hresult(self.__dict__["_get_control_by_paths"](arg_objectPath.COM_val, arg_controlPath.COM_val, byref(arg_gridSearchControl.COM_val)))
            return arg_gridSearchControl.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{BD562D00-ABDC-411B-813D-84C1E3597CEF}", IGridSearchControlCollection)
agcls.AgTypeNameMap["IGridSearchControlCollection"] = IGridSearchControlCollection

class IGridSearchControl(object):
    """Properties for control parameters of a Grid Search profile."""
    _uuid = "{7E71EB52-998F-49E7-80BA-1B11574D59DF}"
    _num_methods = 15
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_enable"] = _raise_uninitialized_error
        self.__dict__["_set_enable"] = _raise_uninitialized_error
        self.__dict__["_get_name"] = _raise_uninitialized_error
        self.__dict__["_get_parent_name"] = _raise_uninitialized_error
        self.__dict__["_get_current_value"] = _raise_uninitialized_error
        self.__dict__["_get_lower_bound"] = _raise_uninitialized_error
        self.__dict__["_set_lower_bound"] = _raise_uninitialized_error
        self.__dict__["_get_upper_bound"] = _raise_uninitialized_error
        self.__dict__["_set_upper_bound"] = _raise_uninitialized_error
        self.__dict__["_get_use_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_set_use_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_get_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_set_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_get_step"] = _raise_uninitialized_error
        self.__dict__["_set_step"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IGridSearchControl._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IGridSearchControl from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IGridSearchControl = agcom.GUID(IGridSearchControl._uuid)
        vtable_offset_local = IGridSearchControl._vtable_offset - 1
        self.__dict__["_get_enable"] = IAGFUNCTYPE(pUnk, IID_IGridSearchControl, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable"] = IAGFUNCTYPE(pUnk, IID_IGridSearchControl, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_name"] = IAGFUNCTYPE(pUnk, IID_IGridSearchControl, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_get_parent_name"] = IAGFUNCTYPE(pUnk, IID_IGridSearchControl, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_get_current_value"] = IAGFUNCTYPE(pUnk, IID_IGridSearchControl, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_get_lower_bound"] = IAGFUNCTYPE(pUnk, IID_IGridSearchControl, vtable_offset_local+6, POINTER(agcom.VARIANT))
        self.__dict__["_set_lower_bound"] = IAGFUNCTYPE(pUnk, IID_IGridSearchControl, vtable_offset_local+7, agcom.VARIANT)
        self.__dict__["_get_upper_bound"] = IAGFUNCTYPE(pUnk, IID_IGridSearchControl, vtable_offset_local+8, POINTER(agcom.VARIANT))
        self.__dict__["_set_upper_bound"] = IAGFUNCTYPE(pUnk, IID_IGridSearchControl, vtable_offset_local+9, agcom.VARIANT)
        self.__dict__["_get_use_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IGridSearchControl, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IGridSearchControl, vtable_offset_local+11, agcom.VARIANT_BOOL)
        self.__dict__["_get_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IGridSearchControl, vtable_offset_local+12, POINTER(agcom.BSTR))
        self.__dict__["_set_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IGridSearchControl, vtable_offset_local+13, agcom.BSTR)
        self.__dict__["_get_step"] = IAGFUNCTYPE(pUnk, IID_IGridSearchControl, vtable_offset_local+14, POINTER(agcom.VARIANT))
        self.__dict__["_set_step"] = IAGFUNCTYPE(pUnk, IID_IGridSearchControl, vtable_offset_local+15, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IGridSearchControl.__dict__ and type(IGridSearchControl.__dict__[attrname]) == property:
            return IGridSearchControl.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IGridSearchControl.")
    
    @property
    def enable(self) -> bool:
        """If true, the variable is being used."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable.setter
    def enable(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable"](arg_newVal.COM_val))

    @property
    def name(self) -> str:
        """The name of the parameter."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def parent_name(self) -> str:
        """The name of the segment to which the parameter belongs."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_parent_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def current_value(self) -> typing.Any:
        """The value of the independent variable after the last targeter run."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_current_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def lower_bound(self) -> typing.Any:
        """Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_lower_bound"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @lower_bound.setter
    def lower_bound(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_lower_bound"](arg_newVal.COM_val))

    @property
    def upper_bound(self) -> typing.Any:
        """Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_upper_bound"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @upper_bound.setter
    def upper_bound(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_upper_bound"](arg_newVal.COM_val))

    @property
    def use_custom_display_unit(self) -> bool:
        """If true, allows display of values in another unit."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_custom_display_unit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_custom_display_unit.setter
    def use_custom_display_unit(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_custom_display_unit"](arg_newVal.COM_val))

    @property
    def custom_display_unit(self) -> str:
        """The unit in which the value will be displayed in the GUI."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_custom_display_unit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @custom_display_unit.setter
    def custom_display_unit(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_custom_display_unit"](arg_newVal.COM_val))

    @property
    def step(self) -> typing.Any:
        """Specifies the step size to use when evaluating the grid search. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @step.setter
    def step(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_step"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7E71EB52-998F-49E7-80BA-1B11574D59DF}", IGridSearchControl)
agcls.AgTypeNameMap["IGridSearchControl"] = IGridSearchControl

class IGridSearchResultCollection(object):
    """Properties for the list of Grid Search result parameters."""
    _uuid = "{BCA009A8-29CD-420A-955E-DC95A251CD9E}"
    _num_methods = 4
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_get_result_by_paths"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IGridSearchResultCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IGridSearchResultCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IGridSearchResultCollection = agcom.GUID(IGridSearchResultCollection._uuid)
        vtable_offset_local = IGridSearchResultCollection._vtable_offset - 1
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IGridSearchResultCollection, vtable_offset_local+1, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IGridSearchResultCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IGridSearchResultCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_get_result_by_paths"] = IAGFUNCTYPE(pUnk, IID_IGridSearchResultCollection, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IGridSearchResultCollection.__dict__ and type(IGridSearchResultCollection.__dict__[attrname]) == property:
            return IGridSearchResultCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IGridSearchResultCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IGridSearchResult":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def item(self, index:int) -> "IGridSearchResult":
        """Allows you to iterate through the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_gridSearchControl:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_index.COM_val, byref(arg_gridSearchControl.COM_val)))
            return arg_gridSearchControl.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def get_result_by_paths(self, objectPath:str, resultPath:str) -> "IGridSearchResult":
        """Returns the result specified by the object/result path."""
        with agmarshall.BSTR_arg(objectPath) as arg_objectPath, \
             agmarshall.BSTR_arg(resultPath) as arg_resultPath, \
             agmarshall.AgInterface_out_arg() as arg_gridSearchResult:
            agcls.evaluate_hresult(self.__dict__["_get_result_by_paths"](arg_objectPath.COM_val, arg_resultPath.COM_val, byref(arg_gridSearchResult.COM_val)))
            return arg_gridSearchResult.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{BCA009A8-29CD-420A-955E-DC95A251CD9E}", IGridSearchResultCollection)
agcls.AgTypeNameMap["IGridSearchResultCollection"] = IGridSearchResultCollection

class IGridSearchResult(object):
    """Properties for result parameters of a Grid Search profile."""
    _uuid = "{36F26633-D0C4-4692-A6D2-4D98451AB3A7}"
    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_enable"] = _raise_uninitialized_error
        self.__dict__["_set_enable"] = _raise_uninitialized_error
        self.__dict__["_get_name"] = _raise_uninitialized_error
        self.__dict__["_get_parent_name"] = _raise_uninitialized_error
        self.__dict__["_get_current_value"] = _raise_uninitialized_error
        self.__dict__["_get_desired_operation"] = _raise_uninitialized_error
        self.__dict__["_set_desired_operation"] = _raise_uninitialized_error
        self.__dict__["_get_use_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_set_use_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_get_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_set_custom_display_unit"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IGridSearchResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IGridSearchResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IGridSearchResult = agcom.GUID(IGridSearchResult._uuid)
        vtable_offset_local = IGridSearchResult._vtable_offset - 1
        self.__dict__["_get_enable"] = IAGFUNCTYPE(pUnk, IID_IGridSearchResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable"] = IAGFUNCTYPE(pUnk, IID_IGridSearchResult, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_name"] = IAGFUNCTYPE(pUnk, IID_IGridSearchResult, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_get_parent_name"] = IAGFUNCTYPE(pUnk, IID_IGridSearchResult, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_get_current_value"] = IAGFUNCTYPE(pUnk, IID_IGridSearchResult, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_get_desired_operation"] = IAGFUNCTYPE(pUnk, IID_IGridSearchResult, vtable_offset_local+6, POINTER(agcom.LONG))
        self.__dict__["_set_desired_operation"] = IAGFUNCTYPE(pUnk, IID_IGridSearchResult, vtable_offset_local+7, agcom.LONG)
        self.__dict__["_get_use_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IGridSearchResult, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IGridSearchResult, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_get_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IGridSearchResult, vtable_offset_local+10, POINTER(agcom.BSTR))
        self.__dict__["_set_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IGridSearchResult, vtable_offset_local+11, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IGridSearchResult.__dict__ and type(IGridSearchResult.__dict__[attrname]) == property:
            return IGridSearchResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IGridSearchResult.")
    
    @property
    def enable(self) -> bool:
        """If true, the variable is being used."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable.setter
    def enable(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable"](arg_newVal.COM_val))

    @property
    def name(self) -> str:
        """The name of the parameter."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def parent_name(self) -> str:
        """The name of the segment to which the parameter belongs."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_parent_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def current_value(self) -> typing.Any:
        """The value of the independent variable after the last targeter run."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_current_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def desired_operation(self) -> "AgEVAGridSearchDesiredOperation":
        """The Desired Operation/Objective of grid search."""
        with agmarshall.AgEnum_arg(AgEVAGridSearchDesiredOperation) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_desired_operation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @desired_operation.setter
    def desired_operation(self, inVal:"AgEVAGridSearchDesiredOperation") -> None:
        with agmarshall.AgEnum_arg(AgEVAGridSearchDesiredOperation, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_desired_operation"](arg_inVal.COM_val))

    @property
    def use_custom_display_unit(self) -> bool:
        """If true, allows display of values in another unit."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_custom_display_unit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_custom_display_unit.setter
    def use_custom_display_unit(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_custom_display_unit"](arg_newVal.COM_val))

    @property
    def custom_display_unit(self) -> str:
        """The unit in which the value will be displayed in the GUI."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_custom_display_unit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @custom_display_unit.setter
    def custom_display_unit(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_custom_display_unit"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{36F26633-D0C4-4692-A6D2-4D98451AB3A7}", IGridSearchResult)
agcls.AgTypeNameMap["IGridSearchResult"] = IGridSearchResult

class IBisectionControlCollection(object):
    """Properties for the list of Bisection control parameters."""
    _uuid = "{C6D33DA0-04F8-4655-88F9-6A3E70E0DFCB}"
    _num_methods = 4
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_get_control_by_paths"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBisectionControlCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBisectionControlCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBisectionControlCollection = agcom.GUID(IBisectionControlCollection._uuid)
        vtable_offset_local = IBisectionControlCollection._vtable_offset - 1
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IBisectionControlCollection, vtable_offset_local+1, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IBisectionControlCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IBisectionControlCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_get_control_by_paths"] = IAGFUNCTYPE(pUnk, IID_IBisectionControlCollection, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBisectionControlCollection.__dict__ and type(IBisectionControlCollection.__dict__[attrname]) == property:
            return IBisectionControlCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBisectionControlCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IBisectionControl":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def item(self, index:int) -> "IBisectionControl":
        """Allows you to iterate through the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_bisectionControl:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_index.COM_val, byref(arg_bisectionControl.COM_val)))
            return arg_bisectionControl.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def get_control_by_paths(self, objectPath:str, controlPath:str) -> "IBisectionControl":
        """Returns the control specified by the object/control path."""
        with agmarshall.BSTR_arg(objectPath) as arg_objectPath, \
             agmarshall.BSTR_arg(controlPath) as arg_controlPath, \
             agmarshall.AgInterface_out_arg() as arg_bisectionControl:
            agcls.evaluate_hresult(self.__dict__["_get_control_by_paths"](arg_objectPath.COM_val, arg_controlPath.COM_val, byref(arg_bisectionControl.COM_val)))
            return arg_bisectionControl.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{C6D33DA0-04F8-4655-88F9-6A3E70E0DFCB}", IBisectionControlCollection)
agcls.AgTypeNameMap["IBisectionControlCollection"] = IBisectionControlCollection

class IBisectionResult(object):
    """Properties for result parameters of a Bisection profile."""
    _uuid = "{750F4B13-2B5E-456E-9969-76D5B82356C8}"
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_enable"] = _raise_uninitialized_error
        self.__dict__["_set_enable"] = _raise_uninitialized_error
        self.__dict__["_get_name"] = _raise_uninitialized_error
        self.__dict__["_get_parent_name"] = _raise_uninitialized_error
        self.__dict__["_get_current_value"] = _raise_uninitialized_error
        self.__dict__["_get_desired_value"] = _raise_uninitialized_error
        self.__dict__["_set_desired_value"] = _raise_uninitialized_error
        self.__dict__["_get_tolerance"] = _raise_uninitialized_error
        self.__dict__["_set_tolerance"] = _raise_uninitialized_error
        self.__dict__["_get_use_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_set_use_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_get_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_set_custom_display_unit"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBisectionResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBisectionResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBisectionResult = agcom.GUID(IBisectionResult._uuid)
        vtable_offset_local = IBisectionResult._vtable_offset - 1
        self.__dict__["_get_enable"] = IAGFUNCTYPE(pUnk, IID_IBisectionResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable"] = IAGFUNCTYPE(pUnk, IID_IBisectionResult, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_name"] = IAGFUNCTYPE(pUnk, IID_IBisectionResult, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_get_parent_name"] = IAGFUNCTYPE(pUnk, IID_IBisectionResult, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_get_current_value"] = IAGFUNCTYPE(pUnk, IID_IBisectionResult, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_get_desired_value"] = IAGFUNCTYPE(pUnk, IID_IBisectionResult, vtable_offset_local+6, POINTER(agcom.VARIANT))
        self.__dict__["_set_desired_value"] = IAGFUNCTYPE(pUnk, IID_IBisectionResult, vtable_offset_local+7, agcom.VARIANT)
        self.__dict__["_get_tolerance"] = IAGFUNCTYPE(pUnk, IID_IBisectionResult, vtable_offset_local+8, POINTER(agcom.VARIANT))
        self.__dict__["_set_tolerance"] = IAGFUNCTYPE(pUnk, IID_IBisectionResult, vtable_offset_local+9, agcom.VARIANT)
        self.__dict__["_get_use_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IBisectionResult, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IBisectionResult, vtable_offset_local+11, agcom.VARIANT_BOOL)
        self.__dict__["_get_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IBisectionResult, vtable_offset_local+12, POINTER(agcom.BSTR))
        self.__dict__["_set_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IBisectionResult, vtable_offset_local+13, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBisectionResult.__dict__ and type(IBisectionResult.__dict__[attrname]) == property:
            return IBisectionResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBisectionResult.")
    
    @property
    def enable(self) -> bool:
        """If true, the variable is being used."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable.setter
    def enable(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable"](arg_newVal.COM_val))

    @property
    def name(self) -> str:
        """The name of the parameter."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def parent_name(self) -> str:
        """The name of the segment to which the parameter belongs."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_parent_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def current_value(self) -> typing.Any:
        """The value of the independent variable after the last targeter run."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_current_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def desired_value(self) -> typing.Any:
        """The value that you want to achieve."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_desired_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @desired_value.setter
    def desired_value(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_desired_value"](arg_newVal.COM_val))

    @property
    def tolerance(self) -> typing.Any:
        """The profile will stop when it achieves a value within this range of the Desired Value."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_tolerance"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @tolerance.setter
    def tolerance(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_tolerance"](arg_newVal.COM_val))

    @property
    def use_custom_display_unit(self) -> bool:
        """If true, allows display of values in another unit."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_custom_display_unit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_custom_display_unit.setter
    def use_custom_display_unit(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_custom_display_unit"](arg_newVal.COM_val))

    @property
    def custom_display_unit(self) -> str:
        """The unit in which the value will be displayed in the GUI."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_custom_display_unit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @custom_display_unit.setter
    def custom_display_unit(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_custom_display_unit"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{750F4B13-2B5E-456E-9969-76D5B82356C8}", IBisectionResult)
agcls.AgTypeNameMap["IBisectionResult"] = IBisectionResult

class IBisectionResultCollection(object):
    """Bisection result collection."""
    _uuid = "{6D0F0277-92F2-4931-A497-EF39C81C72B5}"
    _num_methods = 4
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_get_result_by_paths"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBisectionResultCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBisectionResultCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBisectionResultCollection = agcom.GUID(IBisectionResultCollection._uuid)
        vtable_offset_local = IBisectionResultCollection._vtable_offset - 1
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IBisectionResultCollection, vtable_offset_local+1, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IBisectionResultCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IBisectionResultCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_get_result_by_paths"] = IAGFUNCTYPE(pUnk, IID_IBisectionResultCollection, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBisectionResultCollection.__dict__ and type(IBisectionResultCollection.__dict__[attrname]) == property:
            return IBisectionResultCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBisectionResultCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IBisectionResult":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def item(self, index:int) -> "IBisectionResult":
        """Allows you to iterate through the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_sNOPTResult:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_index.COM_val, byref(arg_sNOPTResult.COM_val)))
            return arg_sNOPTResult.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def get_result_by_paths(self, objectPath:str, resultPath:str) -> "IBisectionResult":
        """Returns the result specified by the object/result names."""
        with agmarshall.BSTR_arg(objectPath) as arg_objectPath, \
             agmarshall.BSTR_arg(resultPath) as arg_resultPath, \
             agmarshall.AgInterface_out_arg() as arg_sNOPTResult:
            agcls.evaluate_hresult(self.__dict__["_get_result_by_paths"](arg_objectPath.COM_val, arg_resultPath.COM_val, byref(arg_sNOPTResult.COM_val)))
            return arg_sNOPTResult.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{6D0F0277-92F2-4931-A497-EF39C81C72B5}", IBisectionResultCollection)
agcls.AgTypeNameMap["IBisectionResultCollection"] = IBisectionResultCollection

class IStoppingConditionElement(object):
    """The status of a stopping condition."""
    _uuid = "{7508042C-1986-42AB-9B83-DE0AAA5626A0}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_active"] = _raise_uninitialized_error
        self.__dict__["_set_active"] = _raise_uninitialized_error
        self.__dict__["_enable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_disable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_is_control_parameter_enabled"] = _raise_uninitialized_error
        self.__dict__["_get_control_parameters_available"] = _raise_uninitialized_error
        self.__dict__["_get_properties"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStoppingConditionElement._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStoppingConditionElement from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStoppingConditionElement = agcom.GUID(IStoppingConditionElement._uuid)
        vtable_offset_local = IStoppingConditionElement._vtable_offset - 1
        self.__dict__["_get_active"] = IAGFUNCTYPE(pUnk, IID_IStoppingConditionElement, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_active"] = IAGFUNCTYPE(pUnk, IID_IStoppingConditionElement, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_enable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IStoppingConditionElement, vtable_offset_local+3, agcom.LONG)
        self.__dict__["_disable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IStoppingConditionElement, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_is_control_parameter_enabled"] = IAGFUNCTYPE(pUnk, IID_IStoppingConditionElement, vtable_offset_local+5, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_control_parameters_available"] = IAGFUNCTYPE(pUnk, IID_IStoppingConditionElement, vtable_offset_local+6, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_properties"] = IAGFUNCTYPE(pUnk, IID_IStoppingConditionElement, vtable_offset_local+7, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStoppingConditionElement.__dict__ and type(IStoppingConditionElement.__dict__[attrname]) == property:
            return IStoppingConditionElement.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStoppingConditionElement.")
    
    @property
    def active(self) -> bool:
        """If true, the stopping condition is active."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_active"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @active.setter
    def active(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_active"](arg_newVal.COM_val))

    def enable_control_parameter(self, param:"AgEVAControlStoppingCondition") -> None:
        """Enables or disables the specified control parameter"""
        with agmarshall.AgEnum_arg(AgEVAControlStoppingCondition, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_enable_control_parameter"](arg_param.COM_val))

    def disable_control_parameter(self, param:"AgEVAControlStoppingCondition") -> None:
        """Disables the specified control parameter"""
        with agmarshall.AgEnum_arg(AgEVAControlStoppingCondition, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_disable_control_parameter"](arg_param.COM_val))

    def is_control_parameter_enabled(self, param:"AgEVAControlStoppingCondition") -> bool:
        """Sees if the specified control is enabled"""
        with agmarshall.AgEnum_arg(AgEVAControlStoppingCondition, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_is_control_parameter_enabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_parameters_available(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_parameters_available"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def properties(self) -> "IStoppingConditionComponent":
        """The properties available to the stopping condition."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_properties"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{7508042C-1986-42AB-9B83-DE0AAA5626A0}", IStoppingConditionElement)
agcls.AgTypeNameMap["IStoppingConditionElement"] = IStoppingConditionElement

class IStoppingConditionCollection(object):
    """The list of Stopping Conditions."""
    _uuid = "{47FEE61C-D8B9-4E24-8417-6A9D1DF966A9}"
    _num_methods = 10
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_add"] = _raise_uninitialized_error
        self.__dict__["_remove"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_cut"] = _raise_uninitialized_error
        self.__dict__["_paste"] = _raise_uninitialized_error
        self.__dict__["_insert_copy"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_index"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStoppingConditionCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStoppingConditionCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStoppingConditionCollection = agcom.GUID(IStoppingConditionCollection._uuid)
        vtable_offset_local = IStoppingConditionCollection._vtable_offset - 1
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IStoppingConditionCollection, vtable_offset_local+1, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_add"] = IAGFUNCTYPE(pUnk, IID_IStoppingConditionCollection, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_remove"] = IAGFUNCTYPE(pUnk, IID_IStoppingConditionCollection, vtable_offset_local+3, agcom.VARIANT)
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IStoppingConditionCollection, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IStoppingConditionCollection, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_cut"] = IAGFUNCTYPE(pUnk, IID_IStoppingConditionCollection, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_paste"] = IAGFUNCTYPE(pUnk, IID_IStoppingConditionCollection, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_insert_copy"] = IAGFUNCTYPE(pUnk, IID_IStoppingConditionCollection, vtable_offset_local+8, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_get_item_by_index"] = IAGFUNCTYPE(pUnk, IID_IStoppingConditionCollection, vtable_offset_local+9, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_get_item_by_name"] = IAGFUNCTYPE(pUnk, IID_IStoppingConditionCollection, vtable_offset_local+10, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStoppingConditionCollection.__dict__ and type(IStoppingConditionCollection.__dict__[attrname]) == property:
            return IStoppingConditionCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStoppingConditionCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IStoppingConditionElement":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def item(self, indexOrName:typing.Any) -> "IStoppingConditionElement":
        """Allows you to iterate through the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppVAStoppingCondition:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_indexOrName.COM_val, byref(arg_ppVAStoppingCondition.COM_val)))
            return arg_ppVAStoppingCondition.python_val

    def add(self, conditionName:str) -> "IStoppingConditionElement":
        """Adds a stopping condition."""
        with agmarshall.BSTR_arg(conditionName) as arg_conditionName, \
             agmarshall.AgInterface_out_arg() as arg_ppVAStoppingCondition:
            agcls.evaluate_hresult(self.__dict__["_add"](arg_conditionName.COM_val, byref(arg_ppVAStoppingCondition.COM_val)))
            return arg_ppVAStoppingCondition.python_val

    def remove(self, indexOrName:typing.Any) -> None:
        """Removes a stopping condition."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_remove"](arg_indexOrName.COM_val))

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def cut(self, indexOrName:typing.Any) -> None:
        """Copies the stopping condition into the clipboard and removes the stopping condition from the list."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_cut"](arg_indexOrName.COM_val))

    def paste(self) -> "IStoppingConditionElement":
        """Pastes the stopping condition from the clipboard and inserts into the list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_paste"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def insert_copy(self, stopCond:"IStoppingConditionElement") -> "IStoppingConditionElement":
        """Copies the stopping condition and inserts the copy into the list."""
        with agmarshall.AgInterface_in_arg(stopCond, IStoppingConditionElement) as arg_stopCond, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_insert_copy"](arg_stopCond.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def get_item_by_index(self, index:int) -> "IStoppingConditionElement":
        """Retrieves a stopping condition in the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppVAStoppingCondition:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_index"](arg_index.COM_val, byref(arg_ppVAStoppingCondition.COM_val)))
            return arg_ppVAStoppingCondition.python_val

    def get_item_by_name(self, name:str) -> "IStoppingConditionElement":
        """Retrieves a stopping condition in the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppVAStoppingCondition:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_name"](arg_name.COM_val, byref(arg_ppVAStoppingCondition.COM_val)))
            return arg_ppVAStoppingCondition.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{47FEE61C-D8B9-4E24-8417-6A9D1DF966A9}", IStoppingConditionCollection)
agcls.AgTypeNameMap["IStoppingConditionCollection"] = IStoppingConditionCollection

class IMissionControlSequenceSegmentCollection(object):
    """Properties for a collection of segments."""
    _uuid = "{550AD0AB-FAB1-4632-895D-774CA07B120E}"
    _num_methods = 13
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_insert"] = _raise_uninitialized_error
        self.__dict__["_remove"] = _raise_uninitialized_error
        self.__dict__["_remove_all"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_cut"] = _raise_uninitialized_error
        self.__dict__["_paste"] = _raise_uninitialized_error
        self.__dict__["_insert_copy"] = _raise_uninitialized_error
        self.__dict__["_insert_by_name"] = _raise_uninitialized_error
        self.__dict__["_get_provide_runtime_type_info"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_index"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMissionControlSequenceSegmentCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMissionControlSequenceSegmentCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMissionControlSequenceSegmentCollection = agcom.GUID(IMissionControlSequenceSegmentCollection._uuid)
        vtable_offset_local = IMissionControlSequenceSegmentCollection._vtable_offset - 1
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSegmentCollection, vtable_offset_local+1, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_insert"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSegmentCollection, vtable_offset_local+2, agcom.LONG, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_remove"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSegmentCollection, vtable_offset_local+3, agcom.BSTR)
        self.__dict__["_remove_all"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSegmentCollection, vtable_offset_local+4, )
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSegmentCollection, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSegmentCollection, vtable_offset_local+6, POINTER(agcom.LONG))
        self.__dict__["_cut"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSegmentCollection, vtable_offset_local+7, agcom.BSTR)
        self.__dict__["_paste"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSegmentCollection, vtable_offset_local+8, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_insert_copy"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSegmentCollection, vtable_offset_local+9, agcom.PVOID, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_insert_by_name"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSegmentCollection, vtable_offset_local+10, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_get_provide_runtime_type_info"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSegmentCollection, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_get_item_by_index"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSegmentCollection, vtable_offset_local+12, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_get_item_by_name"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSegmentCollection, vtable_offset_local+13, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissionControlSequenceSegmentCollection.__dict__ and type(IMissionControlSequenceSegmentCollection.__dict__[attrname]) == property:
            return IMissionControlSequenceSegmentCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissionControlSequenceSegmentCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IMissionControlSequenceSegment":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def item(self, indexOrName:typing.Any) -> "IMissionControlSequenceSegment":
        """Returns the specified segment(using segment name or index number)."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppVAMCSSegment:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_indexOrName.COM_val, byref(arg_ppVAMCSSegment.COM_val)))
            return arg_ppVAMCSSegment.python_val

    def insert(self, segmentType:"AgEVASegmentType", segmentName:str, segmentToInsertBefore:str) -> "IMissionControlSequenceSegment":
        """Adds a segment to the segment collection."""
        with agmarshall.AgEnum_arg(AgEVASegmentType, segmentType) as arg_segmentType, \
             agmarshall.BSTR_arg(segmentName) as arg_segmentName, \
             agmarshall.BSTR_arg(segmentToInsertBefore) as arg_segmentToInsertBefore, \
             agmarshall.AgInterface_out_arg() as arg_ppMCSSegment:
            agcls.evaluate_hresult(self.__dict__["_insert"](arg_segmentType.COM_val, arg_segmentName.COM_val, arg_segmentToInsertBefore.COM_val, byref(arg_ppMCSSegment.COM_val)))
            return arg_ppMCSSegment.python_val

    def remove(self, segmentNameToRemove:str) -> None:
        """Removes a segment; the End segment cannot be deleted."""
        with agmarshall.BSTR_arg(segmentNameToRemove) as arg_segmentNameToRemove:
            agcls.evaluate_hresult(self.__dict__["_remove"](arg_segmentNameToRemove.COM_val))

    def remove_all(self) -> None:
        """Removes all segments; the End segment cannot be deleted."""
        agcls.evaluate_hresult(self.__dict__["_remove_all"]())

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def cut(self, segmentNameToCut:str) -> None:
        """Copies the segment into the clipboard and removes the segment from the sequence."""
        with agmarshall.BSTR_arg(segmentNameToCut) as arg_segmentNameToCut:
            agcls.evaluate_hresult(self.__dict__["_cut"](arg_segmentNameToCut.COM_val))

    def paste(self, segmentToPasteBefore:str) -> "IMissionControlSequenceSegment":
        """Pastes the segment from the clipboard and inserts in before the given segment name."""
        with agmarshall.BSTR_arg(segmentToPasteBefore) as arg_segmentToPasteBefore, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_paste"](arg_segmentToPasteBefore.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def insert_copy(self, segment:"IMissionControlSequenceSegment", segmentToInsertBefore:str) -> "IMissionControlSequenceSegment":
        """Copies the segment pointer and inserts the copy before the given segment name."""
        with agmarshall.AgInterface_in_arg(segment, IMissionControlSequenceSegment) as arg_segment, \
             agmarshall.BSTR_arg(segmentToInsertBefore) as arg_segmentToInsertBefore, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_insert_copy"](arg_segment.COM_val, arg_segmentToInsertBefore.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def insert_by_name(self, segmentName:str, segmentToInsertBefore:str) -> "IMissionControlSequenceSegment":
        """Inserts a segment by name to the segment collection."""
        with agmarshall.BSTR_arg(segmentName) as arg_segmentName, \
             agmarshall.BSTR_arg(segmentToInsertBefore) as arg_segmentToInsertBefore, \
             agmarshall.AgInterface_out_arg() as arg_ppMCSSegment:
            agcls.evaluate_hresult(self.__dict__["_insert_by_name"](arg_segmentName.COM_val, arg_segmentToInsertBefore.COM_val, byref(arg_ppMCSSegment.COM_val)))
            return arg_ppMCSSegment.python_val

    @property
    def provide_runtime_type_info(self) -> "IRuntimeTypeInfo":
        """Returns the IRuntimeTypeInfo interface to access properties at runtime."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_provide_runtime_type_info"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def get_item_by_index(self, index:int) -> "IMissionControlSequenceSegment":
        """Retrieves the specified segment(using segment index number)."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppVAMCSSegment:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_index"](arg_index.COM_val, byref(arg_ppVAMCSSegment.COM_val)))
            return arg_ppVAMCSSegment.python_val

    def get_item_by_name(self, name:str) -> "IMissionControlSequenceSegment":
        """Retrieves the specified segment(using segment name)."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppVAMCSSegment:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_name"](arg_name.COM_val, byref(arg_ppVAMCSSegment.COM_val)))
            return arg_ppVAMCSSegment.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{550AD0AB-FAB1-4632-895D-774CA07B120E}", IMissionControlSequenceSegmentCollection)
agcls.AgTypeNameMap["IMissionControlSequenceSegmentCollection"] = IMissionControlSequenceSegmentCollection

class IState(object):
    """Spacecraft Parameters properties for the spacecraft configuration."""
    _uuid = "{44DC2BBF-BC83-42AE-80A1-C1C4B399637F}"
    _num_methods = 33
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_element_type"] = _raise_uninitialized_error
        self.__dict__["_set_element_type"] = _raise_uninitialized_error
        self.__dict__["_get_element"] = _raise_uninitialized_error
        self.__dict__["_get_epoch"] = _raise_uninitialized_error
        self.__dict__["_set_epoch"] = _raise_uninitialized_error
        self.__dict__["_get_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_get_dry_mass"] = _raise_uninitialized_error
        self.__dict__["_set_dry_mass"] = _raise_uninitialized_error
        self.__dict__["_get_fuel_mass"] = _raise_uninitialized_error
        self.__dict__["_set_fuel_mass"] = _raise_uninitialized_error
        self.__dict__["_get_drag_area"] = _raise_uninitialized_error
        self.__dict__["_set_drag_area"] = _raise_uninitialized_error
        self.__dict__["_get_srp_area"] = _raise_uninitialized_error
        self.__dict__["_set_srp_area"] = _raise_uninitialized_error
        self.__dict__["_get_tank_pressure"] = _raise_uninitialized_error
        self.__dict__["_set_tank_pressure"] = _raise_uninitialized_error
        self.__dict__["_get_tank_temperature"] = _raise_uninitialized_error
        self.__dict__["_set_tank_temperature"] = _raise_uninitialized_error
        self.__dict__["_get_fuel_density"] = _raise_uninitialized_error
        self.__dict__["_set_fuel_density"] = _raise_uninitialized_error
        self.__dict__["_get_cr"] = _raise_uninitialized_error
        self.__dict__["_set_cr"] = _raise_uninitialized_error
        self.__dict__["_get_cd"] = _raise_uninitialized_error
        self.__dict__["_set_cd"] = _raise_uninitialized_error
        self.__dict__["_get_radiation_pressure_coeff"] = _raise_uninitialized_error
        self.__dict__["_set_radiation_pressure_coeff"] = _raise_uninitialized_error
        self.__dict__["_get_radiation_pressure_area"] = _raise_uninitialized_error
        self.__dict__["_set_radiation_pressure_area"] = _raise_uninitialized_error
        self.__dict__["_get_k1"] = _raise_uninitialized_error
        self.__dict__["_set_k1"] = _raise_uninitialized_error
        self.__dict__["_get_k2"] = _raise_uninitialized_error
        self.__dict__["_set_k2"] = _raise_uninitialized_error
        self.__dict__["_get_in_frame_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IState._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IState from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IState = agcom.GUID(IState._uuid)
        vtable_offset_local = IState._vtable_offset - 1
        self.__dict__["_get_element_type"] = IAGFUNCTYPE(pUnk, IID_IState, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_element_type"] = IAGFUNCTYPE(pUnk, IID_IState, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_element"] = IAGFUNCTYPE(pUnk, IID_IState, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_epoch"] = IAGFUNCTYPE(pUnk, IID_IState, vtable_offset_local+4, POINTER(agcom.VARIANT))
        self.__dict__["_set_epoch"] = IAGFUNCTYPE(pUnk, IID_IState, vtable_offset_local+5, agcom.VARIANT)
        self.__dict__["_get_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IState, vtable_offset_local+6, POINTER(agcom.BSTR))
        self.__dict__["_get_dry_mass"] = IAGFUNCTYPE(pUnk, IID_IState, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_dry_mass"] = IAGFUNCTYPE(pUnk, IID_IState, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_fuel_mass"] = IAGFUNCTYPE(pUnk, IID_IState, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_fuel_mass"] = IAGFUNCTYPE(pUnk, IID_IState, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_drag_area"] = IAGFUNCTYPE(pUnk, IID_IState, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_drag_area"] = IAGFUNCTYPE(pUnk, IID_IState, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_srp_area"] = IAGFUNCTYPE(pUnk, IID_IState, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_srp_area"] = IAGFUNCTYPE(pUnk, IID_IState, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_tank_pressure"] = IAGFUNCTYPE(pUnk, IID_IState, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_tank_pressure"] = IAGFUNCTYPE(pUnk, IID_IState, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_tank_temperature"] = IAGFUNCTYPE(pUnk, IID_IState, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_tank_temperature"] = IAGFUNCTYPE(pUnk, IID_IState, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_fuel_density"] = IAGFUNCTYPE(pUnk, IID_IState, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_set_fuel_density"] = IAGFUNCTYPE(pUnk, IID_IState, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_get_cr"] = IAGFUNCTYPE(pUnk, IID_IState, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_set_cr"] = IAGFUNCTYPE(pUnk, IID_IState, vtable_offset_local+22, agcom.DOUBLE)
        self.__dict__["_get_cd"] = IAGFUNCTYPE(pUnk, IID_IState, vtable_offset_local+23, POINTER(agcom.DOUBLE))
        self.__dict__["_set_cd"] = IAGFUNCTYPE(pUnk, IID_IState, vtable_offset_local+24, agcom.DOUBLE)
        self.__dict__["_get_radiation_pressure_coeff"] = IAGFUNCTYPE(pUnk, IID_IState, vtable_offset_local+25, POINTER(agcom.DOUBLE))
        self.__dict__["_set_radiation_pressure_coeff"] = IAGFUNCTYPE(pUnk, IID_IState, vtable_offset_local+26, agcom.DOUBLE)
        self.__dict__["_get_radiation_pressure_area"] = IAGFUNCTYPE(pUnk, IID_IState, vtable_offset_local+27, POINTER(agcom.DOUBLE))
        self.__dict__["_set_radiation_pressure_area"] = IAGFUNCTYPE(pUnk, IID_IState, vtable_offset_local+28, agcom.DOUBLE)
        self.__dict__["_get_k1"] = IAGFUNCTYPE(pUnk, IID_IState, vtable_offset_local+29, POINTER(agcom.DOUBLE))
        self.__dict__["_set_k1"] = IAGFUNCTYPE(pUnk, IID_IState, vtable_offset_local+30, agcom.DOUBLE)
        self.__dict__["_get_k2"] = IAGFUNCTYPE(pUnk, IID_IState, vtable_offset_local+31, POINTER(agcom.DOUBLE))
        self.__dict__["_set_k2"] = IAGFUNCTYPE(pUnk, IID_IState, vtable_offset_local+32, agcom.DOUBLE)
        self.__dict__["_get_in_frame_name"] = IAGFUNCTYPE(pUnk, IID_IState, vtable_offset_local+33, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IState.__dict__ and type(IState.__dict__[attrname]) == property:
            return IState.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IState.")
    
    @property
    def element_type(self) -> "AgEVAElementType":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVAElementType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_element_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_element_type(self, elementType:"AgEVAElementType") -> None:
        """Sets the element type."""
        with agmarshall.AgEnum_arg(AgEVAElementType, elementType) as arg_elementType:
            agcls.evaluate_hresult(self.__dict__["_set_element_type"](arg_elementType.COM_val))

    @property
    def element(self) -> "IElement":
        """Returns the currently selected element type."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAElement:
            agcls.evaluate_hresult(self.__dict__["_get_element"](byref(arg_ppVAElement.COM_val)))
            return arg_ppVAElement.python_val

    @property
    def epoch(self) -> typing.Any:
        """The epoch of the Orbit State. Uses DateFormat Dimension."""
        with agmarshall.VARIANT_arg() as arg_pEpoch:
            agcls.evaluate_hresult(self.__dict__["_get_epoch"](byref(arg_pEpoch.COM_val)))
            return arg_pEpoch.python_val

    @epoch.setter
    def epoch(self, epoch:typing.Any) -> None:
        with agmarshall.VARIANT_arg(epoch) as arg_epoch:
            agcls.evaluate_hresult(self.__dict__["_set_epoch"](arg_epoch.COM_val))

    @property
    def coord_system_name(self) -> str:
        """The coordinate system."""
        with agmarshall.BSTR_arg() as arg_pCoordSysName:
            agcls.evaluate_hresult(self.__dict__["_get_coord_system_name"](byref(arg_pCoordSysName.COM_val)))
            return arg_pCoordSysName.python_val

    @property
    def dry_mass(self) -> float:
        """The mass of the spacecraft exclusive of propellant. Uses Mass Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pDryMass:
            agcls.evaluate_hresult(self.__dict__["_get_dry_mass"](byref(arg_pDryMass.COM_val)))
            return arg_pDryMass.python_val

    @dry_mass.setter
    def dry_mass(self, dryMass:float) -> None:
        with agmarshall.DOUBLE_arg(dryMass) as arg_dryMass:
            agcls.evaluate_hresult(self.__dict__["_set_dry_mass"](arg_dryMass.COM_val))

    @property
    def fuel_mass(self) -> float:
        """The mass of the spacecraft propellant. Uses Mass Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pFuelMass:
            agcls.evaluate_hresult(self.__dict__["_get_fuel_mass"](byref(arg_pFuelMass.COM_val)))
            return arg_pFuelMass.python_val

    @fuel_mass.setter
    def fuel_mass(self, fuelMass:float) -> None:
        with agmarshall.DOUBLE_arg(fuelMass) as arg_fuelMass:
            agcls.evaluate_hresult(self.__dict__["_set_fuel_mass"](arg_fuelMass.COM_val))

    @property
    def drag_area(self) -> float:
        """The cross-sectional area of the spacecraft assumed perpendicular to the direction of motion, used for atmospheric drag calculations. Uses SmallArea Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pFuelMass:
            agcls.evaluate_hresult(self.__dict__["_get_drag_area"](byref(arg_pFuelMass.COM_val)))
            return arg_pFuelMass.python_val

    @drag_area.setter
    def drag_area(self, fuelMass:float) -> None:
        with agmarshall.DOUBLE_arg(fuelMass) as arg_fuelMass:
            agcls.evaluate_hresult(self.__dict__["_set_drag_area"](arg_fuelMass.COM_val))

    @property
    def srp_area(self) -> float:
        """The cross-sectional area of the spacecraft assumed perpendicular to the direction of solar radiation, used for solar radiation calculations. Uses SmallArea Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pSRPArea:
            agcls.evaluate_hresult(self.__dict__["_get_srp_area"](byref(arg_pSRPArea.COM_val)))
            return arg_pSRPArea.python_val

    @srp_area.setter
    def srp_area(self, sRPArea:float) -> None:
        with agmarshall.DOUBLE_arg(sRPArea) as arg_sRPArea:
            agcls.evaluate_hresult(self.__dict__["_set_srp_area"](arg_sRPArea.COM_val))

    @property
    def tank_pressure(self) -> float:
        """The fuel tank pressure. Uses Pressure Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pTankPressure:
            agcls.evaluate_hresult(self.__dict__["_get_tank_pressure"](byref(arg_pTankPressure.COM_val)))
            return arg_pTankPressure.python_val

    @tank_pressure.setter
    def tank_pressure(self, tankPressure:float) -> None:
        with agmarshall.DOUBLE_arg(tankPressure) as arg_tankPressure:
            agcls.evaluate_hresult(self.__dict__["_set_tank_pressure"](arg_tankPressure.COM_val))

    @property
    def tank_temperature(self) -> float:
        """The temperature of the fuel tank. Uses Temperature Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pTankTemperature:
            agcls.evaluate_hresult(self.__dict__["_get_tank_temperature"](byref(arg_pTankTemperature.COM_val)))
            return arg_pTankTemperature.python_val

    @tank_temperature.setter
    def tank_temperature(self, tankTemperature:float) -> None:
        with agmarshall.DOUBLE_arg(tankTemperature) as arg_tankTemperature:
            agcls.evaluate_hresult(self.__dict__["_set_tank_temperature"](arg_tankTemperature.COM_val))

    @property
    def fuel_density(self) -> float:
        """The density of the fuel tank. Uses SmallDensity Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pFuelDensity:
            agcls.evaluate_hresult(self.__dict__["_get_fuel_density"](byref(arg_pFuelDensity.COM_val)))
            return arg_pFuelDensity.python_val

    @fuel_density.setter
    def fuel_density(self, fuelDensity:float) -> None:
        with agmarshall.DOUBLE_arg(fuelDensity) as arg_fuelDensity:
            agcls.evaluate_hresult(self.__dict__["_set_fuel_density"](arg_fuelDensity.COM_val))

    @property
    def cr(self) -> float:
        """The reflectivity of the spacecraft used for solar radiation pressure calculations, where 2.0 is fully reflective and 1.0 is not reflective at all. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pCr:
            agcls.evaluate_hresult(self.__dict__["_get_cr"](byref(arg_pCr.COM_val)))
            return arg_pCr.python_val

    @cr.setter
    def cr(self, cr:float) -> None:
        with agmarshall.DOUBLE_arg(cr) as arg_cr:
            agcls.evaluate_hresult(self.__dict__["_set_cr"](arg_cr.COM_val))

    @property
    def cd(self) -> float:
        """The dimensionless drag coefficient associated with the drag area. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pCd:
            agcls.evaluate_hresult(self.__dict__["_get_cd"](byref(arg_pCd.COM_val)))
            return arg_pCd.python_val

    @cd.setter
    def cd(self, cd:float) -> None:
        with agmarshall.DOUBLE_arg(cd) as arg_cd:
            agcls.evaluate_hresult(self.__dict__["_set_cd"](arg_cd.COM_val))

    @property
    def radiation_pressure_coeff(self) -> float:
        """The reflectivity of the spacecraft used for central body radiation pressure (albedo / thermal pressure) calculations, where 2.0 is fully reflective and 1.0 is not reflective at all. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pRadiationPressureCoeff:
            agcls.evaluate_hresult(self.__dict__["_get_radiation_pressure_coeff"](byref(arg_pRadiationPressureCoeff.COM_val)))
            return arg_pRadiationPressureCoeff.python_val

    @radiation_pressure_coeff.setter
    def radiation_pressure_coeff(self, radiationPressureCoeff:float) -> None:
        with agmarshall.DOUBLE_arg(radiationPressureCoeff) as arg_radiationPressureCoeff:
            agcls.evaluate_hresult(self.__dict__["_set_radiation_pressure_coeff"](arg_radiationPressureCoeff.COM_val))

    @property
    def radiation_pressure_area(self) -> float:
        """The cross-sectional area of the spacecraft assumed perpendicular to the direction of central body radiation, used for central body radiation (albedo / thermal pressure) calculations. Uses Small Area Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pRadiationPressureArea:
            agcls.evaluate_hresult(self.__dict__["_get_radiation_pressure_area"](byref(arg_pRadiationPressureArea.COM_val)))
            return arg_pRadiationPressureArea.python_val

    @radiation_pressure_area.setter
    def radiation_pressure_area(self, radPressureArea:float) -> None:
        with agmarshall.DOUBLE_arg(radPressureArea) as arg_radPressureArea:
            agcls.evaluate_hresult(self.__dict__["_set_radiation_pressure_area"](arg_radPressureArea.COM_val))

    @property
    def k1(self) -> float:
        """If you are using a non-spherical SRP model, this field defines the model's GPS solar radiation pressure K1 (scale) value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pK1:
            agcls.evaluate_hresult(self.__dict__["_get_k1"](byref(arg_pK1.COM_val)))
            return arg_pK1.python_val

    @k1.setter
    def k1(self, k1:float) -> None:
        with agmarshall.DOUBLE_arg(k1) as arg_k1:
            agcls.evaluate_hresult(self.__dict__["_set_k1"](arg_k1.COM_val))

    @property
    def k2(self) -> float:
        """If you are using a non-spherical SRP model, this field defines the model's GPS solar radiation pressure K2 (scale) value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pK2:
            agcls.evaluate_hresult(self.__dict__["_get_k2"](byref(arg_pK2.COM_val)))
            return arg_pK2.python_val

    @k2.setter
    def k2(self, k2:float) -> None:
        with agmarshall.DOUBLE_arg(k2) as arg_k2:
            agcls.evaluate_hresult(self.__dict__["_set_k2"](arg_k2.COM_val))

    def get_in_frame_name(self, frameName:str) -> "IState":
        """Gets the orbit state in the specified frame."""
        with agmarshall.BSTR_arg(frameName) as arg_frameName, \
             agmarshall.AgInterface_out_arg() as arg_ppOrbitState:
            agcls.evaluate_hresult(self.__dict__["_get_in_frame_name"](arg_frameName.COM_val, byref(arg_ppOrbitState.COM_val)))
            return arg_ppOrbitState.python_val


agcls.AgClassCatalog.add_catalog_entry("{44DC2BBF-BC83-42AE-80A1-C1C4B399637F}", IState)
agcls.AgTypeNameMap["IState"] = IState

class IStoppingConditionComponent(object):
    """Properties for a stopping condition."""
    _uuid = "{BB400CAB-0917-4921-BD15-73F6039F3AF2}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_stopping_condition_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStoppingConditionComponent._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStoppingConditionComponent from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStoppingConditionComponent = agcom.GUID(IStoppingConditionComponent._uuid)
        vtable_offset_local = IStoppingConditionComponent._vtable_offset - 1
        self.__dict__["_get_stopping_condition_type"] = IAGFUNCTYPE(pUnk, IID_IStoppingConditionComponent, vtable_offset_local+1, POINTER(agcom.LONG))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStoppingConditionComponent.__dict__ and type(IStoppingConditionComponent.__dict__[attrname]) == property:
            return IStoppingConditionComponent.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStoppingConditionComponent.")
    
    @property
    def stopping_condition_type(self) -> "AgEVAStoppingCondition":
        """The type of stopping condition."""
        with agmarshall.AgEnum_arg(AgEVAStoppingCondition) as arg_pEVAStoppingCondition:
            agcls.evaluate_hresult(self.__dict__["_get_stopping_condition_type"](byref(arg_pEVAStoppingCondition.COM_val)))
            return arg_pEVAStoppingCondition.python_val


agcls.AgClassCatalog.add_catalog_entry("{BB400CAB-0917-4921-BD15-73F6039F3AF2}", IStoppingConditionComponent)
agcls.AgTypeNameMap["IStoppingConditionComponent"] = IStoppingConditionComponent

class IAutomaticSequence(object):
    """Properties for automatic sequences."""
    _uuid = "{B38BC6BA-95F1-4F88-A09D-5657DB8A31AC}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_make_copy"] = _raise_uninitialized_error
        self.__dict__["_get_name"] = _raise_uninitialized_error
        self.__dict__["_set_name"] = _raise_uninitialized_error
        self.__dict__["_get_user_comment"] = _raise_uninitialized_error
        self.__dict__["_set_user_comment"] = _raise_uninitialized_error
        self.__dict__["_get_sequence"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAutomaticSequence._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAutomaticSequence from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAutomaticSequence = agcom.GUID(IAutomaticSequence._uuid)
        vtable_offset_local = IAutomaticSequence._vtable_offset - 1
        self.__dict__["_make_copy"] = IAGFUNCTYPE(pUnk, IID_IAutomaticSequence, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_get_name"] = IAGFUNCTYPE(pUnk, IID_IAutomaticSequence, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_set_name"] = IAGFUNCTYPE(pUnk, IID_IAutomaticSequence, vtable_offset_local+3, agcom.BSTR)
        self.__dict__["_get_user_comment"] = IAGFUNCTYPE(pUnk, IID_IAutomaticSequence, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_set_user_comment"] = IAGFUNCTYPE(pUnk, IID_IAutomaticSequence, vtable_offset_local+5, agcom.BSTR)
        self.__dict__["_get_sequence"] = IAGFUNCTYPE(pUnk, IID_IAutomaticSequence, vtable_offset_local+6, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAutomaticSequence.__dict__ and type(IAutomaticSequence.__dict__[attrname]) == property:
            return IAutomaticSequence.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAutomaticSequence.")
    
    def make_copy(self, uniqueName:str) -> "IAutomaticSequence":
        """Makes a copy of the sequence."""
        with agmarshall.BSTR_arg(uniqueName) as arg_uniqueName, \
             agmarshall.AgInterface_out_arg() as arg_ppAutomaticSequence:
            agcls.evaluate_hresult(self.__dict__["_make_copy"](arg_uniqueName.COM_val, byref(arg_ppAutomaticSequence.COM_val)))
            return arg_ppAutomaticSequence.python_val

    @property
    def name(self) -> str:
        """The name of the sequence."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @name.setter
    def name(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_name"](arg_newVal.COM_val))

    @property
    def user_comment(self) -> str:
        """The user comment."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_user_comment"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @user_comment.setter
    def user_comment(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_user_comment"](arg_newVal.COM_val))

    @property
    def sequence(self) -> "IMissionControlSequenceSegmentCollection":
        """Returns the segment collection of the sequence."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAMCSSegmentCollection:
            agcls.evaluate_hresult(self.__dict__["_get_sequence"](byref(arg_ppVAMCSSegmentCollection.COM_val)))
            return arg_ppVAMCSSegmentCollection.python_val


agcls.AgClassCatalog.add_catalog_entry("{B38BC6BA-95F1-4F88-A09D-5657DB8A31AC}", IAutomaticSequence)
agcls.AgTypeNameMap["IAutomaticSequence"] = IAutomaticSequence

class IAutomaticSequenceCollection(object):
    """Properties for the Automatic Sequence Browser."""
    _uuid = "{E71D785F-1A4C-4E98-BDC1-4EE7055D1FDC}"
    _num_methods = 7
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_add"] = _raise_uninitialized_error
        self.__dict__["_remove"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_index"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAutomaticSequenceCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAutomaticSequenceCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAutomaticSequenceCollection = agcom.GUID(IAutomaticSequenceCollection._uuid)
        vtable_offset_local = IAutomaticSequenceCollection._vtable_offset - 1
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IAutomaticSequenceCollection, vtable_offset_local+1, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_add"] = IAGFUNCTYPE(pUnk, IID_IAutomaticSequenceCollection, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_remove"] = IAGFUNCTYPE(pUnk, IID_IAutomaticSequenceCollection, vtable_offset_local+3, agcom.VARIANT)
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IAutomaticSequenceCollection, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IAutomaticSequenceCollection, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_get_item_by_index"] = IAGFUNCTYPE(pUnk, IID_IAutomaticSequenceCollection, vtable_offset_local+6, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_get_item_by_name"] = IAGFUNCTYPE(pUnk, IID_IAutomaticSequenceCollection, vtable_offset_local+7, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAutomaticSequenceCollection.__dict__ and type(IAutomaticSequenceCollection.__dict__[attrname]) == property:
            return IAutomaticSequenceCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAutomaticSequenceCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IAutomaticSequence":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def item(self, indexOrName:typing.Any) -> "IAutomaticSequence":
        """Returns the given automatic sequence."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppVAAutomaticSequence:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_indexOrName.COM_val, byref(arg_ppVAAutomaticSequence.COM_val)))
            return arg_ppVAAutomaticSequence.python_val

    def add(self, name:str) -> "IAutomaticSequence":
        """Creates a new sequence."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppVAAutomaticSequence:
            agcls.evaluate_hresult(self.__dict__["_add"](arg_name.COM_val, byref(arg_ppVAAutomaticSequence.COM_val)))
            return arg_ppVAAutomaticSequence.python_val

    def remove(self, indexOrName:typing.Any) -> None:
        """Removes a sequence."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_remove"](arg_indexOrName.COM_val))

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def count(self) -> int:
        """The size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def get_item_by_index(self, index:int) -> "IAutomaticSequence":
        """Retrieves the given automatic sequence found by the index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppVAAutomaticSequence:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_index"](arg_index.COM_val, byref(arg_ppVAAutomaticSequence.COM_val)))
            return arg_ppVAAutomaticSequence.python_val

    def get_item_by_name(self, name:str) -> "IAutomaticSequence":
        """Retrieves the given automatic sequence found by the name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppVAAutomaticSequence:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_name"](arg_name.COM_val, byref(arg_ppVAAutomaticSequence.COM_val)))
            return arg_ppVAAutomaticSequence.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{E71D785F-1A4C-4E98-BDC1-4EE7055D1FDC}", IAutomaticSequenceCollection)
agcls.AgTypeNameMap["IAutomaticSequenceCollection"] = IAutomaticSequenceCollection

class IBPlaneCollection(object):
    """Properties for the collection of B-Planes."""
    _uuid = "{64D1804F-3A12-4DA5-AF4F-79C6AE3B39BC}"
    _num_methods = 6
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_add"] = _raise_uninitialized_error
        self.__dict__["_remove"] = _raise_uninitialized_error
        self.__dict__["_remove_all"] = _raise_uninitialized_error
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBPlaneCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBPlaneCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBPlaneCollection = agcom.GUID(IBPlaneCollection._uuid)
        vtable_offset_local = IBPlaneCollection._vtable_offset - 1
        self.__dict__["_add"] = IAGFUNCTYPE(pUnk, IID_IBPlaneCollection, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_remove"] = IAGFUNCTYPE(pUnk, IID_IBPlaneCollection, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_remove_all"] = IAGFUNCTYPE(pUnk, IID_IBPlaneCollection, vtable_offset_local+3, )
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IBPlaneCollection, vtable_offset_local+4, agcom.LONG, POINTER(agcom.BSTR))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IBPlaneCollection, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IBPlaneCollection, vtable_offset_local+6, POINTER(agcom.LONG))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBPlaneCollection.__dict__ and type(IBPlaneCollection.__dict__[attrname]) == property:
            return IBPlaneCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBPlaneCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> str:
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def add(self, bPlaneName:str) -> None:
        """Adds a BPlane."""
        with agmarshall.BSTR_arg(bPlaneName) as arg_bPlaneName:
            agcls.evaluate_hresult(self.__dict__["_add"](arg_bPlaneName.COM_val))

    def remove(self, bPlaneName:str) -> None:
        """Removes a BPlane."""
        with agmarshall.BSTR_arg(bPlaneName) as arg_bPlaneName:
            agcls.evaluate_hresult(self.__dict__["_remove"](arg_bPlaneName.COM_val))

    def remove_all(self) -> None:
        """Removes all BPlanes."""
        agcls.evaluate_hresult(self.__dict__["_remove_all"]())

    def item(self, index:int) -> str:
        """Allows you to iterate through the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_index.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val

    @property
    def count(self) -> int:
        """The number of active BPlanes."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{64D1804F-3A12-4DA5-AF4F-79C6AE3B39BC}", IBPlaneCollection)
agcls.AgTypeNameMap["IBPlaneCollection"] = IBPlaneCollection

class ICalcObjectCollection(object):
    """Collection of calculation objects."""
    _uuid = "{ECCA3BE7-235C-439B-8DE8-8A5010C4A484}"
    _num_methods = 10
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_add"] = _raise_uninitialized_error
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_remove"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_cut"] = _raise_uninitialized_error
        self.__dict__["_paste"] = _raise_uninitialized_error
        self.__dict__["_insert_copy"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_index"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalcObjectCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalcObjectCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalcObjectCollection = agcom.GUID(ICalcObjectCollection._uuid)
        vtable_offset_local = ICalcObjectCollection._vtable_offset - 1
        self.__dict__["_add"] = IAGFUNCTYPE(pUnk, IID_ICalcObjectCollection, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_ICalcObjectCollection, vtable_offset_local+2, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_remove"] = IAGFUNCTYPE(pUnk, IID_ICalcObjectCollection, vtable_offset_local+3, agcom.VARIANT)
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_ICalcObjectCollection, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_ICalcObjectCollection, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_cut"] = IAGFUNCTYPE(pUnk, IID_ICalcObjectCollection, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_paste"] = IAGFUNCTYPE(pUnk, IID_ICalcObjectCollection, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_insert_copy"] = IAGFUNCTYPE(pUnk, IID_ICalcObjectCollection, vtable_offset_local+8, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_get_item_by_index"] = IAGFUNCTYPE(pUnk, IID_ICalcObjectCollection, vtable_offset_local+9, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_get_item_by_name"] = IAGFUNCTYPE(pUnk, IID_ICalcObjectCollection, vtable_offset_local+10, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalcObjectCollection.__dict__ and type(ICalcObjectCollection.__dict__[attrname]) == property:
            return ICalcObjectCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalcObjectCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IComponentInfo":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def add(self, name:str) -> "IComponentInfo":
        """Adds a calc object to the collection."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppComponent:
            agcls.evaluate_hresult(self.__dict__["_add"](arg_name.COM_val, byref(arg_ppComponent.COM_val)))
            return arg_ppComponent.python_val

    def item(self, indexOrName:typing.Any) -> "IComponentInfo":
        """Returns a calc object."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppComponent:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_indexOrName.COM_val, byref(arg_ppComponent.COM_val)))
            return arg_ppComponent.python_val

    def remove(self, indexOrName:typing.Any) -> None:
        """Removes a calc object from the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_remove"](arg_indexOrName.COM_val))

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def cut(self, indexOrName:typing.Any) -> None:
        """Copies a calc object to the clipboard and removes the calc object from the list."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_cut"](arg_indexOrName.COM_val))

    def paste(self) -> "IComponentInfo":
        """Pastes a calc object from the clipboard into the list."""
        with agmarshall.AgInterface_out_arg() as arg_ppCalcObj:
            agcls.evaluate_hresult(self.__dict__["_paste"](byref(arg_ppCalcObj.COM_val)))
            return arg_ppCalcObj.python_val

    def insert_copy(self, calcObj:"IComponentInfo") -> "IComponentInfo":
        """Copies a calc object and inserts the copy into the list."""
        with agmarshall.AgInterface_in_arg(calcObj, IComponentInfo) as arg_calcObj, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_insert_copy"](arg_calcObj.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def get_item_by_index(self, index:int) -> "IComponentInfo":
        """Retrieves a calc object found by the index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppComponent:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_index"](arg_index.COM_val, byref(arg_ppComponent.COM_val)))
            return arg_ppComponent.python_val

    def get_item_by_name(self, name:str) -> "IComponentInfo":
        """Retrieves a calc object found by the name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppComponent:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_name"](arg_name.COM_val, byref(arg_ppComponent.COM_val)))
            return arg_ppComponent.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{ECCA3BE7-235C-439B-8DE8-8A5010C4A484}", ICalcObjectCollection)
agcls.AgTypeNameMap["ICalcObjectCollection"] = ICalcObjectCollection

class IManeuverFinitePropagator(object):
    """Properties for the propagation of a Finite Maneuver."""
    _uuid = "{6F8D5070-D155-4D40-A682-46EF2B69F1A3}"
    _num_methods = 21
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_propagator_name"] = _raise_uninitialized_error
        self.__dict__["_set_propagator_name"] = _raise_uninitialized_error
        self.__dict__["_get_stopping_conditions"] = _raise_uninitialized_error
        self.__dict__["_get_min_propagation_time"] = _raise_uninitialized_error
        self.__dict__["_set_min_propagation_time"] = _raise_uninitialized_error
        self.__dict__["_get_max_propagation_time"] = _raise_uninitialized_error
        self.__dict__["_set_max_propagation_time"] = _raise_uninitialized_error
        self.__dict__["_get_enable_max_propagation_time"] = _raise_uninitialized_error
        self.__dict__["_set_enable_max_propagation_time"] = _raise_uninitialized_error
        self.__dict__["_get_enable_warning_message"] = _raise_uninitialized_error
        self.__dict__["_set_enable_warning_message"] = _raise_uninitialized_error
        self.__dict__["_get_enable_center_burn"] = _raise_uninitialized_error
        self.__dict__["_set_enable_center_burn"] = _raise_uninitialized_error
        self.__dict__["_get_bias"] = _raise_uninitialized_error
        self.__dict__["_set_bias"] = _raise_uninitialized_error
        self.__dict__["_get_override_max_propagation_time"] = _raise_uninitialized_error
        self.__dict__["_set_override_max_propagation_time"] = _raise_uninitialized_error
        self.__dict__["_get_should_stop_for_initially_surpassed_epoch_stopping_conditions"] = _raise_uninitialized_error
        self.__dict__["_set_should_stop_for_initially_surpassed_epoch_stopping_conditions"] = _raise_uninitialized_error
        self.__dict__["_get_should_reinitialize_stm_at_start_of_segment_propagation"] = _raise_uninitialized_error
        self.__dict__["_set_should_reinitialize_stm_at_start_of_segment_propagation"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IManeuverFinitePropagator._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IManeuverFinitePropagator from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IManeuverFinitePropagator = agcom.GUID(IManeuverFinitePropagator._uuid)
        vtable_offset_local = IManeuverFinitePropagator._vtable_offset - 1
        self.__dict__["_get_propagator_name"] = IAGFUNCTYPE(pUnk, IID_IManeuverFinitePropagator, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_propagator_name"] = IAGFUNCTYPE(pUnk, IID_IManeuverFinitePropagator, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_stopping_conditions"] = IAGFUNCTYPE(pUnk, IID_IManeuverFinitePropagator, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_min_propagation_time"] = IAGFUNCTYPE(pUnk, IID_IManeuverFinitePropagator, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_set_min_propagation_time"] = IAGFUNCTYPE(pUnk, IID_IManeuverFinitePropagator, vtable_offset_local+5, agcom.DOUBLE)
        self.__dict__["_get_max_propagation_time"] = IAGFUNCTYPE(pUnk, IID_IManeuverFinitePropagator, vtable_offset_local+6, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_propagation_time"] = IAGFUNCTYPE(pUnk, IID_IManeuverFinitePropagator, vtable_offset_local+7, agcom.DOUBLE)
        self.__dict__["_get_enable_max_propagation_time"] = IAGFUNCTYPE(pUnk, IID_IManeuverFinitePropagator, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable_max_propagation_time"] = IAGFUNCTYPE(pUnk, IID_IManeuverFinitePropagator, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_get_enable_warning_message"] = IAGFUNCTYPE(pUnk, IID_IManeuverFinitePropagator, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable_warning_message"] = IAGFUNCTYPE(pUnk, IID_IManeuverFinitePropagator, vtable_offset_local+11, agcom.VARIANT_BOOL)
        self.__dict__["_get_enable_center_burn"] = IAGFUNCTYPE(pUnk, IID_IManeuverFinitePropagator, vtable_offset_local+12, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable_center_burn"] = IAGFUNCTYPE(pUnk, IID_IManeuverFinitePropagator, vtable_offset_local+13, agcom.VARIANT_BOOL)
        self.__dict__["_get_bias"] = IAGFUNCTYPE(pUnk, IID_IManeuverFinitePropagator, vtable_offset_local+14, POINTER(agcom.DOUBLE))
        self.__dict__["_set_bias"] = IAGFUNCTYPE(pUnk, IID_IManeuverFinitePropagator, vtable_offset_local+15, agcom.DOUBLE)
        self.__dict__["_get_override_max_propagation_time"] = IAGFUNCTYPE(pUnk, IID_IManeuverFinitePropagator, vtable_offset_local+16, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_override_max_propagation_time"] = IAGFUNCTYPE(pUnk, IID_IManeuverFinitePropagator, vtable_offset_local+17, agcom.VARIANT_BOOL)
        self.__dict__["_get_should_stop_for_initially_surpassed_epoch_stopping_conditions"] = IAGFUNCTYPE(pUnk, IID_IManeuverFinitePropagator, vtable_offset_local+18, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_should_stop_for_initially_surpassed_epoch_stopping_conditions"] = IAGFUNCTYPE(pUnk, IID_IManeuverFinitePropagator, vtable_offset_local+19, agcom.VARIANT_BOOL)
        self.__dict__["_get_should_reinitialize_stm_at_start_of_segment_propagation"] = IAGFUNCTYPE(pUnk, IID_IManeuverFinitePropagator, vtable_offset_local+20, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_should_reinitialize_stm_at_start_of_segment_propagation"] = IAGFUNCTYPE(pUnk, IID_IManeuverFinitePropagator, vtable_offset_local+21, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IManeuverFinitePropagator.__dict__ and type(IManeuverFinitePropagator.__dict__[attrname]) == property:
            return IManeuverFinitePropagator.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IManeuverFinitePropagator.")
    
    @property
    def propagator_name(self) -> str:
        """The propagator."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_propagator_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @propagator_name.setter
    def propagator_name(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_propagator_name"](arg_newVal.COM_val))

    @property
    def stopping_conditions(self) -> "IStoppingConditionCollection":
        """The stopping conditions list."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAStoppingConditionCollection:
            agcls.evaluate_hresult(self.__dict__["_get_stopping_conditions"](byref(arg_ppVAStoppingConditionCollection.COM_val)))
            return arg_ppVAStoppingConditionCollection.python_val

    @property
    def min_propagation_time(self) -> float:
        """Minimum Propagation Time - the minimum time that must elapse from the beginning of the segment until Astrogator will begin checking stopping conditions for satisfaction. Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_propagation_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @min_propagation_time.setter
    def min_propagation_time(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_min_propagation_time"](arg_newVal.COM_val))

    @property
    def max_propagation_time(self) -> float:
        """Maximum Propagation Time - the maximum propagation time, after which the segment will end regardless of whether the stopping conditions have been satisfied. Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_propagation_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_propagation_time.setter
    def max_propagation_time(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_propagation_time"](arg_newVal.COM_val))

    @property
    def enable_max_propagation_time(self) -> bool:
        """Enable Maximum Propagation Time - apply the maximum propagation time."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable_max_propagation_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable_max_propagation_time.setter
    def enable_max_propagation_time(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable_max_propagation_time"](arg_newVal.COM_val))

    @property
    def enable_warning_message(self) -> bool:
        """Issue a warning message if propagation is stopped by the Maximum Propagation Time parameter."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable_warning_message"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable_warning_message.setter
    def enable_warning_message(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable_warning_message"](arg_newVal.COM_val))

    @property
    def enable_center_burn(self) -> bool:
        """This property is only available for use with a duration stopping condition. If selected, you are setting the maneuver to start half the time before the previous segment ended."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable_center_burn"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable_center_burn.setter
    def enable_center_burn(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable_center_burn"](arg_newVal.COM_val))

    @property
    def bias(self) -> float:
        """The value by which to adjust the centering of the burn. A positive value will center the burn after the previous segment ends by the amount specified in the Burn Center Bias field. Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_bias"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @bias.setter
    def bias(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_bias"](arg_newVal.COM_val))

    @property
    def override_max_propagation_time(self) -> bool:
        """Override Maximum Propagation Time - if there is a duration or epoch stopping condition that occurs after the maximum propagation time, ignore the maximum propagation time."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_override_max_propagation_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @override_max_propagation_time.setter
    def override_max_propagation_time(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_override_max_propagation_time"](arg_newVal.COM_val))

    @property
    def should_stop_for_initially_surpassed_epoch_stopping_conditions(self) -> bool:
        """Stop immediately if propagation begins beyond an active epoch stopping condition."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_should_stop_for_initially_surpassed_epoch_stopping_conditions"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @should_stop_for_initially_surpassed_epoch_stopping_conditions.setter
    def should_stop_for_initially_surpassed_epoch_stopping_conditions(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_should_stop_for_initially_surpassed_epoch_stopping_conditions"](arg_newVal.COM_val))

    @property
    def should_reinitialize_stm_at_start_of_segment_propagation(self) -> bool:
        """If this segment is propagating the state transition matrix, reset it to the identity matrix at the start of the segment."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_should_reinitialize_stm_at_start_of_segment_propagation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @should_reinitialize_stm_at_start_of_segment_propagation.setter
    def should_reinitialize_stm_at_start_of_segment_propagation(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_should_reinitialize_stm_at_start_of_segment_propagation"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{6F8D5070-D155-4D40-A682-46EF2B69F1A3}", IManeuverFinitePropagator)
agcls.AgTypeNameMap["IManeuverFinitePropagator"] = IManeuverFinitePropagator

class IBurnoutVelocity(object):
    """Properties for the burnout velocity of a Launch segment."""
    _uuid = "{A1EA8DE5-41D0-4419-988E-98EEACEECAE9}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_burnout_option"] = _raise_uninitialized_error
        self.__dict__["_set_burnout_option"] = _raise_uninitialized_error
        self.__dict__["_get_fixed_velocity"] = _raise_uninitialized_error
        self.__dict__["_set_fixed_velocity"] = _raise_uninitialized_error
        self.__dict__["_get_inertial_velocity"] = _raise_uninitialized_error
        self.__dict__["_set_inertial_velocity"] = _raise_uninitialized_error
        self.__dict__["_get_inertial_velocity_azimuth"] = _raise_uninitialized_error
        self.__dict__["_set_inertial_velocity_azimuth"] = _raise_uninitialized_error
        self.__dict__["_get_inertial_horizontal_fpa"] = _raise_uninitialized_error
        self.__dict__["_set_inertial_horizontal_fpa"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBurnoutVelocity._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBurnoutVelocity from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBurnoutVelocity = agcom.GUID(IBurnoutVelocity._uuid)
        vtable_offset_local = IBurnoutVelocity._vtable_offset - 1
        self.__dict__["_get_burnout_option"] = IAGFUNCTYPE(pUnk, IID_IBurnoutVelocity, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_burnout_option"] = IAGFUNCTYPE(pUnk, IID_IBurnoutVelocity, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_fixed_velocity"] = IAGFUNCTYPE(pUnk, IID_IBurnoutVelocity, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_fixed_velocity"] = IAGFUNCTYPE(pUnk, IID_IBurnoutVelocity, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_inertial_velocity"] = IAGFUNCTYPE(pUnk, IID_IBurnoutVelocity, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_inertial_velocity"] = IAGFUNCTYPE(pUnk, IID_IBurnoutVelocity, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_inertial_velocity_azimuth"] = IAGFUNCTYPE(pUnk, IID_IBurnoutVelocity, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_set_inertial_velocity_azimuth"] = IAGFUNCTYPE(pUnk, IID_IBurnoutVelocity, vtable_offset_local+8, agcom.VARIANT)
        self.__dict__["_get_inertial_horizontal_fpa"] = IAGFUNCTYPE(pUnk, IID_IBurnoutVelocity, vtable_offset_local+9, POINTER(agcom.VARIANT))
        self.__dict__["_set_inertial_horizontal_fpa"] = IAGFUNCTYPE(pUnk, IID_IBurnoutVelocity, vtable_offset_local+10, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBurnoutVelocity.__dict__ and type(IBurnoutVelocity.__dict__[attrname]) == property:
            return IBurnoutVelocity.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBurnoutVelocity.")
    
    @property
    def burnout_option(self) -> "AgEVABurnoutOptions":
        """Select to use the fixed or inertial frame."""
        with agmarshall.AgEnum_arg(AgEVABurnoutOptions) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_burnout_option"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @burnout_option.setter
    def burnout_option(self, newVal:"AgEVABurnoutOptions") -> None:
        with agmarshall.AgEnum_arg(AgEVABurnoutOptions, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_burnout_option"](arg_newVal.COM_val))

    @property
    def fixed_velocity(self) -> float:
        """The velocity magnitude . Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_fixed_velocity"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @fixed_velocity.setter
    def fixed_velocity(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_fixed_velocity"](arg_newVal.COM_val))

    @property
    def inertial_velocity(self) -> float:
        """The velocity magnitude. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_inertial_velocity"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @inertial_velocity.setter
    def inertial_velocity(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_inertial_velocity"](arg_newVal.COM_val))

    @property
    def inertial_velocity_azimuth(self) -> typing.Any:
        """The inertial velocity azimuth. Inertial velocity azimuth is the angle from the projection of north in the local horizontal plane to the inertial velocity vector, right handed. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_inertial_velocity_azimuth"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @inertial_velocity_azimuth.setter
    def inertial_velocity_azimuth(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_inertial_velocity_azimuth"](arg_newVal.COM_val))

    @property
    def inertial_horizontal_fpa(self) -> typing.Any:
        """Inertial horizontal flight path angle is the angle from the local horizontal to the inertial velocity vector, positive towards radius. It is also 90 degrees minus vertical flight path angle. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_inertial_horizontal_fpa"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @inertial_horizontal_fpa.setter
    def inertial_horizontal_fpa(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_inertial_horizontal_fpa"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{A1EA8DE5-41D0-4419-988E-98EEACEECAE9}", IBurnoutVelocity)
agcls.AgTypeNameMap["IBurnoutVelocity"] = IBurnoutVelocity

class IAttitudeControl(object):
    """Properties for attitude options for a maneuver segment."""
    _uuid = "{FC43EF22-B727-4538-9E97-B3CD445436CD}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_lead_duration"] = _raise_uninitialized_error
        self.__dict__["_set_lead_duration"] = _raise_uninitialized_error
        self.__dict__["_get_trail_duration"] = _raise_uninitialized_error
        self.__dict__["_set_trail_duration"] = _raise_uninitialized_error
        self.__dict__["_get_body_axis"] = _raise_uninitialized_error
        self.__dict__["_set_body_axis"] = _raise_uninitialized_error
        self.__dict__["_get_constraint_sign"] = _raise_uninitialized_error
        self.__dict__["_set_constraint_sign"] = _raise_uninitialized_error
        self.__dict__["_get_constraint_vector_name"] = _raise_uninitialized_error
        self.__dict__["_set_constraint_vector_name"] = _raise_uninitialized_error
        self.__dict__["_get_custom_function"] = _raise_uninitialized_error
        self.__dict__["_set_custom_function"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAttitudeControl._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAttitudeControl from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAttitudeControl = agcom.GUID(IAttitudeControl._uuid)
        vtable_offset_local = IAttitudeControl._vtable_offset - 1
        self.__dict__["_get_lead_duration"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControl, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_lead_duration"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControl, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_trail_duration"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControl, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_trail_duration"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControl, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_body_axis"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControl, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_body_axis"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControl, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_constraint_sign"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControl, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_constraint_sign"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControl, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_constraint_vector_name"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControl, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_set_constraint_vector_name"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControl, vtable_offset_local+10, agcom.BSTR)
        self.__dict__["_get_custom_function"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControl, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_set_custom_function"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControl, vtable_offset_local+12, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAttitudeControl.__dict__ and type(IAttitudeControl.__dict__[attrname]) == property:
            return IAttitudeControl.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAttitudeControl.")
    
    @property
    def lead_duration(self) -> float:
        """How long before the maneuver starts the maneuver attitude. Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_lead_duration"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @lead_duration.setter
    def lead_duration(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_lead_duration"](arg_newVal.COM_val))

    @property
    def trail_duration(self) -> float:
        """How long to maintain that attitude after the maneuver. Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_trail_duration"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @trail_duration.setter
    def trail_duration(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_trail_duration"](arg_newVal.COM_val))

    @property
    def body_axis(self) -> "AgEVABodyAxis":
        """Whether the engine acceleration (the direction opposite the engine's exhaust) is aligned with positive or negative X, Y or Z body axis."""
        with agmarshall.AgEnum_arg(AgEVABodyAxis) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_body_axis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @body_axis.setter
    def body_axis(self, newVal:"AgEVABodyAxis") -> None:
        with agmarshall.AgEnum_arg(AgEVABodyAxis, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_body_axis"](arg_newVal.COM_val))

    @property
    def constraint_sign(self) -> "AgEVAConstraintSign":
        """Whether the Constraint Vector is positive or negative."""
        with agmarshall.AgEnum_arg(AgEVAConstraintSign) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_constraint_sign"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @constraint_sign.setter
    def constraint_sign(self, newVal:"AgEVAConstraintSign") -> None:
        with agmarshall.AgEnum_arg(AgEVAConstraintSign, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_constraint_sign"](arg_newVal.COM_val))

    @property
    def constraint_vector_name(self) -> str:
        """Constraint Vector - the vector toward which this body vector is constrained."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_constraint_vector_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @constraint_vector_name.setter
    def constraint_vector_name(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_constraint_vector_name"](arg_newVal.COM_val))

    @property
    def custom_function(self) -> "AgEVACustomFunction":
        """The attitude definition to use for other STK functions."""
        with agmarshall.AgEnum_arg(AgEVACustomFunction) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_custom_function"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @custom_function.setter
    def custom_function(self, newVal:"AgEVACustomFunction") -> None:
        with agmarshall.AgEnum_arg(AgEVACustomFunction, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_custom_function"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{FC43EF22-B727-4538-9E97-B3CD445436CD}", IAttitudeControl)
agcls.AgTypeNameMap["IAttitudeControl"] = IAttitudeControl

class IAttitudeControlFinite(IAttitudeControl):
    """The attitude control of a finite maneuver"""
    _uuid = "{827F3B46-D066-462B-A3DB-1DCD56A816BA}"
    _num_methods = 0
    _vtable_offset = IAttitudeControl._vtable_offset + IAttitudeControl._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAttitudeControlFinite._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAttitudeControlFinite from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAttitudeControl._private_init(self, pUnk)
        IID_IAttitudeControlFinite = agcom.GUID(IAttitudeControlFinite._uuid)
        vtable_offset_local = IAttitudeControlFinite._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAttitudeControlFinite.__dict__ and type(IAttitudeControlFinite.__dict__[attrname]) == property:
            return IAttitudeControlFinite.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IAttitudeControl.__setattr__(self, attrname, value)
    

agcls.AgClassCatalog.add_catalog_entry("{827F3B46-D066-462B-A3DB-1DCD56A816BA}", IAttitudeControlFinite)
agcls.AgTypeNameMap["IAttitudeControlFinite"] = IAttitudeControlFinite

class IAttitudeControlImpulsive(IAttitudeControl):
    """The attitude control of an impulsive maneuver."""
    _uuid = "{0BD5E890-FBD8-415E-9E29-38731985F366}"
    _num_methods = 0
    _vtable_offset = IAttitudeControl._vtable_offset + IAttitudeControl._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAttitudeControlImpulsive._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAttitudeControlImpulsive from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAttitudeControl._private_init(self, pUnk)
        IID_IAttitudeControlImpulsive = agcom.GUID(IAttitudeControlImpulsive._uuid)
        vtable_offset_local = IAttitudeControlImpulsive._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAttitudeControlImpulsive.__dict__ and type(IAttitudeControlImpulsive.__dict__[attrname]) == property:
            return IAttitudeControlImpulsive.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IAttitudeControl.__setattr__(self, attrname, value)
    

agcls.AgClassCatalog.add_catalog_entry("{0BD5E890-FBD8-415E-9E29-38731985F366}", IAttitudeControlImpulsive)
agcls.AgTypeNameMap["IAttitudeControlImpulsive"] = IAttitudeControlImpulsive

class IAttitudeControlOptimalFinite(IAttitudeControl):
    """The attitude control of a optimal finite maneuver"""
    _uuid = "{EF8743CB-4A4F-4B89-AB50-D76843E4D618}"
    _num_methods = 0
    _vtable_offset = IAttitudeControl._vtable_offset + IAttitudeControl._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAttitudeControlOptimalFinite._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAttitudeControlOptimalFinite from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAttitudeControl._private_init(self, pUnk)
        IID_IAttitudeControlOptimalFinite = agcom.GUID(IAttitudeControlOptimalFinite._uuid)
        vtable_offset_local = IAttitudeControlOptimalFinite._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAttitudeControlOptimalFinite.__dict__ and type(IAttitudeControlOptimalFinite.__dict__[attrname]) == property:
            return IAttitudeControlOptimalFinite.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IAttitudeControl.__setattr__(self, attrname, value)
    

agcls.AgClassCatalog.add_catalog_entry("{EF8743CB-4A4F-4B89-AB50-D76843E4D618}", IAttitudeControlOptimalFinite)
agcls.AgTypeNameMap["IAttitudeControlOptimalFinite"] = IAttitudeControlOptimalFinite

class IManeuver(object):
    """Properties of an Impulsive Maneuver Segment."""
    _uuid = "{C70B417E-D1C4-40E8-8CDC-67EDED0B56AE}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_attitude_control_type"] = _raise_uninitialized_error
        self.__dict__["_set_attitude_control_type"] = _raise_uninitialized_error
        self.__dict__["_get_attitude_control"] = _raise_uninitialized_error
        self.__dict__["_get_propulsion_method"] = _raise_uninitialized_error
        self.__dict__["_set_propulsion_method"] = _raise_uninitialized_error
        self.__dict__["_get_propulsion_method_value"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IManeuver._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IManeuver from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IManeuver = agcom.GUID(IManeuver._uuid)
        vtable_offset_local = IManeuver._vtable_offset - 1
        self.__dict__["_get_attitude_control_type"] = IAGFUNCTYPE(pUnk, IID_IManeuver, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_attitude_control_type"] = IAGFUNCTYPE(pUnk, IID_IManeuver, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_attitude_control"] = IAGFUNCTYPE(pUnk, IID_IManeuver, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_propulsion_method"] = IAGFUNCTYPE(pUnk, IID_IManeuver, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_set_propulsion_method"] = IAGFUNCTYPE(pUnk, IID_IManeuver, vtable_offset_local+5, agcom.LONG, agcom.BSTR)
        self.__dict__["_get_propulsion_method_value"] = IAGFUNCTYPE(pUnk, IID_IManeuver, vtable_offset_local+6, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IManeuver.__dict__ and type(IManeuver.__dict__[attrname]) == property:
            return IManeuver.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IManeuver.")
    
    @property
    def attitude_control_type(self) -> "AgEVAAttitudeControl":
        """Determines the attitude parameters available for you to specify."""
        with agmarshall.AgEnum_arg(AgEVAAttitudeControl) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_attitude_control_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_attitude_control_type(self, attitudeControlType:"AgEVAAttitudeControl") -> None:
        """Sets the attitude control type."""
        with agmarshall.AgEnum_arg(AgEVAAttitudeControl, attitudeControlType) as arg_attitudeControlType:
            agcls.evaluate_hresult(self.__dict__["_set_attitude_control_type"](arg_attitudeControlType.COM_val))

    @property
    def attitude_control(self) -> "IAttitudeControl":
        """The attitude control properties collection."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAAttitudeControl:
            agcls.evaluate_hresult(self.__dict__["_get_attitude_control"](byref(arg_ppVAAttitudeControl.COM_val)))
            return arg_ppVAAttitudeControl.python_val

    @property
    def propulsion_method(self) -> "AgEVAPropulsionMethod":
        """The propulsion type to be modeled."""
        with agmarshall.AgEnum_arg(AgEVAPropulsionMethod) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_propulsion_method"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_propulsion_method(self, propulsionMethod:"AgEVAPropulsionMethod", value:str) -> None:
        """Sets the propulsion type and associated engine/thruster set."""
        with agmarshall.AgEnum_arg(AgEVAPropulsionMethod, propulsionMethod) as arg_propulsionMethod, \
             agmarshall.BSTR_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_set_propulsion_method"](arg_propulsionMethod.COM_val, arg_value.COM_val))

    @property
    def propulsion_method_value(self) -> str:
        """The specific engine model or thruster set to be used for the maneuver."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_propulsion_method_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{C70B417E-D1C4-40E8-8CDC-67EDED0B56AE}", IManeuver)
agcls.AgTypeNameMap["IManeuver"] = IManeuver

class IDisplaySystem(object):
    """The launch coordinate system."""
    _uuid = "{90BFC47C-35B5-4169-9543-36C65DFABB6A}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IDisplaySystem._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IDisplaySystem from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IDisplaySystem = agcom.GUID(IDisplaySystem._uuid)
        vtable_offset_local = IDisplaySystem._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IDisplaySystem.__dict__ and type(IDisplaySystem.__dict__[attrname]) == property:
            return IDisplaySystem.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IDisplaySystem.")
    

agcls.AgClassCatalog.add_catalog_entry("{90BFC47C-35B5-4169-9543-36C65DFABB6A}", IDisplaySystem)
agcls.AgTypeNameMap["IDisplaySystem"] = IDisplaySystem

class IBurnout(object):
    """The burnout point reference frame."""
    _uuid = "{0BEFC7BA-14CF-422D-BD67-352572ABB55F}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBurnout._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBurnout from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBurnout = agcom.GUID(IBurnout._uuid)
        vtable_offset_local = IBurnout._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBurnout.__dict__ and type(IBurnout.__dict__[attrname]) == property:
            return IBurnout.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBurnout.")
    

agcls.AgClassCatalog.add_catalog_entry("{0BEFC7BA-14CF-422D-BD67-352572ABB55F}", IBurnout)
agcls.AgTypeNameMap["IBurnout"] = IBurnout

class IScriptingSegment(object):
    """Object properties for scripting options."""
    _uuid = "{08B0F341-8A54-43B8-A0B9-50A462E70C71}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_component_name"] = _raise_uninitialized_error
        self.__dict__["_set_component_name"] = _raise_uninitialized_error
        self.__dict__["_get_attribute"] = _raise_uninitialized_error
        self.__dict__["_set_attribute"] = _raise_uninitialized_error
        self.__dict__["_get_unit"] = _raise_uninitialized_error
        self.__dict__["_set_unit"] = _raise_uninitialized_error
        self.__dict__["_get_available_attribute_values"] = _raise_uninitialized_error
        self.__dict__["_get_read_only_property"] = _raise_uninitialized_error
        self.__dict__["_set_read_only_property"] = _raise_uninitialized_error
        self.__dict__["_get_object_name"] = _raise_uninitialized_error
        self.__dict__["_set_object_name"] = _raise_uninitialized_error
        self.__dict__["_get_available_object_names"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IScriptingSegment._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IScriptingSegment from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IScriptingSegment = agcom.GUID(IScriptingSegment._uuid)
        vtable_offset_local = IScriptingSegment._vtable_offset - 1
        self.__dict__["_get_component_name"] = IAGFUNCTYPE(pUnk, IID_IScriptingSegment, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_component_name"] = IAGFUNCTYPE(pUnk, IID_IScriptingSegment, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_attribute"] = IAGFUNCTYPE(pUnk, IID_IScriptingSegment, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_attribute"] = IAGFUNCTYPE(pUnk, IID_IScriptingSegment, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_get_unit"] = IAGFUNCTYPE(pUnk, IID_IScriptingSegment, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_set_unit"] = IAGFUNCTYPE(pUnk, IID_IScriptingSegment, vtable_offset_local+6, agcom.BSTR)
        self.__dict__["_get_available_attribute_values"] = IAGFUNCTYPE(pUnk, IID_IScriptingSegment, vtable_offset_local+7, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_read_only_property"] = IAGFUNCTYPE(pUnk, IID_IScriptingSegment, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_read_only_property"] = IAGFUNCTYPE(pUnk, IID_IScriptingSegment, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_get_object_name"] = IAGFUNCTYPE(pUnk, IID_IScriptingSegment, vtable_offset_local+10, POINTER(agcom.BSTR))
        self.__dict__["_set_object_name"] = IAGFUNCTYPE(pUnk, IID_IScriptingSegment, vtable_offset_local+11, agcom.BSTR)
        self.__dict__["_get_available_object_names"] = IAGFUNCTYPE(pUnk, IID_IScriptingSegment, vtable_offset_local+12, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IScriptingSegment.__dict__ and type(IScriptingSegment.__dict__[attrname]) == property:
            return IScriptingSegment.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IScriptingSegment.")
    
    @property
    def component_name(self) -> str:
        """The name of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_component_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @component_name.setter
    def component_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_component_name"](arg_inVal.COM_val))

    @property
    def attribute(self) -> str:
        """The name of the attribute."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_attribute"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @attribute.setter
    def attribute(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_attribute"](arg_inVal.COM_val))

    @property
    def unit(self) -> str:
        """The unit."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_unit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @unit.setter
    def unit(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_unit"](arg_inVal.COM_val))

    @property
    def available_attribute_values(self) -> list:
        """Returns a list of available attribute values."""
        with agmarshall.SAFEARRAY_arg() as arg_ppNewVal:
            agcls.evaluate_hresult(self.__dict__["_get_available_attribute_values"](byref(arg_ppNewVal.COM_val)))
            return arg_ppNewVal.python_val

    @property
    def read_only_property(self) -> bool:
        """True if it is a read-only property."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_read_only_property"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @read_only_property.setter
    def read_only_property(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_read_only_property"](arg_inVal.COM_val))

    @property
    def object_name(self) -> str:
        """The profile/segment that contains the attribute."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_object_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @object_name.setter
    def object_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_object_name"](arg_inVal.COM_val))

    @property
    def available_object_names(self) -> list:
        """Returns a list of available profile/segment names."""
        with agmarshall.SAFEARRAY_arg() as arg_ppNewVal:
            agcls.evaluate_hresult(self.__dict__["_get_available_object_names"](byref(arg_ppNewVal.COM_val)))
            return arg_ppNewVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{08B0F341-8A54-43B8-A0B9-50A462E70C71}", IScriptingSegment)
agcls.AgTypeNameMap["IScriptingSegment"] = IScriptingSegment

class IScriptingSegmentCollection(object):
    """The list of object properties that the script can interact with."""
    _uuid = "{07549510-B2B9-4AA0-A9AA-E2FDFBC9BBEE}"
    _num_methods = 12
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_add"] = _raise_uninitialized_error
        self.__dict__["_remove"] = _raise_uninitialized_error
        self.__dict__["_remove_all"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_get_provide_runtime_type_info"] = _raise_uninitialized_error
        self.__dict__["_cut"] = _raise_uninitialized_error
        self.__dict__["_paste"] = _raise_uninitialized_error
        self.__dict__["_insert_copy"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_index"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IScriptingSegmentCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IScriptingSegmentCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IScriptingSegmentCollection = agcom.GUID(IScriptingSegmentCollection._uuid)
        vtable_offset_local = IScriptingSegmentCollection._vtable_offset - 1
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IScriptingSegmentCollection, vtable_offset_local+1, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_add"] = IAGFUNCTYPE(pUnk, IID_IScriptingSegmentCollection, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_remove"] = IAGFUNCTYPE(pUnk, IID_IScriptingSegmentCollection, vtable_offset_local+3, agcom.VARIANT)
        self.__dict__["_remove_all"] = IAGFUNCTYPE(pUnk, IID_IScriptingSegmentCollection, vtable_offset_local+4, )
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IScriptingSegmentCollection, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IScriptingSegmentCollection, vtable_offset_local+6, POINTER(agcom.LONG))
        self.__dict__["_get_provide_runtime_type_info"] = IAGFUNCTYPE(pUnk, IID_IScriptingSegmentCollection, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_cut"] = IAGFUNCTYPE(pUnk, IID_IScriptingSegmentCollection, vtable_offset_local+8, agcom.VARIANT)
        self.__dict__["_paste"] = IAGFUNCTYPE(pUnk, IID_IScriptingSegmentCollection, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_insert_copy"] = IAGFUNCTYPE(pUnk, IID_IScriptingSegmentCollection, vtable_offset_local+10, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_get_item_by_index"] = IAGFUNCTYPE(pUnk, IID_IScriptingSegmentCollection, vtable_offset_local+11, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_get_item_by_name"] = IAGFUNCTYPE(pUnk, IID_IScriptingSegmentCollection, vtable_offset_local+12, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IScriptingSegmentCollection.__dict__ and type(IScriptingSegmentCollection.__dict__[attrname]) == property:
            return IScriptingSegmentCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IScriptingSegmentCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IScriptingSegment":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def item(self, indexOrName:typing.Any) -> "IScriptingSegment":
        """Allows you to iterate through the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppVAScriptingSegment:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_indexOrName.COM_val, byref(arg_ppVAScriptingSegment.COM_val)))
            return arg_ppVAScriptingSegment.python_val

    def add(self, componentName:str) -> "IScriptingSegment":
        """Adds an object property to the collection."""
        with agmarshall.BSTR_arg(componentName) as arg_componentName, \
             agmarshall.AgInterface_out_arg() as arg_ppVAScriptingSegment:
            agcls.evaluate_hresult(self.__dict__["_add"](arg_componentName.COM_val, byref(arg_ppVAScriptingSegment.COM_val)))
            return arg_ppVAScriptingSegment.python_val

    def remove(self, indexOrName:typing.Any) -> None:
        """Removes a object property."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_remove"](arg_indexOrName.COM_val))

    def remove_all(self) -> None:
        """Removes all object properties."""
        agcls.evaluate_hresult(self.__dict__["_remove_all"]())

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def provide_runtime_type_info(self) -> "IRuntimeTypeInfo":
        """Returns the IRuntimeTypeInfo interface to access properties at runtime."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_provide_runtime_type_info"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def cut(self, indexOrName:typing.Any) -> None:
        """Copies the object property into the clipboard and removes the object property from the list."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_cut"](arg_indexOrName.COM_val))

    def paste(self) -> "IScriptingSegment":
        """Pastes the object property from the clipboard and inserts into the list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_paste"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def insert_copy(self, objProperty:"IScriptingSegment") -> "IScriptingSegment":
        """Copies the object property and inserts the copy into the list."""
        with agmarshall.AgInterface_in_arg(objProperty, IScriptingSegment) as arg_objProperty, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_insert_copy"](arg_objProperty.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def get_item_by_index(self, index:int) -> "IScriptingSegment":
        """Retrieves a scripting segment in the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppVAScriptingSegment:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_index"](arg_index.COM_val, byref(arg_ppVAScriptingSegment.COM_val)))
            return arg_ppVAScriptingSegment.python_val

    def get_item_by_name(self, name:str) -> "IScriptingSegment":
        """Retrieves a scripting segment in the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppVAScriptingSegment:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_name"](arg_name.COM_val, byref(arg_ppVAScriptingSegment.COM_val)))
            return arg_ppVAScriptingSegment.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{07549510-B2B9-4AA0-A9AA-E2FDFBC9BBEE}", IScriptingSegmentCollection)
agcls.AgTypeNameMap["IScriptingSegmentCollection"] = IScriptingSegmentCollection

class IScriptingParameterEnumerationChoice(object):
    """Enumeration choice."""
    _uuid = "{DED30CDF-730F-4125-AEB8-6A668248B484}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_name"] = _raise_uninitialized_error
        self.__dict__["_set_name"] = _raise_uninitialized_error
        self.__dict__["_get_value"] = _raise_uninitialized_error
        self.__dict__["_set_value"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IScriptingParameterEnumerationChoice._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IScriptingParameterEnumerationChoice from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IScriptingParameterEnumerationChoice = agcom.GUID(IScriptingParameterEnumerationChoice._uuid)
        vtable_offset_local = IScriptingParameterEnumerationChoice._vtable_offset - 1
        self.__dict__["_get_name"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameterEnumerationChoice, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_name"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameterEnumerationChoice, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_value"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameterEnumerationChoice, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_value"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameterEnumerationChoice, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IScriptingParameterEnumerationChoice.__dict__ and type(IScriptingParameterEnumerationChoice.__dict__[attrname]) == property:
            return IScriptingParameterEnumerationChoice.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IScriptingParameterEnumerationChoice.")
    
    @property
    def name(self) -> str:
        """Name of the enumeration"""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @name.setter
    def name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_name"](arg_inVal.COM_val))

    @property
    def value(self) -> int:
        """Integer value of the enumeration"""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @value.setter
    def value(self, inVal:int) -> None:
        with agmarshall.LONG_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_value"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{DED30CDF-730F-4125-AEB8-6A668248B484}", IScriptingParameterEnumerationChoice)
agcls.AgTypeNameMap["IScriptingParameterEnumerationChoice"] = IScriptingParameterEnumerationChoice

class IScriptingParameterEnumerationChoiceCollection(object):
    """The list of enumeration choices available when parameter type is Enumeration."""
    _uuid = "{FF132A94-418D-41DB-8AA2-9DA77625A1A0}"
    _num_methods = 11
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_add"] = _raise_uninitialized_error
        self.__dict__["_remove"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_cut"] = _raise_uninitialized_error
        self.__dict__["_paste"] = _raise_uninitialized_error
        self.__dict__["_insert_copy"] = _raise_uninitialized_error
        self.__dict__["_get_provide_runtime_type_info"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_index"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IScriptingParameterEnumerationChoiceCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IScriptingParameterEnumerationChoiceCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IScriptingParameterEnumerationChoiceCollection = agcom.GUID(IScriptingParameterEnumerationChoiceCollection._uuid)
        vtable_offset_local = IScriptingParameterEnumerationChoiceCollection._vtable_offset - 1
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameterEnumerationChoiceCollection, vtable_offset_local+1, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_add"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameterEnumerationChoiceCollection, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_remove"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameterEnumerationChoiceCollection, vtable_offset_local+3, agcom.VARIANT)
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameterEnumerationChoiceCollection, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameterEnumerationChoiceCollection, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_cut"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameterEnumerationChoiceCollection, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_paste"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameterEnumerationChoiceCollection, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_insert_copy"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameterEnumerationChoiceCollection, vtable_offset_local+8, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_get_provide_runtime_type_info"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameterEnumerationChoiceCollection, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_get_item_by_index"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameterEnumerationChoiceCollection, vtable_offset_local+10, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_get_item_by_name"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameterEnumerationChoiceCollection, vtable_offset_local+11, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IScriptingParameterEnumerationChoiceCollection.__dict__ and type(IScriptingParameterEnumerationChoiceCollection.__dict__[attrname]) == property:
            return IScriptingParameterEnumerationChoiceCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IScriptingParameterEnumerationChoiceCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IScriptingParameterEnumerationChoice":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def item(self, indexOrName:typing.Any) -> "IScriptingParameterEnumerationChoice":
        """Allows you to iterate through the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppChoice:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_indexOrName.COM_val, byref(arg_ppChoice.COM_val)))
            return arg_ppChoice.python_val

    def add(self, choiceName:str) -> "IScriptingParameterEnumerationChoice":
        """Adds an enumeration choice to the collection."""
        with agmarshall.BSTR_arg(choiceName) as arg_choiceName, \
             agmarshall.AgInterface_out_arg() as arg_ppChoice:
            agcls.evaluate_hresult(self.__dict__["_add"](arg_choiceName.COM_val, byref(arg_ppChoice.COM_val)))
            return arg_ppChoice.python_val

    def remove(self, indexOrName:typing.Any) -> None:
        """Removes an enumeration choice."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_remove"](arg_indexOrName.COM_val))

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def cut(self, indexOrName:typing.Any) -> None:
        """Copies the enumeration choice into the clipboard and removes the enumeration choice from the list."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_cut"](arg_indexOrName.COM_val))

    def paste(self) -> "IScriptingParameterEnumerationChoice":
        """Pastes the enumeration choice from the clipboard and inserts into the list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_paste"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def insert_copy(self, choice:"IScriptingParameterEnumerationChoice") -> "IScriptingParameterEnumerationChoice":
        """Copies the enumeration choice and inserts the copy into the list."""
        with agmarshall.AgInterface_in_arg(choice, IScriptingParameterEnumerationChoice) as arg_choice, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_insert_copy"](arg_choice.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def provide_runtime_type_info(self) -> "IRuntimeTypeInfo":
        """Returns the IRuntimeTypeInfo interface to access properties at runtime."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_provide_runtime_type_info"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def get_item_by_index(self, index:int) -> "IScriptingParameterEnumerationChoice":
        """Retrieves a scripting parameter enumeration choice in the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppChoice:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_index"](arg_index.COM_val, byref(arg_ppChoice.COM_val)))
            return arg_ppChoice.python_val

    def get_item_by_name(self, name:str) -> "IScriptingParameterEnumerationChoice":
        """Retrieves a scripting parameter enumeration choice in the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppChoice:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_name"](arg_name.COM_val, byref(arg_ppChoice.COM_val)))
            return arg_ppChoice.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{FF132A94-418D-41DB-8AA2-9DA77625A1A0}", IScriptingParameterEnumerationChoiceCollection)
agcls.AgTypeNameMap["IScriptingParameterEnumerationChoiceCollection"] = IScriptingParameterEnumerationChoiceCollection

class IScriptingParameter(object):
    """Parameter properties for scripting options."""
    _uuid = "{9E855CDD-3359-4D5D-AE7D-5C260E0EE4B3}"
    _num_methods = 23
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_name"] = _raise_uninitialized_error
        self.__dict__["_set_name"] = _raise_uninitialized_error
        self.__dict__["_get_param_value"] = _raise_uninitialized_error
        self.__dict__["_set_param_value"] = _raise_uninitialized_error
        self.__dict__["_get_unit"] = _raise_uninitialized_error
        self.__dict__["_set_unit"] = _raise_uninitialized_error
        self.__dict__["_get_type"] = _raise_uninitialized_error
        self.__dict__["_set_type"] = _raise_uninitialized_error
        self.__dict__["_get_inherit_value"] = _raise_uninitialized_error
        self.__dict__["_set_inherit_value"] = _raise_uninitialized_error
        self.__dict__["_get_user_comment"] = _raise_uninitialized_error
        self.__dict__["_set_user_comment"] = _raise_uninitialized_error
        self.__dict__["_get_dimension"] = _raise_uninitialized_error
        self.__dict__["_set_dimension"] = _raise_uninitialized_error
        self.__dict__["_get_enumeration_choices"] = _raise_uninitialized_error
        self.__dict__["_get_use_min_value"] = _raise_uninitialized_error
        self.__dict__["_set_use_min_value"] = _raise_uninitialized_error
        self.__dict__["_get_min_value"] = _raise_uninitialized_error
        self.__dict__["_set_min_value"] = _raise_uninitialized_error
        self.__dict__["_get_use_max_value"] = _raise_uninitialized_error
        self.__dict__["_set_use_max_value"] = _raise_uninitialized_error
        self.__dict__["_get_max_value"] = _raise_uninitialized_error
        self.__dict__["_set_max_value"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IScriptingParameter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IScriptingParameter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IScriptingParameter = agcom.GUID(IScriptingParameter._uuid)
        vtable_offset_local = IScriptingParameter._vtable_offset - 1
        self.__dict__["_get_name"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameter, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_name"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameter, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_param_value"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameter, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_set_param_value"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameter, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_get_unit"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameter, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_set_unit"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameter, vtable_offset_local+6, agcom.BSTR)
        self.__dict__["_get_type"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameter, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_type"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameter, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_inherit_value"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameter, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_inherit_value"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameter, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_get_user_comment"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameter, vtable_offset_local+11, POINTER(agcom.BSTR))
        self.__dict__["_set_user_comment"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameter, vtable_offset_local+12, agcom.BSTR)
        self.__dict__["_get_dimension"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameter, vtable_offset_local+13, POINTER(agcom.BSTR))
        self.__dict__["_set_dimension"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameter, vtable_offset_local+14, agcom.BSTR)
        self.__dict__["_get_enumeration_choices"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameter, vtable_offset_local+15, POINTER(agcom.PVOID))
        self.__dict__["_get_use_min_value"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameter, vtable_offset_local+16, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_min_value"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameter, vtable_offset_local+17, agcom.VARIANT_BOOL)
        self.__dict__["_get_min_value"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameter, vtable_offset_local+18, POINTER(agcom.VARIANT))
        self.__dict__["_set_min_value"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameter, vtable_offset_local+19, agcom.VARIANT)
        self.__dict__["_get_use_max_value"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameter, vtable_offset_local+20, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_max_value"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameter, vtable_offset_local+21, agcom.VARIANT_BOOL)
        self.__dict__["_get_max_value"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameter, vtable_offset_local+22, POINTER(agcom.VARIANT))
        self.__dict__["_set_max_value"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameter, vtable_offset_local+23, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IScriptingParameter.__dict__ and type(IScriptingParameter.__dict__[attrname]) == property:
            return IScriptingParameter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IScriptingParameter.")
    
    @property
    def name(self) -> str:
        """The parameter name."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @name.setter
    def name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_name"](arg_inVal.COM_val))

    @property
    def param_value(self) -> typing.Any:
        """The parameter value.  Set in Object Model unit preference for selected dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_param_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @param_value.setter
    def param_value(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_param_value"](arg_inVal.COM_val))

    @property
    def unit(self) -> str:
        """The parameter's unit that is used to represent ParamValue during the scripting tool script execution. ParamValue is set in Object Model unit preference for selected dimension and not this unit. As with other units configurable in the desktop environment for STK, this unit is separate (and may differ) from the Object Model unit preference."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_unit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @unit.setter
    def unit(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_unit"](arg_inVal.COM_val))

    @property
    def type(self) -> "AgEVAScriptingParameterType":
        """The parameter's type."""
        with agmarshall.AgEnum_arg(AgEVAScriptingParameterType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @type.setter
    def type(self, inVal:"AgEVAScriptingParameterType") -> None:
        with agmarshall.AgEnum_arg(AgEVAScriptingParameterType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_type"](arg_inVal.COM_val))

    @property
    def inherit_value(self) -> bool:
        """If true, parameter value will be inherited from previous profile's value."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVAl:
            agcls.evaluate_hresult(self.__dict__["_get_inherit_value"](byref(arg_pVAl.COM_val)))
            return arg_pVAl.python_val

    @inherit_value.setter
    def inherit_value(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_inherit_value"](arg_inVal.COM_val))

    @property
    def user_comment(self) -> str:
        """The parameter's comment."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_user_comment"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @user_comment.setter
    def user_comment(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_user_comment"](arg_inVal.COM_val))

    @property
    def dimension(self) -> str:
        """The parameter's dimension."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_dimension"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @dimension.setter
    def dimension(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_dimension"](arg_inVal.COM_val))

    @property
    def enumeration_choices(self) -> "IScriptingParameterEnumerationChoiceCollection":
        """The collection of enumerations to use when parameter type is eVAScriptingParameterTypeEnumeration."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_enumeration_choices"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def use_min_value(self) -> bool:
        """If true, a minimum value will be enforced for the parameter value"""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_min_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_min_value.setter
    def use_min_value(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_min_value"](arg_inVal.COM_val))

    @property
    def min_value(self) -> typing.Any:
        """The minimum value permitted for the parameter value"""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @min_value.setter
    def min_value(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_min_value"](arg_inVal.COM_val))

    @property
    def use_max_value(self) -> bool:
        """If true, a maximum value will be enforced for the parameter value"""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_max_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_max_value.setter
    def use_max_value(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_max_value"](arg_inVal.COM_val))

    @property
    def max_value(self) -> typing.Any:
        """The maximum value permitted for the parameter value"""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_value.setter
    def max_value(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_value"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{9E855CDD-3359-4D5D-AE7D-5C260E0EE4B3}", IScriptingParameter)
agcls.AgTypeNameMap["IScriptingParameter"] = IScriptingParameter

class IScriptingParameterCollection(object):
    """The list of parameters that the script can interact with."""
    _uuid = "{57FC26AA-550D-4408-844E-24F983C94671}"
    _num_methods = 12
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_add"] = _raise_uninitialized_error
        self.__dict__["_remove"] = _raise_uninitialized_error
        self.__dict__["_remove_all"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_get_provide_runtime_type_info"] = _raise_uninitialized_error
        self.__dict__["_cut"] = _raise_uninitialized_error
        self.__dict__["_paste"] = _raise_uninitialized_error
        self.__dict__["_insert_copy"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_index"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IScriptingParameterCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IScriptingParameterCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IScriptingParameterCollection = agcom.GUID(IScriptingParameterCollection._uuid)
        vtable_offset_local = IScriptingParameterCollection._vtable_offset - 1
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameterCollection, vtable_offset_local+1, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_add"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameterCollection, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_remove"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameterCollection, vtable_offset_local+3, agcom.VARIANT)
        self.__dict__["_remove_all"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameterCollection, vtable_offset_local+4, )
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameterCollection, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameterCollection, vtable_offset_local+6, POINTER(agcom.LONG))
        self.__dict__["_get_provide_runtime_type_info"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameterCollection, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_cut"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameterCollection, vtable_offset_local+8, agcom.VARIANT)
        self.__dict__["_paste"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameterCollection, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_insert_copy"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameterCollection, vtable_offset_local+10, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_get_item_by_index"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameterCollection, vtable_offset_local+11, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_get_item_by_name"] = IAGFUNCTYPE(pUnk, IID_IScriptingParameterCollection, vtable_offset_local+12, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IScriptingParameterCollection.__dict__ and type(IScriptingParameterCollection.__dict__[attrname]) == property:
            return IScriptingParameterCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IScriptingParameterCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IScriptingParameter":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def item(self, indexOrName:typing.Any) -> "IScriptingParameter":
        """Allows you to iterate through the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppVAScriptingParameter:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_indexOrName.COM_val, byref(arg_ppVAScriptingParameter.COM_val)))
            return arg_ppVAScriptingParameter.python_val

    def add(self, parameterName:str) -> "IScriptingParameter":
        """Adds a parameter to the collection."""
        with agmarshall.BSTR_arg(parameterName) as arg_parameterName, \
             agmarshall.AgInterface_out_arg() as arg_ppVAScriptingParameter:
            agcls.evaluate_hresult(self.__dict__["_add"](arg_parameterName.COM_val, byref(arg_ppVAScriptingParameter.COM_val)))
            return arg_ppVAScriptingParameter.python_val

    def remove(self, indexOrName:typing.Any) -> None:
        """Removes a parameter."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_remove"](arg_indexOrName.COM_val))

    def remove_all(self) -> None:
        """Removes all parameters."""
        agcls.evaluate_hresult(self.__dict__["_remove_all"]())

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def provide_runtime_type_info(self) -> "IRuntimeTypeInfo":
        """Returns the IRuntimeTypeInfo interface to access properties at runtime."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_provide_runtime_type_info"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def cut(self, indexOrName:typing.Any) -> None:
        """Copies the parameter into the clipboard and removes the parameter from the list."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_cut"](arg_indexOrName.COM_val))

    def paste(self) -> "IScriptingParameter":
        """Pastes the parameter from the clipboard and inserts into the list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_paste"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def insert_copy(self, parameter:"IScriptingParameter") -> "IScriptingParameter":
        """Copies the parameter and inserts the copy into the list."""
        with agmarshall.AgInterface_in_arg(parameter, IScriptingParameter) as arg_parameter, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_insert_copy"](arg_parameter.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def get_item_by_index(self, index:int) -> "IScriptingParameter":
        """Retrieves a scripting parameter in the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppVAScriptingParameter:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_index"](arg_index.COM_val, byref(arg_ppVAScriptingParameter.COM_val)))
            return arg_ppVAScriptingParameter.python_val

    def get_item_by_name(self, name:str) -> "IScriptingParameter":
        """Retrieves a scripting parameter in the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppVAScriptingParameter:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_name"](arg_name.COM_val, byref(arg_ppVAScriptingParameter.COM_val)))
            return arg_ppVAScriptingParameter.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{57FC26AA-550D-4408-844E-24F983C94671}", IScriptingParameterCollection)
agcls.AgTypeNameMap["IScriptingParameterCollection"] = IScriptingParameterCollection

class IScriptingCalcObject(object):
    """Calc Object properties for scripting options."""
    _uuid = "{6DDE7375-1872-436C-B2BE-ADBF1881FFF0}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_component_name"] = _raise_uninitialized_error
        self.__dict__["_set_component_name"] = _raise_uninitialized_error
        self.__dict__["_get_calc_object_name"] = _raise_uninitialized_error
        self.__dict__["_set_calc_object_name"] = _raise_uninitialized_error
        self.__dict__["_get_calc_object"] = _raise_uninitialized_error
        self.__dict__["_set_calc_object"] = _raise_uninitialized_error
        self.__dict__["_get_unit"] = _raise_uninitialized_error
        self.__dict__["_set_unit"] = _raise_uninitialized_error
        self.__dict__["_copy_calc_object_to_clipboard"] = _raise_uninitialized_error
        self.__dict__["_paste_calc_object_from_clipboard"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IScriptingCalcObject._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IScriptingCalcObject from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IScriptingCalcObject = agcom.GUID(IScriptingCalcObject._uuid)
        vtable_offset_local = IScriptingCalcObject._vtable_offset - 1
        self.__dict__["_get_component_name"] = IAGFUNCTYPE(pUnk, IID_IScriptingCalcObject, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_component_name"] = IAGFUNCTYPE(pUnk, IID_IScriptingCalcObject, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_calc_object_name"] = IAGFUNCTYPE(pUnk, IID_IScriptingCalcObject, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_calc_object_name"] = IAGFUNCTYPE(pUnk, IID_IScriptingCalcObject, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_get_calc_object"] = IAGFUNCTYPE(pUnk, IID_IScriptingCalcObject, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_set_calc_object"] = IAGFUNCTYPE(pUnk, IID_IScriptingCalcObject, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_get_unit"] = IAGFUNCTYPE(pUnk, IID_IScriptingCalcObject, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_set_unit"] = IAGFUNCTYPE(pUnk, IID_IScriptingCalcObject, vtable_offset_local+8, agcom.BSTR)
        self.__dict__["_copy_calc_object_to_clipboard"] = IAGFUNCTYPE(pUnk, IID_IScriptingCalcObject, vtable_offset_local+9, )
        self.__dict__["_paste_calc_object_from_clipboard"] = IAGFUNCTYPE(pUnk, IID_IScriptingCalcObject, vtable_offset_local+10, )
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IScriptingCalcObject.__dict__ and type(IScriptingCalcObject.__dict__[attrname]) == property:
            return IScriptingCalcObject.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IScriptingCalcObject.")
    
    @property
    def component_name(self) -> str:
        """The name of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_component_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @component_name.setter
    def component_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_component_name"](arg_inVal.COM_val))

    @property
    def calc_object_name(self) -> str:
        """The name of the calculation object."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_calc_object_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @calc_object_name.setter
    def calc_object_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_calc_object_name"](arg_inVal.COM_val))

    @property
    def calc_object(self) -> "IComponentInfo":
        """The calculation object type."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_calc_object"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @calc_object.setter
    def calc_object(self, inVal:"IComponentInfo") -> None:
        with agmarshall.AgInterface_in_arg(inVal, IComponentInfo) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_calc_object"](arg_inVal.COM_val))

    @property
    def unit(self) -> str:
        """The unit."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_unit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @unit.setter
    def unit(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_unit"](arg_inVal.COM_val))

    def copy_calc_object_to_clipboard(self) -> None:
        """Copies the wrapped calc object to the clipboard."""
        agcls.evaluate_hresult(self.__dict__["_copy_calc_object_to_clipboard"]())

    def paste_calc_object_from_clipboard(self) -> None:
        """Replaces the wrapped calc object with the instance in the clipboard."""
        agcls.evaluate_hresult(self.__dict__["_paste_calc_object_from_clipboard"]())


agcls.AgClassCatalog.add_catalog_entry("{6DDE7375-1872-436C-B2BE-ADBF1881FFF0}", IScriptingCalcObject)
agcls.AgTypeNameMap["IScriptingCalcObject"] = IScriptingCalcObject

class IScriptingCalcObjectCollection(object):
    """The list of calc objects that the script can interact with."""
    _uuid = "{C7742744-0197-46E3-AE3F-E6F60357FACD}"
    _num_methods = 11
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_add"] = _raise_uninitialized_error
        self.__dict__["_remove"] = _raise_uninitialized_error
        self.__dict__["_remove_all"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_cut"] = _raise_uninitialized_error
        self.__dict__["_paste"] = _raise_uninitialized_error
        self.__dict__["_insert_copy"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_index"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IScriptingCalcObjectCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IScriptingCalcObjectCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IScriptingCalcObjectCollection = agcom.GUID(IScriptingCalcObjectCollection._uuid)
        vtable_offset_local = IScriptingCalcObjectCollection._vtable_offset - 1
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IScriptingCalcObjectCollection, vtable_offset_local+1, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_add"] = IAGFUNCTYPE(pUnk, IID_IScriptingCalcObjectCollection, vtable_offset_local+2, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_remove"] = IAGFUNCTYPE(pUnk, IID_IScriptingCalcObjectCollection, vtable_offset_local+3, agcom.VARIANT)
        self.__dict__["_remove_all"] = IAGFUNCTYPE(pUnk, IID_IScriptingCalcObjectCollection, vtable_offset_local+4, )
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IScriptingCalcObjectCollection, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IScriptingCalcObjectCollection, vtable_offset_local+6, POINTER(agcom.LONG))
        self.__dict__["_cut"] = IAGFUNCTYPE(pUnk, IID_IScriptingCalcObjectCollection, vtable_offset_local+7, agcom.VARIANT)
        self.__dict__["_paste"] = IAGFUNCTYPE(pUnk, IID_IScriptingCalcObjectCollection, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_insert_copy"] = IAGFUNCTYPE(pUnk, IID_IScriptingCalcObjectCollection, vtable_offset_local+9, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_get_item_by_index"] = IAGFUNCTYPE(pUnk, IID_IScriptingCalcObjectCollection, vtable_offset_local+10, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_get_item_by_name"] = IAGFUNCTYPE(pUnk, IID_IScriptingCalcObjectCollection, vtable_offset_local+11, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IScriptingCalcObjectCollection.__dict__ and type(IScriptingCalcObjectCollection.__dict__[attrname]) == property:
            return IScriptingCalcObjectCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IScriptingCalcObjectCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IScriptingCalcObject":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def item(self, indexOrName:typing.Any) -> "IScriptingCalcObject":
        """Allows you to iterate through the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppCalcObjectWrapper:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_indexOrName.COM_val, byref(arg_ppCalcObjectWrapper.COM_val)))
            return arg_ppCalcObjectWrapper.python_val

    def add(self, componentName:str) -> "IScriptingCalcObject":
        """Adds a calculation object to the collection."""
        with agmarshall.BSTR_arg(componentName) as arg_componentName, \
             agmarshall.AgInterface_out_arg() as arg_ppVAScriptingParameter:
            agcls.evaluate_hresult(self.__dict__["_add"](arg_componentName.COM_val, byref(arg_ppVAScriptingParameter.COM_val)))
            return arg_ppVAScriptingParameter.python_val

    def remove(self, indexOrName:typing.Any) -> None:
        """Removes a calculation object."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_remove"](arg_indexOrName.COM_val))

    def remove_all(self) -> None:
        """Removes all calculation objects."""
        agcls.evaluate_hresult(self.__dict__["_remove_all"]())

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def cut(self, indexOrName:typing.Any) -> None:
        """Copies the calc object into the clipboard and removes the calc object from the list."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_cut"](arg_indexOrName.COM_val))

    def paste(self) -> "IScriptingCalcObject":
        """Pastes the calc object from the clipboard and inserts into the list."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_paste"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def insert_copy(self, calcObj:"IScriptingCalcObject") -> "IScriptingCalcObject":
        """Copies the calc object and inserts the copy into the list."""
        with agmarshall.AgInterface_in_arg(calcObj, IScriptingCalcObject) as arg_calcObj, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_insert_copy"](arg_calcObj.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def get_item_by_index(self, index:int) -> "IScriptingCalcObject":
        """Retrieves a scripting calc object from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_index"](arg_index.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def get_item_by_name(self, componentName:str) -> "IScriptingCalcObject":
        """Retrieves a scripting calc object from the collection by name."""
        with agmarshall.BSTR_arg(componentName) as arg_componentName, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_name"](arg_componentName.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{C7742744-0197-46E3-AE3F-E6F60357FACD}", IScriptingCalcObjectCollection)
agcls.AgTypeNameMap["IScriptingCalcObjectCollection"] = IScriptingCalcObjectCollection

class IScriptingTool(object):
    """Properties for the Scripting Tool."""
    _uuid = "{BA2389F3-C687-40B6-B4FC-F61F2BF80E6E}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_enable"] = _raise_uninitialized_error
        self.__dict__["_set_enable"] = _raise_uninitialized_error
        self.__dict__["_get_segment_properties"] = _raise_uninitialized_error
        self.__dict__["_get_calc_objects"] = _raise_uninitialized_error
        self.__dict__["_get_parameters"] = _raise_uninitialized_error
        self.__dict__["_get_language_type"] = _raise_uninitialized_error
        self.__dict__["_set_language_type"] = _raise_uninitialized_error
        self.__dict__["_script_text"] = _raise_uninitialized_error
        self.__dict__["_copy_to_clipboard"] = _raise_uninitialized_error
        self.__dict__["_paste_from_clipboard"] = _raise_uninitialized_error
        self.__dict__["_get_pre_iterate"] = _raise_uninitialized_error
        self.__dict__["_set_pre_iterate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IScriptingTool._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IScriptingTool from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IScriptingTool = agcom.GUID(IScriptingTool._uuid)
        vtable_offset_local = IScriptingTool._vtable_offset - 1
        self.__dict__["_get_enable"] = IAGFUNCTYPE(pUnk, IID_IScriptingTool, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable"] = IAGFUNCTYPE(pUnk, IID_IScriptingTool, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_segment_properties"] = IAGFUNCTYPE(pUnk, IID_IScriptingTool, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_calc_objects"] = IAGFUNCTYPE(pUnk, IID_IScriptingTool, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_parameters"] = IAGFUNCTYPE(pUnk, IID_IScriptingTool, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_language_type"] = IAGFUNCTYPE(pUnk, IID_IScriptingTool, vtable_offset_local+6, POINTER(agcom.LONG))
        self.__dict__["_set_language_type"] = IAGFUNCTYPE(pUnk, IID_IScriptingTool, vtable_offset_local+7, agcom.LONG)
        self.__dict__["_script_text"] = IAGFUNCTYPE(pUnk, IID_IScriptingTool, vtable_offset_local+8, agcom.BSTR)
        self.__dict__["_copy_to_clipboard"] = IAGFUNCTYPE(pUnk, IID_IScriptingTool, vtable_offset_local+9, )
        self.__dict__["_paste_from_clipboard"] = IAGFUNCTYPE(pUnk, IID_IScriptingTool, vtable_offset_local+10, )
        self.__dict__["_get_pre_iterate"] = IAGFUNCTYPE(pUnk, IID_IScriptingTool, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_pre_iterate"] = IAGFUNCTYPE(pUnk, IID_IScriptingTool, vtable_offset_local+12, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IScriptingTool.__dict__ and type(IScriptingTool.__dict__[attrname]) == property:
            return IScriptingTool.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IScriptingTool.")
    
    @property
    def enable(self) -> bool:
        """If true, the scripting tool is enabled."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable.setter
    def enable(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable"](arg_inVal.COM_val))

    @property
    def segment_properties(self) -> "IScriptingSegmentCollection":
        """Returns the collection of the segment properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_segment_properties"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def calc_objects(self) -> "IScriptingCalcObjectCollection":
        """Returns the collection of the calculation objects."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_calc_objects"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def parameters(self) -> "IScriptingParameterCollection":
        """Returns the collection of parameters."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_parameters"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def language_type(self) -> "AgEVALanguage":
        """The scripting language being used."""
        with agmarshall.AgEnum_arg(AgEVALanguage) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_language_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @language_type.setter
    def language_type(self, inVal:"AgEVALanguage") -> None:
        with agmarshall.AgEnum_arg(AgEVALanguage, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_language_type"](arg_inVal.COM_val))

    def script_text(self, script:str) -> None:
        """Injects the script into the scripting tool."""
        with agmarshall.BSTR_arg(script) as arg_script:
            agcls.evaluate_hresult(self.__dict__["_script_text"](arg_script.COM_val))

    def copy_to_clipboard(self) -> None:
        """Copies entire scripting tool to clipboard."""
        agcls.evaluate_hresult(self.__dict__["_copy_to_clipboard"]())

    def paste_from_clipboard(self) -> None:
        """Replaces entire scripting tool with scripting tool in clipboard."""
        agcls.evaluate_hresult(self.__dict__["_paste_from_clipboard"]())

    @property
    def pre_iterate(self) -> bool:
        """If true, the sequence will run once before executing the script."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_pre_iterate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @pre_iterate.setter
    def pre_iterate(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_pre_iterate"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{BA2389F3-C687-40B6-B4FC-F61F2BF80E6E}", IScriptingTool)
agcls.AgTypeNameMap["IScriptingTool"] = IScriptingTool

class IElement(object):
    """The elements of the selected coordinate type."""
    _uuid = "{D1D2C328-052A-4C2A-BC2F-739B55556384}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IElement._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IElement from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IElement = agcom.GUID(IElement._uuid)
        vtable_offset_local = IElement._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IElement.__dict__ and type(IElement.__dict__[attrname]) == property:
            return IElement.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IElement.")
    

agcls.AgClassCatalog.add_catalog_entry("{D1D2C328-052A-4C2A-BC2F-739B55556384}", IElement)
agcls.AgTypeNameMap["IElement"] = IElement

class ISpacecraftParameters(object):
    """Properties for spacecraft configuration."""
    _uuid = "{6642A93A-65F8-4D50-A3E8-51B17A9AE3CF}"
    _num_methods = 18
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_dry_mass"] = _raise_uninitialized_error
        self.__dict__["_set_dry_mass"] = _raise_uninitialized_error
        self.__dict__["_get_cd"] = _raise_uninitialized_error
        self.__dict__["_set_cd"] = _raise_uninitialized_error
        self.__dict__["_get_drag_area"] = _raise_uninitialized_error
        self.__dict__["_set_drag_area"] = _raise_uninitialized_error
        self.__dict__["_get_cr"] = _raise_uninitialized_error
        self.__dict__["_set_cr"] = _raise_uninitialized_error
        self.__dict__["_get_solar_radiation_pressure_area"] = _raise_uninitialized_error
        self.__dict__["_set_solar_radiation_pressure_area"] = _raise_uninitialized_error
        self.__dict__["_get_ck"] = _raise_uninitialized_error
        self.__dict__["_set_ck"] = _raise_uninitialized_error
        self.__dict__["_get_radiation_pressure_area"] = _raise_uninitialized_error
        self.__dict__["_set_radiation_pressure_area"] = _raise_uninitialized_error
        self.__dict__["_get_k1"] = _raise_uninitialized_error
        self.__dict__["_set_k1"] = _raise_uninitialized_error
        self.__dict__["_get_k2"] = _raise_uninitialized_error
        self.__dict__["_set_k2"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISpacecraftParameters._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISpacecraftParameters from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISpacecraftParameters = agcom.GUID(ISpacecraftParameters._uuid)
        vtable_offset_local = ISpacecraftParameters._vtable_offset - 1
        self.__dict__["_get_dry_mass"] = IAGFUNCTYPE(pUnk, IID_ISpacecraftParameters, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_dry_mass"] = IAGFUNCTYPE(pUnk, IID_ISpacecraftParameters, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_cd"] = IAGFUNCTYPE(pUnk, IID_ISpacecraftParameters, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_cd"] = IAGFUNCTYPE(pUnk, IID_ISpacecraftParameters, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_drag_area"] = IAGFUNCTYPE(pUnk, IID_ISpacecraftParameters, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_drag_area"] = IAGFUNCTYPE(pUnk, IID_ISpacecraftParameters, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_cr"] = IAGFUNCTYPE(pUnk, IID_ISpacecraftParameters, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_cr"] = IAGFUNCTYPE(pUnk, IID_ISpacecraftParameters, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_solar_radiation_pressure_area"] = IAGFUNCTYPE(pUnk, IID_ISpacecraftParameters, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_solar_radiation_pressure_area"] = IAGFUNCTYPE(pUnk, IID_ISpacecraftParameters, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_ck"] = IAGFUNCTYPE(pUnk, IID_ISpacecraftParameters, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_ck"] = IAGFUNCTYPE(pUnk, IID_ISpacecraftParameters, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_radiation_pressure_area"] = IAGFUNCTYPE(pUnk, IID_ISpacecraftParameters, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_radiation_pressure_area"] = IAGFUNCTYPE(pUnk, IID_ISpacecraftParameters, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_k1"] = IAGFUNCTYPE(pUnk, IID_ISpacecraftParameters, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_k1"] = IAGFUNCTYPE(pUnk, IID_ISpacecraftParameters, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_k2"] = IAGFUNCTYPE(pUnk, IID_ISpacecraftParameters, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_k2"] = IAGFUNCTYPE(pUnk, IID_ISpacecraftParameters, vtable_offset_local+18, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISpacecraftParameters.__dict__ and type(ISpacecraftParameters.__dict__[attrname]) == property:
            return ISpacecraftParameters.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISpacecraftParameters.")
    
    @property
    def dry_mass(self) -> float:
        """The mass of the spacecraft exclusive of propellant. Uses Mass Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_dry_mass"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @dry_mass.setter
    def dry_mass(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_dry_mass"](arg_newVal.COM_val))

    @property
    def cd(self) -> float:
        """The dimensionless drag coefficient associated with the drag area. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_cd"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @cd.setter
    def cd(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_cd"](arg_newVal.COM_val))

    @property
    def drag_area(self) -> float:
        """The cross-sectional area of the spacecraft assumed perpendicular to the direction of motion, used for atmospheric drag calculations. Uses SmallArea Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_area"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_area.setter
    def drag_area(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_area"](arg_newVal.COM_val))

    @property
    def cr(self) -> float:
        """The reflectivity of the spacecraft used for solar radiation pressure calculations, where 2.0 is fully reflective and 1.0 is not reflective at all. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_cr"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @cr.setter
    def cr(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_cr"](arg_newVal.COM_val))

    @property
    def solar_radiation_pressure_area(self) -> float:
        """The cross-sectional area of the spacecraft assumed perpendicular to the direction of solar radiation, used for solar radiation calculations. Uses SmallArea Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_solar_radiation_pressure_area"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @solar_radiation_pressure_area.setter
    def solar_radiation_pressure_area(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_solar_radiation_pressure_area"](arg_newVal.COM_val))

    @property
    def ck(self) -> float:
        """The reflectivity of the spacecraft used for central body radiation pressure (albedo / thermal pressure) calculations, where 2.0 is fully reflective and 1.0 is not reflective at all. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_ck"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ck.setter
    def ck(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_ck"](arg_newVal.COM_val))

    @property
    def radiation_pressure_area(self) -> float:
        """The cross-sectional area of the spacecraft assumed perpendicular to the direction of central body radiation, used for central body radiation (albedo / thermal pressure) calculations. Uses SmallArea Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_radiation_pressure_area"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @radiation_pressure_area.setter
    def radiation_pressure_area(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_radiation_pressure_area"](arg_newVal.COM_val))

    @property
    def k1(self) -> float:
        """If you are using a non-spherical SRP model, this field defines the model's GPS solar radiation pressure K1 (scale) value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_k1"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @k1.setter
    def k1(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_k1"](arg_newVal.COM_val))

    @property
    def k2(self) -> float:
        """If you are using a non-spherical SRP model, this field defines the model's GPS solar radiation pressure K2 (scale) value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_k2"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @k2.setter
    def k2(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_k2"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{6642A93A-65F8-4D50-A3E8-51B17A9AE3CF}", ISpacecraftParameters)
agcls.AgTypeNameMap["ISpacecraftParameters"] = ISpacecraftParameters

class IFuelTank(object):
    """Properties for fuel tank configuration."""
    _uuid = "{6CB64830-3EDB-4E0E-A55B-DAC26DCCCA47}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_tank_pressure"] = _raise_uninitialized_error
        self.__dict__["_set_tank_pressure"] = _raise_uninitialized_error
        self.__dict__["_get_tank_volume"] = _raise_uninitialized_error
        self.__dict__["_set_tank_volume"] = _raise_uninitialized_error
        self.__dict__["_get_tank_temperature"] = _raise_uninitialized_error
        self.__dict__["_set_tank_temperature"] = _raise_uninitialized_error
        self.__dict__["_get_fuel_density"] = _raise_uninitialized_error
        self.__dict__["_set_fuel_density"] = _raise_uninitialized_error
        self.__dict__["_get_fuel_mass"] = _raise_uninitialized_error
        self.__dict__["_set_fuel_mass"] = _raise_uninitialized_error
        self.__dict__["_get_maximum_fuel_mass"] = _raise_uninitialized_error
        self.__dict__["_set_maximum_fuel_mass"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IFuelTank._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IFuelTank from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IFuelTank = agcom.GUID(IFuelTank._uuid)
        vtable_offset_local = IFuelTank._vtable_offset - 1
        self.__dict__["_get_tank_pressure"] = IAGFUNCTYPE(pUnk, IID_IFuelTank, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_tank_pressure"] = IAGFUNCTYPE(pUnk, IID_IFuelTank, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_tank_volume"] = IAGFUNCTYPE(pUnk, IID_IFuelTank, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_tank_volume"] = IAGFUNCTYPE(pUnk, IID_IFuelTank, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_tank_temperature"] = IAGFUNCTYPE(pUnk, IID_IFuelTank, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_tank_temperature"] = IAGFUNCTYPE(pUnk, IID_IFuelTank, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_fuel_density"] = IAGFUNCTYPE(pUnk, IID_IFuelTank, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_fuel_density"] = IAGFUNCTYPE(pUnk, IID_IFuelTank, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_fuel_mass"] = IAGFUNCTYPE(pUnk, IID_IFuelTank, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_fuel_mass"] = IAGFUNCTYPE(pUnk, IID_IFuelTank, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_maximum_fuel_mass"] = IAGFUNCTYPE(pUnk, IID_IFuelTank, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_maximum_fuel_mass"] = IAGFUNCTYPE(pUnk, IID_IFuelTank, vtable_offset_local+12, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IFuelTank.__dict__ and type(IFuelTank.__dict__[attrname]) == property:
            return IFuelTank.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IFuelTank.")
    
    @property
    def tank_pressure(self) -> float:
        """The fuel tank pressure. Uses Pressure Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_tank_pressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @tank_pressure.setter
    def tank_pressure(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_tank_pressure"](arg_newVal.COM_val))

    @property
    def tank_volume(self) -> float:
        """The volume of the fuel tank. Uses SmallVolume Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_tank_volume"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @tank_volume.setter
    def tank_volume(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_tank_volume"](arg_newVal.COM_val))

    @property
    def tank_temperature(self) -> float:
        """The temperature of the fuel tank. Uses Temperature Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_tank_temperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @tank_temperature.setter
    def tank_temperature(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_tank_temperature"](arg_newVal.COM_val))

    @property
    def fuel_density(self) -> float:
        """The density of the fuel. Uses SmallDensity Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_fuel_density"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @fuel_density.setter
    def fuel_density(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_fuel_density"](arg_newVal.COM_val))

    @property
    def fuel_mass(self) -> float:
        """The mass of the spacecraft propellant. Uses Mass Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_fuel_mass"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @fuel_mass.setter
    def fuel_mass(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_fuel_mass"](arg_newVal.COM_val))

    @property
    def maximum_fuel_mass(self) -> float:
        """The maximum fuel mass of the spacecraft; this parameter specifically applies to Finite Maneuver segments that are being executed in Backward Sequences. Uses Mass Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_maximum_fuel_mass"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @maximum_fuel_mass.setter
    def maximum_fuel_mass(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_maximum_fuel_mass"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{6CB64830-3EDB-4E0E-A55B-DAC26DCCCA47}", IFuelTank)
agcls.AgTypeNameMap["IFuelTank"] = IFuelTank

class IMissionControlSequenceSegmentProperties(object):
    """The segment properties."""
    _uuid = "{B8C99C10-CB59-4C72-A97C-CBF561C41D4D}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_display_coordinate_system"] = _raise_uninitialized_error
        self.__dict__["_set_display_coordinate_system"] = _raise_uninitialized_error
        self.__dict__["_get_color"] = _raise_uninitialized_error
        self.__dict__["_set_color"] = _raise_uninitialized_error
        self.__dict__["_get_update_animation_time_after_run"] = _raise_uninitialized_error
        self.__dict__["_set_update_animation_time_after_run"] = _raise_uninitialized_error
        self.__dict__["_apply_final_state_to_b_planes"] = _raise_uninitialized_error
        self.__dict__["_get_b_planes"] = _raise_uninitialized_error
        self.__dict__["_get_last_run_code"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMissionControlSequenceSegmentProperties._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMissionControlSequenceSegmentProperties from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMissionControlSequenceSegmentProperties = agcom.GUID(IMissionControlSequenceSegmentProperties._uuid)
        vtable_offset_local = IMissionControlSequenceSegmentProperties._vtable_offset - 1
        self.__dict__["_get_display_coordinate_system"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSegmentProperties, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_display_coordinate_system"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSegmentProperties, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_color"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSegmentProperties, vtable_offset_local+3, POINTER(agcom.OLE_COLOR))
        self.__dict__["_set_color"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSegmentProperties, vtable_offset_local+4, agcom.OLE_COLOR)
        self.__dict__["_get_update_animation_time_after_run"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSegmentProperties, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_update_animation_time_after_run"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSegmentProperties, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_apply_final_state_to_b_planes"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSegmentProperties, vtable_offset_local+7, )
        self.__dict__["_get_b_planes"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSegmentProperties, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_get_last_run_code"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSegmentProperties, vtable_offset_local+9, POINTER(agcom.LONG))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissionControlSequenceSegmentProperties.__dict__ and type(IMissionControlSequenceSegmentProperties.__dict__[attrname]) == property:
            return IMissionControlSequenceSegmentProperties.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissionControlSequenceSegmentProperties.")
    
    @property
    def display_coordinate_system(self) -> str:
        """The coordinate system that will be used in the segment summary report."""
        with agmarshall.BSTR_arg() as arg_pDisplayCoordinateSystem:
            agcls.evaluate_hresult(self.__dict__["_get_display_coordinate_system"](byref(arg_pDisplayCoordinateSystem.COM_val)))
            return arg_pDisplayCoordinateSystem.python_val

    @display_coordinate_system.setter
    def display_coordinate_system(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_display_coordinate_system"](arg_inVal.COM_val))

    @property
    def color(self) -> agcolor.Color:
        """The display color of the segment."""
        with agmarshall.OLE_COLOR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_color"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @color.setter
    def color(self, inVal:agcolor.Color) -> None:
        with agmarshall.OLE_COLOR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_color"](arg_inVal.COM_val))

    @property
    def update_animation_time_after_run(self) -> bool:
        """If true, Astrogator will set the animation time to the final epoch of the segment when the segment finishes running."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_update_animation_time_after_run"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @update_animation_time_after_run.setter
    def update_animation_time_after_run(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_update_animation_time_after_run"](arg_inVal.COM_val))

    def apply_final_state_to_b_planes(self) -> None:
        """Applies the last calculated final state of the segment to all selected B-Planes."""
        agcls.evaluate_hresult(self.__dict__["_apply_final_state_to_b_planes"]())

    @property
    def b_planes(self) -> "IBPlaneCollection":
        """The B-Plane or B-Planes to which the epoch, position, and velocity of the segment's final state will be applied, according to the B-Plane's definition."""
        with agmarshall.AgInterface_out_arg() as arg_ppVABPlaneCollection:
            agcls.evaluate_hresult(self.__dict__["_get_b_planes"](byref(arg_ppVABPlaneCollection.COM_val)))
            return arg_ppVABPlaneCollection.python_val

    @property
    def last_run_code(self) -> "AgEVARunCode":
        """The last run code returned by the segment."""
        with agmarshall.AgEnum_arg(AgEVARunCode) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_last_run_code"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{B8C99C10-CB59-4C72-A97C-CBF561C41D4D}", IMissionControlSequenceSegmentProperties)
agcls.AgTypeNameMap["IMissionControlSequenceSegmentProperties"] = IMissionControlSequenceSegmentProperties

class IMissionControlSequenceEnd(object):
    """Properties for an End segment."""
    _uuid = "{7AE91388-7900-4AA0-BF30-546957ACFE94}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMissionControlSequenceEnd._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMissionControlSequenceEnd from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMissionControlSequenceEnd = agcom.GUID(IMissionControlSequenceEnd._uuid)
        vtable_offset_local = IMissionControlSequenceEnd._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissionControlSequenceEnd.__dict__ and type(IMissionControlSequenceEnd.__dict__[attrname]) == property:
            return IMissionControlSequenceEnd.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissionControlSequenceEnd.")
    

agcls.AgClassCatalog.add_catalog_entry("{7AE91388-7900-4AA0-BF30-546957ACFE94}", IMissionControlSequenceEnd)
agcls.AgTypeNameMap["IMissionControlSequenceEnd"] = IMissionControlSequenceEnd

class IMissionControlSequenceInitialState(object):
    """Properties for an Initial State segment."""
    _uuid = "{D7458E20-A5E4-45C8-81A1-38A29F4131FD}"
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_set_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_get_orbit_epoch"] = _raise_uninitialized_error
        self.__dict__["_set_orbit_epoch"] = _raise_uninitialized_error
        self.__dict__["_get_spacecraft_parameters"] = _raise_uninitialized_error
        self.__dict__["_get_fuel_tank"] = _raise_uninitialized_error
        self.__dict__["_get_element_type"] = _raise_uninitialized_error
        self.__dict__["_set_element_type"] = _raise_uninitialized_error
        self.__dict__["_get_element"] = _raise_uninitialized_error
        self.__dict__["_enable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_disable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_is_control_parameter_enabled"] = _raise_uninitialized_error
        self.__dict__["_get_control_parameters_available"] = _raise_uninitialized_error
        self.__dict__["_get_user_variables"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMissionControlSequenceInitialState._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMissionControlSequenceInitialState from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMissionControlSequenceInitialState = agcom.GUID(IMissionControlSequenceInitialState._uuid)
        vtable_offset_local = IMissionControlSequenceInitialState._vtable_offset - 1
        self.__dict__["_get_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceInitialState, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceInitialState, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_orbit_epoch"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceInitialState, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_set_orbit_epoch"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceInitialState, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_get_spacecraft_parameters"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceInitialState, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_fuel_tank"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceInitialState, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_get_element_type"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceInitialState, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_element_type"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceInitialState, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_element"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceInitialState, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_enable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceInitialState, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_disable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceInitialState, vtable_offset_local+11, agcom.LONG)
        self.__dict__["_is_control_parameter_enabled"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceInitialState, vtable_offset_local+12, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_control_parameters_available"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceInitialState, vtable_offset_local+13, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_user_variables"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceInitialState, vtable_offset_local+14, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissionControlSequenceInitialState.__dict__ and type(IMissionControlSequenceInitialState.__dict__[attrname]) == property:
            return IMissionControlSequenceInitialState.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissionControlSequenceInitialState.")
    
    @property
    def coord_system_name(self) -> str:
        """The coordinate system."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_system_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_system_name.setter
    def coord_system_name(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_system_name"](arg_newVal.COM_val))

    @property
    def orbit_epoch(self) -> typing.Any:
        """The orbit epoch. Uses DateFormat Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_orbit_epoch"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @orbit_epoch.setter
    def orbit_epoch(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_orbit_epoch"](arg_newVal.COM_val))

    @property
    def spacecraft_parameters(self) -> "ISpacecraftParameters":
        """The spacecraft  parameters."""
        with agmarshall.AgInterface_out_arg() as arg_ppSpacecraftParameters:
            agcls.evaluate_hresult(self.__dict__["_get_spacecraft_parameters"](byref(arg_ppSpacecraftParameters.COM_val)))
            return arg_ppSpacecraftParameters.python_val

    @property
    def fuel_tank(self) -> "IFuelTank":
        """The fuel tank parameters."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAFuelTank:
            agcls.evaluate_hresult(self.__dict__["_get_fuel_tank"](byref(arg_ppVAFuelTank.COM_val)))
            return arg_ppVAFuelTank.python_val

    @property
    def element_type(self) -> "AgEVAElementType":
        """The coordinate type."""
        with agmarshall.AgEnum_arg(AgEVAElementType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_element_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_element_type(self, elementType:"AgEVAElementType") -> None:
        """Selects an coordinate type."""
        with agmarshall.AgEnum_arg(AgEVAElementType, elementType) as arg_elementType:
            agcls.evaluate_hresult(self.__dict__["_set_element_type"](arg_elementType.COM_val))

    @property
    def element(self) -> "IElement":
        """The elements of the selected coordinate type."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAElement:
            agcls.evaluate_hresult(self.__dict__["_get_element"](byref(arg_ppVAElement.COM_val)))
            return arg_ppVAElement.python_val

    def enable_control_parameter(self, param:"AgEVAControlInitState") -> None:
        """Enables a control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlInitState, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_enable_control_parameter"](arg_param.COM_val))

    def disable_control_parameter(self, param:"AgEVAControlInitState") -> None:
        """Disables a control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlInitState, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_disable_control_parameter"](arg_param.COM_val))

    def is_control_parameter_enabled(self, param:"AgEVAControlInitState") -> bool:
        """Sees if a control is enabled."""
        with agmarshall.AgEnum_arg(AgEVAControlInitState, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_is_control_parameter_enabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_parameters_available(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_parameters_available"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def user_variables(self) -> "IUserVariableCollection":
        """Interface used to modify user variables for the initial state segment."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_user_variables"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{D7458E20-A5E4-45C8-81A1-38A29F4131FD}", IMissionControlSequenceInitialState)
agcls.AgTypeNameMap["IMissionControlSequenceInitialState"] = IMissionControlSequenceInitialState

class IMissionControlSequenceSegment(object):
    """General properties for segments."""
    _uuid = "{46F093C1-5138-4A6F-A79C-7F4DB8E7BCB4}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_type"] = _raise_uninitialized_error
        self.__dict__["_get_properties"] = _raise_uninitialized_error
        self.__dict__["_get_initial_state"] = _raise_uninitialized_error
        self.__dict__["_get_final_state"] = _raise_uninitialized_error
        self.__dict__["_get_result_value"] = _raise_uninitialized_error
        self.__dict__["_run"] = _raise_uninitialized_error
        self.__dict__["_get_results"] = _raise_uninitialized_error
        self.__dict__["_get_exec_summary"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMissionControlSequenceSegment._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMissionControlSequenceSegment from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMissionControlSequenceSegment = agcom.GUID(IMissionControlSequenceSegment._uuid)
        vtable_offset_local = IMissionControlSequenceSegment._vtable_offset - 1
        self.__dict__["_get_type"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSegment, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_get_properties"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSegment, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_initial_state"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSegment, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_final_state"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSegment, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_result_value"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSegment, vtable_offset_local+5, agcom.BSTR, POINTER(agcom.VARIANT))
        self.__dict__["_run"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSegment, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_get_results"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSegment, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_get_exec_summary"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSegment, vtable_offset_local+8, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissionControlSequenceSegment.__dict__ and type(IMissionControlSequenceSegment.__dict__[attrname]) == property:
            return IMissionControlSequenceSegment.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissionControlSequenceSegment.")
    
    @property
    def type(self) -> "AgEVASegmentType":
        """Returns the type of segment."""
        with agmarshall.AgEnum_arg(AgEVASegmentType) as arg_pSegmentType:
            agcls.evaluate_hresult(self.__dict__["_get_type"](byref(arg_pSegmentType.COM_val)))
            return arg_pSegmentType.python_val

    @property
    def properties(self) -> "IMissionControlSequenceSegmentProperties":
        """Returns the properties of the segment."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAMCSSegmentProperties:
            agcls.evaluate_hresult(self.__dict__["_get_properties"](byref(arg_ppVAMCSSegmentProperties.COM_val)))
            return arg_ppVAMCSSegmentProperties.python_val

    @property
    def initial_state(self) -> "IState":
        """The initial state of the segment."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_initial_state"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def final_state(self) -> "IState":
        """The final state of the segment."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_final_state"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def get_result_value(self, resultName:str) -> typing.Any:
        """Returns a result value."""
        with agmarshall.BSTR_arg(resultName) as arg_resultName, \
             agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_result_value"](arg_resultName.COM_val, byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    def run(self) -> "IState":
        """Runs the segment in individual segment mode.  See IDriverMissionControlSequence."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_run"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def results(self) -> "ICalcObjectCollection":
        """The results of the segment."""
        with agmarshall.AgInterface_out_arg() as arg_ppVACalcObjectCollection:
            agcls.evaluate_hresult(self.__dict__["_get_results"](byref(arg_ppVACalcObjectCollection.COM_val)))
            return arg_ppVACalcObjectCollection.python_val

    @property
    def exec_summary(self) -> "IDataProviderResult":
        """The segment summary report."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_exec_summary"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{46F093C1-5138-4A6F-A79C-7F4DB8E7BCB4}", IMissionControlSequenceSegment)
agcls.AgTypeNameMap["IMissionControlSequenceSegment"] = IMissionControlSequenceSegment

class IMissionControlSequenceOptions(object):
    """Properties for the MCS Options."""
    _uuid = "{81715712-591E-4553-9DC7-A1266F82E7D9}"
    _num_methods = 37
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_draw_trajectory_in2_d"] = _raise_uninitialized_error
        self.__dict__["_set_draw_trajectory_in2_d"] = _raise_uninitialized_error
        self.__dict__["_get_draw_trajectory_in3_d"] = _raise_uninitialized_error
        self.__dict__["_set_draw_trajectory_in3_d"] = _raise_uninitialized_error
        self.__dict__["_get_update_animation_time_for_all_objects"] = _raise_uninitialized_error
        self.__dict__["_set_update_animation_time_for_all_objects"] = _raise_uninitialized_error
        self.__dict__["_get_clear_dwc_graphics_before_each_run"] = _raise_uninitialized_error
        self.__dict__["_set_clear_dwc_graphics_before_each_run"] = _raise_uninitialized_error
        self.__dict__["_get_clear_additional_b_plane_points"] = _raise_uninitialized_error
        self.__dict__["_set_clear_additional_b_plane_points"] = _raise_uninitialized_error
        self.__dict__["_get_propagate_on_apply"] = _raise_uninitialized_error
        self.__dict__["_set_propagate_on_apply"] = _raise_uninitialized_error
        self.__dict__["_get_enable_trajectory_segment_colors"] = _raise_uninitialized_error
        self.__dict__["_set_enable_trajectory_segment_colors"] = _raise_uninitialized_error
        self.__dict__["_get_save_numbers_in_raw_format"] = _raise_uninitialized_error
        self.__dict__["_set_save_numbers_in_raw_format"] = _raise_uninitialized_error
        self.__dict__["_get_stopping_condition_time_tolerance"] = _raise_uninitialized_error
        self.__dict__["_set_stopping_condition_time_tolerance"] = _raise_uninitialized_error
        self.__dict__["_get_enable_segment_controls"] = _raise_uninitialized_error
        self.__dict__["_set_enable_segment_controls"] = _raise_uninitialized_error
        self.__dict__["_get_enable_segment_results"] = _raise_uninitialized_error
        self.__dict__["_set_enable_segment_results"] = _raise_uninitialized_error
        self.__dict__["_get_enable_logging"] = _raise_uninitialized_error
        self.__dict__["_set_enable_logging"] = _raise_uninitialized_error
        self.__dict__["_get_graphics_update_rate"] = _raise_uninitialized_error
        self.__dict__["_set_graphics_update_rate"] = _raise_uninitialized_error
        self.__dict__["_get_promote_controls"] = _raise_uninitialized_error
        self.__dict__["_set_promote_controls"] = _raise_uninitialized_error
        self.__dict__["_get_use_nominal_settings"] = _raise_uninitialized_error
        self.__dict__["_set_use_nominal_settings"] = _raise_uninitialized_error
        self.__dict__["_get_min_ephem_step"] = _raise_uninitialized_error
        self.__dict__["_set_min_ephem_step"] = _raise_uninitialized_error
        self.__dict__["_get_generate_ephemeris"] = _raise_uninitialized_error
        self.__dict__["_set_generate_ephemeris"] = _raise_uninitialized_error
        self.__dict__["_get_user_variables"] = _raise_uninitialized_error
        self.__dict__["_get_smart_run_mode"] = _raise_uninitialized_error
        self.__dict__["_set_smart_run_mode"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMissionControlSequenceOptions._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMissionControlSequenceOptions from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMissionControlSequenceOptions = agcom.GUID(IMissionControlSequenceOptions._uuid)
        vtable_offset_local = IMissionControlSequenceOptions._vtable_offset - 1
        self.__dict__["_get_draw_trajectory_in2_d"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceOptions, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_draw_trajectory_in2_d"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceOptions, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_draw_trajectory_in3_d"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceOptions, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_draw_trajectory_in3_d"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceOptions, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_get_update_animation_time_for_all_objects"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceOptions, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_update_animation_time_for_all_objects"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceOptions, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_get_clear_dwc_graphics_before_each_run"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceOptions, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_clear_dwc_graphics_before_each_run"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceOptions, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_get_clear_additional_b_plane_points"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceOptions, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_clear_additional_b_plane_points"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceOptions, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_get_propagate_on_apply"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceOptions, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_propagate_on_apply"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceOptions, vtable_offset_local+12, agcom.VARIANT_BOOL)
        self.__dict__["_get_enable_trajectory_segment_colors"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceOptions, vtable_offset_local+13, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable_trajectory_segment_colors"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceOptions, vtable_offset_local+14, agcom.VARIANT_BOOL)
        self.__dict__["_get_save_numbers_in_raw_format"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceOptions, vtable_offset_local+15, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_save_numbers_in_raw_format"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceOptions, vtable_offset_local+16, agcom.VARIANT_BOOL)
        self.__dict__["_get_stopping_condition_time_tolerance"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceOptions, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_stopping_condition_time_tolerance"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceOptions, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_enable_segment_controls"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceOptions, vtable_offset_local+19, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable_segment_controls"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceOptions, vtable_offset_local+20, agcom.VARIANT_BOOL)
        self.__dict__["_get_enable_segment_results"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceOptions, vtable_offset_local+21, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable_segment_results"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceOptions, vtable_offset_local+22, agcom.VARIANT_BOOL)
        self.__dict__["_get_enable_logging"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceOptions, vtable_offset_local+23, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable_logging"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceOptions, vtable_offset_local+24, agcom.VARIANT_BOOL)
        self.__dict__["_get_graphics_update_rate"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceOptions, vtable_offset_local+25, POINTER(agcom.DOUBLE))
        self.__dict__["_set_graphics_update_rate"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceOptions, vtable_offset_local+26, agcom.DOUBLE)
        self.__dict__["_get_promote_controls"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceOptions, vtable_offset_local+27, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_promote_controls"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceOptions, vtable_offset_local+28, agcom.VARIANT_BOOL)
        self.__dict__["_get_use_nominal_settings"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceOptions, vtable_offset_local+29, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_nominal_settings"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceOptions, vtable_offset_local+30, agcom.VARIANT_BOOL)
        self.__dict__["_get_min_ephem_step"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceOptions, vtable_offset_local+31, POINTER(agcom.DOUBLE))
        self.__dict__["_set_min_ephem_step"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceOptions, vtable_offset_local+32, agcom.DOUBLE)
        self.__dict__["_get_generate_ephemeris"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceOptions, vtable_offset_local+33, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_generate_ephemeris"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceOptions, vtable_offset_local+34, agcom.VARIANT_BOOL)
        self.__dict__["_get_user_variables"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceOptions, vtable_offset_local+35, POINTER(agcom.PVOID))
        self.__dict__["_get_smart_run_mode"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceOptions, vtable_offset_local+36, POINTER(agcom.LONG))
        self.__dict__["_set_smart_run_mode"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceOptions, vtable_offset_local+37, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissionControlSequenceOptions.__dict__ and type(IMissionControlSequenceOptions.__dict__[attrname]) == property:
            return IMissionControlSequenceOptions.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissionControlSequenceOptions.")
    
    @property
    def draw_trajectory_in2_d(self) -> bool:
        """If true, Astrogator will draw the trajectory in the 2D Graphics windows as the ephemeris is calculated during the current run."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_draw_trajectory_in2_d"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @draw_trajectory_in2_d.setter
    def draw_trajectory_in2_d(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_draw_trajectory_in2_d"](arg_newVal.COM_val))

    @property
    def draw_trajectory_in3_d(self) -> bool:
        """If true, Astrogator will draw the trajectory in the 3D Graphics windows as the ephemeris is calculated during the current run."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_draw_trajectory_in3_d"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @draw_trajectory_in3_d.setter
    def draw_trajectory_in3_d(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_draw_trajectory_in3_d"](arg_newVal.COM_val))

    @property
    def update_animation_time_for_all_objects(self) -> bool:
        """If true, all other objects will be animated so that they appear at the proper position for the time being computed as the trajectory is calculated."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_update_animation_time_for_all_objects"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @update_animation_time_for_all_objects.setter
    def update_animation_time_for_all_objects(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_update_animation_time_for_all_objects"](arg_newVal.COM_val))

    @property
    def clear_dwc_graphics_before_each_run(self) -> bool:
        """If true, Astrogator will automatically clear all target iteration graphics of the previous run - in all graphics windows - before the current run draws new calculations."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_clear_dwc_graphics_before_each_run"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @clear_dwc_graphics_before_each_run.setter
    def clear_dwc_graphics_before_each_run(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_clear_dwc_graphics_before_each_run"](arg_newVal.COM_val))

    @property
    def clear_additional_b_plane_points(self) -> bool:
        """If true, Astrogator will clear all additional B-Plane points from any previous run - in all graphics windows - before the current run."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_clear_additional_b_plane_points"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @clear_additional_b_plane_points.setter
    def clear_additional_b_plane_points(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_clear_additional_b_plane_points"](arg_newVal.COM_val))

    @property
    def propagate_on_apply(self) -> bool:
        """If true, Astrogator will propagate trajectories whenever you click OK or Apply on the Orbit page. If you want to close the Properties Browser for the satellite without running the MCS, make certain this option is disabled."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_propagate_on_apply"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @propagate_on_apply.setter
    def propagate_on_apply(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_propagate_on_apply"](arg_newVal.COM_val))

    @property
    def enable_trajectory_segment_colors(self) -> bool:
        """If true, trajectory segments are displayed in the 2D Graphics window in the colors selected for the respective segments; otherwise the color of the trajectory is defined by the 2D Graphics Attributes page."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable_trajectory_segment_colors"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable_trajectory_segment_colors.setter
    def enable_trajectory_segment_colors(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable_trajectory_segment_colors"](arg_newVal.COM_val))

    @property
    def save_numbers_in_raw_format(self) -> bool:
        """If true, Astrogator will store satellite information in binary format - to preserve the maximum amount of precision."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_save_numbers_in_raw_format"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @save_numbers_in_raw_format.setter
    def save_numbers_in_raw_format(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_save_numbers_in_raw_format"](arg_newVal.COM_val))

    @property
    def stopping_condition_time_tolerance(self) -> float:
        """The time tolerance, which will be applied with respect to desired trip values throughout the MCS. If this value is set to zero, time tolerance will not be applied."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stopping_condition_time_tolerance"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @stopping_condition_time_tolerance.setter
    def stopping_condition_time_tolerance(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_stopping_condition_time_tolerance"](arg_newVal.COM_val))

    @property
    def enable_segment_controls(self) -> bool:
        """If true, Astrogator will automatically add independent variables to differential correctors."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable_segment_controls"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable_segment_controls.setter
    def enable_segment_controls(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable_segment_controls"](arg_newVal.COM_val))

    @property
    def enable_segment_results(self) -> bool:
        """If true, Astrogator will automatically add dependent variables to differential correctors."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable_segment_results"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable_segment_results.setter
    def enable_segment_results(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable_segment_results"](arg_newVal.COM_val))

    @property
    def enable_logging(self) -> bool:
        """If true, target sequences can be set to produce 'run history' log files for differential corrector profiles. By default, a target sequence does not produce a log file."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable_logging"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable_logging.setter
    def enable_logging(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable_logging"](arg_newVal.COM_val))

    @property
    def graphics_update_rate(self) -> float:
        """The rate (between 0 and 1) at which to update graphics. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_graphics_update_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @graphics_update_rate.setter
    def graphics_update_rate(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_graphics_update_rate"](arg_newVal.COM_val))

    @property
    def promote_controls(self) -> bool:
        """If true, a target sequence will be able to affect controls and results within a nested target sequence in addition to its own."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_promote_controls"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @promote_controls.setter
    def promote_controls(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_promote_controls"](arg_inVal.COM_val))

    @property
    def use_nominal_settings(self) -> bool:
        """If true, components or segments that are modified by a target sequence will be restored to their nominal values as soon as the target sequence completes its run."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_nominal_settings"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_nominal_settings.setter
    def use_nominal_settings(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_nominal_settings"](arg_inVal.COM_val))

    @property
    def min_ephem_step(self) -> float:
        """The minimum step size for saving ephemeris. Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_ephem_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @min_ephem_step.setter
    def min_ephem_step(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_min_ephem_step"](arg_newVal.COM_val))

    @property
    def generate_ephemeris(self) -> bool:
        """If true, Astrogator will generate ephemeris."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_generate_ephemeris"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @generate_ephemeris.setter
    def generate_ephemeris(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_generate_ephemeris"](arg_newVal.COM_val))

    @property
    def user_variables(self) -> "IUserVariableDefinitionCollection":
        """Interface used to add/remove user variables."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_user_variables"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def smart_run_mode(self) -> "AgEVASmartRunMode":
        """Controls whether the run will attempt to only run changed segments."""
        with agmarshall.AgEnum_arg(AgEVASmartRunMode) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_smart_run_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @smart_run_mode.setter
    def smart_run_mode(self, inVal:"AgEVASmartRunMode") -> None:
        """Controls whether the run will attempt to only run changed segments."""
        with agmarshall.AgEnum_arg(AgEVASmartRunMode, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_smart_run_mode"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{81715712-591E-4553-9DC7-A1266F82E7D9}", IMissionControlSequenceOptions)
agcls.AgTypeNameMap["IMissionControlSequenceOptions"] = IMissionControlSequenceOptions

class IDriverMissionControlSequence(object):
    """Properties for the Mission Control Sequence."""
    _uuid = "{109E17B9-8E27-4B6B-A8BE-33DFF19A2C89}"
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_main_sequence"] = _raise_uninitialized_error
        self.__dict__["_get_options"] = _raise_uninitialized_error
        self.__dict__["_get_auto_sequence"] = _raise_uninitialized_error
        self.__dict__["_run_mcs"] = _raise_uninitialized_error
        self.__dict__["_begin_run"] = _raise_uninitialized_error
        self.__dict__["_end_run"] = _raise_uninitialized_error
        self.__dict__["_clear_dwc_graphics"] = _raise_uninitialized_error
        self.__dict__["_reset_all_profiles"] = _raise_uninitialized_error
        self.__dict__["_apply_all_profile_changes"] = _raise_uninitialized_error
        self.__dict__["_append_run"] = _raise_uninitialized_error
        self.__dict__["_append_run_from_time"] = _raise_uninitialized_error
        self.__dict__["_append_run_from_state"] = _raise_uninitialized_error
        self.__dict__["_run_mcs2"] = _raise_uninitialized_error
        self.__dict__["_get_calculation_graphs"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IDriverMissionControlSequence._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IDriverMissionControlSequence from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IDriverMissionControlSequence = agcom.GUID(IDriverMissionControlSequence._uuid)
        vtable_offset_local = IDriverMissionControlSequence._vtable_offset - 1
        self.__dict__["_get_main_sequence"] = IAGFUNCTYPE(pUnk, IID_IDriverMissionControlSequence, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_options"] = IAGFUNCTYPE(pUnk, IID_IDriverMissionControlSequence, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_auto_sequence"] = IAGFUNCTYPE(pUnk, IID_IDriverMissionControlSequence, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_run_mcs"] = IAGFUNCTYPE(pUnk, IID_IDriverMissionControlSequence, vtable_offset_local+4, )
        self.__dict__["_begin_run"] = IAGFUNCTYPE(pUnk, IID_IDriverMissionControlSequence, vtable_offset_local+5, )
        self.__dict__["_end_run"] = IAGFUNCTYPE(pUnk, IID_IDriverMissionControlSequence, vtable_offset_local+6, )
        self.__dict__["_clear_dwc_graphics"] = IAGFUNCTYPE(pUnk, IID_IDriverMissionControlSequence, vtable_offset_local+7, )
        self.__dict__["_reset_all_profiles"] = IAGFUNCTYPE(pUnk, IID_IDriverMissionControlSequence, vtable_offset_local+8, )
        self.__dict__["_apply_all_profile_changes"] = IAGFUNCTYPE(pUnk, IID_IDriverMissionControlSequence, vtable_offset_local+9, )
        self.__dict__["_append_run"] = IAGFUNCTYPE(pUnk, IID_IDriverMissionControlSequence, vtable_offset_local+10, )
        self.__dict__["_append_run_from_time"] = IAGFUNCTYPE(pUnk, IID_IDriverMissionControlSequence, vtable_offset_local+11, agcom.VARIANT, agcom.LONG)
        self.__dict__["_append_run_from_state"] = IAGFUNCTYPE(pUnk, IID_IDriverMissionControlSequence, vtable_offset_local+12, agcom.PVOID, agcom.LONG)
        self.__dict__["_run_mcs2"] = IAGFUNCTYPE(pUnk, IID_IDriverMissionControlSequence, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_get_calculation_graphs"] = IAGFUNCTYPE(pUnk, IID_IDriverMissionControlSequence, vtable_offset_local+14, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IDriverMissionControlSequence.__dict__ and type(IDriverMissionControlSequence.__dict__[attrname]) == property:
            return IDriverMissionControlSequence.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IDriverMissionControlSequence.")
    
    @property
    def main_sequence(self) -> "IMissionControlSequenceSegmentCollection":
        """The Mission Control Sequence."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAMCSSegmentCollection:
            agcls.evaluate_hresult(self.__dict__["_get_main_sequence"](byref(arg_ppVAMCSSegmentCollection.COM_val)))
            return arg_ppVAMCSSegmentCollection.python_val

    @property
    def options(self) -> "IMissionControlSequenceOptions":
        """The Mission Control Sequence options."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAMCSOptions:
            agcls.evaluate_hresult(self.__dict__["_get_options"](byref(arg_ppVAMCSOptions.COM_val)))
            return arg_ppVAMCSOptions.python_val

    @property
    def auto_sequence(self) -> "IAutomaticSequenceCollection":
        """The Automatic Sequences."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAAutomaticSequenceCollection:
            agcls.evaluate_hresult(self.__dict__["_get_auto_sequence"](byref(arg_ppVAAutomaticSequenceCollection.COM_val)))
            return arg_ppVAAutomaticSequenceCollection.python_val

    def run_mcs(self) -> None:
        """Runs the current MCS."""
        agcls.evaluate_hresult(self.__dict__["_run_mcs"]())

    def begin_run(self) -> None:
        """Begins an individual segment mode run."""
        agcls.evaluate_hresult(self.__dict__["_begin_run"]())

    def end_run(self) -> None:
        """Ends an individual segment mode run."""
        agcls.evaluate_hresult(self.__dict__["_end_run"]())

    def clear_dwc_graphics(self) -> None:
        """Clears the draw while calculating graphics"""
        agcls.evaluate_hresult(self.__dict__["_clear_dwc_graphics"]())

    def reset_all_profiles(self) -> None:
        """Resets all active profiles in all target sequences."""
        agcls.evaluate_hresult(self.__dict__["_reset_all_profiles"]())

    def apply_all_profile_changes(self) -> None:
        """Applies all active profile changes in all target sequences."""
        agcls.evaluate_hresult(self.__dict__["_apply_all_profile_changes"]())

    def append_run(self) -> None:
        """Append the existing ephemeris with another individual segment mode run"""
        agcls.evaluate_hresult(self.__dict__["_append_run"]())

    def append_run_from_time(self, epoch:typing.Any, clearEphemerisDirection:"AgEVAClearEphemerisDirection") -> None:
        """Append the existing ephemeris with another individual segment mode run, starting at a specified time. Ephemeris is cleared from time based on clear direction."""
        with agmarshall.VARIANT_arg(epoch) as arg_epoch, \
             agmarshall.AgEnum_arg(AgEVAClearEphemerisDirection, clearEphemerisDirection) as arg_clearEphemerisDirection:
            agcls.evaluate_hresult(self.__dict__["_append_run_from_time"](arg_epoch.COM_val, arg_clearEphemerisDirection.COM_val))

    def append_run_from_state(self, appendState:"IState", clearEphemerisDirection:"AgEVAClearEphemerisDirection") -> None:
        """Append the existing ephemeris with another individual segment mode run, starting at a specified state. Ephemeris is cleared from time based on clear direction."""
        with agmarshall.AgInterface_in_arg(appendState, IState) as arg_appendState, \
             agmarshall.AgEnum_arg(AgEVAClearEphemerisDirection, clearEphemerisDirection) as arg_clearEphemerisDirection:
            agcls.evaluate_hresult(self.__dict__["_append_run_from_state"](arg_appendState.COM_val, arg_clearEphemerisDirection.COM_val))

    def run_mcs2(self) -> "AgEVARunCode":
        """Runs the current MCS and returns an error code."""
        with agmarshall.AgEnum_arg(AgEVARunCode) as arg_pRunCode:
            agcls.evaluate_hresult(self.__dict__["_run_mcs2"](byref(arg_pRunCode.COM_val)))
            return arg_pRunCode.python_val

    @property
    def calculation_graphs(self) -> "ICalculationGraphCollection":
        """The calculation graphs."""
        with agmarshall.AgInterface_out_arg() as arg_ppVACalculationGraphCollection:
            agcls.evaluate_hresult(self.__dict__["_get_calculation_graphs"](byref(arg_ppVACalculationGraphCollection.COM_val)))
            return arg_ppVACalculationGraphCollection.python_val


agcls.AgClassCatalog.add_catalog_entry("{109E17B9-8E27-4B6B-A8BE-33DFF19A2C89}", IDriverMissionControlSequence)
agcls.AgTypeNameMap["IDriverMissionControlSequence"] = IDriverMissionControlSequence

class IElementCartesian(IElement):
    """Properties for Cartesian elements."""
    _uuid = "{63C45864-E165-498E-A88E-8104FABF50B9}"
    _num_methods = 12
    _vtable_offset = IElement._vtable_offset + IElement._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_x"] = _raise_uninitialized_error
        self.__dict__["_set_x"] = _raise_uninitialized_error
        self.__dict__["_get_y"] = _raise_uninitialized_error
        self.__dict__["_set_y"] = _raise_uninitialized_error
        self.__dict__["_get_z"] = _raise_uninitialized_error
        self.__dict__["_set_z"] = _raise_uninitialized_error
        self.__dict__["_get_vx"] = _raise_uninitialized_error
        self.__dict__["_set_vx"] = _raise_uninitialized_error
        self.__dict__["_get_vy"] = _raise_uninitialized_error
        self.__dict__["_set_vy"] = _raise_uninitialized_error
        self.__dict__["_get_vz"] = _raise_uninitialized_error
        self.__dict__["_set_vz"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IElementCartesian._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IElementCartesian from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IElement._private_init(self, pUnk)
        IID_IElementCartesian = agcom.GUID(IElementCartesian._uuid)
        vtable_offset_local = IElementCartesian._vtable_offset - 1
        self.__dict__["_get_x"] = IAGFUNCTYPE(pUnk, IID_IElementCartesian, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_x"] = IAGFUNCTYPE(pUnk, IID_IElementCartesian, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_y"] = IAGFUNCTYPE(pUnk, IID_IElementCartesian, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_y"] = IAGFUNCTYPE(pUnk, IID_IElementCartesian, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_z"] = IAGFUNCTYPE(pUnk, IID_IElementCartesian, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_z"] = IAGFUNCTYPE(pUnk, IID_IElementCartesian, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_vx"] = IAGFUNCTYPE(pUnk, IID_IElementCartesian, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_vx"] = IAGFUNCTYPE(pUnk, IID_IElementCartesian, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_vy"] = IAGFUNCTYPE(pUnk, IID_IElementCartesian, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_vy"] = IAGFUNCTYPE(pUnk, IID_IElementCartesian, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_vz"] = IAGFUNCTYPE(pUnk, IID_IElementCartesian, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_vz"] = IAGFUNCTYPE(pUnk, IID_IElementCartesian, vtable_offset_local+12, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IElementCartesian.__dict__ and type(IElementCartesian.__dict__[attrname]) == property:
            return IElementCartesian.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IElement.__setattr__(self, attrname, value)
    
    @property
    def x(self) -> float:
        """X position component. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_x"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @x.setter
    def x(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_x"](arg_newVal.COM_val))

    @property
    def y(self) -> float:
        """Y position component. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_y"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @y.setter
    def y(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_y"](arg_newVal.COM_val))

    @property
    def z(self) -> float:
        """Z position component. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_z"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @z.setter
    def z(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_z"](arg_newVal.COM_val))

    @property
    def vx(self) -> float:
        """Vx velocity component. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_vx"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @vx.setter
    def vx(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_vx"](arg_newVal.COM_val))

    @property
    def vy(self) -> float:
        """Vy velocity component. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_vy"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @vy.setter
    def vy(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_vy"](arg_newVal.COM_val))

    @property
    def vz(self) -> float:
        """Vz velocity component. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_vz"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @vz.setter
    def vz(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_vz"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{63C45864-E165-498E-A88E-8104FABF50B9}", IElementCartesian)
agcls.AgTypeNameMap["IElementCartesian"] = IElementCartesian

class IElementKeplerian(IElement):
    """Properties for Keplerian elements"""
    _uuid = "{3550E5F6-FDEF-4325-BDBA-2BA984208ECB}"
    _num_methods = 46
    _vtable_offset = IElement._vtable_offset + IElement._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_semi_major_axis"] = _raise_uninitialized_error
        self.__dict__["_set_semi_major_axis"] = _raise_uninitialized_error
        self.__dict__["_get_eccentricity"] = _raise_uninitialized_error
        self.__dict__["_set_eccentricity"] = _raise_uninitialized_error
        self.__dict__["_get_inclination"] = _raise_uninitialized_error
        self.__dict__["_set_inclination"] = _raise_uninitialized_error
        self.__dict__["_get_raan"] = _raise_uninitialized_error
        self.__dict__["_set_raan"] = _raise_uninitialized_error
        self.__dict__["_get_arg_of_periapsis"] = _raise_uninitialized_error
        self.__dict__["_set_arg_of_periapsis"] = _raise_uninitialized_error
        self.__dict__["_get_true_anomaly"] = _raise_uninitialized_error
        self.__dict__["_set_true_anomaly"] = _raise_uninitialized_error
        self.__dict__["_get_apoapsis_altitude_size"] = _raise_uninitialized_error
        self.__dict__["_set_apoapsis_altitude_size"] = _raise_uninitialized_error
        self.__dict__["_get_apoapsis_radius_size"] = _raise_uninitialized_error
        self.__dict__["_set_apoapsis_radius_size"] = _raise_uninitialized_error
        self.__dict__["_get_mean_motion"] = _raise_uninitialized_error
        self.__dict__["_set_mean_motion"] = _raise_uninitialized_error
        self.__dict__["_get_periapsis_altitude_size"] = _raise_uninitialized_error
        self.__dict__["_set_periapsis_altitude_size"] = _raise_uninitialized_error
        self.__dict__["_get_periapsis_radius_size"] = _raise_uninitialized_error
        self.__dict__["_set_periapsis_radius_size"] = _raise_uninitialized_error
        self.__dict__["_get_period"] = _raise_uninitialized_error
        self.__dict__["_set_period"] = _raise_uninitialized_error
        self.__dict__["_get_lan"] = _raise_uninitialized_error
        self.__dict__["_set_lan"] = _raise_uninitialized_error
        self.__dict__["_get_arg_of_latitude"] = _raise_uninitialized_error
        self.__dict__["_set_arg_of_latitude"] = _raise_uninitialized_error
        self.__dict__["_get_eccentric_anomaly"] = _raise_uninitialized_error
        self.__dict__["_set_eccentric_anomaly"] = _raise_uninitialized_error
        self.__dict__["_get_mean_anomaly"] = _raise_uninitialized_error
        self.__dict__["_set_mean_anomaly"] = _raise_uninitialized_error
        self.__dict__["_get_time_past_asc_node"] = _raise_uninitialized_error
        self.__dict__["_set_time_past_asc_node"] = _raise_uninitialized_error
        self.__dict__["_get_time_past_periapsis"] = _raise_uninitialized_error
        self.__dict__["_set_time_past_periapsis"] = _raise_uninitialized_error
        self.__dict__["_get_element_type"] = _raise_uninitialized_error
        self.__dict__["_set_element_type"] = _raise_uninitialized_error
        self.__dict__["_get_apoapsis_altitude_shape"] = _raise_uninitialized_error
        self.__dict__["_set_apoapsis_altitude_shape"] = _raise_uninitialized_error
        self.__dict__["_get_apoapsis_radius_shape"] = _raise_uninitialized_error
        self.__dict__["_set_apoapsis_radius_shape"] = _raise_uninitialized_error
        self.__dict__["_get_periapsis_altitude_shape"] = _raise_uninitialized_error
        self.__dict__["_set_periapsis_altitude_shape"] = _raise_uninitialized_error
        self.__dict__["_get_periapsis_radius_shape"] = _raise_uninitialized_error
        self.__dict__["_set_periapsis_radius_shape"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IElementKeplerian._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IElementKeplerian from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IElement._private_init(self, pUnk)
        IID_IElementKeplerian = agcom.GUID(IElementKeplerian._uuid)
        vtable_offset_local = IElementKeplerian._vtable_offset - 1
        self.__dict__["_get_semi_major_axis"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_semi_major_axis"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_eccentricity"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_eccentricity"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_inclination"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_set_inclination"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_get_raan"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_set_raan"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+8, agcom.VARIANT)
        self.__dict__["_get_arg_of_periapsis"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+9, POINTER(agcom.VARIANT))
        self.__dict__["_set_arg_of_periapsis"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+10, agcom.VARIANT)
        self.__dict__["_get_true_anomaly"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+11, POINTER(agcom.VARIANT))
        self.__dict__["_set_true_anomaly"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+12, agcom.VARIANT)
        self.__dict__["_get_apoapsis_altitude_size"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_apoapsis_altitude_size"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_apoapsis_radius_size"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_apoapsis_radius_size"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_mean_motion"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_mean_motion"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_periapsis_altitude_size"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_set_periapsis_altitude_size"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_get_periapsis_radius_size"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_set_periapsis_radius_size"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+22, agcom.DOUBLE)
        self.__dict__["_get_period"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+23, POINTER(agcom.DOUBLE))
        self.__dict__["_set_period"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+24, agcom.DOUBLE)
        self.__dict__["_get_lan"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+25, POINTER(agcom.VARIANT))
        self.__dict__["_set_lan"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+26, agcom.VARIANT)
        self.__dict__["_get_arg_of_latitude"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+27, POINTER(agcom.VARIANT))
        self.__dict__["_set_arg_of_latitude"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+28, agcom.VARIANT)
        self.__dict__["_get_eccentric_anomaly"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+29, POINTER(agcom.VARIANT))
        self.__dict__["_set_eccentric_anomaly"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+30, agcom.VARIANT)
        self.__dict__["_get_mean_anomaly"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+31, POINTER(agcom.VARIANT))
        self.__dict__["_set_mean_anomaly"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+32, agcom.VARIANT)
        self.__dict__["_get_time_past_asc_node"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+33, POINTER(agcom.DOUBLE))
        self.__dict__["_set_time_past_asc_node"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+34, agcom.DOUBLE)
        self.__dict__["_get_time_past_periapsis"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+35, POINTER(agcom.DOUBLE))
        self.__dict__["_set_time_past_periapsis"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+36, agcom.DOUBLE)
        self.__dict__["_get_element_type"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+37, POINTER(agcom.LONG))
        self.__dict__["_set_element_type"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+38, agcom.LONG)
        self.__dict__["_get_apoapsis_altitude_shape"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+39, POINTER(agcom.DOUBLE))
        self.__dict__["_set_apoapsis_altitude_shape"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+40, agcom.DOUBLE)
        self.__dict__["_get_apoapsis_radius_shape"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+41, POINTER(agcom.DOUBLE))
        self.__dict__["_set_apoapsis_radius_shape"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+42, agcom.DOUBLE)
        self.__dict__["_get_periapsis_altitude_shape"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+43, POINTER(agcom.DOUBLE))
        self.__dict__["_set_periapsis_altitude_shape"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+44, agcom.DOUBLE)
        self.__dict__["_get_periapsis_radius_shape"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+45, POINTER(agcom.DOUBLE))
        self.__dict__["_set_periapsis_radius_shape"] = IAGFUNCTYPE(pUnk, IID_IElementKeplerian, vtable_offset_local+46, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IElementKeplerian.__dict__ and type(IElementKeplerian.__dict__[attrname]) == property:
            return IElementKeplerian.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IElement.__setattr__(self, attrname, value)
    
    @property
    def semi_major_axis(self) -> float:
        """One-half the distance along the long axis of the elliptical orbit. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_semi_major_axis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @semi_major_axis.setter
    def semi_major_axis(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_semi_major_axis"](arg_newVal.COM_val))

    @property
    def eccentricity(self) -> float:
        """Describes the shape of the ellipse (a real number >= 0 and <1, where 0 = a circular orbit). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_eccentricity"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @eccentricity.setter
    def eccentricity(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_eccentricity"](arg_newVal.COM_val))

    @property
    def inclination(self) -> typing.Any:
        """The angle between the angular momentum vector (perpendicular to the plane of the orbit) and the inertial Z axis. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_inclination"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @inclination.setter
    def inclination(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_inclination"](arg_newVal.COM_val))

    @property
    def raan(self) -> typing.Any:
        """The angle from the inertial X axis to the ascending node measured in a right-handed sense about the inertial Z axis in the equatorial plane. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_raan"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @raan.setter
    def raan(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_raan"](arg_newVal.COM_val))

    @property
    def arg_of_periapsis(self) -> typing.Any:
        """The angle from the ascending node to the eccentricity vector (lowest point of orbit) measured in the direction of the satellite's motion and in the orbit plane. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_arg_of_periapsis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @arg_of_periapsis.setter
    def arg_of_periapsis(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_arg_of_periapsis"](arg_newVal.COM_val))

    @property
    def true_anomaly(self) -> typing.Any:
        """The angle from the eccentricity vector (points toward perigee) to the satellite position vector, measured in the direction of satellite motion and in the orbit plane. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_true_anomaly"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @true_anomaly.setter
    def true_anomaly(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_true_anomaly"](arg_newVal.COM_val))

    @property
    def apoapsis_altitude_size(self) -> float:
        """Measured from the ``surface`` of the Earth to the points of maximum and minimum radius in the orbit. For these values, the surface of the Earth is modeled as a sphere whose radius equals the equatorial radius of the Earth. Uses Distance dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_apoapsis_altitude_size"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @apoapsis_altitude_size.setter
    def apoapsis_altitude_size(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_apoapsis_altitude_size"](arg_inVal.COM_val))

    @property
    def apoapsis_radius_size(self) -> float:
        """Measured from the center of the Earth to the points of maximum and minimum radius in the orbit. Uses Distance dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_apoapsis_radius_size"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @apoapsis_radius_size.setter
    def apoapsis_radius_size(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_apoapsis_radius_size"](arg_inVal.COM_val))

    @property
    def mean_motion(self) -> float:
        """The uniform rate of the satellite in a circular orbit of the same period, typically expressed as degrees or radians per second, or as revolutions per day. Uses AngleRate dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_mean_motion"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @mean_motion.setter
    def mean_motion(self, inVal:float) -> None:
        """."""
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_mean_motion"](arg_inVal.COM_val))

    @property
    def periapsis_altitude_size(self) -> float:
        """Measured from the ``surface`` of the Earth to the points of maximum and minimum radius in the orbit. For these values, the surface of the Earth is modeled as a sphere whose radius equals the equatorial radius of the Earth. Uses Distance dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_periapsis_altitude_size"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @periapsis_altitude_size.setter
    def periapsis_altitude_size(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_periapsis_altitude_size"](arg_inVal.COM_val))

    @property
    def periapsis_radius_size(self) -> float:
        """Measured from the center of the Earth to the points of maximum and minimum radius in the orbit. Uses Distance dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_periapsis_radius_size"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @periapsis_radius_size.setter
    def periapsis_radius_size(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_periapsis_radius_size"](arg_inVal.COM_val))

    @property
    def period(self) -> float:
        """The duration of one orbit, based on assumed two-body motion. Uses Time dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_period"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @period.setter
    def period(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_period"](arg_inVal.COM_val))

    @property
    def lan(self) -> typing.Any:
        """The Earth-fixed longitude where the satellite has crossed the inertial equator (the intersection of the ground track and the inertial equator) from south to north based on an assumption of two-body motion. Uses Angle dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_lan"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @lan.setter
    def lan(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_lan"](arg_inVal.COM_val))

    @property
    def arg_of_latitude(self) -> typing.Any:
        """The sum of the True Anomaly and the Argument of Perigee. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_arg_of_latitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @arg_of_latitude.setter
    def arg_of_latitude(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_arg_of_latitude"](arg_newVal.COM_val))

    @property
    def eccentric_anomaly(self) -> typing.Any:
        """Angle measured with origin at the center of the ellipse from the direction of perigee to a point on a circumscribing circle from which a line perpendicular to the SMA intersects the position of the satellite on the ellipse. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_eccentric_anomaly"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @eccentric_anomaly.setter
    def eccentric_anomaly(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_eccentric_anomaly"](arg_newVal.COM_val))

    @property
    def mean_anomaly(self) -> typing.Any:
        """The angle from the eccentricity vector to a position vector where the satellite would be if it were always moving at its average angular rate. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_mean_anomaly"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @mean_anomaly.setter
    def mean_anomaly(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_mean_anomaly"](arg_newVal.COM_val))

    @property
    def time_past_asc_node(self) -> float:
        """The elapsed time since the last ascending node crossing based on assumed two-body motion. Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_time_past_asc_node"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @time_past_asc_node.setter
    def time_past_asc_node(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_time_past_asc_node"](arg_newVal.COM_val))

    @property
    def time_past_periapsis(self) -> float:
        """The elapsed time since the last perigee passage based on assumed two-body motion. Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_time_past_periapsis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @time_past_periapsis.setter
    def time_past_periapsis(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_time_past_periapsis"](arg_newVal.COM_val))

    @property
    def element_type(self) -> "AgEVAElement":
        """Which type of element (osculating or mean)."""
        with agmarshall.AgEnum_arg(AgEVAElement) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_element_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @element_type.setter
    def element_type(self, inVal:"AgEVAElement") -> None:
        """."""
        with agmarshall.AgEnum_arg(AgEVAElement, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_element_type"](arg_inVal.COM_val))

    @property
    def apoapsis_altitude_shape(self) -> float:
        """Describes the shape of the ellipse. Uses Distance dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_apoapsis_altitude_shape"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @apoapsis_altitude_shape.setter
    def apoapsis_altitude_shape(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_apoapsis_altitude_shape"](arg_inVal.COM_val))

    @property
    def apoapsis_radius_shape(self) -> float:
        """Describes the shape of the ellipse. Uses Distance dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_apoapsis_radius_shape"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @apoapsis_radius_shape.setter
    def apoapsis_radius_shape(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_apoapsis_radius_shape"](arg_inVal.COM_val))

    @property
    def periapsis_altitude_shape(self) -> float:
        """Describes the shape of the ellipse. Uses Distance dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_periapsis_altitude_shape"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @periapsis_altitude_shape.setter
    def periapsis_altitude_shape(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_periapsis_altitude_shape"](arg_inVal.COM_val))

    @property
    def periapsis_radius_shape(self) -> float:
        """Describes the shape of the ellipse. Uses Distance dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_periapsis_radius_shape"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @periapsis_radius_shape.setter
    def periapsis_radius_shape(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_periapsis_radius_shape"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3550E5F6-FDEF-4325-BDBA-2BA984208ECB}", IElementKeplerian)
agcls.AgTypeNameMap["IElementKeplerian"] = IElementKeplerian

class IElementDelaunay(IElement):
    """Properties for Delaunay elements"""
    _uuid = "{2D09DD04-C97C-43DB-B01A-D78DDD52FE1F}"
    _num_methods = 18
    _vtable_offset = IElement._vtable_offset + IElement._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_mean_anomaly"] = _raise_uninitialized_error
        self.__dict__["_set_mean_anomaly"] = _raise_uninitialized_error
        self.__dict__["_get_arg_of_periapsis"] = _raise_uninitialized_error
        self.__dict__["_set_arg_of_periapsis"] = _raise_uninitialized_error
        self.__dict__["_get_raan"] = _raise_uninitialized_error
        self.__dict__["_set_raan"] = _raise_uninitialized_error
        self.__dict__["_get_delaunay_l"] = _raise_uninitialized_error
        self.__dict__["_set_delaunay_l"] = _raise_uninitialized_error
        self.__dict__["_get_semi_major_axis"] = _raise_uninitialized_error
        self.__dict__["_set_semi_major_axis"] = _raise_uninitialized_error
        self.__dict__["_get_delaunay_g"] = _raise_uninitialized_error
        self.__dict__["_set_delaunay_g"] = _raise_uninitialized_error
        self.__dict__["_get_semilatus_rectum"] = _raise_uninitialized_error
        self.__dict__["_set_semilatus_rectum"] = _raise_uninitialized_error
        self.__dict__["_get_delaunay_h"] = _raise_uninitialized_error
        self.__dict__["_set_delaunay_h"] = _raise_uninitialized_error
        self.__dict__["_get_inclination"] = _raise_uninitialized_error
        self.__dict__["_set_inclination"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IElementDelaunay._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IElementDelaunay from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IElement._private_init(self, pUnk)
        IID_IElementDelaunay = agcom.GUID(IElementDelaunay._uuid)
        vtable_offset_local = IElementDelaunay._vtable_offset - 1
        self.__dict__["_get_mean_anomaly"] = IAGFUNCTYPE(pUnk, IID_IElementDelaunay, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_set_mean_anomaly"] = IAGFUNCTYPE(pUnk, IID_IElementDelaunay, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_get_arg_of_periapsis"] = IAGFUNCTYPE(pUnk, IID_IElementDelaunay, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_set_arg_of_periapsis"] = IAGFUNCTYPE(pUnk, IID_IElementDelaunay, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_get_raan"] = IAGFUNCTYPE(pUnk, IID_IElementDelaunay, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_set_raan"] = IAGFUNCTYPE(pUnk, IID_IElementDelaunay, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_get_delaunay_l"] = IAGFUNCTYPE(pUnk, IID_IElementDelaunay, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_delaunay_l"] = IAGFUNCTYPE(pUnk, IID_IElementDelaunay, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_semi_major_axis"] = IAGFUNCTYPE(pUnk, IID_IElementDelaunay, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_semi_major_axis"] = IAGFUNCTYPE(pUnk, IID_IElementDelaunay, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_delaunay_g"] = IAGFUNCTYPE(pUnk, IID_IElementDelaunay, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_delaunay_g"] = IAGFUNCTYPE(pUnk, IID_IElementDelaunay, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_semilatus_rectum"] = IAGFUNCTYPE(pUnk, IID_IElementDelaunay, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_semilatus_rectum"] = IAGFUNCTYPE(pUnk, IID_IElementDelaunay, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_delaunay_h"] = IAGFUNCTYPE(pUnk, IID_IElementDelaunay, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_delaunay_h"] = IAGFUNCTYPE(pUnk, IID_IElementDelaunay, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_inclination"] = IAGFUNCTYPE(pUnk, IID_IElementDelaunay, vtable_offset_local+17, POINTER(agcom.VARIANT))
        self.__dict__["_set_inclination"] = IAGFUNCTYPE(pUnk, IID_IElementDelaunay, vtable_offset_local+18, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IElementDelaunay.__dict__ and type(IElementDelaunay.__dict__[attrname]) == property:
            return IElementDelaunay.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IElement.__setattr__(self, attrname, value)
    
    @property
    def mean_anomaly(self) -> typing.Any:
        """The angle from the eccentricity vector to a position vector where the satellite would be if it were always moving at its average angular rate (l). Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_mean_anomaly"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @mean_anomaly.setter
    def mean_anomaly(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_mean_anomaly"](arg_newVal.COM_val))

    @property
    def arg_of_periapsis(self) -> typing.Any:
        """The angle from the ascending node to the eccentricity vector (lowest point of orbit) measured in the direction of the satellite's motion and in the orbit plane (g). Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_arg_of_periapsis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @arg_of_periapsis.setter
    def arg_of_periapsis(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_arg_of_periapsis"](arg_newVal.COM_val))

    @property
    def raan(self) -> typing.Any:
        """The angle from the inertial X axis to the ascending node measured in a right-handed sense about the inertial Z axis in the equatorial plane (h). Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_raan"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @raan.setter
    def raan(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_raan"](arg_newVal.COM_val))

    @property
    def delaunay_l(self) -> float:
        """Related to the two-body orbital energy. Defined as sqrt(GM * a).   Uses AreaRate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_delaunay_l"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @delaunay_l.setter
    def delaunay_l(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_delaunay_l"](arg_newVal.COM_val))

    @property
    def semi_major_axis(self) -> float:
        """One-half the distance along the long axis of the elliptical orbit. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_semi_major_axis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @semi_major_axis.setter
    def semi_major_axis(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_semi_major_axis"](arg_newVal.COM_val))

    @property
    def delaunay_g(self) -> float:
        """The magnitude of the orbital angular momentum. Defined as sqrt(GM * p). Uses AreaRate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_delaunay_g"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @delaunay_g.setter
    def delaunay_g(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_delaunay_g"](arg_newVal.COM_val))

    @property
    def semilatus_rectum(self) -> float:
        """Semi-latus Rectum. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_semilatus_rectum"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @semilatus_rectum.setter
    def semilatus_rectum(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_semilatus_rectum"](arg_newVal.COM_val))

    @property
    def delaunay_h(self) -> float:
        """The Z component of the orbital angular momentum. Defined as G cos(inc).  Uses AreaRate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_delaunay_h"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @delaunay_h.setter
    def delaunay_h(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_delaunay_h"](arg_newVal.COM_val))

    @property
    def inclination(self) -> typing.Any:
        """The angle between the angular momentum vector (perpendicular to the plane of the orbit) and the inertial Z axis. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_inclination"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @inclination.setter
    def inclination(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_inclination"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2D09DD04-C97C-43DB-B01A-D78DDD52FE1F}", IElementDelaunay)
agcls.AgTypeNameMap["IElementDelaunay"] = IElementDelaunay

class IElementEquinoctial(IElement):
    """Properties for Equinoctial elements"""
    _uuid = "{90FA8C03-AA29-446A-A23A-085B71502DAA}"
    _num_methods = 16
    _vtable_offset = IElement._vtable_offset + IElement._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_semi_major_axis"] = _raise_uninitialized_error
        self.__dict__["_set_semi_major_axis"] = _raise_uninitialized_error
        self.__dict__["_get_mean_motion"] = _raise_uninitialized_error
        self.__dict__["_set_mean_motion"] = _raise_uninitialized_error
        self.__dict__["_get_h"] = _raise_uninitialized_error
        self.__dict__["_set_h"] = _raise_uninitialized_error
        self.__dict__["_get_k"] = _raise_uninitialized_error
        self.__dict__["_set_k"] = _raise_uninitialized_error
        self.__dict__["_get_p"] = _raise_uninitialized_error
        self.__dict__["_set_p"] = _raise_uninitialized_error
        self.__dict__["_get_q"] = _raise_uninitialized_error
        self.__dict__["_set_q"] = _raise_uninitialized_error
        self.__dict__["_get_mean_longitude"] = _raise_uninitialized_error
        self.__dict__["_set_mean_longitude"] = _raise_uninitialized_error
        self.__dict__["_get_formulation"] = _raise_uninitialized_error
        self.__dict__["_set_formulation"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IElementEquinoctial._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IElementEquinoctial from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IElement._private_init(self, pUnk)
        IID_IElementEquinoctial = agcom.GUID(IElementEquinoctial._uuid)
        vtable_offset_local = IElementEquinoctial._vtable_offset - 1
        self.__dict__["_get_semi_major_axis"] = IAGFUNCTYPE(pUnk, IID_IElementEquinoctial, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_semi_major_axis"] = IAGFUNCTYPE(pUnk, IID_IElementEquinoctial, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_mean_motion"] = IAGFUNCTYPE(pUnk, IID_IElementEquinoctial, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_mean_motion"] = IAGFUNCTYPE(pUnk, IID_IElementEquinoctial, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_h"] = IAGFUNCTYPE(pUnk, IID_IElementEquinoctial, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_h"] = IAGFUNCTYPE(pUnk, IID_IElementEquinoctial, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_k"] = IAGFUNCTYPE(pUnk, IID_IElementEquinoctial, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_k"] = IAGFUNCTYPE(pUnk, IID_IElementEquinoctial, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_p"] = IAGFUNCTYPE(pUnk, IID_IElementEquinoctial, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_p"] = IAGFUNCTYPE(pUnk, IID_IElementEquinoctial, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_q"] = IAGFUNCTYPE(pUnk, IID_IElementEquinoctial, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_q"] = IAGFUNCTYPE(pUnk, IID_IElementEquinoctial, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_mean_longitude"] = IAGFUNCTYPE(pUnk, IID_IElementEquinoctial, vtable_offset_local+13, POINTER(agcom.VARIANT))
        self.__dict__["_set_mean_longitude"] = IAGFUNCTYPE(pUnk, IID_IElementEquinoctial, vtable_offset_local+14, agcom.VARIANT)
        self.__dict__["_get_formulation"] = IAGFUNCTYPE(pUnk, IID_IElementEquinoctial, vtable_offset_local+15, POINTER(agcom.LONG))
        self.__dict__["_set_formulation"] = IAGFUNCTYPE(pUnk, IID_IElementEquinoctial, vtable_offset_local+16, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IElementEquinoctial.__dict__ and type(IElementEquinoctial.__dict__[attrname]) == property:
            return IElementEquinoctial.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IElement.__setattr__(self, attrname, value)
    
    @property
    def semi_major_axis(self) -> float:
        """Half the length of the major axis of the orbital ellipse. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_semi_major_axis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @semi_major_axis.setter
    def semi_major_axis(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_semi_major_axis"](arg_newVal.COM_val))

    @property
    def mean_motion(self) -> float:
        """The average angular rate of the satellite based on 2 body motion. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_mean_motion"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @mean_motion.setter
    def mean_motion(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_mean_motion"](arg_newVal.COM_val))

    @property
    def h(self) -> float:
        """h/k collectively describe the shape of the satellite's orbit and the position of perigee. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_h"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @h.setter
    def h(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_h"](arg_newVal.COM_val))

    @property
    def k(self) -> float:
        """h/k collectively describe the shape of the satellite's orbit and the position of perigee. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_k"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @k.setter
    def k(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_k"](arg_newVal.COM_val))

    @property
    def p(self) -> float:
        """p/q collectively describe the orientation of the satellite's orbit plane. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_p"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @p.setter
    def p(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_p"](arg_newVal.COM_val))

    @property
    def q(self) -> float:
        """p/q collectively describe the orientation of the satellite's orbit plane. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_q"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @q.setter
    def q(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_q"](arg_newVal.COM_val))

    @property
    def mean_longitude(self) -> typing.Any:
        """Specifies a satellite's position within its orbit at epoch and equals the sum of the classical Right Ascension of the Ascending Node, Argument of Perigee, and Mean Anomaly. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_mean_longitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @mean_longitude.setter
    def mean_longitude(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_mean_longitude"](arg_newVal.COM_val))

    @property
    def formulation(self) -> "AgEVAFormulation":
        """Retrograde, which has its singularity at an inclination of 0 deg. Posigrade, which has its singularity at an inclination of 180 deg."""
        with agmarshall.AgEnum_arg(AgEVAFormulation) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_formulation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @formulation.setter
    def formulation(self, inVal:"AgEVAFormulation") -> None:
        with agmarshall.AgEnum_arg(AgEVAFormulation, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_formulation"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{90FA8C03-AA29-446A-A23A-085B71502DAA}", IElementEquinoctial)
agcls.AgTypeNameMap["IElementEquinoctial"] = IElementEquinoctial

class IElementMixedSpherical(IElement):
    """Properties for Mixed Spherical elements"""
    _uuid = "{8A1D2A11-5A9D-49D8-9CE6-6435B1173292}"
    _num_methods = 14
    _vtable_offset = IElement._vtable_offset + IElement._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_longitude"] = _raise_uninitialized_error
        self.__dict__["_set_longitude"] = _raise_uninitialized_error
        self.__dict__["_get_latitude"] = _raise_uninitialized_error
        self.__dict__["_set_latitude"] = _raise_uninitialized_error
        self.__dict__["_get_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_horizontal_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_set_horizontal_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_get_velocity_azimuth"] = _raise_uninitialized_error
        self.__dict__["_set_velocity_azimuth"] = _raise_uninitialized_error
        self.__dict__["_get_velocity_magnitude"] = _raise_uninitialized_error
        self.__dict__["_set_velocity_magnitude"] = _raise_uninitialized_error
        self.__dict__["_get_vertical_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_set_vertical_flight_path_angle"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IElementMixedSpherical._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IElementMixedSpherical from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IElement._private_init(self, pUnk)
        IID_IElementMixedSpherical = agcom.GUID(IElementMixedSpherical._uuid)
        vtable_offset_local = IElementMixedSpherical._vtable_offset - 1
        self.__dict__["_get_longitude"] = IAGFUNCTYPE(pUnk, IID_IElementMixedSpherical, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_set_longitude"] = IAGFUNCTYPE(pUnk, IID_IElementMixedSpherical, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_get_latitude"] = IAGFUNCTYPE(pUnk, IID_IElementMixedSpherical, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_set_latitude"] = IAGFUNCTYPE(pUnk, IID_IElementMixedSpherical, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_get_altitude"] = IAGFUNCTYPE(pUnk, IID_IElementMixedSpherical, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude"] = IAGFUNCTYPE(pUnk, IID_IElementMixedSpherical, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_horizontal_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IElementMixedSpherical, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_set_horizontal_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IElementMixedSpherical, vtable_offset_local+8, agcom.VARIANT)
        self.__dict__["_get_velocity_azimuth"] = IAGFUNCTYPE(pUnk, IID_IElementMixedSpherical, vtable_offset_local+9, POINTER(agcom.VARIANT))
        self.__dict__["_set_velocity_azimuth"] = IAGFUNCTYPE(pUnk, IID_IElementMixedSpherical, vtable_offset_local+10, agcom.VARIANT)
        self.__dict__["_get_velocity_magnitude"] = IAGFUNCTYPE(pUnk, IID_IElementMixedSpherical, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_velocity_magnitude"] = IAGFUNCTYPE(pUnk, IID_IElementMixedSpherical, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_vertical_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IElementMixedSpherical, vtable_offset_local+13, POINTER(agcom.VARIANT))
        self.__dict__["_set_vertical_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IElementMixedSpherical, vtable_offset_local+14, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IElementMixedSpherical.__dict__ and type(IElementMixedSpherical.__dict__[attrname]) == property:
            return IElementMixedSpherical.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IElement.__setattr__(self, attrname, value)
    
    @property
    def longitude(self) -> typing.Any:
        """Measured from -180.0 deg to +360.0 deg. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_longitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @longitude.setter
    def longitude(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_longitude"](arg_newVal.COM_val))

    @property
    def latitude(self) -> typing.Any:
        """Measured from -90.0 deg to +90.0 deg. The geodetic latitude of a point is the angle between (1) the normal to the reference ellipsoid that passes through the satellite position and (2) the equatorial plane. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_latitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @latitude.setter
    def latitude(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_latitude"](arg_newVal.COM_val))

    @property
    def altitude(self) -> float:
        """The object's position above or below the reference ellipsoid. Altitude is measured along a normal to the surface of the reference ellipsoid. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude.setter
    def altitude(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude"](arg_newVal.COM_val))

    @property
    def horizontal_flight_path_angle(self) -> typing.Any:
        """Horizontal (Hor FPA) or vertical (Ver FPA) flight path angle. The angle between the inertial velocity vector and the radius vector (vertical) or the complement of this angle (horizontal). Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_horizontal_flight_path_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @horizontal_flight_path_angle.setter
    def horizontal_flight_path_angle(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_horizontal_flight_path_angle"](arg_newVal.COM_val))

    @property
    def velocity_azimuth(self) -> typing.Any:
        """The angle in the satellite local horizontal plane between the projection of the inertial velocity vector onto this plane and the local north direction measured as positive in the clockwise direction. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_velocity_azimuth"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @velocity_azimuth.setter
    def velocity_azimuth(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_velocity_azimuth"](arg_newVal.COM_val))

    @property
    def velocity_magnitude(self) -> float:
        """The angle in the satellite local horizontal plane between the projection of the inertial velocity vector onto this plane and the local north direction measured as positive in the clockwise direction. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_velocity_magnitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @velocity_magnitude.setter
    def velocity_magnitude(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_velocity_magnitude"](arg_newVal.COM_val))

    @property
    def vertical_flight_path_angle(self) -> typing.Any:
        """Horizontal (Hor FPA) or vertical (Ver FPA) flight path angle. The angle between the inertial velocity vector and the radius vector (vertical) or the complement of this angle (horizontal). Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_vertical_flight_path_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @vertical_flight_path_angle.setter
    def vertical_flight_path_angle(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_vertical_flight_path_angle"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{8A1D2A11-5A9D-49D8-9CE6-6435B1173292}", IElementMixedSpherical)
agcls.AgTypeNameMap["IElementMixedSpherical"] = IElementMixedSpherical

class IElementSpherical(IElement):
    """Properties for Spherical elements"""
    _uuid = "{C2B6D754-C55A-4FE1-88AE-976A54FD0C75}"
    _num_methods = 14
    _vtable_offset = IElement._vtable_offset + IElement._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_right_ascension"] = _raise_uninitialized_error
        self.__dict__["_set_right_ascension"] = _raise_uninitialized_error
        self.__dict__["_get_declination"] = _raise_uninitialized_error
        self.__dict__["_set_declination"] = _raise_uninitialized_error
        self.__dict__["_get_radius_magnitude"] = _raise_uninitialized_error
        self.__dict__["_set_radius_magnitude"] = _raise_uninitialized_error
        self.__dict__["_get_horizontal_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_set_horizontal_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_get_velocity_azimuth"] = _raise_uninitialized_error
        self.__dict__["_set_velocity_azimuth"] = _raise_uninitialized_error
        self.__dict__["_get_velocity_magnitude"] = _raise_uninitialized_error
        self.__dict__["_set_velocity_magnitude"] = _raise_uninitialized_error
        self.__dict__["_get_vertical_flight_path_angle"] = _raise_uninitialized_error
        self.__dict__["_set_vertical_flight_path_angle"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IElementSpherical._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IElementSpherical from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IElement._private_init(self, pUnk)
        IID_IElementSpherical = agcom.GUID(IElementSpherical._uuid)
        vtable_offset_local = IElementSpherical._vtable_offset - 1
        self.__dict__["_get_right_ascension"] = IAGFUNCTYPE(pUnk, IID_IElementSpherical, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_set_right_ascension"] = IAGFUNCTYPE(pUnk, IID_IElementSpherical, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_get_declination"] = IAGFUNCTYPE(pUnk, IID_IElementSpherical, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_set_declination"] = IAGFUNCTYPE(pUnk, IID_IElementSpherical, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_get_radius_magnitude"] = IAGFUNCTYPE(pUnk, IID_IElementSpherical, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_radius_magnitude"] = IAGFUNCTYPE(pUnk, IID_IElementSpherical, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_horizontal_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IElementSpherical, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_set_horizontal_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IElementSpherical, vtable_offset_local+8, agcom.VARIANT)
        self.__dict__["_get_velocity_azimuth"] = IAGFUNCTYPE(pUnk, IID_IElementSpherical, vtable_offset_local+9, POINTER(agcom.VARIANT))
        self.__dict__["_set_velocity_azimuth"] = IAGFUNCTYPE(pUnk, IID_IElementSpherical, vtable_offset_local+10, agcom.VARIANT)
        self.__dict__["_get_velocity_magnitude"] = IAGFUNCTYPE(pUnk, IID_IElementSpherical, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_velocity_magnitude"] = IAGFUNCTYPE(pUnk, IID_IElementSpherical, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_vertical_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IElementSpherical, vtable_offset_local+13, POINTER(agcom.VARIANT))
        self.__dict__["_set_vertical_flight_path_angle"] = IAGFUNCTYPE(pUnk, IID_IElementSpherical, vtable_offset_local+14, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IElementSpherical.__dict__ and type(IElementSpherical.__dict__[attrname]) == property:
            return IElementSpherical.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IElement.__setattr__(self, attrname, value)
    
    @property
    def right_ascension(self) -> typing.Any:
        """Defined as the angle from the X axis to the projection of the satellite position vector in the equatorial plane measured as positive in the direction of the Y axis. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_right_ascension"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @right_ascension.setter
    def right_ascension(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_right_ascension"](arg_newVal.COM_val))

    @property
    def declination(self) -> typing.Any:
        """Defined as the angle between the satellite position vector and the inertial equatorial plane measured as positive toward the positive inertial Z axis. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_declination"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @declination.setter
    def declination(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_declination"](arg_newVal.COM_val))

    @property
    def radius_magnitude(self) -> float:
        """The magnitude of the satellite position vector. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_radius_magnitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @radius_magnitude.setter
    def radius_magnitude(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_radius_magnitude"](arg_newVal.COM_val))

    @property
    def horizontal_flight_path_angle(self) -> typing.Any:
        """Horizontal (Hor FPA) or vertical (Ver FPA) flight path angle. The angle between the velocity vector and the radius vector (vertical) or the complement of this angle (horizontal). Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_horizontal_flight_path_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @horizontal_flight_path_angle.setter
    def horizontal_flight_path_angle(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_horizontal_flight_path_angle"](arg_newVal.COM_val))

    @property
    def velocity_azimuth(self) -> typing.Any:
        """The angle in the satellite local horizontal plane between the projection of the velocity vector onto this plane and the local north direction measured as positive in the clockwise direction. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_velocity_azimuth"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @velocity_azimuth.setter
    def velocity_azimuth(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_velocity_azimuth"](arg_newVal.COM_val))

    @property
    def velocity_magnitude(self) -> float:
        """The magnitude of the velocity vector. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_velocity_magnitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @velocity_magnitude.setter
    def velocity_magnitude(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_velocity_magnitude"](arg_newVal.COM_val))

    @property
    def vertical_flight_path_angle(self) -> typing.Any:
        """Horizontal (Hor FPA) or vertical (Ver FPA) flight path angle. The angle between the velocity vector and the radius vector (vertical) or the complement of this angle (horizontal). Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_vertical_flight_path_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @vertical_flight_path_angle.setter
    def vertical_flight_path_angle(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_vertical_flight_path_angle"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{C2B6D754-C55A-4FE1-88AE-976A54FD0C75}", IElementSpherical)
agcls.AgTypeNameMap["IElementSpherical"] = IElementSpherical

class IElementTargetVectorIncomingAsymptote(IElement):
    """Properties for Target Vector Incoming Asymptote elements."""
    _uuid = "{B7EA61B2-6910-43E7-B4F7-CBA647EC19A3}"
    _num_methods = 12
    _vtable_offset = IElement._vtable_offset + IElement._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_radius_of_periapsis"] = _raise_uninitialized_error
        self.__dict__["_set_radius_of_periapsis"] = _raise_uninitialized_error
        self.__dict__["_get_c3_energy"] = _raise_uninitialized_error
        self.__dict__["_set_c3_energy"] = _raise_uninitialized_error
        self.__dict__["_get_ra_incoming_asymptote"] = _raise_uninitialized_error
        self.__dict__["_set_ra_incoming_asymptote"] = _raise_uninitialized_error
        self.__dict__["_get_declination_incoming_asymptote"] = _raise_uninitialized_error
        self.__dict__["_set_declination_incoming_asymptote"] = _raise_uninitialized_error
        self.__dict__["_get_velocity_azimuth_periapsis"] = _raise_uninitialized_error
        self.__dict__["_set_velocity_azimuth_periapsis"] = _raise_uninitialized_error
        self.__dict__["_get_true_anomaly"] = _raise_uninitialized_error
        self.__dict__["_set_true_anomaly"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IElementTargetVectorIncomingAsymptote._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IElementTargetVectorIncomingAsymptote from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IElement._private_init(self, pUnk)
        IID_IElementTargetVectorIncomingAsymptote = agcom.GUID(IElementTargetVectorIncomingAsymptote._uuid)
        vtable_offset_local = IElementTargetVectorIncomingAsymptote._vtable_offset - 1
        self.__dict__["_get_radius_of_periapsis"] = IAGFUNCTYPE(pUnk, IID_IElementTargetVectorIncomingAsymptote, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_radius_of_periapsis"] = IAGFUNCTYPE(pUnk, IID_IElementTargetVectorIncomingAsymptote, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_c3_energy"] = IAGFUNCTYPE(pUnk, IID_IElementTargetVectorIncomingAsymptote, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_c3_energy"] = IAGFUNCTYPE(pUnk, IID_IElementTargetVectorIncomingAsymptote, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_ra_incoming_asymptote"] = IAGFUNCTYPE(pUnk, IID_IElementTargetVectorIncomingAsymptote, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_set_ra_incoming_asymptote"] = IAGFUNCTYPE(pUnk, IID_IElementTargetVectorIncomingAsymptote, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_get_declination_incoming_asymptote"] = IAGFUNCTYPE(pUnk, IID_IElementTargetVectorIncomingAsymptote, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_set_declination_incoming_asymptote"] = IAGFUNCTYPE(pUnk, IID_IElementTargetVectorIncomingAsymptote, vtable_offset_local+8, agcom.VARIANT)
        self.__dict__["_get_velocity_azimuth_periapsis"] = IAGFUNCTYPE(pUnk, IID_IElementTargetVectorIncomingAsymptote, vtable_offset_local+9, POINTER(agcom.VARIANT))
        self.__dict__["_set_velocity_azimuth_periapsis"] = IAGFUNCTYPE(pUnk, IID_IElementTargetVectorIncomingAsymptote, vtable_offset_local+10, agcom.VARIANT)
        self.__dict__["_get_true_anomaly"] = IAGFUNCTYPE(pUnk, IID_IElementTargetVectorIncomingAsymptote, vtable_offset_local+11, POINTER(agcom.VARIANT))
        self.__dict__["_set_true_anomaly"] = IAGFUNCTYPE(pUnk, IID_IElementTargetVectorIncomingAsymptote, vtable_offset_local+12, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IElementTargetVectorIncomingAsymptote.__dict__ and type(IElementTargetVectorIncomingAsymptote.__dict__[attrname]) == property:
            return IElementTargetVectorIncomingAsymptote.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IElement.__setattr__(self, attrname, value)
    
    @property
    def radius_of_periapsis(self) -> float:
        """Radius of Periapsis. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_radius_of_periapsis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @radius_of_periapsis.setter
    def radius_of_periapsis(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_radius_of_periapsis"](arg_newVal.COM_val))

    @property
    def c3_energy(self) -> float:
        """C3Energy (Rate squared)."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_c3_energy"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @c3_energy.setter
    def c3_energy(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_c3_energy"](arg_newVal.COM_val))

    @property
    def ra_incoming_asymptote(self) -> typing.Any:
        """Right Ascension of Incoming Asymptote. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_ra_incoming_asymptote"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ra_incoming_asymptote.setter
    def ra_incoming_asymptote(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_ra_incoming_asymptote"](arg_newVal.COM_val))

    @property
    def declination_incoming_asymptote(self) -> typing.Any:
        """Declination of Incoming Asymptote. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_declination_incoming_asymptote"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @declination_incoming_asymptote.setter
    def declination_incoming_asymptote(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_declination_incoming_asymptote"](arg_newVal.COM_val))

    @property
    def velocity_azimuth_periapsis(self) -> typing.Any:
        """Velocity Azimuth at Periapsis. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_velocity_azimuth_periapsis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @velocity_azimuth_periapsis.setter
    def velocity_azimuth_periapsis(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_velocity_azimuth_periapsis"](arg_newVal.COM_val))

    @property
    def true_anomaly(self) -> typing.Any:
        """True Anomaly. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_true_anomaly"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @true_anomaly.setter
    def true_anomaly(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_true_anomaly"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{B7EA61B2-6910-43E7-B4F7-CBA647EC19A3}", IElementTargetVectorIncomingAsymptote)
agcls.AgTypeNameMap["IElementTargetVectorIncomingAsymptote"] = IElementTargetVectorIncomingAsymptote

class IElementTargetVectorOutgoingAsymptote(IElement):
    """Properties for Target Vector Outgoing Asymptote elements."""
    _uuid = "{BE7E87B6-AC1F-4A19-A1C8-15272B707777}"
    _num_methods = 12
    _vtable_offset = IElement._vtable_offset + IElement._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_radius_of_periapsis"] = _raise_uninitialized_error
        self.__dict__["_set_radius_of_periapsis"] = _raise_uninitialized_error
        self.__dict__["_get_c3_energy"] = _raise_uninitialized_error
        self.__dict__["_set_c3_energy"] = _raise_uninitialized_error
        self.__dict__["_get_ra_outgoing_asymptote"] = _raise_uninitialized_error
        self.__dict__["_set_ra_outgoing_asymptote"] = _raise_uninitialized_error
        self.__dict__["_get_declination_outgoing_asymptote"] = _raise_uninitialized_error
        self.__dict__["_set_declination_outgoing_asymptote"] = _raise_uninitialized_error
        self.__dict__["_get_velocity_azimuth_periapsis"] = _raise_uninitialized_error
        self.__dict__["_set_velocity_azimuth_periapsis"] = _raise_uninitialized_error
        self.__dict__["_get_true_anomaly"] = _raise_uninitialized_error
        self.__dict__["_set_true_anomaly"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IElementTargetVectorOutgoingAsymptote._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IElementTargetVectorOutgoingAsymptote from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IElement._private_init(self, pUnk)
        IID_IElementTargetVectorOutgoingAsymptote = agcom.GUID(IElementTargetVectorOutgoingAsymptote._uuid)
        vtable_offset_local = IElementTargetVectorOutgoingAsymptote._vtable_offset - 1
        self.__dict__["_get_radius_of_periapsis"] = IAGFUNCTYPE(pUnk, IID_IElementTargetVectorOutgoingAsymptote, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_radius_of_periapsis"] = IAGFUNCTYPE(pUnk, IID_IElementTargetVectorOutgoingAsymptote, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_c3_energy"] = IAGFUNCTYPE(pUnk, IID_IElementTargetVectorOutgoingAsymptote, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_c3_energy"] = IAGFUNCTYPE(pUnk, IID_IElementTargetVectorOutgoingAsymptote, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_ra_outgoing_asymptote"] = IAGFUNCTYPE(pUnk, IID_IElementTargetVectorOutgoingAsymptote, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_set_ra_outgoing_asymptote"] = IAGFUNCTYPE(pUnk, IID_IElementTargetVectorOutgoingAsymptote, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_get_declination_outgoing_asymptote"] = IAGFUNCTYPE(pUnk, IID_IElementTargetVectorOutgoingAsymptote, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_set_declination_outgoing_asymptote"] = IAGFUNCTYPE(pUnk, IID_IElementTargetVectorOutgoingAsymptote, vtable_offset_local+8, agcom.VARIANT)
        self.__dict__["_get_velocity_azimuth_periapsis"] = IAGFUNCTYPE(pUnk, IID_IElementTargetVectorOutgoingAsymptote, vtable_offset_local+9, POINTER(agcom.VARIANT))
        self.__dict__["_set_velocity_azimuth_periapsis"] = IAGFUNCTYPE(pUnk, IID_IElementTargetVectorOutgoingAsymptote, vtable_offset_local+10, agcom.VARIANT)
        self.__dict__["_get_true_anomaly"] = IAGFUNCTYPE(pUnk, IID_IElementTargetVectorOutgoingAsymptote, vtable_offset_local+11, POINTER(agcom.VARIANT))
        self.__dict__["_set_true_anomaly"] = IAGFUNCTYPE(pUnk, IID_IElementTargetVectorOutgoingAsymptote, vtable_offset_local+12, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IElementTargetVectorOutgoingAsymptote.__dict__ and type(IElementTargetVectorOutgoingAsymptote.__dict__[attrname]) == property:
            return IElementTargetVectorOutgoingAsymptote.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IElement.__setattr__(self, attrname, value)
    
    @property
    def radius_of_periapsis(self) -> float:
        """Radius of Periapsis. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_radius_of_periapsis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @radius_of_periapsis.setter
    def radius_of_periapsis(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_radius_of_periapsis"](arg_newVal.COM_val))

    @property
    def c3_energy(self) -> float:
        """C3Energy (Rate Squared)."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_c3_energy"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @c3_energy.setter
    def c3_energy(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_c3_energy"](arg_newVal.COM_val))

    @property
    def ra_outgoing_asymptote(self) -> typing.Any:
        """Right Ascension of Incoming Asymptote. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_ra_outgoing_asymptote"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ra_outgoing_asymptote.setter
    def ra_outgoing_asymptote(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_ra_outgoing_asymptote"](arg_newVal.COM_val))

    @property
    def declination_outgoing_asymptote(self) -> typing.Any:
        """Declination of Incoming Asymptote. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_declination_outgoing_asymptote"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @declination_outgoing_asymptote.setter
    def declination_outgoing_asymptote(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_declination_outgoing_asymptote"](arg_newVal.COM_val))

    @property
    def velocity_azimuth_periapsis(self) -> typing.Any:
        """Velocity Azimuth at Periapsis. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_velocity_azimuth_periapsis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @velocity_azimuth_periapsis.setter
    def velocity_azimuth_periapsis(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_velocity_azimuth_periapsis"](arg_newVal.COM_val))

    @property
    def true_anomaly(self) -> typing.Any:
        """True Anomaly. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_true_anomaly"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @true_anomaly.setter
    def true_anomaly(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_true_anomaly"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{BE7E87B6-AC1F-4A19-A1C8-15272B707777}", IElementTargetVectorOutgoingAsymptote)
agcls.AgTypeNameMap["IElementTargetVectorOutgoingAsymptote"] = IElementTargetVectorOutgoingAsymptote

class IElementGeodetic(IElement):
    """Properties for Geodetic elements"""
    _uuid = "{091F376E-6C32-4567-BE00-D1CE1857B50F}"
    _num_methods = 16
    _vtable_offset = IElement._vtable_offset + IElement._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_latitude"] = _raise_uninitialized_error
        self.__dict__["_set_latitude"] = _raise_uninitialized_error
        self.__dict__["_get_longitude"] = _raise_uninitialized_error
        self.__dict__["_set_longitude"] = _raise_uninitialized_error
        self.__dict__["_get_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_radius_magnitude"] = _raise_uninitialized_error
        self.__dict__["_set_radius_magnitude"] = _raise_uninitialized_error
        self.__dict__["_get_latitude_rate"] = _raise_uninitialized_error
        self.__dict__["_set_latitude_rate"] = _raise_uninitialized_error
        self.__dict__["_get_longitude_rate"] = _raise_uninitialized_error
        self.__dict__["_set_longitude_rate"] = _raise_uninitialized_error
        self.__dict__["_get_altitude_rate"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_rate"] = _raise_uninitialized_error
        self.__dict__["_get_radius_rate"] = _raise_uninitialized_error
        self.__dict__["_set_radius_rate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IElementGeodetic._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IElementGeodetic from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IElement._private_init(self, pUnk)
        IID_IElementGeodetic = agcom.GUID(IElementGeodetic._uuid)
        vtable_offset_local = IElementGeodetic._vtable_offset - 1
        self.__dict__["_get_latitude"] = IAGFUNCTYPE(pUnk, IID_IElementGeodetic, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_set_latitude"] = IAGFUNCTYPE(pUnk, IID_IElementGeodetic, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_get_longitude"] = IAGFUNCTYPE(pUnk, IID_IElementGeodetic, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_set_longitude"] = IAGFUNCTYPE(pUnk, IID_IElementGeodetic, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_get_altitude"] = IAGFUNCTYPE(pUnk, IID_IElementGeodetic, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude"] = IAGFUNCTYPE(pUnk, IID_IElementGeodetic, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_radius_magnitude"] = IAGFUNCTYPE(pUnk, IID_IElementGeodetic, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_radius_magnitude"] = IAGFUNCTYPE(pUnk, IID_IElementGeodetic, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_latitude_rate"] = IAGFUNCTYPE(pUnk, IID_IElementGeodetic, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_latitude_rate"] = IAGFUNCTYPE(pUnk, IID_IElementGeodetic, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_longitude_rate"] = IAGFUNCTYPE(pUnk, IID_IElementGeodetic, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_longitude_rate"] = IAGFUNCTYPE(pUnk, IID_IElementGeodetic, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_altitude_rate"] = IAGFUNCTYPE(pUnk, IID_IElementGeodetic, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude_rate"] = IAGFUNCTYPE(pUnk, IID_IElementGeodetic, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_radius_rate"] = IAGFUNCTYPE(pUnk, IID_IElementGeodetic, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_radius_rate"] = IAGFUNCTYPE(pUnk, IID_IElementGeodetic, vtable_offset_local+16, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IElementGeodetic.__dict__ and type(IElementGeodetic.__dict__[attrname]) == property:
            return IElementGeodetic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IElement.__setattr__(self, attrname, value)
    
    @property
    def latitude(self) -> typing.Any:
        """Measured in degrees from -90.0 deg to +90.0 deg. The geodetic latitude of a point is the angle between the normal to the reference ellipsoid and the equatorial plane. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_latitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @latitude.setter
    def latitude(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_latitude"](arg_newVal.COM_val))

    @property
    def longitude(self) -> typing.Any:
        """Measured in degrees from -360.0 deg to +360.0 deg. The longitude of a point is the angle between the projection of the position vector in the equatorial plane and the prime meridian. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_longitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @longitude.setter
    def longitude(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_longitude"](arg_newVal.COM_val))

    @property
    def altitude(self) -> float:
        """Measured along an outward normal to the surface of the ellipsoid. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude.setter
    def altitude(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude"](arg_newVal.COM_val))

    @property
    def radius_magnitude(self) -> float:
        """Measured from the center of the Earth. Specified as distance above or below the reference ellipsoid. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_radius_magnitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @radius_magnitude.setter
    def radius_magnitude(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_radius_magnitude"](arg_newVal.COM_val))

    @property
    def latitude_rate(self) -> float:
        """The rate of change of the satellite's latitude. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_latitude_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @latitude_rate.setter
    def latitude_rate(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_latitude_rate"](arg_newVal.COM_val))

    @property
    def longitude_rate(self) -> float:
        """The rate of change of the satellite's longitude. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_longitude_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @longitude_rate.setter
    def longitude_rate(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_longitude_rate"](arg_newVal.COM_val))

    @property
    def altitude_rate(self) -> float:
        """The rate of change of the altitude. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude_rate.setter
    def altitude_rate(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_rate"](arg_newVal.COM_val))

    @property
    def radius_rate(self) -> float:
        """The rate of change of the radius. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_radius_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @radius_rate.setter
    def radius_rate(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_radius_rate"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{091F376E-6C32-4567-BE00-D1CE1857B50F}", IElementGeodetic)
agcls.AgTypeNameMap["IElementGeodetic"] = IElementGeodetic

class IElementBPlane(IElement):
    """Properties for BPlane elements"""
    _uuid = "{83490C08-4958-4B0E-8AE9-E6795F70211A}"
    _num_methods = 26
    _vtable_offset = IElement._vtable_offset + IElement._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_right_ascension_of_b_plane"] = _raise_uninitialized_error
        self.__dict__["_set_right_ascension_of_b_plane"] = _raise_uninitialized_error
        self.__dict__["_get_declination_of_b_plane"] = _raise_uninitialized_error
        self.__dict__["_set_declination_of_b_plane"] = _raise_uninitialized_error
        self.__dict__["_get_b_dot_r_first_b_vector"] = _raise_uninitialized_error
        self.__dict__["_set_b_dot_r_first_b_vector"] = _raise_uninitialized_error
        self.__dict__["_get_b_dot_t_second_b_vector"] = _raise_uninitialized_error
        self.__dict__["_set_b_dot_t_second_b_vector"] = _raise_uninitialized_error
        self.__dict__["_get_hyperbolic_turning_angle"] = _raise_uninitialized_error
        self.__dict__["_set_hyperbolic_turning_angle"] = _raise_uninitialized_error
        self.__dict__["_get_orbital_c3_energy"] = _raise_uninitialized_error
        self.__dict__["_set_orbital_c3_energy"] = _raise_uninitialized_error
        self.__dict__["_get_hyperbolic_v_infinity"] = _raise_uninitialized_error
        self.__dict__["_set_hyperbolic_v_infinity"] = _raise_uninitialized_error
        self.__dict__["_get_semi_major_axis"] = _raise_uninitialized_error
        self.__dict__["_set_semi_major_axis"] = _raise_uninitialized_error
        self.__dict__["_get_b_dot_t_first_b_vector"] = _raise_uninitialized_error
        self.__dict__["_set_b_dot_t_first_b_vector"] = _raise_uninitialized_error
        self.__dict__["_get_b_theta_first_b_vector"] = _raise_uninitialized_error
        self.__dict__["_set_b_theta_first_b_vector"] = _raise_uninitialized_error
        self.__dict__["_get_b_dot_r_second_b_vector"] = _raise_uninitialized_error
        self.__dict__["_set_b_dot_r_second_b_vector"] = _raise_uninitialized_error
        self.__dict__["_get_b_mag_second_b_vector"] = _raise_uninitialized_error
        self.__dict__["_set_b_mag_second_b_vector"] = _raise_uninitialized_error
        self.__dict__["_get_true_anomaly"] = _raise_uninitialized_error
        self.__dict__["_set_true_anomaly"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IElementBPlane._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IElementBPlane from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IElement._private_init(self, pUnk)
        IID_IElementBPlane = agcom.GUID(IElementBPlane._uuid)
        vtable_offset_local = IElementBPlane._vtable_offset - 1
        self.__dict__["_get_right_ascension_of_b_plane"] = IAGFUNCTYPE(pUnk, IID_IElementBPlane, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_right_ascension_of_b_plane"] = IAGFUNCTYPE(pUnk, IID_IElementBPlane, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_declination_of_b_plane"] = IAGFUNCTYPE(pUnk, IID_IElementBPlane, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_declination_of_b_plane"] = IAGFUNCTYPE(pUnk, IID_IElementBPlane, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_b_dot_r_first_b_vector"] = IAGFUNCTYPE(pUnk, IID_IElementBPlane, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_b_dot_r_first_b_vector"] = IAGFUNCTYPE(pUnk, IID_IElementBPlane, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_b_dot_t_second_b_vector"] = IAGFUNCTYPE(pUnk, IID_IElementBPlane, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_b_dot_t_second_b_vector"] = IAGFUNCTYPE(pUnk, IID_IElementBPlane, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_hyperbolic_turning_angle"] = IAGFUNCTYPE(pUnk, IID_IElementBPlane, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_hyperbolic_turning_angle"] = IAGFUNCTYPE(pUnk, IID_IElementBPlane, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_orbital_c3_energy"] = IAGFUNCTYPE(pUnk, IID_IElementBPlane, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_orbital_c3_energy"] = IAGFUNCTYPE(pUnk, IID_IElementBPlane, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_hyperbolic_v_infinity"] = IAGFUNCTYPE(pUnk, IID_IElementBPlane, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_hyperbolic_v_infinity"] = IAGFUNCTYPE(pUnk, IID_IElementBPlane, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_semi_major_axis"] = IAGFUNCTYPE(pUnk, IID_IElementBPlane, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_semi_major_axis"] = IAGFUNCTYPE(pUnk, IID_IElementBPlane, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_b_dot_t_first_b_vector"] = IAGFUNCTYPE(pUnk, IID_IElementBPlane, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_b_dot_t_first_b_vector"] = IAGFUNCTYPE(pUnk, IID_IElementBPlane, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_b_theta_first_b_vector"] = IAGFUNCTYPE(pUnk, IID_IElementBPlane, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_set_b_theta_first_b_vector"] = IAGFUNCTYPE(pUnk, IID_IElementBPlane, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_get_b_dot_r_second_b_vector"] = IAGFUNCTYPE(pUnk, IID_IElementBPlane, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_set_b_dot_r_second_b_vector"] = IAGFUNCTYPE(pUnk, IID_IElementBPlane, vtable_offset_local+22, agcom.DOUBLE)
        self.__dict__["_get_b_mag_second_b_vector"] = IAGFUNCTYPE(pUnk, IID_IElementBPlane, vtable_offset_local+23, POINTER(agcom.DOUBLE))
        self.__dict__["_set_b_mag_second_b_vector"] = IAGFUNCTYPE(pUnk, IID_IElementBPlane, vtable_offset_local+24, agcom.DOUBLE)
        self.__dict__["_get_true_anomaly"] = IAGFUNCTYPE(pUnk, IID_IElementBPlane, vtable_offset_local+25, POINTER(agcom.DOUBLE))
        self.__dict__["_set_true_anomaly"] = IAGFUNCTYPE(pUnk, IID_IElementBPlane, vtable_offset_local+26, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IElementBPlane.__dict__ and type(IElementBPlane.__dict__[attrname]) == property:
            return IElementBPlane.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IElement.__setattr__(self, attrname, value)
    
    @property
    def right_ascension_of_b_plane(self) -> float:
        """Right Ascension of the B-Plane Normal."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_right_ascension_of_b_plane"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @right_ascension_of_b_plane.setter
    def right_ascension_of_b_plane(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_right_ascension_of_b_plane"](arg_newVal.COM_val))

    @property
    def declination_of_b_plane(self) -> float:
        """Declination of the B-Plane Normal."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_declination_of_b_plane"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @declination_of_b_plane.setter
    def declination_of_b_plane(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_declination_of_b_plane"](arg_newVal.COM_val))

    @property
    def b_dot_r_first_b_vector(self) -> float:
        """B vector dotted with R vector."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_b_dot_r_first_b_vector"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @b_dot_r_first_b_vector.setter
    def b_dot_r_first_b_vector(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_b_dot_r_first_b_vector"](arg_newVal.COM_val))

    @property
    def b_dot_t_second_b_vector(self) -> float:
        """B vector dotted with T vector."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_b_dot_t_second_b_vector"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @b_dot_t_second_b_vector.setter
    def b_dot_t_second_b_vector(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_b_dot_t_second_b_vector"](arg_newVal.COM_val))

    @property
    def hyperbolic_turning_angle(self) -> float:
        """Hyperbolic turning angle."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_hyperbolic_turning_angle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @hyperbolic_turning_angle.setter
    def hyperbolic_turning_angle(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_hyperbolic_turning_angle"](arg_newVal.COM_val))

    @property
    def orbital_c3_energy(self) -> float:
        """Orbital C3 Energy."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_orbital_c3_energy"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @orbital_c3_energy.setter
    def orbital_c3_energy(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_orbital_c3_energy"](arg_newVal.COM_val))

    @property
    def hyperbolic_v_infinity(self) -> float:
        """Hyperbolic V infinity."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_hyperbolic_v_infinity"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @hyperbolic_v_infinity.setter
    def hyperbolic_v_infinity(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_hyperbolic_v_infinity"](arg_newVal.COM_val))

    @property
    def semi_major_axis(self) -> float:
        """Semi-major axis."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_semi_major_axis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @semi_major_axis.setter
    def semi_major_axis(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_semi_major_axis"](arg_newVal.COM_val))

    @property
    def b_dot_t_first_b_vector(self) -> float:
        """B vector dotted with T vector used as the first quantity to define the B vector."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_b_dot_t_first_b_vector"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @b_dot_t_first_b_vector.setter
    def b_dot_t_first_b_vector(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_b_dot_t_first_b_vector"](arg_newVal.COM_val))

    @property
    def b_theta_first_b_vector(self) -> float:
        """Angle between the B vector and T vector used as the first quantity to define the B vector."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_b_theta_first_b_vector"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @b_theta_first_b_vector.setter
    def b_theta_first_b_vector(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_b_theta_first_b_vector"](arg_newVal.COM_val))

    @property
    def b_dot_r_second_b_vector(self) -> float:
        """B vector dotted with T vector used as the second quantity to define the B vector."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_b_dot_r_second_b_vector"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @b_dot_r_second_b_vector.setter
    def b_dot_r_second_b_vector(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_b_dot_r_second_b_vector"](arg_newVal.COM_val))

    @property
    def b_mag_second_b_vector(self) -> float:
        """Magnitude of the B vector used as the second quantity to define the B vector."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_b_mag_second_b_vector"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @b_mag_second_b_vector.setter
    def b_mag_second_b_vector(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_b_mag_second_b_vector"](arg_newVal.COM_val))

    @property
    def true_anomaly(self) -> float:
        """True Anomaly."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_true_anomaly"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @true_anomaly.setter
    def true_anomaly(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_true_anomaly"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{83490C08-4958-4B0E-8AE9-E6795F70211A}", IElementBPlane)
agcls.AgTypeNameMap["IElementBPlane"] = IElementBPlane

class IStoppingCondition(IStoppingConditionComponent):
    """Basic properties for a stopping condition."""
    _uuid = "{7B18D549-E67A-4532-9767-ECC78418475D}"
    _num_methods = 30
    _vtable_offset = IStoppingConditionComponent._vtable_offset + IStoppingConditionComponent._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_trip"] = _raise_uninitialized_error
        self.__dict__["_set_trip"] = _raise_uninitialized_error
        self.__dict__["_get_tolerance"] = _raise_uninitialized_error
        self.__dict__["_set_tolerance"] = _raise_uninitialized_error
        self.__dict__["_get_repeat_count"] = _raise_uninitialized_error
        self.__dict__["_set_repeat_count"] = _raise_uninitialized_error
        self.__dict__["_get_inherited"] = _raise_uninitialized_error
        self.__dict__["_set_inherited"] = _raise_uninitialized_error
        self.__dict__["_get_max_trip_times"] = _raise_uninitialized_error
        self.__dict__["_set_max_trip_times"] = _raise_uninitialized_error
        self.__dict__["_get_coord_system"] = _raise_uninitialized_error
        self.__dict__["_set_coord_system"] = _raise_uninitialized_error
        self.__dict__["_get_sequence"] = _raise_uninitialized_error
        self.__dict__["_set_sequence"] = _raise_uninitialized_error
        self.__dict__["_get_constraints"] = _raise_uninitialized_error
        self.__dict__["_get_user_calc_object_name"] = _raise_uninitialized_error
        self.__dict__["_set_user_calc_object_name"] = _raise_uninitialized_error
        self.__dict__["_get_user_calc_object"] = _raise_uninitialized_error
        self.__dict__["_set_user_calc_object"] = _raise_uninitialized_error
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_criterion"] = _raise_uninitialized_error
        self.__dict__["_set_criterion"] = _raise_uninitialized_error
        self.__dict__["_get_before_conditions"] = _raise_uninitialized_error
        self.__dict__["_get_dimension"] = _raise_uninitialized_error
        self.__dict__["_get_reference_point"] = _raise_uninitialized_error
        self.__dict__["_set_reference_point"] = _raise_uninitialized_error
        self.__dict__["_copy_user_calc_object_to_clipboard"] = _raise_uninitialized_error
        self.__dict__["_paste_user_calc_object_from_clipboard"] = _raise_uninitialized_error
        self.__dict__["_get_user_calc_object_link_embed_control"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStoppingCondition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStoppingCondition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IStoppingConditionComponent._private_init(self, pUnk)
        IID_IStoppingCondition = agcom.GUID(IStoppingCondition._uuid)
        vtable_offset_local = IStoppingCondition._vtable_offset - 1
        self.__dict__["_get_trip"] = IAGFUNCTYPE(pUnk, IID_IStoppingCondition, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_set_trip"] = IAGFUNCTYPE(pUnk, IID_IStoppingCondition, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_get_tolerance"] = IAGFUNCTYPE(pUnk, IID_IStoppingCondition, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_tolerance"] = IAGFUNCTYPE(pUnk, IID_IStoppingCondition, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_repeat_count"] = IAGFUNCTYPE(pUnk, IID_IStoppingCondition, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_repeat_count"] = IAGFUNCTYPE(pUnk, IID_IStoppingCondition, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_inherited"] = IAGFUNCTYPE(pUnk, IID_IStoppingCondition, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_inherited"] = IAGFUNCTYPE(pUnk, IID_IStoppingCondition, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_get_max_trip_times"] = IAGFUNCTYPE(pUnk, IID_IStoppingCondition, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_trip_times"] = IAGFUNCTYPE(pUnk, IID_IStoppingCondition, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_coord_system"] = IAGFUNCTYPE(pUnk, IID_IStoppingCondition, vtable_offset_local+11, POINTER(agcom.BSTR))
        self.__dict__["_set_coord_system"] = IAGFUNCTYPE(pUnk, IID_IStoppingCondition, vtable_offset_local+12, agcom.BSTR)
        self.__dict__["_get_sequence"] = IAGFUNCTYPE(pUnk, IID_IStoppingCondition, vtable_offset_local+13, POINTER(agcom.BSTR))
        self.__dict__["_set_sequence"] = IAGFUNCTYPE(pUnk, IID_IStoppingCondition, vtable_offset_local+14, agcom.BSTR)
        self.__dict__["_get_constraints"] = IAGFUNCTYPE(pUnk, IID_IStoppingCondition, vtable_offset_local+15, POINTER(agcom.PVOID))
        self.__dict__["_get_user_calc_object_name"] = IAGFUNCTYPE(pUnk, IID_IStoppingCondition, vtable_offset_local+16, POINTER(agcom.BSTR))
        self.__dict__["_set_user_calc_object_name"] = IAGFUNCTYPE(pUnk, IID_IStoppingCondition, vtable_offset_local+17, agcom.BSTR)
        self.__dict__["_get_user_calc_object"] = IAGFUNCTYPE(pUnk, IID_IStoppingCondition, vtable_offset_local+18, POINTER(agcom.PVOID))
        self.__dict__["_set_user_calc_object"] = IAGFUNCTYPE(pUnk, IID_IStoppingCondition, vtable_offset_local+19, agcom.PVOID)
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStoppingCondition, vtable_offset_local+20, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStoppingCondition, vtable_offset_local+21, agcom.BSTR)
        self.__dict__["_get_criterion"] = IAGFUNCTYPE(pUnk, IID_IStoppingCondition, vtable_offset_local+22, POINTER(agcom.LONG))
        self.__dict__["_set_criterion"] = IAGFUNCTYPE(pUnk, IID_IStoppingCondition, vtable_offset_local+23, agcom.LONG)
        self.__dict__["_get_before_conditions"] = IAGFUNCTYPE(pUnk, IID_IStoppingCondition, vtable_offset_local+24, POINTER(agcom.PVOID))
        self.__dict__["_get_dimension"] = IAGFUNCTYPE(pUnk, IID_IStoppingCondition, vtable_offset_local+25, POINTER(agcom.BSTR))
        self.__dict__["_get_reference_point"] = IAGFUNCTYPE(pUnk, IID_IStoppingCondition, vtable_offset_local+26, POINTER(agcom.BSTR))
        self.__dict__["_set_reference_point"] = IAGFUNCTYPE(pUnk, IID_IStoppingCondition, vtable_offset_local+27, agcom.BSTR)
        self.__dict__["_copy_user_calc_object_to_clipboard"] = IAGFUNCTYPE(pUnk, IID_IStoppingCondition, vtable_offset_local+28, )
        self.__dict__["_paste_user_calc_object_from_clipboard"] = IAGFUNCTYPE(pUnk, IID_IStoppingCondition, vtable_offset_local+29, )
        self.__dict__["_get_user_calc_object_link_embed_control"] = IAGFUNCTYPE(pUnk, IID_IStoppingCondition, vtable_offset_local+30, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStoppingCondition.__dict__ and type(IStoppingCondition.__dict__[attrname]) == property:
            return IStoppingCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IStoppingConditionComponent.__setattr__(self, attrname, value)
    
    @property
    def trip(self) -> typing.Any:
        """The desired value - the value at which the condition will be satisfied. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_trip"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @trip.setter
    def trip(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_trip"](arg_newVal.COM_val))

    @property
    def tolerance(self) -> float:
        """The desired tolerance for achieving the stopping condition. Dimension depends on context."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_tolerance"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @tolerance.setter
    def tolerance(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_tolerance"](arg_newVal.COM_val))

    @property
    def repeat_count(self) -> float:
        """The number of times the condition must be satisfied before the propagation ends or moves on to the designated automatic sequence. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_repeat_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @repeat_count.setter
    def repeat_count(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_repeat_count"](arg_newVal.COM_val))

    @property
    def inherited(self) -> bool:
        """Condition Inherited by Automatic Sequences - if true, the stopping condition will be applied to any automatic sequences activated within the same segment."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_inherited"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @inherited.setter
    def inherited(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_inherited"](arg_newVal.COM_val))

    @property
    def max_trip_times(self) -> float:
        """The maximum number of times that the stopping condition will be applied - and any resulting automatic sequences executed. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_trip_times"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_trip_times.setter
    def max_trip_times(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_trip_times"](arg_inVal.COM_val))

    @property
    def coord_system(self) -> str:
        """The coordinate system. The default coordinate system of a stopping condition is Earth Inertial."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_system"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_system.setter
    def coord_system(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_system"](arg_newVal.COM_val))

    @property
    def sequence(self) -> str:
        """The automatic sequence to trigger if the highlighted stopping condition is satisfied."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sequence"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sequence.setter
    def sequence(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_sequence"](arg_newVal.COM_val))

    @property
    def constraints(self) -> "IConstraintCollection":
        """Further conditions that must be met in order for the stopping condition to be deemed satisfied."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAConstraintCollection:
            agcls.evaluate_hresult(self.__dict__["_get_constraints"](byref(arg_ppVAConstraintCollection.COM_val)))
            return arg_ppVAConstraintCollection.python_val

    @property
    def user_calc_object_name(self) -> str:
        """User Calc Object - a User Calculation Object for the highlighted stopping condition. For user-defined stopping conditions, use this field to specify what kind of value you want to stop on."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_user_calc_object_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @user_calc_object_name.setter
    def user_calc_object_name(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_user_calc_object_name"](arg_newVal.COM_val))

    @property
    def user_calc_object(self) -> "IComponentInfo":
        """A User Calculation Object for the highlighted stopping condition. For user-defined stopping conditions, use this field to specify what kind of value you want to stop on."""
        with agmarshall.AgInterface_out_arg() as arg_ppComponentInfo:
            agcls.evaluate_hresult(self.__dict__["_get_user_calc_object"](byref(arg_ppComponentInfo.COM_val)))
            return arg_ppComponentInfo.python_val

    @user_calc_object.setter
    def user_calc_object(self, newVal:"IComponentInfo") -> None:
        with agmarshall.AgInterface_in_arg(newVal, IComponentInfo) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_user_calc_object"](arg_newVal.COM_val))

    @property
    def central_body_name(self) -> str:
        """The central body. The default central body of a stopping condition is the Earth."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_newVal.COM_val))

    @property
    def criterion(self) -> "AgEVACriterion":
        """Specifies the direction from which the stopping condition value must be achieved."""
        with agmarshall.AgEnum_arg(AgEVACriterion) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_criterion"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @criterion.setter
    def criterion(self, newVal:"AgEVACriterion") -> None:
        with agmarshall.AgEnum_arg(AgEVACriterion, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_criterion"](arg_newVal.COM_val))

    @property
    def before_conditions(self) -> "IStoppingConditionCollection":
        """A 'before' stopping condition is used to define a stopping condition that depends on two events. Astrogator will ignore a stopping condition until its 'before' conditions are met. Astrogator then interpolates backwards to the normal stopping condition."""
        with agmarshall.AgInterface_out_arg() as arg_ppStoppingConditionCollection:
            agcls.evaluate_hresult(self.__dict__["_get_before_conditions"](byref(arg_ppStoppingConditionCollection.COM_val)))
            return arg_ppStoppingConditionCollection.python_val

    @property
    def dimension(self) -> str:
        """The dimension of the stopping condition."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_dimension"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def reference_point(self) -> str:
        """Reference point used for calculation."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_point"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @reference_point.setter
    def reference_point(self, inVal:str) -> None:
        """Reference point used for calculation."""
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_point"](arg_inVal.COM_val))

    def copy_user_calc_object_to_clipboard(self) -> None:
        """Copies the user-defined stopping condition calc object to the clipboard."""
        agcls.evaluate_hresult(self.__dict__["_copy_user_calc_object_to_clipboard"]())

    def paste_user_calc_object_from_clipboard(self) -> None:
        """Replaces the user-defined stopping condition calc object with the calc object in the clipboard."""
        agcls.evaluate_hresult(self.__dict__["_paste_user_calc_object_from_clipboard"]())

    @property
    def user_calc_object_link_embed_control(self) -> "IComponentLinkEmbedControl":
        """Gets the link / embed controller for managing the user calc. object."""
        with agmarshall.AgInterface_out_arg() as arg_ppVal:
            agcls.evaluate_hresult(self.__dict__["_get_user_calc_object_link_embed_control"](byref(arg_ppVal.COM_val)))
            return arg_ppVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{7B18D549-E67A-4532-9767-ECC78418475D}", IStoppingCondition)
agcls.AgTypeNameMap["IStoppingCondition"] = IStoppingCondition

class ILightingStoppingCondition(IStoppingConditionComponent):
    """Properties for a lighting stopping condition."""
    _uuid = "{05642E87-6580-4E1F-82EF-BA6406DBAC65}"
    _num_methods = 18
    _vtable_offset = IStoppingConditionComponent._vtable_offset + IStoppingConditionComponent._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_max_trip_times"] = _raise_uninitialized_error
        self.__dict__["_set_max_trip_times"] = _raise_uninitialized_error
        self.__dict__["_get_repeat_count"] = _raise_uninitialized_error
        self.__dict__["_set_repeat_count"] = _raise_uninitialized_error
        self.__dict__["_get_constraints"] = _raise_uninitialized_error
        self.__dict__["_get_before_conditions"] = _raise_uninitialized_error
        self.__dict__["_get_inherited"] = _raise_uninitialized_error
        self.__dict__["_set_inherited"] = _raise_uninitialized_error
        self.__dict__["_get_sequence"] = _raise_uninitialized_error
        self.__dict__["_set_sequence"] = _raise_uninitialized_error
        self.__dict__["_get_condition"] = _raise_uninitialized_error
        self.__dict__["_set_condition"] = _raise_uninitialized_error
        self.__dict__["_get_eclipsing_bodies_list_source"] = _raise_uninitialized_error
        self.__dict__["_set_eclipsing_bodies_list_source"] = _raise_uninitialized_error
        self.__dict__["_add_eclipsing_body"] = _raise_uninitialized_error
        self.__dict__["_remove_eclipsing_body"] = _raise_uninitialized_error
        self.__dict__["_get_eclipsing_bodies"] = _raise_uninitialized_error
        self.__dict__["_get_available_eclipsing_bodies"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ILightingStoppingCondition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ILightingStoppingCondition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IStoppingConditionComponent._private_init(self, pUnk)
        IID_ILightingStoppingCondition = agcom.GUID(ILightingStoppingCondition._uuid)
        vtable_offset_local = ILightingStoppingCondition._vtable_offset - 1
        self.__dict__["_get_max_trip_times"] = IAGFUNCTYPE(pUnk, IID_ILightingStoppingCondition, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_trip_times"] = IAGFUNCTYPE(pUnk, IID_ILightingStoppingCondition, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_repeat_count"] = IAGFUNCTYPE(pUnk, IID_ILightingStoppingCondition, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_repeat_count"] = IAGFUNCTYPE(pUnk, IID_ILightingStoppingCondition, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_constraints"] = IAGFUNCTYPE(pUnk, IID_ILightingStoppingCondition, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_before_conditions"] = IAGFUNCTYPE(pUnk, IID_ILightingStoppingCondition, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_get_inherited"] = IAGFUNCTYPE(pUnk, IID_ILightingStoppingCondition, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_inherited"] = IAGFUNCTYPE(pUnk, IID_ILightingStoppingCondition, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_get_sequence"] = IAGFUNCTYPE(pUnk, IID_ILightingStoppingCondition, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_set_sequence"] = IAGFUNCTYPE(pUnk, IID_ILightingStoppingCondition, vtable_offset_local+10, agcom.BSTR)
        self.__dict__["_get_condition"] = IAGFUNCTYPE(pUnk, IID_ILightingStoppingCondition, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_set_condition"] = IAGFUNCTYPE(pUnk, IID_ILightingStoppingCondition, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_get_eclipsing_bodies_list_source"] = IAGFUNCTYPE(pUnk, IID_ILightingStoppingCondition, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_set_eclipsing_bodies_list_source"] = IAGFUNCTYPE(pUnk, IID_ILightingStoppingCondition, vtable_offset_local+14, agcom.LONG)
        self.__dict__["_add_eclipsing_body"] = IAGFUNCTYPE(pUnk, IID_ILightingStoppingCondition, vtable_offset_local+15, agcom.BSTR)
        self.__dict__["_remove_eclipsing_body"] = IAGFUNCTYPE(pUnk, IID_ILightingStoppingCondition, vtable_offset_local+16, agcom.BSTR)
        self.__dict__["_get_eclipsing_bodies"] = IAGFUNCTYPE(pUnk, IID_ILightingStoppingCondition, vtable_offset_local+17, POINTER(agcom.SAFEARRAY))
        self.__dict__["_get_available_eclipsing_bodies"] = IAGFUNCTYPE(pUnk, IID_ILightingStoppingCondition, vtable_offset_local+18, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ILightingStoppingCondition.__dict__ and type(ILightingStoppingCondition.__dict__[attrname]) == property:
            return ILightingStoppingCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IStoppingConditionComponent.__setattr__(self, attrname, value)
    
    @property
    def max_trip_times(self) -> float:
        """Rhe maximum number of times that the stopping condition will be applied - and any resulting automatic sequences executed. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_trip_times"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_trip_times.setter
    def max_trip_times(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_trip_times"](arg_inVal.COM_val))

    @property
    def repeat_count(self) -> float:
        """The number of times the condition must be satisfied before the propagation ends or moves on to the designated automatic sequence. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_repeat_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @repeat_count.setter
    def repeat_count(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_repeat_count"](arg_newVal.COM_val))

    @property
    def constraints(self) -> "IConstraintCollection":
        """Further conditions that must be met in order for the stopping condition to be deemed satisfied."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAConstraintCollection:
            agcls.evaluate_hresult(self.__dict__["_get_constraints"](byref(arg_ppVAConstraintCollection.COM_val)))
            return arg_ppVAConstraintCollection.python_val

    @property
    def before_conditions(self) -> "IStoppingConditionCollection":
        """A 'before' stopping condition is used to define a stopping condition that depends on two events. Astrogator will ignore a stopping condition until its 'before' conditions are met. Astrogator then interpolates backwards to the normal stopping condition."""
        with agmarshall.AgInterface_out_arg() as arg_ppStoppingConditionCollection:
            agcls.evaluate_hresult(self.__dict__["_get_before_conditions"](byref(arg_ppStoppingConditionCollection.COM_val)))
            return arg_ppStoppingConditionCollection.python_val

    @property
    def inherited(self) -> bool:
        """Condition Inherited by Automatic Sequences - if true, the stopping condition will be applied to any automatic sequences activated within the same segment."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_inherited"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @inherited.setter
    def inherited(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_inherited"](arg_newVal.COM_val))

    @property
    def sequence(self) -> str:
        """The automatic sequence to trigger if the highlighted stopping condition is satisfied."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sequence"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sequence.setter
    def sequence(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_sequence"](arg_newVal.COM_val))

    @property
    def condition(self) -> "AgEVALightingCondition":
        """Specifies the direction from which the stopping condition value must be achieved."""
        with agmarshall.AgEnum_arg(AgEVALightingCondition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_condition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @condition.setter
    def condition(self, newVal:"AgEVALightingCondition") -> None:
        with agmarshall.AgEnum_arg(AgEVALightingCondition, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_condition"](arg_newVal.COM_val))

    @property
    def eclipsing_bodies_list_source(self) -> "AgEVAEclipsingBodiesSource":
        """Eclipsing Bodies List Source."""
        with agmarshall.AgEnum_arg(AgEVAEclipsingBodiesSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_eclipsing_bodies_list_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @eclipsing_bodies_list_source.setter
    def eclipsing_bodies_list_source(self, newVal:"AgEVAEclipsingBodiesSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAEclipsingBodiesSource, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_eclipsing_bodies_list_source"](arg_newVal.COM_val))

    def add_eclipsing_body(self, eclipsingBody:str) -> None:
        """Adds an eclipsing body."""
        with agmarshall.BSTR_arg(eclipsingBody) as arg_eclipsingBody:
            agcls.evaluate_hresult(self.__dict__["_add_eclipsing_body"](arg_eclipsingBody.COM_val))

    def remove_eclipsing_body(self, eclipsingBody:str) -> None:
        """Removes an eclipsing body."""
        with agmarshall.BSTR_arg(eclipsingBody) as arg_eclipsingBody:
            agcls.evaluate_hresult(self.__dict__["_remove_eclipsing_body"](arg_eclipsingBody.COM_val))

    @property
    def eclipsing_bodies(self) -> list:
        """Returns a list of user selected eclipsing bodies."""
        with agmarshall.SAFEARRAY_arg() as arg_ppNewVal:
            agcls.evaluate_hresult(self.__dict__["_get_eclipsing_bodies"](byref(arg_ppNewVal.COM_val)))
            return arg_ppNewVal.python_val

    @property
    def available_eclipsing_bodies(self) -> list:
        """Returns a list of available eclipsing bodies."""
        with agmarshall.SAFEARRAY_arg() as arg_ppNewVal:
            agcls.evaluate_hresult(self.__dict__["_get_available_eclipsing_bodies"](byref(arg_ppNewVal.COM_val)))
            return arg_ppNewVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{05642E87-6580-4E1F-82EF-BA6406DBAC65}", ILightingStoppingCondition)
agcls.AgTypeNameMap["ILightingStoppingCondition"] = ILightingStoppingCondition

class IAccessStoppingCondition(IStoppingConditionComponent):
    """Properties for an access stopping condition."""
    _uuid = "{2A2D2F12-9F9B-43F6-B6B0-00088C006504}"
    _num_methods = 28
    _vtable_offset = IStoppingConditionComponent._vtable_offset + IStoppingConditionComponent._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_time_convergence"] = _raise_uninitialized_error
        self.__dict__["_set_time_convergence"] = _raise_uninitialized_error
        self.__dict__["_get_repeat_count"] = _raise_uninitialized_error
        self.__dict__["_set_repeat_count"] = _raise_uninitialized_error
        self.__dict__["_get_inherited"] = _raise_uninitialized_error
        self.__dict__["_set_inherited"] = _raise_uninitialized_error
        self.__dict__["_get_max_trip_times"] = _raise_uninitialized_error
        self.__dict__["_set_max_trip_times"] = _raise_uninitialized_error
        self.__dict__["_get_sequence"] = _raise_uninitialized_error
        self.__dict__["_set_sequence"] = _raise_uninitialized_error
        self.__dict__["_get_constraints"] = _raise_uninitialized_error
        self.__dict__["_get_criterion"] = _raise_uninitialized_error
        self.__dict__["_set_criterion"] = _raise_uninitialized_error
        self.__dict__["_get_before_conditions"] = _raise_uninitialized_error
        self.__dict__["_get_aberration_type"] = _raise_uninitialized_error
        self.__dict__["_set_aberration_type"] = _raise_uninitialized_error
        self.__dict__["_set_base_selection"] = _raise_uninitialized_error
        self.__dict__["_get_base_selection_type"] = _raise_uninitialized_error
        self.__dict__["_get_base_selection"] = _raise_uninitialized_error
        self.__dict__["_get_clock_host"] = _raise_uninitialized_error
        self.__dict__["_set_clock_host"] = _raise_uninitialized_error
        self.__dict__["_get_signal_sense"] = _raise_uninitialized_error
        self.__dict__["_set_signal_sense"] = _raise_uninitialized_error
        self.__dict__["_get_target_object"] = _raise_uninitialized_error
        self.__dict__["_get_time_delay_convergence_tolerance"] = _raise_uninitialized_error
        self.__dict__["_set_time_delay_convergence_tolerance"] = _raise_uninitialized_error
        self.__dict__["_get_use_light_time_delay"] = _raise_uninitialized_error
        self.__dict__["_set_use_light_time_delay"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAccessStoppingCondition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAccessStoppingCondition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IStoppingConditionComponent._private_init(self, pUnk)
        IID_IAccessStoppingCondition = agcom.GUID(IAccessStoppingCondition._uuid)
        vtable_offset_local = IAccessStoppingCondition._vtable_offset - 1
        self.__dict__["_get_time_convergence"] = IAGFUNCTYPE(pUnk, IID_IAccessStoppingCondition, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_time_convergence"] = IAGFUNCTYPE(pUnk, IID_IAccessStoppingCondition, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_repeat_count"] = IAGFUNCTYPE(pUnk, IID_IAccessStoppingCondition, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_repeat_count"] = IAGFUNCTYPE(pUnk, IID_IAccessStoppingCondition, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_inherited"] = IAGFUNCTYPE(pUnk, IID_IAccessStoppingCondition, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_inherited"] = IAGFUNCTYPE(pUnk, IID_IAccessStoppingCondition, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_get_max_trip_times"] = IAGFUNCTYPE(pUnk, IID_IAccessStoppingCondition, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_trip_times"] = IAGFUNCTYPE(pUnk, IID_IAccessStoppingCondition, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_sequence"] = IAGFUNCTYPE(pUnk, IID_IAccessStoppingCondition, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_set_sequence"] = IAGFUNCTYPE(pUnk, IID_IAccessStoppingCondition, vtable_offset_local+10, agcom.BSTR)
        self.__dict__["_get_constraints"] = IAGFUNCTYPE(pUnk, IID_IAccessStoppingCondition, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_get_criterion"] = IAGFUNCTYPE(pUnk, IID_IAccessStoppingCondition, vtable_offset_local+12, POINTER(agcom.LONG))
        self.__dict__["_set_criterion"] = IAGFUNCTYPE(pUnk, IID_IAccessStoppingCondition, vtable_offset_local+13, agcom.LONG)
        self.__dict__["_get_before_conditions"] = IAGFUNCTYPE(pUnk, IID_IAccessStoppingCondition, vtable_offset_local+14, POINTER(agcom.PVOID))
        self.__dict__["_get_aberration_type"] = IAGFUNCTYPE(pUnk, IID_IAccessStoppingCondition, vtable_offset_local+15, POINTER(agcom.LONG))
        self.__dict__["_set_aberration_type"] = IAGFUNCTYPE(pUnk, IID_IAccessStoppingCondition, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_set_base_selection"] = IAGFUNCTYPE(pUnk, IID_IAccessStoppingCondition, vtable_offset_local+17, agcom.LONG)
        self.__dict__["_get_base_selection_type"] = IAGFUNCTYPE(pUnk, IID_IAccessStoppingCondition, vtable_offset_local+18, POINTER(agcom.LONG))
        self.__dict__["_get_base_selection"] = IAGFUNCTYPE(pUnk, IID_IAccessStoppingCondition, vtable_offset_local+19, POINTER(agcom.PVOID))
        self.__dict__["_get_clock_host"] = IAGFUNCTYPE(pUnk, IID_IAccessStoppingCondition, vtable_offset_local+20, POINTER(agcom.LONG))
        self.__dict__["_set_clock_host"] = IAGFUNCTYPE(pUnk, IID_IAccessStoppingCondition, vtable_offset_local+21, agcom.LONG)
        self.__dict__["_get_signal_sense"] = IAGFUNCTYPE(pUnk, IID_IAccessStoppingCondition, vtable_offset_local+22, POINTER(agcom.LONG))
        self.__dict__["_set_signal_sense"] = IAGFUNCTYPE(pUnk, IID_IAccessStoppingCondition, vtable_offset_local+23, agcom.LONG)
        self.__dict__["_get_target_object"] = IAGFUNCTYPE(pUnk, IID_IAccessStoppingCondition, vtable_offset_local+24, POINTER(agcom.PVOID))
        self.__dict__["_get_time_delay_convergence_tolerance"] = IAGFUNCTYPE(pUnk, IID_IAccessStoppingCondition, vtable_offset_local+25, POINTER(agcom.DOUBLE))
        self.__dict__["_set_time_delay_convergence_tolerance"] = IAGFUNCTYPE(pUnk, IID_IAccessStoppingCondition, vtable_offset_local+26, agcom.DOUBLE)
        self.__dict__["_get_use_light_time_delay"] = IAGFUNCTYPE(pUnk, IID_IAccessStoppingCondition, vtable_offset_local+27, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_light_time_delay"] = IAGFUNCTYPE(pUnk, IID_IAccessStoppingCondition, vtable_offset_local+28, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAccessStoppingCondition.__dict__ and type(IAccessStoppingCondition.__dict__[attrname]) == property:
            return IAccessStoppingCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IStoppingConditionComponent.__setattr__(self, attrname, value)
    
    @property
    def time_convergence(self) -> float:
        """Sets the time tolerance that is used by the access algorithms to determine the start times and stop times of access intervals. Uses Time dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_time_convergence"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @time_convergence.setter
    def time_convergence(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_time_convergence"](arg_newVal.COM_val))

    @property
    def repeat_count(self) -> float:
        """The number of times the condition must be satisfied before the propagation ends or moves on to the designated automatic sequence. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_repeat_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @repeat_count.setter
    def repeat_count(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_repeat_count"](arg_newVal.COM_val))

    @property
    def inherited(self) -> bool:
        """Condition Inherited by Automatic Sequences - if true, the stopping condition will be applied to any automatic sequences activated within the same segment."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_inherited"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @inherited.setter
    def inherited(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_inherited"](arg_newVal.COM_val))

    @property
    def max_trip_times(self) -> float:
        """The maximum number of times that the stopping condition will be applied - and any resulting automatic sequences executed. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_trip_times"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_trip_times.setter
    def max_trip_times(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_trip_times"](arg_inVal.COM_val))

    @property
    def sequence(self) -> str:
        """The automatic sequence to trigger if the highlighted stopping condition is satisfied."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sequence"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sequence.setter
    def sequence(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_sequence"](arg_newVal.COM_val))

    @property
    def constraints(self) -> "IConstraintCollection":
        """Further conditions that must be met in order for the stopping condition to be deemed satisfied."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAConstraintCollection:
            agcls.evaluate_hresult(self.__dict__["_get_constraints"](byref(arg_ppVAConstraintCollection.COM_val)))
            return arg_ppVAConstraintCollection.python_val

    @property
    def criterion(self) -> "AgEVAAccessCriterion":
        """Specifies the direction from which the stopping condition value must be achieved."""
        with agmarshall.AgEnum_arg(AgEVAAccessCriterion) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_criterion"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @criterion.setter
    def criterion(self, newVal:"AgEVAAccessCriterion") -> None:
        with agmarshall.AgEnum_arg(AgEVAAccessCriterion, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_criterion"](arg_newVal.COM_val))

    @property
    def before_conditions(self) -> "IStoppingConditionCollection":
        """A 'before' stopping condition is used to define a stopping condition that depends on two events. Astrogator will ignore a stopping condition until its 'before' conditions are met. Astrogator then interpolates backwards to the normal stopping condition."""
        with agmarshall.AgInterface_out_arg() as arg_ppStoppingConditionCollection:
            agcls.evaluate_hresult(self.__dict__["_get_before_conditions"](byref(arg_ppStoppingConditionCollection.COM_val)))
            return arg_ppStoppingConditionCollection.python_val

    @property
    def aberration_type(self) -> "AgEAberrationType":
        """Sets the model of aberration to be used in access computations."""
        with agmarshall.AgEnum_arg(AgEAberrationType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_aberration_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @aberration_type.setter
    def aberration_type(self, inVal:"AgEAberrationType") -> None:
        with agmarshall.AgEnum_arg(AgEAberrationType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_aberration_type"](arg_inVal.COM_val))

    def set_base_selection(self, selection:"AgEVABaseSelection") -> None:
        """BaseSelection"""
        with agmarshall.AgEnum_arg(AgEVABaseSelection, selection) as arg_selection:
            agcls.evaluate_hresult(self.__dict__["_set_base_selection"](arg_selection.COM_val))

    @property
    def base_selection_type(self) -> "AgEVABaseSelection":
        """The base object for the access calculation."""
        with agmarshall.AgEnum_arg(AgEVABaseSelection) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_base_selection_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def base_selection(self) -> "ILinkToObject":
        """Returns the base selection object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_base_selection"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def clock_host(self) -> "AgEIvClockHost":
        """Time values are reported with a clock colocated with the clock host object."""
        with agmarshall.AgEnum_arg(AgEIvClockHost) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_clock_host"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @clock_host.setter
    def clock_host(self, inVal:"AgEIvClockHost") -> None:
        with agmarshall.AgEnum_arg(AgEIvClockHost, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_clock_host"](arg_inVal.COM_val))

    @property
    def signal_sense(self) -> "AgEIvTimeSense":
        """Sets the direction of the signal."""
        with agmarshall.AgEnum_arg(AgEIvTimeSense) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_signal_sense"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @signal_sense.setter
    def signal_sense(self, inVal:"AgEIvTimeSense") -> None:
        with agmarshall.AgEnum_arg(AgEIvTimeSense, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_signal_sense"](arg_inVal.COM_val))

    @property
    def target_object(self) -> "ILinkToObject":
        """The target object for the access calculation."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_object"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def time_delay_convergence_tolerance(self) -> float:
        """The tolerance used when iterating to determine the light time delay. The iteration stops when the improvement in the value is less than this tolerance. Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_time_delay_convergence_tolerance"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @time_delay_convergence_tolerance.setter
    def time_delay_convergence_tolerance(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_time_delay_convergence_tolerance"](arg_inVal.COM_val))

    @property
    def use_light_time_delay(self) -> bool:
        """Whether to consider light time delay in access computations."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_light_time_delay"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_light_time_delay.setter
    def use_light_time_delay(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_light_time_delay"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2A2D2F12-9F9B-43F6-B6B0-00088C006504}", IAccessStoppingCondition)
agcls.AgTypeNameMap["IAccessStoppingCondition"] = IAccessStoppingCondition

class IMissionControlSequencePropagate(object):
    """Properties for a Propagate segment."""
    _uuid = "{41E66E06-FD6A-4523-8956-B0DF0BE5479E}"
    _num_methods = 21
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_propagator_name"] = _raise_uninitialized_error
        self.__dict__["_set_propagator_name"] = _raise_uninitialized_error
        self.__dict__["_get_stopping_conditions"] = _raise_uninitialized_error
        self.__dict__["_get_min_propagation_time"] = _raise_uninitialized_error
        self.__dict__["_set_min_propagation_time"] = _raise_uninitialized_error
        self.__dict__["_get_max_propagation_time"] = _raise_uninitialized_error
        self.__dict__["_set_max_propagation_time"] = _raise_uninitialized_error
        self.__dict__["_get_enable_max_propagation_time"] = _raise_uninitialized_error
        self.__dict__["_set_enable_max_propagation_time"] = _raise_uninitialized_error
        self.__dict__["_get_enable_warning_message"] = _raise_uninitialized_error
        self.__dict__["_set_enable_warning_message"] = _raise_uninitialized_error
        self.__dict__["_enable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_disable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_is_control_parameter_enabled"] = _raise_uninitialized_error
        self.__dict__["_get_control_parameters_available"] = _raise_uninitialized_error
        self.__dict__["_get_override_max_propagation_time"] = _raise_uninitialized_error
        self.__dict__["_set_override_max_propagation_time"] = _raise_uninitialized_error
        self.__dict__["_get_should_stop_for_initially_surpassed_epoch_stopping_conditions"] = _raise_uninitialized_error
        self.__dict__["_set_should_stop_for_initially_surpassed_epoch_stopping_conditions"] = _raise_uninitialized_error
        self.__dict__["_get_should_reinitialize_stm_at_start_of_segment_propagation"] = _raise_uninitialized_error
        self.__dict__["_set_should_reinitialize_stm_at_start_of_segment_propagation"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMissionControlSequencePropagate._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMissionControlSequencePropagate from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMissionControlSequencePropagate = agcom.GUID(IMissionControlSequencePropagate._uuid)
        vtable_offset_local = IMissionControlSequencePropagate._vtable_offset - 1
        self.__dict__["_get_propagator_name"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequencePropagate, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_propagator_name"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequencePropagate, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_stopping_conditions"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequencePropagate, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_min_propagation_time"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequencePropagate, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_set_min_propagation_time"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequencePropagate, vtable_offset_local+5, agcom.DOUBLE)
        self.__dict__["_get_max_propagation_time"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequencePropagate, vtable_offset_local+6, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_propagation_time"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequencePropagate, vtable_offset_local+7, agcom.DOUBLE)
        self.__dict__["_get_enable_max_propagation_time"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequencePropagate, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable_max_propagation_time"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequencePropagate, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_get_enable_warning_message"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequencePropagate, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable_warning_message"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequencePropagate, vtable_offset_local+11, agcom.VARIANT_BOOL)
        self.__dict__["_enable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequencePropagate, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_disable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequencePropagate, vtable_offset_local+13, agcom.LONG)
        self.__dict__["_is_control_parameter_enabled"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequencePropagate, vtable_offset_local+14, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_control_parameters_available"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequencePropagate, vtable_offset_local+15, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_override_max_propagation_time"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequencePropagate, vtable_offset_local+16, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_override_max_propagation_time"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequencePropagate, vtable_offset_local+17, agcom.VARIANT_BOOL)
        self.__dict__["_get_should_stop_for_initially_surpassed_epoch_stopping_conditions"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequencePropagate, vtable_offset_local+18, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_should_stop_for_initially_surpassed_epoch_stopping_conditions"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequencePropagate, vtable_offset_local+19, agcom.VARIANT_BOOL)
        self.__dict__["_get_should_reinitialize_stm_at_start_of_segment_propagation"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequencePropagate, vtable_offset_local+20, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_should_reinitialize_stm_at_start_of_segment_propagation"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequencePropagate, vtable_offset_local+21, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissionControlSequencePropagate.__dict__ and type(IMissionControlSequencePropagate.__dict__[attrname]) == property:
            return IMissionControlSequencePropagate.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissionControlSequencePropagate.")
    
    @property
    def propagator_name(self) -> str:
        """The propagator."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_propagator_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @propagator_name.setter
    def propagator_name(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_propagator_name"](arg_newVal.COM_val))

    @property
    def stopping_conditions(self) -> "IStoppingConditionCollection":
        """The list of stopping conditions defined for the segment."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAStoppingConditionCollection:
            agcls.evaluate_hresult(self.__dict__["_get_stopping_conditions"](byref(arg_ppVAStoppingConditionCollection.COM_val)))
            return arg_ppVAStoppingConditionCollection.python_val

    @property
    def min_propagation_time(self) -> float:
        """The minimum time that must elapse from the beginning of the segment until Astrogator will begin checking stopping conditions for satisfaction. Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_propagation_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @min_propagation_time.setter
    def min_propagation_time(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_min_propagation_time"](arg_newVal.COM_val))

    @property
    def max_propagation_time(self) -> float:
        """The maximum propagation time, after which the segment will end regardless of whether the stopping conditions have been satisfied. Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_propagation_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_propagation_time.setter
    def max_propagation_time(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_propagation_time"](arg_newVal.COM_val))

    @property
    def enable_max_propagation_time(self) -> bool:
        """If true, the maximum propagation time is enforced."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable_max_propagation_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable_max_propagation_time.setter
    def enable_max_propagation_time(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable_max_propagation_time"](arg_newVal.COM_val))

    @property
    def enable_warning_message(self) -> bool:
        """If true, Astrogator will issue a warning message if propagation is stopped by the Maximum Propagation Time parameter."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable_warning_message"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable_warning_message.setter
    def enable_warning_message(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable_warning_message"](arg_newVal.COM_val))

    def enable_control_parameter(self, param:"AgEVAControlAdvanced") -> None:
        """Enables or disables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlAdvanced, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_enable_control_parameter"](arg_param.COM_val))

    def disable_control_parameter(self, param:"AgEVAControlAdvanced") -> None:
        """Disables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlAdvanced, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_disable_control_parameter"](arg_param.COM_val))

    def is_control_parameter_enabled(self, param:"AgEVAControlAdvanced") -> bool:
        """Sees if the specified control is enabled."""
        with agmarshall.AgEnum_arg(AgEVAControlAdvanced, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_is_control_parameter_enabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_parameters_available(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_parameters_available"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def override_max_propagation_time(self) -> bool:
        """Override Maximum Propagation Time - if there is a duration or epoch stopping condition that occurs after the maximum propagation time, ignore the maximum propagation time."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_override_max_propagation_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @override_max_propagation_time.setter
    def override_max_propagation_time(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_override_max_propagation_time"](arg_newVal.COM_val))

    @property
    def should_stop_for_initially_surpassed_epoch_stopping_conditions(self) -> bool:
        """Stop immediately if propagation begins beyond an active epoch stopping condition."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_should_stop_for_initially_surpassed_epoch_stopping_conditions"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @should_stop_for_initially_surpassed_epoch_stopping_conditions.setter
    def should_stop_for_initially_surpassed_epoch_stopping_conditions(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_should_stop_for_initially_surpassed_epoch_stopping_conditions"](arg_newVal.COM_val))

    @property
    def should_reinitialize_stm_at_start_of_segment_propagation(self) -> bool:
        """If this segment is propagating the state transition matrix, reset it to the identity matrix at the start of the segment."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_should_reinitialize_stm_at_start_of_segment_propagation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @should_reinitialize_stm_at_start_of_segment_propagation.setter
    def should_reinitialize_stm_at_start_of_segment_propagation(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_should_reinitialize_stm_at_start_of_segment_propagation"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{41E66E06-FD6A-4523-8956-B0DF0BE5479E}", IMissionControlSequencePropagate)
agcls.AgTypeNameMap["IMissionControlSequencePropagate"] = IMissionControlSequencePropagate

class IMissionControlSequenceSequence(object):
    """Properties for a Sequence segment."""
    _uuid = "{0FE48F27-40D3-4D78-9B87-6539D1977696}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_repeat_count"] = _raise_uninitialized_error
        self.__dict__["_set_repeat_count"] = _raise_uninitialized_error
        self.__dict__["_get_generate_ephemeris"] = _raise_uninitialized_error
        self.__dict__["_set_generate_ephemeris"] = _raise_uninitialized_error
        self.__dict__["_get_segments"] = _raise_uninitialized_error
        self.__dict__["_get_sequence_state_to_pass"] = _raise_uninitialized_error
        self.__dict__["_set_sequence_state_to_pass"] = _raise_uninitialized_error
        self.__dict__["_get_scripting_tool"] = _raise_uninitialized_error
        self.__dict__["_apply_script"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMissionControlSequenceSequence._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMissionControlSequenceSequence from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMissionControlSequenceSequence = agcom.GUID(IMissionControlSequenceSequence._uuid)
        vtable_offset_local = IMissionControlSequenceSequence._vtable_offset - 1
        self.__dict__["_get_repeat_count"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSequence, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_repeat_count"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSequence, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_generate_ephemeris"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSequence, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_generate_ephemeris"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSequence, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_get_segments"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSequence, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_sequence_state_to_pass"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSequence, vtable_offset_local+6, POINTER(agcom.LONG))
        self.__dict__["_set_sequence_state_to_pass"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSequence, vtable_offset_local+7, agcom.LONG)
        self.__dict__["_get_scripting_tool"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSequence, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_apply_script"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceSequence, vtable_offset_local+9, )
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissionControlSequenceSequence.__dict__ and type(IMissionControlSequenceSequence.__dict__[attrname]) == property:
            return IMissionControlSequenceSequence.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissionControlSequenceSequence.")
    
    @property
    def repeat_count(self) -> int:
        """The number of times that the sequence will be executed. A sequence that is repeated is executed immediately subsequent to the previous execution of the sequence. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_repeat_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @repeat_count.setter
    def repeat_count(self, newVal:int) -> None:
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_repeat_count"](arg_newVal.COM_val))

    @property
    def generate_ephemeris(self) -> bool:
        """If true, the sequence generates ephemeris and displays it in the 2D and 3D Graphics windows."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_generate_ephemeris"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @generate_ephemeris.setter
    def generate_ephemeris(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_generate_ephemeris"](arg_newVal.COM_val))

    @property
    def segments(self) -> "IMissionControlSequenceSegmentCollection":
        """The list of segments defined for the sequence."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAMCSSegmentCollection:
            agcls.evaluate_hresult(self.__dict__["_get_segments"](byref(arg_ppVAMCSSegmentCollection.COM_val)))
            return arg_ppVAMCSSegmentCollection.python_val

    @property
    def sequence_state_to_pass(self) -> "AgEVASequenceStateToPass":
        """State To Pass To Next Segment - the state of the sequence to pass."""
        with agmarshall.AgEnum_arg(AgEVASequenceStateToPass) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sequence_state_to_pass"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sequence_state_to_pass.setter
    def sequence_state_to_pass(self, inVal:"AgEVASequenceStateToPass") -> None:
        with agmarshall.AgEnum_arg(AgEVASequenceStateToPass, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_sequence_state_to_pass"](arg_inVal.COM_val))

    @property
    def scripting_tool(self) -> "IScriptingTool":
        """Returns the Scripting tool for the sequence."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_scripting_tool"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def apply_script(self) -> None:
        """Apply the script."""
        agcls.evaluate_hresult(self.__dict__["_apply_script"]())


agcls.AgClassCatalog.add_catalog_entry("{0FE48F27-40D3-4D78-9B87-6539D1977696}", IMissionControlSequenceSequence)
agcls.AgTypeNameMap["IMissionControlSequenceSequence"] = IMissionControlSequenceSequence

class IMissionControlSequenceBackwardSequence(IMissionControlSequenceSequence):
    """Properties for a Backward Sequence segment."""
    _uuid = "{F9AF6E49-B8E0-4E5E-91CC-04E622CBC9EF}"
    _num_methods = 0
    _vtable_offset = IMissionControlSequenceSequence._vtable_offset + IMissionControlSequenceSequence._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMissionControlSequenceBackwardSequence._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMissionControlSequenceBackwardSequence from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMissionControlSequenceSequence._private_init(self, pUnk)
        IID_IMissionControlSequenceBackwardSequence = agcom.GUID(IMissionControlSequenceBackwardSequence._uuid)
        vtable_offset_local = IMissionControlSequenceBackwardSequence._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissionControlSequenceBackwardSequence.__dict__ and type(IMissionControlSequenceBackwardSequence.__dict__[attrname]) == property:
            return IMissionControlSequenceBackwardSequence.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IMissionControlSequenceSequence.__setattr__(self, attrname, value)
    

agcls.AgClassCatalog.add_catalog_entry("{F9AF6E49-B8E0-4E5E-91CC-04E622CBC9EF}", IMissionControlSequenceBackwardSequence)
agcls.AgTypeNameMap["IMissionControlSequenceBackwardSequence"] = IMissionControlSequenceBackwardSequence

class IMissionControlSequenceLaunch(object):
    """Properties for a Launch segment."""
    _uuid = "{C342C18C-80EF-4E1F-8363-90181B755E66}"
    _num_methods = 32
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_step_size"] = _raise_uninitialized_error
        self.__dict__["_set_step_size"] = _raise_uninitialized_error
        self.__dict__["_get_pre_launch_time"] = _raise_uninitialized_error
        self.__dict__["_set_pre_launch_time"] = _raise_uninitialized_error
        self.__dict__["_get_epoch"] = _raise_uninitialized_error
        self.__dict__["_set_epoch"] = _raise_uninitialized_error
        self.__dict__["_enable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_disable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_is_control_parameter_enabled"] = _raise_uninitialized_error
        self.__dict__["_get_control_parameters_available"] = _raise_uninitialized_error
        self.__dict__["_get_initial_acceleration"] = _raise_uninitialized_error
        self.__dict__["_set_initial_acceleration"] = _raise_uninitialized_error
        self.__dict__["_get_spacecraft_parameters"] = _raise_uninitialized_error
        self.__dict__["_get_fuel_tank"] = _raise_uninitialized_error
        self.__dict__["_get_display_system_type"] = _raise_uninitialized_error
        self.__dict__["_set_display_system_type"] = _raise_uninitialized_error
        self.__dict__["_get_display_system"] = _raise_uninitialized_error
        self.__dict__["_get_ascent_type"] = _raise_uninitialized_error
        self.__dict__["_set_ascent_type"] = _raise_uninitialized_error
        self.__dict__["_get_time_of_flight"] = _raise_uninitialized_error
        self.__dict__["_set_time_of_flight"] = _raise_uninitialized_error
        self.__dict__["_get_burnout_type"] = _raise_uninitialized_error
        self.__dict__["_set_burnout_type"] = _raise_uninitialized_error
        self.__dict__["_get_burnout"] = _raise_uninitialized_error
        self.__dict__["_get_burnout_velocity"] = _raise_uninitialized_error
        self.__dict__["_get_use_previous_segment_state"] = _raise_uninitialized_error
        self.__dict__["_set_use_previous_segment_state"] = _raise_uninitialized_error
        self.__dict__["_get_set_met_epoch"] = _raise_uninitialized_error
        self.__dict__["_set_set_met_epoch"] = _raise_uninitialized_error
        self.__dict__["_get_user_variables"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMissionControlSequenceLaunch._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMissionControlSequenceLaunch from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMissionControlSequenceLaunch = agcom.GUID(IMissionControlSequenceLaunch._uuid)
        vtable_offset_local = IMissionControlSequenceLaunch._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceLaunch, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceLaunch, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_step_size"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceLaunch, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_step_size"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceLaunch, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_pre_launch_time"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceLaunch, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_pre_launch_time"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceLaunch, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_epoch"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceLaunch, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_set_epoch"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceLaunch, vtable_offset_local+8, agcom.VARIANT)
        self.__dict__["_enable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceLaunch, vtable_offset_local+9, agcom.LONG)
        self.__dict__["_disable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceLaunch, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_is_control_parameter_enabled"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceLaunch, vtable_offset_local+11, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_control_parameters_available"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceLaunch, vtable_offset_local+12, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_initial_acceleration"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceLaunch, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_initial_acceleration"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceLaunch, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_spacecraft_parameters"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceLaunch, vtable_offset_local+15, POINTER(agcom.PVOID))
        self.__dict__["_get_fuel_tank"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceLaunch, vtable_offset_local+16, POINTER(agcom.PVOID))
        self.__dict__["_get_display_system_type"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceLaunch, vtable_offset_local+17, POINTER(agcom.LONG))
        self.__dict__["_set_display_system_type"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceLaunch, vtable_offset_local+18, agcom.LONG)
        self.__dict__["_get_display_system"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceLaunch, vtable_offset_local+19, POINTER(agcom.PVOID))
        self.__dict__["_get_ascent_type"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceLaunch, vtable_offset_local+20, POINTER(agcom.LONG))
        self.__dict__["_set_ascent_type"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceLaunch, vtable_offset_local+21, agcom.LONG)
        self.__dict__["_get_time_of_flight"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceLaunch, vtable_offset_local+22, POINTER(agcom.DOUBLE))
        self.__dict__["_set_time_of_flight"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceLaunch, vtable_offset_local+23, agcom.DOUBLE)
        self.__dict__["_get_burnout_type"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceLaunch, vtable_offset_local+24, POINTER(agcom.LONG))
        self.__dict__["_set_burnout_type"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceLaunch, vtable_offset_local+25, agcom.LONG)
        self.__dict__["_get_burnout"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceLaunch, vtable_offset_local+26, POINTER(agcom.PVOID))
        self.__dict__["_get_burnout_velocity"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceLaunch, vtable_offset_local+27, POINTER(agcom.PVOID))
        self.__dict__["_get_use_previous_segment_state"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceLaunch, vtable_offset_local+28, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_previous_segment_state"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceLaunch, vtable_offset_local+29, agcom.VARIANT_BOOL)
        self.__dict__["_get_set_met_epoch"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceLaunch, vtable_offset_local+30, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_set_met_epoch"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceLaunch, vtable_offset_local+31, agcom.VARIANT_BOOL)
        self.__dict__["_get_user_variables"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceLaunch, vtable_offset_local+32, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissionControlSequenceLaunch.__dict__ and type(IMissionControlSequenceLaunch.__dict__[attrname]) == property:
            return IMissionControlSequenceLaunch.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissionControlSequenceLaunch.")
    
    @property
    def central_body_name(self) -> str:
        """The central body."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_newVal.COM_val))

    @property
    def step_size(self) -> float:
        """The time interval between calculated ephemeris output points. Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_step_size"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @step_size.setter
    def step_size(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_step_size"](arg_newVal.COM_val))

    @property
    def pre_launch_time(self) -> float:
        """The amount of time before the spacecraft's launch that it will be created in the scenario. The vehicle will remain at the launch position until beginning of the launch epoch. Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_pre_launch_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @pre_launch_time.setter
    def pre_launch_time(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_pre_launch_time"](arg_newVal.COM_val))

    @property
    def epoch(self) -> typing.Any:
        """The date and time of the launch. Uses DateFormat Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_epoch"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @epoch.setter
    def epoch(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_epoch"](arg_newVal.COM_val))

    def enable_control_parameter(self, param:"AgEVAControlLaunch") -> None:
        """Enables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlLaunch, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_enable_control_parameter"](arg_param.COM_val))

    def disable_control_parameter(self, param:"AgEVAControlLaunch") -> None:
        """Disables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlLaunch, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_disable_control_parameter"](arg_param.COM_val))

    def is_control_parameter_enabled(self, param:"AgEVAControlLaunch") -> bool:
        """Sees if the specified control is enabled."""
        with agmarshall.AgEnum_arg(AgEVAControlLaunch, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_is_control_parameter_enabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_parameters_available(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_parameters_available"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def initial_acceleration(self) -> float:
        """The initial acceleration, for the Quartic Motion Ascent Type. Uses Acceleration Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_initial_acceleration"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @initial_acceleration.setter
    def initial_acceleration(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_initial_acceleration"](arg_newVal.COM_val))

    @property
    def spacecraft_parameters(self) -> "ISpacecraftParameters":
        """Satellite Properties - the spacecraft's physical properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppVASpacecraftParameters:
            agcls.evaluate_hresult(self.__dict__["_get_spacecraft_parameters"](byref(arg_ppVASpacecraftParameters.COM_val)))
            return arg_ppVASpacecraftParameters.python_val

    @property
    def fuel_tank(self) -> "IFuelTank":
        """The spacecraft's fuel tank properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAFuelTank:
            agcls.evaluate_hresult(self.__dict__["_get_fuel_tank"](byref(arg_ppVAFuelTank.COM_val)))
            return arg_ppVAFuelTank.python_val

    @property
    def display_system_type(self) -> "AgEVALaunchDisplaySystem":
        """The launch coordinate type."""
        with agmarshall.AgEnum_arg(AgEVALaunchDisplaySystem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_display_system_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_display_system_type(self, displaySystemType:"AgEVALaunchDisplaySystem") -> None:
        """Sets the display system type."""
        with agmarshall.AgEnum_arg(AgEVALaunchDisplaySystem, displaySystemType) as arg_displaySystemType:
            agcls.evaluate_hresult(self.__dict__["_set_display_system_type"](arg_displaySystemType.COM_val))

    @property
    def display_system(self) -> "IDisplaySystem":
        """Gets the current Display System."""
        with agmarshall.AgInterface_out_arg() as arg_ppVADisplaySystem:
            agcls.evaluate_hresult(self.__dict__["_get_display_system"](byref(arg_ppVADisplaySystem.COM_val)))
            return arg_ppVADisplaySystem.python_val

    @property
    def ascent_type(self) -> "AgEVAAscentType":
        """The order of the spline used to generate the motion along the ellipse."""
        with agmarshall.AgEnum_arg(AgEVAAscentType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_ascent_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ascent_type.setter
    def ascent_type(self, newVal:"AgEVAAscentType") -> None:
        with agmarshall.AgEnum_arg(AgEVAAscentType, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_ascent_type"](arg_newVal.COM_val))

    @property
    def time_of_flight(self) -> float:
        """The time of flight (the time from launch to burnout). Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_time_of_flight"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @time_of_flight.setter
    def time_of_flight(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_time_of_flight"](arg_newVal.COM_val))

    @property
    def burnout_type(self) -> "AgEVABurnoutType":
        """The burnout type."""
        with agmarshall.AgEnum_arg(AgEVABurnoutType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_burnout_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_burnout_type(self, burnoutType:"AgEVABurnoutType") -> None:
        """Sets the burnout type."""
        with agmarshall.AgEnum_arg(AgEVABurnoutType, burnoutType) as arg_burnoutType:
            agcls.evaluate_hresult(self.__dict__["_set_burnout_type"](arg_burnoutType.COM_val))

    @property
    def burnout(self) -> "IBurnout":
        """The burnout point definition."""
        with agmarshall.AgInterface_out_arg() as arg_ppVABurnout:
            agcls.evaluate_hresult(self.__dict__["_get_burnout"](byref(arg_ppVABurnout.COM_val)))
            return arg_ppVABurnout.python_val

    @property
    def burnout_velocity(self) -> "IBurnoutVelocity":
        """The burnout velocity definition."""
        with agmarshall.AgInterface_out_arg() as arg_ppVABurnoutVelocity:
            agcls.evaluate_hresult(self.__dict__["_get_burnout_velocity"](byref(arg_ppVABurnoutVelocity.COM_val)))
            return arg_ppVABurnoutVelocity.python_val

    @property
    def use_previous_segment_state(self) -> bool:
        """If true, the previous segment state is used to define the launch location parameters."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_previous_segment_state"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_previous_segment_state.setter
    def use_previous_segment_state(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_previous_segment_state"](arg_newVal.COM_val))

    @property
    def set_met_epoch(self) -> bool:
        """If true, the Mission Elapsed Time epoch will be set to the launch epoch."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_set_met_epoch"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @set_met_epoch.setter
    def set_met_epoch(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_set_met_epoch"](arg_newVal.COM_val))

    @property
    def user_variables(self) -> "IUserVariableCollection":
        """Interface used to modify user variables for the launch segment."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_user_variables"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{C342C18C-80EF-4E1F-8363-90181B755E66}", IMissionControlSequenceLaunch)
agcls.AgTypeNameMap["IMissionControlSequenceLaunch"] = IMissionControlSequenceLaunch

class IDisplaySystemGeodetic(IDisplaySystem):
    """Properties for a geodetic launch coordinate system."""
    _uuid = "{3A9597F2-E224-44C9-801F-60CA7A1CB2A1}"
    _num_methods = 6
    _vtable_offset = IDisplaySystem._vtable_offset + IDisplaySystem._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_latitude"] = _raise_uninitialized_error
        self.__dict__["_set_latitude"] = _raise_uninitialized_error
        self.__dict__["_get_longitude"] = _raise_uninitialized_error
        self.__dict__["_set_longitude"] = _raise_uninitialized_error
        self.__dict__["_get_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_altitude"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IDisplaySystemGeodetic._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IDisplaySystemGeodetic from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IDisplaySystem._private_init(self, pUnk)
        IID_IDisplaySystemGeodetic = agcom.GUID(IDisplaySystemGeodetic._uuid)
        vtable_offset_local = IDisplaySystemGeodetic._vtable_offset - 1
        self.__dict__["_get_latitude"] = IAGFUNCTYPE(pUnk, IID_IDisplaySystemGeodetic, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_set_latitude"] = IAGFUNCTYPE(pUnk, IID_IDisplaySystemGeodetic, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_get_longitude"] = IAGFUNCTYPE(pUnk, IID_IDisplaySystemGeodetic, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_set_longitude"] = IAGFUNCTYPE(pUnk, IID_IDisplaySystemGeodetic, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_get_altitude"] = IAGFUNCTYPE(pUnk, IID_IDisplaySystemGeodetic, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude"] = IAGFUNCTYPE(pUnk, IID_IDisplaySystemGeodetic, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IDisplaySystemGeodetic.__dict__ and type(IDisplaySystemGeodetic.__dict__[attrname]) == property:
            return IDisplaySystemGeodetic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IDisplaySystem.__setattr__(self, attrname, value)
    
    @property
    def latitude(self) -> typing.Any:
        """The latitude of the launch location. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_latitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @latitude.setter
    def latitude(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_latitude"](arg_newVal.COM_val))

    @property
    def longitude(self) -> typing.Any:
        """The longitude of the launch location. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_longitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @longitude.setter
    def longitude(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_longitude"](arg_newVal.COM_val))

    @property
    def altitude(self) -> float:
        """The altitude of the launch location. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude.setter
    def altitude(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3A9597F2-E224-44C9-801F-60CA7A1CB2A1}", IDisplaySystemGeodetic)
agcls.AgTypeNameMap["IDisplaySystemGeodetic"] = IDisplaySystemGeodetic

class IDisplaySystemGeocentric(IDisplaySystem):
    """Properties for a geocentric launch coordinate system."""
    _uuid = "{FD9BAAFA-0CDC-481C-A76C-9F25698C468A}"
    _num_methods = 6
    _vtable_offset = IDisplaySystem._vtable_offset + IDisplaySystem._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_latitude"] = _raise_uninitialized_error
        self.__dict__["_set_latitude"] = _raise_uninitialized_error
        self.__dict__["_get_longitude"] = _raise_uninitialized_error
        self.__dict__["_set_longitude"] = _raise_uninitialized_error
        self.__dict__["_get_radius"] = _raise_uninitialized_error
        self.__dict__["_set_radius"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IDisplaySystemGeocentric._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IDisplaySystemGeocentric from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IDisplaySystem._private_init(self, pUnk)
        IID_IDisplaySystemGeocentric = agcom.GUID(IDisplaySystemGeocentric._uuid)
        vtable_offset_local = IDisplaySystemGeocentric._vtable_offset - 1
        self.__dict__["_get_latitude"] = IAGFUNCTYPE(pUnk, IID_IDisplaySystemGeocentric, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_set_latitude"] = IAGFUNCTYPE(pUnk, IID_IDisplaySystemGeocentric, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_get_longitude"] = IAGFUNCTYPE(pUnk, IID_IDisplaySystemGeocentric, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_set_longitude"] = IAGFUNCTYPE(pUnk, IID_IDisplaySystemGeocentric, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_get_radius"] = IAGFUNCTYPE(pUnk, IID_IDisplaySystemGeocentric, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_radius"] = IAGFUNCTYPE(pUnk, IID_IDisplaySystemGeocentric, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IDisplaySystemGeocentric.__dict__ and type(IDisplaySystemGeocentric.__dict__[attrname]) == property:
            return IDisplaySystemGeocentric.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IDisplaySystem.__setattr__(self, attrname, value)
    
    @property
    def latitude(self) -> typing.Any:
        """The latitude of the launch location. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_latitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @latitude.setter
    def latitude(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_latitude"](arg_newVal.COM_val))

    @property
    def longitude(self) -> typing.Any:
        """The longitude of the launch location. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_longitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @longitude.setter
    def longitude(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_longitude"](arg_newVal.COM_val))

    @property
    def radius(self) -> float:
        """The radius of the launch location. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_radius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @radius.setter
    def radius(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_radius"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{FD9BAAFA-0CDC-481C-A76C-9F25698C468A}", IDisplaySystemGeocentric)
agcls.AgTypeNameMap["IDisplaySystemGeocentric"] = IDisplaySystemGeocentric

class IBurnoutCBFCartesian(IBurnout):
    """Properties for a Cartesian CBF burnout state definition."""
    _uuid = "{A45DD94F-A384-4CCB-B803-F29F2DA41A39}"
    _num_methods = 12
    _vtable_offset = IBurnout._vtable_offset + IBurnout._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_cartesian_burnout_x"] = _raise_uninitialized_error
        self.__dict__["_set_cartesian_burnout_x"] = _raise_uninitialized_error
        self.__dict__["_get_cartesian_burnout_y"] = _raise_uninitialized_error
        self.__dict__["_set_cartesian_burnout_y"] = _raise_uninitialized_error
        self.__dict__["_get_cartesian_burnout_z"] = _raise_uninitialized_error
        self.__dict__["_set_cartesian_burnout_z"] = _raise_uninitialized_error
        self.__dict__["_get_cartesian_burnout_vx"] = _raise_uninitialized_error
        self.__dict__["_set_cartesian_burnout_vx"] = _raise_uninitialized_error
        self.__dict__["_get_cartesian_burnout_vy"] = _raise_uninitialized_error
        self.__dict__["_set_cartesian_burnout_vy"] = _raise_uninitialized_error
        self.__dict__["_get_cartesian_burnout_vz"] = _raise_uninitialized_error
        self.__dict__["_set_cartesian_burnout_vz"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBurnoutCBFCartesian._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBurnoutCBFCartesian from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBurnout._private_init(self, pUnk)
        IID_IBurnoutCBFCartesian = agcom.GUID(IBurnoutCBFCartesian._uuid)
        vtable_offset_local = IBurnoutCBFCartesian._vtable_offset - 1
        self.__dict__["_get_cartesian_burnout_x"] = IAGFUNCTYPE(pUnk, IID_IBurnoutCBFCartesian, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_cartesian_burnout_x"] = IAGFUNCTYPE(pUnk, IID_IBurnoutCBFCartesian, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_cartesian_burnout_y"] = IAGFUNCTYPE(pUnk, IID_IBurnoutCBFCartesian, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_cartesian_burnout_y"] = IAGFUNCTYPE(pUnk, IID_IBurnoutCBFCartesian, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_cartesian_burnout_z"] = IAGFUNCTYPE(pUnk, IID_IBurnoutCBFCartesian, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_cartesian_burnout_z"] = IAGFUNCTYPE(pUnk, IID_IBurnoutCBFCartesian, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_cartesian_burnout_vx"] = IAGFUNCTYPE(pUnk, IID_IBurnoutCBFCartesian, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_cartesian_burnout_vx"] = IAGFUNCTYPE(pUnk, IID_IBurnoutCBFCartesian, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_cartesian_burnout_vy"] = IAGFUNCTYPE(pUnk, IID_IBurnoutCBFCartesian, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_cartesian_burnout_vy"] = IAGFUNCTYPE(pUnk, IID_IBurnoutCBFCartesian, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_cartesian_burnout_vz"] = IAGFUNCTYPE(pUnk, IID_IBurnoutCBFCartesian, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_cartesian_burnout_vz"] = IAGFUNCTYPE(pUnk, IID_IBurnoutCBFCartesian, vtable_offset_local+12, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBurnoutCBFCartesian.__dict__ and type(IBurnoutCBFCartesian.__dict__[attrname]) == property:
            return IBurnoutCBFCartesian.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IBurnout.__setattr__(self, attrname, value)
    
    @property
    def cartesian_burnout_x(self) -> float:
        """The CBF x component of the spacecraft burnout location. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_cartesian_burnout_x"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @cartesian_burnout_x.setter
    def cartesian_burnout_x(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_cartesian_burnout_x"](arg_newVal.COM_val))

    @property
    def cartesian_burnout_y(self) -> float:
        """The CBF y component of the spacecraft burnout location. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_cartesian_burnout_y"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @cartesian_burnout_y.setter
    def cartesian_burnout_y(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_cartesian_burnout_y"](arg_newVal.COM_val))

    @property
    def cartesian_burnout_z(self) -> float:
        """The CBF z component of the spacecraft burnout location. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_cartesian_burnout_z"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @cartesian_burnout_z.setter
    def cartesian_burnout_z(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_cartesian_burnout_z"](arg_newVal.COM_val))

    @property
    def cartesian_burnout_vx(self) -> float:
        """The CBF x component of the spacecraft burnout velocity. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_cartesian_burnout_vx"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @cartesian_burnout_vx.setter
    def cartesian_burnout_vx(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_cartesian_burnout_vx"](arg_newVal.COM_val))

    @property
    def cartesian_burnout_vy(self) -> float:
        """The CBF y component of the spacecraft burnout velocity. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_cartesian_burnout_vy"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @cartesian_burnout_vy.setter
    def cartesian_burnout_vy(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_cartesian_burnout_vy"](arg_newVal.COM_val))

    @property
    def cartesian_burnout_vz(self) -> float:
        """The CBF z component of the spacecraft burnout velocity. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_cartesian_burnout_vz"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @cartesian_burnout_vz.setter
    def cartesian_burnout_vz(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_cartesian_burnout_vz"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{A45DD94F-A384-4CCB-B803-F29F2DA41A39}", IBurnoutCBFCartesian)
agcls.AgTypeNameMap["IBurnoutCBFCartesian"] = IBurnoutCBFCartesian

class IBurnoutGeodetic(IBurnout):
    """Properties for a geodetic burnout point definition."""
    _uuid = "{CA74E0CB-01D7-4D65-BC0D-82A469B5E320}"
    _num_methods = 6
    _vtable_offset = IBurnout._vtable_offset + IBurnout._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_latitude"] = _raise_uninitialized_error
        self.__dict__["_set_latitude"] = _raise_uninitialized_error
        self.__dict__["_get_longitude"] = _raise_uninitialized_error
        self.__dict__["_set_longitude"] = _raise_uninitialized_error
        self.__dict__["_get_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_altitude"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBurnoutGeodetic._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBurnoutGeodetic from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBurnout._private_init(self, pUnk)
        IID_IBurnoutGeodetic = agcom.GUID(IBurnoutGeodetic._uuid)
        vtable_offset_local = IBurnoutGeodetic._vtable_offset - 1
        self.__dict__["_get_latitude"] = IAGFUNCTYPE(pUnk, IID_IBurnoutGeodetic, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_set_latitude"] = IAGFUNCTYPE(pUnk, IID_IBurnoutGeodetic, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_get_longitude"] = IAGFUNCTYPE(pUnk, IID_IBurnoutGeodetic, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_set_longitude"] = IAGFUNCTYPE(pUnk, IID_IBurnoutGeodetic, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_get_altitude"] = IAGFUNCTYPE(pUnk, IID_IBurnoutGeodetic, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude"] = IAGFUNCTYPE(pUnk, IID_IBurnoutGeodetic, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBurnoutGeodetic.__dict__ and type(IBurnoutGeodetic.__dict__[attrname]) == property:
            return IBurnoutGeodetic.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IBurnout.__setattr__(self, attrname, value)
    
    @property
    def latitude(self) -> typing.Any:
        """The latitude of the spacecraft burnout. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_latitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @latitude.setter
    def latitude(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_latitude"](arg_newVal.COM_val))

    @property
    def longitude(self) -> typing.Any:
        """The longitude of the spacecraft burnout. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_longitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @longitude.setter
    def longitude(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_longitude"](arg_newVal.COM_val))

    @property
    def altitude(self) -> float:
        """The altitude of the spacecraft burnout. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude.setter
    def altitude(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{CA74E0CB-01D7-4D65-BC0D-82A469B5E320}", IBurnoutGeodetic)
agcls.AgTypeNameMap["IBurnoutGeodetic"] = IBurnoutGeodetic

class IBurnoutGeocentric(IBurnout):
    """{Properties for a geocentric burnout point definition."""
    _uuid = "{BFFA4B30-4A19-4FF9-849D-E6DD6534116D}"
    _num_methods = 6
    _vtable_offset = IBurnout._vtable_offset + IBurnout._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_latitude"] = _raise_uninitialized_error
        self.__dict__["_set_latitude"] = _raise_uninitialized_error
        self.__dict__["_get_longitude"] = _raise_uninitialized_error
        self.__dict__["_set_longitude"] = _raise_uninitialized_error
        self.__dict__["_get_radius"] = _raise_uninitialized_error
        self.__dict__["_set_radius"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBurnoutGeocentric._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBurnoutGeocentric from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBurnout._private_init(self, pUnk)
        IID_IBurnoutGeocentric = agcom.GUID(IBurnoutGeocentric._uuid)
        vtable_offset_local = IBurnoutGeocentric._vtable_offset - 1
        self.__dict__["_get_latitude"] = IAGFUNCTYPE(pUnk, IID_IBurnoutGeocentric, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_set_latitude"] = IAGFUNCTYPE(pUnk, IID_IBurnoutGeocentric, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_get_longitude"] = IAGFUNCTYPE(pUnk, IID_IBurnoutGeocentric, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_set_longitude"] = IAGFUNCTYPE(pUnk, IID_IBurnoutGeocentric, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_get_radius"] = IAGFUNCTYPE(pUnk, IID_IBurnoutGeocentric, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_radius"] = IAGFUNCTYPE(pUnk, IID_IBurnoutGeocentric, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBurnoutGeocentric.__dict__ and type(IBurnoutGeocentric.__dict__[attrname]) == property:
            return IBurnoutGeocentric.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IBurnout.__setattr__(self, attrname, value)
    
    @property
    def latitude(self) -> typing.Any:
        """The latitude of the spacecraft burnout. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_latitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @latitude.setter
    def latitude(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_latitude"](arg_newVal.COM_val))

    @property
    def longitude(self) -> typing.Any:
        """The longitude of the spacecraft burnout. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_longitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @longitude.setter
    def longitude(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_longitude"](arg_newVal.COM_val))

    @property
    def radius(self) -> float:
        """The radius of the spacecraft burnout. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_radius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @radius.setter
    def radius(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_radius"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{BFFA4B30-4A19-4FF9-849D-E6DD6534116D}", IBurnoutGeocentric)
agcls.AgTypeNameMap["IBurnoutGeocentric"] = IBurnoutGeocentric

class IBurnoutLaunchAzAltitude(IBurnout):
    """Properties for a launch azimuth / altitude burnout point definition."""
    _uuid = "{FCE8CBAF-46BE-4F76-AB1A-E2116127A402}"
    _num_methods = 6
    _vtable_offset = IBurnout._vtable_offset + IBurnout._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_azimuth"] = _raise_uninitialized_error
        self.__dict__["_set_azimuth"] = _raise_uninitialized_error
        self.__dict__["_get_down_range_dist"] = _raise_uninitialized_error
        self.__dict__["_set_down_range_dist"] = _raise_uninitialized_error
        self.__dict__["_get_altitude_radius"] = _raise_uninitialized_error
        self.__dict__["_set_altitude_radius"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBurnoutLaunchAzAltitude._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBurnoutLaunchAzAltitude from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBurnout._private_init(self, pUnk)
        IID_IBurnoutLaunchAzAltitude = agcom.GUID(IBurnoutLaunchAzAltitude._uuid)
        vtable_offset_local = IBurnoutLaunchAzAltitude._vtable_offset - 1
        self.__dict__["_get_azimuth"] = IAGFUNCTYPE(pUnk, IID_IBurnoutLaunchAzAltitude, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_set_azimuth"] = IAGFUNCTYPE(pUnk, IID_IBurnoutLaunchAzAltitude, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_get_down_range_dist"] = IAGFUNCTYPE(pUnk, IID_IBurnoutLaunchAzAltitude, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_down_range_dist"] = IAGFUNCTYPE(pUnk, IID_IBurnoutLaunchAzAltitude, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_altitude_radius"] = IAGFUNCTYPE(pUnk, IID_IBurnoutLaunchAzAltitude, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_altitude_radius"] = IAGFUNCTYPE(pUnk, IID_IBurnoutLaunchAzAltitude, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBurnoutLaunchAzAltitude.__dict__ and type(IBurnoutLaunchAzAltitude.__dict__[attrname]) == property:
            return IBurnoutLaunchAzAltitude.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IBurnout.__setattr__(self, attrname, value)
    
    @property
    def azimuth(self) -> typing.Any:
        """The azimuth of the launch trajectory. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_azimuth"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @azimuth.setter
    def azimuth(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_azimuth"](arg_newVal.COM_val))

    @property
    def down_range_dist(self) -> float:
        """The downrange distance of the spacecraft from launch at burnout. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_down_range_dist"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @down_range_dist.setter
    def down_range_dist(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_down_range_dist"](arg_newVal.COM_val))

    @property
    def altitude_radius(self) -> float:
        """The altitude of the spacecraft at burnout. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_altitude_radius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @altitude_radius.setter
    def altitude_radius(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_altitude_radius"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{FCE8CBAF-46BE-4F76-AB1A-E2116127A402}", IBurnoutLaunchAzAltitude)
agcls.AgTypeNameMap["IBurnoutLaunchAzAltitude"] = IBurnoutLaunchAzAltitude

class IBurnoutLaunchAzRadius(IBurnout):
    """Properties for a launch azimuth / radius burnout point definition."""
    _uuid = "{623DDE08-539E-4BAD-A63D-FCC195094F14}"
    _num_methods = 6
    _vtable_offset = IBurnout._vtable_offset + IBurnout._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_azimuth"] = _raise_uninitialized_error
        self.__dict__["_set_azimuth"] = _raise_uninitialized_error
        self.__dict__["_get_down_range_dist"] = _raise_uninitialized_error
        self.__dict__["_set_down_range_dist"] = _raise_uninitialized_error
        self.__dict__["_get_radius"] = _raise_uninitialized_error
        self.__dict__["_set_radius"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBurnoutLaunchAzRadius._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBurnoutLaunchAzRadius from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBurnout._private_init(self, pUnk)
        IID_IBurnoutLaunchAzRadius = agcom.GUID(IBurnoutLaunchAzRadius._uuid)
        vtable_offset_local = IBurnoutLaunchAzRadius._vtable_offset - 1
        self.__dict__["_get_azimuth"] = IAGFUNCTYPE(pUnk, IID_IBurnoutLaunchAzRadius, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_set_azimuth"] = IAGFUNCTYPE(pUnk, IID_IBurnoutLaunchAzRadius, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_get_down_range_dist"] = IAGFUNCTYPE(pUnk, IID_IBurnoutLaunchAzRadius, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_down_range_dist"] = IAGFUNCTYPE(pUnk, IID_IBurnoutLaunchAzRadius, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_radius"] = IAGFUNCTYPE(pUnk, IID_IBurnoutLaunchAzRadius, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_radius"] = IAGFUNCTYPE(pUnk, IID_IBurnoutLaunchAzRadius, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBurnoutLaunchAzRadius.__dict__ and type(IBurnoutLaunchAzRadius.__dict__[attrname]) == property:
            return IBurnoutLaunchAzRadius.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IBurnout.__setattr__(self, attrname, value)
    
    @property
    def azimuth(self) -> typing.Any:
        """The azimuth of the launch trajectory. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_azimuth"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @azimuth.setter
    def azimuth(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_azimuth"](arg_newVal.COM_val))

    @property
    def down_range_dist(self) -> float:
        """The downrange distance of the spacecraft from launch at burnout. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_down_range_dist"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @down_range_dist.setter
    def down_range_dist(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_down_range_dist"](arg_newVal.COM_val))

    @property
    def radius(self) -> float:
        """The radius of the spacecraft at burnout. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_radius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @radius.setter
    def radius(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_radius"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{623DDE08-539E-4BAD-A63D-FCC195094F14}", IBurnoutLaunchAzRadius)
agcls.AgTypeNameMap["IBurnoutLaunchAzRadius"] = IBurnoutLaunchAzRadius

class IMissionControlSequenceFollow(object):
    """Properties for a Follow segment."""
    _uuid = "{88C0BA74-B2B8-4B69-85B5-94B6CC7DEACE}"
    _num_methods = 22
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_leader"] = _raise_uninitialized_error
        self.__dict__["_get_x_offset"] = _raise_uninitialized_error
        self.__dict__["_set_x_offset"] = _raise_uninitialized_error
        self.__dict__["_get_y_offset"] = _raise_uninitialized_error
        self.__dict__["_set_y_offset"] = _raise_uninitialized_error
        self.__dict__["_get_z_offset"] = _raise_uninitialized_error
        self.__dict__["_set_z_offset"] = _raise_uninitialized_error
        self.__dict__["_get_separation_conditions"] = _raise_uninitialized_error
        self.__dict__["_get_spacecraft_parameters"] = _raise_uninitialized_error
        self.__dict__["_get_fuel_tank"] = _raise_uninitialized_error
        self.__dict__["_get_joining_type"] = _raise_uninitialized_error
        self.__dict__["_set_joining_type"] = _raise_uninitialized_error
        self.__dict__["_get_separation_type"] = _raise_uninitialized_error
        self.__dict__["_set_separation_type"] = _raise_uninitialized_error
        self.__dict__["_get_spacecraft_and_fuel_tank_type"] = _raise_uninitialized_error
        self.__dict__["_set_spacecraft_and_fuel_tank_type"] = _raise_uninitialized_error
        self.__dict__["_get_joining_conditions"] = _raise_uninitialized_error
        self.__dict__["_enable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_disable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_is_control_parameter_enabled"] = _raise_uninitialized_error
        self.__dict__["_get_control_parameters_available"] = _raise_uninitialized_error
        self.__dict__["_get_user_variables"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMissionControlSequenceFollow._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMissionControlSequenceFollow from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMissionControlSequenceFollow = agcom.GUID(IMissionControlSequenceFollow._uuid)
        vtable_offset_local = IMissionControlSequenceFollow._vtable_offset - 1
        self.__dict__["_get_leader"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceFollow, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_x_offset"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceFollow, vtable_offset_local+2, POINTER(agcom.DOUBLE))
        self.__dict__["_set_x_offset"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceFollow, vtable_offset_local+3, agcom.DOUBLE)
        self.__dict__["_get_y_offset"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceFollow, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_set_y_offset"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceFollow, vtable_offset_local+5, agcom.DOUBLE)
        self.__dict__["_get_z_offset"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceFollow, vtable_offset_local+6, POINTER(agcom.DOUBLE))
        self.__dict__["_set_z_offset"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceFollow, vtable_offset_local+7, agcom.DOUBLE)
        self.__dict__["_get_separation_conditions"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceFollow, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_get_spacecraft_parameters"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceFollow, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_get_fuel_tank"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceFollow, vtable_offset_local+10, POINTER(agcom.PVOID))
        self.__dict__["_get_joining_type"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceFollow, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_set_joining_type"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceFollow, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_get_separation_type"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceFollow, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_set_separation_type"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceFollow, vtable_offset_local+14, agcom.LONG)
        self.__dict__["_get_spacecraft_and_fuel_tank_type"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceFollow, vtable_offset_local+15, POINTER(agcom.LONG))
        self.__dict__["_set_spacecraft_and_fuel_tank_type"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceFollow, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_get_joining_conditions"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceFollow, vtable_offset_local+17, POINTER(agcom.PVOID))
        self.__dict__["_enable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceFollow, vtable_offset_local+18, agcom.LONG)
        self.__dict__["_disable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceFollow, vtable_offset_local+19, agcom.LONG)
        self.__dict__["_is_control_parameter_enabled"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceFollow, vtable_offset_local+20, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_control_parameters_available"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceFollow, vtable_offset_local+21, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_user_variables"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceFollow, vtable_offset_local+22, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissionControlSequenceFollow.__dict__ and type(IMissionControlSequenceFollow.__dict__[attrname]) == property:
            return IMissionControlSequenceFollow.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissionControlSequenceFollow.")
    
    @property
    def leader(self) -> "ILinkToObject":
        """The leader object."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_get_leader"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val

    @property
    def x_offset(self) -> float:
        """The distance that the spacecraft will be offset from the leader's body frame along the X axis. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_x_offset"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @x_offset.setter
    def x_offset(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_x_offset"](arg_newVal.COM_val))

    @property
    def y_offset(self) -> float:
        """The distance that the spacecraft will be offset from the leader's body frame along the Y axis. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_y_offset"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @y_offset.setter
    def y_offset(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_y_offset"](arg_newVal.COM_val))

    @property
    def z_offset(self) -> float:
        """The distance that the spacecraft will be offset from the leader's body frame along the Z axis. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_z_offset"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @z_offset.setter
    def z_offset(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_z_offset"](arg_newVal.COM_val))

    @property
    def separation_conditions(self) -> "IStoppingConditionCollection":
        """If separation conditions are specified, the list of separation conditions."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAStoppingConditionCollection:
            agcls.evaluate_hresult(self.__dict__["_get_separation_conditions"](byref(arg_ppVAStoppingConditionCollection.COM_val)))
            return arg_ppVAStoppingConditionCollection.python_val

    @property
    def spacecraft_parameters(self) -> "ISpacecraftParameters":
        """The spacecraft's physical properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppVASpacecraftParameters:
            agcls.evaluate_hresult(self.__dict__["_get_spacecraft_parameters"](byref(arg_ppVASpacecraftParameters.COM_val)))
            return arg_ppVASpacecraftParameters.python_val

    @property
    def fuel_tank(self) -> "IFuelTank":
        """The spacecraft's fuel tank properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAFuelTank:
            agcls.evaluate_hresult(self.__dict__["_get_fuel_tank"](byref(arg_ppVAFuelTank.COM_val)))
            return arg_ppVAFuelTank.python_val

    @property
    def joining_type(self) -> "AgEVAFollowJoin":
        """The joining type."""
        with agmarshall.AgEnum_arg(AgEVAFollowJoin) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_joining_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @joining_type.setter
    def joining_type(self, newVal:"AgEVAFollowJoin") -> None:
        with agmarshall.AgEnum_arg(AgEVAFollowJoin, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_joining_type"](arg_newVal.COM_val))

    @property
    def separation_type(self) -> "AgEVAFollowSeparation":
        """The separation type."""
        with agmarshall.AgEnum_arg(AgEVAFollowSeparation) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_separation_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @separation_type.setter
    def separation_type(self, newVal:"AgEVAFollowSeparation") -> None:
        with agmarshall.AgEnum_arg(AgEVAFollowSeparation, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_separation_type"](arg_newVal.COM_val))

    @property
    def spacecraft_and_fuel_tank_type(self) -> "AgEVAFollowSpacecraftAndFuelTank":
        """The spacecraft snd fuel tank configuration type."""
        with agmarshall.AgEnum_arg(AgEVAFollowSpacecraftAndFuelTank) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_spacecraft_and_fuel_tank_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @spacecraft_and_fuel_tank_type.setter
    def spacecraft_and_fuel_tank_type(self, newVal:"AgEVAFollowSpacecraftAndFuelTank") -> None:
        with agmarshall.AgEnum_arg(AgEVAFollowSpacecraftAndFuelTank, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_spacecraft_and_fuel_tank_type"](arg_newVal.COM_val))

    @property
    def joining_conditions(self) -> "IStoppingConditionCollection":
        """If joining conditions are specified, the list of joining conditions."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAStoppingConditionCollection:
            agcls.evaluate_hresult(self.__dict__["_get_joining_conditions"](byref(arg_ppVAStoppingConditionCollection.COM_val)))
            return arg_ppVAStoppingConditionCollection.python_val

    def enable_control_parameter(self, param:"AgEVAControlFollow") -> None:
        """Enables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlFollow, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_enable_control_parameter"](arg_param.COM_val))

    def disable_control_parameter(self, param:"AgEVAControlFollow") -> None:
        """Disables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlFollow, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_disable_control_parameter"](arg_param.COM_val))

    def is_control_parameter_enabled(self, param:"AgEVAControlFollow") -> bool:
        """Sees if the specified control is enabled."""
        with agmarshall.AgEnum_arg(AgEVAControlFollow, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_is_control_parameter_enabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_parameters_available(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_parameters_available"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def user_variables(self) -> "IUserVariableCollection":
        """Interface used to modify user variables for the follow segment."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_user_variables"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{88C0BA74-B2B8-4B69-85B5-94B6CC7DEACE}", IMissionControlSequenceFollow)
agcls.AgTypeNameMap["IMissionControlSequenceFollow"] = IMissionControlSequenceFollow

class IMissionControlSequenceManeuver(object):
    """General properties for a Maneuver segment."""
    _uuid = "{B640A28E-36A1-4934-ABC6-1A74C1A1B9E5}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_maneuver_type"] = _raise_uninitialized_error
        self.__dict__["_set_maneuver_type"] = _raise_uninitialized_error
        self.__dict__["_get_maneuver"] = _raise_uninitialized_error
        self.__dict__["_enable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_disable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_is_control_parameter_enabled"] = _raise_uninitialized_error
        self.__dict__["_get_control_parameters_available"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMissionControlSequenceManeuver._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMissionControlSequenceManeuver from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMissionControlSequenceManeuver = agcom.GUID(IMissionControlSequenceManeuver._uuid)
        vtable_offset_local = IMissionControlSequenceManeuver._vtable_offset - 1
        self.__dict__["_get_maneuver_type"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceManeuver, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_maneuver_type"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceManeuver, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_maneuver"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceManeuver, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_enable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceManeuver, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_disable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceManeuver, vtable_offset_local+5, agcom.LONG)
        self.__dict__["_is_control_parameter_enabled"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceManeuver, vtable_offset_local+6, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_control_parameters_available"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceManeuver, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissionControlSequenceManeuver.__dict__ and type(IMissionControlSequenceManeuver.__dict__[attrname]) == property:
            return IMissionControlSequenceManeuver.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissionControlSequenceManeuver.")
    
    @property
    def maneuver_type(self) -> "AgEVAManeuverType":
        """The maneuver type."""
        with agmarshall.AgEnum_arg(AgEVAManeuverType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_maneuver_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_maneuver_type(self, maneuverType:"AgEVAManeuverType") -> None:
        """Sets the maneuver type"""
        with agmarshall.AgEnum_arg(AgEVAManeuverType, maneuverType) as arg_maneuverType:
            agcls.evaluate_hresult(self.__dict__["_set_maneuver_type"](arg_maneuverType.COM_val))

    @property
    def maneuver(self) -> "IManeuver":
        """The Maneuver properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAManeuver:
            agcls.evaluate_hresult(self.__dict__["_get_maneuver"](byref(arg_ppVAManeuver.COM_val)))
            return arg_ppVAManeuver.python_val

    def enable_control_parameter(self, param:"AgEVAControlManeuver") -> None:
        """Enables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlManeuver, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_enable_control_parameter"](arg_param.COM_val))

    def disable_control_parameter(self, param:"AgEVAControlManeuver") -> None:
        """Disables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlManeuver, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_disable_control_parameter"](arg_param.COM_val))

    def is_control_parameter_enabled(self, param:"AgEVAControlManeuver") -> bool:
        """Sees if the specified control is enabled."""
        with agmarshall.AgEnum_arg(AgEVAControlManeuver, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_is_control_parameter_enabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_parameters_available(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_parameters_available"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{B640A28E-36A1-4934-ABC6-1A74C1A1B9E5}", IMissionControlSequenceManeuver)
agcls.AgTypeNameMap["IMissionControlSequenceManeuver"] = IMissionControlSequenceManeuver

class IManeuverFinite(IManeuver):
    """Engine properties for a Finite Maneuver."""
    _uuid = "{2BE095B5-A674-4868-9178-6ADB00753CBF}"
    _num_methods = 7
    _vtable_offset = IManeuver._vtable_offset + IManeuver._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_pressure_mode"] = _raise_uninitialized_error
        self.__dict__["_set_pressure_mode"] = _raise_uninitialized_error
        self.__dict__["_get_thrust_efficiency"] = _raise_uninitialized_error
        self.__dict__["_set_thrust_efficiency"] = _raise_uninitialized_error
        self.__dict__["_get_thrust_efficiency_mode"] = _raise_uninitialized_error
        self.__dict__["_set_thrust_efficiency_mode"] = _raise_uninitialized_error
        self.__dict__["_get_propagator"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IManeuverFinite._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IManeuverFinite from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IManeuver._private_init(self, pUnk)
        IID_IManeuverFinite = agcom.GUID(IManeuverFinite._uuid)
        vtable_offset_local = IManeuverFinite._vtable_offset - 1
        self.__dict__["_get_pressure_mode"] = IAGFUNCTYPE(pUnk, IID_IManeuverFinite, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_pressure_mode"] = IAGFUNCTYPE(pUnk, IID_IManeuverFinite, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_thrust_efficiency"] = IAGFUNCTYPE(pUnk, IID_IManeuverFinite, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_thrust_efficiency"] = IAGFUNCTYPE(pUnk, IID_IManeuverFinite, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_thrust_efficiency_mode"] = IAGFUNCTYPE(pUnk, IID_IManeuverFinite, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_thrust_efficiency_mode"] = IAGFUNCTYPE(pUnk, IID_IManeuverFinite, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_propagator"] = IAGFUNCTYPE(pUnk, IID_IManeuverFinite, vtable_offset_local+7, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IManeuverFinite.__dict__ and type(IManeuverFinite.__dict__[attrname]) == property:
            return IManeuverFinite.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IManeuver.__setattr__(self, attrname, value)
    
    @property
    def pressure_mode(self) -> "AgEVAPressureMode":
        """The pressure mode."""
        with agmarshall.AgEnum_arg(AgEVAPressureMode) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_pressure_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @pressure_mode.setter
    def pressure_mode(self, newVal:"AgEVAPressureMode") -> None:
        with agmarshall.AgEnum_arg(AgEVAPressureMode, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_pressure_mode"](arg_newVal.COM_val))

    @property
    def thrust_efficiency(self) -> float:
        """The thrust efficiency value. Any number above zero is valid, with typical values around 0.98 to 1.02. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_thrust_efficiency"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @thrust_efficiency.setter
    def thrust_efficiency(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_thrust_efficiency"](arg_newVal.COM_val))

    @property
    def thrust_efficiency_mode(self) -> "AgEVAThrustType":
        """Thrust - the calculations that are effected by the thrust efficiency value."""
        with agmarshall.AgEnum_arg(AgEVAThrustType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_thrust_efficiency_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @thrust_efficiency_mode.setter
    def thrust_efficiency_mode(self, newVal:"AgEVAThrustType") -> None:
        with agmarshall.AgEnum_arg(AgEVAThrustType, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_thrust_efficiency_mode"](arg_newVal.COM_val))

    @property
    def propagator(self) -> "IManeuverFinitePropagator":
        """The propagator."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAManeuverFinitePropagator:
            agcls.evaluate_hresult(self.__dict__["_get_propagator"](byref(arg_ppVAManeuverFinitePropagator.COM_val)))
            return arg_ppVAManeuverFinitePropagator.python_val


agcls.AgClassCatalog.add_catalog_entry("{2BE095B5-A674-4868-9178-6ADB00753CBF}", IManeuverFinite)
agcls.AgTypeNameMap["IManeuverFinite"] = IManeuverFinite

class IManeuverImpulsive(IManeuver):
    """Properties for an Impulsive Maneuver."""
    _uuid = "{41595314-A798-41ED-80DD-0DA873CCF8A0}"
    _num_methods = 2
    _vtable_offset = IManeuver._vtable_offset + IManeuver._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_update_mass"] = _raise_uninitialized_error
        self.__dict__["_set_update_mass"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IManeuverImpulsive._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IManeuverImpulsive from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IManeuver._private_init(self, pUnk)
        IID_IManeuverImpulsive = agcom.GUID(IManeuverImpulsive._uuid)
        vtable_offset_local = IManeuverImpulsive._vtable_offset - 1
        self.__dict__["_get_update_mass"] = IAGFUNCTYPE(pUnk, IID_IManeuverImpulsive, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_update_mass"] = IAGFUNCTYPE(pUnk, IID_IManeuverImpulsive, vtable_offset_local+2, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IManeuverImpulsive.__dict__ and type(IManeuverImpulsive.__dict__[attrname]) == property:
            return IManeuverImpulsive.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IManeuver.__setattr__(self, attrname, value)
    
    @property
    def update_mass(self) -> bool:
        """True if the mass of the spacecraft will be updated on the basis of fuel usage."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_update_mass"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @update_mass.setter
    def update_mass(self, pVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_update_mass"](arg_pVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{41595314-A798-41ED-80DD-0DA873CCF8A0}", IManeuverImpulsive)
agcls.AgTypeNameMap["IManeuverImpulsive"] = IManeuverImpulsive

class IAttitudeControlImpulsiveVelocityVector(IAttitudeControlImpulsive):
    """Properties for the Velocity Vector attitude control for an Impulsive Maneuver."""
    _uuid = "{EF098B53-D99D-4AB6-A227-DED98E48B4DB}"
    _num_methods = 3
    _vtable_offset = IAttitudeControlImpulsive._vtable_offset + IAttitudeControlImpulsive._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_delta_v_magnitude"] = _raise_uninitialized_error
        self.__dict__["_set_delta_v_magnitude"] = _raise_uninitialized_error
        self.__dict__["_get_body_constraint_vector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAttitudeControlImpulsiveVelocityVector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAttitudeControlImpulsiveVelocityVector from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAttitudeControlImpulsive._private_init(self, pUnk)
        IID_IAttitudeControlImpulsiveVelocityVector = agcom.GUID(IAttitudeControlImpulsiveVelocityVector._uuid)
        vtable_offset_local = IAttitudeControlImpulsiveVelocityVector._vtable_offset - 1
        self.__dict__["_get_delta_v_magnitude"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveVelocityVector, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_delta_v_magnitude"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveVelocityVector, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_body_constraint_vector"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveVelocityVector, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAttitudeControlImpulsiveVelocityVector.__dict__ and type(IAttitudeControlImpulsiveVelocityVector.__dict__[attrname]) == property:
            return IAttitudeControlImpulsiveVelocityVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IAttitudeControlImpulsive.__setattr__(self, attrname, value)
    
    @property
    def delta_v_magnitude(self) -> float:
        """The size of the delta-V to be applied to the orbit along the velocity vector. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_delta_v_magnitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @delta_v_magnitude.setter
    def delta_v_magnitude(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_delta_v_magnitude"](arg_newVal.COM_val))

    @property
    def body_constraint_vector(self) -> "IDirection":
        """Defines a constraint vector in spacecraft body coordinates to complete the attitude definition."""
        with agmarshall.AgInterface_out_arg() as arg_ppDirection:
            agcls.evaluate_hresult(self.__dict__["_get_body_constraint_vector"](byref(arg_ppDirection.COM_val)))
            return arg_ppDirection.python_val


agcls.AgClassCatalog.add_catalog_entry("{EF098B53-D99D-4AB6-A227-DED98E48B4DB}", IAttitudeControlImpulsiveVelocityVector)
agcls.AgTypeNameMap["IAttitudeControlImpulsiveVelocityVector"] = IAttitudeControlImpulsiveVelocityVector

class IAttitudeControlImpulsiveAntiVelocityVector(IAttitudeControlImpulsive):
    """Properties for the Anti-Velocity Vector attitude control for an Impulsive Maneuver."""
    _uuid = "{711B2692-73A2-4C08-9AF3-CC1F93317DF2}"
    _num_methods = 3
    _vtable_offset = IAttitudeControlImpulsive._vtable_offset + IAttitudeControlImpulsive._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_delta_v_magnitude"] = _raise_uninitialized_error
        self.__dict__["_set_delta_v_magnitude"] = _raise_uninitialized_error
        self.__dict__["_get_body_constraint_vector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAttitudeControlImpulsiveAntiVelocityVector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAttitudeControlImpulsiveAntiVelocityVector from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAttitudeControlImpulsive._private_init(self, pUnk)
        IID_IAttitudeControlImpulsiveAntiVelocityVector = agcom.GUID(IAttitudeControlImpulsiveAntiVelocityVector._uuid)
        vtable_offset_local = IAttitudeControlImpulsiveAntiVelocityVector._vtable_offset - 1
        self.__dict__["_get_delta_v_magnitude"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveAntiVelocityVector, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_delta_v_magnitude"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveAntiVelocityVector, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_body_constraint_vector"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveAntiVelocityVector, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAttitudeControlImpulsiveAntiVelocityVector.__dict__ and type(IAttitudeControlImpulsiveAntiVelocityVector.__dict__[attrname]) == property:
            return IAttitudeControlImpulsiveAntiVelocityVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IAttitudeControlImpulsive.__setattr__(self, attrname, value)
    
    @property
    def delta_v_magnitude(self) -> float:
        """The size of the delta-V to be applied to the orbit along the velocity vector. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_delta_v_magnitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @delta_v_magnitude.setter
    def delta_v_magnitude(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_delta_v_magnitude"](arg_newVal.COM_val))

    @property
    def body_constraint_vector(self) -> "IDirection":
        """Defines a constraint vector in spacecraft body coordinates to complete the attitude definition."""
        with agmarshall.AgInterface_out_arg() as arg_ppDirection:
            agcls.evaluate_hresult(self.__dict__["_get_body_constraint_vector"](byref(arg_ppDirection.COM_val)))
            return arg_ppDirection.python_val


agcls.AgClassCatalog.add_catalog_entry("{711B2692-73A2-4C08-9AF3-CC1F93317DF2}", IAttitudeControlImpulsiveAntiVelocityVector)
agcls.AgTypeNameMap["IAttitudeControlImpulsiveAntiVelocityVector"] = IAttitudeControlImpulsiveAntiVelocityVector

class IAttitudeControlImpulsiveAttitude(IAttitudeControlImpulsive):
    """Properties for the Attitude attitude control for an Impulsive Maneuver."""
    _uuid = "{D9334B8B-9016-4F73-A134-0C61C91060E1}"
    _num_methods = 5
    _vtable_offset = IAttitudeControlImpulsive._vtable_offset + IAttitudeControlImpulsive._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_delta_v_magnitude"] = _raise_uninitialized_error
        self.__dict__["_set_delta_v_magnitude"] = _raise_uninitialized_error
        self.__dict__["_get_ref_axes_name"] = _raise_uninitialized_error
        self.__dict__["_set_ref_axes_name"] = _raise_uninitialized_error
        self.__dict__["_get_orientation"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAttitudeControlImpulsiveAttitude._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAttitudeControlImpulsiveAttitude from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAttitudeControlImpulsive._private_init(self, pUnk)
        IID_IAttitudeControlImpulsiveAttitude = agcom.GUID(IAttitudeControlImpulsiveAttitude._uuid)
        vtable_offset_local = IAttitudeControlImpulsiveAttitude._vtable_offset - 1
        self.__dict__["_get_delta_v_magnitude"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveAttitude, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_delta_v_magnitude"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveAttitude, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_ref_axes_name"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveAttitude, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_ref_axes_name"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveAttitude, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_get_orientation"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveAttitude, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAttitudeControlImpulsiveAttitude.__dict__ and type(IAttitudeControlImpulsiveAttitude.__dict__[attrname]) == property:
            return IAttitudeControlImpulsiveAttitude.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IAttitudeControlImpulsive.__setattr__(self, attrname, value)
    
    @property
    def delta_v_magnitude(self) -> float:
        """The size of the delta-V to be applied along the X axis - as defined by the selected axes and rotation. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_delta_v_magnitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @delta_v_magnitude.setter
    def delta_v_magnitude(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_delta_v_magnitude"](arg_newVal.COM_val))

    @property
    def ref_axes_name(self) -> str:
        """Ref Axes - the reference axes to be used in modeling this maneuver."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_ref_axes_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ref_axes_name.setter
    def ref_axes_name(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_ref_axes_name"](arg_newVal.COM_val))

    @property
    def orientation(self) -> "IOrientation":
        """The orientation of the attitude."""
        with agmarshall.AgInterface_out_arg() as arg_ppOrientation:
            agcls.evaluate_hresult(self.__dict__["_get_orientation"](byref(arg_ppOrientation.COM_val)))
            return arg_ppOrientation.python_val


agcls.AgClassCatalog.add_catalog_entry("{D9334B8B-9016-4F73-A134-0C61C91060E1}", IAttitudeControlImpulsiveAttitude)
agcls.AgTypeNameMap["IAttitudeControlImpulsiveAttitude"] = IAttitudeControlImpulsiveAttitude

class IAttitudeControlImpulsiveFile(IAttitudeControlImpulsive):
    """Properties for the File attitude control for an Impulsive Maneuver."""
    _uuid = "{24B73A06-3F9E-4409-AE5E-00504C6A2AD7}"
    _num_methods = 7
    _vtable_offset = IAttitudeControlImpulsive._vtable_offset + IAttitudeControlImpulsive._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_delta_v_magnitude"] = _raise_uninitialized_error
        self.__dict__["_set_delta_v_magnitude"] = _raise_uninitialized_error
        self.__dict__["_get_filename"] = _raise_uninitialized_error
        self.__dict__["_set_filename"] = _raise_uninitialized_error
        self.__dict__["_get_file_time_offset"] = _raise_uninitialized_error
        self.__dict__["_set_file_time_offset"] = _raise_uninitialized_error
        self.__dict__["_get_full_filename"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAttitudeControlImpulsiveFile._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAttitudeControlImpulsiveFile from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAttitudeControlImpulsive._private_init(self, pUnk)
        IID_IAttitudeControlImpulsiveFile = agcom.GUID(IAttitudeControlImpulsiveFile._uuid)
        vtable_offset_local = IAttitudeControlImpulsiveFile._vtable_offset - 1
        self.__dict__["_get_delta_v_magnitude"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveFile, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_delta_v_magnitude"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveFile, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_filename"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveFile, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_filename"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveFile, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_get_file_time_offset"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveFile, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_file_time_offset"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveFile, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_full_filename"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveFile, vtable_offset_local+7, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAttitudeControlImpulsiveFile.__dict__ and type(IAttitudeControlImpulsiveFile.__dict__[attrname]) == property:
            return IAttitudeControlImpulsiveFile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IAttitudeControlImpulsive.__setattr__(self, attrname, value)
    
    @property
    def delta_v_magnitude(self) -> float:
        """The size of the delta-V to be applied to the orbit along the specified direction. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_delta_v_magnitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @delta_v_magnitude.setter
    def delta_v_magnitude(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_delta_v_magnitude"](arg_newVal.COM_val))

    @property
    def filename(self) -> str:
        """The attitude file to use."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_filename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @filename.setter
    def filename(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_filename"](arg_newVal.COM_val))

    @property
    def file_time_offset(self) -> float:
        """The time offset can be used to adjust the time stored in the attitude file. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_file_time_offset"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @file_time_offset.setter
    def file_time_offset(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_file_time_offset"](arg_newVal.COM_val))

    @property
    def full_filename(self) -> str:
        """The full path and name of the attitude file to use."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_full_filename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{24B73A06-3F9E-4409-AE5E-00504C6A2AD7}", IAttitudeControlImpulsiveFile)
agcls.AgTypeNameMap["IAttitudeControlImpulsiveFile"] = IAttitudeControlImpulsiveFile

class IAttitudeControlImpulsiveThrustVector(IAttitudeControlImpulsive):
    """Properties for the Thrust Vector attitude control for an Impulsive Maneuver."""
    _uuid = "{3C985D0B-4049-4C5E-81BC-E394CCE17787}"
    _num_methods = 23
    _vtable_offset = IAttitudeControlImpulsive._vtable_offset + IAttitudeControlImpulsive._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_thrust_axes_name"] = _raise_uninitialized_error
        self.__dict__["_set_thrust_axes_name"] = _raise_uninitialized_error
        self.__dict__["_get_body_constraint_vector"] = _raise_uninitialized_error
        self.__dict__["_get_allow_negative_spherical_magnitude"] = _raise_uninitialized_error
        self.__dict__["_set_allow_negative_spherical_magnitude"] = _raise_uninitialized_error
        self.__dict__["_get_coord_type"] = _raise_uninitialized_error
        self.__dict__["_set_coord_type"] = _raise_uninitialized_error
        self.__dict__["_get_x"] = _raise_uninitialized_error
        self.__dict__["_set_x"] = _raise_uninitialized_error
        self.__dict__["_get_y"] = _raise_uninitialized_error
        self.__dict__["_set_y"] = _raise_uninitialized_error
        self.__dict__["_get_z"] = _raise_uninitialized_error
        self.__dict__["_set_z"] = _raise_uninitialized_error
        self.__dict__["_get_azimuth"] = _raise_uninitialized_error
        self.__dict__["_set_azimuth"] = _raise_uninitialized_error
        self.__dict__["_get_elevation"] = _raise_uninitialized_error
        self.__dict__["_set_elevation"] = _raise_uninitialized_error
        self.__dict__["_get_magnitude"] = _raise_uninitialized_error
        self.__dict__["_set_magnitude"] = _raise_uninitialized_error
        self.__dict__["_assign_cartesian"] = _raise_uninitialized_error
        self.__dict__["_query_cartesian"] = _raise_uninitialized_error
        self.__dict__["_assign_spherical"] = _raise_uninitialized_error
        self.__dict__["_query_spherical"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAttitudeControlImpulsiveThrustVector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAttitudeControlImpulsiveThrustVector from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAttitudeControlImpulsive._private_init(self, pUnk)
        IID_IAttitudeControlImpulsiveThrustVector = agcom.GUID(IAttitudeControlImpulsiveThrustVector._uuid)
        vtable_offset_local = IAttitudeControlImpulsiveThrustVector._vtable_offset - 1
        self.__dict__["_get_thrust_axes_name"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveThrustVector, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_thrust_axes_name"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveThrustVector, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_body_constraint_vector"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveThrustVector, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_allow_negative_spherical_magnitude"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveThrustVector, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_allow_negative_spherical_magnitude"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveThrustVector, vtable_offset_local+5, agcom.VARIANT_BOOL)
        self.__dict__["_get_coord_type"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveThrustVector, vtable_offset_local+6, POINTER(agcom.LONG))
        self.__dict__["_set_coord_type"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveThrustVector, vtable_offset_local+7, agcom.LONG)
        self.__dict__["_get_x"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveThrustVector, vtable_offset_local+8, POINTER(agcom.DOUBLE))
        self.__dict__["_set_x"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveThrustVector, vtable_offset_local+9, agcom.DOUBLE)
        self.__dict__["_get_y"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveThrustVector, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_set_y"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveThrustVector, vtable_offset_local+11, agcom.DOUBLE)
        self.__dict__["_get_z"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveThrustVector, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_set_z"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveThrustVector, vtable_offset_local+13, agcom.DOUBLE)
        self.__dict__["_get_azimuth"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveThrustVector, vtable_offset_local+14, POINTER(agcom.VARIANT))
        self.__dict__["_set_azimuth"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveThrustVector, vtable_offset_local+15, agcom.VARIANT)
        self.__dict__["_get_elevation"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveThrustVector, vtable_offset_local+16, POINTER(agcom.VARIANT))
        self.__dict__["_set_elevation"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveThrustVector, vtable_offset_local+17, agcom.VARIANT)
        self.__dict__["_get_magnitude"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveThrustVector, vtable_offset_local+18, POINTER(agcom.DOUBLE))
        self.__dict__["_set_magnitude"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveThrustVector, vtable_offset_local+19, agcom.DOUBLE)
        self.__dict__["_assign_cartesian"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveThrustVector, vtable_offset_local+20, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE)
        self.__dict__["_query_cartesian"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveThrustVector, vtable_offset_local+21, POINTER(agcom.SAFEARRAY))
        self.__dict__["_assign_spherical"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveThrustVector, vtable_offset_local+22, agcom.VARIANT, agcom.VARIANT, agcom.DOUBLE)
        self.__dict__["_query_spherical"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlImpulsiveThrustVector, vtable_offset_local+23, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAttitudeControlImpulsiveThrustVector.__dict__ and type(IAttitudeControlImpulsiveThrustVector.__dict__[attrname]) == property:
            return IAttitudeControlImpulsiveThrustVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IAttitudeControlImpulsive.__setattr__(self, attrname, value)
    
    @property
    def thrust_axes_name(self) -> str:
        """The thrust axes."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_thrust_axes_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @thrust_axes_name.setter
    def thrust_axes_name(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_thrust_axes_name"](arg_newVal.COM_val))

    @property
    def body_constraint_vector(self) -> "IDirection":
        """Defines a constraint vector in spacecraft body coordinates to complete the attitude definition."""
        with agmarshall.AgInterface_out_arg() as arg_ppDirection:
            agcls.evaluate_hresult(self.__dict__["_get_body_constraint_vector"](byref(arg_ppDirection.COM_val)))
            return arg_ppDirection.python_val

    @property
    def allow_negative_spherical_magnitude(self) -> bool:
        """True if the spherical magnitude should be allowed to be less than zero."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_allow_negative_spherical_magnitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @allow_negative_spherical_magnitude.setter
    def allow_negative_spherical_magnitude(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_allow_negative_spherical_magnitude"](arg_newVal.COM_val))

    @property
    def coord_type(self) -> "AgEVAImpDeltaVRep":
        """The coordinate representation for the DeltaV."""
        with agmarshall.AgEnum_arg(AgEVAImpDeltaVRep) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_type.setter
    def coord_type(self, newVal:"AgEVAImpDeltaVRep") -> None:
        with agmarshall.AgEnum_arg(AgEVAImpDeltaVRep, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_type"](arg_newVal.COM_val))

    @property
    def x(self) -> float:
        """The Cartesian X component of the impulsive DeltaV (dimension: SmallDistance/Time)."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_x"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @x.setter
    def x(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_x"](arg_newVal.COM_val))

    @property
    def y(self) -> float:
        """The Cartesian Y component of the impulsive DeltaV (dimension: SmallDistance/Time)."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_y"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @y.setter
    def y(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_y"](arg_newVal.COM_val))

    @property
    def z(self) -> float:
        """The Cartesian Z component of the impulsive DeltaV (dimension: SmallDistance/Time)."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_z"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @z.setter
    def z(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_z"](arg_newVal.COM_val))

    @property
    def azimuth(self) -> typing.Any:
        """The spherical Azimuth angle of the impulsive DeltaV (dimension: Angle)."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_azimuth"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @azimuth.setter
    def azimuth(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_azimuth"](arg_newVal.COM_val))

    @property
    def elevation(self) -> typing.Any:
        """The spherical Elevation angle of the impulsive DeltaV (dimension: Angle)."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_elevation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @elevation.setter
    def elevation(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_elevation"](arg_newVal.COM_val))

    @property
    def magnitude(self) -> float:
        """The spherical Magnitude of the impulsive DeltaV (dimension: SmallDistance/Time)."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_magnitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @magnitude.setter
    def magnitude(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_magnitude"](arg_newVal.COM_val))

    def assign_cartesian(self, xVal:float, yVal:float, zVal:float) -> None:
        """Assign all three Cartesian components of the DeltaV vector (dimension: SmallDistance/Time)"""
        with agmarshall.DOUBLE_arg(xVal) as arg_xVal, \
             agmarshall.DOUBLE_arg(yVal) as arg_yVal, \
             agmarshall.DOUBLE_arg(zVal) as arg_zVal:
            agcls.evaluate_hresult(self.__dict__["_assign_cartesian"](arg_xVal.COM_val, arg_yVal.COM_val, arg_zVal.COM_val))

    def query_cartesian(self) -> list:
        """Get all three Cartesian components of the DeltaV vector as an array (dimension: SmallDistance/Time)"""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_query_cartesian"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def assign_spherical(self, azVal:typing.Any, elVal:typing.Any, magVal:float) -> None:
        """Assign all three spherical components of the DeltaV vector (order Az, El, Mag; dimensions: Angle, Angle, SmallDistance/Time)"""
        with agmarshall.VARIANT_arg(azVal) as arg_azVal, \
             agmarshall.VARIANT_arg(elVal) as arg_elVal, \
             agmarshall.DOUBLE_arg(magVal) as arg_magVal:
            agcls.evaluate_hresult(self.__dict__["_assign_spherical"](arg_azVal.COM_val, arg_elVal.COM_val, arg_magVal.COM_val))

    def query_spherical(self) -> list:
        """Get all three spherical components of the DeltaV vector as an array (order Az, El, Mag; dimensions: Angle, Angle, SmallDistance/Time)"""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_query_spherical"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{3C985D0B-4049-4C5E-81BC-E394CCE17787}", IAttitudeControlImpulsiveThrustVector)
agcls.AgTypeNameMap["IAttitudeControlImpulsiveThrustVector"] = IAttitudeControlImpulsiveThrustVector

class IAttitudeControlFiniteAntiVelocityVector(IAttitudeControlFinite):
    """Properties for the Anti-Velocity Vector attitude control for a Finite Maneuver."""
    _uuid = "{DB9276FA-2033-425D-9453-A0862C3DC715}"
    _num_methods = 3
    _vtable_offset = IAttitudeControlFinite._vtable_offset + IAttitudeControlFinite._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_attitude_update"] = _raise_uninitialized_error
        self.__dict__["_set_attitude_update"] = _raise_uninitialized_error
        self.__dict__["_get_body_constraint_vector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAttitudeControlFiniteAntiVelocityVector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAttitudeControlFiniteAntiVelocityVector from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAttitudeControlFinite._private_init(self, pUnk)
        IID_IAttitudeControlFiniteAntiVelocityVector = agcom.GUID(IAttitudeControlFiniteAntiVelocityVector._uuid)
        vtable_offset_local = IAttitudeControlFiniteAntiVelocityVector._vtable_offset - 1
        self.__dict__["_get_attitude_update"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteAntiVelocityVector, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_attitude_update"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteAntiVelocityVector, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_body_constraint_vector"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteAntiVelocityVector, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAttitudeControlFiniteAntiVelocityVector.__dict__ and type(IAttitudeControlFiniteAntiVelocityVector.__dict__[attrname]) == property:
            return IAttitudeControlFiniteAntiVelocityVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IAttitudeControlFinite.__setattr__(self, attrname, value)
    
    @property
    def attitude_update(self) -> "AgEVAAttitudeUpdate":
        """How and when the attitude will be updated."""
        with agmarshall.AgEnum_arg(AgEVAAttitudeUpdate) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_attitude_update"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @attitude_update.setter
    def attitude_update(self, newVal:"AgEVAAttitudeUpdate") -> None:
        with agmarshall.AgEnum_arg(AgEVAAttitudeUpdate, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_attitude_update"](arg_newVal.COM_val))

    @property
    def body_constraint_vector(self) -> "IDirection":
        """Defines a constraint vector in spacecraft body coordinates to complete the attitude definition."""
        with agmarshall.AgInterface_out_arg() as arg_ppDirection:
            agcls.evaluate_hresult(self.__dict__["_get_body_constraint_vector"](byref(arg_ppDirection.COM_val)))
            return arg_ppDirection.python_val


agcls.AgClassCatalog.add_catalog_entry("{DB9276FA-2033-425D-9453-A0862C3DC715}", IAttitudeControlFiniteAntiVelocityVector)
agcls.AgTypeNameMap["IAttitudeControlFiniteAntiVelocityVector"] = IAttitudeControlFiniteAntiVelocityVector

class IAttitudeControlFiniteAttitude(IAttitudeControlFinite):
    """Properties for the Attitude attitude control for a Finite Maneuver."""
    _uuid = "{BE7E2121-2A2E-4045-BE6F-E75256FDD287}"
    _num_methods = 5
    _vtable_offset = IAttitudeControlFinite._vtable_offset + IAttitudeControlFinite._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_attitude_update"] = _raise_uninitialized_error
        self.__dict__["_set_attitude_update"] = _raise_uninitialized_error
        self.__dict__["_get_ref_axes_name"] = _raise_uninitialized_error
        self.__dict__["_set_ref_axes_name"] = _raise_uninitialized_error
        self.__dict__["_get_orientation"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAttitudeControlFiniteAttitude._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAttitudeControlFiniteAttitude from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAttitudeControlFinite._private_init(self, pUnk)
        IID_IAttitudeControlFiniteAttitude = agcom.GUID(IAttitudeControlFiniteAttitude._uuid)
        vtable_offset_local = IAttitudeControlFiniteAttitude._vtable_offset - 1
        self.__dict__["_get_attitude_update"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteAttitude, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_attitude_update"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteAttitude, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_ref_axes_name"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteAttitude, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_ref_axes_name"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteAttitude, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_get_orientation"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteAttitude, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAttitudeControlFiniteAttitude.__dict__ and type(IAttitudeControlFiniteAttitude.__dict__[attrname]) == property:
            return IAttitudeControlFiniteAttitude.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IAttitudeControlFinite.__setattr__(self, attrname, value)
    
    @property
    def attitude_update(self) -> "AgEVAAttitudeUpdate":
        """How and when the attitude will be updated."""
        with agmarshall.AgEnum_arg(AgEVAAttitudeUpdate) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_attitude_update"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @attitude_update.setter
    def attitude_update(self, newVal:"AgEVAAttitudeUpdate") -> None:
        with agmarshall.AgEnum_arg(AgEVAAttitudeUpdate, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_attitude_update"](arg_newVal.COM_val))

    @property
    def ref_axes_name(self) -> str:
        """Ref Axes - the reference axes to be used in modeling this maneuver."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_ref_axes_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ref_axes_name.setter
    def ref_axes_name(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_ref_axes_name"](arg_newVal.COM_val))

    @property
    def orientation(self) -> "IOrientation":
        """The orientation of the attitude."""
        with agmarshall.AgInterface_out_arg() as arg_ppOrientation:
            agcls.evaluate_hresult(self.__dict__["_get_orientation"](byref(arg_ppOrientation.COM_val)))
            return arg_ppOrientation.python_val


agcls.AgClassCatalog.add_catalog_entry("{BE7E2121-2A2E-4045-BE6F-E75256FDD287}", IAttitudeControlFiniteAttitude)
agcls.AgTypeNameMap["IAttitudeControlFiniteAttitude"] = IAttitudeControlFiniteAttitude

class IAttitudeControlFiniteFile(IAttitudeControlFinite):
    """Properties for the File attitude control for a Finite Maneuver."""
    _uuid = "{B2B44C74-C8D0-4AE0-A259-F73CD60AEC97}"
    _num_methods = 5
    _vtable_offset = IAttitudeControlFinite._vtable_offset + IAttitudeControlFinite._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_filename"] = _raise_uninitialized_error
        self.__dict__["_set_filename"] = _raise_uninitialized_error
        self.__dict__["_get_file_time_offset"] = _raise_uninitialized_error
        self.__dict__["_set_file_time_offset"] = _raise_uninitialized_error
        self.__dict__["_get_full_filename"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAttitudeControlFiniteFile._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAttitudeControlFiniteFile from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAttitudeControlFinite._private_init(self, pUnk)
        IID_IAttitudeControlFiniteFile = agcom.GUID(IAttitudeControlFiniteFile._uuid)
        vtable_offset_local = IAttitudeControlFiniteFile._vtable_offset - 1
        self.__dict__["_get_filename"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteFile, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_filename"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteFile, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_file_time_offset"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteFile, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_file_time_offset"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteFile, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_full_filename"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteFile, vtable_offset_local+5, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAttitudeControlFiniteFile.__dict__ and type(IAttitudeControlFiniteFile.__dict__[attrname]) == property:
            return IAttitudeControlFiniteFile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IAttitudeControlFinite.__setattr__(self, attrname, value)
    
    @property
    def filename(self) -> str:
        """The attitude file to use."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_filename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @filename.setter
    def filename(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_filename"](arg_newVal.COM_val))

    @property
    def file_time_offset(self) -> float:
        """The time offset can be used to adjust the time stored in the attitude file. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_file_time_offset"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @file_time_offset.setter
    def file_time_offset(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_file_time_offset"](arg_newVal.COM_val))

    @property
    def full_filename(self) -> str:
        """The full path and name of the attitude file to use."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_full_filename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{B2B44C74-C8D0-4AE0-A259-F73CD60AEC97}", IAttitudeControlFiniteFile)
agcls.AgTypeNameMap["IAttitudeControlFiniteFile"] = IAttitudeControlFiniteFile

class IAttitudeControlFiniteThrustVector(IAttitudeControlFinite):
    """Properties for the Thrust Vector attitude control for a Finite Maneuver."""
    _uuid = "{5928D05A-399E-4773-A934-23E9B9EEF39E}"
    _num_methods = 6
    _vtable_offset = IAttitudeControlFinite._vtable_offset + IAttitudeControlFinite._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_attitude_update"] = _raise_uninitialized_error
        self.__dict__["_set_attitude_update"] = _raise_uninitialized_error
        self.__dict__["_get_thrust_axes_name"] = _raise_uninitialized_error
        self.__dict__["_set_thrust_axes_name"] = _raise_uninitialized_error
        self.__dict__["_get_body_constraint_vector"] = _raise_uninitialized_error
        self.__dict__["_get_thrust_vector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAttitudeControlFiniteThrustVector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAttitudeControlFiniteThrustVector from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAttitudeControlFinite._private_init(self, pUnk)
        IID_IAttitudeControlFiniteThrustVector = agcom.GUID(IAttitudeControlFiniteThrustVector._uuid)
        vtable_offset_local = IAttitudeControlFiniteThrustVector._vtable_offset - 1
        self.__dict__["_get_attitude_update"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteThrustVector, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_attitude_update"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteThrustVector, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_thrust_axes_name"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteThrustVector, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_thrust_axes_name"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteThrustVector, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_get_body_constraint_vector"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteThrustVector, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_thrust_vector"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteThrustVector, vtable_offset_local+6, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAttitudeControlFiniteThrustVector.__dict__ and type(IAttitudeControlFiniteThrustVector.__dict__[attrname]) == property:
            return IAttitudeControlFiniteThrustVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IAttitudeControlFinite.__setattr__(self, attrname, value)
    
    @property
    def attitude_update(self) -> "AgEVAAttitudeUpdate":
        """How and when the attitude will be updated."""
        with agmarshall.AgEnum_arg(AgEVAAttitudeUpdate) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_attitude_update"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @attitude_update.setter
    def attitude_update(self, newVal:"AgEVAAttitudeUpdate") -> None:
        with agmarshall.AgEnum_arg(AgEVAAttitudeUpdate, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_attitude_update"](arg_newVal.COM_val))

    @property
    def thrust_axes_name(self) -> str:
        """The thrust axes."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_thrust_axes_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @thrust_axes_name.setter
    def thrust_axes_name(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_thrust_axes_name"](arg_newVal.COM_val))

    @property
    def body_constraint_vector(self) -> "IDirection":
        """Defines a constraint vector in spacecraft body coordinates to complete the attitude definition."""
        with agmarshall.AgInterface_out_arg() as arg_ppDirection:
            agcls.evaluate_hresult(self.__dict__["_get_body_constraint_vector"](byref(arg_ppDirection.COM_val)))
            return arg_ppDirection.python_val

    @property
    def thrust_vector(self) -> "IDirection":
        """Defines the thrust vector in the reference axes."""
        with agmarshall.AgInterface_out_arg() as arg_ppDirection:
            agcls.evaluate_hresult(self.__dict__["_get_thrust_vector"](byref(arg_ppDirection.COM_val)))
            return arg_ppDirection.python_val


agcls.AgClassCatalog.add_catalog_entry("{5928D05A-399E-4773-A934-23E9B9EEF39E}", IAttitudeControlFiniteThrustVector)
agcls.AgTypeNameMap["IAttitudeControlFiniteThrustVector"] = IAttitudeControlFiniteThrustVector

class IAttitudeControlFiniteTimeVarying(IAttitudeControlFinite):
    """Properties for the Time Varying attitude control for a Finite Maneuver."""
    _uuid = "{52E48F6D-0FD1-4E30-9398-DCCA988454CE}"
    _num_methods = 35
    _vtable_offset = IAttitudeControlFinite._vtable_offset + IAttitudeControlFinite._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_thrust_axes_name"] = _raise_uninitialized_error
        self.__dict__["_set_thrust_axes_name"] = _raise_uninitialized_error
        self.__dict__["_get_body_constraint_vector"] = _raise_uninitialized_error
        self.__dict__["_get_az0"] = _raise_uninitialized_error
        self.__dict__["_set_az0"] = _raise_uninitialized_error
        self.__dict__["_get_az1"] = _raise_uninitialized_error
        self.__dict__["_set_az1"] = _raise_uninitialized_error
        self.__dict__["_get_az2"] = _raise_uninitialized_error
        self.__dict__["_set_az2"] = _raise_uninitialized_error
        self.__dict__["_get_az3"] = _raise_uninitialized_error
        self.__dict__["_set_az3"] = _raise_uninitialized_error
        self.__dict__["_get_az4"] = _raise_uninitialized_error
        self.__dict__["_set_az4"] = _raise_uninitialized_error
        self.__dict__["_get_az_a"] = _raise_uninitialized_error
        self.__dict__["_set_az_a"] = _raise_uninitialized_error
        self.__dict__["_get_az_f"] = _raise_uninitialized_error
        self.__dict__["_set_az_f"] = _raise_uninitialized_error
        self.__dict__["_get_az_p"] = _raise_uninitialized_error
        self.__dict__["_set_az_p"] = _raise_uninitialized_error
        self.__dict__["_get_el0"] = _raise_uninitialized_error
        self.__dict__["_set_el0"] = _raise_uninitialized_error
        self.__dict__["_get_el1"] = _raise_uninitialized_error
        self.__dict__["_set_el1"] = _raise_uninitialized_error
        self.__dict__["_get_el2"] = _raise_uninitialized_error
        self.__dict__["_set_el2"] = _raise_uninitialized_error
        self.__dict__["_get_el3"] = _raise_uninitialized_error
        self.__dict__["_set_el3"] = _raise_uninitialized_error
        self.__dict__["_get_el4"] = _raise_uninitialized_error
        self.__dict__["_set_el4"] = _raise_uninitialized_error
        self.__dict__["_get_el_a"] = _raise_uninitialized_error
        self.__dict__["_set_el_a"] = _raise_uninitialized_error
        self.__dict__["_get_el_f"] = _raise_uninitialized_error
        self.__dict__["_set_el_f"] = _raise_uninitialized_error
        self.__dict__["_get_el_p"] = _raise_uninitialized_error
        self.__dict__["_set_el_p"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAttitudeControlFiniteTimeVarying._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAttitudeControlFiniteTimeVarying from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAttitudeControlFinite._private_init(self, pUnk)
        IID_IAttitudeControlFiniteTimeVarying = agcom.GUID(IAttitudeControlFiniteTimeVarying._uuid)
        vtable_offset_local = IAttitudeControlFiniteTimeVarying._vtable_offset - 1
        self.__dict__["_get_thrust_axes_name"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteTimeVarying, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_thrust_axes_name"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteTimeVarying, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_body_constraint_vector"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteTimeVarying, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_az0"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteTimeVarying, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_set_az0"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteTimeVarying, vtable_offset_local+5, agcom.DOUBLE)
        self.__dict__["_get_az1"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteTimeVarying, vtable_offset_local+6, POINTER(agcom.DOUBLE))
        self.__dict__["_set_az1"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteTimeVarying, vtable_offset_local+7, agcom.DOUBLE)
        self.__dict__["_get_az2"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteTimeVarying, vtable_offset_local+8, POINTER(agcom.DOUBLE))
        self.__dict__["_set_az2"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteTimeVarying, vtable_offset_local+9, agcom.DOUBLE)
        self.__dict__["_get_az3"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteTimeVarying, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_set_az3"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteTimeVarying, vtable_offset_local+11, agcom.DOUBLE)
        self.__dict__["_get_az4"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteTimeVarying, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_set_az4"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteTimeVarying, vtable_offset_local+13, agcom.DOUBLE)
        self.__dict__["_get_az_a"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteTimeVarying, vtable_offset_local+14, POINTER(agcom.DOUBLE))
        self.__dict__["_set_az_a"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteTimeVarying, vtable_offset_local+15, agcom.DOUBLE)
        self.__dict__["_get_az_f"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteTimeVarying, vtable_offset_local+16, POINTER(agcom.DOUBLE))
        self.__dict__["_set_az_f"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteTimeVarying, vtable_offset_local+17, agcom.DOUBLE)
        self.__dict__["_get_az_p"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteTimeVarying, vtable_offset_local+18, POINTER(agcom.DOUBLE))
        self.__dict__["_set_az_p"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteTimeVarying, vtable_offset_local+19, agcom.DOUBLE)
        self.__dict__["_get_el0"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteTimeVarying, vtable_offset_local+20, POINTER(agcom.DOUBLE))
        self.__dict__["_set_el0"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteTimeVarying, vtable_offset_local+21, agcom.DOUBLE)
        self.__dict__["_get_el1"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteTimeVarying, vtable_offset_local+22, POINTER(agcom.DOUBLE))
        self.__dict__["_set_el1"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteTimeVarying, vtable_offset_local+23, agcom.DOUBLE)
        self.__dict__["_get_el2"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteTimeVarying, vtable_offset_local+24, POINTER(agcom.DOUBLE))
        self.__dict__["_set_el2"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteTimeVarying, vtable_offset_local+25, agcom.DOUBLE)
        self.__dict__["_get_el3"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteTimeVarying, vtable_offset_local+26, POINTER(agcom.DOUBLE))
        self.__dict__["_set_el3"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteTimeVarying, vtable_offset_local+27, agcom.DOUBLE)
        self.__dict__["_get_el4"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteTimeVarying, vtable_offset_local+28, POINTER(agcom.DOUBLE))
        self.__dict__["_set_el4"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteTimeVarying, vtable_offset_local+29, agcom.DOUBLE)
        self.__dict__["_get_el_a"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteTimeVarying, vtable_offset_local+30, POINTER(agcom.DOUBLE))
        self.__dict__["_set_el_a"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteTimeVarying, vtable_offset_local+31, agcom.DOUBLE)
        self.__dict__["_get_el_f"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteTimeVarying, vtable_offset_local+32, POINTER(agcom.DOUBLE))
        self.__dict__["_set_el_f"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteTimeVarying, vtable_offset_local+33, agcom.DOUBLE)
        self.__dict__["_get_el_p"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteTimeVarying, vtable_offset_local+34, POINTER(agcom.DOUBLE))
        self.__dict__["_set_el_p"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteTimeVarying, vtable_offset_local+35, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAttitudeControlFiniteTimeVarying.__dict__ and type(IAttitudeControlFiniteTimeVarying.__dict__[attrname]) == property:
            return IAttitudeControlFiniteTimeVarying.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IAttitudeControlFinite.__setattr__(self, attrname, value)
    
    @property
    def thrust_axes_name(self) -> str:
        """The thrust axes."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_thrust_axes_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @thrust_axes_name.setter
    def thrust_axes_name(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_thrust_axes_name"](arg_newVal.COM_val))

    @property
    def body_constraint_vector(self) -> "IDirection":
        """Defines a constraint vector in spacecraft body coordinates to complete the attitude definition."""
        with agmarshall.AgInterface_out_arg() as arg_ppDirection:
            agcls.evaluate_hresult(self.__dict__["_get_body_constraint_vector"](byref(arg_ppDirection.COM_val)))
            return arg_ppDirection.python_val

    @property
    def az0(self) -> float:
        """Azimuth constant term (dimension: angle)"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_az0"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @az0.setter
    def az0(self, pVal:float) -> None:
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_az0"](arg_pVal.COM_val))

    @property
    def az1(self) -> float:
        """Azimuth linear term (dimension: angle/time)"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_az1"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @az1.setter
    def az1(self, pVal:float) -> None:
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_az1"](arg_pVal.COM_val))

    @property
    def az2(self) -> float:
        """Azimuth quadratic term (dimension: angle/time^2)"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_az2"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @az2.setter
    def az2(self, pVal:float) -> None:
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_az2"](arg_pVal.COM_val))

    @property
    def az3(self) -> float:
        """Azimuth cubic term (dimension: angle/time^3)"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_az3"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @az3.setter
    def az3(self, pVal:float) -> None:
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_az3"](arg_pVal.COM_val))

    @property
    def az4(self) -> float:
        """Azimuth quartic term (dimension: angle/time^4)"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_az4"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @az4.setter
    def az4(self, pVal:float) -> None:
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_az4"](arg_pVal.COM_val))

    @property
    def az_a(self) -> float:
        """Azimuth sine term amplitude (dimension: angle)"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_az_a"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @az_a.setter
    def az_a(self, pVal:float) -> None:
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_az_a"](arg_pVal.COM_val))

    @property
    def az_f(self) -> float:
        """Azimuth sine term frequency (dimension: angle/time)"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_az_f"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @az_f.setter
    def az_f(self, pVal:float) -> None:
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_az_f"](arg_pVal.COM_val))

    @property
    def az_p(self) -> float:
        """Azimuth sine term phase (dimension: angle)"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_az_p"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @az_p.setter
    def az_p(self, pVal:float) -> None:
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_az_p"](arg_pVal.COM_val))

    @property
    def el0(self) -> float:
        """Elevation constant term (dimension: angle)"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_el0"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @el0.setter
    def el0(self, pVal:float) -> None:
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_el0"](arg_pVal.COM_val))

    @property
    def el1(self) -> float:
        """Elevation linear term (dimension: angle/time)"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_el1"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @el1.setter
    def el1(self, pVal:float) -> None:
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_el1"](arg_pVal.COM_val))

    @property
    def el2(self) -> float:
        """Elevation quadratic term (dimension: angle/time^2)"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_el2"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @el2.setter
    def el2(self, pVal:float) -> None:
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_el2"](arg_pVal.COM_val))

    @property
    def el3(self) -> float:
        """Elevation cubic term (dimension: angle/time^3)"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_el3"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @el3.setter
    def el3(self, pVal:float) -> None:
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_el3"](arg_pVal.COM_val))

    @property
    def el4(self) -> float:
        """Elevation quartic term (dimension: angle/time^4)"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_el4"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @el4.setter
    def el4(self, pVal:float) -> None:
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_el4"](arg_pVal.COM_val))

    @property
    def el_a(self) -> float:
        """Elevation sine term amplitude (dimension: angle)"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_el_a"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @el_a.setter
    def el_a(self, pVal:float) -> None:
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_el_a"](arg_pVal.COM_val))

    @property
    def el_f(self) -> float:
        """Elevation sine term frequency (dimension: angle/time)"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_el_f"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @el_f.setter
    def el_f(self, pVal:float) -> None:
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_el_f"](arg_pVal.COM_val))

    @property
    def el_p(self) -> float:
        """Elevation sine term phase (dimension: angle)"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_el_p"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @el_p.setter
    def el_p(self, pVal:float) -> None:
        with agmarshall.DOUBLE_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_el_p"](arg_pVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{52E48F6D-0FD1-4E30-9398-DCCA988454CE}", IAttitudeControlFiniteTimeVarying)
agcls.AgTypeNameMap["IAttitudeControlFiniteTimeVarying"] = IAttitudeControlFiniteTimeVarying

class IAttitudeControlFiniteVelocityVector(IAttitudeControlFinite):
    """Properties for the Velocity Vector attitude control for a Finite Maneuver."""
    _uuid = "{0AD7345F-8B3C-474A-A1FC-AF0BA8BE4F38}"
    _num_methods = 3
    _vtable_offset = IAttitudeControlFinite._vtable_offset + IAttitudeControlFinite._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_attitude_update"] = _raise_uninitialized_error
        self.__dict__["_set_attitude_update"] = _raise_uninitialized_error
        self.__dict__["_get_body_constraint_vector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAttitudeControlFiniteVelocityVector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAttitudeControlFiniteVelocityVector from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAttitudeControlFinite._private_init(self, pUnk)
        IID_IAttitudeControlFiniteVelocityVector = agcom.GUID(IAttitudeControlFiniteVelocityVector._uuid)
        vtable_offset_local = IAttitudeControlFiniteVelocityVector._vtable_offset - 1
        self.__dict__["_get_attitude_update"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteVelocityVector, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_attitude_update"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteVelocityVector, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_body_constraint_vector"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFiniteVelocityVector, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAttitudeControlFiniteVelocityVector.__dict__ and type(IAttitudeControlFiniteVelocityVector.__dict__[attrname]) == property:
            return IAttitudeControlFiniteVelocityVector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IAttitudeControlFinite.__setattr__(self, attrname, value)
    
    @property
    def attitude_update(self) -> "AgEVAAttitudeUpdate":
        """How and when the attitude will be updated."""
        with agmarshall.AgEnum_arg(AgEVAAttitudeUpdate) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_attitude_update"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @attitude_update.setter
    def attitude_update(self, newVal:"AgEVAAttitudeUpdate") -> None:
        with agmarshall.AgEnum_arg(AgEVAAttitudeUpdate, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_attitude_update"](arg_newVal.COM_val))

    @property
    def body_constraint_vector(self) -> "IDirection":
        """Defines a constraint vector in spacecraft body coordinates to complete the attitude definition."""
        with agmarshall.AgInterface_out_arg() as arg_ppDirection:
            agcls.evaluate_hresult(self.__dict__["_get_body_constraint_vector"](byref(arg_ppDirection.COM_val)))
            return arg_ppDirection.python_val


agcls.AgClassCatalog.add_catalog_entry("{0AD7345F-8B3C-474A-A1FC-AF0BA8BE4F38}", IAttitudeControlFiniteVelocityVector)
agcls.AgTypeNameMap["IAttitudeControlFiniteVelocityVector"] = IAttitudeControlFiniteVelocityVector

class IAttitudeControlFinitePlugin(IAttitudeControlFinite):
    """Properties for the Plugin attitude control for a Finite Maneuver."""
    _uuid = "{97762200-0ECD-423E-83FA-128D9DBC9C59}"
    _num_methods = 3
    _vtable_offset = IAttitudeControlFinite._vtable_offset + IAttitudeControlFinite._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_select_plugin_by_name"] = _raise_uninitialized_error
        self.__dict__["_get_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_get_plugin_config"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAttitudeControlFinitePlugin._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAttitudeControlFinitePlugin from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAttitudeControlFinite._private_init(self, pUnk)
        IID_IAttitudeControlFinitePlugin = agcom.GUID(IAttitudeControlFinitePlugin._uuid)
        vtable_offset_local = IAttitudeControlFinitePlugin._vtable_offset - 1
        self.__dict__["_select_plugin_by_name"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFinitePlugin, vtable_offset_local+1, agcom.BSTR)
        self.__dict__["_get_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFinitePlugin, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_get_plugin_config"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlFinitePlugin, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAttitudeControlFinitePlugin.__dict__ and type(IAttitudeControlFinitePlugin.__dict__[attrname]) == property:
            return IAttitudeControlFinitePlugin.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IAttitudeControlFinite.__setattr__(self, attrname, value)
    
    def select_plugin_by_name(self, name:str) -> None:
        """Selects plugin using the plugin name."""
        with agmarshall.BSTR_arg(name) as arg_name:
            agcls.evaluate_hresult(self.__dict__["_select_plugin_by_name"](arg_name.COM_val))

    @property
    def plugin_name(self) -> str:
        """The selected plugin's name."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_plugin_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def plugin_config(self) -> "IPluginProperties":
        """The properties of the selected plugin."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_plugin_config"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{97762200-0ECD-423E-83FA-128D9DBC9C59}", IAttitudeControlFinitePlugin)
agcls.AgTypeNameMap["IAttitudeControlFinitePlugin"] = IAttitudeControlFinitePlugin

class IAttitudeControlOptimalFiniteLagrange(IAttitudeControlOptimalFinite):
    """Properties for the Lagrange Interpolation attitude control for a Optimal Finite Maneuver."""
    _uuid = "{5E65B4C8-BFDB-4812-BE54-FF94FEDFDB12}"
    _num_methods = 1
    _vtable_offset = IAttitudeControlOptimalFinite._vtable_offset + IAttitudeControlOptimalFinite._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_body_constraint_vector"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAttitudeControlOptimalFiniteLagrange._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAttitudeControlOptimalFiniteLagrange from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAttitudeControlOptimalFinite._private_init(self, pUnk)
        IID_IAttitudeControlOptimalFiniteLagrange = agcom.GUID(IAttitudeControlOptimalFiniteLagrange._uuid)
        vtable_offset_local = IAttitudeControlOptimalFiniteLagrange._vtable_offset - 1
        self.__dict__["_get_body_constraint_vector"] = IAGFUNCTYPE(pUnk, IID_IAttitudeControlOptimalFiniteLagrange, vtable_offset_local+1, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAttitudeControlOptimalFiniteLagrange.__dict__ and type(IAttitudeControlOptimalFiniteLagrange.__dict__[attrname]) == property:
            return IAttitudeControlOptimalFiniteLagrange.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IAttitudeControlOptimalFinite.__setattr__(self, attrname, value)
    
    @property
    def body_constraint_vector(self) -> "IDirection":
        """Defines a constraint vector in spacecraft body coordinates to complete the attitude definition."""
        with agmarshall.AgInterface_out_arg() as arg_ppDirection:
            agcls.evaluate_hresult(self.__dict__["_get_body_constraint_vector"](byref(arg_ppDirection.COM_val)))
            return arg_ppDirection.python_val


agcls.AgClassCatalog.add_catalog_entry("{5E65B4C8-BFDB-4812-BE54-FF94FEDFDB12}", IAttitudeControlOptimalFiniteLagrange)
agcls.AgTypeNameMap["IAttitudeControlOptimalFiniteLagrange"] = IAttitudeControlOptimalFiniteLagrange

class IMissionControlSequenceHold(object):
    """Properties for a Hold segment."""
    _uuid = "{E53CB41B-2AFA-40B5-97AE-079CA69F0779}"
    _num_methods = 23
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_step_size"] = _raise_uninitialized_error
        self.__dict__["_set_step_size"] = _raise_uninitialized_error
        self.__dict__["_get_hold_frame_name"] = _raise_uninitialized_error
        self.__dict__["_set_hold_frame_name"] = _raise_uninitialized_error
        self.__dict__["_get_enable_hold_attitude"] = _raise_uninitialized_error
        self.__dict__["_set_enable_hold_attitude"] = _raise_uninitialized_error
        self.__dict__["_get_stopping_conditions"] = _raise_uninitialized_error
        self.__dict__["_get_min_propagation_time"] = _raise_uninitialized_error
        self.__dict__["_set_min_propagation_time"] = _raise_uninitialized_error
        self.__dict__["_get_max_propagation_time"] = _raise_uninitialized_error
        self.__dict__["_set_max_propagation_time"] = _raise_uninitialized_error
        self.__dict__["_get_enable_max_propagation_time"] = _raise_uninitialized_error
        self.__dict__["_set_enable_max_propagation_time"] = _raise_uninitialized_error
        self.__dict__["_get_enable_warning_message"] = _raise_uninitialized_error
        self.__dict__["_set_enable_warning_message"] = _raise_uninitialized_error
        self.__dict__["_enable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_disable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_is_control_parameter_enabled"] = _raise_uninitialized_error
        self.__dict__["_get_control_parameters_available"] = _raise_uninitialized_error
        self.__dict__["_get_override_max_propagation_time"] = _raise_uninitialized_error
        self.__dict__["_set_override_max_propagation_time"] = _raise_uninitialized_error
        self.__dict__["_get_should_stop_for_initially_surpassed_epoch_stopping_conditions"] = _raise_uninitialized_error
        self.__dict__["_set_should_stop_for_initially_surpassed_epoch_stopping_conditions"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMissionControlSequenceHold._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMissionControlSequenceHold from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMissionControlSequenceHold = agcom.GUID(IMissionControlSequenceHold._uuid)
        vtable_offset_local = IMissionControlSequenceHold._vtable_offset - 1
        self.__dict__["_get_step_size"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceHold, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_step_size"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceHold, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_hold_frame_name"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceHold, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_hold_frame_name"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceHold, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_get_enable_hold_attitude"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceHold, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable_hold_attitude"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceHold, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_get_stopping_conditions"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceHold, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_get_min_propagation_time"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceHold, vtable_offset_local+8, POINTER(agcom.DOUBLE))
        self.__dict__["_set_min_propagation_time"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceHold, vtable_offset_local+9, agcom.DOUBLE)
        self.__dict__["_get_max_propagation_time"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceHold, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_propagation_time"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceHold, vtable_offset_local+11, agcom.DOUBLE)
        self.__dict__["_get_enable_max_propagation_time"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceHold, vtable_offset_local+12, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable_max_propagation_time"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceHold, vtable_offset_local+13, agcom.VARIANT_BOOL)
        self.__dict__["_get_enable_warning_message"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceHold, vtable_offset_local+14, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable_warning_message"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceHold, vtable_offset_local+15, agcom.VARIANT_BOOL)
        self.__dict__["_enable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceHold, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_disable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceHold, vtable_offset_local+17, agcom.LONG)
        self.__dict__["_is_control_parameter_enabled"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceHold, vtable_offset_local+18, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_control_parameters_available"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceHold, vtable_offset_local+19, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_override_max_propagation_time"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceHold, vtable_offset_local+20, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_override_max_propagation_time"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceHold, vtable_offset_local+21, agcom.VARIANT_BOOL)
        self.__dict__["_get_should_stop_for_initially_surpassed_epoch_stopping_conditions"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceHold, vtable_offset_local+22, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_should_stop_for_initially_surpassed_epoch_stopping_conditions"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceHold, vtable_offset_local+23, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissionControlSequenceHold.__dict__ and type(IMissionControlSequenceHold.__dict__[attrname]) == property:
            return IMissionControlSequenceHold.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissionControlSequenceHold.")
    
    @property
    def step_size(self) -> float:
        """The time interval between calculated ephemeris output points. Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_step_size"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @step_size.setter
    def step_size(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_step_size"](arg_newVal.COM_val))

    @property
    def hold_frame_name(self) -> str:
        """Hold Frame - the reference frame of the Hold segment."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_hold_frame_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @hold_frame_name.setter
    def hold_frame_name(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_hold_frame_name"](arg_newVal.COM_val))

    @property
    def enable_hold_attitude(self) -> bool:
        """Enable Hold Altitude - if true, the spacecraft's attitude is fixed within the hold frame."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable_hold_attitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable_hold_attitude.setter
    def enable_hold_attitude(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable_hold_attitude"](arg_newVal.COM_val))

    @property
    def stopping_conditions(self) -> "IStoppingConditionCollection":
        """The stopping conditions defined for the segment."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAStoppingConditionCollection:
            agcls.evaluate_hresult(self.__dict__["_get_stopping_conditions"](byref(arg_ppVAStoppingConditionCollection.COM_val)))
            return arg_ppVAStoppingConditionCollection.python_val

    @property
    def min_propagation_time(self) -> float:
        """Minimum Propagation Time - the minimum time that must elapse from the beginning of the segment until Astrogator will begin checking stopping conditions for satisfaction. Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_propagation_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @min_propagation_time.setter
    def min_propagation_time(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_min_propagation_time"](arg_newVal.COM_val))

    @property
    def max_propagation_time(self) -> float:
        """Maximum Propagation Time - the maximum propagation time, after which the segment will end regardless of whether the stopping conditions have been satisfied. Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_propagation_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_propagation_time.setter
    def max_propagation_time(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_propagation_time"](arg_newVal.COM_val))

    @property
    def enable_max_propagation_time(self) -> bool:
        """Enable Maximum Propagation Time - if true, the maximum propagation time will be enforced."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable_max_propagation_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable_max_propagation_time.setter
    def enable_max_propagation_time(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable_max_propagation_time"](arg_newVal.COM_val))

    @property
    def enable_warning_message(self) -> bool:
        """If true, Astrogator will issue a warning message if propagation is stopped by the Maximum Propagation Time parameter."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable_warning_message"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable_warning_message.setter
    def enable_warning_message(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable_warning_message"](arg_newVal.COM_val))

    def enable_control_parameter(self, param:"AgEVAControlAdvanced") -> None:
        """Enables or disables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlAdvanced, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_enable_control_parameter"](arg_param.COM_val))

    def disable_control_parameter(self, param:"AgEVAControlAdvanced") -> None:
        """Disables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlAdvanced, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_disable_control_parameter"](arg_param.COM_val))

    def is_control_parameter_enabled(self, param:"AgEVAControlAdvanced") -> bool:
        """Sees if the specified control is enabled."""
        with agmarshall.AgEnum_arg(AgEVAControlAdvanced, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_is_control_parameter_enabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_parameters_available(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_parameters_available"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def override_max_propagation_time(self) -> bool:
        """Override Maximum Propagation Time - if there is a duration or epoch stopping condition that occurs after the maximum propagation time, ignore the maximum propagation time."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_override_max_propagation_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @override_max_propagation_time.setter
    def override_max_propagation_time(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_override_max_propagation_time"](arg_newVal.COM_val))

    @property
    def should_stop_for_initially_surpassed_epoch_stopping_conditions(self) -> bool:
        """Stop immediately if propagation begins beyond an active epoch stopping condition."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_should_stop_for_initially_surpassed_epoch_stopping_conditions"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @should_stop_for_initially_surpassed_epoch_stopping_conditions.setter
    def should_stop_for_initially_surpassed_epoch_stopping_conditions(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_should_stop_for_initially_surpassed_epoch_stopping_conditions"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E53CB41B-2AFA-40B5-97AE-079CA69F0779}", IMissionControlSequenceHold)
agcls.AgTypeNameMap["IMissionControlSequenceHold"] = IMissionControlSequenceHold

class IMissionControlSequenceUpdate(object):
    """Properties for an Update segment."""
    _uuid = "{070D13DE-2D3C-4002-8D20-A8483EA1F8E3}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_set_action_and_value"] = _raise_uninitialized_error
        self.__dict__["_get_action"] = _raise_uninitialized_error
        self.__dict__["_get_value"] = _raise_uninitialized_error
        self.__dict__["_set_action"] = _raise_uninitialized_error
        self.__dict__["_set_value"] = _raise_uninitialized_error
        self.__dict__["_disable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_enable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_is_control_parameter_enabled"] = _raise_uninitialized_error
        self.__dict__["_get_control_parameters_available"] = _raise_uninitialized_error
        self.__dict__["_get_user_variables"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMissionControlSequenceUpdate._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMissionControlSequenceUpdate from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMissionControlSequenceUpdate = agcom.GUID(IMissionControlSequenceUpdate._uuid)
        vtable_offset_local = IMissionControlSequenceUpdate._vtable_offset - 1
        self.__dict__["_set_action_and_value"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceUpdate, vtable_offset_local+1, agcom.LONG, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_get_action"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceUpdate, vtable_offset_local+2, agcom.LONG, POINTER(agcom.LONG))
        self.__dict__["_get_value"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceUpdate, vtable_offset_local+3, agcom.LONG, POINTER(agcom.DOUBLE))
        self.__dict__["_set_action"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceUpdate, vtable_offset_local+4, agcom.LONG, agcom.LONG)
        self.__dict__["_set_value"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceUpdate, vtable_offset_local+5, agcom.LONG, agcom.DOUBLE)
        self.__dict__["_disable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceUpdate, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_enable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceUpdate, vtable_offset_local+7, agcom.LONG)
        self.__dict__["_is_control_parameter_enabled"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceUpdate, vtable_offset_local+8, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_control_parameters_available"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceUpdate, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_user_variables"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceUpdate, vtable_offset_local+10, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissionControlSequenceUpdate.__dict__ and type(IMissionControlSequenceUpdate.__dict__[attrname]) == property:
            return IMissionControlSequenceUpdate.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissionControlSequenceUpdate.")
    
    def set_action_and_value(self, parameterType:"AgEVAUpdateParam", actionType:"AgEVAUpdateAction", value:float) -> None:
        """Sets an action and the new value."""
        with agmarshall.AgEnum_arg(AgEVAUpdateParam, parameterType) as arg_parameterType, \
             agmarshall.AgEnum_arg(AgEVAUpdateAction, actionType) as arg_actionType, \
             agmarshall.DOUBLE_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_set_action_and_value"](arg_parameterType.COM_val, arg_actionType.COM_val, arg_value.COM_val))

    def get_action(self, parameterType:"AgEVAUpdateParam") -> "AgEVAUpdateAction":
        """Gets the action type for a parameter."""
        with agmarshall.AgEnum_arg(AgEVAUpdateParam, parameterType) as arg_parameterType, \
             agmarshall.AgEnum_arg(AgEVAUpdateAction) as arg_pActionType:
            agcls.evaluate_hresult(self.__dict__["_get_action"](arg_parameterType.COM_val, byref(arg_pActionType.COM_val)))
            return arg_pActionType.python_val

    def get_value(self, parameterType:"AgEVAUpdateParam") -> float:
        """Gets the value type for a parameter."""
        with agmarshall.AgEnum_arg(AgEVAUpdateParam, parameterType) as arg_parameterType, \
             agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_value"](arg_parameterType.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_action(self, parameterName:"AgEVAUpdateParam", actionType:"AgEVAUpdateAction") -> None:
        """Sets the update action type."""
        with agmarshall.AgEnum_arg(AgEVAUpdateParam, parameterName) as arg_parameterName, \
             agmarshall.AgEnum_arg(AgEVAUpdateAction, actionType) as arg_actionType:
            agcls.evaluate_hresult(self.__dict__["_set_action"](arg_parameterName.COM_val, arg_actionType.COM_val))

    def set_value(self, parameterName:"AgEVAUpdateParam", value:float) -> None:
        """Sets the update value."""
        with agmarshall.AgEnum_arg(AgEVAUpdateParam, parameterName) as arg_parameterName, \
             agmarshall.DOUBLE_arg(value) as arg_value:
            agcls.evaluate_hresult(self.__dict__["_set_value"](arg_parameterName.COM_val, arg_value.COM_val))

    def disable_control_parameter(self, param:"AgEVAControlUpdate") -> None:
        """Disables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlUpdate, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_disable_control_parameter"](arg_param.COM_val))

    def enable_control_parameter(self, param:"AgEVAControlUpdate") -> None:
        """Enables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlUpdate, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_enable_control_parameter"](arg_param.COM_val))

    def is_control_parameter_enabled(self, param:"AgEVAControlUpdate") -> bool:
        """Sees if the specified control is enabled."""
        with agmarshall.AgEnum_arg(AgEVAControlUpdate, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_is_control_parameter_enabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_parameters_available(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_parameters_available"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def user_variables(self) -> "IUserVariableUpdateCollection":
        """Interface used to modify user variables for the update segment."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_user_variables"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{070D13DE-2D3C-4002-8D20-A8483EA1F8E3}", IMissionControlSequenceUpdate)
agcls.AgTypeNameMap["IMissionControlSequenceUpdate"] = IMissionControlSequenceUpdate

class IMissionControlSequenceReturn(object):
    """Properties for a Return segment."""
    _uuid = "{9C9AB217-64E6-4697-98F8-3B4BCB34AD62}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_return_control_to_parent_sequence"] = _raise_uninitialized_error
        self.__dict__["_set_return_control_to_parent_sequence"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMissionControlSequenceReturn._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMissionControlSequenceReturn from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMissionControlSequenceReturn = agcom.GUID(IMissionControlSequenceReturn._uuid)
        vtable_offset_local = IMissionControlSequenceReturn._vtable_offset - 1
        self.__dict__["_get_return_control_to_parent_sequence"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceReturn, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_return_control_to_parent_sequence"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceReturn, vtable_offset_local+2, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissionControlSequenceReturn.__dict__ and type(IMissionControlSequenceReturn.__dict__[attrname]) == property:
            return IMissionControlSequenceReturn.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissionControlSequenceReturn.")
    
    @property
    def return_control_to_parent_sequence(self) -> "AgEVAReturnControl":
        """The state of the segment."""
        with agmarshall.AgEnum_arg(AgEVAReturnControl) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_return_control_to_parent_sequence"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @return_control_to_parent_sequence.setter
    def return_control_to_parent_sequence(self, newVal:"AgEVAReturnControl") -> None:
        with agmarshall.AgEnum_arg(AgEVAReturnControl, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_return_control_to_parent_sequence"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{9C9AB217-64E6-4697-98F8-3B4BCB34AD62}", IMissionControlSequenceReturn)
agcls.AgTypeNameMap["IMissionControlSequenceReturn"] = IMissionControlSequenceReturn

class IMissionControlSequenceStop(object):
    """Properties for a Stop segment."""
    _uuid = "{E6CFAA75-3E0C-4B68-9897-66B5556DCD5B}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_enabled"] = _raise_uninitialized_error
        self.__dict__["_set_enabled"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMissionControlSequenceStop._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMissionControlSequenceStop from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMissionControlSequenceStop = agcom.GUID(IMissionControlSequenceStop._uuid)
        vtable_offset_local = IMissionControlSequenceStop._vtable_offset - 1
        self.__dict__["_get_enabled"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceStop, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enabled"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceStop, vtable_offset_local+2, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissionControlSequenceStop.__dict__ and type(IMissionControlSequenceStop.__dict__[attrname]) == property:
            return IMissionControlSequenceStop.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissionControlSequenceStop.")
    
    @property
    def enabled(self) -> bool:
        """If true, the segment will stop the execution of the MCS."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enabled"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enabled.setter
    def enabled(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enabled"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E6CFAA75-3E0C-4B68-9897-66B5556DCD5B}", IMissionControlSequenceStop)
agcls.AgTypeNameMap["IMissionControlSequenceStop"] = IMissionControlSequenceStop

class IProfile(object):
    """General properties for target sequence profiles."""
    _uuid = "{CA331A4E-223E-410B-987C-9BE49AEC33A2}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_copy"] = _raise_uninitialized_error
        self.__dict__["_get_name"] = _raise_uninitialized_error
        self.__dict__["_set_name"] = _raise_uninitialized_error
        self.__dict__["_get_status"] = _raise_uninitialized_error
        self.__dict__["_get_user_comment"] = _raise_uninitialized_error
        self.__dict__["_set_user_comment"] = _raise_uninitialized_error
        self.__dict__["_get_mode"] = _raise_uninitialized_error
        self.__dict__["_set_mode"] = _raise_uninitialized_error
        self.__dict__["_get_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProfile._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProfile from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProfile = agcom.GUID(IProfile._uuid)
        vtable_offset_local = IProfile._vtable_offset - 1
        self.__dict__["_copy"] = IAGFUNCTYPE(pUnk, IID_IProfile, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_name"] = IAGFUNCTYPE(pUnk, IID_IProfile, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_set_name"] = IAGFUNCTYPE(pUnk, IID_IProfile, vtable_offset_local+3, agcom.BSTR)
        self.__dict__["_get_status"] = IAGFUNCTYPE(pUnk, IID_IProfile, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_get_user_comment"] = IAGFUNCTYPE(pUnk, IID_IProfile, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_set_user_comment"] = IAGFUNCTYPE(pUnk, IID_IProfile, vtable_offset_local+6, agcom.BSTR)
        self.__dict__["_get_mode"] = IAGFUNCTYPE(pUnk, IID_IProfile, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_mode"] = IAGFUNCTYPE(pUnk, IID_IProfile, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_type"] = IAGFUNCTYPE(pUnk, IID_IProfile, vtable_offset_local+9, POINTER(agcom.LONG))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProfile.__dict__ and type(IProfile.__dict__[attrname]) == property:
            return IProfile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProfile.")
    
    def copy(self) -> "IProfile":
        """Makes a copy of the profile."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAProfile:
            agcls.evaluate_hresult(self.__dict__["_copy"](byref(arg_ppVAProfile.COM_val)))
            return arg_ppVAProfile.python_val

    @property
    def name(self) -> str:
        """The name of the profile."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @name.setter
    def name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_name"](arg_inVal.COM_val))

    @property
    def status(self) -> str:
        """The status of the profile."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_status"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def user_comment(self) -> str:
        """A user comment."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_user_comment"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @user_comment.setter
    def user_comment(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_user_comment"](arg_inVal.COM_val))

    @property
    def mode(self) -> "AgEVAProfileMode":
        """The profile's mode."""
        with agmarshall.AgEnum_arg(AgEVAProfileMode) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @mode.setter
    def mode(self, inVal:"AgEVAProfileMode") -> None:
        with agmarshall.AgEnum_arg(AgEVAProfileMode, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_mode"](arg_inVal.COM_val))

    @property
    def type(self) -> "AgEVAProfile":
        """Return the current profile type."""
        with agmarshall.AgEnum_arg(AgEVAProfile) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{CA331A4E-223E-410B-987C-9BE49AEC33A2}", IProfile)
agcls.AgTypeNameMap["IProfile"] = IProfile

class IProfileCollection(object):
    """Properties for a list of target sequence profiles."""
    _uuid = "{BA4A3DD4-79DF-4E22-A71B-A0F0A484CA5A}"
    _num_methods = 14
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_add"] = _raise_uninitialized_error
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_get_available_profiles"] = _raise_uninitialized_error
        self.__dict__["_remove"] = _raise_uninitialized_error
        self.__dict__["_remove_all"] = _raise_uninitialized_error
        self.__dict__["_get_provide_runtime_type_info"] = _raise_uninitialized_error
        self.__dict__["_cut"] = _raise_uninitialized_error
        self.__dict__["_paste"] = _raise_uninitialized_error
        self.__dict__["_insert_copy"] = _raise_uninitialized_error
        self.__dict__["_add2"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_index"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProfileCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProfileCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IProfileCollection = agcom.GUID(IProfileCollection._uuid)
        vtable_offset_local = IProfileCollection._vtable_offset - 1
        self.__dict__["_add"] = IAGFUNCTYPE(pUnk, IID_IProfileCollection, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IProfileCollection, vtable_offset_local+2, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IProfileCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IProfileCollection, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_get_available_profiles"] = IAGFUNCTYPE(pUnk, IID_IProfileCollection, vtable_offset_local+5, POINTER(agcom.SAFEARRAY))
        self.__dict__["_remove"] = IAGFUNCTYPE(pUnk, IID_IProfileCollection, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_remove_all"] = IAGFUNCTYPE(pUnk, IID_IProfileCollection, vtable_offset_local+7, )
        self.__dict__["_get_provide_runtime_type_info"] = IAGFUNCTYPE(pUnk, IID_IProfileCollection, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_cut"] = IAGFUNCTYPE(pUnk, IID_IProfileCollection, vtable_offset_local+9, agcom.VARIANT)
        self.__dict__["_paste"] = IAGFUNCTYPE(pUnk, IID_IProfileCollection, vtable_offset_local+10, agcom.VARIANT, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_insert_copy"] = IAGFUNCTYPE(pUnk, IID_IProfileCollection, vtable_offset_local+11, agcom.PVOID, agcom.VARIANT, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_add2"] = IAGFUNCTYPE(pUnk, IID_IProfileCollection, vtable_offset_local+12, agcom.BSTR, agcom.VARIANT, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_get_item_by_index"] = IAGFUNCTYPE(pUnk, IID_IProfileCollection, vtable_offset_local+13, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_get_item_by_name"] = IAGFUNCTYPE(pUnk, IID_IProfileCollection, vtable_offset_local+14, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProfileCollection.__dict__ and type(IProfileCollection.__dict__[attrname]) == property:
            return IProfileCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IProfileCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IProfile":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def add(self, profileName:str) -> "IProfile":
        """Adds a profile."""
        with agmarshall.BSTR_arg(profileName) as arg_profileName, \
             agmarshall.AgInterface_out_arg() as arg_ppVAProfile:
            agcls.evaluate_hresult(self.__dict__["_add"](arg_profileName.COM_val, byref(arg_ppVAProfile.COM_val)))
            return arg_ppVAProfile.python_val

    def item(self, indexOrName:typing.Any) -> "IProfile":
        """Allows you to iterate through the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppVAProfile:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_indexOrName.COM_val, byref(arg_ppVAProfile.COM_val)))
            return arg_ppVAProfile.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def available_profiles(self) -> list:
        """Returns a list of available profiles."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_available_profiles"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def remove(self, indexOrProfileName:typing.Any) -> None:
        """Removes an item from the profile collection."""
        with agmarshall.VARIANT_arg(indexOrProfileName) as arg_indexOrProfileName:
            agcls.evaluate_hresult(self.__dict__["_remove"](arg_indexOrProfileName.COM_val))

    def remove_all(self) -> None:
        """Removes all profiles from the profile collection."""
        agcls.evaluate_hresult(self.__dict__["_remove_all"]())

    @property
    def provide_runtime_type_info(self) -> "IRuntimeTypeInfo":
        """Returns the IRuntimeTypeInfo interface to access properties at runtime."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_provide_runtime_type_info"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def cut(self, indexOrName:typing.Any) -> None:
        """Copies the profile into the clipboard and removes profile from the list."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_cut"](arg_indexOrName.COM_val))

    def paste(self, indexOrName:typing.Any, direction:"AgEVAProfileInsertDirection") -> "IProfile":
        """Pastes the profile from the clipboard and inserts into the list."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgEnum_arg(AgEVAProfileInsertDirection, direction) as arg_direction, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_paste"](arg_indexOrName.COM_val, arg_direction.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def insert_copy(self, profile:"IProfile", indexOrName:typing.Any, direction:"AgEVAProfileInsertDirection") -> "IProfile":
        """Copies the profile and inserts the copy into the list."""
        with agmarshall.AgInterface_in_arg(profile, IProfile) as arg_profile, \
             agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgEnum_arg(AgEVAProfileInsertDirection, direction) as arg_direction, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_insert_copy"](arg_profile.COM_val, arg_indexOrName.COM_val, arg_direction.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def add2(self, profileName:str, indexOrName:typing.Any, direction:"AgEVAProfileInsertDirection") -> "IProfile":
        """Adds a profile."""
        with agmarshall.BSTR_arg(profileName) as arg_profileName, \
             agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgEnum_arg(AgEVAProfileInsertDirection, direction) as arg_direction, \
             agmarshall.AgInterface_out_arg() as arg_ppVAProfile:
            agcls.evaluate_hresult(self.__dict__["_add2"](arg_profileName.COM_val, arg_indexOrName.COM_val, arg_direction.COM_val, byref(arg_ppVAProfile.COM_val)))
            return arg_ppVAProfile.python_val

    def get_item_by_index(self, index:int) -> "IProfile":
        """Retrieves a profile from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppVAProfile:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_index"](arg_index.COM_val, byref(arg_ppVAProfile.COM_val)))
            return arg_ppVAProfile.python_val

    def get_item_by_name(self, name:str) -> "IProfile":
        """Retrieves a profile from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppVAProfile:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_name"](arg_name.COM_val, byref(arg_ppVAProfile.COM_val)))
            return arg_ppVAProfile.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{BA4A3DD4-79DF-4E22-A71B-A0F0A484CA5A}", IProfileCollection)
agcls.AgTypeNameMap["IProfileCollection"] = IProfileCollection

class IMissionControlSequenceTargetSequence(object):
    """General properties of a TargetSequence segment."""
    _uuid = "{703A8064-AB76-41FC-AADA-5134C30DB1C9}"
    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_action"] = _raise_uninitialized_error
        self.__dict__["_set_action"] = _raise_uninitialized_error
        self.__dict__["_get_when_profiles_finish"] = _raise_uninitialized_error
        self.__dict__["_set_when_profiles_finish"] = _raise_uninitialized_error
        self.__dict__["_get_continue_on_failure"] = _raise_uninitialized_error
        self.__dict__["_set_continue_on_failure"] = _raise_uninitialized_error
        self.__dict__["_get_segments"] = _raise_uninitialized_error
        self.__dict__["_get_profiles"] = _raise_uninitialized_error
        self.__dict__["_apply_profiles"] = _raise_uninitialized_error
        self.__dict__["_reset_profiles"] = _raise_uninitialized_error
        self.__dict__["_apply_profile"] = _raise_uninitialized_error
        self.__dict__["_reset_profile"] = _raise_uninitialized_error
        self.__dict__["_apply_profile_by_name"] = _raise_uninitialized_error
        self.__dict__["_reset_profile_by_name"] = _raise_uninitialized_error
        self.__dict__["_get_reset_inner_targeters"] = _raise_uninitialized_error
        self.__dict__["_set_reset_inner_targeters"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMissionControlSequenceTargetSequence._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMissionControlSequenceTargetSequence from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMissionControlSequenceTargetSequence = agcom.GUID(IMissionControlSequenceTargetSequence._uuid)
        vtable_offset_local = IMissionControlSequenceTargetSequence._vtable_offset - 1
        self.__dict__["_get_action"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceTargetSequence, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_action"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceTargetSequence, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_when_profiles_finish"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceTargetSequence, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_when_profiles_finish"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceTargetSequence, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_continue_on_failure"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceTargetSequence, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_continue_on_failure"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceTargetSequence, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_get_segments"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceTargetSequence, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_get_profiles"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceTargetSequence, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_apply_profiles"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceTargetSequence, vtable_offset_local+9, )
        self.__dict__["_reset_profiles"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceTargetSequence, vtable_offset_local+10, )
        self.__dict__["_apply_profile"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceTargetSequence, vtable_offset_local+11, agcom.PVOID)
        self.__dict__["_reset_profile"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceTargetSequence, vtable_offset_local+12, agcom.PVOID)
        self.__dict__["_apply_profile_by_name"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceTargetSequence, vtable_offset_local+13, agcom.BSTR)
        self.__dict__["_reset_profile_by_name"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceTargetSequence, vtable_offset_local+14, agcom.BSTR)
        self.__dict__["_get_reset_inner_targeters"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceTargetSequence, vtable_offset_local+15, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_reset_inner_targeters"] = IAGFUNCTYPE(pUnk, IID_IMissionControlSequenceTargetSequence, vtable_offset_local+16, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMissionControlSequenceTargetSequence.__dict__ and type(IMissionControlSequenceTargetSequence.__dict__[attrname]) == property:
            return IMissionControlSequenceTargetSequence.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMissionControlSequenceTargetSequence.")
    
    @property
    def action(self) -> "AgEVATargetSeqAction":
        """Whether to run the sequence nominally or using profiles."""
        with agmarshall.AgEnum_arg(AgEVATargetSeqAction) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_action"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @action.setter
    def action(self, newVal:"AgEVATargetSeqAction") -> None:
        with agmarshall.AgEnum_arg(AgEVATargetSeqAction, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_action"](arg_newVal.COM_val))

    @property
    def when_profiles_finish(self) -> "AgEVAProfilesFinish":
        """When Profiles Converge - the action to be carried out if targeting has converged."""
        with agmarshall.AgEnum_arg(AgEVAProfilesFinish) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_when_profiles_finish"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @when_profiles_finish.setter
    def when_profiles_finish(self, newVal:"AgEVAProfilesFinish") -> None:
        with agmarshall.AgEnum_arg(AgEVAProfilesFinish, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_when_profiles_finish"](arg_newVal.COM_val))

    @property
    def continue_on_failure(self) -> bool:
        """Continue if profiles don't converge - if true, the target sequence continues if a profile fails to converge; otherwise, the MCS will stop upon the failure of a search profile."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_continue_on_failure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @continue_on_failure.setter
    def continue_on_failure(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_continue_on_failure"](arg_newVal.COM_val))

    @property
    def segments(self) -> "IMissionControlSequenceSegmentCollection":
        """Returns the segments contained within the target sequence."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAMCSSegmentCollection:
            agcls.evaluate_hresult(self.__dict__["_get_segments"](byref(arg_ppVAMCSSegmentCollection.COM_val)))
            return arg_ppVAMCSSegmentCollection.python_val

    @property
    def profiles(self) -> "IProfileCollection":
        """Returns the profiles used within the target sequence."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAProfileCollection:
            agcls.evaluate_hresult(self.__dict__["_get_profiles"](byref(arg_ppVAProfileCollection.COM_val)))
            return arg_ppVAProfileCollection.python_val

    def apply_profiles(self) -> None:
        """Apply Changes - applies the current values of search profiles' controls and the changes specified by the segment configuration profiles to the segments within the target sequence."""
        agcls.evaluate_hresult(self.__dict__["_apply_profiles"]())

    def reset_profiles(self) -> None:
        """Reset - resets the controls of the search profiles to the segments' values."""
        agcls.evaluate_hresult(self.__dict__["_reset_profiles"]())

    def apply_profile(self, profile:"IProfile") -> None:
        """Apply Changes - applies the current values of specified profile to the segments within the target sequence."""
        with agmarshall.AgInterface_in_arg(profile, IProfile) as arg_profile:
            agcls.evaluate_hresult(self.__dict__["_apply_profile"](arg_profile.COM_val))

    def reset_profile(self, profile:"IProfile") -> None:
        """Reset - resets the current values of specified profile."""
        with agmarshall.AgInterface_in_arg(profile, IProfile) as arg_profile:
            agcls.evaluate_hresult(self.__dict__["_reset_profile"](arg_profile.COM_val))

    def apply_profile_by_name(self, profile:str) -> None:
        """Apply Changes - applies the current values of specified profile to the segments within the target sequence."""
        with agmarshall.BSTR_arg(profile) as arg_profile:
            agcls.evaluate_hresult(self.__dict__["_apply_profile_by_name"](arg_profile.COM_val))

    def reset_profile_by_name(self, profile:str) -> None:
        """Reset - resets the current values of specified profile."""
        with agmarshall.BSTR_arg(profile) as arg_profile:
            agcls.evaluate_hresult(self.__dict__["_reset_profile_by_name"](arg_profile.COM_val))

    @property
    def reset_inner_targeters(self) -> bool:
        """If true, inner target sequences will have their profiles reset before each run."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reset_inner_targeters"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reset_inner_targeters.setter
    def reset_inner_targeters(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_reset_inner_targeters"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{703A8064-AB76-41FC-AADA-5134C30DB1C9}", IMissionControlSequenceTargetSequence)
agcls.AgTypeNameMap["IMissionControlSequenceTargetSequence"] = IMissionControlSequenceTargetSequence

class IDifferentialCorrectorControl(object):
    """Properties for control parameters of a differential corrector profile."""
    _uuid = "{5F55DF8A-688A-48E6-A084-48E270AB766E}"
    _num_methods = 25
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_enable"] = _raise_uninitialized_error
        self.__dict__["_set_enable"] = _raise_uninitialized_error
        self.__dict__["_get_name"] = _raise_uninitialized_error
        self.__dict__["_get_final_value"] = _raise_uninitialized_error
        self.__dict__["_get_last_update"] = _raise_uninitialized_error
        self.__dict__["_get_parent_name"] = _raise_uninitialized_error
        self.__dict__["_get_initial_value"] = _raise_uninitialized_error
        self.__dict__["_get_perturbation"] = _raise_uninitialized_error
        self.__dict__["_set_perturbation"] = _raise_uninitialized_error
        self.__dict__["_get_correction"] = _raise_uninitialized_error
        self.__dict__["_set_correction"] = _raise_uninitialized_error
        self.__dict__["_get_tolerance"] = _raise_uninitialized_error
        self.__dict__["_set_tolerance"] = _raise_uninitialized_error
        self.__dict__["_get_max_step"] = _raise_uninitialized_error
        self.__dict__["_set_max_step"] = _raise_uninitialized_error
        self.__dict__["_get_scaling_method"] = _raise_uninitialized_error
        self.__dict__["_set_scaling_method"] = _raise_uninitialized_error
        self.__dict__["_get_scaling_value"] = _raise_uninitialized_error
        self.__dict__["_set_scaling_value"] = _raise_uninitialized_error
        self.__dict__["_get_dimension"] = _raise_uninitialized_error
        self.__dict__["_get_use_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_set_use_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_get_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_set_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_get_values"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IDifferentialCorrectorControl._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IDifferentialCorrectorControl from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IDifferentialCorrectorControl = agcom.GUID(IDifferentialCorrectorControl._uuid)
        vtable_offset_local = IDifferentialCorrectorControl._vtable_offset - 1
        self.__dict__["_get_enable"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorControl, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorControl, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_name"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorControl, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_get_final_value"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorControl, vtable_offset_local+4, POINTER(agcom.VARIANT))
        self.__dict__["_get_last_update"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorControl, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_get_parent_name"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorControl, vtable_offset_local+6, POINTER(agcom.BSTR))
        self.__dict__["_get_initial_value"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorControl, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_get_perturbation"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorControl, vtable_offset_local+8, POINTER(agcom.VARIANT))
        self.__dict__["_set_perturbation"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorControl, vtable_offset_local+9, agcom.VARIANT)
        self.__dict__["_get_correction"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorControl, vtable_offset_local+10, POINTER(agcom.VARIANT))
        self.__dict__["_set_correction"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorControl, vtable_offset_local+11, agcom.VARIANT)
        self.__dict__["_get_tolerance"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorControl, vtable_offset_local+12, POINTER(agcom.VARIANT))
        self.__dict__["_set_tolerance"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorControl, vtable_offset_local+13, agcom.VARIANT)
        self.__dict__["_get_max_step"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorControl, vtable_offset_local+14, POINTER(agcom.VARIANT))
        self.__dict__["_set_max_step"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorControl, vtable_offset_local+15, agcom.VARIANT)
        self.__dict__["_get_scaling_method"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorControl, vtable_offset_local+16, POINTER(agcom.LONG))
        self.__dict__["_set_scaling_method"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorControl, vtable_offset_local+17, agcom.LONG)
        self.__dict__["_get_scaling_value"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorControl, vtable_offset_local+18, POINTER(agcom.VARIANT))
        self.__dict__["_set_scaling_value"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorControl, vtable_offset_local+19, agcom.VARIANT)
        self.__dict__["_get_dimension"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorControl, vtable_offset_local+20, POINTER(agcom.BSTR))
        self.__dict__["_get_use_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorControl, vtable_offset_local+21, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorControl, vtable_offset_local+22, agcom.VARIANT_BOOL)
        self.__dict__["_get_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorControl, vtable_offset_local+23, POINTER(agcom.BSTR))
        self.__dict__["_set_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorControl, vtable_offset_local+24, agcom.BSTR)
        self.__dict__["_get_values"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorControl, vtable_offset_local+25, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IDifferentialCorrectorControl.__dict__ and type(IDifferentialCorrectorControl.__dict__[attrname]) == property:
            return IDifferentialCorrectorControl.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IDifferentialCorrectorControl.")
    
    @property
    def enable(self) -> bool:
        """If true, the variable is being used."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable.setter
    def enable(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable"](arg_newVal.COM_val))

    @property
    def name(self) -> str:
        """The name of the parameter."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def final_value(self) -> typing.Any:
        """The value of the independent variable after the last targeter run."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_final_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def last_update(self) -> typing.Any:
        """The amount by which the value of the independent variable changed during the last targeter run."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_last_update"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def parent_name(self) -> str:
        """The name of the segment to which the parameter belongs."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_parent_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def initial_value(self) -> typing.Any:
        """The nominal value of the element selected as a parameter. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_initial_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def perturbation(self) -> typing.Any:
        """The value to be used in calculating numerical derivatives. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_perturbation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @perturbation.setter
    def perturbation(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_perturbation"](arg_newVal.COM_val))

    @property
    def correction(self) -> typing.Any:
        """The amount by which the nominal value of the parameter should be corrected to achieve the selected goals. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_correction"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @correction.setter
    def correction(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_correction"](arg_newVal.COM_val))

    @property
    def tolerance(self) -> typing.Any:
        """The smallest update to the parameter to be made before the targeter stops. Only used if the convergence criteria is set to 'Either equality constraints or last control parameter updates within tolerance'. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_tolerance"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @tolerance.setter
    def tolerance(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_tolerance"](arg_newVal.COM_val))

    @property
    def max_step(self) -> typing.Any:
        """The maximum increment to make to the value of the parameter in any one step. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_step.setter
    def max_step(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_step"](arg_newVal.COM_val))

    @property
    def scaling_method(self) -> "AgEVADCScalingMethod":
        """Allows better numerical behavior if the parameters have very different magnitudes. The same scaling method is applied to all parameters."""
        with agmarshall.AgEnum_arg(AgEVADCScalingMethod) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_scaling_method"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @scaling_method.setter
    def scaling_method(self, newVal:"AgEVADCScalingMethod") -> None:
        with agmarshall.AgEnum_arg(AgEVADCScalingMethod, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_scaling_method"](arg_newVal.COM_val))

    @property
    def scaling_value(self) -> typing.Any:
        """Applies to the Specified Value scaling method. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_scaling_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @scaling_value.setter
    def scaling_value(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_scaling_value"](arg_newVal.COM_val))

    @property
    def dimension(self) -> str:
        """Dimension of the constraint."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_dimension"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def use_custom_display_unit(self) -> bool:
        """If true, allows display of values in another unit."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_custom_display_unit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_custom_display_unit.setter
    def use_custom_display_unit(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_custom_display_unit"](arg_newVal.COM_val))

    @property
    def custom_display_unit(self) -> str:
        """The unit in which the value will be displayed in the GUI."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_custom_display_unit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @custom_display_unit.setter
    def custom_display_unit(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_custom_display_unit"](arg_newVal.COM_val))

    @property
    def values(self) -> list:
        """List of values of this independent variable at each iteration, including nominal run. Dimension depends on context."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_values"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{5F55DF8A-688A-48E6-A084-48E270AB766E}", IDifferentialCorrectorControl)
agcls.AgTypeNameMap["IDifferentialCorrectorControl"] = IDifferentialCorrectorControl

class IDifferentialCorrectorResult(object):
    """Properties for equality constraints of a differential corrector profile."""
    _uuid = "{F55E0916-7FAE-469B-AB4F-9D09C26BB554}"
    _num_methods = 22
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_enable"] = _raise_uninitialized_error
        self.__dict__["_set_enable"] = _raise_uninitialized_error
        self.__dict__["_get_name"] = _raise_uninitialized_error
        self.__dict__["_get_desired_value"] = _raise_uninitialized_error
        self.__dict__["_set_desired_value"] = _raise_uninitialized_error
        self.__dict__["_get_current_value"] = _raise_uninitialized_error
        self.__dict__["_get_parent_name"] = _raise_uninitialized_error
        self.__dict__["_get_difference"] = _raise_uninitialized_error
        self.__dict__["_get_tolerance"] = _raise_uninitialized_error
        self.__dict__["_set_tolerance"] = _raise_uninitialized_error
        self.__dict__["_get_scaling_method"] = _raise_uninitialized_error
        self.__dict__["_set_scaling_method"] = _raise_uninitialized_error
        self.__dict__["_get_scaling_value"] = _raise_uninitialized_error
        self.__dict__["_set_scaling_value"] = _raise_uninitialized_error
        self.__dict__["_get_weight"] = _raise_uninitialized_error
        self.__dict__["_set_weight"] = _raise_uninitialized_error
        self.__dict__["_get_dimension"] = _raise_uninitialized_error
        self.__dict__["_get_use_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_set_use_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_get_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_set_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_get_values"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IDifferentialCorrectorResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IDifferentialCorrectorResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IDifferentialCorrectorResult = agcom.GUID(IDifferentialCorrectorResult._uuid)
        vtable_offset_local = IDifferentialCorrectorResult._vtable_offset - 1
        self.__dict__["_get_enable"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorResult, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_name"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorResult, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_get_desired_value"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorResult, vtable_offset_local+4, POINTER(agcom.VARIANT))
        self.__dict__["_set_desired_value"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorResult, vtable_offset_local+5, agcom.VARIANT)
        self.__dict__["_get_current_value"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorResult, vtable_offset_local+6, POINTER(agcom.VARIANT))
        self.__dict__["_get_parent_name"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorResult, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_get_difference"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorResult, vtable_offset_local+8, POINTER(agcom.VARIANT))
        self.__dict__["_get_tolerance"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorResult, vtable_offset_local+9, POINTER(agcom.VARIANT))
        self.__dict__["_set_tolerance"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorResult, vtable_offset_local+10, agcom.VARIANT)
        self.__dict__["_get_scaling_method"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorResult, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_set_scaling_method"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorResult, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_get_scaling_value"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorResult, vtable_offset_local+13, POINTER(agcom.VARIANT))
        self.__dict__["_set_scaling_value"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorResult, vtable_offset_local+14, agcom.VARIANT)
        self.__dict__["_get_weight"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorResult, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_weight"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorResult, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_dimension"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorResult, vtable_offset_local+17, POINTER(agcom.BSTR))
        self.__dict__["_get_use_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorResult, vtable_offset_local+18, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorResult, vtable_offset_local+19, agcom.VARIANT_BOOL)
        self.__dict__["_get_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorResult, vtable_offset_local+20, POINTER(agcom.BSTR))
        self.__dict__["_set_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorResult, vtable_offset_local+21, agcom.BSTR)
        self.__dict__["_get_values"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorResult, vtable_offset_local+22, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IDifferentialCorrectorResult.__dict__ and type(IDifferentialCorrectorResult.__dict__[attrname]) == property:
            return IDifferentialCorrectorResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IDifferentialCorrectorResult.")
    
    @property
    def enable(self) -> bool:
        """If true, the variable is being used."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable.setter
    def enable(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable"](arg_newVal.COM_val))

    @property
    def name(self) -> str:
        """The name of the parameter."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def desired_value(self) -> typing.Any:
        """The desired value. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_desired_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @desired_value.setter
    def desired_value(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_desired_value"](arg_newVal.COM_val))

    @property
    def current_value(self) -> typing.Any:
        """The value achieved for this dependent variable in the last targeter run. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_current_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def parent_name(self) -> str:
        """Object - the name of the segment to which the parameter belongs."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_parent_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def difference(self) -> typing.Any:
        """The difference between the current and desired value for this dependent variable. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_difference"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def tolerance(self) -> typing.Any:
        """How close the targeter should come to the desired value before stopping. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_tolerance"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @tolerance.setter
    def tolerance(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_tolerance"](arg_newVal.COM_val))

    @property
    def scaling_method(self) -> "AgEVADCScalingMethod":
        """Allows better numerical behavior if the constraints have very different magnitudes. The same scaling method is applied to all constraints."""
        with agmarshall.AgEnum_arg(AgEVADCScalingMethod) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_scaling_method"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @scaling_method.setter
    def scaling_method(self, newVal:"AgEVADCScalingMethod") -> None:
        with agmarshall.AgEnum_arg(AgEVADCScalingMethod, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_scaling_method"](arg_newVal.COM_val))

    @property
    def scaling_value(self) -> typing.Any:
        """Applies to the Specified Value scaling method. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_scaling_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @scaling_value.setter
    def scaling_value(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_scaling_value"](arg_newVal.COM_val))

    @property
    def weight(self) -> float:
        """The factor by which the constraint error is to be multiplied. This is used to emphasize/de-emphasize the importance of one constraint relative to the others. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_weight"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @weight.setter
    def weight(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_weight"](arg_newVal.COM_val))

    @property
    def dimension(self) -> str:
        """The dimension of the values."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_dimension"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def use_custom_display_unit(self) -> bool:
        """If true, allows display of values in another unit."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_custom_display_unit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_custom_display_unit.setter
    def use_custom_display_unit(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_custom_display_unit"](arg_newVal.COM_val))

    @property
    def custom_display_unit(self) -> str:
        """The unit in which the value will be displayed in the GUI."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_custom_display_unit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @custom_display_unit.setter
    def custom_display_unit(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_custom_display_unit"](arg_newVal.COM_val))

    @property
    def values(self) -> list:
        """List of values of this dependent variable at each iteration, including nominal run. Dimension depends on context."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_values"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{F55E0916-7FAE-469B-AB4F-9D09C26BB554}", IDifferentialCorrectorResult)
agcls.AgTypeNameMap["IDifferentialCorrectorResult"] = IDifferentialCorrectorResult

class ISearchPluginControl(object):
    """Properties of search plugin control parameters."""
    _uuid = "{71AB197F-79CB-438C-8F0A-A48FA0069865}"
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_control_name"] = _raise_uninitialized_error
        self.__dict__["_get_current_value"] = _raise_uninitialized_error
        self.__dict__["_get_parent_segment_name"] = _raise_uninitialized_error
        self.__dict__["_get_initial_value"] = _raise_uninitialized_error
        self.__dict__["_get_plugin_identifier"] = _raise_uninitialized_error
        self.__dict__["_get_plugin_config"] = _raise_uninitialized_error
        self.__dict__["_get_dimension"] = _raise_uninitialized_error
        self.__dict__["_get_use_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_set_use_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_get_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_set_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_get_values"] = _raise_uninitialized_error
        self.__dict__["_set_current_value"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISearchPluginControl._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISearchPluginControl from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISearchPluginControl = agcom.GUID(ISearchPluginControl._uuid)
        vtable_offset_local = ISearchPluginControl._vtable_offset - 1
        self.__dict__["_get_control_name"] = IAGFUNCTYPE(pUnk, IID_ISearchPluginControl, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_get_current_value"] = IAGFUNCTYPE(pUnk, IID_ISearchPluginControl, vtable_offset_local+2, POINTER(agcom.VARIANT))
        self.__dict__["_get_parent_segment_name"] = IAGFUNCTYPE(pUnk, IID_ISearchPluginControl, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_get_initial_value"] = IAGFUNCTYPE(pUnk, IID_ISearchPluginControl, vtable_offset_local+4, POINTER(agcom.VARIANT))
        self.__dict__["_get_plugin_identifier"] = IAGFUNCTYPE(pUnk, IID_ISearchPluginControl, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_get_plugin_config"] = IAGFUNCTYPE(pUnk, IID_ISearchPluginControl, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_get_dimension"] = IAGFUNCTYPE(pUnk, IID_ISearchPluginControl, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_get_use_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_ISearchPluginControl, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_ISearchPluginControl, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_get_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_ISearchPluginControl, vtable_offset_local+10, POINTER(agcom.BSTR))
        self.__dict__["_set_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_ISearchPluginControl, vtable_offset_local+11, agcom.BSTR)
        self.__dict__["_get_values"] = IAGFUNCTYPE(pUnk, IID_ISearchPluginControl, vtable_offset_local+12, POINTER(agcom.SAFEARRAY))
        self.__dict__["_set_current_value"] = IAGFUNCTYPE(pUnk, IID_ISearchPluginControl, vtable_offset_local+13, agcom.VARIANT)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISearchPluginControl.__dict__ and type(ISearchPluginControl.__dict__[attrname]) == property:
            return ISearchPluginControl.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISearchPluginControl.")
    
    @property
    def control_name(self) -> str:
        """The name of the control parameter."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def current_value(self) -> typing.Any:
        """The current value of the control parameter."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_current_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def parent_segment_name(self) -> str:
        """The parent segment of the control parameter."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_parent_segment_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def initial_value(self) -> typing.Any:
        """The initial value of the control parameter. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_initial_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def plugin_identifier(self) -> str:
        """The plugin identifier."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_plugin_identifier"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def plugin_config(self) -> "IPluginProperties":
        """The properties of the selected plugin."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_plugin_config"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def dimension(self) -> str:
        """The dimension of the values."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_dimension"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def use_custom_display_unit(self) -> bool:
        """If true, allows display of values in another unit."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_custom_display_unit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_custom_display_unit.setter
    def use_custom_display_unit(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_custom_display_unit"](arg_newVal.COM_val))

    @property
    def custom_display_unit(self) -> str:
        """The unit in which the value will be displayed in the GUI."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_custom_display_unit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @custom_display_unit.setter
    def custom_display_unit(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_custom_display_unit"](arg_newVal.COM_val))

    @property
    def values(self) -> list:
        """List of values of this independent variable at each iteration, including nominal run. Dimension depends on context."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_values"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @current_value.setter
    def current_value(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_current_value"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{71AB197F-79CB-438C-8F0A-A48FA0069865}", ISearchPluginControl)
agcls.AgTypeNameMap["ISearchPluginControl"] = ISearchPluginControl

class ISearchPluginResult(object):
    """Properties of search plugin equality constraints."""
    _uuid = "{7881FB30-0FB9-43EF-98A1-9CF84D69A23F}"
    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_result_name"] = _raise_uninitialized_error
        self.__dict__["_get_current_value"] = _raise_uninitialized_error
        self.__dict__["_get_parent_segment_name"] = _raise_uninitialized_error
        self.__dict__["_get_plugin_identifier"] = _raise_uninitialized_error
        self.__dict__["_get_plugin_config"] = _raise_uninitialized_error
        self.__dict__["_get_dimension"] = _raise_uninitialized_error
        self.__dict__["_get_use_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_set_use_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_get_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_set_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_get_values"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISearchPluginResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISearchPluginResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISearchPluginResult = agcom.GUID(ISearchPluginResult._uuid)
        vtable_offset_local = ISearchPluginResult._vtable_offset - 1
        self.__dict__["_get_result_name"] = IAGFUNCTYPE(pUnk, IID_ISearchPluginResult, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_get_current_value"] = IAGFUNCTYPE(pUnk, IID_ISearchPluginResult, vtable_offset_local+2, POINTER(agcom.VARIANT))
        self.__dict__["_get_parent_segment_name"] = IAGFUNCTYPE(pUnk, IID_ISearchPluginResult, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_get_plugin_identifier"] = IAGFUNCTYPE(pUnk, IID_ISearchPluginResult, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_get_plugin_config"] = IAGFUNCTYPE(pUnk, IID_ISearchPluginResult, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_dimension"] = IAGFUNCTYPE(pUnk, IID_ISearchPluginResult, vtable_offset_local+6, POINTER(agcom.BSTR))
        self.__dict__["_get_use_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_ISearchPluginResult, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_ISearchPluginResult, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_get_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_ISearchPluginResult, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_set_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_ISearchPluginResult, vtable_offset_local+10, agcom.BSTR)
        self.__dict__["_get_values"] = IAGFUNCTYPE(pUnk, IID_ISearchPluginResult, vtable_offset_local+11, POINTER(agcom.SAFEARRAY))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISearchPluginResult.__dict__ and type(ISearchPluginResult.__dict__[attrname]) == property:
            return ISearchPluginResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISearchPluginResult.")
    
    @property
    def result_name(self) -> str:
        """The name of the equality constraint."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_result_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def current_value(self) -> typing.Any:
        """The current value of the result variable."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_current_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def parent_segment_name(self) -> str:
        """The parent segment of the result variable."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_parent_segment_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def plugin_identifier(self) -> str:
        """The plugin identifier."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_plugin_identifier"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def plugin_config(self) -> "IPluginProperties":
        """The properties of the selected plugin."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_plugin_config"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def dimension(self) -> str:
        """The dimension of the values."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_dimension"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def use_custom_display_unit(self) -> bool:
        """If true, allows display of values in another unit."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_custom_display_unit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_custom_display_unit.setter
    def use_custom_display_unit(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_custom_display_unit"](arg_newVal.COM_val))

    @property
    def custom_display_unit(self) -> str:
        """The unit in which the value will be displayed in the GUI."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_custom_display_unit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @custom_display_unit.setter
    def custom_display_unit(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_custom_display_unit"](arg_newVal.COM_val))

    @property
    def values(self) -> list:
        """List of values of this dependent variable at each iteration, including nominal run. Dimension depends on context."""
        with agmarshall.SAFEARRAY_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_values"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{7881FB30-0FB9-43EF-98A1-9CF84D69A23F}", ISearchPluginResult)
agcls.AgTypeNameMap["ISearchPluginResult"] = ISearchPluginResult

class ISearchPluginResultCollection(object):
    """Properties for the list of search plugin equality constraints."""
    _uuid = "{48F5FEA5-9306-4115-B120-E479FD31A601}"
    _num_methods = 4
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_get_result_by_paths"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISearchPluginResultCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISearchPluginResultCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISearchPluginResultCollection = agcom.GUID(ISearchPluginResultCollection._uuid)
        vtable_offset_local = ISearchPluginResultCollection._vtable_offset - 1
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_ISearchPluginResultCollection, vtable_offset_local+1, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_ISearchPluginResultCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_ISearchPluginResultCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_get_result_by_paths"] = IAGFUNCTYPE(pUnk, IID_ISearchPluginResultCollection, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISearchPluginResultCollection.__dict__ and type(ISearchPluginResultCollection.__dict__[attrname]) == property:
            return ISearchPluginResultCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISearchPluginResultCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ISearchPluginResult":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def item(self, index:int) -> "ISearchPluginResult":
        """Allows you to iterate through the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_searchConstraintResult:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_index.COM_val, byref(arg_searchConstraintResult.COM_val)))
            return arg_searchConstraintResult.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Function to enumerate through the collection"""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def count(self) -> int:
        """Size of the collection"""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def get_result_by_paths(self, objectPath:str, resultPath:str) -> "ISearchPluginResult":
        """Returns the result specified by the object/result path."""
        with agmarshall.BSTR_arg(objectPath) as arg_objectPath, \
             agmarshall.BSTR_arg(resultPath) as arg_resultPath, \
             agmarshall.AgInterface_out_arg() as arg_searchConstraintResult:
            agcls.evaluate_hresult(self.__dict__["_get_result_by_paths"](arg_objectPath.COM_val, arg_resultPath.COM_val, byref(arg_searchConstraintResult.COM_val)))
            return arg_searchConstraintResult.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{48F5FEA5-9306-4115-B120-E479FD31A601}", ISearchPluginResultCollection)
agcls.AgTypeNameMap["ISearchPluginResultCollection"] = ISearchPluginResultCollection

class ISearchPluginControlCollection(object):
    """Properties for the list of search plugin control parameters."""
    _uuid = "{6DAD8352-416A-402F-BD38-40CEF9E0CE4C}"
    _num_methods = 4
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_get_control_by_paths"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISearchPluginControlCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISearchPluginControlCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISearchPluginControlCollection = agcom.GUID(ISearchPluginControlCollection._uuid)
        vtable_offset_local = ISearchPluginControlCollection._vtable_offset - 1
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_ISearchPluginControlCollection, vtable_offset_local+1, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_ISearchPluginControlCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_ISearchPluginControlCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_get_control_by_paths"] = IAGFUNCTYPE(pUnk, IID_ISearchPluginControlCollection, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISearchPluginControlCollection.__dict__ and type(ISearchPluginControlCollection.__dict__[attrname]) == property:
            return ISearchPluginControlCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISearchPluginControlCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ISearchPluginControl":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def item(self, index:int) -> "ISearchPluginControl":
        """Allows you to iterate through the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_searchPluginControl:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_index.COM_val, byref(arg_searchPluginControl.COM_val)))
            return arg_searchPluginControl.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Property that allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def get_control_by_paths(self, objectPath:str, controlPath:str) -> "ISearchPluginControl":
        """Returns the control specified by the object/control path."""
        with agmarshall.BSTR_arg(objectPath) as arg_objectPath, \
             agmarshall.BSTR_arg(controlPath) as arg_controlPath, \
             agmarshall.AgInterface_out_arg() as arg_searchPluginControl:
            agcls.evaluate_hresult(self.__dict__["_get_control_by_paths"](arg_objectPath.COM_val, arg_controlPath.COM_val, byref(arg_searchPluginControl.COM_val)))
            return arg_searchPluginControl.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{6DAD8352-416A-402F-BD38-40CEF9E0CE4C}", ISearchPluginControlCollection)
agcls.AgTypeNameMap["ISearchPluginControlCollection"] = ISearchPluginControlCollection

class IDifferentialCorrectorControlCollection(object):
    """Properties for the list of control parameters for a differential corrector profile."""
    _uuid = "{271A0046-EC08-49FC-A75A-4D49B6E7AD3A}"
    _num_methods = 5
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_get_control_by_paths"] = _raise_uninitialized_error
        self.__dict__["_get_provide_runtime_type_info"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IDifferentialCorrectorControlCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IDifferentialCorrectorControlCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IDifferentialCorrectorControlCollection = agcom.GUID(IDifferentialCorrectorControlCollection._uuid)
        vtable_offset_local = IDifferentialCorrectorControlCollection._vtable_offset - 1
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorControlCollection, vtable_offset_local+1, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorControlCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorControlCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_get_control_by_paths"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorControlCollection, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_get_provide_runtime_type_info"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorControlCollection, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IDifferentialCorrectorControlCollection.__dict__ and type(IDifferentialCorrectorControlCollection.__dict__[attrname]) == property:
            return IDifferentialCorrectorControlCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IDifferentialCorrectorControlCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IDifferentialCorrectorControl":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def item(self, index:int) -> "IDifferentialCorrectorControl":
        """Allows you to iterate through the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_dCControl:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_index.COM_val, byref(arg_dCControl.COM_val)))
            return arg_dCControl.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def get_control_by_paths(self, objectPath:str, controlPath:str) -> "IDifferentialCorrectorControl":
        """Returns the control specified by the object/control path."""
        with agmarshall.BSTR_arg(objectPath) as arg_objectPath, \
             agmarshall.BSTR_arg(controlPath) as arg_controlPath, \
             agmarshall.AgInterface_out_arg() as arg_dCControl:
            agcls.evaluate_hresult(self.__dict__["_get_control_by_paths"](arg_objectPath.COM_val, arg_controlPath.COM_val, byref(arg_dCControl.COM_val)))
            return arg_dCControl.python_val

    @property
    def provide_runtime_type_info(self) -> "IRuntimeTypeInfo":
        """Returns the IRuntimeTypeInfo interface to access properties at runtime."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_provide_runtime_type_info"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{271A0046-EC08-49FC-A75A-4D49B6E7AD3A}", IDifferentialCorrectorControlCollection)
agcls.AgTypeNameMap["IDifferentialCorrectorControlCollection"] = IDifferentialCorrectorControlCollection

class IDifferentialCorrectorResultCollection(object):
    """Differential Corrector result collection."""
    _uuid = "{1AB78F87-F0BC-42DF-80C9-AAACF11FE5D4}"
    _num_methods = 5
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_get_result_by_paths"] = _raise_uninitialized_error
        self.__dict__["_get_provide_runtime_type_info"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IDifferentialCorrectorResultCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IDifferentialCorrectorResultCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IDifferentialCorrectorResultCollection = agcom.GUID(IDifferentialCorrectorResultCollection._uuid)
        vtable_offset_local = IDifferentialCorrectorResultCollection._vtable_offset - 1
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorResultCollection, vtable_offset_local+1, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorResultCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorResultCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_get_result_by_paths"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorResultCollection, vtable_offset_local+4, agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_get_provide_runtime_type_info"] = IAGFUNCTYPE(pUnk, IID_IDifferentialCorrectorResultCollection, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IDifferentialCorrectorResultCollection.__dict__ and type(IDifferentialCorrectorResultCollection.__dict__[attrname]) == property:
            return IDifferentialCorrectorResultCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IDifferentialCorrectorResultCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IDifferentialCorrectorResult":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def item(self, index:int) -> "IDifferentialCorrectorResult":
        """Allows you to iterate through the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_dCResult:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_index.COM_val, byref(arg_dCResult.COM_val)))
            return arg_dCResult.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def get_result_by_paths(self, objectPath:str, resultPath:str) -> "IDifferentialCorrectorResult":
        """Returns the result specified by the object/result path."""
        with agmarshall.BSTR_arg(objectPath) as arg_objectPath, \
             agmarshall.BSTR_arg(resultPath) as arg_resultPath, \
             agmarshall.AgInterface_out_arg() as arg_dCResult:
            agcls.evaluate_hresult(self.__dict__["_get_result_by_paths"](arg_objectPath.COM_val, arg_resultPath.COM_val, byref(arg_dCResult.COM_val)))
            return arg_dCResult.python_val

    @property
    def provide_runtime_type_info(self) -> "IRuntimeTypeInfo":
        """Returns the IRuntimeTypeInfo interface to access properties at runtime."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_provide_runtime_type_info"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{1AB78F87-F0BC-42DF-80C9-AAACF11FE5D4}", IDifferentialCorrectorResultCollection)
agcls.AgTypeNameMap["IDifferentialCorrectorResultCollection"] = IDifferentialCorrectorResultCollection

class ITargeterGraphActiveControl(object):
    """Properties for targeter graph active control."""
    _uuid = "{341791C5-446F-4812-BDE8-702EE9D3D980}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_name"] = _raise_uninitialized_error
        self.__dict__["_get_parent_name"] = _raise_uninitialized_error
        self.__dict__["_get_show_graph_value"] = _raise_uninitialized_error
        self.__dict__["_set_show_graph_value"] = _raise_uninitialized_error
        self.__dict__["_get_line_color"] = _raise_uninitialized_error
        self.__dict__["_set_line_color"] = _raise_uninitialized_error
        self.__dict__["_get_point_style"] = _raise_uninitialized_error
        self.__dict__["_set_point_style"] = _raise_uninitialized_error
        self.__dict__["_get_y_axis"] = _raise_uninitialized_error
        self.__dict__["_set_y_axis"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITargeterGraphActiveControl._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITargeterGraphActiveControl from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITargeterGraphActiveControl = agcom.GUID(ITargeterGraphActiveControl._uuid)
        vtable_offset_local = ITargeterGraphActiveControl._vtable_offset - 1
        self.__dict__["_get_name"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphActiveControl, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_get_parent_name"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphActiveControl, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_get_show_graph_value"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphActiveControl, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_show_graph_value"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphActiveControl, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_get_line_color"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphActiveControl, vtable_offset_local+5, POINTER(agcom.OLE_COLOR))
        self.__dict__["_set_line_color"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphActiveControl, vtable_offset_local+6, agcom.OLE_COLOR)
        self.__dict__["_get_point_style"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphActiveControl, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_set_point_style"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphActiveControl, vtable_offset_local+8, agcom.BSTR)
        self.__dict__["_get_y_axis"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphActiveControl, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_set_y_axis"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphActiveControl, vtable_offset_local+10, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITargeterGraphActiveControl.__dict__ and type(ITargeterGraphActiveControl.__dict__[attrname]) == property:
            return ITargeterGraphActiveControl.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITargeterGraphActiveControl.")
    
    @property
    def name(self) -> str:
        """The name of the active control."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_name"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def parent_name(self) -> str:
        """The segment or component to which the element belongs."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_parent_name"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def show_graph_value(self) -> bool:
        """Show the value."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_show_graph_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @show_graph_value.setter
    def show_graph_value(self, inVal:bool) -> None:
        """Show the value."""
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_show_graph_value"](arg_inVal.COM_val))

    @property
    def line_color(self) -> agcolor.Color:
        """Line Color."""
        with agmarshall.OLE_COLOR_arg() as arg_pValue:
            agcls.evaluate_hresult(self.__dict__["_get_line_color"](byref(arg_pValue.COM_val)))
            return arg_pValue.python_val

    @line_color.setter
    def line_color(self, inVal:agcolor.Color) -> None:
        """Line Color."""
        with agmarshall.OLE_COLOR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_line_color"](arg_inVal.COM_val))

    @property
    def point_style(self) -> str:
        """Point Style."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_point_style"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @point_style.setter
    def point_style(self, inVal:str) -> None:
        """Point Style."""
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_point_style"](arg_inVal.COM_val))

    @property
    def y_axis(self) -> str:
        """Select whether to display the control's value range on the left or right side of the graph."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_y_axis"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @y_axis.setter
    def y_axis(self, inVal:str) -> None:
        """Select whether to display the control's value range on the left or right side of the graph."""
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_y_axis"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{341791C5-446F-4812-BDE8-702EE9D3D980}", ITargeterGraphActiveControl)
agcls.AgTypeNameMap["ITargeterGraphActiveControl"] = ITargeterGraphActiveControl

class ITargeterGraphResult(object):
    """Properties for targeter graph result."""
    _uuid = "{16985A6D-61AE-467F-9A66-255556F9C8E1}"
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_name"] = _raise_uninitialized_error
        self.__dict__["_get_parent_name"] = _raise_uninitialized_error
        self.__dict__["_get_show_desired_value"] = _raise_uninitialized_error
        self.__dict__["_set_show_desired_value"] = _raise_uninitialized_error
        self.__dict__["_get_line_color"] = _raise_uninitialized_error
        self.__dict__["_set_line_color"] = _raise_uninitialized_error
        self.__dict__["_get_point_style"] = _raise_uninitialized_error
        self.__dict__["_set_point_style"] = _raise_uninitialized_error
        self.__dict__["_get_y_axis"] = _raise_uninitialized_error
        self.__dict__["_set_y_axis"] = _raise_uninitialized_error
        self.__dict__["_get_graph_option"] = _raise_uninitialized_error
        self.__dict__["_set_graph_option"] = _raise_uninitialized_error
        self.__dict__["_get_show_tolerance_band"] = _raise_uninitialized_error
        self.__dict__["_set_show_tolerance_band"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITargeterGraphResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITargeterGraphResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITargeterGraphResult = agcom.GUID(ITargeterGraphResult._uuid)
        vtable_offset_local = ITargeterGraphResult._vtable_offset - 1
        self.__dict__["_get_name"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphResult, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_get_parent_name"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphResult, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_get_show_desired_value"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphResult, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_show_desired_value"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphResult, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_get_line_color"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphResult, vtable_offset_local+5, POINTER(agcom.OLE_COLOR))
        self.__dict__["_set_line_color"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphResult, vtable_offset_local+6, agcom.OLE_COLOR)
        self.__dict__["_get_point_style"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphResult, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_set_point_style"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphResult, vtable_offset_local+8, agcom.BSTR)
        self.__dict__["_get_y_axis"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphResult, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_set_y_axis"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphResult, vtable_offset_local+10, agcom.BSTR)
        self.__dict__["_get_graph_option"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphResult, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_set_graph_option"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphResult, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_get_show_tolerance_band"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphResult, vtable_offset_local+13, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_show_tolerance_band"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphResult, vtable_offset_local+14, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITargeterGraphResult.__dict__ and type(ITargeterGraphResult.__dict__[attrname]) == property:
            return ITargeterGraphResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITargeterGraphResult.")
    
    @property
    def name(self) -> str:
        """The name of the result."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_name"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def parent_name(self) -> str:
        """The segment or component for which this result has been selected."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_parent_name"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def show_desired_value(self) -> bool:
        """Show the desired value."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_show_desired_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @show_desired_value.setter
    def show_desired_value(self, inVal:bool) -> None:
        """Show the desired value."""
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_show_desired_value"](arg_inVal.COM_val))

    @property
    def line_color(self) -> agcolor.Color:
        """Line Color."""
        with agmarshall.OLE_COLOR_arg() as arg_pValue:
            agcls.evaluate_hresult(self.__dict__["_get_line_color"](byref(arg_pValue.COM_val)))
            return arg_pValue.python_val

    @line_color.setter
    def line_color(self, inVal:agcolor.Color) -> None:
        """Line Color."""
        with agmarshall.OLE_COLOR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_line_color"](arg_inVal.COM_val))

    @property
    def point_style(self) -> str:
        """Point Style."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_point_style"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @point_style.setter
    def point_style(self, inVal:str) -> None:
        """Point Style."""
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_point_style"](arg_inVal.COM_val))

    @property
    def y_axis(self) -> str:
        """Select whether to display the result's value range on the left or right side of the graph."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_y_axis"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @y_axis.setter
    def y_axis(self, inVal:str) -> None:
        """Select whether to display the result's value range on the left or right side of the graph."""
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_y_axis"](arg_inVal.COM_val))

    @property
    def graph_option(self) -> "AgEVAGraphOption":
        """Graph option."""
        with agmarshall.AgEnum_arg(AgEVAGraphOption) as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_graph_option"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @graph_option.setter
    def graph_option(self, inVal:"AgEVAGraphOption") -> None:
        """Graph option."""
        with agmarshall.AgEnum_arg(AgEVAGraphOption, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_graph_option"](arg_inVal.COM_val))

    @property
    def show_tolerance_band(self) -> bool:
        """Show the tolerance band."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_show_tolerance_band"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @show_tolerance_band.setter
    def show_tolerance_band(self, inVal:bool) -> None:
        """Show the tolerance band."""
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_show_tolerance_band"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{16985A6D-61AE-467F-9A66-255556F9C8E1}", ITargeterGraphResult)
agcls.AgTypeNameMap["ITargeterGraphResult"] = ITargeterGraphResult

class ITargeterGraphActiveControlCollection(object):
    """Targeter graph active controls."""
    _uuid = "{57FE9616-8C44-4F5B-8B31-F005C0B678A2}"
    _num_methods = 4
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_get_provide_runtime_type_info"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITargeterGraphActiveControlCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITargeterGraphActiveControlCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITargeterGraphActiveControlCollection = agcom.GUID(ITargeterGraphActiveControlCollection._uuid)
        vtable_offset_local = ITargeterGraphActiveControlCollection._vtable_offset - 1
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphActiveControlCollection, vtable_offset_local+1, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphActiveControlCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphActiveControlCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_get_provide_runtime_type_info"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphActiveControlCollection, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITargeterGraphActiveControlCollection.__dict__ and type(ITargeterGraphActiveControlCollection.__dict__[attrname]) == property:
            return ITargeterGraphActiveControlCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITargeterGraphActiveControlCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ITargeterGraphActiveControl":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def item(self, index:int) -> "ITargeterGraphActiveControl":
        """Allows you to iterate through the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_dCControl:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_index.COM_val, byref(arg_dCControl.COM_val)))
            return arg_dCControl.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def provide_runtime_type_info(self) -> "IRuntimeTypeInfo":
        """Returns the IRuntimeTypeInfo interface to access properties at runtime."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_provide_runtime_type_info"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{57FE9616-8C44-4F5B-8B31-F005C0B678A2}", ITargeterGraphActiveControlCollection)
agcls.AgTypeNameMap["ITargeterGraphActiveControlCollection"] = ITargeterGraphActiveControlCollection

class ITargeterGraphResultCollection(object):
    """Targeter graph results."""
    _uuid = "{00E250BC-BA84-4ED7-A6A8-43FA17EF2731}"
    _num_methods = 4
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_get_provide_runtime_type_info"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITargeterGraphResultCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITargeterGraphResultCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITargeterGraphResultCollection = agcom.GUID(ITargeterGraphResultCollection._uuid)
        vtable_offset_local = ITargeterGraphResultCollection._vtable_offset - 1
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphResultCollection, vtable_offset_local+1, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphResultCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphResultCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_get_provide_runtime_type_info"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphResultCollection, vtable_offset_local+4, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITargeterGraphResultCollection.__dict__ and type(ITargeterGraphResultCollection.__dict__[attrname]) == property:
            return ITargeterGraphResultCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITargeterGraphResultCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ITargeterGraphResult":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def item(self, index:int) -> "ITargeterGraphResult":
        """Allows you to iterate through the collection."""
        with agmarshall.LONG_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_dCControl:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_index.COM_val, byref(arg_dCControl.COM_val)))
            return arg_dCControl.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def provide_runtime_type_info(self) -> "IRuntimeTypeInfo":
        """Returns the IRuntimeTypeInfo interface to access properties at runtime."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_provide_runtime_type_info"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{00E250BC-BA84-4ED7-A6A8-43FA17EF2731}", ITargeterGraphResultCollection)
agcls.AgTypeNameMap["ITargeterGraphResultCollection"] = ITargeterGraphResultCollection

class ITargeterGraph(object):
    """Properties for a Targeter Graph."""
    _uuid = "{418A2587-7803-4746-9A49-1B1A87BB906A}"
    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_name"] = _raise_uninitialized_error
        self.__dict__["_set_name"] = _raise_uninitialized_error
        self.__dict__["_get_generate_on_run"] = _raise_uninitialized_error
        self.__dict__["_set_generate_on_run"] = _raise_uninitialized_error
        self.__dict__["_get_user_comment"] = _raise_uninitialized_error
        self.__dict__["_set_user_comment"] = _raise_uninitialized_error
        self.__dict__["_get_show_label_iterations"] = _raise_uninitialized_error
        self.__dict__["_set_show_label_iterations"] = _raise_uninitialized_error
        self.__dict__["_get_show_desired_value"] = _raise_uninitialized_error
        self.__dict__["_set_show_desired_value"] = _raise_uninitialized_error
        self.__dict__["_get_show_tolerance_band"] = _raise_uninitialized_error
        self.__dict__["_set_show_tolerance_band"] = _raise_uninitialized_error
        self.__dict__["_get_independent_variable"] = _raise_uninitialized_error
        self.__dict__["_set_independent_variable"] = _raise_uninitialized_error
        self.__dict__["_get_active_controls"] = _raise_uninitialized_error
        self.__dict__["_get_results"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITargeterGraph._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITargeterGraph from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITargeterGraph = agcom.GUID(ITargeterGraph._uuid)
        vtable_offset_local = ITargeterGraph._vtable_offset - 1
        self.__dict__["_get_name"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraph, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_name"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraph, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_generate_on_run"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraph, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_generate_on_run"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraph, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_get_user_comment"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraph, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_set_user_comment"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraph, vtable_offset_local+6, agcom.BSTR)
        self.__dict__["_get_show_label_iterations"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraph, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_show_label_iterations"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraph, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_get_show_desired_value"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraph, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_show_desired_value"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraph, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_get_show_tolerance_band"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraph, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_show_tolerance_band"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraph, vtable_offset_local+12, agcom.VARIANT_BOOL)
        self.__dict__["_get_independent_variable"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraph, vtable_offset_local+13, POINTER(agcom.BSTR))
        self.__dict__["_set_independent_variable"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraph, vtable_offset_local+14, agcom.BSTR)
        self.__dict__["_get_active_controls"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraph, vtable_offset_local+15, POINTER(agcom.PVOID))
        self.__dict__["_get_results"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraph, vtable_offset_local+16, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITargeterGraph.__dict__ and type(ITargeterGraph.__dict__[attrname]) == property:
            return ITargeterGraph.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITargeterGraph.")
    
    @property
    def name(self) -> str:
        """The name of the graph."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_name"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @name.setter
    def name(self, inVal:str) -> None:
        """The name of the graph."""
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_name"](arg_inVal.COM_val))

    @property
    def generate_on_run(self) -> bool:
        """Generate the graph while MCS is being run."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_generate_on_run"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @generate_on_run.setter
    def generate_on_run(self, inVal:bool) -> None:
        """Generate the graph while MCS is being run."""
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_generate_on_run"](arg_inVal.COM_val))

    @property
    def user_comment(self) -> str:
        """User Comment."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_user_comment"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @user_comment.setter
    def user_comment(self, inVal:str) -> None:
        """User Comment."""
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_user_comment"](arg_inVal.COM_val))

    @property
    def show_label_iterations(self) -> bool:
        """Label each of the points on the graph labeled according to its iteration number."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_show_label_iterations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @show_label_iterations.setter
    def show_label_iterations(self, inVal:bool) -> None:
        """Label each of the points on the graph labeled according to its iteration number."""
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_show_label_iterations"](arg_inVal.COM_val))

    @property
    def show_desired_value(self) -> bool:
        """Show the desired equality constraint value(s) on the graph. Not applicable to SNOPT and IPOPT search profiles."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_show_desired_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @show_desired_value.setter
    def show_desired_value(self, inVal:bool) -> None:
        """Show the desired equality constraint value(s) on the graph. Not applicable to SNOPT and IPOPT search profiles."""
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_show_desired_value"](arg_inVal.COM_val))

    @property
    def show_tolerance_band(self) -> bool:
        """Show the tolerance band on the graph. Not applicable to SNOPT and IPOPT search profiles."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_show_tolerance_band"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @show_tolerance_band.setter
    def show_tolerance_band(self, inVal:bool) -> None:
        """Show the tolerance band on the graph. Not applicable to SNOPT and IPOPT search profiles."""
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_show_tolerance_band"](arg_inVal.COM_val))

    @property
    def independent_variable(self) -> str:
        """Select the graph's X axis."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_independent_variable"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @independent_variable.setter
    def independent_variable(self, inVal:str) -> None:
        """Select the graph's X axis."""
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_independent_variable"](arg_inVal.COM_val))

    @property
    def active_controls(self) -> "ITargeterGraphActiveControlCollection":
        """Active Controls."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_active_controls"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def results(self) -> "ITargeterGraphResultCollection":
        """Results."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_results"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{418A2587-7803-4746-9A49-1B1A87BB906A}", ITargeterGraph)
agcls.AgTypeNameMap["ITargeterGraph"] = ITargeterGraph

class ITargeterGraphCollection(object):
    """The list of User Variables accessed through the Driver."""
    _uuid = "{10EA0426-F62C-40C1-B1C6-A5B5E0BD0414}"
    _num_methods = 11
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_add_graph"] = _raise_uninitialized_error
        self.__dict__["_remove_graph"] = _raise_uninitialized_error
        self.__dict__["_get_provide_runtime_type_info"] = _raise_uninitialized_error
        self.__dict__["_cut"] = _raise_uninitialized_error
        self.__dict__["_paste"] = _raise_uninitialized_error
        self.__dict__["_insert_copy"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_index"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITargeterGraphCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITargeterGraphCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITargeterGraphCollection = agcom.GUID(ITargeterGraphCollection._uuid)
        vtable_offset_local = ITargeterGraphCollection._vtable_offset - 1
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphCollection, vtable_offset_local+1, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_add_graph"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphCollection, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_remove_graph"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphCollection, vtable_offset_local+5, agcom.VARIANT)
        self.__dict__["_get_provide_runtime_type_info"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphCollection, vtable_offset_local+6, POINTER(agcom.PVOID))
        self.__dict__["_cut"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphCollection, vtable_offset_local+7, agcom.VARIANT)
        self.__dict__["_paste"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphCollection, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_insert_copy"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphCollection, vtable_offset_local+9, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_get_item_by_index"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphCollection, vtable_offset_local+10, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_get_item_by_name"] = IAGFUNCTYPE(pUnk, IID_ITargeterGraphCollection, vtable_offset_local+11, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITargeterGraphCollection.__dict__ and type(ITargeterGraphCollection.__dict__[attrname]) == property:
            return ITargeterGraphCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITargeterGraphCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "ITargeterGraph":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def item(self, indexOrName:typing.Any) -> "ITargeterGraph":
        """Allows you to iterate through the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_targeterGraph:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_indexOrName.COM_val, byref(arg_targeterGraph.COM_val)))
            return arg_targeterGraph.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def add_graph(self) -> "ITargeterGraph":
        """Adds a new targeter graph."""
        with agmarshall.AgInterface_out_arg() as arg_targeterGraph:
            agcls.evaluate_hresult(self.__dict__["_add_graph"](byref(arg_targeterGraph.COM_val)))
            return arg_targeterGraph.python_val

    def remove_graph(self, indexOrName:typing.Any) -> None:
        """Removes a targeter graph."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_remove_graph"](arg_indexOrName.COM_val))

    @property
    def provide_runtime_type_info(self) -> "IRuntimeTypeInfo":
        """Returns the IRuntimeTypeInfo interface to access properties at runtime."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_provide_runtime_type_info"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def cut(self, indexOrName:typing.Any) -> None:
        """Copies a targeter graph to the clipboard and removes the targeter graph from the list."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_cut"](arg_indexOrName.COM_val))

    def paste(self) -> "ITargeterGraph":
        """Pastes a targeter graph from the clipboard into the list."""
        with agmarshall.AgInterface_out_arg() as arg_ppGraph:
            agcls.evaluate_hresult(self.__dict__["_paste"](byref(arg_ppGraph.COM_val)))
            return arg_ppGraph.python_val

    def insert_copy(self, graph:"ITargeterGraph") -> "ITargeterGraph":
        """Copies a targeter graph and inserts the copy into the list."""
        with agmarshall.AgInterface_in_arg(graph, ITargeterGraph) as arg_graph, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_insert_copy"](arg_graph.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def get_item_by_index(self, index:int) -> "ITargeterGraph":
        """Retrieves a targeter graph from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppTargeterGraph:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_index"](arg_index.COM_val, byref(arg_ppTargeterGraph.COM_val)))
            return arg_ppTargeterGraph.python_val

    def get_item_by_name(self, name:str) -> "ITargeterGraph":
        """Retrieves a targeter graph from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppTargeterGraph:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_name"](arg_name.COM_val, byref(arg_ppTargeterGraph.COM_val)))
            return arg_ppTargeterGraph.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{10EA0426-F62C-40C1-B1C6-A5B5E0BD0414}", ITargeterGraphCollection)
agcls.AgTypeNameMap["ITargeterGraphCollection"] = ITargeterGraphCollection

class IProfileSearchPlugin(IProfile):
    """Properties of a plugin search profile."""
    _uuid = "{9380509D-A189-453D-B1EF-D1D8E34420FF}"
    _num_methods = 9
    _vtable_offset = IProfile._vtable_offset + IProfile._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_controls"] = _raise_uninitialized_error
        self.__dict__["_get_results"] = _raise_uninitialized_error
        self.__dict__["_get_plugin_config"] = _raise_uninitialized_error
        self.__dict__["_get_plugin_identifier"] = _raise_uninitialized_error
        self.__dict__["_get_scripting_tool"] = _raise_uninitialized_error
        self.__dict__["_get_reset_controls_before_run"] = _raise_uninitialized_error
        self.__dict__["_set_reset_controls_before_run"] = _raise_uninitialized_error
        self.__dict__["_get_targeter_graphs"] = _raise_uninitialized_error
        self.__dict__["_get_log_file"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProfileSearchPlugin._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProfileSearchPlugin from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProfile._private_init(self, pUnk)
        IID_IProfileSearchPlugin = agcom.GUID(IProfileSearchPlugin._uuid)
        vtable_offset_local = IProfileSearchPlugin._vtable_offset - 1
        self.__dict__["_get_controls"] = IAGFUNCTYPE(pUnk, IID_IProfileSearchPlugin, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_results"] = IAGFUNCTYPE(pUnk, IID_IProfileSearchPlugin, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_plugin_config"] = IAGFUNCTYPE(pUnk, IID_IProfileSearchPlugin, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_plugin_identifier"] = IAGFUNCTYPE(pUnk, IID_IProfileSearchPlugin, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_get_scripting_tool"] = IAGFUNCTYPE(pUnk, IID_IProfileSearchPlugin, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_reset_controls_before_run"] = IAGFUNCTYPE(pUnk, IID_IProfileSearchPlugin, vtable_offset_local+6, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_reset_controls_before_run"] = IAGFUNCTYPE(pUnk, IID_IProfileSearchPlugin, vtable_offset_local+7, agcom.VARIANT_BOOL)
        self.__dict__["_get_targeter_graphs"] = IAGFUNCTYPE(pUnk, IID_IProfileSearchPlugin, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_get_log_file"] = IAGFUNCTYPE(pUnk, IID_IProfileSearchPlugin, vtable_offset_local+9, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProfileSearchPlugin.__dict__ and type(IProfileSearchPlugin.__dict__[attrname]) == property:
            return IProfileSearchPlugin.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IProfile.__setattr__(self, attrname, value)
    
    @property
    def controls(self) -> "ISearchPluginControlCollection":
        """The selected control parameters."""
        with agmarshall.AgInterface_out_arg() as arg_ppSearchPluginControlCollection:
            agcls.evaluate_hresult(self.__dict__["_get_controls"](byref(arg_ppSearchPluginControlCollection.COM_val)))
            return arg_ppSearchPluginControlCollection.python_val

    @property
    def results(self) -> "ISearchPluginResultCollection":
        """The selected equality constraints."""
        with agmarshall.AgInterface_out_arg() as arg_ppSearchPluginResultCollection:
            agcls.evaluate_hresult(self.__dict__["_get_results"](byref(arg_ppSearchPluginResultCollection.COM_val)))
            return arg_ppSearchPluginResultCollection.python_val

    @property
    def plugin_config(self) -> "IPluginProperties":
        """The properties of the selected plugin."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_plugin_config"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def plugin_identifier(self) -> str:
        """The plugin identifier."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_plugin_identifier"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @property
    def scripting_tool(self) -> "IScriptingTool":
        """Returns the Scripting tool for the sequence."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_scripting_tool"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def reset_controls_before_run(self) -> bool:
        """Reset controls before each run."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reset_controls_before_run"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reset_controls_before_run.setter
    def reset_controls_before_run(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_reset_controls_before_run"](arg_newVal.COM_val))

    @property
    def targeter_graphs(self) -> "ITargeterGraphCollection":
        """Graphs"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_targeter_graphs"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def log_file(self) -> str:
        """Name of the log file for this profile."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_log_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{9380509D-A189-453D-B1EF-D1D8E34420FF}", IProfileSearchPlugin)
agcls.AgTypeNameMap["IProfileSearchPlugin"] = IProfileSearchPlugin

class IProfileDifferentialCorrector(IProfile):
    """Properties for a Differential Corrector profile."""
    _uuid = "{E131F674-A7BA-408C-9109-BF50D16BE4F0}"
    _num_methods = 39
    _vtable_offset = IProfile._vtable_offset + IProfile._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_control_parameters"] = _raise_uninitialized_error
        self.__dict__["_get_results"] = _raise_uninitialized_error
        self.__dict__["_get_max_iterations"] = _raise_uninitialized_error
        self.__dict__["_set_max_iterations"] = _raise_uninitialized_error
        self.__dict__["_get_enable_display_status"] = _raise_uninitialized_error
        self.__dict__["_set_enable_display_status"] = _raise_uninitialized_error
        self.__dict__["_get_convergence_criteria"] = _raise_uninitialized_error
        self.__dict__["_set_convergence_criteria"] = _raise_uninitialized_error
        self.__dict__["_get_enable_line_search"] = _raise_uninitialized_error
        self.__dict__["_set_enable_line_search"] = _raise_uninitialized_error
        self.__dict__["_get_max_line_search_iterations"] = _raise_uninitialized_error
        self.__dict__["_set_max_line_search_iterations"] = _raise_uninitialized_error
        self.__dict__["_get_line_search_lower_bound"] = _raise_uninitialized_error
        self.__dict__["_set_line_search_lower_bound"] = _raise_uninitialized_error
        self.__dict__["_get_line_search_upper_bound"] = _raise_uninitialized_error
        self.__dict__["_set_line_search_upper_bound"] = _raise_uninitialized_error
        self.__dict__["_get_line_search_tolerance"] = _raise_uninitialized_error
        self.__dict__["_set_line_search_tolerance"] = _raise_uninitialized_error
        self.__dict__["_get_enable_homotopy"] = _raise_uninitialized_error
        self.__dict__["_set_enable_homotopy"] = _raise_uninitialized_error
        self.__dict__["_get_homotopy_steps"] = _raise_uninitialized_error
        self.__dict__["_set_homotopy_steps"] = _raise_uninitialized_error
        self.__dict__["_get_derivative_calc_method"] = _raise_uninitialized_error
        self.__dict__["_set_derivative_calc_method"] = _raise_uninitialized_error
        self.__dict__["_get_clear_corrections_before_run"] = _raise_uninitialized_error
        self.__dict__["_set_clear_corrections_before_run"] = _raise_uninitialized_error
        self.__dict__["_get_enable_b_plane_nominal"] = _raise_uninitialized_error
        self.__dict__["_set_enable_b_plane_nominal"] = _raise_uninitialized_error
        self.__dict__["_get_enable_b_plane_perturbations"] = _raise_uninitialized_error
        self.__dict__["_set_enable_b_plane_perturbations"] = _raise_uninitialized_error
        self.__dict__["_get_draw_perturbation"] = _raise_uninitialized_error
        self.__dict__["_set_draw_perturbation"] = _raise_uninitialized_error
        self.__dict__["_get_scripting_tool"] = _raise_uninitialized_error
        self.__dict__["_get_root_finding_algorithm"] = _raise_uninitialized_error
        self.__dict__["_set_root_finding_algorithm"] = _raise_uninitialized_error
        self.__dict__["_get_num_iterations"] = _raise_uninitialized_error
        self.__dict__["_get_targeter_graphs"] = _raise_uninitialized_error
        self.__dict__["_get_stop_on_limit_cycle_detection"] = _raise_uninitialized_error
        self.__dict__["_set_stop_on_limit_cycle_detection"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProfileDifferentialCorrector._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProfileDifferentialCorrector from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProfile._private_init(self, pUnk)
        IID_IProfileDifferentialCorrector = agcom.GUID(IProfileDifferentialCorrector._uuid)
        vtable_offset_local = IProfileDifferentialCorrector._vtable_offset - 1
        self.__dict__["_get_control_parameters"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_results"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_max_iterations"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_max_iterations"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_enable_display_status"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable_display_status"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_get_convergence_criteria"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_convergence_criteria"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_enable_line_search"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable_line_search"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_get_max_line_search_iterations"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_set_max_line_search_iterations"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_get_line_search_lower_bound"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_line_search_lower_bound"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_line_search_upper_bound"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_line_search_upper_bound"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_line_search_tolerance"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_line_search_tolerance"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_enable_homotopy"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+19, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable_homotopy"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+20, agcom.VARIANT_BOOL)
        self.__dict__["_get_homotopy_steps"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+21, POINTER(agcom.LONG))
        self.__dict__["_set_homotopy_steps"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+22, agcom.LONG)
        self.__dict__["_get_derivative_calc_method"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+23, POINTER(agcom.LONG))
        self.__dict__["_set_derivative_calc_method"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+24, agcom.LONG)
        self.__dict__["_get_clear_corrections_before_run"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+25, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_clear_corrections_before_run"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+26, agcom.VARIANT_BOOL)
        self.__dict__["_get_enable_b_plane_nominal"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+27, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable_b_plane_nominal"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+28, agcom.VARIANT_BOOL)
        self.__dict__["_get_enable_b_plane_perturbations"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+29, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable_b_plane_perturbations"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+30, agcom.VARIANT_BOOL)
        self.__dict__["_get_draw_perturbation"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+31, POINTER(agcom.LONG))
        self.__dict__["_set_draw_perturbation"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+32, agcom.LONG)
        self.__dict__["_get_scripting_tool"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+33, POINTER(agcom.PVOID))
        self.__dict__["_get_root_finding_algorithm"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+34, POINTER(agcom.LONG))
        self.__dict__["_set_root_finding_algorithm"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+35, agcom.LONG)
        self.__dict__["_get_num_iterations"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+36, POINTER(agcom.LONG))
        self.__dict__["_get_targeter_graphs"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+37, POINTER(agcom.PVOID))
        self.__dict__["_get_stop_on_limit_cycle_detection"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+38, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_stop_on_limit_cycle_detection"] = IAGFUNCTYPE(pUnk, IID_IProfileDifferentialCorrector, vtable_offset_local+39, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProfileDifferentialCorrector.__dict__ and type(IProfileDifferentialCorrector.__dict__[attrname]) == property:
            return IProfileDifferentialCorrector.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IProfile.__setattr__(self, attrname, value)
    
    @property
    def control_parameters(self) -> "IDifferentialCorrectorControlCollection":
        """The list of control parameters defined for the profile."""
        with agmarshall.AgInterface_out_arg() as arg_ppVADCControlCollection:
            agcls.evaluate_hresult(self.__dict__["_get_control_parameters"](byref(arg_ppVADCControlCollection.COM_val)))
            return arg_ppVADCControlCollection.python_val

    @property
    def results(self) -> "IDifferentialCorrectorResultCollection":
        """The list of results defined for the profile."""
        with agmarshall.AgInterface_out_arg() as arg_ppVADCResultCollection:
            agcls.evaluate_hresult(self.__dict__["_get_results"](byref(arg_ppVADCResultCollection.COM_val)))
            return arg_ppVADCResultCollection.python_val

    @property
    def max_iterations(self) -> int:
        """The number of complete iterations of the profile to try before stopping. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_iterations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_iterations.setter
    def max_iterations(self, newVal:int) -> None:
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_iterations"](arg_newVal.COM_val))

    @property
    def enable_display_status(self) -> bool:
        """If true, a page will appear during the targeting run to report the status of the targeting effort in terms of proximity to the desired value for each dependent variable in the profile."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable_display_status"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable_display_status.setter
    def enable_display_status(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable_display_status"](arg_newVal.COM_val))

    @property
    def convergence_criteria(self) -> "AgEVAConvergenceCriteria":
        """The convergence criteria."""
        with agmarshall.AgEnum_arg(AgEVAConvergenceCriteria) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_convergence_criteria"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @convergence_criteria.setter
    def convergence_criteria(self, newVal:"AgEVAConvergenceCriteria") -> None:
        with agmarshall.AgEnum_arg(AgEVAConvergenceCriteria, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_convergence_criteria"](arg_newVal.COM_val))

    @property
    def enable_line_search(self) -> bool:
        """If true, the profile will perform a line search."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable_line_search"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable_line_search.setter
    def enable_line_search(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable_line_search"](arg_newVal.COM_val))

    @property
    def max_line_search_iterations(self) -> int:
        """The number of line search iterations to try before stopping. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_line_search_iterations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_line_search_iterations.setter
    def max_line_search_iterations(self, newVal:int) -> None:
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_line_search_iterations"](arg_newVal.COM_val))

    @property
    def line_search_lower_bound(self) -> float:
        """The low boundary for the line search. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_line_search_lower_bound"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @line_search_lower_bound.setter
    def line_search_lower_bound(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_line_search_lower_bound"](arg_newVal.COM_val))

    @property
    def line_search_upper_bound(self) -> float:
        """The high boundary for the line search. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_line_search_upper_bound"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @line_search_upper_bound.setter
    def line_search_upper_bound(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_line_search_upper_bound"](arg_newVal.COM_val))

    @property
    def line_search_tolerance(self) -> float:
        """The tolerance for the line search. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_line_search_tolerance"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @line_search_tolerance.setter
    def line_search_tolerance(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_line_search_tolerance"](arg_newVal.COM_val))

    @property
    def enable_homotopy(self) -> bool:
        """If true, the profile will divide the problem into steps to solve it."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable_homotopy"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable_homotopy.setter
    def enable_homotopy(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable_homotopy"](arg_newVal.COM_val))

    @property
    def homotopy_steps(self) -> int:
        """The number of steps to divide a problem into for a homotopic calculation. Dimensionless - ."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_homotopy_steps"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @homotopy_steps.setter
    def homotopy_steps(self, newVal:int) -> None:
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_homotopy_steps"](arg_newVal.COM_val))

    @property
    def derivative_calc_method(self) -> "AgEVADeriveCalcMethod":
        """The derivative calculation method."""
        with agmarshall.AgEnum_arg(AgEVADeriveCalcMethod) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_derivative_calc_method"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @derivative_calc_method.setter
    def derivative_calc_method(self, newVal:"AgEVADeriveCalcMethod") -> None:
        with agmarshall.AgEnum_arg(AgEVADeriveCalcMethod, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_derivative_calc_method"](arg_newVal.COM_val))

    @property
    def clear_corrections_before_run(self) -> bool:
        """Clear Corrections Before Each Run - if true, the differential corrector is automatically reset each time that it is run, discarding information that was computed the last time it was run."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_clear_corrections_before_run"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @clear_corrections_before_run.setter
    def clear_corrections_before_run(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_clear_corrections_before_run"](arg_newVal.COM_val))

    @property
    def enable_b_plane_nominal(self) -> bool:
        """If true, Astrogator will update the display of B-Planes for the nominal run of each iteration during the targeting process."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable_b_plane_nominal"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable_b_plane_nominal.setter
    def enable_b_plane_nominal(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable_b_plane_nominal"](arg_newVal.COM_val))

    @property
    def enable_b_plane_perturbations(self) -> bool:
        """If true, Astrogator will update the display of B-Planes for both of the perturbations of each iteration during the targeting process."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable_b_plane_perturbations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable_b_plane_perturbations.setter
    def enable_b_plane_perturbations(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable_b_plane_perturbations"](arg_newVal.COM_val))

    @property
    def draw_perturbation(self) -> "AgEVADrawPerturbation":
        """Defines the display of perturbations in the 2D and 3D Graphics windows, if you have set Astrogator to draw while calculating."""
        with agmarshall.AgEnum_arg(AgEVADrawPerturbation) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_draw_perturbation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @draw_perturbation.setter
    def draw_perturbation(self, newVal:"AgEVADrawPerturbation") -> None:
        with agmarshall.AgEnum_arg(AgEVADrawPerturbation, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_draw_perturbation"](arg_newVal.COM_val))

    @property
    def scripting_tool(self) -> "IScriptingTool":
        """Returns the Scripting tool for the sequence."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_scripting_tool"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def root_finding_algorithm(self) -> "AgEVARootFindingAlgorithm":
        """The root-finding algorithm to use."""
        with agmarshall.AgEnum_arg(AgEVARootFindingAlgorithm) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_root_finding_algorithm"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @root_finding_algorithm.setter
    def root_finding_algorithm(self, pVal:"AgEVARootFindingAlgorithm") -> None:
        with agmarshall.AgEnum_arg(AgEVARootFindingAlgorithm, pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_root_finding_algorithm"](arg_pVal.COM_val))

    @property
    def num_iterations(self) -> int:
        """The number of iterations of the last run"""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_num_iterations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def targeter_graphs(self) -> "ITargeterGraphCollection":
        """Graphs"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_targeter_graphs"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def stop_on_limit_cycle_detection(self) -> bool:
        """If true, Astrogator will stop targeting if a limit cycle is detected."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_stop_on_limit_cycle_detection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @stop_on_limit_cycle_detection.setter
    def stop_on_limit_cycle_detection(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_stop_on_limit_cycle_detection"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E131F674-A7BA-408C-9109-BF50D16BE4F0}", IProfileDifferentialCorrector)
agcls.AgTypeNameMap["IProfileDifferentialCorrector"] = IProfileDifferentialCorrector

class IProfileChangeManeuverType(IProfile):
    """Properties for a Change Maneuver Type profile."""
    _uuid = "{17F50A61-1E84-4060-A86A-93434A5522D5}"
    _num_methods = 4
    _vtable_offset = IProfile._vtable_offset + IProfile._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_segment"] = _raise_uninitialized_error
        self.__dict__["_set_segment"] = _raise_uninitialized_error
        self.__dict__["_get_maneuver_type"] = _raise_uninitialized_error
        self.__dict__["_set_maneuver_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProfileChangeManeuverType._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProfileChangeManeuverType from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProfile._private_init(self, pUnk)
        IID_IProfileChangeManeuverType = agcom.GUID(IProfileChangeManeuverType._uuid)
        vtable_offset_local = IProfileChangeManeuverType._vtable_offset - 1
        self.__dict__["_get_segment"] = IAGFUNCTYPE(pUnk, IID_IProfileChangeManeuverType, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_set_segment"] = IAGFUNCTYPE(pUnk, IID_IProfileChangeManeuverType, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_get_maneuver_type"] = IAGFUNCTYPE(pUnk, IID_IProfileChangeManeuverType, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_maneuver_type"] = IAGFUNCTYPE(pUnk, IID_IProfileChangeManeuverType, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProfileChangeManeuverType.__dict__ and type(IProfileChangeManeuverType.__dict__[attrname]) == property:
            return IProfileChangeManeuverType.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IProfile.__setattr__(self, attrname, value)
    
    @property
    def segment(self) -> "IMissionControlSequenceManeuver":
        """The targeted maneuver segment."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAMCSManeuver:
            agcls.evaluate_hresult(self.__dict__["_get_segment"](byref(arg_ppVAMCSManeuver.COM_val)))
            return arg_ppVAMCSManeuver.python_val

    @segment.setter
    def segment(self, pSegment:"IMissionControlSequenceManeuver") -> None:
        with agmarshall.AgInterface_in_arg(pSegment, IMissionControlSequenceManeuver) as arg_pSegment:
            agcls.evaluate_hresult(self.__dict__["_set_segment"](arg_pSegment.COM_val))

    @property
    def maneuver_type(self) -> "AgEVAManeuverType":
        """The new maneuver type for the targeted segment."""
        with agmarshall.AgEnum_arg(AgEVAManeuverType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_maneuver_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @maneuver_type.setter
    def maneuver_type(self, newVal:"AgEVAManeuverType") -> None:
        with agmarshall.AgEnum_arg(AgEVAManeuverType, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_maneuver_type"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{17F50A61-1E84-4060-A86A-93434A5522D5}", IProfileChangeManeuverType)
agcls.AgTypeNameMap["IProfileChangeManeuverType"] = IProfileChangeManeuverType

class IProfileScriptingTool(IProfile):
    """Properties for a Scripting Tool profile."""
    _uuid = "{8D1192C7-8230-4475-BAFF-A135F9EE0ABD}"
    _num_methods = 10
    _vtable_offset = IProfile._vtable_offset + IProfile._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_enable"] = _raise_uninitialized_error
        self.__dict__["_set_enable"] = _raise_uninitialized_error
        self.__dict__["_get_segment_properties"] = _raise_uninitialized_error
        self.__dict__["_get_calc_objects"] = _raise_uninitialized_error
        self.__dict__["_get_parameters"] = _raise_uninitialized_error
        self.__dict__["_get_language_type"] = _raise_uninitialized_error
        self.__dict__["_set_language_type"] = _raise_uninitialized_error
        self.__dict__["_script_text"] = _raise_uninitialized_error
        self.__dict__["_copy_to_clipboard"] = _raise_uninitialized_error
        self.__dict__["_paste_from_clipboard"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProfileScriptingTool._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProfileScriptingTool from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProfile._private_init(self, pUnk)
        IID_IProfileScriptingTool = agcom.GUID(IProfileScriptingTool._uuid)
        vtable_offset_local = IProfileScriptingTool._vtable_offset - 1
        self.__dict__["_get_enable"] = IAGFUNCTYPE(pUnk, IID_IProfileScriptingTool, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable"] = IAGFUNCTYPE(pUnk, IID_IProfileScriptingTool, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_segment_properties"] = IAGFUNCTYPE(pUnk, IID_IProfileScriptingTool, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_calc_objects"] = IAGFUNCTYPE(pUnk, IID_IProfileScriptingTool, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_parameters"] = IAGFUNCTYPE(pUnk, IID_IProfileScriptingTool, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_language_type"] = IAGFUNCTYPE(pUnk, IID_IProfileScriptingTool, vtable_offset_local+6, POINTER(agcom.LONG))
        self.__dict__["_set_language_type"] = IAGFUNCTYPE(pUnk, IID_IProfileScriptingTool, vtable_offset_local+7, agcom.LONG)
        self.__dict__["_script_text"] = IAGFUNCTYPE(pUnk, IID_IProfileScriptingTool, vtable_offset_local+8, agcom.BSTR)
        self.__dict__["_copy_to_clipboard"] = IAGFUNCTYPE(pUnk, IID_IProfileScriptingTool, vtable_offset_local+9, )
        self.__dict__["_paste_from_clipboard"] = IAGFUNCTYPE(pUnk, IID_IProfileScriptingTool, vtable_offset_local+10, )
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProfileScriptingTool.__dict__ and type(IProfileScriptingTool.__dict__[attrname]) == property:
            return IProfileScriptingTool.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IProfile.__setattr__(self, attrname, value)
    
    @property
    def enable(self) -> bool:
        """If true, the scripting tool will be used."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable.setter
    def enable(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable"](arg_inVal.COM_val))

    @property
    def segment_properties(self) -> "IScriptingSegmentCollection":
        """Returns the collection of the segment properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_segment_properties"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def calc_objects(self) -> "IScriptingCalcObjectCollection":
        """Returns the collection of the calc objects."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_calc_objects"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def parameters(self) -> "IScriptingParameterCollection":
        """Returns the collection of parameters."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_parameters"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def language_type(self) -> "AgEVALanguage":
        """The scripting language being used."""
        with agmarshall.AgEnum_arg(AgEVALanguage) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_language_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @language_type.setter
    def language_type(self, inVal:"AgEVALanguage") -> None:
        with agmarshall.AgEnum_arg(AgEVALanguage, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_language_type"](arg_inVal.COM_val))

    def script_text(self, script:str) -> None:
        """Injects the script into the scripting tool."""
        with agmarshall.BSTR_arg(script) as arg_script:
            agcls.evaluate_hresult(self.__dict__["_script_text"](arg_script.COM_val))

    def copy_to_clipboard(self) -> None:
        """Copies entire scripting tool to clipboard."""
        agcls.evaluate_hresult(self.__dict__["_copy_to_clipboard"]())

    def paste_from_clipboard(self) -> None:
        """Replaces entire scripting tool with scripting tool in clipboard."""
        agcls.evaluate_hresult(self.__dict__["_paste_from_clipboard"]())


agcls.AgClassCatalog.add_catalog_entry("{8D1192C7-8230-4475-BAFF-A135F9EE0ABD}", IProfileScriptingTool)
agcls.AgTypeNameMap["IProfileScriptingTool"] = IProfileScriptingTool

class IProfileChangeReturnSegment(IProfile):
    """Properties for a Change Return Segment profile."""
    _uuid = "{B65E05D2-1B1C-414C-A57E-A93333A5D57C}"
    _num_methods = 5
    _vtable_offset = IProfile._vtable_offset + IProfile._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_segment_name"] = _raise_uninitialized_error
        self.__dict__["_set_segment_name"] = _raise_uninitialized_error
        self.__dict__["_set_segment"] = _raise_uninitialized_error
        self.__dict__["_get_state"] = _raise_uninitialized_error
        self.__dict__["_set_state"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProfileChangeReturnSegment._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProfileChangeReturnSegment from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProfile._private_init(self, pUnk)
        IID_IProfileChangeReturnSegment = agcom.GUID(IProfileChangeReturnSegment._uuid)
        vtable_offset_local = IProfileChangeReturnSegment._vtable_offset - 1
        self.__dict__["_get_segment_name"] = IAGFUNCTYPE(pUnk, IID_IProfileChangeReturnSegment, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_segment_name"] = IAGFUNCTYPE(pUnk, IID_IProfileChangeReturnSegment, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_set_segment"] = IAGFUNCTYPE(pUnk, IID_IProfileChangeReturnSegment, vtable_offset_local+3, agcom.PVOID)
        self.__dict__["_get_state"] = IAGFUNCTYPE(pUnk, IID_IProfileChangeReturnSegment, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_set_state"] = IAGFUNCTYPE(pUnk, IID_IProfileChangeReturnSegment, vtable_offset_local+5, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProfileChangeReturnSegment.__dict__ and type(IProfileChangeReturnSegment.__dict__[attrname]) == property:
            return IProfileChangeReturnSegment.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IProfile.__setattr__(self, attrname, value)
    
    @property
    def segment_name(self) -> str:
        """The targeted return segment."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_segment_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @segment_name.setter
    def segment_name(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_segment_name"](arg_newVal.COM_val))

    def set_segment(self, pVAMCSReturn:"IMissionControlSequenceReturn") -> None:
        """Sets the return segment to target."""
        with agmarshall.AgInterface_in_arg(pVAMCSReturn, IMissionControlSequenceReturn) as arg_pVAMCSReturn:
            agcls.evaluate_hresult(self.__dict__["_set_segment"](arg_pVAMCSReturn.COM_val))

    @property
    def state(self) -> "AgEVAReturnControl":
        """The new state for the targeted return segment."""
        with agmarshall.AgEnum_arg(AgEVAReturnControl) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_state"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @state.setter
    def state(self, newVal:"AgEVAReturnControl") -> None:
        with agmarshall.AgEnum_arg(AgEVAReturnControl, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_state"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{B65E05D2-1B1C-414C-A57E-A93333A5D57C}", IProfileChangeReturnSegment)
agcls.AgTypeNameMap["IProfileChangeReturnSegment"] = IProfileChangeReturnSegment

class IProfileChangePropagator(IProfile):
    """Properties for a Change Propagator profile."""
    _uuid = "{FB6704EC-C787-4051-BE39-1584C5CAD0F6}"
    _num_methods = 5
    _vtable_offset = IProfile._vtable_offset + IProfile._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_segment_name"] = _raise_uninitialized_error
        self.__dict__["_set_segment_name"] = _raise_uninitialized_error
        self.__dict__["_set_segment"] = _raise_uninitialized_error
        self.__dict__["_get_propagator_name"] = _raise_uninitialized_error
        self.__dict__["_set_propagator_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProfileChangePropagator._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProfileChangePropagator from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProfile._private_init(self, pUnk)
        IID_IProfileChangePropagator = agcom.GUID(IProfileChangePropagator._uuid)
        vtable_offset_local = IProfileChangePropagator._vtable_offset - 1
        self.__dict__["_get_segment_name"] = IAGFUNCTYPE(pUnk, IID_IProfileChangePropagator, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_segment_name"] = IAGFUNCTYPE(pUnk, IID_IProfileChangePropagator, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_set_segment"] = IAGFUNCTYPE(pUnk, IID_IProfileChangePropagator, vtable_offset_local+3, agcom.PVOID)
        self.__dict__["_get_propagator_name"] = IAGFUNCTYPE(pUnk, IID_IProfileChangePropagator, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_set_propagator_name"] = IAGFUNCTYPE(pUnk, IID_IProfileChangePropagator, vtable_offset_local+5, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProfileChangePropagator.__dict__ and type(IProfileChangePropagator.__dict__[attrname]) == property:
            return IProfileChangePropagator.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IProfile.__setattr__(self, attrname, value)
    
    @property
    def segment_name(self) -> str:
        """The name of the profile."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_segment_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @segment_name.setter
    def segment_name(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_segment_name"](arg_newVal.COM_val))

    def set_segment(self, pVAMCSSegment:"IMissionControlSequenceSegment") -> None:
        """The targeted segment."""
        with agmarshall.AgInterface_in_arg(pVAMCSSegment, IMissionControlSequenceSegment) as arg_pVAMCSSegment:
            agcls.evaluate_hresult(self.__dict__["_set_segment"](arg_pVAMCSSegment.COM_val))

    @property
    def propagator_name(self) -> str:
        """The new propagator's name."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_propagator_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @propagator_name.setter
    def propagator_name(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_propagator_name"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{FB6704EC-C787-4051-BE39-1584C5CAD0F6}", IProfileChangePropagator)
agcls.AgTypeNameMap["IProfileChangePropagator"] = IProfileChangePropagator

class IProfileChangeStopSegment(IProfile):
    """Properties for a Change Stop Segment profile."""
    _uuid = "{1B9A0E28-8C19-448D-9CD1-AB10B492C767}"
    _num_methods = 5
    _vtable_offset = IProfile._vtable_offset + IProfile._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_segment_name"] = _raise_uninitialized_error
        self.__dict__["_set_segment_name"] = _raise_uninitialized_error
        self.__dict__["_set_segment"] = _raise_uninitialized_error
        self.__dict__["_get_state"] = _raise_uninitialized_error
        self.__dict__["_set_state"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProfileChangeStopSegment._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProfileChangeStopSegment from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProfile._private_init(self, pUnk)
        IID_IProfileChangeStopSegment = agcom.GUID(IProfileChangeStopSegment._uuid)
        vtable_offset_local = IProfileChangeStopSegment._vtable_offset - 1
        self.__dict__["_get_segment_name"] = IAGFUNCTYPE(pUnk, IID_IProfileChangeStopSegment, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_segment_name"] = IAGFUNCTYPE(pUnk, IID_IProfileChangeStopSegment, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_set_segment"] = IAGFUNCTYPE(pUnk, IID_IProfileChangeStopSegment, vtable_offset_local+3, agcom.PVOID)
        self.__dict__["_get_state"] = IAGFUNCTYPE(pUnk, IID_IProfileChangeStopSegment, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_set_state"] = IAGFUNCTYPE(pUnk, IID_IProfileChangeStopSegment, vtable_offset_local+5, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProfileChangeStopSegment.__dict__ and type(IProfileChangeStopSegment.__dict__[attrname]) == property:
            return IProfileChangeStopSegment.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IProfile.__setattr__(self, attrname, value)
    
    @property
    def segment_name(self) -> str:
        """The targeted stop segment."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_segment_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @segment_name.setter
    def segment_name(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_segment_name"](arg_newVal.COM_val))

    def set_segment(self, pVAMCSStop:"IMissionControlSequenceStop") -> None:
        """Sets the stop segment to target."""
        with agmarshall.AgInterface_in_arg(pVAMCSStop, IMissionControlSequenceStop) as arg_pVAMCSStop:
            agcls.evaluate_hresult(self.__dict__["_set_segment"](arg_pVAMCSStop.COM_val))

    @property
    def state(self) -> "AgEVAState":
        """The new state of the targeted stop segment."""
        with agmarshall.AgEnum_arg(AgEVAState) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_state"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @state.setter
    def state(self, newVal:"AgEVAState") -> None:
        with agmarshall.AgEnum_arg(AgEVAState, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_state"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{1B9A0E28-8C19-448D-9CD1-AB10B492C767}", IProfileChangeStopSegment)
agcls.AgTypeNameMap["IProfileChangeStopSegment"] = IProfileChangeStopSegment

class IProfileChangeStoppingConditionState(IProfile):
    """Properties for a Change Stopping Condition State profile."""
    _uuid = "{977C9F84-852A-4B5D-861B-8F9E3809CE7D}"
    _num_methods = 8
    _vtable_offset = IProfile._vtable_offset + IProfile._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_segment_name"] = _raise_uninitialized_error
        self.__dict__["_set_segment_name"] = _raise_uninitialized_error
        self.__dict__["_set_segment"] = _raise_uninitialized_error
        self.__dict__["_get_state"] = _raise_uninitialized_error
        self.__dict__["_set_state"] = _raise_uninitialized_error
        self.__dict__["_set_trigger"] = _raise_uninitialized_error
        self.__dict__["_get_trigger_name"] = _raise_uninitialized_error
        self.__dict__["_set_trigger_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProfileChangeStoppingConditionState._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProfileChangeStoppingConditionState from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProfile._private_init(self, pUnk)
        IID_IProfileChangeStoppingConditionState = agcom.GUID(IProfileChangeStoppingConditionState._uuid)
        vtable_offset_local = IProfileChangeStoppingConditionState._vtable_offset - 1
        self.__dict__["_get_segment_name"] = IAGFUNCTYPE(pUnk, IID_IProfileChangeStoppingConditionState, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_segment_name"] = IAGFUNCTYPE(pUnk, IID_IProfileChangeStoppingConditionState, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_set_segment"] = IAGFUNCTYPE(pUnk, IID_IProfileChangeStoppingConditionState, vtable_offset_local+3, agcom.PVOID)
        self.__dict__["_get_state"] = IAGFUNCTYPE(pUnk, IID_IProfileChangeStoppingConditionState, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_set_state"] = IAGFUNCTYPE(pUnk, IID_IProfileChangeStoppingConditionState, vtable_offset_local+5, agcom.LONG)
        self.__dict__["_set_trigger"] = IAGFUNCTYPE(pUnk, IID_IProfileChangeStoppingConditionState, vtable_offset_local+6, agcom.PVOID)
        self.__dict__["_get_trigger_name"] = IAGFUNCTYPE(pUnk, IID_IProfileChangeStoppingConditionState, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_set_trigger_name"] = IAGFUNCTYPE(pUnk, IID_IProfileChangeStoppingConditionState, vtable_offset_local+8, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProfileChangeStoppingConditionState.__dict__ and type(IProfileChangeStoppingConditionState.__dict__[attrname]) == property:
            return IProfileChangeStoppingConditionState.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IProfile.__setattr__(self, attrname, value)
    
    @property
    def segment_name(self) -> str:
        """The segment that contains the targeted stopping condition."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_segment_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @segment_name.setter
    def segment_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_segment_name"](arg_inVal.COM_val))

    def set_segment(self, mCSSegment:"IMissionControlSequenceSegment") -> None:
        """Sets the targeted segment."""
        with agmarshall.AgInterface_in_arg(mCSSegment, IMissionControlSequenceSegment) as arg_mCSSegment:
            agcls.evaluate_hresult(self.__dict__["_set_segment"](arg_mCSSegment.COM_val))

    @property
    def state(self) -> "AgEVAState":
        """The new state of the targeted stopping condition."""
        with agmarshall.AgEnum_arg(AgEVAState) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_state"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @state.setter
    def state(self, newVal:"AgEVAState") -> None:
        with agmarshall.AgEnum_arg(AgEVAState, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_state"](arg_newVal.COM_val))

    def set_trigger(self, stoppingCondition:"IStoppingCondition") -> None:
        """The targeted stopping condition."""
        with agmarshall.AgInterface_in_arg(stoppingCondition, IStoppingCondition) as arg_stoppingCondition:
            agcls.evaluate_hresult(self.__dict__["_set_trigger"](arg_stoppingCondition.COM_val))

    @property
    def trigger_name(self) -> str:
        """The name of the targeted stopping condition."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_trigger_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @trigger_name.setter
    def trigger_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_trigger_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{977C9F84-852A-4B5D-861B-8F9E3809CE7D}", IProfileChangeStoppingConditionState)
agcls.AgTypeNameMap["IProfileChangeStoppingConditionState"] = IProfileChangeStoppingConditionState

class IProfileSeedFiniteManeuver(IProfile):
    """Properties for a Seed Finite Maneuver segment."""
    _uuid = "{C56665D5-CEF3-47A1-854E-64CB0A8CA9CA}"
    _num_methods = 5
    _vtable_offset = IProfile._vtable_offset + IProfile._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_segment_name"] = _raise_uninitialized_error
        self.__dict__["_set_segment_name"] = _raise_uninitialized_error
        self.__dict__["_set_segment"] = _raise_uninitialized_error
        self.__dict__["_get_leave_all_active_stopping_conditions_active"] = _raise_uninitialized_error
        self.__dict__["_set_leave_all_active_stopping_conditions_active"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProfileSeedFiniteManeuver._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProfileSeedFiniteManeuver from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProfile._private_init(self, pUnk)
        IID_IProfileSeedFiniteManeuver = agcom.GUID(IProfileSeedFiniteManeuver._uuid)
        vtable_offset_local = IProfileSeedFiniteManeuver._vtable_offset - 1
        self.__dict__["_get_segment_name"] = IAGFUNCTYPE(pUnk, IID_IProfileSeedFiniteManeuver, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_segment_name"] = IAGFUNCTYPE(pUnk, IID_IProfileSeedFiniteManeuver, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_set_segment"] = IAGFUNCTYPE(pUnk, IID_IProfileSeedFiniteManeuver, vtable_offset_local+3, agcom.PVOID)
        self.__dict__["_get_leave_all_active_stopping_conditions_active"] = IAGFUNCTYPE(pUnk, IID_IProfileSeedFiniteManeuver, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_leave_all_active_stopping_conditions_active"] = IAGFUNCTYPE(pUnk, IID_IProfileSeedFiniteManeuver, vtable_offset_local+5, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProfileSeedFiniteManeuver.__dict__ and type(IProfileSeedFiniteManeuver.__dict__[attrname]) == property:
            return IProfileSeedFiniteManeuver.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IProfile.__setattr__(self, attrname, value)
    
    @property
    def segment_name(self) -> str:
        """The targeted maneuver segment."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_segment_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @segment_name.setter
    def segment_name(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_segment_name"](arg_newVal.COM_val))

    def set_segment(self, pVAMCSManeuver:"IMissionControlSequenceManeuver") -> None:
        """Sets the maneuver segment to target."""
        with agmarshall.AgInterface_in_arg(pVAMCSManeuver, IMissionControlSequenceManeuver) as arg_pVAMCSManeuver:
            agcls.evaluate_hresult(self.__dict__["_set_segment"](arg_pVAMCSManeuver.COM_val))

    @property
    def leave_all_active_stopping_conditions_active(self) -> bool:
        """If true, all active stopping conditions on the seeded maneuver will remain active during run."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_leave_all_active_stopping_conditions_active"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @leave_all_active_stopping_conditions_active.setter
    def leave_all_active_stopping_conditions_active(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_leave_all_active_stopping_conditions_active"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{C56665D5-CEF3-47A1-854E-64CB0A8CA9CA}", IProfileSeedFiniteManeuver)
agcls.AgTypeNameMap["IProfileSeedFiniteManeuver"] = IProfileSeedFiniteManeuver

class IProfileRunOnce(IProfile):
    """Properties for a Run Once profile."""
    _uuid = "{75574EA3-277E-4A6D-9529-3342088679DB}"
    _num_methods = 0
    _vtable_offset = IProfile._vtable_offset + IProfile._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProfileRunOnce._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProfileRunOnce from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProfile._private_init(self, pUnk)
        IID_IProfileRunOnce = agcom.GUID(IProfileRunOnce._uuid)
        vtable_offset_local = IProfileRunOnce._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProfileRunOnce.__dict__ and type(IProfileRunOnce.__dict__[attrname]) == property:
            return IProfileRunOnce.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IProfile.__setattr__(self, attrname, value)
    

agcls.AgClassCatalog.add_catalog_entry("{75574EA3-277E-4A6D-9529-3342088679DB}", IProfileRunOnce)
agcls.AgTypeNameMap["IProfileRunOnce"] = IProfileRunOnce

class IUserVariableDefinition(object):
    """Properties for a User Variable definition."""
    _uuid = "{25F2A622-8F6A-4CBB-91C6-ED5AD9C24028}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_unit_dimension"] = _raise_uninitialized_error
        self.__dict__["_set_unit_dimension"] = _raise_uninitialized_error
        self.__dict__["_get_variable_name"] = _raise_uninitialized_error
        self.__dict__["_set_variable_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IUserVariableDefinition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IUserVariableDefinition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IUserVariableDefinition = agcom.GUID(IUserVariableDefinition._uuid)
        vtable_offset_local = IUserVariableDefinition._vtable_offset - 1
        self.__dict__["_get_unit_dimension"] = IAGFUNCTYPE(pUnk, IID_IUserVariableDefinition, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_unit_dimension"] = IAGFUNCTYPE(pUnk, IID_IUserVariableDefinition, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_variable_name"] = IAGFUNCTYPE(pUnk, IID_IUserVariableDefinition, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_variable_name"] = IAGFUNCTYPE(pUnk, IID_IUserVariableDefinition, vtable_offset_local+4, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IUserVariableDefinition.__dict__ and type(IUserVariableDefinition.__dict__[attrname]) == property:
            return IUserVariableDefinition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IUserVariableDefinition.")
    
    @property
    def unit_dimension(self) -> str:
        """The dimension of the user variable."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_unit_dimension"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @unit_dimension.setter
    def unit_dimension(self, inVal:str) -> None:
        """The dimension of the user variable."""
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_unit_dimension"](arg_inVal.COM_val))

    @property
    def variable_name(self) -> str:
        """The name of the user variable."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_variable_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @variable_name.setter
    def variable_name(self, inVal:str) -> None:
        """The name of the user variable."""
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_variable_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{25F2A622-8F6A-4CBB-91C6-ED5AD9C24028}", IUserVariableDefinition)
agcls.AgTypeNameMap["IUserVariableDefinition"] = IUserVariableDefinition

class IUserVariable(object):
    """The properties for a User Variable initial value."""
    _uuid = "{31B617D6-AE6D-46CE-845D-90FFCD7A5B13}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_unit_dimension"] = _raise_uninitialized_error
        self.__dict__["_get_variable_name"] = _raise_uninitialized_error
        self.__dict__["_get_variable_value"] = _raise_uninitialized_error
        self.__dict__["_set_variable_value"] = _raise_uninitialized_error
        self.__dict__["_enable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_disable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_is_control_parameter_enabled"] = _raise_uninitialized_error
        self.__dict__["_get_control_parameters_available"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IUserVariable._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IUserVariable from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IUserVariable = agcom.GUID(IUserVariable._uuid)
        vtable_offset_local = IUserVariable._vtable_offset - 1
        self.__dict__["_get_unit_dimension"] = IAGFUNCTYPE(pUnk, IID_IUserVariable, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_get_variable_name"] = IAGFUNCTYPE(pUnk, IID_IUserVariable, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_get_variable_value"] = IAGFUNCTYPE(pUnk, IID_IUserVariable, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_set_variable_value"] = IAGFUNCTYPE(pUnk, IID_IUserVariable, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_enable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IUserVariable, vtable_offset_local+5, )
        self.__dict__["_disable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IUserVariable, vtable_offset_local+6, )
        self.__dict__["_is_control_parameter_enabled"] = IAGFUNCTYPE(pUnk, IID_IUserVariable, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_control_parameters_available"] = IAGFUNCTYPE(pUnk, IID_IUserVariable, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IUserVariable.__dict__ and type(IUserVariable.__dict__[attrname]) == property:
            return IUserVariable.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IUserVariable.")
    
    @property
    def unit_dimension(self) -> str:
        """The dimension of the user variable."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_unit_dimension"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def variable_name(self) -> str:
        """The name of the user variable."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_variable_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def variable_value(self) -> typing.Any:
        """The initial value of the user variable."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_variable_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @variable_value.setter
    def variable_value(self, inVal:typing.Any) -> None:
        """The initial value of the user variable."""
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_variable_value"](arg_inVal.COM_val))

    def enable_control_parameter(self) -> None:
        """Enables or disables the specified control parameter."""
        agcls.evaluate_hresult(self.__dict__["_enable_control_parameter"]())

    def disable_control_parameter(self) -> None:
        """Disables the specified control parameter."""
        agcls.evaluate_hresult(self.__dict__["_disable_control_parameter"]())

    def is_control_parameter_enabled(self) -> bool:
        """Sees if the specified control is enabled."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_is_control_parameter_enabled"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_parameters_available(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_parameters_available"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{31B617D6-AE6D-46CE-845D-90FFCD7A5B13}", IUserVariable)
agcls.AgTypeNameMap["IUserVariable"] = IUserVariable

class IUserVariableUpdate(object):
    """Properties for a User Variable update."""
    _uuid = "{14F87E74-D85B-40D1-86FF-97E7F514FCF7}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_unit_dimension"] = _raise_uninitialized_error
        self.__dict__["_get_variable_name"] = _raise_uninitialized_error
        self.__dict__["_get_variable_value"] = _raise_uninitialized_error
        self.__dict__["_set_variable_value"] = _raise_uninitialized_error
        self.__dict__["_get_variable_action"] = _raise_uninitialized_error
        self.__dict__["_set_variable_action"] = _raise_uninitialized_error
        self.__dict__["_enable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_disable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_is_control_parameter_enabled"] = _raise_uninitialized_error
        self.__dict__["_get_control_parameters_available"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IUserVariableUpdate._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IUserVariableUpdate from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IUserVariableUpdate = agcom.GUID(IUserVariableUpdate._uuid)
        vtable_offset_local = IUserVariableUpdate._vtable_offset - 1
        self.__dict__["_get_unit_dimension"] = IAGFUNCTYPE(pUnk, IID_IUserVariableUpdate, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_get_variable_name"] = IAGFUNCTYPE(pUnk, IID_IUserVariableUpdate, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_get_variable_value"] = IAGFUNCTYPE(pUnk, IID_IUserVariableUpdate, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_set_variable_value"] = IAGFUNCTYPE(pUnk, IID_IUserVariableUpdate, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_get_variable_action"] = IAGFUNCTYPE(pUnk, IID_IUserVariableUpdate, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_variable_action"] = IAGFUNCTYPE(pUnk, IID_IUserVariableUpdate, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_enable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IUserVariableUpdate, vtable_offset_local+7, )
        self.__dict__["_disable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IUserVariableUpdate, vtable_offset_local+8, )
        self.__dict__["_is_control_parameter_enabled"] = IAGFUNCTYPE(pUnk, IID_IUserVariableUpdate, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_control_parameters_available"] = IAGFUNCTYPE(pUnk, IID_IUserVariableUpdate, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IUserVariableUpdate.__dict__ and type(IUserVariableUpdate.__dict__[attrname]) == property:
            return IUserVariableUpdate.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IUserVariableUpdate.")
    
    @property
    def unit_dimension(self) -> str:
        """The dimension of the user variable."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_unit_dimension"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def variable_name(self) -> str:
        """The name of the user variable."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_variable_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def variable_value(self) -> typing.Any:
        """Update value of the user variable."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_variable_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @variable_value.setter
    def variable_value(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_variable_value"](arg_inVal.COM_val))

    @property
    def variable_action(self) -> "AgEVAUpdateAction":
        """Action to be performed using the value."""
        with agmarshall.AgEnum_arg(AgEVAUpdateAction) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_variable_action"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @variable_action.setter
    def variable_action(self, inVal:"AgEVAUpdateAction") -> None:
        with agmarshall.AgEnum_arg(AgEVAUpdateAction, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_variable_action"](arg_inVal.COM_val))

    def enable_control_parameter(self) -> None:
        """Enables or disables the specified control parameter."""
        agcls.evaluate_hresult(self.__dict__["_enable_control_parameter"]())

    def disable_control_parameter(self) -> None:
        """Disables the specified control parameter."""
        agcls.evaluate_hresult(self.__dict__["_disable_control_parameter"]())

    def is_control_parameter_enabled(self) -> bool:
        """Sees if the specified control is enabled."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_is_control_parameter_enabled"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_parameters_available(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_parameters_available"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{14F87E74-D85B-40D1-86FF-97E7F514FCF7}", IUserVariableUpdate)
agcls.AgTypeNameMap["IUserVariableUpdate"] = IUserVariableUpdate

class IProfileSNOPTOptimizer(IProfile):
    """Properties of SNOPT Optimizer profile."""
    _uuid = "{6BE54C72-2B85-4925-B969-5602527616A1}"
    _num_methods = 22
    _vtable_offset = IProfile._vtable_offset + IProfile._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_control_parameters"] = _raise_uninitialized_error
        self.__dict__["_get_results"] = _raise_uninitialized_error
        self.__dict__["_get_targeter_graphs"] = _raise_uninitialized_error
        self.__dict__["_get_scripting_tool"] = _raise_uninitialized_error
        self.__dict__["_get_reset_controls_before_run"] = _raise_uninitialized_error
        self.__dict__["_set_reset_controls_before_run"] = _raise_uninitialized_error
        self.__dict__["_get_max_major_iterations"] = _raise_uninitialized_error
        self.__dict__["_set_max_major_iterations"] = _raise_uninitialized_error
        self.__dict__["_get_tolerance_on_major_feasibility"] = _raise_uninitialized_error
        self.__dict__["_set_tolerance_on_major_feasibility"] = _raise_uninitialized_error
        self.__dict__["_get_tolerance_on_major_optimality"] = _raise_uninitialized_error
        self.__dict__["_set_tolerance_on_major_optimality"] = _raise_uninitialized_error
        self.__dict__["_get_max_minor_iterations"] = _raise_uninitialized_error
        self.__dict__["_set_max_minor_iterations"] = _raise_uninitialized_error
        self.__dict__["_get_tolerance_on_minor_feasibility"] = _raise_uninitialized_error
        self.__dict__["_set_tolerance_on_minor_feasibility"] = _raise_uninitialized_error
        self.__dict__["_get_tolerance_on_minor_optimality"] = _raise_uninitialized_error
        self.__dict__["_set_tolerance_on_minor_optimality"] = _raise_uninitialized_error
        self.__dict__["_get_options_filename"] = _raise_uninitialized_error
        self.__dict__["_set_options_filename"] = _raise_uninitialized_error
        self.__dict__["_get_allow_internal_primal_infeasibility_measure_normalization"] = _raise_uninitialized_error
        self.__dict__["_set_allow_internal_primal_infeasibility_measure_normalization"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProfileSNOPTOptimizer._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProfileSNOPTOptimizer from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProfile._private_init(self, pUnk)
        IID_IProfileSNOPTOptimizer = agcom.GUID(IProfileSNOPTOptimizer._uuid)
        vtable_offset_local = IProfileSNOPTOptimizer._vtable_offset - 1
        self.__dict__["_get_control_parameters"] = IAGFUNCTYPE(pUnk, IID_IProfileSNOPTOptimizer, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_results"] = IAGFUNCTYPE(pUnk, IID_IProfileSNOPTOptimizer, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_targeter_graphs"] = IAGFUNCTYPE(pUnk, IID_IProfileSNOPTOptimizer, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_scripting_tool"] = IAGFUNCTYPE(pUnk, IID_IProfileSNOPTOptimizer, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_reset_controls_before_run"] = IAGFUNCTYPE(pUnk, IID_IProfileSNOPTOptimizer, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_reset_controls_before_run"] = IAGFUNCTYPE(pUnk, IID_IProfileSNOPTOptimizer, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_get_max_major_iterations"] = IAGFUNCTYPE(pUnk, IID_IProfileSNOPTOptimizer, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_max_major_iterations"] = IAGFUNCTYPE(pUnk, IID_IProfileSNOPTOptimizer, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_tolerance_on_major_feasibility"] = IAGFUNCTYPE(pUnk, IID_IProfileSNOPTOptimizer, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_tolerance_on_major_feasibility"] = IAGFUNCTYPE(pUnk, IID_IProfileSNOPTOptimizer, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_tolerance_on_major_optimality"] = IAGFUNCTYPE(pUnk, IID_IProfileSNOPTOptimizer, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_tolerance_on_major_optimality"] = IAGFUNCTYPE(pUnk, IID_IProfileSNOPTOptimizer, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_max_minor_iterations"] = IAGFUNCTYPE(pUnk, IID_IProfileSNOPTOptimizer, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_set_max_minor_iterations"] = IAGFUNCTYPE(pUnk, IID_IProfileSNOPTOptimizer, vtable_offset_local+14, agcom.LONG)
        self.__dict__["_get_tolerance_on_minor_feasibility"] = IAGFUNCTYPE(pUnk, IID_IProfileSNOPTOptimizer, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_tolerance_on_minor_feasibility"] = IAGFUNCTYPE(pUnk, IID_IProfileSNOPTOptimizer, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_tolerance_on_minor_optimality"] = IAGFUNCTYPE(pUnk, IID_IProfileSNOPTOptimizer, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_tolerance_on_minor_optimality"] = IAGFUNCTYPE(pUnk, IID_IProfileSNOPTOptimizer, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_options_filename"] = IAGFUNCTYPE(pUnk, IID_IProfileSNOPTOptimizer, vtable_offset_local+19, POINTER(agcom.BSTR))
        self.__dict__["_set_options_filename"] = IAGFUNCTYPE(pUnk, IID_IProfileSNOPTOptimizer, vtable_offset_local+20, agcom.BSTR)
        self.__dict__["_get_allow_internal_primal_infeasibility_measure_normalization"] = IAGFUNCTYPE(pUnk, IID_IProfileSNOPTOptimizer, vtable_offset_local+21, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_allow_internal_primal_infeasibility_measure_normalization"] = IAGFUNCTYPE(pUnk, IID_IProfileSNOPTOptimizer, vtable_offset_local+22, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProfileSNOPTOptimizer.__dict__ and type(IProfileSNOPTOptimizer.__dict__[attrname]) == property:
            return IProfileSNOPTOptimizer.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IProfile.__setattr__(self, attrname, value)
    
    @property
    def control_parameters(self) -> "ISNOPTControlCollection":
        """The list of control parameters defined for the profile."""
        with agmarshall.AgInterface_out_arg() as arg_ppVASNOPTControlCollection:
            agcls.evaluate_hresult(self.__dict__["_get_control_parameters"](byref(arg_ppVASNOPTControlCollection.COM_val)))
            return arg_ppVASNOPTControlCollection.python_val

    @property
    def results(self) -> "ISNOPTResultCollection":
        """The list of results defined for the profile."""
        with agmarshall.AgInterface_out_arg() as arg_ppVASNOPTResultCollection:
            agcls.evaluate_hresult(self.__dict__["_get_results"](byref(arg_ppVASNOPTResultCollection.COM_val)))
            return arg_ppVASNOPTResultCollection.python_val

    @property
    def targeter_graphs(self) -> "ITargeterGraphCollection":
        """Graphs"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_targeter_graphs"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def scripting_tool(self) -> "IScriptingTool":
        """Returns the Scripting tool for the sequence."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_scripting_tool"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def reset_controls_before_run(self) -> bool:
        """Reset controls before each run."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reset_controls_before_run"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reset_controls_before_run.setter
    def reset_controls_before_run(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_reset_controls_before_run"](arg_newVal.COM_val))

    @property
    def max_major_iterations(self) -> int:
        """The maximum number of major iterations allowed."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_major_iterations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_major_iterations.setter
    def max_major_iterations(self, newVal:int) -> None:
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_major_iterations"](arg_newVal.COM_val))

    @property
    def tolerance_on_major_feasibility(self) -> float:
        """Specifies how accurately the nonlinear constraints should be satisfied."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_tolerance_on_major_feasibility"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @tolerance_on_major_feasibility.setter
    def tolerance_on_major_feasibility(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_tolerance_on_major_feasibility"](arg_newVal.COM_val))

    @property
    def tolerance_on_major_optimality(self) -> float:
        """Specifies the final accuracy of the dual variables."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_tolerance_on_major_optimality"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @tolerance_on_major_optimality.setter
    def tolerance_on_major_optimality(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_tolerance_on_major_optimality"](arg_newVal.COM_val))

    @property
    def max_minor_iterations(self) -> int:
        """The maximum number of iterations for the QP subproblem allowed during a single major iteration."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_minor_iterations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_minor_iterations.setter
    def max_minor_iterations(self, newVal:int) -> None:
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_minor_iterations"](arg_newVal.COM_val))

    @property
    def tolerance_on_minor_feasibility(self) -> float:
        """The tolerance which the QP subproblem must meet before being considered feasible."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_tolerance_on_minor_feasibility"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @tolerance_on_minor_feasibility.setter
    def tolerance_on_minor_feasibility(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_tolerance_on_minor_feasibility"](arg_newVal.COM_val))

    @property
    def tolerance_on_minor_optimality(self) -> float:
        """This option is undocumented in the SNOPT literature, and included here for completeness in terms of tolerance options."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_tolerance_on_minor_optimality"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @tolerance_on_minor_optimality.setter
    def tolerance_on_minor_optimality(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_tolerance_on_minor_optimality"](arg_newVal.COM_val))

    @property
    def options_filename(self) -> str:
        """If used, the associated SNOPT specifications file may define any of the various SNOPT options. Options in the file that conflict with options specified elsewhere will take precedence."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_options_filename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @options_filename.setter
    def options_filename(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_options_filename"](arg_newVal.COM_val))

    @property
    def allow_internal_primal_infeasibility_measure_normalization(self) -> bool:
        """Whether to allow internal normalization of the primal infeasibility measure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_allow_internal_primal_infeasibility_measure_normalization"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @allow_internal_primal_infeasibility_measure_normalization.setter
    def allow_internal_primal_infeasibility_measure_normalization(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_allow_internal_primal_infeasibility_measure_normalization"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{6BE54C72-2B85-4925-B969-5602527616A1}", IProfileSNOPTOptimizer)
agcls.AgTypeNameMap["IProfileSNOPTOptimizer"] = IProfileSNOPTOptimizer

class ISNOPTControl(object):
    """Properties for control parameters of a SNOPT profile."""
    _uuid = "{4C637192-8687-4218-9BD6-A7B7C7B6E720}"
    _num_methods = 17
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_enable"] = _raise_uninitialized_error
        self.__dict__["_set_enable"] = _raise_uninitialized_error
        self.__dict__["_get_name"] = _raise_uninitialized_error
        self.__dict__["_get_parent_name"] = _raise_uninitialized_error
        self.__dict__["_get_initial_value"] = _raise_uninitialized_error
        self.__dict__["_get_current_value"] = _raise_uninitialized_error
        self.__dict__["_set_current_value"] = _raise_uninitialized_error
        self.__dict__["_get_lower_bound"] = _raise_uninitialized_error
        self.__dict__["_set_lower_bound"] = _raise_uninitialized_error
        self.__dict__["_get_upper_bound"] = _raise_uninitialized_error
        self.__dict__["_set_upper_bound"] = _raise_uninitialized_error
        self.__dict__["_get_scaling_value"] = _raise_uninitialized_error
        self.__dict__["_set_scaling_value"] = _raise_uninitialized_error
        self.__dict__["_get_use_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_set_use_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_get_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_set_custom_display_unit"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISNOPTControl._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISNOPTControl from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISNOPTControl = agcom.GUID(ISNOPTControl._uuid)
        vtable_offset_local = ISNOPTControl._vtable_offset - 1
        self.__dict__["_get_enable"] = IAGFUNCTYPE(pUnk, IID_ISNOPTControl, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable"] = IAGFUNCTYPE(pUnk, IID_ISNOPTControl, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_name"] = IAGFUNCTYPE(pUnk, IID_ISNOPTControl, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_get_parent_name"] = IAGFUNCTYPE(pUnk, IID_ISNOPTControl, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_get_initial_value"] = IAGFUNCTYPE(pUnk, IID_ISNOPTControl, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_get_current_value"] = IAGFUNCTYPE(pUnk, IID_ISNOPTControl, vtable_offset_local+6, POINTER(agcom.VARIANT))
        self.__dict__["_set_current_value"] = IAGFUNCTYPE(pUnk, IID_ISNOPTControl, vtable_offset_local+7, agcom.VARIANT)
        self.__dict__["_get_lower_bound"] = IAGFUNCTYPE(pUnk, IID_ISNOPTControl, vtable_offset_local+8, POINTER(agcom.VARIANT))
        self.__dict__["_set_lower_bound"] = IAGFUNCTYPE(pUnk, IID_ISNOPTControl, vtable_offset_local+9, agcom.VARIANT)
        self.__dict__["_get_upper_bound"] = IAGFUNCTYPE(pUnk, IID_ISNOPTControl, vtable_offset_local+10, POINTER(agcom.VARIANT))
        self.__dict__["_set_upper_bound"] = IAGFUNCTYPE(pUnk, IID_ISNOPTControl, vtable_offset_local+11, agcom.VARIANT)
        self.__dict__["_get_scaling_value"] = IAGFUNCTYPE(pUnk, IID_ISNOPTControl, vtable_offset_local+12, POINTER(agcom.VARIANT))
        self.__dict__["_set_scaling_value"] = IAGFUNCTYPE(pUnk, IID_ISNOPTControl, vtable_offset_local+13, agcom.VARIANT)
        self.__dict__["_get_use_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_ISNOPTControl, vtable_offset_local+14, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_ISNOPTControl, vtable_offset_local+15, agcom.VARIANT_BOOL)
        self.__dict__["_get_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_ISNOPTControl, vtable_offset_local+16, POINTER(agcom.BSTR))
        self.__dict__["_set_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_ISNOPTControl, vtable_offset_local+17, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISNOPTControl.__dict__ and type(ISNOPTControl.__dict__[attrname]) == property:
            return ISNOPTControl.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISNOPTControl.")
    
    @property
    def enable(self) -> bool:
        """If true, the variable is being used."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable.setter
    def enable(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable"](arg_newVal.COM_val))

    @property
    def name(self) -> str:
        """The name of the parameter."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def parent_name(self) -> str:
        """The name of the segment to which the parameter belongs."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_parent_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def initial_value(self) -> typing.Any:
        """The nominal value of the element selected as a parameter. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_initial_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def current_value(self) -> typing.Any:
        """The value of the independent variable after the last targeter run."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_current_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @current_value.setter
    def current_value(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_current_value"](arg_newVal.COM_val))

    @property
    def lower_bound(self) -> typing.Any:
        """Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_lower_bound"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @lower_bound.setter
    def lower_bound(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_lower_bound"](arg_newVal.COM_val))

    @property
    def upper_bound(self) -> typing.Any:
        """Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_upper_bound"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @upper_bound.setter
    def upper_bound(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_upper_bound"](arg_newVal.COM_val))

    @property
    def scaling_value(self) -> typing.Any:
        """Applies to the Specified Value scaling method. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_scaling_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @scaling_value.setter
    def scaling_value(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_scaling_value"](arg_newVal.COM_val))

    @property
    def use_custom_display_unit(self) -> bool:
        """If true, allows display of values in another unit."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_custom_display_unit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_custom_display_unit.setter
    def use_custom_display_unit(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_custom_display_unit"](arg_newVal.COM_val))

    @property
    def custom_display_unit(self) -> str:
        """The unit in which the value will be displayed in the GUI."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_custom_display_unit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @custom_display_unit.setter
    def custom_display_unit(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_custom_display_unit"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4C637192-8687-4218-9BD6-A7B7C7B6E720}", ISNOPTControl)
agcls.AgTypeNameMap["ISNOPTControl"] = ISNOPTControl

class ISNOPTResult(object):
    """Properties for objecvtive and constraints of a SNOPT profile."""
    _uuid = "{79392E1D-E3C7-4403-9D4C-1C13AB8368A9}"
    _num_methods = 19
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_enable"] = _raise_uninitialized_error
        self.__dict__["_set_enable"] = _raise_uninitialized_error
        self.__dict__["_get_name"] = _raise_uninitialized_error
        self.__dict__["_get_current_value"] = _raise_uninitialized_error
        self.__dict__["_get_parent_name"] = _raise_uninitialized_error
        self.__dict__["_get_lower_bound"] = _raise_uninitialized_error
        self.__dict__["_set_lower_bound"] = _raise_uninitialized_error
        self.__dict__["_get_upper_bound"] = _raise_uninitialized_error
        self.__dict__["_set_upper_bound"] = _raise_uninitialized_error
        self.__dict__["_get_scaling_value"] = _raise_uninitialized_error
        self.__dict__["_set_scaling_value"] = _raise_uninitialized_error
        self.__dict__["_get_weight"] = _raise_uninitialized_error
        self.__dict__["_set_weight"] = _raise_uninitialized_error
        self.__dict__["_get_goal"] = _raise_uninitialized_error
        self.__dict__["_set_goal"] = _raise_uninitialized_error
        self.__dict__["_get_use_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_set_use_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_get_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_set_custom_display_unit"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISNOPTResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISNOPTResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISNOPTResult = agcom.GUID(ISNOPTResult._uuid)
        vtable_offset_local = ISNOPTResult._vtable_offset - 1
        self.__dict__["_get_enable"] = IAGFUNCTYPE(pUnk, IID_ISNOPTResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable"] = IAGFUNCTYPE(pUnk, IID_ISNOPTResult, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_name"] = IAGFUNCTYPE(pUnk, IID_ISNOPTResult, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_get_current_value"] = IAGFUNCTYPE(pUnk, IID_ISNOPTResult, vtable_offset_local+4, POINTER(agcom.VARIANT))
        self.__dict__["_get_parent_name"] = IAGFUNCTYPE(pUnk, IID_ISNOPTResult, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_get_lower_bound"] = IAGFUNCTYPE(pUnk, IID_ISNOPTResult, vtable_offset_local+6, POINTER(agcom.VARIANT))
        self.__dict__["_set_lower_bound"] = IAGFUNCTYPE(pUnk, IID_ISNOPTResult, vtable_offset_local+7, agcom.VARIANT)
        self.__dict__["_get_upper_bound"] = IAGFUNCTYPE(pUnk, IID_ISNOPTResult, vtable_offset_local+8, POINTER(agcom.VARIANT))
        self.__dict__["_set_upper_bound"] = IAGFUNCTYPE(pUnk, IID_ISNOPTResult, vtable_offset_local+9, agcom.VARIANT)
        self.__dict__["_get_scaling_value"] = IAGFUNCTYPE(pUnk, IID_ISNOPTResult, vtable_offset_local+10, POINTER(agcom.VARIANT))
        self.__dict__["_set_scaling_value"] = IAGFUNCTYPE(pUnk, IID_ISNOPTResult, vtable_offset_local+11, agcom.VARIANT)
        self.__dict__["_get_weight"] = IAGFUNCTYPE(pUnk, IID_ISNOPTResult, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_set_weight"] = IAGFUNCTYPE(pUnk, IID_ISNOPTResult, vtable_offset_local+13, agcom.DOUBLE)
        self.__dict__["_get_goal"] = IAGFUNCTYPE(pUnk, IID_ISNOPTResult, vtable_offset_local+14, POINTER(agcom.LONG))
        self.__dict__["_set_goal"] = IAGFUNCTYPE(pUnk, IID_ISNOPTResult, vtable_offset_local+15, agcom.LONG)
        self.__dict__["_get_use_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_ISNOPTResult, vtable_offset_local+16, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_ISNOPTResult, vtable_offset_local+17, agcom.VARIANT_BOOL)
        self.__dict__["_get_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_ISNOPTResult, vtable_offset_local+18, POINTER(agcom.BSTR))
        self.__dict__["_set_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_ISNOPTResult, vtable_offset_local+19, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISNOPTResult.__dict__ and type(ISNOPTResult.__dict__[attrname]) == property:
            return ISNOPTResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISNOPTResult.")
    
    @property
    def enable(self) -> bool:
        """If true, the variable is being used."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable.setter
    def enable(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable"](arg_newVal.COM_val))

    @property
    def name(self) -> str:
        """The name of the parameter."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def current_value(self) -> typing.Any:
        """The value achieved for this dependent variable in the last targeter run. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_current_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def parent_name(self) -> str:
        """Object - the name of the segment to which the parameter belongs."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_parent_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def lower_bound(self) -> typing.Any:
        """The lower limit achievable by this quantity in the optimizer's iteration history. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_lower_bound"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @lower_bound.setter
    def lower_bound(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_lower_bound"](arg_newVal.COM_val))

    @property
    def upper_bound(self) -> typing.Any:
        """The upper limit achievable by this quantity in the optimizer's iteration history. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_upper_bound"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @upper_bound.setter
    def upper_bound(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_upper_bound"](arg_newVal.COM_val))

    @property
    def scaling_value(self) -> typing.Any:
        """Applies to the Specified Value scaling method. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_scaling_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @scaling_value.setter
    def scaling_value(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_scaling_value"](arg_newVal.COM_val))

    @property
    def weight(self) -> float:
        """The factor by which the constraint error is to be multiplied."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_weight"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @weight.setter
    def weight(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_weight"](arg_newVal.COM_val))

    @property
    def goal(self) -> "AgEVASNOPTGoal":
        """The purpose of the element in the problem."""
        with agmarshall.AgEnum_arg(AgEVASNOPTGoal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_goal"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @goal.setter
    def goal(self, inVal:"AgEVASNOPTGoal") -> None:
        with agmarshall.AgEnum_arg(AgEVASNOPTGoal, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_goal"](arg_inVal.COM_val))

    @property
    def use_custom_display_unit(self) -> bool:
        """If true, allows display of values in another unit."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_custom_display_unit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_custom_display_unit.setter
    def use_custom_display_unit(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_custom_display_unit"](arg_newVal.COM_val))

    @property
    def custom_display_unit(self) -> str:
        """The unit in which the value will be displayed in the GUI."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_custom_display_unit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @custom_display_unit.setter
    def custom_display_unit(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_custom_display_unit"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{79392E1D-E3C7-4403-9D4C-1C13AB8368A9}", ISNOPTResult)
agcls.AgTypeNameMap["ISNOPTResult"] = ISNOPTResult

class IProfileIPOPTOptimizer(IProfile):
    """Properties of IPOPT Optimizer profile."""
    _uuid = "{23DCC03E-E187-41EF-85C8-FC3DCA09E7A8}"
    _num_methods = 18
    _vtable_offset = IProfile._vtable_offset + IProfile._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_control_parameters"] = _raise_uninitialized_error
        self.__dict__["_get_results"] = _raise_uninitialized_error
        self.__dict__["_get_targeter_graphs"] = _raise_uninitialized_error
        self.__dict__["_get_scripting_tool"] = _raise_uninitialized_error
        self.__dict__["_get_reset_controls_before_run"] = _raise_uninitialized_error
        self.__dict__["_set_reset_controls_before_run"] = _raise_uninitialized_error
        self.__dict__["_get_tolerance_on_convergence"] = _raise_uninitialized_error
        self.__dict__["_set_tolerance_on_convergence"] = _raise_uninitialized_error
        self.__dict__["_get_maximum_iterations"] = _raise_uninitialized_error
        self.__dict__["_set_maximum_iterations"] = _raise_uninitialized_error
        self.__dict__["_get_tolerance_on_constraint_violation"] = _raise_uninitialized_error
        self.__dict__["_set_tolerance_on_constraint_violation"] = _raise_uninitialized_error
        self.__dict__["_get_tolerance_on_dual_infeasibility"] = _raise_uninitialized_error
        self.__dict__["_set_tolerance_on_dual_infeasibility"] = _raise_uninitialized_error
        self.__dict__["_get_tolerance_on_complementary_infeasibility"] = _raise_uninitialized_error
        self.__dict__["_set_tolerance_on_complementary_infeasibility"] = _raise_uninitialized_error
        self.__dict__["_get_options_filename"] = _raise_uninitialized_error
        self.__dict__["_set_options_filename"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProfileIPOPTOptimizer._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProfileIPOPTOptimizer from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProfile._private_init(self, pUnk)
        IID_IProfileIPOPTOptimizer = agcom.GUID(IProfileIPOPTOptimizer._uuid)
        vtable_offset_local = IProfileIPOPTOptimizer._vtable_offset - 1
        self.__dict__["_get_control_parameters"] = IAGFUNCTYPE(pUnk, IID_IProfileIPOPTOptimizer, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_results"] = IAGFUNCTYPE(pUnk, IID_IProfileIPOPTOptimizer, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_targeter_graphs"] = IAGFUNCTYPE(pUnk, IID_IProfileIPOPTOptimizer, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_scripting_tool"] = IAGFUNCTYPE(pUnk, IID_IProfileIPOPTOptimizer, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_reset_controls_before_run"] = IAGFUNCTYPE(pUnk, IID_IProfileIPOPTOptimizer, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_reset_controls_before_run"] = IAGFUNCTYPE(pUnk, IID_IProfileIPOPTOptimizer, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_get_tolerance_on_convergence"] = IAGFUNCTYPE(pUnk, IID_IProfileIPOPTOptimizer, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_tolerance_on_convergence"] = IAGFUNCTYPE(pUnk, IID_IProfileIPOPTOptimizer, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_maximum_iterations"] = IAGFUNCTYPE(pUnk, IID_IProfileIPOPTOptimizer, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_set_maximum_iterations"] = IAGFUNCTYPE(pUnk, IID_IProfileIPOPTOptimizer, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_get_tolerance_on_constraint_violation"] = IAGFUNCTYPE(pUnk, IID_IProfileIPOPTOptimizer, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_tolerance_on_constraint_violation"] = IAGFUNCTYPE(pUnk, IID_IProfileIPOPTOptimizer, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_tolerance_on_dual_infeasibility"] = IAGFUNCTYPE(pUnk, IID_IProfileIPOPTOptimizer, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_tolerance_on_dual_infeasibility"] = IAGFUNCTYPE(pUnk, IID_IProfileIPOPTOptimizer, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_tolerance_on_complementary_infeasibility"] = IAGFUNCTYPE(pUnk, IID_IProfileIPOPTOptimizer, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_tolerance_on_complementary_infeasibility"] = IAGFUNCTYPE(pUnk, IID_IProfileIPOPTOptimizer, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_options_filename"] = IAGFUNCTYPE(pUnk, IID_IProfileIPOPTOptimizer, vtable_offset_local+17, POINTER(agcom.BSTR))
        self.__dict__["_set_options_filename"] = IAGFUNCTYPE(pUnk, IID_IProfileIPOPTOptimizer, vtable_offset_local+18, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProfileIPOPTOptimizer.__dict__ and type(IProfileIPOPTOptimizer.__dict__[attrname]) == property:
            return IProfileIPOPTOptimizer.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IProfile.__setattr__(self, attrname, value)
    
    @property
    def control_parameters(self) -> "IIPOPTControlCollection":
        """The list of control parameters defined for the profile."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAIPOPTControlCollection:
            agcls.evaluate_hresult(self.__dict__["_get_control_parameters"](byref(arg_ppVAIPOPTControlCollection.COM_val)))
            return arg_ppVAIPOPTControlCollection.python_val

    @property
    def results(self) -> "IIPOPTResultCollection":
        """The list of results defined for the profile."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAIPOPTResultCollection:
            agcls.evaluate_hresult(self.__dict__["_get_results"](byref(arg_ppVAIPOPTResultCollection.COM_val)))
            return arg_ppVAIPOPTResultCollection.python_val

    @property
    def targeter_graphs(self) -> "ITargeterGraphCollection":
        """Graphs"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_targeter_graphs"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def scripting_tool(self) -> "IScriptingTool":
        """Returns the Scripting tool for the sequence."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_scripting_tool"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def reset_controls_before_run(self) -> bool:
        """Reset controls before each run."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reset_controls_before_run"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reset_controls_before_run.setter
    def reset_controls_before_run(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_reset_controls_before_run"](arg_newVal.COM_val))

    @property
    def tolerance_on_convergence(self) -> float:
        """The tolerance by which the optimality conditions must be satisfied for the problem to be considered converged. The default value is 1E-8."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_tolerance_on_convergence"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @tolerance_on_convergence.setter
    def tolerance_on_convergence(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_tolerance_on_convergence"](arg_newVal.COM_val))

    @property
    def maximum_iterations(self) -> int:
        """The maximum number of iterations before IPOPT should give up if it hasn't yet converged on a solution. The default value is 3000."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_maximum_iterations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @maximum_iterations.setter
    def maximum_iterations(self, newVal:int) -> None:
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_maximum_iterations"](arg_newVal.COM_val))

    @property
    def tolerance_on_constraint_violation(self) -> float:
        """The tolerance by which user-specified constraints are allowed to be violated with the solution still considered feasible. The default value is 1.0E-4."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_tolerance_on_constraint_violation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @tolerance_on_constraint_violation.setter
    def tolerance_on_constraint_violation(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_tolerance_on_constraint_violation"](arg_newVal.COM_val))

    @property
    def tolerance_on_dual_infeasibility(self) -> float:
        """The desired absolute tolerance on the maximum norm of the dual infeasibility. The default value is 1."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_tolerance_on_dual_infeasibility"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @tolerance_on_dual_infeasibility.setter
    def tolerance_on_dual_infeasibility(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_tolerance_on_dual_infeasibility"](arg_newVal.COM_val))

    @property
    def tolerance_on_complementary_infeasibility(self) -> float:
        """The desired absolute tolerance on the maximum norm of the complementarity conditions. The default value is 1.0E-4."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_tolerance_on_complementary_infeasibility"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @tolerance_on_complementary_infeasibility.setter
    def tolerance_on_complementary_infeasibility(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_tolerance_on_complementary_infeasibility"](arg_newVal.COM_val))

    @property
    def options_filename(self) -> str:
        """If used, the associated IPOPT specifications file may define any of the various IPOPT options. Options in the file that conflict with options specified elsewhere will take precedence."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_options_filename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @options_filename.setter
    def options_filename(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_options_filename"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{23DCC03E-E187-41EF-85C8-FC3DCA09E7A8}", IProfileIPOPTOptimizer)
agcls.AgTypeNameMap["IProfileIPOPTOptimizer"] = IProfileIPOPTOptimizer

class IIPOPTControl(object):
    """Properties for control parameters of a IPOPT profile."""
    _uuid = "{EBDE767F-00E7-4779-ABB9-23DB3B87FE54}"
    _num_methods = 17
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_enable"] = _raise_uninitialized_error
        self.__dict__["_set_enable"] = _raise_uninitialized_error
        self.__dict__["_get_name"] = _raise_uninitialized_error
        self.__dict__["_get_parent_name"] = _raise_uninitialized_error
        self.__dict__["_get_initial_value"] = _raise_uninitialized_error
        self.__dict__["_get_current_value"] = _raise_uninitialized_error
        self.__dict__["_set_current_value"] = _raise_uninitialized_error
        self.__dict__["_get_lower_bound"] = _raise_uninitialized_error
        self.__dict__["_set_lower_bound"] = _raise_uninitialized_error
        self.__dict__["_get_upper_bound"] = _raise_uninitialized_error
        self.__dict__["_set_upper_bound"] = _raise_uninitialized_error
        self.__dict__["_get_scaling_value"] = _raise_uninitialized_error
        self.__dict__["_set_scaling_value"] = _raise_uninitialized_error
        self.__dict__["_get_use_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_set_use_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_get_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_set_custom_display_unit"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IIPOPTControl._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IIPOPTControl from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IIPOPTControl = agcom.GUID(IIPOPTControl._uuid)
        vtable_offset_local = IIPOPTControl._vtable_offset - 1
        self.__dict__["_get_enable"] = IAGFUNCTYPE(pUnk, IID_IIPOPTControl, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable"] = IAGFUNCTYPE(pUnk, IID_IIPOPTControl, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_name"] = IAGFUNCTYPE(pUnk, IID_IIPOPTControl, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_get_parent_name"] = IAGFUNCTYPE(pUnk, IID_IIPOPTControl, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_get_initial_value"] = IAGFUNCTYPE(pUnk, IID_IIPOPTControl, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_get_current_value"] = IAGFUNCTYPE(pUnk, IID_IIPOPTControl, vtable_offset_local+6, POINTER(agcom.VARIANT))
        self.__dict__["_set_current_value"] = IAGFUNCTYPE(pUnk, IID_IIPOPTControl, vtable_offset_local+7, agcom.VARIANT)
        self.__dict__["_get_lower_bound"] = IAGFUNCTYPE(pUnk, IID_IIPOPTControl, vtable_offset_local+8, POINTER(agcom.VARIANT))
        self.__dict__["_set_lower_bound"] = IAGFUNCTYPE(pUnk, IID_IIPOPTControl, vtable_offset_local+9, agcom.VARIANT)
        self.__dict__["_get_upper_bound"] = IAGFUNCTYPE(pUnk, IID_IIPOPTControl, vtable_offset_local+10, POINTER(agcom.VARIANT))
        self.__dict__["_set_upper_bound"] = IAGFUNCTYPE(pUnk, IID_IIPOPTControl, vtable_offset_local+11, agcom.VARIANT)
        self.__dict__["_get_scaling_value"] = IAGFUNCTYPE(pUnk, IID_IIPOPTControl, vtable_offset_local+12, POINTER(agcom.VARIANT))
        self.__dict__["_set_scaling_value"] = IAGFUNCTYPE(pUnk, IID_IIPOPTControl, vtable_offset_local+13, agcom.VARIANT)
        self.__dict__["_get_use_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IIPOPTControl, vtable_offset_local+14, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IIPOPTControl, vtable_offset_local+15, agcom.VARIANT_BOOL)
        self.__dict__["_get_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IIPOPTControl, vtable_offset_local+16, POINTER(agcom.BSTR))
        self.__dict__["_set_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IIPOPTControl, vtable_offset_local+17, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IIPOPTControl.__dict__ and type(IIPOPTControl.__dict__[attrname]) == property:
            return IIPOPTControl.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IIPOPTControl.")
    
    @property
    def enable(self) -> bool:
        """If true, the variable is being used."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable.setter
    def enable(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable"](arg_newVal.COM_val))

    @property
    def name(self) -> str:
        """The name of the parameter."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def parent_name(self) -> str:
        """The name of the segment to which the parameter belongs."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_parent_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def initial_value(self) -> typing.Any:
        """The nominal value of the element selected as a parameter. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_initial_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def current_value(self) -> typing.Any:
        """The value of the independent variable after the last targeter run."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_current_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @current_value.setter
    def current_value(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_current_value"](arg_newVal.COM_val))

    @property
    def lower_bound(self) -> typing.Any:
        """Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_lower_bound"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @lower_bound.setter
    def lower_bound(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_lower_bound"](arg_newVal.COM_val))

    @property
    def upper_bound(self) -> typing.Any:
        """Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_upper_bound"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @upper_bound.setter
    def upper_bound(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_upper_bound"](arg_newVal.COM_val))

    @property
    def scaling_value(self) -> typing.Any:
        """Applies to the Specified Value scaling method. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_scaling_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @scaling_value.setter
    def scaling_value(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_scaling_value"](arg_newVal.COM_val))

    @property
    def use_custom_display_unit(self) -> bool:
        """If true, allows display of values in another unit."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_custom_display_unit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_custom_display_unit.setter
    def use_custom_display_unit(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_custom_display_unit"](arg_newVal.COM_val))

    @property
    def custom_display_unit(self) -> str:
        """The unit in which the value will be displayed in the GUI."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_custom_display_unit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @custom_display_unit.setter
    def custom_display_unit(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_custom_display_unit"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{EBDE767F-00E7-4779-ABB9-23DB3B87FE54}", IIPOPTControl)
agcls.AgTypeNameMap["IIPOPTControl"] = IIPOPTControl

class IIPOPTResult(object):
    """Properties for objecvtive and constraints of a IPOPT profile."""
    _uuid = "{CBBEA11D-662A-4218-A9DC-84A16ABAE3D4}"
    _num_methods = 19
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_enable"] = _raise_uninitialized_error
        self.__dict__["_set_enable"] = _raise_uninitialized_error
        self.__dict__["_get_name"] = _raise_uninitialized_error
        self.__dict__["_get_current_value"] = _raise_uninitialized_error
        self.__dict__["_get_parent_name"] = _raise_uninitialized_error
        self.__dict__["_get_lower_bound"] = _raise_uninitialized_error
        self.__dict__["_set_lower_bound"] = _raise_uninitialized_error
        self.__dict__["_get_upper_bound"] = _raise_uninitialized_error
        self.__dict__["_set_upper_bound"] = _raise_uninitialized_error
        self.__dict__["_get_scaling_value"] = _raise_uninitialized_error
        self.__dict__["_set_scaling_value"] = _raise_uninitialized_error
        self.__dict__["_get_weight"] = _raise_uninitialized_error
        self.__dict__["_set_weight"] = _raise_uninitialized_error
        self.__dict__["_get_goal"] = _raise_uninitialized_error
        self.__dict__["_set_goal"] = _raise_uninitialized_error
        self.__dict__["_get_use_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_set_use_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_get_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_set_custom_display_unit"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IIPOPTResult._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IIPOPTResult from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IIPOPTResult = agcom.GUID(IIPOPTResult._uuid)
        vtable_offset_local = IIPOPTResult._vtable_offset - 1
        self.__dict__["_get_enable"] = IAGFUNCTYPE(pUnk, IID_IIPOPTResult, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable"] = IAGFUNCTYPE(pUnk, IID_IIPOPTResult, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_name"] = IAGFUNCTYPE(pUnk, IID_IIPOPTResult, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_get_current_value"] = IAGFUNCTYPE(pUnk, IID_IIPOPTResult, vtable_offset_local+4, POINTER(agcom.VARIANT))
        self.__dict__["_get_parent_name"] = IAGFUNCTYPE(pUnk, IID_IIPOPTResult, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_get_lower_bound"] = IAGFUNCTYPE(pUnk, IID_IIPOPTResult, vtable_offset_local+6, POINTER(agcom.VARIANT))
        self.__dict__["_set_lower_bound"] = IAGFUNCTYPE(pUnk, IID_IIPOPTResult, vtable_offset_local+7, agcom.VARIANT)
        self.__dict__["_get_upper_bound"] = IAGFUNCTYPE(pUnk, IID_IIPOPTResult, vtable_offset_local+8, POINTER(agcom.VARIANT))
        self.__dict__["_set_upper_bound"] = IAGFUNCTYPE(pUnk, IID_IIPOPTResult, vtable_offset_local+9, agcom.VARIANT)
        self.__dict__["_get_scaling_value"] = IAGFUNCTYPE(pUnk, IID_IIPOPTResult, vtable_offset_local+10, POINTER(agcom.VARIANT))
        self.__dict__["_set_scaling_value"] = IAGFUNCTYPE(pUnk, IID_IIPOPTResult, vtable_offset_local+11, agcom.VARIANT)
        self.__dict__["_get_weight"] = IAGFUNCTYPE(pUnk, IID_IIPOPTResult, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_set_weight"] = IAGFUNCTYPE(pUnk, IID_IIPOPTResult, vtable_offset_local+13, agcom.DOUBLE)
        self.__dict__["_get_goal"] = IAGFUNCTYPE(pUnk, IID_IIPOPTResult, vtable_offset_local+14, POINTER(agcom.LONG))
        self.__dict__["_set_goal"] = IAGFUNCTYPE(pUnk, IID_IIPOPTResult, vtable_offset_local+15, agcom.LONG)
        self.__dict__["_get_use_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IIPOPTResult, vtable_offset_local+16, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IIPOPTResult, vtable_offset_local+17, agcom.VARIANT_BOOL)
        self.__dict__["_get_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IIPOPTResult, vtable_offset_local+18, POINTER(agcom.BSTR))
        self.__dict__["_set_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IIPOPTResult, vtable_offset_local+19, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IIPOPTResult.__dict__ and type(IIPOPTResult.__dict__[attrname]) == property:
            return IIPOPTResult.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IIPOPTResult.")
    
    @property
    def enable(self) -> bool:
        """If true, the variable is being used."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable.setter
    def enable(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable"](arg_newVal.COM_val))

    @property
    def name(self) -> str:
        """The name of the parameter."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def current_value(self) -> typing.Any:
        """The value achieved for this dependent variable in the last targeter run. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_current_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def parent_name(self) -> str:
        """Object - the name of the segment to which the parameter belongs."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_parent_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def lower_bound(self) -> typing.Any:
        """The lower limit achievable by this quantity in the optimizer's iteration history. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_lower_bound"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @lower_bound.setter
    def lower_bound(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_lower_bound"](arg_newVal.COM_val))

    @property
    def upper_bound(self) -> typing.Any:
        """The upper limit achievable by this quantity in the optimizer's iteration history. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_upper_bound"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @upper_bound.setter
    def upper_bound(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_upper_bound"](arg_newVal.COM_val))

    @property
    def scaling_value(self) -> typing.Any:
        """Applies to the Specified Value scaling method. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_scaling_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @scaling_value.setter
    def scaling_value(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_scaling_value"](arg_newVal.COM_val))

    @property
    def weight(self) -> float:
        """The factor by which the constraint error is to be multiplied."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_weight"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @weight.setter
    def weight(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_weight"](arg_newVal.COM_val))

    @property
    def goal(self) -> "AgEVAIPOPTGoal":
        """The purpose of the element in the problem."""
        with agmarshall.AgEnum_arg(AgEVAIPOPTGoal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_goal"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @goal.setter
    def goal(self, inVal:"AgEVAIPOPTGoal") -> None:
        with agmarshall.AgEnum_arg(AgEVAIPOPTGoal, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_goal"](arg_inVal.COM_val))

    @property
    def use_custom_display_unit(self) -> bool:
        """If true, allows display of values in another unit."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_custom_display_unit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_custom_display_unit.setter
    def use_custom_display_unit(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_custom_display_unit"](arg_newVal.COM_val))

    @property
    def custom_display_unit(self) -> str:
        """The unit in which the value will be displayed in the GUI."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_custom_display_unit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @custom_display_unit.setter
    def custom_display_unit(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_custom_display_unit"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{CBBEA11D-662A-4218-A9DC-84A16ABAE3D4}", IIPOPTResult)
agcls.AgTypeNameMap["IIPOPTResult"] = IIPOPTResult

class IManeuverOptimalFinite(IManeuver):
    """Engine properties for a Optimal Finite Maneuver."""
    _uuid = "{FDEE9E11-C6ED-495E-9DC3-F3674F0D4813}"
    _num_methods = 40
    _vtable_offset = IManeuver._vtable_offset + IManeuver._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_pressure_mode"] = _raise_uninitialized_error
        self.__dict__["_set_pressure_mode"] = _raise_uninitialized_error
        self.__dict__["_get_thrust_efficiency"] = _raise_uninitialized_error
        self.__dict__["_set_thrust_efficiency"] = _raise_uninitialized_error
        self.__dict__["_get_thrust_efficiency_mode"] = _raise_uninitialized_error
        self.__dict__["_set_thrust_efficiency_mode"] = _raise_uninitialized_error
        self.__dict__["_get_number_of_nodes"] = _raise_uninitialized_error
        self.__dict__["_set_number_of_nodes"] = _raise_uninitialized_error
        self.__dict__["_get_initial_guess_file_name"] = _raise_uninitialized_error
        self.__dict__["_set_initial_guess_file_name"] = _raise_uninitialized_error
        self.__dict__["_get_seed_method"] = _raise_uninitialized_error
        self.__dict__["_set_seed_method"] = _raise_uninitialized_error
        self.__dict__["_run_seed"] = _raise_uninitialized_error
        self.__dict__["_get_node_status_message"] = _raise_uninitialized_error
        self.__dict__["_get_run_mode"] = _raise_uninitialized_error
        self.__dict__["_set_run_mode"] = _raise_uninitialized_error
        self.__dict__["_get_halt_mcs_when_no_convergence"] = _raise_uninitialized_error
        self.__dict__["_set_halt_mcs_when_no_convergence"] = _raise_uninitialized_error
        self.__dict__["_get_discretization_strategy"] = _raise_uninitialized_error
        self.__dict__["_set_discretization_strategy"] = _raise_uninitialized_error
        self.__dict__["_get_working_variables"] = _raise_uninitialized_error
        self.__dict__["_set_working_variables"] = _raise_uninitialized_error
        self.__dict__["_get_scaling_options"] = _raise_uninitialized_error
        self.__dict__["_set_scaling_options"] = _raise_uninitialized_error
        self.__dict__["_get_enable_unit_vector_controls"] = _raise_uninitialized_error
        self.__dict__["_set_enable_unit_vector_controls"] = _raise_uninitialized_error
        self.__dict__["_get_thrust_axes"] = _raise_uninitialized_error
        self.__dict__["_get_snopt_optimizer"] = _raise_uninitialized_error
        self.__dict__["_get_initial_boundary_conditions"] = _raise_uninitialized_error
        self.__dict__["_get_final_boundary_conditions"] = _raise_uninitialized_error
        self.__dict__["_get_path_boundary_conditions"] = _raise_uninitialized_error
        self.__dict__["_get_log_file_name"] = _raise_uninitialized_error
        self.__dict__["_get_export_format"] = _raise_uninitialized_error
        self.__dict__["_set_export_format"] = _raise_uninitialized_error
        self.__dict__["_get_steering_nodes"] = _raise_uninitialized_error
        self.__dict__["_export_nodes"] = _raise_uninitialized_error
        self.__dict__["_get_initial_guess_interpolation_method"] = _raise_uninitialized_error
        self.__dict__["_set_initial_guess_interpolation_method"] = _raise_uninitialized_error
        self.__dict__["_get_should_reinitialize_stm_at_start_of_segment_propagation"] = _raise_uninitialized_error
        self.__dict__["_set_should_reinitialize_stm_at_start_of_segment_propagation"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IManeuverOptimalFinite._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IManeuverOptimalFinite from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IManeuver._private_init(self, pUnk)
        IID_IManeuverOptimalFinite = agcom.GUID(IManeuverOptimalFinite._uuid)
        vtable_offset_local = IManeuverOptimalFinite._vtable_offset - 1
        self.__dict__["_get_pressure_mode"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_pressure_mode"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_thrust_efficiency"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_thrust_efficiency"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_thrust_efficiency_mode"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_thrust_efficiency_mode"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_number_of_nodes"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_number_of_nodes"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_initial_guess_file_name"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_set_initial_guess_file_name"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+10, agcom.BSTR)
        self.__dict__["_get_seed_method"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_set_seed_method"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_run_seed"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+13, )
        self.__dict__["_get_node_status_message"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+14, POINTER(agcom.BSTR))
        self.__dict__["_get_run_mode"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+15, POINTER(agcom.LONG))
        self.__dict__["_set_run_mode"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_get_halt_mcs_when_no_convergence"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+17, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_halt_mcs_when_no_convergence"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+18, agcom.VARIANT_BOOL)
        self.__dict__["_get_discretization_strategy"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+19, POINTER(agcom.LONG))
        self.__dict__["_set_discretization_strategy"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+20, agcom.LONG)
        self.__dict__["_get_working_variables"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+21, POINTER(agcom.LONG))
        self.__dict__["_set_working_variables"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+22, agcom.LONG)
        self.__dict__["_get_scaling_options"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+23, POINTER(agcom.LONG))
        self.__dict__["_set_scaling_options"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+24, agcom.LONG)
        self.__dict__["_get_enable_unit_vector_controls"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+25, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable_unit_vector_controls"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+26, agcom.VARIANT_BOOL)
        self.__dict__["_get_thrust_axes"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+27, POINTER(agcom.BSTR))
        self.__dict__["_get_snopt_optimizer"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+28, POINTER(agcom.PVOID))
        self.__dict__["_get_initial_boundary_conditions"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+29, POINTER(agcom.PVOID))
        self.__dict__["_get_final_boundary_conditions"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+30, POINTER(agcom.PVOID))
        self.__dict__["_get_path_boundary_conditions"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+31, POINTER(agcom.PVOID))
        self.__dict__["_get_log_file_name"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+32, POINTER(agcom.BSTR))
        self.__dict__["_get_export_format"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+33, POINTER(agcom.LONG))
        self.__dict__["_set_export_format"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+34, agcom.LONG)
        self.__dict__["_get_steering_nodes"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+35, POINTER(agcom.PVOID))
        self.__dict__["_export_nodes"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+36, agcom.BSTR)
        self.__dict__["_get_initial_guess_interpolation_method"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+37, POINTER(agcom.LONG))
        self.__dict__["_set_initial_guess_interpolation_method"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+38, agcom.LONG)
        self.__dict__["_get_should_reinitialize_stm_at_start_of_segment_propagation"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+39, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_should_reinitialize_stm_at_start_of_segment_propagation"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFinite, vtable_offset_local+40, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IManeuverOptimalFinite.__dict__ and type(IManeuverOptimalFinite.__dict__[attrname]) == property:
            return IManeuverOptimalFinite.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IManeuver.__setattr__(self, attrname, value)
    
    @property
    def pressure_mode(self) -> "AgEVAPressureMode":
        """The pressure mode."""
        with agmarshall.AgEnum_arg(AgEVAPressureMode) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_pressure_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @pressure_mode.setter
    def pressure_mode(self, newVal:"AgEVAPressureMode") -> None:
        with agmarshall.AgEnum_arg(AgEVAPressureMode, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_pressure_mode"](arg_newVal.COM_val))

    @property
    def thrust_efficiency(self) -> float:
        """The fraction of ideal thrust applied. Any number above zero is valid, with typical values around 0.98 to 1.02. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_thrust_efficiency"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @thrust_efficiency.setter
    def thrust_efficiency(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_thrust_efficiency"](arg_newVal.COM_val))

    @property
    def thrust_efficiency_mode(self) -> "AgEVAThrustType":
        """Thrust - the calculations that are effected by the thrust efficiency value."""
        with agmarshall.AgEnum_arg(AgEVAThrustType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_thrust_efficiency_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @thrust_efficiency_mode.setter
    def thrust_efficiency_mode(self, newVal:"AgEVAThrustType") -> None:
        """Mode indicating fraction of ideal thrust applied."""
        with agmarshall.AgEnum_arg(AgEVAThrustType, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_thrust_efficiency_mode"](arg_newVal.COM_val))

    @property
    def number_of_nodes(self) -> int:
        """Number of nodes to discretize collocation problem into."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_number_of_nodes"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @number_of_nodes.setter
    def number_of_nodes(self, newVal:int) -> None:
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_number_of_nodes"](arg_newVal.COM_val))

    @property
    def initial_guess_file_name(self) -> str:
        """File containing ephemeris for nodes that serve as an initial guess."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_initial_guess_file_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @initial_guess_file_name.setter
    def initial_guess_file_name(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_initial_guess_file_name"](arg_newVal.COM_val))

    @property
    def seed_method(self) -> "AgEVAOptimalFiniteSeedMethod":
        """Initial seed method."""
        with agmarshall.AgEnum_arg(AgEVAOptimalFiniteSeedMethod) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_seed_method"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @seed_method.setter
    def seed_method(self, newVal:"AgEVAOptimalFiniteSeedMethod") -> None:
        with agmarshall.AgEnum_arg(AgEVAOptimalFiniteSeedMethod, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_seed_method"](arg_newVal.COM_val))

    def run_seed(self) -> None:
        """Run seed."""
        agcls.evaluate_hresult(self.__dict__["_run_seed"]())

    @property
    def node_status_message(self) -> str:
        """A message that indicates what nodes are currently held by the segment."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_node_status_message"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def run_mode(self) -> "AgEVAOptimalFiniteRunMode":
        """Run mode."""
        with agmarshall.AgEnum_arg(AgEVAOptimalFiniteRunMode) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_run_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @run_mode.setter
    def run_mode(self, newVal:"AgEVAOptimalFiniteRunMode") -> None:
        with agmarshall.AgEnum_arg(AgEVAOptimalFiniteRunMode, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_run_mode"](arg_newVal.COM_val))

    @property
    def halt_mcs_when_no_convergence(self) -> bool:
        """Halt MCS and discard result if optimization is unsuccessful."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_halt_mcs_when_no_convergence"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @halt_mcs_when_no_convergence.setter
    def halt_mcs_when_no_convergence(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_halt_mcs_when_no_convergence"](arg_newVal.COM_val))

    @property
    def discretization_strategy(self) -> "AgEVAOptimalFiniteDiscretizationStrategy":
        """Discretization Strategy."""
        with agmarshall.AgEnum_arg(AgEVAOptimalFiniteDiscretizationStrategy) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_discretization_strategy"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @discretization_strategy.setter
    def discretization_strategy(self, newVal:"AgEVAOptimalFiniteDiscretizationStrategy") -> None:
        with agmarshall.AgEnum_arg(AgEVAOptimalFiniteDiscretizationStrategy, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_discretization_strategy"](arg_newVal.COM_val))

    @property
    def working_variables(self) -> "AgEVAOptimalFiniteWorkingVariables":
        """Working Variables."""
        with agmarshall.AgEnum_arg(AgEVAOptimalFiniteWorkingVariables) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_working_variables"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @working_variables.setter
    def working_variables(self, newVal:"AgEVAOptimalFiniteWorkingVariables") -> None:
        with agmarshall.AgEnum_arg(AgEVAOptimalFiniteWorkingVariables, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_working_variables"](arg_newVal.COM_val))

    @property
    def scaling_options(self) -> "AgEVAOptimalFiniteScalingOptions":
        """Scaling Options."""
        with agmarshall.AgEnum_arg(AgEVAOptimalFiniteScalingOptions) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_scaling_options"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @scaling_options.setter
    def scaling_options(self, newVal:"AgEVAOptimalFiniteScalingOptions") -> None:
        with agmarshall.AgEnum_arg(AgEVAOptimalFiniteScalingOptions, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_scaling_options"](arg_newVal.COM_val))

    @property
    def enable_unit_vector_controls(self) -> bool:
        """Enable unit vector for thrust direction."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable_unit_vector_controls"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable_unit_vector_controls.setter
    def enable_unit_vector_controls(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable_unit_vector_controls"](arg_newVal.COM_val))

    @property
    def thrust_axes(self) -> str:
        """Label reflecting coordinate axes for the thrust vector"""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_thrust_axes"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def snopt_optimizer(self) -> "IManeuverOptimalFiniteSNOPTOptimizer":
        """SNOPT Optimizer Options."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteSNOPTOptimizer:
            agcls.evaluate_hresult(self.__dict__["_get_snopt_optimizer"](byref(arg_ppAgVAManeuverOptimalFiniteSNOPTOptimizer.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteSNOPTOptimizer.python_val

    @property
    def initial_boundary_conditions(self) -> "IManeuverOptimalFiniteInitialBoundaryConditions":
        """Initial Boundary Conditions."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteInitialBoundaryConditions:
            agcls.evaluate_hresult(self.__dict__["_get_initial_boundary_conditions"](byref(arg_ppAgVAManeuverOptimalFiniteInitialBoundaryConditions.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteInitialBoundaryConditions.python_val

    @property
    def final_boundary_conditions(self) -> "IManeuverOptimalFiniteFinalBoundaryConditions":
        """Final Boundary Conditions."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFiniteFinalBoundaryConditions:
            agcls.evaluate_hresult(self.__dict__["_get_final_boundary_conditions"](byref(arg_ppAgVAManeuverOptimalFiniteFinalBoundaryConditions.COM_val)))
            return arg_ppAgVAManeuverOptimalFiniteFinalBoundaryConditions.python_val

    @property
    def path_boundary_conditions(self) -> "IManeuverOptimalFinitePathBoundaryConditions":
        """Path Boundary Conditions."""
        with agmarshall.AgInterface_out_arg() as arg_ppAgVAManeuverOptimalFinitePathBoundaryConditions:
            agcls.evaluate_hresult(self.__dict__["_get_path_boundary_conditions"](byref(arg_ppAgVAManeuverOptimalFinitePathBoundaryConditions.COM_val)))
            return arg_ppAgVAManeuverOptimalFinitePathBoundaryConditions.python_val

    @property
    def log_file_name(self) -> str:
        """Log file name for optimal finite maneuver."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_log_file_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def export_format(self) -> "AgEVAOptimalFiniteExportNodesFormat":
        """Format for exporting collocation control variables."""
        with agmarshall.AgEnum_arg(AgEVAOptimalFiniteExportNodesFormat) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_export_format"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @export_format.setter
    def export_format(self, newVal:"AgEVAOptimalFiniteExportNodesFormat") -> None:
        with agmarshall.AgEnum_arg(AgEVAOptimalFiniteExportNodesFormat, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_export_format"](arg_newVal.COM_val))

    @property
    def steering_nodes(self) -> "IManeuverOptimalFiniteSteeringNodeCollection":
        """The list of steering nodes."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAManeuverOptimalFiniteFinalSteeringNodeCollection:
            agcls.evaluate_hresult(self.__dict__["_get_steering_nodes"](byref(arg_ppVAManeuverOptimalFiniteFinalSteeringNodeCollection.COM_val)))
            return arg_ppVAManeuverOptimalFiniteFinalSteeringNodeCollection.python_val

    def export_nodes(self, fileName:str) -> None:
        """Exports the current set of collocation nodes to a file."""
        with agmarshall.BSTR_arg(fileName) as arg_fileName:
            agcls.evaluate_hresult(self.__dict__["_export_nodes"](arg_fileName.COM_val))

    @property
    def initial_guess_interpolation_method(self) -> "AgEVAOptimalFiniteGuessMethod":
        """Guess interpolation method."""
        with agmarshall.AgEnum_arg(AgEVAOptimalFiniteGuessMethod) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_initial_guess_interpolation_method"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @initial_guess_interpolation_method.setter
    def initial_guess_interpolation_method(self, newVal:"AgEVAOptimalFiniteGuessMethod") -> None:
        with agmarshall.AgEnum_arg(AgEVAOptimalFiniteGuessMethod, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_initial_guess_interpolation_method"](arg_newVal.COM_val))

    @property
    def should_reinitialize_stm_at_start_of_segment_propagation(self) -> bool:
        """If this segment is propagating the state transition matrix, reset it to the identity matrix at the start of the segment."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_should_reinitialize_stm_at_start_of_segment_propagation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @should_reinitialize_stm_at_start_of_segment_propagation.setter
    def should_reinitialize_stm_at_start_of_segment_propagation(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_should_reinitialize_stm_at_start_of_segment_propagation"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{FDEE9E11-C6ED-495E-9DC3-F3674F0D4813}", IManeuverOptimalFinite)
agcls.AgTypeNameMap["IManeuverOptimalFinite"] = IManeuverOptimalFinite

class IManeuverOptimalFiniteSteeringNodeElement(object):
    """The elements of the steering node."""
    _uuid = "{428CDEC6-6E07-4EDA-B656-AF669F95BB8E}"
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_node_index"] = _raise_uninitialized_error
        self.__dict__["_get_time"] = _raise_uninitialized_error
        self.__dict__["_get_mass"] = _raise_uninitialized_error
        self.__dict__["_get_azimuth"] = _raise_uninitialized_error
        self.__dict__["_get_elevation"] = _raise_uninitialized_error
        self.__dict__["_get_dir_cos_x"] = _raise_uninitialized_error
        self.__dict__["_get_dir_cos_y"] = _raise_uninitialized_error
        self.__dict__["_get_dir_cos_z"] = _raise_uninitialized_error
        self.__dict__["_get_pos_x"] = _raise_uninitialized_error
        self.__dict__["_get_pos_y"] = _raise_uninitialized_error
        self.__dict__["_get_pos_z"] = _raise_uninitialized_error
        self.__dict__["_get_vel_x"] = _raise_uninitialized_error
        self.__dict__["_get_vel_y"] = _raise_uninitialized_error
        self.__dict__["_get_vel_z"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IManeuverOptimalFiniteSteeringNodeElement._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IManeuverOptimalFiniteSteeringNodeElement from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IManeuverOptimalFiniteSteeringNodeElement = agcom.GUID(IManeuverOptimalFiniteSteeringNodeElement._uuid)
        vtable_offset_local = IManeuverOptimalFiniteSteeringNodeElement._vtable_offset - 1
        self.__dict__["_get_node_index"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSteeringNodeElement, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_get_time"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSteeringNodeElement, vtable_offset_local+2, POINTER(agcom.DOUBLE))
        self.__dict__["_get_mass"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSteeringNodeElement, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_get_azimuth"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSteeringNodeElement, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_get_elevation"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSteeringNodeElement, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_get_dir_cos_x"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSteeringNodeElement, vtable_offset_local+6, POINTER(agcom.DOUBLE))
        self.__dict__["_get_dir_cos_y"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSteeringNodeElement, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_get_dir_cos_z"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSteeringNodeElement, vtable_offset_local+8, POINTER(agcom.DOUBLE))
        self.__dict__["_get_pos_x"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSteeringNodeElement, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_get_pos_y"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSteeringNodeElement, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_get_pos_z"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSteeringNodeElement, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_get_vel_x"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSteeringNodeElement, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_get_vel_y"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSteeringNodeElement, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_get_vel_z"] = IAGFUNCTYPE(pUnk, IID_IManeuverOptimalFiniteSteeringNodeElement, vtable_offset_local+14, POINTER(agcom.DOUBLE))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IManeuverOptimalFiniteSteeringNodeElement.__dict__ and type(IManeuverOptimalFiniteSteeringNodeElement.__dict__[attrname]) == property:
            return IManeuverOptimalFiniteSteeringNodeElement.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IManeuverOptimalFiniteSteeringNodeElement.")
    
    @property
    def node_index(self) -> int:
        """The index of the node in the array of nodes."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_node_index"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def time(self) -> float:
        """The time associated with the node."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def mass(self) -> float:
        """The mass at the node."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_mass"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def azimuth(self) -> float:
        """The azimuth of the steering angle."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_azimuth"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def elevation(self) -> float:
        """The elevation of the steering angle."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_elevation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def dir_cos_x(self) -> float:
        """The first component of the steering unit vector."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_dir_cos_x"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def dir_cos_y(self) -> float:
        """The second component of the steering unit vector."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_dir_cos_y"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def dir_cos_z(self) -> float:
        """The third component of the steering unit vector."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_dir_cos_z"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def pos_x(self) -> float:
        """The X component of the position vector."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_pos_x"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def pos_y(self) -> float:
        """The Y component of the position vector."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_pos_y"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def pos_z(self) -> float:
        """The Z component of the position vector."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_pos_z"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def vel_x(self) -> float:
        """The X component of the velocity vector."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_vel_x"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def vel_y(self) -> float:
        """The Y component of the velocity vector."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_vel_y"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def vel_z(self) -> float:
        """The Z component of the velocity vector."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_vel_z"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{428CDEC6-6E07-4EDA-B656-AF669F95BB8E}", IManeuverOptimalFiniteSteeringNodeElement)
agcls.AgTypeNameMap["IManeuverOptimalFiniteSteeringNodeElement"] = IManeuverOptimalFiniteSteeringNodeElement

class IProfileLambertProfile(IProfile):
    """Properties for a Lambert profile."""
    _uuid = "{6F736B1F-850D-4736-9106-8BDC4FE52A30}"
    _num_methods = 56
    _vtable_offset = IProfile._vtable_offset + IProfile._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_set_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_get_target_coord_type"] = _raise_uninitialized_error
        self.__dict__["_set_target_coord_type"] = _raise_uninitialized_error
        self.__dict__["_get_enable_second_maneuver"] = _raise_uninitialized_error
        self.__dict__["_set_enable_second_maneuver"] = _raise_uninitialized_error
        self.__dict__["_get_target_position_x"] = _raise_uninitialized_error
        self.__dict__["_set_target_position_x"] = _raise_uninitialized_error
        self.__dict__["_get_target_position_y"] = _raise_uninitialized_error
        self.__dict__["_set_target_position_y"] = _raise_uninitialized_error
        self.__dict__["_get_target_position_z"] = _raise_uninitialized_error
        self.__dict__["_set_target_position_z"] = _raise_uninitialized_error
        self.__dict__["_get_target_velocity_x"] = _raise_uninitialized_error
        self.__dict__["_set_target_velocity_x"] = _raise_uninitialized_error
        self.__dict__["_get_target_velocity_y"] = _raise_uninitialized_error
        self.__dict__["_set_target_velocity_y"] = _raise_uninitialized_error
        self.__dict__["_get_target_velocity_z"] = _raise_uninitialized_error
        self.__dict__["_set_target_velocity_z"] = _raise_uninitialized_error
        self.__dict__["_get_target_semimajor_axis"] = _raise_uninitialized_error
        self.__dict__["_set_target_semimajor_axis"] = _raise_uninitialized_error
        self.__dict__["_get_target_eccentricity"] = _raise_uninitialized_error
        self.__dict__["_set_target_eccentricity"] = _raise_uninitialized_error
        self.__dict__["_get_target_inclination"] = _raise_uninitialized_error
        self.__dict__["_set_target_inclination"] = _raise_uninitialized_error
        self.__dict__["_get_target_right_ascension_of_ascending_node"] = _raise_uninitialized_error
        self.__dict__["_set_target_right_ascension_of_ascending_node"] = _raise_uninitialized_error
        self.__dict__["_get_target_argument_of_periapsis"] = _raise_uninitialized_error
        self.__dict__["_set_target_argument_of_periapsis"] = _raise_uninitialized_error
        self.__dict__["_get_target_true_anomaly"] = _raise_uninitialized_error
        self.__dict__["_set_target_true_anomaly"] = _raise_uninitialized_error
        self.__dict__["_get_solution_option"] = _raise_uninitialized_error
        self.__dict__["_set_solution_option"] = _raise_uninitialized_error
        self.__dict__["_get_time_of_flight"] = _raise_uninitialized_error
        self.__dict__["_set_time_of_flight"] = _raise_uninitialized_error
        self.__dict__["_get_revolutions"] = _raise_uninitialized_error
        self.__dict__["_set_revolutions"] = _raise_uninitialized_error
        self.__dict__["_get_orbital_energy"] = _raise_uninitialized_error
        self.__dict__["_set_orbital_energy"] = _raise_uninitialized_error
        self.__dict__["_get_direction_of_motion"] = _raise_uninitialized_error
        self.__dict__["_set_direction_of_motion"] = _raise_uninitialized_error
        self.__dict__["_get_central_body_collision_altitude_padding"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_collision_altitude_padding"] = _raise_uninitialized_error
        self.__dict__["_get_enable_write_to_first_maneuver"] = _raise_uninitialized_error
        self.__dict__["_set_enable_write_to_first_maneuver"] = _raise_uninitialized_error
        self.__dict__["_get_first_maneuver_segment"] = _raise_uninitialized_error
        self.__dict__["_set_first_maneuver_segment"] = _raise_uninitialized_error
        self.__dict__["_get_enable_write_duration_to_propagate"] = _raise_uninitialized_error
        self.__dict__["_set_enable_write_duration_to_propagate"] = _raise_uninitialized_error
        self.__dict__["_get_disable_non_lambert_propagate_stop_conditions"] = _raise_uninitialized_error
        self.__dict__["_set_disable_non_lambert_propagate_stop_conditions"] = _raise_uninitialized_error
        self.__dict__["_get_propagate_segment"] = _raise_uninitialized_error
        self.__dict__["_set_propagate_segment"] = _raise_uninitialized_error
        self.__dict__["_get_enable_write_to_second_maneuver"] = _raise_uninitialized_error
        self.__dict__["_set_enable_write_to_second_maneuver"] = _raise_uninitialized_error
        self.__dict__["_get_second_maneuver_segment"] = _raise_uninitialized_error
        self.__dict__["_set_second_maneuver_segment"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProfileLambertProfile._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProfileLambertProfile from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProfile._private_init(self, pUnk)
        IID_IProfileLambertProfile = agcom.GUID(IProfileLambertProfile._uuid)
        vtable_offset_local = IProfileLambertProfile._vtable_offset - 1
        self.__dict__["_get_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_target_coord_type"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_target_coord_type"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_enable_second_maneuver"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable_second_maneuver"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_get_target_position_x"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_target_position_x"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_target_position_y"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_target_position_y"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_target_position_z"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_target_position_z"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_target_velocity_x"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_target_velocity_x"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_target_velocity_y"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_target_velocity_y"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_target_velocity_z"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_target_velocity_z"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_target_semimajor_axis"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_set_target_semimajor_axis"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_get_target_eccentricity"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_set_target_eccentricity"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+22, agcom.DOUBLE)
        self.__dict__["_get_target_inclination"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+23, POINTER(agcom.DOUBLE))
        self.__dict__["_set_target_inclination"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+24, agcom.DOUBLE)
        self.__dict__["_get_target_right_ascension_of_ascending_node"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+25, POINTER(agcom.DOUBLE))
        self.__dict__["_set_target_right_ascension_of_ascending_node"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+26, agcom.DOUBLE)
        self.__dict__["_get_target_argument_of_periapsis"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+27, POINTER(agcom.DOUBLE))
        self.__dict__["_set_target_argument_of_periapsis"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+28, agcom.DOUBLE)
        self.__dict__["_get_target_true_anomaly"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+29, POINTER(agcom.DOUBLE))
        self.__dict__["_set_target_true_anomaly"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+30, agcom.DOUBLE)
        self.__dict__["_get_solution_option"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+31, POINTER(agcom.LONG))
        self.__dict__["_set_solution_option"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+32, agcom.LONG)
        self.__dict__["_get_time_of_flight"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+33, POINTER(agcom.DOUBLE))
        self.__dict__["_set_time_of_flight"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+34, agcom.DOUBLE)
        self.__dict__["_get_revolutions"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+35, POINTER(agcom.LONG))
        self.__dict__["_set_revolutions"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+36, agcom.LONG)
        self.__dict__["_get_orbital_energy"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+37, POINTER(agcom.LONG))
        self.__dict__["_set_orbital_energy"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+38, agcom.LONG)
        self.__dict__["_get_direction_of_motion"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+39, POINTER(agcom.LONG))
        self.__dict__["_set_direction_of_motion"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+40, agcom.LONG)
        self.__dict__["_get_central_body_collision_altitude_padding"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+41, POINTER(agcom.DOUBLE))
        self.__dict__["_set_central_body_collision_altitude_padding"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+42, agcom.DOUBLE)
        self.__dict__["_get_enable_write_to_first_maneuver"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+43, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable_write_to_first_maneuver"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+44, agcom.VARIANT_BOOL)
        self.__dict__["_get_first_maneuver_segment"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+45, POINTER(agcom.BSTR))
        self.__dict__["_set_first_maneuver_segment"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+46, agcom.BSTR)
        self.__dict__["_get_enable_write_duration_to_propagate"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+47, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable_write_duration_to_propagate"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+48, agcom.VARIANT_BOOL)
        self.__dict__["_get_disable_non_lambert_propagate_stop_conditions"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+49, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_disable_non_lambert_propagate_stop_conditions"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+50, agcom.VARIANT_BOOL)
        self.__dict__["_get_propagate_segment"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+51, POINTER(agcom.BSTR))
        self.__dict__["_set_propagate_segment"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+52, agcom.BSTR)
        self.__dict__["_get_enable_write_to_second_maneuver"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+53, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable_write_to_second_maneuver"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+54, agcom.VARIANT_BOOL)
        self.__dict__["_get_second_maneuver_segment"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+55, POINTER(agcom.BSTR))
        self.__dict__["_set_second_maneuver_segment"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertProfile, vtable_offset_local+56, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProfileLambertProfile.__dict__ and type(IProfileLambertProfile.__dict__[attrname]) == property:
            return IProfileLambertProfile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IProfile.__setattr__(self, attrname, value)
    
    @property
    def coord_system_name(self) -> str:
        """The coordinate system."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_system_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_system_name.setter
    def coord_system_name(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_system_name"](arg_newVal.COM_val))

    @property
    def target_coord_type(self) -> "AgEVALambertTargetCoordType":
        """The target coordinate type."""
        with agmarshall.AgEnum_arg(AgEVALambertTargetCoordType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_coord_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_target_coord_type(self, elementType:"AgEVALambertTargetCoordType") -> None:
        """Selects a target coordinate type."""
        with agmarshall.AgEnum_arg(AgEVALambertTargetCoordType, elementType) as arg_elementType:
            agcls.evaluate_hresult(self.__dict__["_set_target_coord_type"](arg_elementType.COM_val))

    @property
    def enable_second_maneuver(self) -> bool:
        """Enable to calculate second maneuver at destination."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable_second_maneuver"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable_second_maneuver.setter
    def enable_second_maneuver(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable_second_maneuver"](arg_newVal.COM_val))

    @property
    def target_position_x(self) -> float:
        """The X component of the target position for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_position_x"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_position_x.setter
    def target_position_x(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_position_x"](arg_newVal.COM_val))

    @property
    def target_position_y(self) -> float:
        """The Y component of the target position for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_position_y"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_position_y.setter
    def target_position_y(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_position_y"](arg_newVal.COM_val))

    @property
    def target_position_z(self) -> float:
        """The Z component of the target position for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_position_z"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_position_z.setter
    def target_position_z(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_position_z"](arg_newVal.COM_val))

    @property
    def target_velocity_x(self) -> float:
        """The X component of the target velocity for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_velocity_x"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_velocity_x.setter
    def target_velocity_x(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_velocity_x"](arg_newVal.COM_val))

    @property
    def target_velocity_y(self) -> float:
        """The Y component of the target velocity for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_velocity_y"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_velocity_y.setter
    def target_velocity_y(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_velocity_y"](arg_newVal.COM_val))

    @property
    def target_velocity_z(self) -> float:
        """The Z component of the target velocity for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_velocity_z"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_velocity_z.setter
    def target_velocity_z(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_velocity_z"](arg_newVal.COM_val))

    @property
    def target_semimajor_axis(self) -> float:
        """The target semimajor axis for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_semimajor_axis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_semimajor_axis.setter
    def target_semimajor_axis(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_semimajor_axis"](arg_newVal.COM_val))

    @property
    def target_eccentricity(self) -> float:
        """The target eccentricity for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_eccentricity"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_eccentricity.setter
    def target_eccentricity(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_eccentricity"](arg_newVal.COM_val))

    @property
    def target_inclination(self) -> float:
        """The target inclination for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_inclination"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_inclination.setter
    def target_inclination(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_inclination"](arg_newVal.COM_val))

    @property
    def target_right_ascension_of_ascending_node(self) -> float:
        """The target right ascension of the ascending node for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_right_ascension_of_ascending_node"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_right_ascension_of_ascending_node.setter
    def target_right_ascension_of_ascending_node(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_right_ascension_of_ascending_node"](arg_newVal.COM_val))

    @property
    def target_argument_of_periapsis(self) -> float:
        """The target argument of periapsis for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_argument_of_periapsis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_argument_of_periapsis.setter
    def target_argument_of_periapsis(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_argument_of_periapsis"](arg_newVal.COM_val))

    @property
    def target_true_anomaly(self) -> float:
        """The target true anomaly for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_true_anomaly"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_true_anomaly.setter
    def target_true_anomaly(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_true_anomaly"](arg_newVal.COM_val))

    @property
    def solution_option(self) -> "AgEVALambertSolutionOptionType":
        """Lambert solution calculation type."""
        with agmarshall.AgEnum_arg(AgEVALambertSolutionOptionType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_solution_option"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @solution_option.setter
    def solution_option(self, newVal:"AgEVALambertSolutionOptionType") -> None:
        with agmarshall.AgEnum_arg(AgEVALambertSolutionOptionType, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_solution_option"](arg_newVal.COM_val))

    @property
    def time_of_flight(self) -> float:
        """The time of flight between departure and arrival for the Lambert solution."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_time_of_flight"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @time_of_flight.setter
    def time_of_flight(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_time_of_flight"](arg_newVal.COM_val))

    @property
    def revolutions(self) -> int:
        """The number of revolutions. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_revolutions"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @revolutions.setter
    def revolutions(self, newVal:int) -> None:
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_revolutions"](arg_newVal.COM_val))

    @property
    def orbital_energy(self) -> "AgEVALambertOrbitalEnergyType":
        """The orbital energy for the Lambert solution."""
        with agmarshall.AgEnum_arg(AgEVALambertOrbitalEnergyType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_orbital_energy"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @orbital_energy.setter
    def orbital_energy(self, newVal:"AgEVALambertOrbitalEnergyType") -> None:
        with agmarshall.AgEnum_arg(AgEVALambertOrbitalEnergyType, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_orbital_energy"](arg_newVal.COM_val))

    @property
    def direction_of_motion(self) -> "AgEVALambertDirectionOfMotionType":
        """The direction of motion (long or short) for the Lambert solution."""
        with agmarshall.AgEnum_arg(AgEVALambertDirectionOfMotionType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_direction_of_motion"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @direction_of_motion.setter
    def direction_of_motion(self, newVal:"AgEVALambertDirectionOfMotionType") -> None:
        with agmarshall.AgEnum_arg(AgEVALambertDirectionOfMotionType, newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_direction_of_motion"](arg_newVal.COM_val))

    @property
    def central_body_collision_altitude_padding(self) -> float:
        """The minimum altitude below which the Lambert algorithm will consider the spacecraft to have hit the central body."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_collision_altitude_padding"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_collision_altitude_padding.setter
    def central_body_collision_altitude_padding(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_collision_altitude_padding"](arg_newVal.COM_val))

    @property
    def enable_write_to_first_maneuver(self) -> bool:
        """Set this to true to write the Delta-V solution from Lambert at the start of the transfer to the linked maneuver."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable_write_to_first_maneuver"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable_write_to_first_maneuver.setter
    def enable_write_to_first_maneuver(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable_write_to_first_maneuver"](arg_newVal.COM_val))

    @property
    def first_maneuver_segment(self) -> str:
        """The first maneuver segment to manipulate that occurs at the start of the transfer."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_first_maneuver_segment"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @first_maneuver_segment.setter
    def first_maneuver_segment(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_first_maneuver_segment"](arg_newVal.COM_val))

    @property
    def enable_write_duration_to_propagate(self) -> bool:
        """Set this to true to write the Lambert duration of transfer to the 'LambertDuration' stopping condition in the linked propagate segment."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable_write_duration_to_propagate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable_write_duration_to_propagate.setter
    def enable_write_duration_to_propagate(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable_write_duration_to_propagate"](arg_newVal.COM_val))

    @property
    def disable_non_lambert_propagate_stop_conditions(self) -> bool:
        """Set this to true to disable all non-LambertDuration stopping conditions in the propagate segment."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_disable_non_lambert_propagate_stop_conditions"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @disable_non_lambert_propagate_stop_conditions.setter
    def disable_non_lambert_propagate_stop_conditions(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_disable_non_lambert_propagate_stop_conditions"](arg_newVal.COM_val))

    @property
    def propagate_segment(self) -> str:
        """This is the propagate segment to manipulate that contains the transfer duration."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_propagate_segment"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @propagate_segment.setter
    def propagate_segment(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_propagate_segment"](arg_newVal.COM_val))

    @property
    def enable_write_to_second_maneuver(self) -> bool:
        """Set this to true to write the Delta-V solution from Lambert at the end of the transfer to the linked maneuver."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable_write_to_second_maneuver"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable_write_to_second_maneuver.setter
    def enable_write_to_second_maneuver(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable_write_to_second_maneuver"](arg_newVal.COM_val))

    @property
    def second_maneuver_segment(self) -> str:
        """This is the second maneuver segment to manipulate that occurs at the end of the transfer."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_second_maneuver_segment"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @second_maneuver_segment.setter
    def second_maneuver_segment(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_second_maneuver_segment"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{6F736B1F-850D-4736-9106-8BDC4FE52A30}", IProfileLambertProfile)
agcls.AgTypeNameMap["IProfileLambertProfile"] = IProfileLambertProfile

class IProfileLambertSearchProfile(IProfile):
    """Properties for a Lambert Search Profile."""
    _uuid = "{22C5891F-AD49-40BE-9C99-58E23CCFD106}"
    _num_methods = 64
    _vtable_offset = IProfile._vtable_offset + IProfile._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_set_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_get_target_coord_type"] = _raise_uninitialized_error
        self.__dict__["_set_target_coord_type"] = _raise_uninitialized_error
        self.__dict__["_get_enable_second_maneuver"] = _raise_uninitialized_error
        self.__dict__["_set_enable_second_maneuver"] = _raise_uninitialized_error
        self.__dict__["_get_enable_target_match_phase"] = _raise_uninitialized_error
        self.__dict__["_set_enable_target_match_phase"] = _raise_uninitialized_error
        self.__dict__["_get_target_position_x"] = _raise_uninitialized_error
        self.__dict__["_set_target_position_x"] = _raise_uninitialized_error
        self.__dict__["_get_target_position_y"] = _raise_uninitialized_error
        self.__dict__["_set_target_position_y"] = _raise_uninitialized_error
        self.__dict__["_get_target_position_z"] = _raise_uninitialized_error
        self.__dict__["_set_target_position_z"] = _raise_uninitialized_error
        self.__dict__["_get_target_velocity_x"] = _raise_uninitialized_error
        self.__dict__["_set_target_velocity_x"] = _raise_uninitialized_error
        self.__dict__["_get_target_velocity_y"] = _raise_uninitialized_error
        self.__dict__["_set_target_velocity_y"] = _raise_uninitialized_error
        self.__dict__["_get_target_velocity_z"] = _raise_uninitialized_error
        self.__dict__["_set_target_velocity_z"] = _raise_uninitialized_error
        self.__dict__["_get_target_semimajor_axis"] = _raise_uninitialized_error
        self.__dict__["_set_target_semimajor_axis"] = _raise_uninitialized_error
        self.__dict__["_get_target_eccentricity"] = _raise_uninitialized_error
        self.__dict__["_set_target_eccentricity"] = _raise_uninitialized_error
        self.__dict__["_get_target_inclination"] = _raise_uninitialized_error
        self.__dict__["_set_target_inclination"] = _raise_uninitialized_error
        self.__dict__["_get_target_right_ascension_of_ascending_node"] = _raise_uninitialized_error
        self.__dict__["_set_target_right_ascension_of_ascending_node"] = _raise_uninitialized_error
        self.__dict__["_get_target_argument_of_periapsis"] = _raise_uninitialized_error
        self.__dict__["_set_target_argument_of_periapsis"] = _raise_uninitialized_error
        self.__dict__["_get_target_true_anomaly"] = _raise_uninitialized_error
        self.__dict__["_set_target_true_anomaly"] = _raise_uninitialized_error
        self.__dict__["_get_enable_write_departure_delay_to_first_propagate"] = _raise_uninitialized_error
        self.__dict__["_set_enable_write_departure_delay_to_first_propagate"] = _raise_uninitialized_error
        self.__dict__["_get_disable_first_propagate_non_lambert_stop_conditions"] = _raise_uninitialized_error
        self.__dict__["_set_disable_first_propagate_non_lambert_stop_conditions"] = _raise_uninitialized_error
        self.__dict__["_get_first_propagate_segment"] = _raise_uninitialized_error
        self.__dict__["_set_first_propagate_segment"] = _raise_uninitialized_error
        self.__dict__["_get_enable_write_to_first_maneuver"] = _raise_uninitialized_error
        self.__dict__["_set_enable_write_to_first_maneuver"] = _raise_uninitialized_error
        self.__dict__["_get_first_maneuver_segment"] = _raise_uninitialized_error
        self.__dict__["_set_first_maneuver_segment"] = _raise_uninitialized_error
        self.__dict__["_get_latest_departure_time"] = _raise_uninitialized_error
        self.__dict__["_set_latest_departure_time"] = _raise_uninitialized_error
        self.__dict__["_get_earliest_arrival_time"] = _raise_uninitialized_error
        self.__dict__["_set_earliest_arrival_time"] = _raise_uninitialized_error
        self.__dict__["_get_latest_arrival_time"] = _raise_uninitialized_error
        self.__dict__["_set_latest_arrival_time"] = _raise_uninitialized_error
        self.__dict__["_get_grid_search_time_step"] = _raise_uninitialized_error
        self.__dict__["_set_grid_search_time_step"] = _raise_uninitialized_error
        self.__dict__["_get_max_revolutions"] = _raise_uninitialized_error
        self.__dict__["_set_max_revolutions"] = _raise_uninitialized_error
        self.__dict__["_get_central_body_collision_altitude_padding"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_collision_altitude_padding"] = _raise_uninitialized_error
        self.__dict__["_get_enable_write_duration_to_second_propagate"] = _raise_uninitialized_error
        self.__dict__["_set_enable_write_duration_to_second_propagate"] = _raise_uninitialized_error
        self.__dict__["_get_disable_second_propagate_non_lambert_stop_conditions"] = _raise_uninitialized_error
        self.__dict__["_set_disable_second_propagate_non_lambert_stop_conditions"] = _raise_uninitialized_error
        self.__dict__["_get_second_propagate_segment"] = _raise_uninitialized_error
        self.__dict__["_set_second_propagate_segment"] = _raise_uninitialized_error
        self.__dict__["_get_enable_write_to_second_maneuver"] = _raise_uninitialized_error
        self.__dict__["_set_enable_write_to_second_maneuver"] = _raise_uninitialized_error
        self.__dict__["_get_second_maneuver_segment"] = _raise_uninitialized_error
        self.__dict__["_set_second_maneuver_segment"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProfileLambertSearchProfile._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProfileLambertSearchProfile from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProfile._private_init(self, pUnk)
        IID_IProfileLambertSearchProfile = agcom.GUID(IProfileLambertSearchProfile._uuid)
        vtable_offset_local = IProfileLambertSearchProfile._vtable_offset - 1
        self.__dict__["_get_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_target_coord_type"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_target_coord_type"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_enable_second_maneuver"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable_second_maneuver"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_get_enable_target_match_phase"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable_target_match_phase"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_get_target_position_x"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_target_position_x"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_target_position_y"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_target_position_y"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_target_position_z"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_target_position_z"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_target_velocity_x"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_target_velocity_x"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_target_velocity_y"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_target_velocity_y"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_target_velocity_z"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_set_target_velocity_z"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_get_target_semimajor_axis"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_set_target_semimajor_axis"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+22, agcom.DOUBLE)
        self.__dict__["_get_target_eccentricity"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+23, POINTER(agcom.DOUBLE))
        self.__dict__["_set_target_eccentricity"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+24, agcom.DOUBLE)
        self.__dict__["_get_target_inclination"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+25, POINTER(agcom.DOUBLE))
        self.__dict__["_set_target_inclination"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+26, agcom.DOUBLE)
        self.__dict__["_get_target_right_ascension_of_ascending_node"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+27, POINTER(agcom.DOUBLE))
        self.__dict__["_set_target_right_ascension_of_ascending_node"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+28, agcom.DOUBLE)
        self.__dict__["_get_target_argument_of_periapsis"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+29, POINTER(agcom.DOUBLE))
        self.__dict__["_set_target_argument_of_periapsis"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+30, agcom.DOUBLE)
        self.__dict__["_get_target_true_anomaly"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+31, POINTER(agcom.DOUBLE))
        self.__dict__["_set_target_true_anomaly"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+32, agcom.DOUBLE)
        self.__dict__["_get_enable_write_departure_delay_to_first_propagate"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+33, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable_write_departure_delay_to_first_propagate"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+34, agcom.VARIANT_BOOL)
        self.__dict__["_get_disable_first_propagate_non_lambert_stop_conditions"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+35, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_disable_first_propagate_non_lambert_stop_conditions"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+36, agcom.VARIANT_BOOL)
        self.__dict__["_get_first_propagate_segment"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+37, POINTER(agcom.BSTR))
        self.__dict__["_set_first_propagate_segment"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+38, agcom.BSTR)
        self.__dict__["_get_enable_write_to_first_maneuver"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+39, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable_write_to_first_maneuver"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+40, agcom.VARIANT_BOOL)
        self.__dict__["_get_first_maneuver_segment"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+41, POINTER(agcom.BSTR))
        self.__dict__["_set_first_maneuver_segment"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+42, agcom.BSTR)
        self.__dict__["_get_latest_departure_time"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+43, POINTER(agcom.DOUBLE))
        self.__dict__["_set_latest_departure_time"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+44, agcom.DOUBLE)
        self.__dict__["_get_earliest_arrival_time"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+45, POINTER(agcom.DOUBLE))
        self.__dict__["_set_earliest_arrival_time"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+46, agcom.DOUBLE)
        self.__dict__["_get_latest_arrival_time"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+47, POINTER(agcom.DOUBLE))
        self.__dict__["_set_latest_arrival_time"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+48, agcom.DOUBLE)
        self.__dict__["_get_grid_search_time_step"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+49, POINTER(agcom.DOUBLE))
        self.__dict__["_set_grid_search_time_step"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+50, agcom.DOUBLE)
        self.__dict__["_get_max_revolutions"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+51, POINTER(agcom.LONG))
        self.__dict__["_set_max_revolutions"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+52, agcom.LONG)
        self.__dict__["_get_central_body_collision_altitude_padding"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+53, POINTER(agcom.DOUBLE))
        self.__dict__["_set_central_body_collision_altitude_padding"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+54, agcom.DOUBLE)
        self.__dict__["_get_enable_write_duration_to_second_propagate"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+55, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable_write_duration_to_second_propagate"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+56, agcom.VARIANT_BOOL)
        self.__dict__["_get_disable_second_propagate_non_lambert_stop_conditions"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+57, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_disable_second_propagate_non_lambert_stop_conditions"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+58, agcom.VARIANT_BOOL)
        self.__dict__["_get_second_propagate_segment"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+59, POINTER(agcom.BSTR))
        self.__dict__["_set_second_propagate_segment"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+60, agcom.BSTR)
        self.__dict__["_get_enable_write_to_second_maneuver"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+61, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable_write_to_second_maneuver"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+62, agcom.VARIANT_BOOL)
        self.__dict__["_get_second_maneuver_segment"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+63, POINTER(agcom.BSTR))
        self.__dict__["_set_second_maneuver_segment"] = IAGFUNCTYPE(pUnk, IID_IProfileLambertSearchProfile, vtable_offset_local+64, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProfileLambertSearchProfile.__dict__ and type(IProfileLambertSearchProfile.__dict__[attrname]) == property:
            return IProfileLambertSearchProfile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IProfile.__setattr__(self, attrname, value)
    
    @property
    def coord_system_name(self) -> str:
        """The coordinate system."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_system_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_system_name.setter
    def coord_system_name(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_system_name"](arg_newVal.COM_val))

    @property
    def target_coord_type(self) -> "AgEVALambertTargetCoordType":
        """The target coordinate type."""
        with agmarshall.AgEnum_arg(AgEVALambertTargetCoordType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_coord_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_target_coord_type(self, elementType:"AgEVALambertTargetCoordType") -> None:
        """Selects a target coordinate type."""
        with agmarshall.AgEnum_arg(AgEVALambertTargetCoordType, elementType) as arg_elementType:
            agcls.evaluate_hresult(self.__dict__["_set_target_coord_type"](arg_elementType.COM_val))

    @property
    def enable_second_maneuver(self) -> bool:
        """Enable to calculate second maneuver at destination."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable_second_maneuver"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable_second_maneuver.setter
    def enable_second_maneuver(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable_second_maneuver"](arg_newVal.COM_val))

    @property
    def enable_target_match_phase(self) -> bool:
        """Set this to true if the satellite should match the phase of the orbit at the target."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable_target_match_phase"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable_target_match_phase.setter
    def enable_target_match_phase(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable_target_match_phase"](arg_newVal.COM_val))

    @property
    def target_position_x(self) -> float:
        """The X component of the target position for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_position_x"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_position_x.setter
    def target_position_x(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_position_x"](arg_newVal.COM_val))

    @property
    def target_position_y(self) -> float:
        """The Y component of the target position for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_position_y"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_position_y.setter
    def target_position_y(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_position_y"](arg_newVal.COM_val))

    @property
    def target_position_z(self) -> float:
        """The Z component of the target position for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_position_z"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_position_z.setter
    def target_position_z(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_position_z"](arg_newVal.COM_val))

    @property
    def target_velocity_x(self) -> float:
        """The X component of the target velocity for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_velocity_x"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_velocity_x.setter
    def target_velocity_x(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_velocity_x"](arg_newVal.COM_val))

    @property
    def target_velocity_y(self) -> float:
        """The Y component of the target velocity for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_velocity_y"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_velocity_y.setter
    def target_velocity_y(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_velocity_y"](arg_newVal.COM_val))

    @property
    def target_velocity_z(self) -> float:
        """The Z component of the target velocity for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_velocity_z"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_velocity_z.setter
    def target_velocity_z(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_velocity_z"](arg_newVal.COM_val))

    @property
    def target_semimajor_axis(self) -> float:
        """The target semimajor axis for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_semimajor_axis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_semimajor_axis.setter
    def target_semimajor_axis(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_semimajor_axis"](arg_newVal.COM_val))

    @property
    def target_eccentricity(self) -> float:
        """The target eccentricity for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_eccentricity"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_eccentricity.setter
    def target_eccentricity(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_eccentricity"](arg_newVal.COM_val))

    @property
    def target_inclination(self) -> float:
        """The target inclination for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_inclination"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_inclination.setter
    def target_inclination(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_inclination"](arg_newVal.COM_val))

    @property
    def target_right_ascension_of_ascending_node(self) -> float:
        """The target right ascension of the ascending node for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_right_ascension_of_ascending_node"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_right_ascension_of_ascending_node.setter
    def target_right_ascension_of_ascending_node(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_right_ascension_of_ascending_node"](arg_newVal.COM_val))

    @property
    def target_argument_of_periapsis(self) -> float:
        """The target argument of periapsis for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_argument_of_periapsis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_argument_of_periapsis.setter
    def target_argument_of_periapsis(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_argument_of_periapsis"](arg_newVal.COM_val))

    @property
    def target_true_anomaly(self) -> float:
        """The target true anomaly for the end of the Lambert transfer."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_true_anomaly"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_true_anomaly.setter
    def target_true_anomaly(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_true_anomaly"](arg_newVal.COM_val))

    @property
    def enable_write_departure_delay_to_first_propagate(self) -> bool:
        """Set this to true to write the departure delay duration before the Lambert transfer to the 'LambertDuration' stopping condition in the first linked propagate segment."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable_write_departure_delay_to_first_propagate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable_write_departure_delay_to_first_propagate.setter
    def enable_write_departure_delay_to_first_propagate(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable_write_departure_delay_to_first_propagate"](arg_newVal.COM_val))

    @property
    def disable_first_propagate_non_lambert_stop_conditions(self) -> bool:
        """Set this to true to disable all non-LambertDuration stopping conditions in the first propagate segment."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_disable_first_propagate_non_lambert_stop_conditions"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @disable_first_propagate_non_lambert_stop_conditions.setter
    def disable_first_propagate_non_lambert_stop_conditions(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_disable_first_propagate_non_lambert_stop_conditions"](arg_newVal.COM_val))

    @property
    def first_propagate_segment(self) -> str:
        """This is the propagate segment to manipulate that contains the departure delay."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_first_propagate_segment"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @first_propagate_segment.setter
    def first_propagate_segment(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_first_propagate_segment"](arg_newVal.COM_val))

    @property
    def enable_write_to_first_maneuver(self) -> bool:
        """et this to true to write the Delta-V solution from Lambert at the start of the transfer to the linked maneuver."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable_write_to_first_maneuver"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable_write_to_first_maneuver.setter
    def enable_write_to_first_maneuver(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable_write_to_first_maneuver"](arg_newVal.COM_val))

    @property
    def first_maneuver_segment(self) -> str:
        """This is the first maneuver segment to manipulate that occurs at the start of the transfer. It is visible when you select Write Initial Inertial Delta-V to Maneuver."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_first_maneuver_segment"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @first_maneuver_segment.setter
    def first_maneuver_segment(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_first_maneuver_segment"](arg_newVal.COM_val))

    @property
    def latest_departure_time(self) -> float:
        """This is the latest time from the start of the target sequence for the first Lambert maneuver to occur."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_latest_departure_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @latest_departure_time.setter
    def latest_departure_time(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_latest_departure_time"](arg_newVal.COM_val))

    @property
    def earliest_arrival_time(self) -> float:
        """This is the earliest time from the start of the target sequence that the satellite should arrive at its destination."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_earliest_arrival_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @earliest_arrival_time.setter
    def earliest_arrival_time(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_earliest_arrival_time"](arg_newVal.COM_val))

    @property
    def latest_arrival_time(self) -> float:
        """This is the latest time from the start of the target sequence that the satellite should arrive at its destination."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_latest_arrival_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @latest_arrival_time.setter
    def latest_arrival_time(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_latest_arrival_time"](arg_newVal.COM_val))

    @property
    def grid_search_time_step(self) -> float:
        """This is the time step between Lambert evaluations for searching over both the departure window and arrival window of time."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_grid_search_time_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @grid_search_time_step.setter
    def grid_search_time_step(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_grid_search_time_step"](arg_newVal.COM_val))

    @property
    def max_revolutions(self) -> int:
        """This is the maximum number of revolutions for the Lambert solution."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_revolutions"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_revolutions.setter
    def max_revolutions(self, newVal:int) -> None:
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_revolutions"](arg_newVal.COM_val))

    @property
    def central_body_collision_altitude_padding(self) -> float:
        """The minimum altitude below which the Lambert algorithm will consider the spacecraft to have hit the central body."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_collision_altitude_padding"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_collision_altitude_padding.setter
    def central_body_collision_altitude_padding(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_collision_altitude_padding"](arg_newVal.COM_val))

    @property
    def enable_write_duration_to_second_propagate(self) -> bool:
        """Set this to true to write the Lambert duration of transfer to the 'LambertDuration' stopping condition in the second linked propagate segment."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable_write_duration_to_second_propagate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable_write_duration_to_second_propagate.setter
    def enable_write_duration_to_second_propagate(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable_write_duration_to_second_propagate"](arg_newVal.COM_val))

    @property
    def disable_second_propagate_non_lambert_stop_conditions(self) -> bool:
        """Set this to true to disable all non-LambertDuration stopping conditions in the second propagate segment. This is visible when you select Write Flight Duration to Second Propagate."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_disable_second_propagate_non_lambert_stop_conditions"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @disable_second_propagate_non_lambert_stop_conditions.setter
    def disable_second_propagate_non_lambert_stop_conditions(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_disable_second_propagate_non_lambert_stop_conditions"](arg_newVal.COM_val))

    @property
    def second_propagate_segment(self) -> str:
        """This is the propagate segment to manipulate that contains the transfer duration. It is visible when you select Write Flight Duration to Second Propagate."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_second_propagate_segment"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @second_propagate_segment.setter
    def second_propagate_segment(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_second_propagate_segment"](arg_newVal.COM_val))

    @property
    def enable_write_to_second_maneuver(self) -> bool:
        """Set this to true to write the Delta-V solution from Lambert at the end of the transfer to the linked maneuver. It is visible when you select Calculate Second Maneuver At Destination ."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable_write_to_second_maneuver"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable_write_to_second_maneuver.setter
    def enable_write_to_second_maneuver(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable_write_to_second_maneuver"](arg_newVal.COM_val))

    @property
    def second_maneuver_segment(self) -> str:
        """This is the second maneuver segment to manipulate that occurs at the end of the transfer. It is visible when you select Write Final Inertial Delta-V to Maneuver."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_second_maneuver_segment"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @second_maneuver_segment.setter
    def second_maneuver_segment(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_second_maneuver_segment"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{22C5891F-AD49-40BE-9C99-58E23CCFD106}", IProfileLambertSearchProfile)
agcls.AgTypeNameMap["IProfileLambertSearchProfile"] = IProfileLambertSearchProfile

class IProfileGoldenSection(IProfile):
    """Properties for a Golden Section profile."""
    _uuid = "{505EC87D-BE26-4477-B7E8-6586731428D0}"
    _num_methods = 9
    _vtable_offset = IProfile._vtable_offset + IProfile._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_targeter_graphs"] = _raise_uninitialized_error
        self.__dict__["_get_scripting_tool"] = _raise_uninitialized_error
        self.__dict__["_get_controls"] = _raise_uninitialized_error
        self.__dict__["_get_results"] = _raise_uninitialized_error
        self.__dict__["_get_max_iterations"] = _raise_uninitialized_error
        self.__dict__["_set_max_iterations"] = _raise_uninitialized_error
        self.__dict__["_get_log_file"] = _raise_uninitialized_error
        self.__dict__["_get_enable_display_status"] = _raise_uninitialized_error
        self.__dict__["_set_enable_display_status"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProfileGoldenSection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProfileGoldenSection from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProfile._private_init(self, pUnk)
        IID_IProfileGoldenSection = agcom.GUID(IProfileGoldenSection._uuid)
        vtable_offset_local = IProfileGoldenSection._vtable_offset - 1
        self.__dict__["_get_targeter_graphs"] = IAGFUNCTYPE(pUnk, IID_IProfileGoldenSection, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_scripting_tool"] = IAGFUNCTYPE(pUnk, IID_IProfileGoldenSection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_controls"] = IAGFUNCTYPE(pUnk, IID_IProfileGoldenSection, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_results"] = IAGFUNCTYPE(pUnk, IID_IProfileGoldenSection, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_max_iterations"] = IAGFUNCTYPE(pUnk, IID_IProfileGoldenSection, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_max_iterations"] = IAGFUNCTYPE(pUnk, IID_IProfileGoldenSection, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_log_file"] = IAGFUNCTYPE(pUnk, IID_IProfileGoldenSection, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_get_enable_display_status"] = IAGFUNCTYPE(pUnk, IID_IProfileGoldenSection, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable_display_status"] = IAGFUNCTYPE(pUnk, IID_IProfileGoldenSection, vtable_offset_local+9, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProfileGoldenSection.__dict__ and type(IProfileGoldenSection.__dict__[attrname]) == property:
            return IProfileGoldenSection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IProfile.__setattr__(self, attrname, value)
    
    @property
    def targeter_graphs(self) -> "ITargeterGraphCollection":
        """Graphs"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_targeter_graphs"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def scripting_tool(self) -> "IScriptingTool":
        """Returns the Scripting tool for the sequence."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_scripting_tool"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def controls(self) -> "IGoldenSectionControlCollection":
        """The list of control parameters defined for the profile."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAGoldenSectionControlCollection:
            agcls.evaluate_hresult(self.__dict__["_get_controls"](byref(arg_ppVAGoldenSectionControlCollection.COM_val)))
            return arg_ppVAGoldenSectionControlCollection.python_val

    @property
    def results(self) -> "IGoldenSectionResultCollection":
        """The list of results defined for the profile."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAGoldenSectionResultCollection:
            agcls.evaluate_hresult(self.__dict__["_get_results"](byref(arg_ppVAGoldenSectionResultCollection.COM_val)))
            return arg_ppVAGoldenSectionResultCollection.python_val

    @property
    def max_iterations(self) -> int:
        """The number of complete iterations of the profile to try before stopping. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_iterations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_iterations.setter
    def max_iterations(self, newVal:int) -> None:
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_iterations"](arg_newVal.COM_val))

    @property
    def log_file(self) -> str:
        """Name of the log file for this profile."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_log_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def enable_display_status(self) -> bool:
        """If true, a page will appear during the targeting run to report the status of the targeting effort in terms of proximity to the desired value for each dependent variable in the profile."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable_display_status"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable_display_status.setter
    def enable_display_status(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable_display_status"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{505EC87D-BE26-4477-B7E8-6586731428D0}", IProfileGoldenSection)
agcls.AgTypeNameMap["IProfileGoldenSection"] = IProfileGoldenSection

class IProfileGridSearch(IProfile):
    """Properties for a Grid Search profile."""
    _uuid = "{EDE96C58-0563-4B05-A7B6-735C3699FE87}"
    _num_methods = 9
    _vtable_offset = IProfile._vtable_offset + IProfile._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_targeter_graphs"] = _raise_uninitialized_error
        self.__dict__["_get_scripting_tool"] = _raise_uninitialized_error
        self.__dict__["_get_controls"] = _raise_uninitialized_error
        self.__dict__["_get_results"] = _raise_uninitialized_error
        self.__dict__["_get_log_file"] = _raise_uninitialized_error
        self.__dict__["_get_enable_display_status"] = _raise_uninitialized_error
        self.__dict__["_set_enable_display_status"] = _raise_uninitialized_error
        self.__dict__["_get_should_generate_graph"] = _raise_uninitialized_error
        self.__dict__["_set_should_generate_graph"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProfileGridSearch._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProfileGridSearch from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProfile._private_init(self, pUnk)
        IID_IProfileGridSearch = agcom.GUID(IProfileGridSearch._uuid)
        vtable_offset_local = IProfileGridSearch._vtable_offset - 1
        self.__dict__["_get_targeter_graphs"] = IAGFUNCTYPE(pUnk, IID_IProfileGridSearch, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_scripting_tool"] = IAGFUNCTYPE(pUnk, IID_IProfileGridSearch, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_controls"] = IAGFUNCTYPE(pUnk, IID_IProfileGridSearch, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_results"] = IAGFUNCTYPE(pUnk, IID_IProfileGridSearch, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_log_file"] = IAGFUNCTYPE(pUnk, IID_IProfileGridSearch, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_get_enable_display_status"] = IAGFUNCTYPE(pUnk, IID_IProfileGridSearch, vtable_offset_local+6, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable_display_status"] = IAGFUNCTYPE(pUnk, IID_IProfileGridSearch, vtable_offset_local+7, agcom.VARIANT_BOOL)
        self.__dict__["_get_should_generate_graph"] = IAGFUNCTYPE(pUnk, IID_IProfileGridSearch, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_should_generate_graph"] = IAGFUNCTYPE(pUnk, IID_IProfileGridSearch, vtable_offset_local+9, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProfileGridSearch.__dict__ and type(IProfileGridSearch.__dict__[attrname]) == property:
            return IProfileGridSearch.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IProfile.__setattr__(self, attrname, value)
    
    @property
    def targeter_graphs(self) -> "ITargeterGraphCollection":
        """Graphs"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_targeter_graphs"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def scripting_tool(self) -> "IScriptingTool":
        """Returns the Scripting tool for the sequence."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_scripting_tool"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def controls(self) -> "IGridSearchControlCollection":
        """The list of control parameters defined for the profile."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAGridSearchControlCollection:
            agcls.evaluate_hresult(self.__dict__["_get_controls"](byref(arg_ppVAGridSearchControlCollection.COM_val)))
            return arg_ppVAGridSearchControlCollection.python_val

    @property
    def results(self) -> "IGridSearchResultCollection":
        """The list of results defined for the profile."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAGridSearchResultCollection:
            agcls.evaluate_hresult(self.__dict__["_get_results"](byref(arg_ppVAGridSearchResultCollection.COM_val)))
            return arg_ppVAGridSearchResultCollection.python_val

    @property
    def log_file(self) -> str:
        """Name of the log file for this profile."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_log_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def enable_display_status(self) -> bool:
        """If true, a page will appear during the targeting run to report the status of the targeting effort in terms of proximity to the desired value for each dependent variable in the profile."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable_display_status"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable_display_status.setter
    def enable_display_status(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable_display_status"](arg_newVal.COM_val))

    @property
    def should_generate_graph(self) -> bool:
        """If true, a plot is automatically generate the selected result value versus the control value for the grid search when the profile runs."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_should_generate_graph"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @should_generate_graph.setter
    def should_generate_graph(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_should_generate_graph"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{EDE96C58-0563-4B05-A7B6-735C3699FE87}", IProfileGridSearch)
agcls.AgTypeNameMap["IProfileGridSearch"] = IProfileGridSearch

class ICalcObjectLinkEmbedControlCollection(object):
    """Collection of link/embed calculation objects."""
    _uuid = "{4294354A-2EF8-4D34-8FC9-DD360DFCF3EF}"
    _num_methods = 10
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_add"] = _raise_uninitialized_error
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_remove"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_cut"] = _raise_uninitialized_error
        self.__dict__["_paste"] = _raise_uninitialized_error
        self.__dict__["_insert_copy"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_index"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICalcObjectLinkEmbedControlCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICalcObjectLinkEmbedControlCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICalcObjectLinkEmbedControlCollection = agcom.GUID(ICalcObjectLinkEmbedControlCollection._uuid)
        vtable_offset_local = ICalcObjectLinkEmbedControlCollection._vtable_offset - 1
        self.__dict__["_add"] = IAGFUNCTYPE(pUnk, IID_ICalcObjectLinkEmbedControlCollection, vtable_offset_local+1, agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID))
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_ICalcObjectLinkEmbedControlCollection, vtable_offset_local+2, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_remove"] = IAGFUNCTYPE(pUnk, IID_ICalcObjectLinkEmbedControlCollection, vtable_offset_local+3, agcom.VARIANT)
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_ICalcObjectLinkEmbedControlCollection, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_ICalcObjectLinkEmbedControlCollection, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_cut"] = IAGFUNCTYPE(pUnk, IID_ICalcObjectLinkEmbedControlCollection, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_paste"] = IAGFUNCTYPE(pUnk, IID_ICalcObjectLinkEmbedControlCollection, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_insert_copy"] = IAGFUNCTYPE(pUnk, IID_ICalcObjectLinkEmbedControlCollection, vtable_offset_local+8, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_get_item_by_index"] = IAGFUNCTYPE(pUnk, IID_ICalcObjectLinkEmbedControlCollection, vtable_offset_local+9, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_get_item_by_name"] = IAGFUNCTYPE(pUnk, IID_ICalcObjectLinkEmbedControlCollection, vtable_offset_local+10, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICalcObjectLinkEmbedControlCollection.__dict__ and type(ICalcObjectLinkEmbedControlCollection.__dict__[attrname]) == property:
            return ICalcObjectLinkEmbedControlCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICalcObjectLinkEmbedControlCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IComponentLinkEmbedControl":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def add(self, name:str, refType:"AgEComponentLinkEmbedControlReferenceType") -> "IComponentLinkEmbedControl":
        """Adds a link/embed calc object to the collection."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgEnum_arg(AgEComponentLinkEmbedControlReferenceType, refType) as arg_refType, \
             agmarshall.AgInterface_out_arg() as arg_ppComponentLinkEmbedControl:
            agcls.evaluate_hresult(self.__dict__["_add"](arg_name.COM_val, arg_refType.COM_val, byref(arg_ppComponentLinkEmbedControl.COM_val)))
            return arg_ppComponentLinkEmbedControl.python_val

    def item(self, indexOrName:typing.Any) -> "IComponentLinkEmbedControl":
        """Returns a link/embed calc object."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppComponentLinkEmbedControl:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_indexOrName.COM_val, byref(arg_ppComponentLinkEmbedControl.COM_val)))
            return arg_ppComponentLinkEmbedControl.python_val

    def remove(self, indexOrName:typing.Any) -> None:
        """Removes a link/embed calc object from the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_remove"](arg_indexOrName.COM_val))

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def cut(self, indexOrName:typing.Any) -> None:
        """Copies a link/embed calc object to the clipboard and removes the calc object from the list."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_cut"](arg_indexOrName.COM_val))

    def paste(self) -> "IComponentLinkEmbedControl":
        """Pastes a link/embed calc object from the clipboard into the list."""
        with agmarshall.AgInterface_out_arg() as arg_ppCalcObj:
            agcls.evaluate_hresult(self.__dict__["_paste"](byref(arg_ppCalcObj.COM_val)))
            return arg_ppCalcObj.python_val

    def insert_copy(self, calcObj:"IComponentLinkEmbedControl") -> "IComponentLinkEmbedControl":
        """Copies a link/embed calc object and inserts the copy into the list."""
        with agmarshall.AgInterface_in_arg(calcObj, IComponentLinkEmbedControl) as arg_calcObj, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_insert_copy"](arg_calcObj.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def get_item_by_index(self, index:int) -> "IComponentLinkEmbedControl":
        """Retrieves a link/embed calc object found by the index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppComponent:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_index"](arg_index.COM_val, byref(arg_ppComponent.COM_val)))
            return arg_ppComponent.python_val

    def get_item_by_name(self, name:str) -> "IComponentLinkEmbedControl":
        """Retrieves a link/embed calc object found by the name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppComponent:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_name"](arg_name.COM_val, byref(arg_ppComponent.COM_val)))
            return arg_ppComponent.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{4294354A-2EF8-4D34-8FC9-DD360DFCF3EF}", ICalcObjectLinkEmbedControlCollection)
agcls.AgTypeNameMap["ICalcObjectLinkEmbedControlCollection"] = ICalcObjectLinkEmbedControlCollection

class IProfileBisection(IProfile):
    """Properties of Single Parameter Bisection profile."""
    _uuid = "{F0B2CF95-1CC9-4394-9A19-00FF41B8E0FC}"
    _num_methods = 8
    _vtable_offset = IProfile._vtable_offset + IProfile._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_control_parameters"] = _raise_uninitialized_error
        self.__dict__["_get_results"] = _raise_uninitialized_error
        self.__dict__["_get_targeter_graphs"] = _raise_uninitialized_error
        self.__dict__["_get_scripting_tool"] = _raise_uninitialized_error
        self.__dict__["_get_reset_controls_before_run"] = _raise_uninitialized_error
        self.__dict__["_set_reset_controls_before_run"] = _raise_uninitialized_error
        self.__dict__["_get_maximum_iterations"] = _raise_uninitialized_error
        self.__dict__["_set_maximum_iterations"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IProfileBisection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IProfileBisection from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProfile._private_init(self, pUnk)
        IID_IProfileBisection = agcom.GUID(IProfileBisection._uuid)
        vtable_offset_local = IProfileBisection._vtable_offset - 1
        self.__dict__["_get_control_parameters"] = IAGFUNCTYPE(pUnk, IID_IProfileBisection, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_results"] = IAGFUNCTYPE(pUnk, IID_IProfileBisection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_targeter_graphs"] = IAGFUNCTYPE(pUnk, IID_IProfileBisection, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_scripting_tool"] = IAGFUNCTYPE(pUnk, IID_IProfileBisection, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_reset_controls_before_run"] = IAGFUNCTYPE(pUnk, IID_IProfileBisection, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_reset_controls_before_run"] = IAGFUNCTYPE(pUnk, IID_IProfileBisection, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_get_maximum_iterations"] = IAGFUNCTYPE(pUnk, IID_IProfileBisection, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_maximum_iterations"] = IAGFUNCTYPE(pUnk, IID_IProfileBisection, vtable_offset_local+8, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IProfileBisection.__dict__ and type(IProfileBisection.__dict__[attrname]) == property:
            return IProfileBisection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            IProfile.__setattr__(self, attrname, value)
    
    @property
    def control_parameters(self) -> "IBisectionControlCollection":
        """The list of control parameters defined for the profile."""
        with agmarshall.AgInterface_out_arg() as arg_ppVABisectionControlCollection:
            agcls.evaluate_hresult(self.__dict__["_get_control_parameters"](byref(arg_ppVABisectionControlCollection.COM_val)))
            return arg_ppVABisectionControlCollection.python_val

    @property
    def results(self) -> "IBisectionResultCollection":
        """The list of results defined for the profile."""
        with agmarshall.AgInterface_out_arg() as arg_ppVABisectionResultCollection:
            agcls.evaluate_hresult(self.__dict__["_get_results"](byref(arg_ppVABisectionResultCollection.COM_val)))
            return arg_ppVABisectionResultCollection.python_val

    @property
    def targeter_graphs(self) -> "ITargeterGraphCollection":
        """Graphs"""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_targeter_graphs"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def scripting_tool(self) -> "IScriptingTool":
        """Returns the Scripting tool for the sequence."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_scripting_tool"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def reset_controls_before_run(self) -> bool:
        """Reset controls before each run."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reset_controls_before_run"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reset_controls_before_run.setter
    def reset_controls_before_run(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_reset_controls_before_run"](arg_newVal.COM_val))

    @property
    def maximum_iterations(self) -> int:
        """The maximum number of iterations allowed."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_maximum_iterations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @maximum_iterations.setter
    def maximum_iterations(self, newVal:int) -> None:
        with agmarshall.LONG_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_maximum_iterations"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{F0B2CF95-1CC9-4394-9A19-00FF41B8E0FC}", IProfileBisection)
agcls.AgTypeNameMap["IProfileBisection"] = IProfileBisection

class IBisectionControl(object):
    """Properties for control parameters of a Bisection Search profile."""
    _uuid = "{F60B718A-09E3-4C6B-A05D-3562CFB5EF4E}"
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_enable"] = _raise_uninitialized_error
        self.__dict__["_set_enable"] = _raise_uninitialized_error
        self.__dict__["_get_name"] = _raise_uninitialized_error
        self.__dict__["_get_parent_name"] = _raise_uninitialized_error
        self.__dict__["_get_initial_value"] = _raise_uninitialized_error
        self.__dict__["_get_current_value"] = _raise_uninitialized_error
        self.__dict__["_set_current_value"] = _raise_uninitialized_error
        self.__dict__["_get_bound_search_step"] = _raise_uninitialized_error
        self.__dict__["_set_bound_search_step"] = _raise_uninitialized_error
        self.__dict__["_get_use_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_set_use_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_get_custom_display_unit"] = _raise_uninitialized_error
        self.__dict__["_set_custom_display_unit"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBisectionControl._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBisectionControl from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBisectionControl = agcom.GUID(IBisectionControl._uuid)
        vtable_offset_local = IBisectionControl._vtable_offset - 1
        self.__dict__["_get_enable"] = IAGFUNCTYPE(pUnk, IID_IBisectionControl, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_enable"] = IAGFUNCTYPE(pUnk, IID_IBisectionControl, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_name"] = IAGFUNCTYPE(pUnk, IID_IBisectionControl, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_get_parent_name"] = IAGFUNCTYPE(pUnk, IID_IBisectionControl, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_get_initial_value"] = IAGFUNCTYPE(pUnk, IID_IBisectionControl, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_get_current_value"] = IAGFUNCTYPE(pUnk, IID_IBisectionControl, vtable_offset_local+6, POINTER(agcom.VARIANT))
        self.__dict__["_set_current_value"] = IAGFUNCTYPE(pUnk, IID_IBisectionControl, vtable_offset_local+7, agcom.VARIANT)
        self.__dict__["_get_bound_search_step"] = IAGFUNCTYPE(pUnk, IID_IBisectionControl, vtable_offset_local+8, POINTER(agcom.VARIANT))
        self.__dict__["_set_bound_search_step"] = IAGFUNCTYPE(pUnk, IID_IBisectionControl, vtable_offset_local+9, agcom.VARIANT)
        self.__dict__["_get_use_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IBisectionControl, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IBisectionControl, vtable_offset_local+11, agcom.VARIANT_BOOL)
        self.__dict__["_get_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IBisectionControl, vtable_offset_local+12, POINTER(agcom.BSTR))
        self.__dict__["_set_custom_display_unit"] = IAGFUNCTYPE(pUnk, IID_IBisectionControl, vtable_offset_local+13, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBisectionControl.__dict__ and type(IBisectionControl.__dict__[attrname]) == property:
            return IBisectionControl.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBisectionControl.")
    
    @property
    def enable(self) -> bool:
        """If true, the variable is being used."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_enable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @enable.setter
    def enable(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_enable"](arg_newVal.COM_val))

    @property
    def name(self) -> str:
        """The name of the parameter."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def parent_name(self) -> str:
        """The name of the segment to which the parameter belongs."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_parent_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def initial_value(self) -> typing.Any:
        """The nominal value of the element selected as a parameter. Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_initial_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def current_value(self) -> typing.Any:
        """The value of the independent variable after the last targeter run."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_current_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @current_value.setter
    def current_value(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_current_value"](arg_newVal.COM_val))

    @property
    def bound_search_step(self) -> typing.Any:
        """Dimension depends on context."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_bound_search_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @bound_search_step.setter
    def bound_search_step(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_bound_search_step"](arg_newVal.COM_val))

    @property
    def use_custom_display_unit(self) -> bool:
        """If true, allows display of values in another unit."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_custom_display_unit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_custom_display_unit.setter
    def use_custom_display_unit(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_custom_display_unit"](arg_newVal.COM_val))

    @property
    def custom_display_unit(self) -> str:
        """The unit in which the value will be displayed in the GUI."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_custom_display_unit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @custom_display_unit.setter
    def custom_display_unit(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_custom_display_unit"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{F60B718A-09E3-4C6B-A05D-3562CFB5EF4E}", IBisectionControl)
agcls.AgTypeNameMap["IBisectionControl"] = IBisectionControl

class IStateCalcHeightAboveTerrain(object):
    """Interface for StateCalcHeightAboveTerrain"""
    _uuid = "{30A4FAC3-1250-456A-BB29-689AA50F8D75}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcHeightAboveTerrain._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcHeightAboveTerrain from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcHeightAboveTerrain = agcom.GUID(IStateCalcHeightAboveTerrain._uuid)
        vtable_offset_local = IStateCalcHeightAboveTerrain._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcHeightAboveTerrain, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcHeightAboveTerrain, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcHeightAboveTerrain.__dict__ and type(IStateCalcHeightAboveTerrain.__dict__[attrname]) == property:
            return IStateCalcHeightAboveTerrain.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcHeightAboveTerrain.")
    
    @property
    def central_body_name(self) -> str:
        """Central Body used for calculation"""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        """Central Body used for calculation"""
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{30A4FAC3-1250-456A-BB29-689AA50F8D75}", IStateCalcHeightAboveTerrain)
agcls.AgTypeNameMap["IStateCalcHeightAboveTerrain"] = IStateCalcHeightAboveTerrain

class IStateCalcEpoch(object):
    """Properties for an Epoch calculation object."""
    _uuid = "{F23ADE47-91EF-41B9-9606-DA034C50F69D}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcEpoch._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcEpoch from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcEpoch = agcom.GUID(IStateCalcEpoch._uuid)
        vtable_offset_local = IStateCalcEpoch._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcEpoch.__dict__ and type(IStateCalcEpoch.__dict__[attrname]) == property:
            return IStateCalcEpoch.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcEpoch.")
    

agcls.AgClassCatalog.add_catalog_entry("{F23ADE47-91EF-41B9-9606-DA034C50F69D}", IStateCalcEpoch)
agcls.AgTypeNameMap["IStateCalcEpoch"] = IStateCalcEpoch

class IStateCalcOrbitDelaunayG(object):
    """Interface for AsStateCalcOrbitDelaunayG"""
    _uuid = "{8527A30E-E743-4040-8B0D-7AE1EB237279}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_element_type"] = _raise_uninitialized_error
        self.__dict__["_set_element_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcOrbitDelaunayG._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcOrbitDelaunayG from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcOrbitDelaunayG = agcom.GUID(IStateCalcOrbitDelaunayG._uuid)
        vtable_offset_local = IStateCalcOrbitDelaunayG._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitDelaunayG, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitDelaunayG, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitDelaunayG, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitDelaunayG, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcOrbitDelaunayG.__dict__ and type(IStateCalcOrbitDelaunayG.__dict__[attrname]) == property:
            return IStateCalcOrbitDelaunayG.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcOrbitDelaunayG.")
    
    @property
    def central_body_name(self) -> str:
        """Central Body used for calculation"""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        """Central Body used for calculation"""
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def element_type(self) -> "AgEVAElement":
        """Choice of osculating or mean elements"""
        with agmarshall.AgEnum_arg(AgEVAElement) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_element_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @element_type.setter
    def element_type(self, inVal:"AgEVAElement") -> None:
        """Choice of osculating or mean elements"""
        with agmarshall.AgEnum_arg(AgEVAElement, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_element_type"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{8527A30E-E743-4040-8B0D-7AE1EB237279}", IStateCalcOrbitDelaunayG)
agcls.AgTypeNameMap["IStateCalcOrbitDelaunayG"] = IStateCalcOrbitDelaunayG

class IStateCalcOrbitDelaunayH(object):
    """Interface for AsStateCalcOrbitDelaunayH"""
    _uuid = "{01E122E4-2B6D-4301-81D2-B83B6C169CB5}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_element_type"] = _raise_uninitialized_error
        self.__dict__["_set_element_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcOrbitDelaunayH._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcOrbitDelaunayH from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcOrbitDelaunayH = agcom.GUID(IStateCalcOrbitDelaunayH._uuid)
        vtable_offset_local = IStateCalcOrbitDelaunayH._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitDelaunayH, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitDelaunayH, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitDelaunayH, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitDelaunayH, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcOrbitDelaunayH.__dict__ and type(IStateCalcOrbitDelaunayH.__dict__[attrname]) == property:
            return IStateCalcOrbitDelaunayH.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcOrbitDelaunayH.")
    
    @property
    def central_body_name(self) -> str:
        """Central Body used for calculation"""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        """Central Body used for calculation"""
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def element_type(self) -> "AgEVAElement":
        """Choice of osculating or mean elements"""
        with agmarshall.AgEnum_arg(AgEVAElement) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_element_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @element_type.setter
    def element_type(self, inVal:"AgEVAElement") -> None:
        """Choice of osculating or mean elements"""
        with agmarshall.AgEnum_arg(AgEVAElement, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_element_type"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{01E122E4-2B6D-4301-81D2-B83B6C169CB5}", IStateCalcOrbitDelaunayH)
agcls.AgTypeNameMap["IStateCalcOrbitDelaunayH"] = IStateCalcOrbitDelaunayH

class IStateCalcOrbitDelaunayL(object):
    """Interface for AsStateCalcOrbitDelaunayL"""
    _uuid = "{10C517CA-1CF0-45FF-B36E-3E3181269745}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_element_type"] = _raise_uninitialized_error
        self.__dict__["_set_element_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcOrbitDelaunayL._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcOrbitDelaunayL from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcOrbitDelaunayL = agcom.GUID(IStateCalcOrbitDelaunayL._uuid)
        vtable_offset_local = IStateCalcOrbitDelaunayL._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitDelaunayL, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitDelaunayL, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitDelaunayL, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitDelaunayL, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcOrbitDelaunayL.__dict__ and type(IStateCalcOrbitDelaunayL.__dict__[attrname]) == property:
            return IStateCalcOrbitDelaunayL.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcOrbitDelaunayL.")
    
    @property
    def central_body_name(self) -> str:
        """Central Body used for calculation"""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        """Central Body used for calculation"""
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def element_type(self) -> "AgEVAElement":
        """Choice of osculating or mean elements"""
        with agmarshall.AgEnum_arg(AgEVAElement) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_element_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @element_type.setter
    def element_type(self, inVal:"AgEVAElement") -> None:
        """Choice of osculating or mean elements"""
        with agmarshall.AgEnum_arg(AgEVAElement, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_element_type"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{10C517CA-1CF0-45FF-B36E-3E3181269745}", IStateCalcOrbitDelaunayL)
agcls.AgTypeNameMap["IStateCalcOrbitDelaunayL"] = IStateCalcOrbitDelaunayL

class IStateCalcOrbitSemiLatusRectum(object):
    """Interface for AsStateCalcOrbitSemiLatusRectum"""
    _uuid = "{06396376-8F96-419A-86D4-32298E6A6087}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_element_type"] = _raise_uninitialized_error
        self.__dict__["_set_element_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcOrbitSemiLatusRectum._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcOrbitSemiLatusRectum from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcOrbitSemiLatusRectum = agcom.GUID(IStateCalcOrbitSemiLatusRectum._uuid)
        vtable_offset_local = IStateCalcOrbitSemiLatusRectum._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitSemiLatusRectum, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitSemiLatusRectum, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitSemiLatusRectum, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitSemiLatusRectum, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcOrbitSemiLatusRectum.__dict__ and type(IStateCalcOrbitSemiLatusRectum.__dict__[attrname]) == property:
            return IStateCalcOrbitSemiLatusRectum.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcOrbitSemiLatusRectum.")
    
    @property
    def central_body_name(self) -> str:
        """Central Body used for calculation"""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        """Central Body used for calculation"""
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def element_type(self) -> "AgEVAElement":
        """Choice of osculating or mean elements"""
        with agmarshall.AgEnum_arg(AgEVAElement) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_element_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @element_type.setter
    def element_type(self, inVal:"AgEVAElement") -> None:
        """Choice of osculating or mean elements"""
        with agmarshall.AgEnum_arg(AgEVAElement, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_element_type"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{06396376-8F96-419A-86D4-32298E6A6087}", IStateCalcOrbitSemiLatusRectum)
agcls.AgTypeNameMap["IStateCalcOrbitSemiLatusRectum"] = IStateCalcOrbitSemiLatusRectum

class IStateCalcJacobiConstant(object):
    """Properties for a Jacobi Constant calculation object."""
    _uuid = "{12857E60-E0BF-49BE-84EA-F9A0C73DB557}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcJacobiConstant._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcJacobiConstant from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcJacobiConstant = agcom.GUID(IStateCalcJacobiConstant._uuid)
        vtable_offset_local = IStateCalcJacobiConstant._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcJacobiConstant.__dict__ and type(IStateCalcJacobiConstant.__dict__[attrname]) == property:
            return IStateCalcJacobiConstant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcJacobiConstant.")
    

agcls.AgClassCatalog.add_catalog_entry("{12857E60-E0BF-49BE-84EA-F9A0C73DB557}", IStateCalcJacobiConstant)
agcls.AgTypeNameMap["IStateCalcJacobiConstant"] = IStateCalcJacobiConstant

class IStateCalcCartesianElem(object):
    """Properties for a Cartesian Element calculation object."""
    _uuid = "{43611884-2507-4D9B-AFF2-9BC5AA0786BD}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_set_coord_system_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcCartesianElem._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcCartesianElem from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcCartesianElem = agcom.GUID(IStateCalcCartesianElem._uuid)
        vtable_offset_local = IStateCalcCartesianElem._vtable_offset - 1
        self.__dict__["_get_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCartesianElem, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCartesianElem, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcCartesianElem.__dict__ and type(IStateCalcCartesianElem.__dict__[attrname]) == property:
            return IStateCalcCartesianElem.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcCartesianElem.")
    
    @property
    def coord_system_name(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_system_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_system_name.setter
    def coord_system_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_system_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{43611884-2507-4D9B-AFF2-9BC5AA0786BD}", IStateCalcCartesianElem)
agcls.AgTypeNameMap["IStateCalcCartesianElem"] = IStateCalcCartesianElem

class IStateCalcCartSTMElem(object):
    """Properties for a Cartesian STM Element calculation object."""
    _uuid = "{72B246C3-618A-40B7-8501-C39BF07E4B95}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_set_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_get_final_var"] = _raise_uninitialized_error
        self.__dict__["_set_final_var"] = _raise_uninitialized_error
        self.__dict__["_get_init_var"] = _raise_uninitialized_error
        self.__dict__["_set_init_var"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcCartSTMElem._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcCartSTMElem from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcCartSTMElem = agcom.GUID(IStateCalcCartSTMElem._uuid)
        vtable_offset_local = IStateCalcCartSTMElem._vtable_offset - 1
        self.__dict__["_get_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCartSTMElem, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCartSTMElem, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_final_var"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCartSTMElem, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_final_var"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCartSTMElem, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_init_var"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCartSTMElem, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_init_var"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCartSTMElem, vtable_offset_local+6, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcCartSTMElem.__dict__ and type(IStateCalcCartSTMElem.__dict__[attrname]) == property:
            return IStateCalcCartSTMElem.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcCartSTMElem.")
    
    @property
    def coord_system_name(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_system_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_system_name.setter
    def coord_system_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_system_name"](arg_inVal.COM_val))

    @property
    def final_var(self) -> "AgEVASTMPertVariables":
        """The final variation variable."""
        with agmarshall.AgEnum_arg(AgEVASTMPertVariables) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_final_var"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @final_var.setter
    def final_var(self, inVal:"AgEVASTMPertVariables") -> None:
        with agmarshall.AgEnum_arg(AgEVASTMPertVariables, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_final_var"](arg_inVal.COM_val))

    @property
    def init_var(self) -> "AgEVASTMPertVariables":
        """The initial variation variable."""
        with agmarshall.AgEnum_arg(AgEVASTMPertVariables) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_init_var"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @init_var.setter
    def init_var(self, inVal:"AgEVASTMPertVariables") -> None:
        with agmarshall.AgEnum_arg(AgEVASTMPertVariables, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_init_var"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{72B246C3-618A-40B7-8501-C39BF07E4B95}", IStateCalcCartSTMElem)
agcls.AgTypeNameMap["IStateCalcCartSTMElem"] = IStateCalcCartSTMElem

class IStateCalcSTMEigenval(object):
    """Properties for an STM Eigenvalue calculation object."""
    _uuid = "{24838E22-D7CE-40FF-8268-9E72AE39467B}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_set_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_get_eigenvalue_number"] = _raise_uninitialized_error
        self.__dict__["_set_eigenvalue_number"] = _raise_uninitialized_error
        self.__dict__["_get_eigenvalue_complex_part"] = _raise_uninitialized_error
        self.__dict__["_set_eigenvalue_complex_part"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcSTMEigenval._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcSTMEigenval from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcSTMEigenval = agcom.GUID(IStateCalcSTMEigenval._uuid)
        vtable_offset_local = IStateCalcSTMEigenval._vtable_offset - 1
        self.__dict__["_get_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSTMEigenval, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSTMEigenval, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_eigenvalue_number"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSTMEigenval, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_eigenvalue_number"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSTMEigenval, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_eigenvalue_complex_part"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSTMEigenval, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_eigenvalue_complex_part"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSTMEigenval, vtable_offset_local+6, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcSTMEigenval.__dict__ and type(IStateCalcSTMEigenval.__dict__[attrname]) == property:
            return IStateCalcSTMEigenval.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcSTMEigenval.")
    
    @property
    def coord_system_name(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_system_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_system_name.setter
    def coord_system_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_system_name"](arg_inVal.COM_val))

    @property
    def eigenvalue_number(self) -> "AgEVASTMEigenNumber":
        """The number identifying one of the six Eigenvalues."""
        with agmarshall.AgEnum_arg(AgEVASTMEigenNumber) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_eigenvalue_number"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @eigenvalue_number.setter
    def eigenvalue_number(self, inVal:"AgEVASTMEigenNumber") -> None:
        with agmarshall.AgEnum_arg(AgEVASTMEigenNumber, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_eigenvalue_number"](arg_inVal.COM_val))

    @property
    def eigenvalue_complex_part(self) -> "AgEVAComplexNumber":
        """Whether this value represents the real or imaginary part of the Eigenvalue."""
        with agmarshall.AgEnum_arg(AgEVAComplexNumber) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_eigenvalue_complex_part"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @eigenvalue_complex_part.setter
    def eigenvalue_complex_part(self, inVal:"AgEVAComplexNumber") -> None:
        with agmarshall.AgEnum_arg(AgEVAComplexNumber, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_eigenvalue_complex_part"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{24838E22-D7CE-40FF-8268-9E72AE39467B}", IStateCalcSTMEigenval)
agcls.AgTypeNameMap["IStateCalcSTMEigenval"] = IStateCalcSTMEigenval

class IStateCalcSTMEigenvecElem(object):
    """Properties for an STM Eigenvector element calculation object."""
    _uuid = "{7D28974A-19AF-4E80-889E-5CDA7E9DACEB}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_set_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_get_eigenvector_number"] = _raise_uninitialized_error
        self.__dict__["_set_eigenvector_number"] = _raise_uninitialized_error
        self.__dict__["_get_state_variable"] = _raise_uninitialized_error
        self.__dict__["_set_state_variable"] = _raise_uninitialized_error
        self.__dict__["_get_eigenvector_complex_part"] = _raise_uninitialized_error
        self.__dict__["_set_eigenvector_complex_part"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcSTMEigenvecElem._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcSTMEigenvecElem from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcSTMEigenvecElem = agcom.GUID(IStateCalcSTMEigenvecElem._uuid)
        vtable_offset_local = IStateCalcSTMEigenvecElem._vtable_offset - 1
        self.__dict__["_get_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSTMEigenvecElem, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSTMEigenvecElem, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_eigenvector_number"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSTMEigenvecElem, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_eigenvector_number"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSTMEigenvecElem, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_state_variable"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSTMEigenvecElem, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_state_variable"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSTMEigenvecElem, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_eigenvector_complex_part"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSTMEigenvecElem, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_eigenvector_complex_part"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSTMEigenvecElem, vtable_offset_local+8, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcSTMEigenvecElem.__dict__ and type(IStateCalcSTMEigenvecElem.__dict__[attrname]) == property:
            return IStateCalcSTMEigenvecElem.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcSTMEigenvecElem.")
    
    @property
    def coord_system_name(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_system_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_system_name.setter
    def coord_system_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_system_name"](arg_inVal.COM_val))

    @property
    def eigenvector_number(self) -> "AgEVASTMEigenNumber":
        """The number identifying one of the six Eigenvectors."""
        with agmarshall.AgEnum_arg(AgEVASTMEigenNumber) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_eigenvector_number"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @eigenvector_number.setter
    def eigenvector_number(self, inVal:"AgEVASTMEigenNumber") -> None:
        with agmarshall.AgEnum_arg(AgEVASTMEigenNumber, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_eigenvector_number"](arg_inVal.COM_val))

    @property
    def state_variable(self) -> "AgEVASTMPertVariables":
        """The variable identifying the component within an Eigenvector."""
        with agmarshall.AgEnum_arg(AgEVASTMPertVariables) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_state_variable"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @state_variable.setter
    def state_variable(self, inVal:"AgEVASTMPertVariables") -> None:
        with agmarshall.AgEnum_arg(AgEVASTMPertVariables, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_state_variable"](arg_inVal.COM_val))

    @property
    def eigenvector_complex_part(self) -> "AgEVAComplexNumber":
        """Whether this value represents the real or imaginary part of an Eigenvector element."""
        with agmarshall.AgEnum_arg(AgEVAComplexNumber) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_eigenvector_complex_part"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @eigenvector_complex_part.setter
    def eigenvector_complex_part(self, inVal:"AgEVAComplexNumber") -> None:
        with agmarshall.AgEnum_arg(AgEVAComplexNumber, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_eigenvector_complex_part"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7D28974A-19AF-4E80-889E-5CDA7E9DACEB}", IStateCalcSTMEigenvecElem)
agcls.AgTypeNameMap["IStateCalcSTMEigenvecElem"] = IStateCalcSTMEigenvecElem

class IStateCalcEnvironment(object):
    """Properties for an Environment calculation object."""
    _uuid = "{BB89B6D8-34A3-42F2-B7B3-CFDAAA9BE00C}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_model_name"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_model_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcEnvironment._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcEnvironment from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcEnvironment = agcom.GUID(IStateCalcEnvironment._uuid)
        vtable_offset_local = IStateCalcEnvironment._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcEnvironment, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcEnvironment, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_atmos_model_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcEnvironment, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_atmos_model_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcEnvironment, vtable_offset_local+4, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcEnvironment.__dict__ and type(IStateCalcEnvironment.__dict__[attrname]) == property:
            return IStateCalcEnvironment.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcEnvironment.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def atmos_model_name(self) -> str:
        """The atmospheric density model of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_model_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_model_name.setter
    def atmos_model_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_model_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{BB89B6D8-34A3-42F2-B7B3-CFDAAA9BE00C}", IStateCalcEnvironment)
agcls.AgTypeNameMap["IStateCalcEnvironment"] = IStateCalcEnvironment

class IStateCalcEquinoctialElem(object):
    """Properties for an Equinoctial Element calculation object."""
    _uuid = "{A63BA51C-CE64-410D-832F-7BDCE13E5069}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_set_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_get_element_type"] = _raise_uninitialized_error
        self.__dict__["_set_element_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcEquinoctialElem._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcEquinoctialElem from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcEquinoctialElem = agcom.GUID(IStateCalcEquinoctialElem._uuid)
        vtable_offset_local = IStateCalcEquinoctialElem._vtable_offset - 1
        self.__dict__["_get_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcEquinoctialElem, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcEquinoctialElem, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcEquinoctialElem, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcEquinoctialElem, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcEquinoctialElem.__dict__ and type(IStateCalcEquinoctialElem.__dict__[attrname]) == property:
            return IStateCalcEquinoctialElem.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcEquinoctialElem.")
    
    @property
    def coord_system_name(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_system_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_system_name.setter
    def coord_system_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_system_name"](arg_inVal.COM_val))

    @property
    def element_type(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_element_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @element_type.setter
    def element_type(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_element_type"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{A63BA51C-CE64-410D-832F-7BDCE13E5069}", IStateCalcEquinoctialElem)
agcls.AgTypeNameMap["IStateCalcEquinoctialElem"] = IStateCalcEquinoctialElem

class IStateCalcDamageFlux(object):
    """Interface for AgAsStateCalcDamageFlux"""
    _uuid = "{5E7EBA7C-121F-4649-8599-A222F65BA10B}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcDamageFlux._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcDamageFlux from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcDamageFlux = agcom.GUID(IStateCalcDamageFlux._uuid)
        vtable_offset_local = IStateCalcDamageFlux._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcDamageFlux.__dict__ and type(IStateCalcDamageFlux.__dict__[attrname]) == property:
            return IStateCalcDamageFlux.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcDamageFlux.")
    

agcls.AgClassCatalog.add_catalog_entry("{5E7EBA7C-121F-4649-8599-A222F65BA10B}", IStateCalcDamageFlux)
agcls.AgTypeNameMap["IStateCalcDamageFlux"] = IStateCalcDamageFlux

class IStateCalcDamageMassFlux(object):
    """Interface for AgAsStateCalcDamageMassFlux"""
    _uuid = "{CDA309A6-91BD-49DF-BE71-E3F194AB73AE}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcDamageMassFlux._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcDamageMassFlux from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcDamageMassFlux = agcom.GUID(IStateCalcDamageMassFlux._uuid)
        vtable_offset_local = IStateCalcDamageMassFlux._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcDamageMassFlux.__dict__ and type(IStateCalcDamageMassFlux.__dict__[attrname]) == property:
            return IStateCalcDamageMassFlux.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcDamageMassFlux.")
    

agcls.AgClassCatalog.add_catalog_entry("{CDA309A6-91BD-49DF-BE71-E3F194AB73AE}", IStateCalcDamageMassFlux)
agcls.AgTypeNameMap["IStateCalcDamageMassFlux"] = IStateCalcDamageMassFlux

class IStateCalcMagnitudeFieldDipoleL(object):
    """Interface for AgAsStateCalcMagFieldDipoleL"""
    _uuid = "{46E20C5A-4030-4D57-AAA7-38CFFD65D91D}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcMagnitudeFieldDipoleL._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcMagnitudeFieldDipoleL from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcMagnitudeFieldDipoleL = agcom.GUID(IStateCalcMagnitudeFieldDipoleL._uuid)
        vtable_offset_local = IStateCalcMagnitudeFieldDipoleL._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcMagnitudeFieldDipoleL.__dict__ and type(IStateCalcMagnitudeFieldDipoleL.__dict__[attrname]) == property:
            return IStateCalcMagnitudeFieldDipoleL.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcMagnitudeFieldDipoleL.")
    

agcls.AgClassCatalog.add_catalog_entry("{46E20C5A-4030-4D57-AAA7-38CFFD65D91D}", IStateCalcMagnitudeFieldDipoleL)
agcls.AgTypeNameMap["IStateCalcMagnitudeFieldDipoleL"] = IStateCalcMagnitudeFieldDipoleL

class IStateCalcSEETMagnitudeFieldFieldLineSepAngle(object):
    """Properties for a SEETMagFieldFieldLineSepAngle calculation object."""
    _uuid = "{FFCDD5EA-7808-4A0C-BDA5-5E4BC504F968}"
    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_target_object"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcSEETMagnitudeFieldFieldLineSepAngle._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcSEETMagnitudeFieldFieldLineSepAngle from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcSEETMagnitudeFieldFieldLineSepAngle = agcom.GUID(IStateCalcSEETMagnitudeFieldFieldLineSepAngle._uuid)
        vtable_offset_local = IStateCalcSEETMagnitudeFieldFieldLineSepAngle._vtable_offset - 1
        self.__dict__["_get_target_object"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSEETMagnitudeFieldFieldLineSepAngle, vtable_offset_local+1, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcSEETMagnitudeFieldFieldLineSepAngle.__dict__ and type(IStateCalcSEETMagnitudeFieldFieldLineSepAngle.__dict__[attrname]) == property:
            return IStateCalcSEETMagnitudeFieldFieldLineSepAngle.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcSEETMagnitudeFieldFieldLineSepAngle.")
    
    @property
    def target_object(self) -> "ILinkToObject":
        """The reference object."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_get_target_object"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val


agcls.AgClassCatalog.add_catalog_entry("{FFCDD5EA-7808-4A0C-BDA5-5E4BC504F968}", IStateCalcSEETMagnitudeFieldFieldLineSepAngle)
agcls.AgTypeNameMap["IStateCalcSEETMagnitudeFieldFieldLineSepAngle"] = IStateCalcSEETMagnitudeFieldFieldLineSepAngle

class IStateCalcImpactFlux(object):
    """Interface for AgAsStateCalcImpactFlux"""
    _uuid = "{70F6FCD6-139C-4166-B242-61652F690A89}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcImpactFlux._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcImpactFlux from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcImpactFlux = agcom.GUID(IStateCalcImpactFlux._uuid)
        vtable_offset_local = IStateCalcImpactFlux._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcImpactFlux.__dict__ and type(IStateCalcImpactFlux.__dict__[attrname]) == property:
            return IStateCalcImpactFlux.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcImpactFlux.")
    

agcls.AgClassCatalog.add_catalog_entry("{70F6FCD6-139C-4166-B242-61652F690A89}", IStateCalcImpactFlux)
agcls.AgTypeNameMap["IStateCalcImpactFlux"] = IStateCalcImpactFlux

class IStateCalcImpactMassFlux(object):
    """Interface for AgAsStateCalcImpactMassFlux"""
    _uuid = "{67D77299-1936-4E9A-A44F-C155686E4DB2}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcImpactMassFlux._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcImpactMassFlux from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcImpactMassFlux = agcom.GUID(IStateCalcImpactMassFlux._uuid)
        vtable_offset_local = IStateCalcImpactMassFlux._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcImpactMassFlux.__dict__ and type(IStateCalcImpactMassFlux.__dict__[attrname]) == property:
            return IStateCalcImpactMassFlux.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcImpactMassFlux.")
    

agcls.AgClassCatalog.add_catalog_entry("{67D77299-1936-4E9A-A44F-C155686E4DB2}", IStateCalcImpactMassFlux)
agcls.AgTypeNameMap["IStateCalcImpactMassFlux"] = IStateCalcImpactMassFlux

class IStateCalcSEETSAAFlux(object):
    """Interface for AgAsStateCalcSEETSAAFlux"""
    _uuid = "{3C633703-2759-4894-96EA-F6E3C2F98AA1}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcSEETSAAFlux._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcSEETSAAFlux from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcSEETSAAFlux = agcom.GUID(IStateCalcSEETSAAFlux._uuid)
        vtable_offset_local = IStateCalcSEETSAAFlux._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcSEETSAAFlux.__dict__ and type(IStateCalcSEETSAAFlux.__dict__[attrname]) == property:
            return IStateCalcSEETSAAFlux.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcSEETSAAFlux.")
    

agcls.AgClassCatalog.add_catalog_entry("{3C633703-2759-4894-96EA-F6E3C2F98AA1}", IStateCalcSEETSAAFlux)
agcls.AgTypeNameMap["IStateCalcSEETSAAFlux"] = IStateCalcSEETSAAFlux

class IStateCalcSEETVehTemp(object):
    """Interface for AgAsStateCalcSEETVehTemp"""
    _uuid = "{4B70C4FB-3403-4F3F-9F3F-B2C0CF8DB393}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcSEETVehTemp._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcSEETVehTemp from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcSEETVehTemp = agcom.GUID(IStateCalcSEETVehTemp._uuid)
        vtable_offset_local = IStateCalcSEETVehTemp._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcSEETVehTemp.__dict__ and type(IStateCalcSEETVehTemp.__dict__[attrname]) == property:
            return IStateCalcSEETVehTemp.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcSEETVehTemp.")
    

agcls.AgClassCatalog.add_catalog_entry("{4B70C4FB-3403-4F3F-9F3F-B2C0CF8DB393}", IStateCalcSEETVehTemp)
agcls.AgTypeNameMap["IStateCalcSEETVehTemp"] = IStateCalcSEETVehTemp

class IStateCalcCloseApproachBearing(object):
    """Properties for a CloseApproachBearing calculation object."""
    _uuid = "{E7717197-6955-4ECB-BF98-DA50AD7547F3}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_reference_selection"] = _raise_uninitialized_error
        self.__dict__["_set_reference_selection"] = _raise_uninitialized_error
        self.__dict__["_get_reference"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcCloseApproachBearing._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcCloseApproachBearing from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcCloseApproachBearing = agcom.GUID(IStateCalcCloseApproachBearing._uuid)
        vtable_offset_local = IStateCalcCloseApproachBearing._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCloseApproachBearing, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCloseApproachBearing, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_reference_selection"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCloseApproachBearing, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_reference_selection"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCloseApproachBearing, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_reference"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCloseApproachBearing, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcCloseApproachBearing.__dict__ and type(IStateCalcCloseApproachBearing.__dict__[attrname]) == property:
            return IStateCalcCloseApproachBearing.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcCloseApproachBearing.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def reference_selection(self) -> "AgEVACalcObjectReference":
        """The reference object selection."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_selection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_selection.setter
    def reference_selection(self, inVal:"AgEVACalcObjectReference") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_selection"](arg_inVal.COM_val))

    @property
    def reference(self) -> "ILinkToObject":
        """The reference object."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_get_reference"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val


agcls.AgClassCatalog.add_catalog_entry("{E7717197-6955-4ECB-BF98-DA50AD7547F3}", IStateCalcCloseApproachBearing)
agcls.AgTypeNameMap["IStateCalcCloseApproachBearing"] = IStateCalcCloseApproachBearing

class IStateCalcCloseApproachMagnitude(object):
    """Properties for a CloseApproachMagnitude calculation object."""
    _uuid = "{DDACF6D7-29C0-46BB-A21A-123580E25161}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_reference_selection"] = _raise_uninitialized_error
        self.__dict__["_set_reference_selection"] = _raise_uninitialized_error
        self.__dict__["_get_reference"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcCloseApproachMagnitude._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcCloseApproachMagnitude from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcCloseApproachMagnitude = agcom.GUID(IStateCalcCloseApproachMagnitude._uuid)
        vtable_offset_local = IStateCalcCloseApproachMagnitude._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCloseApproachMagnitude, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCloseApproachMagnitude, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_reference_selection"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCloseApproachMagnitude, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_reference_selection"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCloseApproachMagnitude, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_reference"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCloseApproachMagnitude, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcCloseApproachMagnitude.__dict__ and type(IStateCalcCloseApproachMagnitude.__dict__[attrname]) == property:
            return IStateCalcCloseApproachMagnitude.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcCloseApproachMagnitude.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def reference_selection(self) -> "AgEVACalcObjectReference":
        """The reference object selection."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_selection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_selection.setter
    def reference_selection(self, inVal:"AgEVACalcObjectReference") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_selection"](arg_inVal.COM_val))

    @property
    def reference(self) -> "ILinkToObject":
        """The reference object."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_get_reference"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val


agcls.AgClassCatalog.add_catalog_entry("{DDACF6D7-29C0-46BB-A21A-123580E25161}", IStateCalcCloseApproachMagnitude)
agcls.AgTypeNameMap["IStateCalcCloseApproachMagnitude"] = IStateCalcCloseApproachMagnitude

class IStateCalcCloseApproachTheta(object):
    """Properties for a CloseApproachTheta calculation object."""
    _uuid = "{2F89E7F5-154B-4CED-807A-040A064F1A14}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_reference_selection"] = _raise_uninitialized_error
        self.__dict__["_set_reference_selection"] = _raise_uninitialized_error
        self.__dict__["_get_reference"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcCloseApproachTheta._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcCloseApproachTheta from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcCloseApproachTheta = agcom.GUID(IStateCalcCloseApproachTheta._uuid)
        vtable_offset_local = IStateCalcCloseApproachTheta._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCloseApproachTheta, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCloseApproachTheta, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_reference_selection"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCloseApproachTheta, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_reference_selection"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCloseApproachTheta, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_reference"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCloseApproachTheta, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcCloseApproachTheta.__dict__ and type(IStateCalcCloseApproachTheta.__dict__[attrname]) == property:
            return IStateCalcCloseApproachTheta.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcCloseApproachTheta.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def reference_selection(self) -> "AgEVACalcObjectReference":
        """The reference object selection."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_selection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_selection.setter
    def reference_selection(self, inVal:"AgEVACalcObjectReference") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_selection"](arg_inVal.COM_val))

    @property
    def reference(self) -> "ILinkToObject":
        """The reference object."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_get_reference"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val


agcls.AgClassCatalog.add_catalog_entry("{2F89E7F5-154B-4CED-807A-040A064F1A14}", IStateCalcCloseApproachTheta)
agcls.AgTypeNameMap["IStateCalcCloseApproachTheta"] = IStateCalcCloseApproachTheta

class IStateCalcCloseApproachX(object):
    """Properties for a CloseApproachX calculation object."""
    _uuid = "{B57EFFE4-9742-4F26-989C-A8D64549F8ED}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_reference_selection"] = _raise_uninitialized_error
        self.__dict__["_set_reference_selection"] = _raise_uninitialized_error
        self.__dict__["_get_reference"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcCloseApproachX._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcCloseApproachX from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcCloseApproachX = agcom.GUID(IStateCalcCloseApproachX._uuid)
        vtable_offset_local = IStateCalcCloseApproachX._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCloseApproachX, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCloseApproachX, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_reference_selection"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCloseApproachX, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_reference_selection"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCloseApproachX, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_reference"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCloseApproachX, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcCloseApproachX.__dict__ and type(IStateCalcCloseApproachX.__dict__[attrname]) == property:
            return IStateCalcCloseApproachX.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcCloseApproachX.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def reference_selection(self) -> "AgEVACalcObjectReference":
        """The reference object selection."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_selection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_selection.setter
    def reference_selection(self, inVal:"AgEVACalcObjectReference") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_selection"](arg_inVal.COM_val))

    @property
    def reference(self) -> "ILinkToObject":
        """The reference object."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_get_reference"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val


agcls.AgClassCatalog.add_catalog_entry("{B57EFFE4-9742-4F26-989C-A8D64549F8ED}", IStateCalcCloseApproachX)
agcls.AgTypeNameMap["IStateCalcCloseApproachX"] = IStateCalcCloseApproachX

class IStateCalcCloseApproachY(object):
    """Properties for a CloseApproachY calculation object."""
    _uuid = "{7C03BAD0-6CF8-4A20-ABA9-B16006A4016E}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_reference_selection"] = _raise_uninitialized_error
        self.__dict__["_set_reference_selection"] = _raise_uninitialized_error
        self.__dict__["_get_reference"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcCloseApproachY._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcCloseApproachY from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcCloseApproachY = agcom.GUID(IStateCalcCloseApproachY._uuid)
        vtable_offset_local = IStateCalcCloseApproachY._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCloseApproachY, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCloseApproachY, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_reference_selection"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCloseApproachY, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_reference_selection"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCloseApproachY, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_reference"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCloseApproachY, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcCloseApproachY.__dict__ and type(IStateCalcCloseApproachY.__dict__[attrname]) == property:
            return IStateCalcCloseApproachY.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcCloseApproachY.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def reference_selection(self) -> "AgEVACalcObjectReference":
        """The reference object selection."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_selection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_selection.setter
    def reference_selection(self, inVal:"AgEVACalcObjectReference") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_selection"](arg_inVal.COM_val))

    @property
    def reference(self) -> "ILinkToObject":
        """The reference object."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_get_reference"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val


agcls.AgClassCatalog.add_catalog_entry("{7C03BAD0-6CF8-4A20-ABA9-B16006A4016E}", IStateCalcCloseApproachY)
agcls.AgTypeNameMap["IStateCalcCloseApproachY"] = IStateCalcCloseApproachY

class IStateCalcCloseApproachCosBearing(object):
    """Properties for a CosineOfCloseApproachBearing calculation object."""
    _uuid = "{ED9F8425-E6C7-49D0-842F-84FE096E6C27}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_reference_selection"] = _raise_uninitialized_error
        self.__dict__["_set_reference_selection"] = _raise_uninitialized_error
        self.__dict__["_get_reference"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcCloseApproachCosBearing._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcCloseApproachCosBearing from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcCloseApproachCosBearing = agcom.GUID(IStateCalcCloseApproachCosBearing._uuid)
        vtable_offset_local = IStateCalcCloseApproachCosBearing._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCloseApproachCosBearing, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCloseApproachCosBearing, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_reference_selection"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCloseApproachCosBearing, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_reference_selection"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCloseApproachCosBearing, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_reference"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCloseApproachCosBearing, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcCloseApproachCosBearing.__dict__ and type(IStateCalcCloseApproachCosBearing.__dict__[attrname]) == property:
            return IStateCalcCloseApproachCosBearing.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcCloseApproachCosBearing.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def reference_selection(self) -> "AgEVACalcObjectReference":
        """The reference object selection."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_selection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_selection.setter
    def reference_selection(self, inVal:"AgEVACalcObjectReference") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_selection"](arg_inVal.COM_val))

    @property
    def reference(self) -> "ILinkToObject":
        """The reference object."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_get_reference"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val


agcls.AgClassCatalog.add_catalog_entry("{ED9F8425-E6C7-49D0-842F-84FE096E6C27}", IStateCalcCloseApproachCosBearing)
agcls.AgTypeNameMap["IStateCalcCloseApproachCosBearing"] = IStateCalcCloseApproachCosBearing

class IStateCalcRelGroundTrackError(object):
    """Properties for a RelGroundTrackError calculation object."""
    _uuid = "{F9BD881C-FBBF-4B59-AA64-8D303DBBCC44}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_direction"] = _raise_uninitialized_error
        self.__dict__["_set_direction"] = _raise_uninitialized_error
        self.__dict__["_get_signed"] = _raise_uninitialized_error
        self.__dict__["_set_signed"] = _raise_uninitialized_error
        self.__dict__["_get_reference_selection"] = _raise_uninitialized_error
        self.__dict__["_set_reference_selection"] = _raise_uninitialized_error
        self.__dict__["_get_reference"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcRelGroundTrackError._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcRelGroundTrackError from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcRelGroundTrackError = agcom.GUID(IStateCalcRelGroundTrackError._uuid)
        vtable_offset_local = IStateCalcRelGroundTrackError._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelGroundTrackError, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelGroundTrackError, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_direction"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelGroundTrackError, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_direction"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelGroundTrackError, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_signed"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelGroundTrackError, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_signed"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelGroundTrackError, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_get_reference_selection"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelGroundTrackError, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_reference_selection"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelGroundTrackError, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_reference"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelGroundTrackError, vtable_offset_local+9, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcRelGroundTrackError.__dict__ and type(IStateCalcRelGroundTrackError.__dict__[attrname]) == property:
            return IStateCalcRelGroundTrackError.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcRelGroundTrackError.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def direction(self) -> "AgEVACalcObjectDirection":
        """The direction to search for the desired value."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectDirection) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_direction"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @direction.setter
    def direction(self, inVal:"AgEVACalcObjectDirection") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectDirection, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_direction"](arg_inVal.COM_val))

    @property
    def signed(self) -> bool:
        """True if signed based on RxV."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_signed"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @signed.setter
    def signed(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_signed"](arg_inVal.COM_val))

    @property
    def reference_selection(self) -> "AgEVACalcObjectReference":
        """The reference object selection."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_selection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_selection.setter
    def reference_selection(self, inVal:"AgEVACalcObjectReference") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_selection"](arg_inVal.COM_val))

    @property
    def reference(self) -> "ILinkToObject":
        """The reference object."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_get_reference"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val


agcls.AgClassCatalog.add_catalog_entry("{F9BD881C-FBBF-4B59-AA64-8D303DBBCC44}", IStateCalcRelGroundTrackError)
agcls.AgTypeNameMap["IStateCalcRelGroundTrackError"] = IStateCalcRelGroundTrackError

class IStateCalcRelAtAOLMaster(object):
    """Properties for a RelativeAtAOL calculation object."""
    _uuid = "{8864FF20-53E7-4609-86A7-C9F7B113B651}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_calc_object_name"] = _raise_uninitialized_error
        self.__dict__["_set_calc_object_name"] = _raise_uninitialized_error
        self.__dict__["_get_direction"] = _raise_uninitialized_error
        self.__dict__["_set_direction"] = _raise_uninitialized_error
        self.__dict__["_get_reference_selection"] = _raise_uninitialized_error
        self.__dict__["_set_reference_selection"] = _raise_uninitialized_error
        self.__dict__["_get_reference"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcRelAtAOLMaster._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcRelAtAOLMaster from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcRelAtAOLMaster = agcom.GUID(IStateCalcRelAtAOLMaster._uuid)
        vtable_offset_local = IStateCalcRelAtAOLMaster._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelAtAOLMaster, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelAtAOLMaster, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_calc_object_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelAtAOLMaster, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_calc_object_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelAtAOLMaster, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_get_direction"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelAtAOLMaster, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_direction"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelAtAOLMaster, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_reference_selection"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelAtAOLMaster, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_reference_selection"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelAtAOLMaster, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_reference"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelAtAOLMaster, vtable_offset_local+9, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcRelAtAOLMaster.__dict__ and type(IStateCalcRelAtAOLMaster.__dict__[attrname]) == property:
            return IStateCalcRelAtAOLMaster.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcRelAtAOLMaster.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def calc_object_name(self) -> str:
        """The calculation object of interest."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_calc_object_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @calc_object_name.setter
    def calc_object_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_calc_object_name"](arg_inVal.COM_val))

    @property
    def direction(self) -> "AgEVACalcObjectDirection":
        """The direction to search for the desired value."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectDirection) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_direction"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @direction.setter
    def direction(self, inVal:"AgEVACalcObjectDirection") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectDirection, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_direction"](arg_inVal.COM_val))

    @property
    def reference_selection(self) -> "AgEVACalcObjectReference":
        """The reference object selection."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_selection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_selection.setter
    def reference_selection(self, inVal:"AgEVACalcObjectReference") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_selection"](arg_inVal.COM_val))

    @property
    def reference(self) -> "ILinkToObject":
        """The reference object."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_get_reference"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val


agcls.AgClassCatalog.add_catalog_entry("{8864FF20-53E7-4609-86A7-C9F7B113B651}", IStateCalcRelAtAOLMaster)
agcls.AgTypeNameMap["IStateCalcRelAtAOLMaster"] = IStateCalcRelAtAOLMaster

class IStateCalcDeltaFromMaster(object):
    """Properties for a Rel Mean Mean Anomaly calculation object."""
    _uuid = "{6203B45E-E2E8-42D1-BB22-9BBF57CC1FDE}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_calc_object_name"] = _raise_uninitialized_error
        self.__dict__["_set_calc_object_name"] = _raise_uninitialized_error
        self.__dict__["_get_reference_selection"] = _raise_uninitialized_error
        self.__dict__["_set_reference_selection"] = _raise_uninitialized_error
        self.__dict__["_get_reference"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcDeltaFromMaster._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcDeltaFromMaster from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcDeltaFromMaster = agcom.GUID(IStateCalcDeltaFromMaster._uuid)
        vtable_offset_local = IStateCalcDeltaFromMaster._vtable_offset - 1
        self.__dict__["_get_calc_object_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDeltaFromMaster, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_calc_object_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDeltaFromMaster, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_reference_selection"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDeltaFromMaster, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_reference_selection"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDeltaFromMaster, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_reference"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDeltaFromMaster, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcDeltaFromMaster.__dict__ and type(IStateCalcDeltaFromMaster.__dict__[attrname]) == property:
            return IStateCalcDeltaFromMaster.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcDeltaFromMaster.")
    
    @property
    def calc_object_name(self) -> str:
        """The calculation object of interest."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_calc_object_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @calc_object_name.setter
    def calc_object_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_calc_object_name"](arg_inVal.COM_val))

    @property
    def reference_selection(self) -> "AgEVACalcObjectReference":
        """The reference object selection."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_selection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_selection.setter
    def reference_selection(self, inVal:"AgEVACalcObjectReference") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_selection"](arg_inVal.COM_val))

    @property
    def reference(self) -> "ILinkToObject":
        """The reference object."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_get_reference"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val


agcls.AgClassCatalog.add_catalog_entry("{6203B45E-E2E8-42D1-BB22-9BBF57CC1FDE}", IStateCalcDeltaFromMaster)
agcls.AgTypeNameMap["IStateCalcDeltaFromMaster"] = IStateCalcDeltaFromMaster

class IStateCalcLonDriftRate(object):
    """Properties for a Longitude Drift Rate calculation object."""
    _uuid = "{D464DED3-3358-452D-B55C-2B017D04C8F9}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_element_type"] = _raise_uninitialized_error
        self.__dict__["_set_element_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcLonDriftRate._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcLonDriftRate from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcLonDriftRate = agcom.GUID(IStateCalcLonDriftRate._uuid)
        vtable_offset_local = IStateCalcLonDriftRate._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcLonDriftRate, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcLonDriftRate, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcLonDriftRate, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcLonDriftRate, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcLonDriftRate.__dict__ and type(IStateCalcLonDriftRate.__dict__[attrname]) == property:
            return IStateCalcLonDriftRate.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcLonDriftRate.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def element_type(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_element_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @element_type.setter
    def element_type(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_element_type"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{D464DED3-3358-452D-B55C-2B017D04C8F9}", IStateCalcLonDriftRate)
agcls.AgTypeNameMap["IStateCalcLonDriftRate"] = IStateCalcLonDriftRate

class IStateCalcMeanEarthLon(object):
    """Properties for a Mean Earth Longitude calculation object."""
    _uuid = "{49D6969B-42BD-4E55-9016-0F951FF34DEE}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcMeanEarthLon._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcMeanEarthLon from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcMeanEarthLon = agcom.GUID(IStateCalcMeanEarthLon._uuid)
        vtable_offset_local = IStateCalcMeanEarthLon._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcMeanEarthLon, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcMeanEarthLon, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcMeanEarthLon.__dict__ and type(IStateCalcMeanEarthLon.__dict__[attrname]) == property:
            return IStateCalcMeanEarthLon.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcMeanEarthLon.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{49D6969B-42BD-4E55-9016-0F951FF34DEE}", IStateCalcMeanEarthLon)
agcls.AgTypeNameMap["IStateCalcMeanEarthLon"] = IStateCalcMeanEarthLon

class IStateCalcRectifiedLon(object):
    """Properties for a RectifiedLon calculation object."""
    _uuid = "{FD75BCCA-8F5C-49BA-AADE-040E1186385D}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcRectifiedLon._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcRectifiedLon from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcRectifiedLon = agcom.GUID(IStateCalcRectifiedLon._uuid)
        vtable_offset_local = IStateCalcRectifiedLon._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRectifiedLon, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRectifiedLon, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcRectifiedLon.__dict__ and type(IStateCalcRectifiedLon.__dict__[attrname]) == property:
            return IStateCalcRectifiedLon.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcRectifiedLon.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{FD75BCCA-8F5C-49BA-AADE-040E1186385D}", IStateCalcRectifiedLon)
agcls.AgTypeNameMap["IStateCalcRectifiedLon"] = IStateCalcRectifiedLon

class IStateCalcTrueLongitude(object):
    """Properties for a TrueLongitude calculation object."""
    _uuid = "{8D80A622-E99D-407B-A30D-44EE0B7FF577}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcTrueLongitude._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcTrueLongitude from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcTrueLongitude = agcom.GUID(IStateCalcTrueLongitude._uuid)
        vtable_offset_local = IStateCalcTrueLongitude._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcTrueLongitude, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcTrueLongitude, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcTrueLongitude.__dict__ and type(IStateCalcTrueLongitude.__dict__[attrname]) == property:
            return IStateCalcTrueLongitude.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcTrueLongitude.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{8D80A622-E99D-407B-A30D-44EE0B7FF577}", IStateCalcTrueLongitude)
agcls.AgTypeNameMap["IStateCalcTrueLongitude"] = IStateCalcTrueLongitude

class IStateCalcGeodeticTrueLongitude(object):
    """Properties for a GeodeticTrueLongitude calculation object."""
    _uuid = "{76BD7923-C04A-4789-885E-4643A30E9BB2}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcGeodeticTrueLongitude._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcGeodeticTrueLongitude from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcGeodeticTrueLongitude = agcom.GUID(IStateCalcGeodeticTrueLongitude._uuid)
        vtable_offset_local = IStateCalcGeodeticTrueLongitude._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcGeodeticTrueLongitude, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcGeodeticTrueLongitude, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcGeodeticTrueLongitude.__dict__ and type(IStateCalcGeodeticTrueLongitude.__dict__[attrname]) == property:
            return IStateCalcGeodeticTrueLongitude.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcGeodeticTrueLongitude.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{76BD7923-C04A-4789-885E-4643A30E9BB2}", IStateCalcGeodeticTrueLongitude)
agcls.AgTypeNameMap["IStateCalcGeodeticTrueLongitude"] = IStateCalcGeodeticTrueLongitude

class IStateCalcGeodeticTrueLongitudeAtTimeOfPerigee(object):
    """Properties for a GeodeticTrueLongitudeAtTimeOfPerigee calculation object."""
    _uuid = "{9B9ACD2A-1A98-4D05-A8F1-2878918138E2}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcGeodeticTrueLongitudeAtTimeOfPerigee._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcGeodeticTrueLongitudeAtTimeOfPerigee from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcGeodeticTrueLongitudeAtTimeOfPerigee = agcom.GUID(IStateCalcGeodeticTrueLongitudeAtTimeOfPerigee._uuid)
        vtable_offset_local = IStateCalcGeodeticTrueLongitudeAtTimeOfPerigee._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcGeodeticTrueLongitudeAtTimeOfPerigee, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcGeodeticTrueLongitudeAtTimeOfPerigee, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcGeodeticTrueLongitudeAtTimeOfPerigee.__dict__ and type(IStateCalcGeodeticTrueLongitudeAtTimeOfPerigee.__dict__[attrname]) == property:
            return IStateCalcGeodeticTrueLongitudeAtTimeOfPerigee.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcGeodeticTrueLongitudeAtTimeOfPerigee.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{9B9ACD2A-1A98-4D05-A8F1-2878918138E2}", IStateCalcGeodeticTrueLongitudeAtTimeOfPerigee)
agcls.AgTypeNameMap["IStateCalcGeodeticTrueLongitudeAtTimeOfPerigee"] = IStateCalcGeodeticTrueLongitudeAtTimeOfPerigee

class IStateCalcMeanRightAscension(object):
    """Properties for a MeanRightAscension calculation object."""
    _uuid = "{073A71DB-77AA-460E-8BD2-B5E4226029B2}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcMeanRightAscension._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcMeanRightAscension from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcMeanRightAscension = agcom.GUID(IStateCalcMeanRightAscension._uuid)
        vtable_offset_local = IStateCalcMeanRightAscension._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcMeanRightAscension, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcMeanRightAscension, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcMeanRightAscension.__dict__ and type(IStateCalcMeanRightAscension.__dict__[attrname]) == property:
            return IStateCalcMeanRightAscension.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcMeanRightAscension.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{073A71DB-77AA-460E-8BD2-B5E4226029B2}", IStateCalcMeanRightAscension)
agcls.AgTypeNameMap["IStateCalcMeanRightAscension"] = IStateCalcMeanRightAscension

class IStateCalcGeodeticMeanRightAscension(object):
    """Properties for a GeodeticMeanRightAscension calculation object."""
    _uuid = "{9AF8C388-DBF6-4A2A-A728-6CE55CD774FC}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcGeodeticMeanRightAscension._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcGeodeticMeanRightAscension from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcGeodeticMeanRightAscension = agcom.GUID(IStateCalcGeodeticMeanRightAscension._uuid)
        vtable_offset_local = IStateCalcGeodeticMeanRightAscension._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcGeodeticMeanRightAscension, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcGeodeticMeanRightAscension, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcGeodeticMeanRightAscension.__dict__ and type(IStateCalcGeodeticMeanRightAscension.__dict__[attrname]) == property:
            return IStateCalcGeodeticMeanRightAscension.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcGeodeticMeanRightAscension.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{9AF8C388-DBF6-4A2A-A728-6CE55CD774FC}", IStateCalcGeodeticMeanRightAscension)
agcls.AgTypeNameMap["IStateCalcGeodeticMeanRightAscension"] = IStateCalcGeodeticMeanRightAscension

class IStateCalcTwoBodyDriftRate(object):
    """Properties for a TwoBodyDriftRate calculation object."""
    _uuid = "{9C9ADC21-B1EB-4BC8-A569-51B5F80A2DE1}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcTwoBodyDriftRate._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcTwoBodyDriftRate from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcTwoBodyDriftRate = agcom.GUID(IStateCalcTwoBodyDriftRate._uuid)
        vtable_offset_local = IStateCalcTwoBodyDriftRate._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcTwoBodyDriftRate, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcTwoBodyDriftRate, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcTwoBodyDriftRate.__dict__ and type(IStateCalcTwoBodyDriftRate.__dict__[attrname]) == property:
            return IStateCalcTwoBodyDriftRate.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcTwoBodyDriftRate.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{9C9ADC21-B1EB-4BC8-A569-51B5F80A2DE1}", IStateCalcTwoBodyDriftRate)
agcls.AgTypeNameMap["IStateCalcTwoBodyDriftRate"] = IStateCalcTwoBodyDriftRate

class IStateCalcDriftRateFactor(object):
    """Properties for a DriftRateFactor calculation object."""
    _uuid = "{D50B861F-D9B7-49F8-9B23-D89FBA4C334E}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_drift_rate_model"] = _raise_uninitialized_error
        self.__dict__["_set_drift_rate_model"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcDriftRateFactor._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcDriftRateFactor from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcDriftRateFactor = agcom.GUID(IStateCalcDriftRateFactor._uuid)
        vtable_offset_local = IStateCalcDriftRateFactor._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDriftRateFactor, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDriftRateFactor, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_drift_rate_model"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDriftRateFactor, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_drift_rate_model"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDriftRateFactor, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcDriftRateFactor.__dict__ and type(IStateCalcDriftRateFactor.__dict__[attrname]) == property:
            return IStateCalcDriftRateFactor.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcDriftRateFactor.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def drift_rate_model(self) -> "AgEVAGeoStationaryDriftRateModel":
        """The gravity model used to compute drift rate."""
        with agmarshall.AgEnum_arg(AgEVAGeoStationaryDriftRateModel) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drift_rate_model"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drift_rate_model.setter
    def drift_rate_model(self, val:"AgEVAGeoStationaryDriftRateModel") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoStationaryDriftRateModel, val) as arg_val:
            agcls.evaluate_hresult(self.__dict__["_set_drift_rate_model"](arg_val.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{D50B861F-D9B7-49F8-9B23-D89FBA4C334E}", IStateCalcDriftRateFactor)
agcls.AgTypeNameMap["IStateCalcDriftRateFactor"] = IStateCalcDriftRateFactor

class IStateCalcEccentricityX(object):
    """Properties for a EccentricityX calculation object."""
    _uuid = "{0FB1B835-D3EB-43EB-A500-2FD1A15D8BF0}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcEccentricityX._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcEccentricityX from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcEccentricityX = agcom.GUID(IStateCalcEccentricityX._uuid)
        vtable_offset_local = IStateCalcEccentricityX._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcEccentricityX, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcEccentricityX, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcEccentricityX.__dict__ and type(IStateCalcEccentricityX.__dict__[attrname]) == property:
            return IStateCalcEccentricityX.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcEccentricityX.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{0FB1B835-D3EB-43EB-A500-2FD1A15D8BF0}", IStateCalcEccentricityX)
agcls.AgTypeNameMap["IStateCalcEccentricityX"] = IStateCalcEccentricityX

class IStateCalcEccentricityY(object):
    """Properties for a EccentricityY calculation object."""
    _uuid = "{98C2F051-C83D-446E-A3CC-CE1FA96FAADB}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcEccentricityY._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcEccentricityY from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcEccentricityY = agcom.GUID(IStateCalcEccentricityY._uuid)
        vtable_offset_local = IStateCalcEccentricityY._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcEccentricityY, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcEccentricityY, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcEccentricityY.__dict__ and type(IStateCalcEccentricityY.__dict__[attrname]) == property:
            return IStateCalcEccentricityY.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcEccentricityY.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{98C2F051-C83D-446E-A3CC-CE1FA96FAADB}", IStateCalcEccentricityY)
agcls.AgTypeNameMap["IStateCalcEccentricityY"] = IStateCalcEccentricityY

class IStateCalcInclinationX(object):
    """Properties for a InclinationX calculation object."""
    _uuid = "{A8646172-74A1-4998-AFE4-AF0AF5351478}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_inclination_magnitude_type"] = _raise_uninitialized_error
        self.__dict__["_set_inclination_magnitude_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcInclinationX._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcInclinationX from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcInclinationX = agcom.GUID(IStateCalcInclinationX._uuid)
        vtable_offset_local = IStateCalcInclinationX._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcInclinationX, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcInclinationX, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_inclination_magnitude_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcInclinationX, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_inclination_magnitude_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcInclinationX, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcInclinationX.__dict__ and type(IStateCalcInclinationX.__dict__[attrname]) == property:
            return IStateCalcInclinationX.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcInclinationX.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def inclination_magnitude_type(self) -> "AgEVAGeoStationaryInclinationMag":
        """Magnitude to use when computing the inclination vector."""
        with agmarshall.AgEnum_arg(AgEVAGeoStationaryInclinationMag) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_inclination_magnitude_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @inclination_magnitude_type.setter
    def inclination_magnitude_type(self, val:"AgEVAGeoStationaryInclinationMag") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoStationaryInclinationMag, val) as arg_val:
            agcls.evaluate_hresult(self.__dict__["_set_inclination_magnitude_type"](arg_val.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{A8646172-74A1-4998-AFE4-AF0AF5351478}", IStateCalcInclinationX)
agcls.AgTypeNameMap["IStateCalcInclinationX"] = IStateCalcInclinationX

class IStateCalcInclinationY(object):
    """Properties for a InclinationY calculation object."""
    _uuid = "{5CEC75BB-28C3-4BA7-A96E-DC115619B093}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_inclination_magnitude_type"] = _raise_uninitialized_error
        self.__dict__["_set_inclination_magnitude_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcInclinationY._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcInclinationY from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcInclinationY = agcom.GUID(IStateCalcInclinationY._uuid)
        vtable_offset_local = IStateCalcInclinationY._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcInclinationY, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcInclinationY, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_inclination_magnitude_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcInclinationY, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_inclination_magnitude_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcInclinationY, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcInclinationY.__dict__ and type(IStateCalcInclinationY.__dict__[attrname]) == property:
            return IStateCalcInclinationY.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcInclinationY.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def inclination_magnitude_type(self) -> "AgEVAGeoStationaryInclinationMag":
        """Magnitude to use when computing the inclination vector."""
        with agmarshall.AgEnum_arg(AgEVAGeoStationaryInclinationMag) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_inclination_magnitude_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @inclination_magnitude_type.setter
    def inclination_magnitude_type(self, val:"AgEVAGeoStationaryInclinationMag") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoStationaryInclinationMag, val) as arg_val:
            agcls.evaluate_hresult(self.__dict__["_set_inclination_magnitude_type"](arg_val.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{5CEC75BB-28C3-4BA7-A96E-DC115619B093}", IStateCalcInclinationY)
agcls.AgTypeNameMap["IStateCalcInclinationY"] = IStateCalcInclinationY

class IStateCalcUnitAngularMomentumX(object):
    """Properties for a UnitAngularMomentumX calculation object."""
    _uuid = "{7165CE29-2BAA-438B-BF73-49E4B5AFD22D}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcUnitAngularMomentumX._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcUnitAngularMomentumX from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcUnitAngularMomentumX = agcom.GUID(IStateCalcUnitAngularMomentumX._uuid)
        vtable_offset_local = IStateCalcUnitAngularMomentumX._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcUnitAngularMomentumX, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcUnitAngularMomentumX, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcUnitAngularMomentumX.__dict__ and type(IStateCalcUnitAngularMomentumX.__dict__[attrname]) == property:
            return IStateCalcUnitAngularMomentumX.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcUnitAngularMomentumX.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7165CE29-2BAA-438B-BF73-49E4B5AFD22D}", IStateCalcUnitAngularMomentumX)
agcls.AgTypeNameMap["IStateCalcUnitAngularMomentumX"] = IStateCalcUnitAngularMomentumX

class IStateCalcUnitAngularMomentumY(object):
    """Properties for a UnitAngularMomentumY calculation object."""
    _uuid = "{F0A06177-01B3-401E-980F-B61774B91FD0}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcUnitAngularMomentumY._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcUnitAngularMomentumY from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcUnitAngularMomentumY = agcom.GUID(IStateCalcUnitAngularMomentumY._uuid)
        vtable_offset_local = IStateCalcUnitAngularMomentumY._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcUnitAngularMomentumY, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcUnitAngularMomentumY, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcUnitAngularMomentumY.__dict__ and type(IStateCalcUnitAngularMomentumY.__dict__[attrname]) == property:
            return IStateCalcUnitAngularMomentumY.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcUnitAngularMomentumY.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{F0A06177-01B3-401E-980F-B61774B91FD0}", IStateCalcUnitAngularMomentumY)
agcls.AgTypeNameMap["IStateCalcUnitAngularMomentumY"] = IStateCalcUnitAngularMomentumY

class IStateCalcUnitAngularMomentumZ(object):
    """Properties for a UnitAngularMomentumZ calculation object."""
    _uuid = "{7184F372-5CFE-4792-B30F-5DC69E9A6F01}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcUnitAngularMomentumZ._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcUnitAngularMomentumZ from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcUnitAngularMomentumZ = agcom.GUID(IStateCalcUnitAngularMomentumZ._uuid)
        vtable_offset_local = IStateCalcUnitAngularMomentumZ._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcUnitAngularMomentumZ, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcUnitAngularMomentumZ, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcUnitAngularMomentumZ.__dict__ and type(IStateCalcUnitAngularMomentumZ.__dict__[attrname]) == property:
            return IStateCalcUnitAngularMomentumZ.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcUnitAngularMomentumZ.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7184F372-5CFE-4792-B30F-5DC69E9A6F01}", IStateCalcUnitAngularMomentumZ)
agcls.AgTypeNameMap["IStateCalcUnitAngularMomentumZ"] = IStateCalcUnitAngularMomentumZ

class IStateCalcGeodeticElem(object):
    """Properties for a Geodetic Element calculation object."""
    _uuid = "{D827128C-F7C1-40CE-AE27-DDF0AAEBB150}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcGeodeticElem._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcGeodeticElem from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcGeodeticElem = agcom.GUID(IStateCalcGeodeticElem._uuid)
        vtable_offset_local = IStateCalcGeodeticElem._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcGeodeticElem, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcGeodeticElem, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcGeodeticElem.__dict__ and type(IStateCalcGeodeticElem.__dict__[attrname]) == property:
            return IStateCalcGeodeticElem.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcGeodeticElem.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{D827128C-F7C1-40CE-AE27-DDF0AAEBB150}", IStateCalcGeodeticElem)
agcls.AgTypeNameMap["IStateCalcGeodeticElem"] = IStateCalcGeodeticElem

class IStateCalcRepeatingGroundTrackErr(object):
    """Properties for a RepeatingGroundTrackEquatorError calculation object."""
    _uuid = "{53C25A30-1C1E-42F0-AEA5-D67EF1037A18}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_reference_longitude"] = _raise_uninitialized_error
        self.__dict__["_set_reference_longitude"] = _raise_uninitialized_error
        self.__dict__["_get_repeat_count"] = _raise_uninitialized_error
        self.__dict__["_set_repeat_count"] = _raise_uninitialized_error
        self.__dict__["_enable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_disable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_is_control_parameter_enabled"] = _raise_uninitialized_error
        self.__dict__["_get_control_parameters_available"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcRepeatingGroundTrackErr._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcRepeatingGroundTrackErr from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcRepeatingGroundTrackErr = agcom.GUID(IStateCalcRepeatingGroundTrackErr._uuid)
        vtable_offset_local = IStateCalcRepeatingGroundTrackErr._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRepeatingGroundTrackErr, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRepeatingGroundTrackErr, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_reference_longitude"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRepeatingGroundTrackErr, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_set_reference_longitude"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRepeatingGroundTrackErr, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_get_repeat_count"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRepeatingGroundTrackErr, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_repeat_count"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRepeatingGroundTrackErr, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_enable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRepeatingGroundTrackErr, vtable_offset_local+7, agcom.LONG)
        self.__dict__["_disable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRepeatingGroundTrackErr, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_is_control_parameter_enabled"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRepeatingGroundTrackErr, vtable_offset_local+9, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_control_parameters_available"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRepeatingGroundTrackErr, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcRepeatingGroundTrackErr.__dict__ and type(IStateCalcRepeatingGroundTrackErr.__dict__[attrname]) == property:
            return IStateCalcRepeatingGroundTrackErr.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcRepeatingGroundTrackErr.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def reference_longitude(self) -> typing.Any:
        """The longitude at the equator to be used as a reference for the repeating ground track. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_longitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_longitude.setter
    def reference_longitude(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_longitude"](arg_inVal.COM_val))

    @property
    def repeat_count(self) -> float:
        """The number of orbits before the ground track repeats over the same longitude. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_repeat_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @repeat_count.setter
    def repeat_count(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_repeat_count"](arg_inVal.COM_val))

    def enable_control_parameter(self, param:"AgEVAControlRepeatingGroundTrackErr") -> None:
        """Enables the specified control parameter"""
        with agmarshall.AgEnum_arg(AgEVAControlRepeatingGroundTrackErr, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_enable_control_parameter"](arg_param.COM_val))

    def disable_control_parameter(self, param:"AgEVAControlRepeatingGroundTrackErr") -> None:
        """Disables the specified control parameter"""
        with agmarshall.AgEnum_arg(AgEVAControlRepeatingGroundTrackErr, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_disable_control_parameter"](arg_param.COM_val))

    def is_control_parameter_enabled(self, param:"AgEVAControlRepeatingGroundTrackErr") -> bool:
        """Sees if the specified control is enabled"""
        with agmarshall.AgEnum_arg(AgEVAControlRepeatingGroundTrackErr, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_is_control_parameter_enabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_parameters_available(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_parameters_available"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{53C25A30-1C1E-42F0-AEA5-D67EF1037A18}", IStateCalcRepeatingGroundTrackErr)
agcls.AgTypeNameMap["IStateCalcRepeatingGroundTrackErr"] = IStateCalcRepeatingGroundTrackErr

class IStateCalcAltitudeOfApoapsis(object):
    """Properties for an Altitude of Apoapsis calculation object."""
    _uuid = "{891F3D94-A765-42AE-9459-7575CD33E62E}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_element_type"] = _raise_uninitialized_error
        self.__dict__["_set_element_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcAltitudeOfApoapsis._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcAltitudeOfApoapsis from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcAltitudeOfApoapsis = agcom.GUID(IStateCalcAltitudeOfApoapsis._uuid)
        vtable_offset_local = IStateCalcAltitudeOfApoapsis._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcAltitudeOfApoapsis, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcAltitudeOfApoapsis, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcAltitudeOfApoapsis, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcAltitudeOfApoapsis, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcAltitudeOfApoapsis.__dict__ and type(IStateCalcAltitudeOfApoapsis.__dict__[attrname]) == property:
            return IStateCalcAltitudeOfApoapsis.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcAltitudeOfApoapsis.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def element_type(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_element_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @element_type.setter
    def element_type(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_element_type"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{891F3D94-A765-42AE-9459-7575CD33E62E}", IStateCalcAltitudeOfApoapsis)
agcls.AgTypeNameMap["IStateCalcAltitudeOfApoapsis"] = IStateCalcAltitudeOfApoapsis

class IStateCalcAltitudeOfPeriapsis(object):
    """Properties for an Altitude Of Periapsis calculation object."""
    _uuid = "{3A81E388-64C2-41BD-88FC-19E318F08D5C}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_element_type"] = _raise_uninitialized_error
        self.__dict__["_set_element_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcAltitudeOfPeriapsis._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcAltitudeOfPeriapsis from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcAltitudeOfPeriapsis = agcom.GUID(IStateCalcAltitudeOfPeriapsis._uuid)
        vtable_offset_local = IStateCalcAltitudeOfPeriapsis._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcAltitudeOfPeriapsis, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcAltitudeOfPeriapsis, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcAltitudeOfPeriapsis, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcAltitudeOfPeriapsis, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcAltitudeOfPeriapsis.__dict__ and type(IStateCalcAltitudeOfPeriapsis.__dict__[attrname]) == property:
            return IStateCalcAltitudeOfPeriapsis.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcAltitudeOfPeriapsis.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def element_type(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_element_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @element_type.setter
    def element_type(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_element_type"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3A81E388-64C2-41BD-88FC-19E318F08D5C}", IStateCalcAltitudeOfPeriapsis)
agcls.AgTypeNameMap["IStateCalcAltitudeOfPeriapsis"] = IStateCalcAltitudeOfPeriapsis

class IStateCalcArgOfLat(object):
    """Properties for an Argument of Latitude calculation object."""
    _uuid = "{C5B93283-1CEB-407C-837F-21BB7C8227BD}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_set_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_get_element_type"] = _raise_uninitialized_error
        self.__dict__["_set_element_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcArgOfLat._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcArgOfLat from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcArgOfLat = agcom.GUID(IStateCalcArgOfLat._uuid)
        vtable_offset_local = IStateCalcArgOfLat._vtable_offset - 1
        self.__dict__["_get_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcArgOfLat, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcArgOfLat, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcArgOfLat, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcArgOfLat, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcArgOfLat.__dict__ and type(IStateCalcArgOfLat.__dict__[attrname]) == property:
            return IStateCalcArgOfLat.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcArgOfLat.")
    
    @property
    def coord_system_name(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_system_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_system_name.setter
    def coord_system_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_system_name"](arg_inVal.COM_val))

    @property
    def element_type(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_element_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @element_type.setter
    def element_type(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_element_type"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{C5B93283-1CEB-407C-837F-21BB7C8227BD}", IStateCalcArgOfLat)
agcls.AgTypeNameMap["IStateCalcArgOfLat"] = IStateCalcArgOfLat

class IStateCalcArgOfPeriapsis(object):
    """Properties for an Argument of Periapsis calculation object."""
    _uuid = "{30364B7E-BBCE-4FCF-BC76-7330A97ECE0F}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_set_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_get_element_type"] = _raise_uninitialized_error
        self.__dict__["_set_element_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcArgOfPeriapsis._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcArgOfPeriapsis from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcArgOfPeriapsis = agcom.GUID(IStateCalcArgOfPeriapsis._uuid)
        vtable_offset_local = IStateCalcArgOfPeriapsis._vtable_offset - 1
        self.__dict__["_get_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcArgOfPeriapsis, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcArgOfPeriapsis, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcArgOfPeriapsis, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcArgOfPeriapsis, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcArgOfPeriapsis.__dict__ and type(IStateCalcArgOfPeriapsis.__dict__[attrname]) == property:
            return IStateCalcArgOfPeriapsis.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcArgOfPeriapsis.")
    
    @property
    def coord_system_name(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_system_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_system_name.setter
    def coord_system_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_system_name"](arg_inVal.COM_val))

    @property
    def element_type(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_element_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @element_type.setter
    def element_type(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_element_type"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{30364B7E-BBCE-4FCF-BC76-7330A97ECE0F}", IStateCalcArgOfPeriapsis)
agcls.AgTypeNameMap["IStateCalcArgOfPeriapsis"] = IStateCalcArgOfPeriapsis

class IStateCalcEccentricityAnomaly(object):
    """Properties for an Eccentric Anomaly calculation object."""
    _uuid = "{9655A1AA-233C-4E4C-9A2E-93B91A439947}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_element_type"] = _raise_uninitialized_error
        self.__dict__["_set_element_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcEccentricityAnomaly._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcEccentricityAnomaly from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcEccentricityAnomaly = agcom.GUID(IStateCalcEccentricityAnomaly._uuid)
        vtable_offset_local = IStateCalcEccentricityAnomaly._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcEccentricityAnomaly, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcEccentricityAnomaly, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcEccentricityAnomaly, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcEccentricityAnomaly, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcEccentricityAnomaly.__dict__ and type(IStateCalcEccentricityAnomaly.__dict__[attrname]) == property:
            return IStateCalcEccentricityAnomaly.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcEccentricityAnomaly.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def element_type(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_element_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @element_type.setter
    def element_type(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_element_type"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{9655A1AA-233C-4E4C-9A2E-93B91A439947}", IStateCalcEccentricityAnomaly)
agcls.AgTypeNameMap["IStateCalcEccentricityAnomaly"] = IStateCalcEccentricityAnomaly

class IStateCalcEccentricity(object):
    """Properties for an Eccentricity calculation object."""
    _uuid = "{3AE52837-A597-473A-83A2-9DC9B2271101}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_element_type"] = _raise_uninitialized_error
        self.__dict__["_set_element_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcEccentricity._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcEccentricity from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcEccentricity = agcom.GUID(IStateCalcEccentricity._uuid)
        vtable_offset_local = IStateCalcEccentricity._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcEccentricity, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcEccentricity, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcEccentricity, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcEccentricity, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcEccentricity.__dict__ and type(IStateCalcEccentricity.__dict__[attrname]) == property:
            return IStateCalcEccentricity.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcEccentricity.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def element_type(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_element_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @element_type.setter
    def element_type(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_element_type"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3AE52837-A597-473A-83A2-9DC9B2271101}", IStateCalcEccentricity)
agcls.AgTypeNameMap["IStateCalcEccentricity"] = IStateCalcEccentricity

class IStateCalcInclination(object):
    """Properties for an Inclination calculation object."""
    _uuid = "{477CF8AA-81BE-4C13-8F6D-7157268869A3}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_set_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_get_element_type"] = _raise_uninitialized_error
        self.__dict__["_set_element_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcInclination._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcInclination from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcInclination = agcom.GUID(IStateCalcInclination._uuid)
        vtable_offset_local = IStateCalcInclination._vtable_offset - 1
        self.__dict__["_get_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcInclination, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcInclination, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcInclination, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcInclination, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcInclination.__dict__ and type(IStateCalcInclination.__dict__[attrname]) == property:
            return IStateCalcInclination.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcInclination.")
    
    @property
    def coord_system_name(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_system_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_system_name.setter
    def coord_system_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_system_name"](arg_inVal.COM_val))

    @property
    def element_type(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_element_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @element_type.setter
    def element_type(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_element_type"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{477CF8AA-81BE-4C13-8F6D-7157268869A3}", IStateCalcInclination)
agcls.AgTypeNameMap["IStateCalcInclination"] = IStateCalcInclination

class IStateCalcLonOfAscNode(object):
    """Properties for a Longitude of Ascending Node calculation object."""
    _uuid = "{9A4EED12-F650-449B-B3C0-2278D58A8D92}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_element_type"] = _raise_uninitialized_error
        self.__dict__["_set_element_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcLonOfAscNode._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcLonOfAscNode from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcLonOfAscNode = agcom.GUID(IStateCalcLonOfAscNode._uuid)
        vtable_offset_local = IStateCalcLonOfAscNode._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcLonOfAscNode, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcLonOfAscNode, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcLonOfAscNode, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcLonOfAscNode, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcLonOfAscNode.__dict__ and type(IStateCalcLonOfAscNode.__dict__[attrname]) == property:
            return IStateCalcLonOfAscNode.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcLonOfAscNode.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def element_type(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_element_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @element_type.setter
    def element_type(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_element_type"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{9A4EED12-F650-449B-B3C0-2278D58A8D92}", IStateCalcLonOfAscNode)
agcls.AgTypeNameMap["IStateCalcLonOfAscNode"] = IStateCalcLonOfAscNode

class IStateCalcMeanAnomaly(object):
    """Properties for a MeanAnomaly calculation object."""
    _uuid = "{2E620A15-C918-467A-A8C3-817BF13FC602}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_element_type"] = _raise_uninitialized_error
        self.__dict__["_set_element_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcMeanAnomaly._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcMeanAnomaly from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcMeanAnomaly = agcom.GUID(IStateCalcMeanAnomaly._uuid)
        vtable_offset_local = IStateCalcMeanAnomaly._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcMeanAnomaly, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcMeanAnomaly, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcMeanAnomaly, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcMeanAnomaly, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcMeanAnomaly.__dict__ and type(IStateCalcMeanAnomaly.__dict__[attrname]) == property:
            return IStateCalcMeanAnomaly.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcMeanAnomaly.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def element_type(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_element_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @element_type.setter
    def element_type(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_element_type"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2E620A15-C918-467A-A8C3-817BF13FC602}", IStateCalcMeanAnomaly)
agcls.AgTypeNameMap["IStateCalcMeanAnomaly"] = IStateCalcMeanAnomaly

class IStateCalcMeanMotion(object):
    """Properties for a Mean Motion calculation object."""
    _uuid = "{3CF417E4-9A1B-492B-BEA8-A019896B26E9}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_element_type"] = _raise_uninitialized_error
        self.__dict__["_set_element_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcMeanMotion._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcMeanMotion from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcMeanMotion = agcom.GUID(IStateCalcMeanMotion._uuid)
        vtable_offset_local = IStateCalcMeanMotion._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcMeanMotion, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcMeanMotion, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcMeanMotion, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcMeanMotion, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcMeanMotion.__dict__ and type(IStateCalcMeanMotion.__dict__[attrname]) == property:
            return IStateCalcMeanMotion.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcMeanMotion.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def element_type(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_element_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @element_type.setter
    def element_type(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_element_type"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3CF417E4-9A1B-492B-BEA8-A019896B26E9}", IStateCalcMeanMotion)
agcls.AgTypeNameMap["IStateCalcMeanMotion"] = IStateCalcMeanMotion

class IStateCalcOrbitPeriod(object):
    """Properties for an Orbit Period calculation object."""
    _uuid = "{C108486C-571C-4007-9EFD-70CD8745C3D5}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_element_type"] = _raise_uninitialized_error
        self.__dict__["_set_element_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcOrbitPeriod._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcOrbitPeriod from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcOrbitPeriod = agcom.GUID(IStateCalcOrbitPeriod._uuid)
        vtable_offset_local = IStateCalcOrbitPeriod._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitPeriod, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitPeriod, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitPeriod, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitPeriod, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcOrbitPeriod.__dict__ and type(IStateCalcOrbitPeriod.__dict__[attrname]) == property:
            return IStateCalcOrbitPeriod.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcOrbitPeriod.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def element_type(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_element_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @element_type.setter
    def element_type(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_element_type"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{C108486C-571C-4007-9EFD-70CD8745C3D5}", IStateCalcOrbitPeriod)
agcls.AgTypeNameMap["IStateCalcOrbitPeriod"] = IStateCalcOrbitPeriod

class IStateCalcNumRevs(object):
    """Properties for a Number of Revolutions calculation object."""
    _uuid = "{A9FF9984-5A98-44F1-A231-10C3F26A1082}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_element_type"] = _raise_uninitialized_error
        self.__dict__["_set_element_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcNumRevs._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcNumRevs from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcNumRevs = agcom.GUID(IStateCalcNumRevs._uuid)
        vtable_offset_local = IStateCalcNumRevs._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcNumRevs, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcNumRevs, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcNumRevs, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcNumRevs, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcNumRevs.__dict__ and type(IStateCalcNumRevs.__dict__[attrname]) == property:
            return IStateCalcNumRevs.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcNumRevs.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def element_type(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_element_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @element_type.setter
    def element_type(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_element_type"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{A9FF9984-5A98-44F1-A231-10C3F26A1082}", IStateCalcNumRevs)
agcls.AgTypeNameMap["IStateCalcNumRevs"] = IStateCalcNumRevs

class IStateCalcRAAN(object):
    """Properties for a RAAN calculation object."""
    _uuid = "{B2456E5C-7305-4AAD-8318-7A65D65C328A}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_set_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_get_element_type"] = _raise_uninitialized_error
        self.__dict__["_set_element_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcRAAN._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcRAAN from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcRAAN = agcom.GUID(IStateCalcRAAN._uuid)
        vtable_offset_local = IStateCalcRAAN._vtable_offset - 1
        self.__dict__["_get_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRAAN, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRAAN, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRAAN, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRAAN, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcRAAN.__dict__ and type(IStateCalcRAAN.__dict__[attrname]) == property:
            return IStateCalcRAAN.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcRAAN.")
    
    @property
    def coord_system_name(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_system_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_system_name.setter
    def coord_system_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_system_name"](arg_inVal.COM_val))

    @property
    def element_type(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_element_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @element_type.setter
    def element_type(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_element_type"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{B2456E5C-7305-4AAD-8318-7A65D65C328A}", IStateCalcRAAN)
agcls.AgTypeNameMap["IStateCalcRAAN"] = IStateCalcRAAN

class IStateCalcRadOfApoapsis(object):
    """Properties for a Radius Of Apoapsis calculation object."""
    _uuid = "{2B481148-138F-44EA-9EE2-03FC7FA82CEC}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_element_type"] = _raise_uninitialized_error
        self.__dict__["_set_element_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcRadOfApoapsis._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcRadOfApoapsis from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcRadOfApoapsis = agcom.GUID(IStateCalcRadOfApoapsis._uuid)
        vtable_offset_local = IStateCalcRadOfApoapsis._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRadOfApoapsis, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRadOfApoapsis, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRadOfApoapsis, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRadOfApoapsis, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcRadOfApoapsis.__dict__ and type(IStateCalcRadOfApoapsis.__dict__[attrname]) == property:
            return IStateCalcRadOfApoapsis.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcRadOfApoapsis.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def element_type(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_element_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @element_type.setter
    def element_type(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_element_type"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2B481148-138F-44EA-9EE2-03FC7FA82CEC}", IStateCalcRadOfApoapsis)
agcls.AgTypeNameMap["IStateCalcRadOfApoapsis"] = IStateCalcRadOfApoapsis

class IStateCalcRadOfPeriapsis(object):
    """Properties for a Radius Of Periapsis calculation object."""
    _uuid = "{8AF6B875-ED5E-4734-B98B-17B03203FFE8}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_element_type"] = _raise_uninitialized_error
        self.__dict__["_set_element_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcRadOfPeriapsis._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcRadOfPeriapsis from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcRadOfPeriapsis = agcom.GUID(IStateCalcRadOfPeriapsis._uuid)
        vtable_offset_local = IStateCalcRadOfPeriapsis._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRadOfPeriapsis, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRadOfPeriapsis, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRadOfPeriapsis, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRadOfPeriapsis, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcRadOfPeriapsis.__dict__ and type(IStateCalcRadOfPeriapsis.__dict__[attrname]) == property:
            return IStateCalcRadOfPeriapsis.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcRadOfPeriapsis.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def element_type(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_element_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @element_type.setter
    def element_type(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_element_type"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{8AF6B875-ED5E-4734-B98B-17B03203FFE8}", IStateCalcRadOfPeriapsis)
agcls.AgTypeNameMap["IStateCalcRadOfPeriapsis"] = IStateCalcRadOfPeriapsis

class IStateCalcSemiMajorAxis(object):
    """Properties for a Semimajor Axis calculation object."""
    _uuid = "{0DC03521-C37A-4D96-A820-E0D19835C7DF}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_element_type"] = _raise_uninitialized_error
        self.__dict__["_set_element_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcSemiMajorAxis._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcSemiMajorAxis from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcSemiMajorAxis = agcom.GUID(IStateCalcSemiMajorAxis._uuid)
        vtable_offset_local = IStateCalcSemiMajorAxis._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSemiMajorAxis, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSemiMajorAxis, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSemiMajorAxis, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSemiMajorAxis, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcSemiMajorAxis.__dict__ and type(IStateCalcSemiMajorAxis.__dict__[attrname]) == property:
            return IStateCalcSemiMajorAxis.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcSemiMajorAxis.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def element_type(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_element_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @element_type.setter
    def element_type(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_element_type"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{0DC03521-C37A-4D96-A820-E0D19835C7DF}", IStateCalcSemiMajorAxis)
agcls.AgTypeNameMap["IStateCalcSemiMajorAxis"] = IStateCalcSemiMajorAxis

class IStateCalcTimePastAscNode(object):
    """Properties for a Time Past Ascending Node calculation object."""
    _uuid = "{4ED0F733-4995-4D32-8533-D7A1801C4FBB}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_set_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_get_element_type"] = _raise_uninitialized_error
        self.__dict__["_set_element_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcTimePastAscNode._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcTimePastAscNode from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcTimePastAscNode = agcom.GUID(IStateCalcTimePastAscNode._uuid)
        vtable_offset_local = IStateCalcTimePastAscNode._vtable_offset - 1
        self.__dict__["_get_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcTimePastAscNode, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcTimePastAscNode, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcTimePastAscNode, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcTimePastAscNode, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcTimePastAscNode.__dict__ and type(IStateCalcTimePastAscNode.__dict__[attrname]) == property:
            return IStateCalcTimePastAscNode.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcTimePastAscNode.")
    
    @property
    def coord_system_name(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_system_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_system_name.setter
    def coord_system_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_system_name"](arg_inVal.COM_val))

    @property
    def element_type(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_element_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @element_type.setter
    def element_type(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_element_type"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4ED0F733-4995-4D32-8533-D7A1801C4FBB}", IStateCalcTimePastAscNode)
agcls.AgTypeNameMap["IStateCalcTimePastAscNode"] = IStateCalcTimePastAscNode

class IStateCalcTimePastPeriapsis(object):
    """Properties for a Time Past Periapsis calculation object."""
    _uuid = "{30BCAEF0-2921-4EE5-B047-79CA370F9C83}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_element_type"] = _raise_uninitialized_error
        self.__dict__["_set_element_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcTimePastPeriapsis._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcTimePastPeriapsis from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcTimePastPeriapsis = agcom.GUID(IStateCalcTimePastPeriapsis._uuid)
        vtable_offset_local = IStateCalcTimePastPeriapsis._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcTimePastPeriapsis, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcTimePastPeriapsis, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcTimePastPeriapsis, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcTimePastPeriapsis, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcTimePastPeriapsis.__dict__ and type(IStateCalcTimePastPeriapsis.__dict__[attrname]) == property:
            return IStateCalcTimePastPeriapsis.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcTimePastPeriapsis.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def element_type(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_element_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @element_type.setter
    def element_type(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_element_type"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{30BCAEF0-2921-4EE5-B047-79CA370F9C83}", IStateCalcTimePastPeriapsis)
agcls.AgTypeNameMap["IStateCalcTimePastPeriapsis"] = IStateCalcTimePastPeriapsis

class IStateCalcDeltaV(object):
    """Properties for a DeltaV calculation object."""
    _uuid = "{F6E77B5A-1A44-4CD0-A0BF-2991C1A33EBA}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcDeltaV._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcDeltaV from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcDeltaV = agcom.GUID(IStateCalcDeltaV._uuid)
        vtable_offset_local = IStateCalcDeltaV._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcDeltaV.__dict__ and type(IStateCalcDeltaV.__dict__[attrname]) == property:
            return IStateCalcDeltaV.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcDeltaV.")
    

agcls.AgClassCatalog.add_catalog_entry("{F6E77B5A-1A44-4CD0-A0BF-2991C1A33EBA}", IStateCalcDeltaV)
agcls.AgTypeNameMap["IStateCalcDeltaV"] = IStateCalcDeltaV

class IStateCalcDeltaVSquared(object):
    """Properties for a DeltaV Squared calculation object."""
    _uuid = "{52506197-B072-4F2A-A1E6-10728D969E2A}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcDeltaVSquared._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcDeltaVSquared from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcDeltaVSquared = agcom.GUID(IStateCalcDeltaVSquared._uuid)
        vtable_offset_local = IStateCalcDeltaVSquared._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcDeltaVSquared.__dict__ and type(IStateCalcDeltaVSquared.__dict__[attrname]) == property:
            return IStateCalcDeltaVSquared.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcDeltaVSquared.")
    

agcls.AgClassCatalog.add_catalog_entry("{52506197-B072-4F2A-A1E6-10728D969E2A}", IStateCalcDeltaVSquared)
agcls.AgTypeNameMap["IStateCalcDeltaVSquared"] = IStateCalcDeltaVSquared

class IStateCalcMissionControlSequenceDeltaV(object):
    """Properties for a MCS DeltaV calculation object."""
    _uuid = "{6411CC14-1207-49C7-ACEF-31EC24908D59}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcMissionControlSequenceDeltaV._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcMissionControlSequenceDeltaV from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcMissionControlSequenceDeltaV = agcom.GUID(IStateCalcMissionControlSequenceDeltaV._uuid)
        vtable_offset_local = IStateCalcMissionControlSequenceDeltaV._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcMissionControlSequenceDeltaV.__dict__ and type(IStateCalcMissionControlSequenceDeltaV.__dict__[attrname]) == property:
            return IStateCalcMissionControlSequenceDeltaV.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcMissionControlSequenceDeltaV.")
    

agcls.AgClassCatalog.add_catalog_entry("{6411CC14-1207-49C7-ACEF-31EC24908D59}", IStateCalcMissionControlSequenceDeltaV)
agcls.AgTypeNameMap["IStateCalcMissionControlSequenceDeltaV"] = IStateCalcMissionControlSequenceDeltaV

class IStateCalcMissionControlSequenceDeltaVSquared(object):
    """Properties for a MCS DeltaV Squared calculation object."""
    _uuid = "{17C279CA-79C4-4076-AF85-6018DA3FAB83}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_squared_type"] = _raise_uninitialized_error
        self.__dict__["_set_squared_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcMissionControlSequenceDeltaVSquared._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcMissionControlSequenceDeltaVSquared from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcMissionControlSequenceDeltaVSquared = agcom.GUID(IStateCalcMissionControlSequenceDeltaVSquared._uuid)
        vtable_offset_local = IStateCalcMissionControlSequenceDeltaVSquared._vtable_offset - 1
        self.__dict__["_get_squared_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcMissionControlSequenceDeltaVSquared, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_squared_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcMissionControlSequenceDeltaVSquared, vtable_offset_local+2, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcMissionControlSequenceDeltaVSquared.__dict__ and type(IStateCalcMissionControlSequenceDeltaVSquared.__dict__[attrname]) == property:
            return IStateCalcMissionControlSequenceDeltaVSquared.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcMissionControlSequenceDeltaVSquared.")
    
    @property
    def squared_type(self) -> "AgEVASquaredType":
        """Whether the value should be calculated as the sum of the squares of the maneuver Delta-Vs or the square of the sum of the maneuver Delta-Vs."""
        with agmarshall.AgEnum_arg(AgEVASquaredType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_squared_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @squared_type.setter
    def squared_type(self, inVal:"AgEVASquaredType") -> None:
        """Whether the value should be calculated as the sum of the squares of the maneuver Delta-Vs or the square of the sum of the maneuver Delta-Vs."""
        with agmarshall.AgEnum_arg(AgEVASquaredType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_squared_type"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{17C279CA-79C4-4076-AF85-6018DA3FAB83}", IStateCalcMissionControlSequenceDeltaVSquared)
agcls.AgTypeNameMap["IStateCalcMissionControlSequenceDeltaVSquared"] = IStateCalcMissionControlSequenceDeltaVSquared

class IStateCalcSequenceDeltaV(object):
    """Properties for a Sequence DeltaV calculation object."""
    _uuid = "{0F7BEE65-4F80-404D-AA99-1F92F88E2525}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_sequence_name"] = _raise_uninitialized_error
        self.__dict__["_set_sequence_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcSequenceDeltaV._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcSequenceDeltaV from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcSequenceDeltaV = agcom.GUID(IStateCalcSequenceDeltaV._uuid)
        vtable_offset_local = IStateCalcSequenceDeltaV._vtable_offset - 1
        self.__dict__["_get_sequence_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSequenceDeltaV, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_sequence_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSequenceDeltaV, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcSequenceDeltaV.__dict__ and type(IStateCalcSequenceDeltaV.__dict__[attrname]) == property:
            return IStateCalcSequenceDeltaV.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcSequenceDeltaV.")
    
    @property
    def sequence_name(self) -> str:
        """The sequence whose DeltaV's are to be summed."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sequence_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sequence_name.setter
    def sequence_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_sequence_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{0F7BEE65-4F80-404D-AA99-1F92F88E2525}", IStateCalcSequenceDeltaV)
agcls.AgTypeNameMap["IStateCalcSequenceDeltaV"] = IStateCalcSequenceDeltaV

class IStateCalcSequenceDeltaVSquared(object):
    """Properties for a Sequence DeltaV Squared calculation object."""
    _uuid = "{D6D37B91-EDAE-4E35-865F-538C2155A239}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_sequence_name"] = _raise_uninitialized_error
        self.__dict__["_set_sequence_name"] = _raise_uninitialized_error
        self.__dict__["_get_squared_type"] = _raise_uninitialized_error
        self.__dict__["_set_squared_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcSequenceDeltaVSquared._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcSequenceDeltaVSquared from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcSequenceDeltaVSquared = agcom.GUID(IStateCalcSequenceDeltaVSquared._uuid)
        vtable_offset_local = IStateCalcSequenceDeltaVSquared._vtable_offset - 1
        self.__dict__["_get_sequence_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSequenceDeltaVSquared, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_sequence_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSequenceDeltaVSquared, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_squared_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSequenceDeltaVSquared, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_squared_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSequenceDeltaVSquared, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcSequenceDeltaVSquared.__dict__ and type(IStateCalcSequenceDeltaVSquared.__dict__[attrname]) == property:
            return IStateCalcSequenceDeltaVSquared.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcSequenceDeltaVSquared.")
    
    @property
    def sequence_name(self) -> str:
        """The sequence whose DeltaV's are to be accumulated."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sequence_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sequence_name.setter
    def sequence_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_sequence_name"](arg_inVal.COM_val))

    @property
    def squared_type(self) -> "AgEVASquaredType":
        """Whether the value should be calculated as the sum of the squares of the maneuver Delta-Vs or the square of the sum of the maneuver Delta-Vs."""
        with agmarshall.AgEnum_arg(AgEVASquaredType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_squared_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @squared_type.setter
    def squared_type(self, inVal:"AgEVASquaredType") -> None:
        """Whether the value should be calculated as the sum of the squares of the maneuver Delta-Vs or the square of the sum of the maneuver Delta-Vs."""
        with agmarshall.AgEnum_arg(AgEVASquaredType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_squared_type"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{D6D37B91-EDAE-4E35-865F-538C2155A239}", IStateCalcSequenceDeltaVSquared)
agcls.AgTypeNameMap["IStateCalcSequenceDeltaVSquared"] = IStateCalcSequenceDeltaVSquared

class IStateCalcFuelMass(object):
    """Properties for a FuelMass calculation object."""
    _uuid = "{2707D8D8-8D1E-477D-B246-0568788FE867}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcFuelMass._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcFuelMass from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcFuelMass = agcom.GUID(IStateCalcFuelMass._uuid)
        vtable_offset_local = IStateCalcFuelMass._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcFuelMass.__dict__ and type(IStateCalcFuelMass.__dict__[attrname]) == property:
            return IStateCalcFuelMass.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcFuelMass.")
    

agcls.AgClassCatalog.add_catalog_entry("{2707D8D8-8D1E-477D-B246-0568788FE867}", IStateCalcFuelMass)
agcls.AgTypeNameMap["IStateCalcFuelMass"] = IStateCalcFuelMass

class IStateCalcDensity(object):
    """Properties for a Fuel Density calculation object."""
    _uuid = "{9AE849EC-D75D-45A2-A23A-404C041BDB7B}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcDensity._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcDensity from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcDensity = agcom.GUID(IStateCalcDensity._uuid)
        vtable_offset_local = IStateCalcDensity._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcDensity.__dict__ and type(IStateCalcDensity.__dict__[attrname]) == property:
            return IStateCalcDensity.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcDensity.")
    

agcls.AgClassCatalog.add_catalog_entry("{9AE849EC-D75D-45A2-A23A-404C041BDB7B}", IStateCalcDensity)
agcls.AgTypeNameMap["IStateCalcDensity"] = IStateCalcDensity

class IStateCalcInertialDeltaVMagnitude(object):
    """Properties for an Inertial DeltaV Magnitude calculation object."""
    _uuid = "{206A8426-8860-4E7B-A0A1-0C1A8D4A79C5}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcInertialDeltaVMagnitude._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcInertialDeltaVMagnitude from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcInertialDeltaVMagnitude = agcom.GUID(IStateCalcInertialDeltaVMagnitude._uuid)
        vtable_offset_local = IStateCalcInertialDeltaVMagnitude._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcInertialDeltaVMagnitude.__dict__ and type(IStateCalcInertialDeltaVMagnitude.__dict__[attrname]) == property:
            return IStateCalcInertialDeltaVMagnitude.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcInertialDeltaVMagnitude.")
    

agcls.AgClassCatalog.add_catalog_entry("{206A8426-8860-4E7B-A0A1-0C1A8D4A79C5}", IStateCalcInertialDeltaVMagnitude)
agcls.AgTypeNameMap["IStateCalcInertialDeltaVMagnitude"] = IStateCalcInertialDeltaVMagnitude

class IStateCalcInertialDeltaVx(object):
    """Properties for an Inertial DeltaVx calculation object."""
    _uuid = "{D18A9666-512E-476E-89C0-FF6B2D3C2428}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_coord_axes_name"] = _raise_uninitialized_error
        self.__dict__["_set_coord_axes_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcInertialDeltaVx._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcInertialDeltaVx from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcInertialDeltaVx = agcom.GUID(IStateCalcInertialDeltaVx._uuid)
        vtable_offset_local = IStateCalcInertialDeltaVx._vtable_offset - 1
        self.__dict__["_get_coord_axes_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcInertialDeltaVx, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_coord_axes_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcInertialDeltaVx, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcInertialDeltaVx.__dict__ and type(IStateCalcInertialDeltaVx.__dict__[attrname]) == property:
            return IStateCalcInertialDeltaVx.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcInertialDeltaVx.")
    
    @property
    def coord_axes_name(self) -> str:
        """The coordinate axes."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_axes_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_axes_name.setter
    def coord_axes_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_axes_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{D18A9666-512E-476E-89C0-FF6B2D3C2428}", IStateCalcInertialDeltaVx)
agcls.AgTypeNameMap["IStateCalcInertialDeltaVx"] = IStateCalcInertialDeltaVx

class IStateCalcInertialDeltaVy(object):
    """Properties for an Inertial DeltaVy calculation object."""
    _uuid = "{4A5489A4-1EDC-4CD1-BF9F-EAF779ECFFD3}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_coord_axes_name"] = _raise_uninitialized_error
        self.__dict__["_set_coord_axes_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcInertialDeltaVy._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcInertialDeltaVy from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcInertialDeltaVy = agcom.GUID(IStateCalcInertialDeltaVy._uuid)
        vtable_offset_local = IStateCalcInertialDeltaVy._vtable_offset - 1
        self.__dict__["_get_coord_axes_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcInertialDeltaVy, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_coord_axes_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcInertialDeltaVy, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcInertialDeltaVy.__dict__ and type(IStateCalcInertialDeltaVy.__dict__[attrname]) == property:
            return IStateCalcInertialDeltaVy.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcInertialDeltaVy.")
    
    @property
    def coord_axes_name(self) -> str:
        """The coordinate axes."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_axes_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_axes_name.setter
    def coord_axes_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_axes_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4A5489A4-1EDC-4CD1-BF9F-EAF779ECFFD3}", IStateCalcInertialDeltaVy)
agcls.AgTypeNameMap["IStateCalcInertialDeltaVy"] = IStateCalcInertialDeltaVy

class IStateCalcInertialDeltaVz(object):
    """Properties for an Inertial DeltaVz calculation object."""
    _uuid = "{4301E169-DEE2-411A-9DBD-06DEC30F9EBD}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_coord_axes_name"] = _raise_uninitialized_error
        self.__dict__["_set_coord_axes_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcInertialDeltaVz._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcInertialDeltaVz from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcInertialDeltaVz = agcom.GUID(IStateCalcInertialDeltaVz._uuid)
        vtable_offset_local = IStateCalcInertialDeltaVz._vtable_offset - 1
        self.__dict__["_get_coord_axes_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcInertialDeltaVz, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_coord_axes_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcInertialDeltaVz, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcInertialDeltaVz.__dict__ and type(IStateCalcInertialDeltaVz.__dict__[attrname]) == property:
            return IStateCalcInertialDeltaVz.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcInertialDeltaVz.")
    
    @property
    def coord_axes_name(self) -> str:
        """The coordinate axes."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_axes_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_axes_name.setter
    def coord_axes_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_axes_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4301E169-DEE2-411A-9DBD-06DEC30F9EBD}", IStateCalcInertialDeltaVz)
agcls.AgTypeNameMap["IStateCalcInertialDeltaVz"] = IStateCalcInertialDeltaVz

class IStateCalcManeuverSpecificImpulse(object):
    """Properties for a Specific Impulse calculation object."""
    _uuid = "{4EA5927D-76E7-405C-AA5A-903C19B576DC}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcManeuverSpecificImpulse._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcManeuverSpecificImpulse from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcManeuverSpecificImpulse = agcom.GUID(IStateCalcManeuverSpecificImpulse._uuid)
        vtable_offset_local = IStateCalcManeuverSpecificImpulse._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcManeuverSpecificImpulse.__dict__ and type(IStateCalcManeuverSpecificImpulse.__dict__[attrname]) == property:
            return IStateCalcManeuverSpecificImpulse.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcManeuverSpecificImpulse.")
    

agcls.AgClassCatalog.add_catalog_entry("{4EA5927D-76E7-405C-AA5A-903C19B576DC}", IStateCalcManeuverSpecificImpulse)
agcls.AgTypeNameMap["IStateCalcManeuverSpecificImpulse"] = IStateCalcManeuverSpecificImpulse

class IStateCalcPressure(object):
    """Properties for a Tank Pressure calculation object."""
    _uuid = "{C37E82D4-7AA9-4BA0-92DA-1372268F63D6}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcPressure._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcPressure from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcPressure = agcom.GUID(IStateCalcPressure._uuid)
        vtable_offset_local = IStateCalcPressure._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcPressure.__dict__ and type(IStateCalcPressure.__dict__[attrname]) == property:
            return IStateCalcPressure.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcPressure.")
    

agcls.AgClassCatalog.add_catalog_entry("{C37E82D4-7AA9-4BA0-92DA-1372268F63D6}", IStateCalcPressure)
agcls.AgTypeNameMap["IStateCalcPressure"] = IStateCalcPressure

class IStateCalcTemperature(object):
    """Properties for a Tank Temperature calculation object."""
    _uuid = "{E0EC7C19-B337-4BFD-9A8B-30A88784D697}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcTemperature._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcTemperature from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcTemperature = agcom.GUID(IStateCalcTemperature._uuid)
        vtable_offset_local = IStateCalcTemperature._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcTemperature.__dict__ and type(IStateCalcTemperature.__dict__[attrname]) == property:
            return IStateCalcTemperature.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcTemperature.")
    

agcls.AgClassCatalog.add_catalog_entry("{E0EC7C19-B337-4BFD-9A8B-30A88784D697}", IStateCalcTemperature)
agcls.AgTypeNameMap["IStateCalcTemperature"] = IStateCalcTemperature

class IStateCalcVectorX(object):
    """Properties for a Vector X calculation object."""
    _uuid = "{ADD32358-B55C-4758-BBB9-391728F24BB8}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_coord_axes_name"] = _raise_uninitialized_error
        self.__dict__["_set_coord_axes_name"] = _raise_uninitialized_error
        self.__dict__["_get_vector_name"] = _raise_uninitialized_error
        self.__dict__["_set_vector_name"] = _raise_uninitialized_error
        self.__dict__["_get_unit_dimension"] = _raise_uninitialized_error
        self.__dict__["_set_unit_dimension"] = _raise_uninitialized_error
        self.__dict__["_get_normalize"] = _raise_uninitialized_error
        self.__dict__["_set_normalize"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcVectorX._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcVectorX from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcVectorX = agcom.GUID(IStateCalcVectorX._uuid)
        vtable_offset_local = IStateCalcVectorX._vtable_offset - 1
        self.__dict__["_get_coord_axes_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorX, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_coord_axes_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorX, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_vector_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorX, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_vector_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorX, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_get_unit_dimension"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorX, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_set_unit_dimension"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorX, vtable_offset_local+6, agcom.BSTR)
        self.__dict__["_get_normalize"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorX, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_normalize"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorX, vtable_offset_local+8, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcVectorX.__dict__ and type(IStateCalcVectorX.__dict__[attrname]) == property:
            return IStateCalcVectorX.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcVectorX.")
    
    @property
    def coord_axes_name(self) -> str:
        """The coordinate axes."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_axes_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_axes_name.setter
    def coord_axes_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_axes_name"](arg_inVal.COM_val))

    @property
    def vector_name(self) -> str:
        """The vector."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_vector_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @vector_name.setter
    def vector_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_vector_name"](arg_inVal.COM_val))

    @property
    def unit_dimension(self) -> str:
        """The unit dimension."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_unit_dimension"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @unit_dimension.setter
    def unit_dimension(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_unit_dimension"](arg_inVal.COM_val))

    @property
    def normalize(self) -> bool:
        """If true, return the normalized magnitude."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_normalize"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @normalize.setter
    def normalize(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_normalize"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{ADD32358-B55C-4758-BBB9-391728F24BB8}", IStateCalcVectorX)
agcls.AgTypeNameMap["IStateCalcVectorX"] = IStateCalcVectorX

class IStateCalcVectorY(object):
    """Properties for a Vector Y calculation object."""
    _uuid = "{BCF6F352-A2ED-491B-9961-5A164D6B5388}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_coord_axes_name"] = _raise_uninitialized_error
        self.__dict__["_set_coord_axes_name"] = _raise_uninitialized_error
        self.__dict__["_get_vector_name"] = _raise_uninitialized_error
        self.__dict__["_set_vector_name"] = _raise_uninitialized_error
        self.__dict__["_get_unit_dimension"] = _raise_uninitialized_error
        self.__dict__["_set_unit_dimension"] = _raise_uninitialized_error
        self.__dict__["_get_normalize"] = _raise_uninitialized_error
        self.__dict__["_set_normalize"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcVectorY._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcVectorY from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcVectorY = agcom.GUID(IStateCalcVectorY._uuid)
        vtable_offset_local = IStateCalcVectorY._vtable_offset - 1
        self.__dict__["_get_coord_axes_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorY, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_coord_axes_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorY, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_vector_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorY, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_vector_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorY, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_get_unit_dimension"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorY, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_set_unit_dimension"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorY, vtable_offset_local+6, agcom.BSTR)
        self.__dict__["_get_normalize"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorY, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_normalize"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorY, vtable_offset_local+8, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcVectorY.__dict__ and type(IStateCalcVectorY.__dict__[attrname]) == property:
            return IStateCalcVectorY.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcVectorY.")
    
    @property
    def coord_axes_name(self) -> str:
        """The coordinate axes."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_axes_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_axes_name.setter
    def coord_axes_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_axes_name"](arg_inVal.COM_val))

    @property
    def vector_name(self) -> str:
        """The vector."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_vector_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @vector_name.setter
    def vector_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_vector_name"](arg_inVal.COM_val))

    @property
    def unit_dimension(self) -> str:
        """The unit dimension."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_unit_dimension"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @unit_dimension.setter
    def unit_dimension(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_unit_dimension"](arg_inVal.COM_val))

    @property
    def normalize(self) -> bool:
        """If true, return the normalized magnitude."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_normalize"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @normalize.setter
    def normalize(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_normalize"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{BCF6F352-A2ED-491B-9961-5A164D6B5388}", IStateCalcVectorY)
agcls.AgTypeNameMap["IStateCalcVectorY"] = IStateCalcVectorY

class IStateCalcVectorZ(object):
    """Properties for a Vector Z calculation object."""
    _uuid = "{7F7E2A8A-7A33-48E3-A622-1A23E2672102}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_coord_axes_name"] = _raise_uninitialized_error
        self.__dict__["_set_coord_axes_name"] = _raise_uninitialized_error
        self.__dict__["_get_vector_name"] = _raise_uninitialized_error
        self.__dict__["_set_vector_name"] = _raise_uninitialized_error
        self.__dict__["_get_unit_dimension"] = _raise_uninitialized_error
        self.__dict__["_set_unit_dimension"] = _raise_uninitialized_error
        self.__dict__["_get_normalize"] = _raise_uninitialized_error
        self.__dict__["_set_normalize"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcVectorZ._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcVectorZ from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcVectorZ = agcom.GUID(IStateCalcVectorZ._uuid)
        vtable_offset_local = IStateCalcVectorZ._vtable_offset - 1
        self.__dict__["_get_coord_axes_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorZ, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_coord_axes_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorZ, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_vector_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorZ, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_vector_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorZ, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_get_unit_dimension"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorZ, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_set_unit_dimension"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorZ, vtable_offset_local+6, agcom.BSTR)
        self.__dict__["_get_normalize"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorZ, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_normalize"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorZ, vtable_offset_local+8, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcVectorZ.__dict__ and type(IStateCalcVectorZ.__dict__[attrname]) == property:
            return IStateCalcVectorZ.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcVectorZ.")
    
    @property
    def coord_axes_name(self) -> str:
        """The coordinate axes."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_axes_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_axes_name.setter
    def coord_axes_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_axes_name"](arg_inVal.COM_val))

    @property
    def vector_name(self) -> str:
        """The vector."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_vector_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @vector_name.setter
    def vector_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_vector_name"](arg_inVal.COM_val))

    @property
    def unit_dimension(self) -> str:
        """The unit dimension."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_unit_dimension"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @unit_dimension.setter
    def unit_dimension(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_unit_dimension"](arg_inVal.COM_val))

    @property
    def normalize(self) -> bool:
        """If true, return the normalized magnitude."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_normalize"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @normalize.setter
    def normalize(self, newVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_normalize"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7F7E2A8A-7A33-48E3-A622-1A23E2672102}", IStateCalcVectorZ)
agcls.AgTypeNameMap["IStateCalcVectorZ"] = IStateCalcVectorZ

class IStateCalcMass(object):
    """Properties for a Total Mass calculation object."""
    _uuid = "{1C324BE8-C857-42F2-AFA9-88AD686E53CE}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcMass._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcMass from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcMass = agcom.GUID(IStateCalcMass._uuid)
        vtable_offset_local = IStateCalcMass._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcMass.__dict__ and type(IStateCalcMass.__dict__[attrname]) == property:
            return IStateCalcMass.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcMass.")
    

agcls.AgClassCatalog.add_catalog_entry("{1C324BE8-C857-42F2-AFA9-88AD686E53CE}", IStateCalcMass)
agcls.AgTypeNameMap["IStateCalcMass"] = IStateCalcMass

class IStateCalcManeuverTotalMassFlowRate(object):
    """Properties for a Total Mass Flow Rate calculation object."""
    _uuid = "{DFD18CDB-7478-4CB0-86B3-46870753D290}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcManeuverTotalMassFlowRate._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcManeuverTotalMassFlowRate from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcManeuverTotalMassFlowRate = agcom.GUID(IStateCalcManeuverTotalMassFlowRate._uuid)
        vtable_offset_local = IStateCalcManeuverTotalMassFlowRate._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcManeuverTotalMassFlowRate.__dict__ and type(IStateCalcManeuverTotalMassFlowRate.__dict__[attrname]) == property:
            return IStateCalcManeuverTotalMassFlowRate.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcManeuverTotalMassFlowRate.")
    

agcls.AgClassCatalog.add_catalog_entry("{DFD18CDB-7478-4CB0-86B3-46870753D290}", IStateCalcManeuverTotalMassFlowRate)
agcls.AgTypeNameMap["IStateCalcManeuverTotalMassFlowRate"] = IStateCalcManeuverTotalMassFlowRate

class IStateCalcAbsoluteValue(object):
    """Properties for an Absolute Value calculation object."""
    _uuid = "{214DD350-1B42-48C1-9720-66D109A5376B}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_calc_object_name"] = _raise_uninitialized_error
        self.__dict__["_set_calc_object_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcAbsoluteValue._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcAbsoluteValue from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcAbsoluteValue = agcom.GUID(IStateCalcAbsoluteValue._uuid)
        vtable_offset_local = IStateCalcAbsoluteValue._vtable_offset - 1
        self.__dict__["_get_calc_object_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcAbsoluteValue, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_calc_object_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcAbsoluteValue, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcAbsoluteValue.__dict__ and type(IStateCalcAbsoluteValue.__dict__[attrname]) == property:
            return IStateCalcAbsoluteValue.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcAbsoluteValue.")
    
    @property
    def calc_object_name(self) -> str:
        """The calculation object."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_calc_object_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @calc_object_name.setter
    def calc_object_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_calc_object_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{214DD350-1B42-48C1-9720-66D109A5376B}", IStateCalcAbsoluteValue)
agcls.AgTypeNameMap["IStateCalcAbsoluteValue"] = IStateCalcAbsoluteValue

class IStateCalcDifference(object):
    """Properties for a Difference calculation object."""
    _uuid = "{4236F99F-8B4C-495E-BC83-41C4B0F1630E}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_calc_object_name"] = _raise_uninitialized_error
        self.__dict__["_set_calc_object_name"] = _raise_uninitialized_error
        self.__dict__["_get_difference_order"] = _raise_uninitialized_error
        self.__dict__["_set_difference_order"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcDifference._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcDifference from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcDifference = agcom.GUID(IStateCalcDifference._uuid)
        vtable_offset_local = IStateCalcDifference._vtable_offset - 1
        self.__dict__["_get_calc_object_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDifference, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_calc_object_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDifference, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_difference_order"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDifference, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_difference_order"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDifference, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcDifference.__dict__ and type(IStateCalcDifference.__dict__[attrname]) == property:
            return IStateCalcDifference.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcDifference.")
    
    @property
    def calc_object_name(self) -> str:
        """The calculation object."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_calc_object_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @calc_object_name.setter
    def calc_object_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_calc_object_name"](arg_inVal.COM_val))

    @property
    def difference_order(self) -> "AgEVADifferenceOrder":
        """The order of the difference calculation."""
        with agmarshall.AgEnum_arg(AgEVADifferenceOrder) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_difference_order"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @difference_order.setter
    def difference_order(self, inVal:"AgEVADifferenceOrder") -> None:
        with agmarshall.AgEnum_arg(AgEVADifferenceOrder, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_difference_order"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4236F99F-8B4C-495E-BC83-41C4B0F1630E}", IStateCalcDifference)
agcls.AgTypeNameMap["IStateCalcDifference"] = IStateCalcDifference

class IStateCalcDifferenceOtherSegment(object):
    """Properties for a Difference Across Segments calculation object."""
    _uuid = "{E5A6D40B-34F4-4325-AC8F-EE183AC7BA96}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_calc_object_name"] = _raise_uninitialized_error
        self.__dict__["_set_calc_object_name"] = _raise_uninitialized_error
        self.__dict__["_get_other_segment_name"] = _raise_uninitialized_error
        self.__dict__["_set_other_segment_name"] = _raise_uninitialized_error
        self.__dict__["_get_segment_state_to_use"] = _raise_uninitialized_error
        self.__dict__["_set_segment_state_to_use"] = _raise_uninitialized_error
        self.__dict__["_get_difference_order"] = _raise_uninitialized_error
        self.__dict__["_set_difference_order"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcDifferenceOtherSegment._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcDifferenceOtherSegment from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcDifferenceOtherSegment = agcom.GUID(IStateCalcDifferenceOtherSegment._uuid)
        vtable_offset_local = IStateCalcDifferenceOtherSegment._vtable_offset - 1
        self.__dict__["_get_calc_object_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDifferenceOtherSegment, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_calc_object_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDifferenceOtherSegment, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_other_segment_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDifferenceOtherSegment, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_other_segment_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDifferenceOtherSegment, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_get_segment_state_to_use"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDifferenceOtherSegment, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_segment_state_to_use"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDifferenceOtherSegment, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_difference_order"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDifferenceOtherSegment, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_difference_order"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDifferenceOtherSegment, vtable_offset_local+8, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcDifferenceOtherSegment.__dict__ and type(IStateCalcDifferenceOtherSegment.__dict__[attrname]) == property:
            return IStateCalcDifferenceOtherSegment.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcDifferenceOtherSegment.")
    
    @property
    def calc_object_name(self) -> str:
        """The calculation object."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_calc_object_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @calc_object_name.setter
    def calc_object_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_calc_object_name"](arg_inVal.COM_val))

    @property
    def other_segment_name(self) -> str:
        """The segment to be compared against."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_other_segment_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @other_segment_name.setter
    def other_segment_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_other_segment_name"](arg_inVal.COM_val))

    @property
    def segment_state_to_use(self) -> "AgEVASegmentState":
        """The segment state to use in the calculation."""
        with agmarshall.AgEnum_arg(AgEVASegmentState) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_segment_state_to_use"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @segment_state_to_use.setter
    def segment_state_to_use(self, inVal:"AgEVASegmentState") -> None:
        with agmarshall.AgEnum_arg(AgEVASegmentState, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_segment_state_to_use"](arg_inVal.COM_val))

    @property
    def difference_order(self) -> "AgEVASegmentDifferenceOrder":
        """The order of the difference calculation."""
        with agmarshall.AgEnum_arg(AgEVASegmentDifferenceOrder) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_difference_order"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @difference_order.setter
    def difference_order(self, inVal:"AgEVASegmentDifferenceOrder") -> None:
        with agmarshall.AgEnum_arg(AgEVASegmentDifferenceOrder, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_difference_order"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E5A6D40B-34F4-4325-AC8F-EE183AC7BA96}", IStateCalcDifferenceOtherSegment)
agcls.AgTypeNameMap["IStateCalcDifferenceOtherSegment"] = IStateCalcDifferenceOtherSegment

class IStateCalcPositionDifferenceOtherSegment(object):
    """Properties for a Position Difference Across Segments calculation object."""
    _uuid = "{168CD10A-F726-450F-A63F-E00A85FDEF87}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_other_segment_name"] = _raise_uninitialized_error
        self.__dict__["_set_other_segment_name"] = _raise_uninitialized_error
        self.__dict__["_get_segment_state_to_use"] = _raise_uninitialized_error
        self.__dict__["_set_segment_state_to_use"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcPositionDifferenceOtherSegment._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcPositionDifferenceOtherSegment from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcPositionDifferenceOtherSegment = agcom.GUID(IStateCalcPositionDifferenceOtherSegment._uuid)
        vtable_offset_local = IStateCalcPositionDifferenceOtherSegment._vtable_offset - 1
        self.__dict__["_get_other_segment_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcPositionDifferenceOtherSegment, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_other_segment_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcPositionDifferenceOtherSegment, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_segment_state_to_use"] = IAGFUNCTYPE(pUnk, IID_IStateCalcPositionDifferenceOtherSegment, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_segment_state_to_use"] = IAGFUNCTYPE(pUnk, IID_IStateCalcPositionDifferenceOtherSegment, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcPositionDifferenceOtherSegment.__dict__ and type(IStateCalcPositionDifferenceOtherSegment.__dict__[attrname]) == property:
            return IStateCalcPositionDifferenceOtherSegment.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcPositionDifferenceOtherSegment.")
    
    @property
    def other_segment_name(self) -> str:
        """The segment to be compared against."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_other_segment_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @other_segment_name.setter
    def other_segment_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_other_segment_name"](arg_inVal.COM_val))

    @property
    def segment_state_to_use(self) -> "AgEVASegmentState":
        """The segment state to use in the calculation."""
        with agmarshall.AgEnum_arg(AgEVASegmentState) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_segment_state_to_use"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @segment_state_to_use.setter
    def segment_state_to_use(self, inVal:"AgEVASegmentState") -> None:
        with agmarshall.AgEnum_arg(AgEVASegmentState, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_segment_state_to_use"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{168CD10A-F726-450F-A63F-E00A85FDEF87}", IStateCalcPositionDifferenceOtherSegment)
agcls.AgTypeNameMap["IStateCalcPositionDifferenceOtherSegment"] = IStateCalcPositionDifferenceOtherSegment

class IStateCalcVelDifferenceOtherSegment(object):
    """Properties for a Velocity Difference Across Segments calculation object."""
    _uuid = "{9BE8161D-7D1A-4FF6-8B63-C160E22844D1}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_other_segment_name"] = _raise_uninitialized_error
        self.__dict__["_set_other_segment_name"] = _raise_uninitialized_error
        self.__dict__["_get_segment_state_to_use"] = _raise_uninitialized_error
        self.__dict__["_set_segment_state_to_use"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcVelDifferenceOtherSegment._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcVelDifferenceOtherSegment from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcVelDifferenceOtherSegment = agcom.GUID(IStateCalcVelDifferenceOtherSegment._uuid)
        vtable_offset_local = IStateCalcVelDifferenceOtherSegment._vtable_offset - 1
        self.__dict__["_get_other_segment_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVelDifferenceOtherSegment, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_other_segment_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVelDifferenceOtherSegment, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_segment_state_to_use"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVelDifferenceOtherSegment, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_segment_state_to_use"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVelDifferenceOtherSegment, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcVelDifferenceOtherSegment.__dict__ and type(IStateCalcVelDifferenceOtherSegment.__dict__[attrname]) == property:
            return IStateCalcVelDifferenceOtherSegment.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcVelDifferenceOtherSegment.")
    
    @property
    def other_segment_name(self) -> str:
        """The segment to be compared against."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_other_segment_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @other_segment_name.setter
    def other_segment_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_other_segment_name"](arg_inVal.COM_val))

    @property
    def segment_state_to_use(self) -> "AgEVASegmentState":
        """The segment state to use in the calculation."""
        with agmarshall.AgEnum_arg(AgEVASegmentState) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_segment_state_to_use"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @segment_state_to_use.setter
    def segment_state_to_use(self, inVal:"AgEVASegmentState") -> None:
        with agmarshall.AgEnum_arg(AgEVASegmentState, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_segment_state_to_use"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{9BE8161D-7D1A-4FF6-8B63-C160E22844D1}", IStateCalcVelDifferenceOtherSegment)
agcls.AgTypeNameMap["IStateCalcVelDifferenceOtherSegment"] = IStateCalcVelDifferenceOtherSegment

class IStateCalcPositionVelDifferenceOtherSegment(object):
    """Properties for a Position and Velocity Difference Across Segments calculation object."""
    _uuid = "{58BA297D-0E89-46C4-9C9B-E8E7EA2B23AC}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_other_segment_name"] = _raise_uninitialized_error
        self.__dict__["_set_other_segment_name"] = _raise_uninitialized_error
        self.__dict__["_get_segment_state_to_use"] = _raise_uninitialized_error
        self.__dict__["_set_segment_state_to_use"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcPositionVelDifferenceOtherSegment._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcPositionVelDifferenceOtherSegment from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcPositionVelDifferenceOtherSegment = agcom.GUID(IStateCalcPositionVelDifferenceOtherSegment._uuid)
        vtable_offset_local = IStateCalcPositionVelDifferenceOtherSegment._vtable_offset - 1
        self.__dict__["_get_other_segment_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcPositionVelDifferenceOtherSegment, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_other_segment_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcPositionVelDifferenceOtherSegment, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_segment_state_to_use"] = IAGFUNCTYPE(pUnk, IID_IStateCalcPositionVelDifferenceOtherSegment, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_segment_state_to_use"] = IAGFUNCTYPE(pUnk, IID_IStateCalcPositionVelDifferenceOtherSegment, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcPositionVelDifferenceOtherSegment.__dict__ and type(IStateCalcPositionVelDifferenceOtherSegment.__dict__[attrname]) == property:
            return IStateCalcPositionVelDifferenceOtherSegment.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcPositionVelDifferenceOtherSegment.")
    
    @property
    def other_segment_name(self) -> str:
        """The segment to be compared against."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_other_segment_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @other_segment_name.setter
    def other_segment_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_other_segment_name"](arg_inVal.COM_val))

    @property
    def segment_state_to_use(self) -> "AgEVASegmentState":
        """The segment state to use in the calculation."""
        with agmarshall.AgEnum_arg(AgEVASegmentState) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_segment_state_to_use"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @segment_state_to_use.setter
    def segment_state_to_use(self, inVal:"AgEVASegmentState") -> None:
        with agmarshall.AgEnum_arg(AgEVASegmentState, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_segment_state_to_use"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{58BA297D-0E89-46C4-9C9B-E8E7EA2B23AC}", IStateCalcPositionVelDifferenceOtherSegment)
agcls.AgTypeNameMap["IStateCalcPositionVelDifferenceOtherSegment"] = IStateCalcPositionVelDifferenceOtherSegment

class IStateCalcValueAtSegment(object):
    """Properties for a Value At Segment calculation object."""
    _uuid = "{950DEE79-D37E-4EE5-AB69-6E145AAFB9AC}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_calc_object_name"] = _raise_uninitialized_error
        self.__dict__["_set_calc_object_name"] = _raise_uninitialized_error
        self.__dict__["_get_other_segment_name"] = _raise_uninitialized_error
        self.__dict__["_set_other_segment_name"] = _raise_uninitialized_error
        self.__dict__["_get_segment_state_to_use"] = _raise_uninitialized_error
        self.__dict__["_set_segment_state_to_use"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcValueAtSegment._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcValueAtSegment from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcValueAtSegment = agcom.GUID(IStateCalcValueAtSegment._uuid)
        vtable_offset_local = IStateCalcValueAtSegment._vtable_offset - 1
        self.__dict__["_get_calc_object_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcValueAtSegment, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_calc_object_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcValueAtSegment, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_other_segment_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcValueAtSegment, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_other_segment_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcValueAtSegment, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_get_segment_state_to_use"] = IAGFUNCTYPE(pUnk, IID_IStateCalcValueAtSegment, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_segment_state_to_use"] = IAGFUNCTYPE(pUnk, IID_IStateCalcValueAtSegment, vtable_offset_local+6, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcValueAtSegment.__dict__ and type(IStateCalcValueAtSegment.__dict__[attrname]) == property:
            return IStateCalcValueAtSegment.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcValueAtSegment.")
    
    @property
    def calc_object_name(self) -> str:
        """The calculation object."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_calc_object_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @calc_object_name.setter
    def calc_object_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_calc_object_name"](arg_inVal.COM_val))

    @property
    def other_segment_name(self) -> str:
        """The segment to be compared against."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_other_segment_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @other_segment_name.setter
    def other_segment_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_other_segment_name"](arg_inVal.COM_val))

    @property
    def segment_state_to_use(self) -> "AgEVASegmentState":
        """The segment state to use in the calculation."""
        with agmarshall.AgEnum_arg(AgEVASegmentState) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_segment_state_to_use"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @segment_state_to_use.setter
    def segment_state_to_use(self, inVal:"AgEVASegmentState") -> None:
        with agmarshall.AgEnum_arg(AgEVASegmentState, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_segment_state_to_use"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{950DEE79-D37E-4EE5-AB69-6E145AAFB9AC}", IStateCalcValueAtSegment)
agcls.AgTypeNameMap["IStateCalcValueAtSegment"] = IStateCalcValueAtSegment

class IStateCalcMaxValue(object):
    """Properties for a Maximum Value calculation object."""
    _uuid = "{A7B9EBBB-D87A-4F04-8DE3-E7812F322B66}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_calc_object_name"] = _raise_uninitialized_error
        self.__dict__["_set_calc_object_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcMaxValue._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcMaxValue from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcMaxValue = agcom.GUID(IStateCalcMaxValue._uuid)
        vtable_offset_local = IStateCalcMaxValue._vtable_offset - 1
        self.__dict__["_get_calc_object_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcMaxValue, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_calc_object_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcMaxValue, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcMaxValue.__dict__ and type(IStateCalcMaxValue.__dict__[attrname]) == property:
            return IStateCalcMaxValue.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcMaxValue.")
    
    @property
    def calc_object_name(self) -> str:
        """The calculation  object."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_calc_object_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @calc_object_name.setter
    def calc_object_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_calc_object_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{A7B9EBBB-D87A-4F04-8DE3-E7812F322B66}", IStateCalcMaxValue)
agcls.AgTypeNameMap["IStateCalcMaxValue"] = IStateCalcMaxValue

class IStateCalcMinValue(object):
    """Properties for a Minimum Value calculation object."""
    _uuid = "{22B15669-D363-4C73-87AE-424E1DF37ABA}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_calc_object_name"] = _raise_uninitialized_error
        self.__dict__["_set_calc_object_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcMinValue._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcMinValue from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcMinValue = agcom.GUID(IStateCalcMinValue._uuid)
        vtable_offset_local = IStateCalcMinValue._vtable_offset - 1
        self.__dict__["_get_calc_object_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcMinValue, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_calc_object_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcMinValue, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcMinValue.__dict__ and type(IStateCalcMinValue.__dict__[attrname]) == property:
            return IStateCalcMinValue.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcMinValue.")
    
    @property
    def calc_object_name(self) -> str:
        """The calculation  object."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_calc_object_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @calc_object_name.setter
    def calc_object_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_calc_object_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{22B15669-D363-4C73-87AE-424E1DF37ABA}", IStateCalcMinValue)
agcls.AgTypeNameMap["IStateCalcMinValue"] = IStateCalcMinValue

class IStateCalcMeanValue(object):
    """Properties for a Mean Value calculation object."""
    _uuid = "{7523BA0F-0B19-4660-8785-D9C23F29CB1C}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_calc_object_name"] = _raise_uninitialized_error
        self.__dict__["_set_calc_object_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcMeanValue._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcMeanValue from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcMeanValue = agcom.GUID(IStateCalcMeanValue._uuid)
        vtable_offset_local = IStateCalcMeanValue._vtable_offset - 1
        self.__dict__["_get_calc_object_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcMeanValue, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_calc_object_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcMeanValue, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcMeanValue.__dict__ and type(IStateCalcMeanValue.__dict__[attrname]) == property:
            return IStateCalcMeanValue.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcMeanValue.")
    
    @property
    def calc_object_name(self) -> str:
        """The calculation  object."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_calc_object_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @calc_object_name.setter
    def calc_object_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_calc_object_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7523BA0F-0B19-4660-8785-D9C23F29CB1C}", IStateCalcMeanValue)
agcls.AgTypeNameMap["IStateCalcMeanValue"] = IStateCalcMeanValue

class IStateCalcMedianValue(object):
    """Properties for a Median Value calculation object."""
    _uuid = "{3B7D51C9-5395-4AAA-828D-2AFF5CAB5676}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_calc_object_name"] = _raise_uninitialized_error
        self.__dict__["_set_calc_object_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcMedianValue._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcMedianValue from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcMedianValue = agcom.GUID(IStateCalcMedianValue._uuid)
        vtable_offset_local = IStateCalcMedianValue._vtable_offset - 1
        self.__dict__["_get_calc_object_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcMedianValue, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_calc_object_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcMedianValue, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcMedianValue.__dict__ and type(IStateCalcMedianValue.__dict__[attrname]) == property:
            return IStateCalcMedianValue.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcMedianValue.")
    
    @property
    def calc_object_name(self) -> str:
        """The calculation  object."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_calc_object_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @calc_object_name.setter
    def calc_object_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_calc_object_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3B7D51C9-5395-4AAA-828D-2AFF5CAB5676}", IStateCalcMedianValue)
agcls.AgTypeNameMap["IStateCalcMedianValue"] = IStateCalcMedianValue

class IStateCalcStandardDeviation(object):
    """Properties for a Standard Deviation calculation object."""
    _uuid = "{41847821-7A1E-46E9-AC78-B50A3D1D1500}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_calc_object_name"] = _raise_uninitialized_error
        self.__dict__["_set_calc_object_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcStandardDeviation._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcStandardDeviation from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcStandardDeviation = agcom.GUID(IStateCalcStandardDeviation._uuid)
        vtable_offset_local = IStateCalcStandardDeviation._vtable_offset - 1
        self.__dict__["_get_calc_object_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcStandardDeviation, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_calc_object_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcStandardDeviation, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcStandardDeviation.__dict__ and type(IStateCalcStandardDeviation.__dict__[attrname]) == property:
            return IStateCalcStandardDeviation.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcStandardDeviation.")
    
    @property
    def calc_object_name(self) -> str:
        """The calculation  object."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_calc_object_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @calc_object_name.setter
    def calc_object_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_calc_object_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{41847821-7A1E-46E9-AC78-B50A3D1D1500}", IStateCalcStandardDeviation)
agcls.AgTypeNameMap["IStateCalcStandardDeviation"] = IStateCalcStandardDeviation

class IStateCalcNegative(object):
    """Properties for a Negative calculation object."""
    _uuid = "{AE894289-670C-4C3F-8EAB-ABD6056919F2}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_calc_object_name"] = _raise_uninitialized_error
        self.__dict__["_set_calc_object_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcNegative._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcNegative from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcNegative = agcom.GUID(IStateCalcNegative._uuid)
        vtable_offset_local = IStateCalcNegative._vtable_offset - 1
        self.__dict__["_get_calc_object_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcNegative, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_calc_object_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcNegative, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcNegative.__dict__ and type(IStateCalcNegative.__dict__[attrname]) == property:
            return IStateCalcNegative.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcNegative.")
    
    @property
    def calc_object_name(self) -> str:
        """The calculation  object."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_calc_object_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @calc_object_name.setter
    def calc_object_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_calc_object_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{AE894289-670C-4C3F-8EAB-ABD6056919F2}", IStateCalcNegative)
agcls.AgTypeNameMap["IStateCalcNegative"] = IStateCalcNegative

class IStateCalcTrueAnomaly(object):
    """Properties for a Mean True Anomaly calculation object."""
    _uuid = "{639BD92E-793C-49C3-A72C-3456824F43EE}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_element_type"] = _raise_uninitialized_error
        self.__dict__["_set_element_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcTrueAnomaly._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcTrueAnomaly from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcTrueAnomaly = agcom.GUID(IStateCalcTrueAnomaly._uuid)
        vtable_offset_local = IStateCalcTrueAnomaly._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcTrueAnomaly, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcTrueAnomaly, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcTrueAnomaly, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcTrueAnomaly, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcTrueAnomaly.__dict__ and type(IStateCalcTrueAnomaly.__dict__[attrname]) == property:
            return IStateCalcTrueAnomaly.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcTrueAnomaly.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def element_type(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_element_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @element_type.setter
    def element_type(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_element_type"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{639BD92E-793C-49C3-A72C-3456824F43EE}", IStateCalcTrueAnomaly)
agcls.AgTypeNameMap["IStateCalcTrueAnomaly"] = IStateCalcTrueAnomaly

class IBDotRCalc(object):
    """Properties for a BDotR calculation object."""
    _uuid = "{BE67DDCF-6371-4275-996C-5DDB200E3B3F}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_target_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_target_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_ref_vector_name"] = _raise_uninitialized_error
        self.__dict__["_set_ref_vector_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBDotRCalc._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBDotRCalc from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBDotRCalc = agcom.GUID(IBDotRCalc._uuid)
        vtable_offset_local = IBDotRCalc._vtable_offset - 1
        self.__dict__["_get_target_body_name"] = IAGFUNCTYPE(pUnk, IID_IBDotRCalc, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_target_body_name"] = IAGFUNCTYPE(pUnk, IID_IBDotRCalc, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_ref_vector_name"] = IAGFUNCTYPE(pUnk, IID_IBDotRCalc, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_ref_vector_name"] = IAGFUNCTYPE(pUnk, IID_IBDotRCalc, vtable_offset_local+4, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBDotRCalc.__dict__ and type(IBDotRCalc.__dict__[attrname]) == property:
            return IBDotRCalc.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBDotRCalc.")
    
    @property
    def target_body_name(self) -> str:
        """The target body for B-plane computation."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_body_name.setter
    def target_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_body_name"](arg_inVal.COM_val))

    @property
    def ref_vector_name(self) -> str:
        """The reference vector to use to define the B-plane."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_ref_vector_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ref_vector_name.setter
    def ref_vector_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_ref_vector_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{BE67DDCF-6371-4275-996C-5DDB200E3B3F}", IBDotRCalc)
agcls.AgTypeNameMap["IBDotRCalc"] = IBDotRCalc

class IBDotTCalc(object):
    """Properties for a BDotT calculation object."""
    _uuid = "{E9BE921C-D864-4019-A3E7-A54DA59502FD}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_target_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_target_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_ref_vector_name"] = _raise_uninitialized_error
        self.__dict__["_set_ref_vector_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBDotTCalc._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBDotTCalc from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBDotTCalc = agcom.GUID(IBDotTCalc._uuid)
        vtable_offset_local = IBDotTCalc._vtable_offset - 1
        self.__dict__["_get_target_body_name"] = IAGFUNCTYPE(pUnk, IID_IBDotTCalc, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_target_body_name"] = IAGFUNCTYPE(pUnk, IID_IBDotTCalc, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_ref_vector_name"] = IAGFUNCTYPE(pUnk, IID_IBDotTCalc, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_ref_vector_name"] = IAGFUNCTYPE(pUnk, IID_IBDotTCalc, vtable_offset_local+4, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBDotTCalc.__dict__ and type(IBDotTCalc.__dict__[attrname]) == property:
            return IBDotTCalc.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBDotTCalc.")
    
    @property
    def target_body_name(self) -> str:
        """The target body for B-plane computation."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_body_name.setter
    def target_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_body_name"](arg_inVal.COM_val))

    @property
    def ref_vector_name(self) -> str:
        """The reference vector to use to define the B-plane."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_ref_vector_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ref_vector_name.setter
    def ref_vector_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_ref_vector_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E9BE921C-D864-4019-A3E7-A54DA59502FD}", IBDotTCalc)
agcls.AgTypeNameMap["IBDotTCalc"] = IBDotTCalc

class IBMagnitudeCalc(object):
    """Properties for a BMagnitude calculation object."""
    _uuid = "{7D570198-8048-407E-B532-B7B2B86860C1}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_target_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_target_body_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBMagnitudeCalc._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBMagnitudeCalc from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBMagnitudeCalc = agcom.GUID(IBMagnitudeCalc._uuid)
        vtable_offset_local = IBMagnitudeCalc._vtable_offset - 1
        self.__dict__["_get_target_body_name"] = IAGFUNCTYPE(pUnk, IID_IBMagnitudeCalc, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_target_body_name"] = IAGFUNCTYPE(pUnk, IID_IBMagnitudeCalc, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBMagnitudeCalc.__dict__ and type(IBMagnitudeCalc.__dict__[attrname]) == property:
            return IBMagnitudeCalc.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBMagnitudeCalc.")
    
    @property
    def target_body_name(self) -> str:
        """The target body for B-plane computation."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_body_name.setter
    def target_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_body_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7D570198-8048-407E-B532-B7B2B86860C1}", IBMagnitudeCalc)
agcls.AgTypeNameMap["IBMagnitudeCalc"] = IBMagnitudeCalc

class IBThetaCalc(object):
    """Properties for a BTheta calculation object."""
    _uuid = "{F478A128-3084-457F-B098-09114FF32DB8}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_target_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_target_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_ref_vector_name"] = _raise_uninitialized_error
        self.__dict__["_set_ref_vector_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBThetaCalc._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBThetaCalc from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBThetaCalc = agcom.GUID(IBThetaCalc._uuid)
        vtable_offset_local = IBThetaCalc._vtable_offset - 1
        self.__dict__["_get_target_body_name"] = IAGFUNCTYPE(pUnk, IID_IBThetaCalc, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_target_body_name"] = IAGFUNCTYPE(pUnk, IID_IBThetaCalc, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_ref_vector_name"] = IAGFUNCTYPE(pUnk, IID_IBThetaCalc, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_ref_vector_name"] = IAGFUNCTYPE(pUnk, IID_IBThetaCalc, vtable_offset_local+4, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBThetaCalc.__dict__ and type(IBThetaCalc.__dict__[attrname]) == property:
            return IBThetaCalc.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBThetaCalc.")
    
    @property
    def target_body_name(self) -> str:
        """The target body for B-plane computation."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @target_body_name.setter
    def target_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_target_body_name"](arg_inVal.COM_val))

    @property
    def ref_vector_name(self) -> str:
        """The reference vector to use to define the B-plane."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_ref_vector_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ref_vector_name.setter
    def ref_vector_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_ref_vector_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{F478A128-3084-457F-B098-09114FF32DB8}", IBThetaCalc)
agcls.AgTypeNameMap["IBThetaCalc"] = IBThetaCalc

class IStateCalcDeltaDec(object):
    """Properties for a Delta Declination calculation object."""
    _uuid = "{2C14B234-E769-4969-BFA3-54A5AB2C6F89}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_reference_type"] = _raise_uninitialized_error
        self.__dict__["_set_reference_type"] = _raise_uninitialized_error
        self.__dict__["_get_reference_body"] = _raise_uninitialized_error
        self.__dict__["_set_reference_body"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcDeltaDec._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcDeltaDec from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcDeltaDec = agcom.GUID(IStateCalcDeltaDec._uuid)
        vtable_offset_local = IStateCalcDeltaDec._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDeltaDec, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDeltaDec, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_reference_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDeltaDec, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_reference_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDeltaDec, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_reference_body"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDeltaDec, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_set_reference_body"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDeltaDec, vtable_offset_local+6, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcDeltaDec.__dict__ and type(IStateCalcDeltaDec.__dict__[attrname]) == property:
            return IStateCalcDeltaDec.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcDeltaDec.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def reference_type(self) -> "AgEVACalcObjectCentralBodyReference":
        """The central body's reference type"""
        with agmarshall.AgEnum_arg(AgEVACalcObjectCentralBodyReference) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_type.setter
    def reference_type(self, inVal:"AgEVACalcObjectCentralBodyReference") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectCentralBodyReference, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_type"](arg_inVal.COM_val))

    @property
    def reference_body(self) -> str:
        """The reference body of the component. Read only when the ReferenceType is eVACalcObjectCentralBodyReferenceParent."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_body"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_body.setter
    def reference_body(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_body"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2C14B234-E769-4969-BFA3-54A5AB2C6F89}", IStateCalcDeltaDec)
agcls.AgTypeNameMap["IStateCalcDeltaDec"] = IStateCalcDeltaDec

class IStateCalcDeltaRA(object):
    """Properties for a Delta Right Asc calculation object."""
    _uuid = "{42FFF17F-F89E-438E-B5C9-0206AD20D09E}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_reference_type"] = _raise_uninitialized_error
        self.__dict__["_set_reference_type"] = _raise_uninitialized_error
        self.__dict__["_get_reference_body"] = _raise_uninitialized_error
        self.__dict__["_set_reference_body"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcDeltaRA._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcDeltaRA from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcDeltaRA = agcom.GUID(IStateCalcDeltaRA._uuid)
        vtable_offset_local = IStateCalcDeltaRA._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDeltaRA, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDeltaRA, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_reference_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDeltaRA, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_reference_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDeltaRA, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_reference_body"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDeltaRA, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_set_reference_body"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDeltaRA, vtable_offset_local+6, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcDeltaRA.__dict__ and type(IStateCalcDeltaRA.__dict__[attrname]) == property:
            return IStateCalcDeltaRA.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcDeltaRA.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def reference_type(self) -> "AgEVACalcObjectCentralBodyReference":
        """The central body's reference type"""
        with agmarshall.AgEnum_arg(AgEVACalcObjectCentralBodyReference) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_type.setter
    def reference_type(self, inVal:"AgEVACalcObjectCentralBodyReference") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectCentralBodyReference, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_type"](arg_inVal.COM_val))

    @property
    def reference_body(self) -> str:
        """The reference body of the component. Read only when the ReferenceType is eVACalcObjectCentralBodyReferenceParent."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_body"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_body.setter
    def reference_body(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_body"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{42FFF17F-F89E-438E-B5C9-0206AD20D09E}", IStateCalcDeltaRA)
agcls.AgTypeNameMap["IStateCalcDeltaRA"] = IStateCalcDeltaRA

class IStateCalcBetaAngle(object):
    """Properties for a Beta Angle calculation object."""
    _uuid = "{6D251D91-4555-4C35-B56C-04832CF014E2}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcBetaAngle._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcBetaAngle from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcBetaAngle = agcom.GUID(IStateCalcBetaAngle._uuid)
        vtable_offset_local = IStateCalcBetaAngle._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcBetaAngle, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcBetaAngle, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcBetaAngle.__dict__ and type(IStateCalcBetaAngle.__dict__[attrname]) == property:
            return IStateCalcBetaAngle.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcBetaAngle.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{6D251D91-4555-4C35-B56C-04832CF014E2}", IStateCalcBetaAngle)
agcls.AgTypeNameMap["IStateCalcBetaAngle"] = IStateCalcBetaAngle

class IStateCalcLocalApparentSolarLon(object):
    """Properties for a Local Apparent Solar Longitude calculation object."""
    _uuid = "{619668AB-B09E-4160-9ED3-1365F3678C60}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcLocalApparentSolarLon._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcLocalApparentSolarLon from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcLocalApparentSolarLon = agcom.GUID(IStateCalcLocalApparentSolarLon._uuid)
        vtable_offset_local = IStateCalcLocalApparentSolarLon._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcLocalApparentSolarLon, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcLocalApparentSolarLon, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcLocalApparentSolarLon.__dict__ and type(IStateCalcLocalApparentSolarLon.__dict__[attrname]) == property:
            return IStateCalcLocalApparentSolarLon.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcLocalApparentSolarLon.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{619668AB-B09E-4160-9ED3-1365F3678C60}", IStateCalcLocalApparentSolarLon)
agcls.AgTypeNameMap["IStateCalcLocalApparentSolarLon"] = IStateCalcLocalApparentSolarLon

class IStateCalcLonOfPeriapsis(object):
    """Properties for a Longitude of Periapsis calculation object."""
    _uuid = "{1F8ECEB0-EFBE-4A23-8781-9BDEFF119DF0}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_set_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_get_element_type"] = _raise_uninitialized_error
        self.__dict__["_set_element_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcLonOfPeriapsis._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcLonOfPeriapsis from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcLonOfPeriapsis = agcom.GUID(IStateCalcLonOfPeriapsis._uuid)
        vtable_offset_local = IStateCalcLonOfPeriapsis._vtable_offset - 1
        self.__dict__["_get_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcLonOfPeriapsis, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcLonOfPeriapsis, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcLonOfPeriapsis, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcLonOfPeriapsis, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcLonOfPeriapsis.__dict__ and type(IStateCalcLonOfPeriapsis.__dict__[attrname]) == property:
            return IStateCalcLonOfPeriapsis.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcLonOfPeriapsis.")
    
    @property
    def coord_system_name(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_system_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_system_name.setter
    def coord_system_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_system_name"](arg_inVal.COM_val))

    @property
    def element_type(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_element_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @element_type.setter
    def element_type(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_element_type"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{1F8ECEB0-EFBE-4A23-8781-9BDEFF119DF0}", IStateCalcLonOfPeriapsis)
agcls.AgTypeNameMap["IStateCalcLonOfPeriapsis"] = IStateCalcLonOfPeriapsis

class IStateCalcOrbitStateValue(object):
    """Properties for an Orbit State Value calculation object."""
    _uuid = "{BE928A27-517C-4D52-A681-DA6CFC89E59F}"
    _num_methods = 20
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_calc_object_name"] = _raise_uninitialized_error
        self.__dict__["_set_calc_object_name"] = _raise_uninitialized_error
        self.__dict__["_get_input_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_set_input_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_get_x"] = _raise_uninitialized_error
        self.__dict__["_set_x"] = _raise_uninitialized_error
        self.__dict__["_get_y"] = _raise_uninitialized_error
        self.__dict__["_set_y"] = _raise_uninitialized_error
        self.__dict__["_get_z"] = _raise_uninitialized_error
        self.__dict__["_set_z"] = _raise_uninitialized_error
        self.__dict__["_get_vx"] = _raise_uninitialized_error
        self.__dict__["_set_vx"] = _raise_uninitialized_error
        self.__dict__["_get_vy"] = _raise_uninitialized_error
        self.__dict__["_set_vy"] = _raise_uninitialized_error
        self.__dict__["_get_vz"] = _raise_uninitialized_error
        self.__dict__["_set_vz"] = _raise_uninitialized_error
        self.__dict__["_enable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_disable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_is_control_parameter_enabled"] = _raise_uninitialized_error
        self.__dict__["_get_control_parameters_available"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcOrbitStateValue._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcOrbitStateValue from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcOrbitStateValue = agcom.GUID(IStateCalcOrbitStateValue._uuid)
        vtable_offset_local = IStateCalcOrbitStateValue._vtable_offset - 1
        self.__dict__["_get_calc_object_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitStateValue, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_calc_object_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitStateValue, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_input_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitStateValue, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_input_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitStateValue, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_get_x"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitStateValue, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_set_x"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitStateValue, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_get_y"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitStateValue, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_set_y"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitStateValue, vtable_offset_local+8, agcom.VARIANT)
        self.__dict__["_get_z"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitStateValue, vtable_offset_local+9, POINTER(agcom.VARIANT))
        self.__dict__["_set_z"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitStateValue, vtable_offset_local+10, agcom.VARIANT)
        self.__dict__["_get_vx"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitStateValue, vtable_offset_local+11, POINTER(agcom.VARIANT))
        self.__dict__["_set_vx"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitStateValue, vtable_offset_local+12, agcom.VARIANT)
        self.__dict__["_get_vy"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitStateValue, vtable_offset_local+13, POINTER(agcom.VARIANT))
        self.__dict__["_set_vy"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitStateValue, vtable_offset_local+14, agcom.VARIANT)
        self.__dict__["_get_vz"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitStateValue, vtable_offset_local+15, POINTER(agcom.VARIANT))
        self.__dict__["_set_vz"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitStateValue, vtable_offset_local+16, agcom.VARIANT)
        self.__dict__["_enable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitStateValue, vtable_offset_local+17, agcom.LONG)
        self.__dict__["_disable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitStateValue, vtable_offset_local+18, agcom.LONG)
        self.__dict__["_is_control_parameter_enabled"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitStateValue, vtable_offset_local+19, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_control_parameters_available"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOrbitStateValue, vtable_offset_local+20, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcOrbitStateValue.__dict__ and type(IStateCalcOrbitStateValue.__dict__[attrname]) == property:
            return IStateCalcOrbitStateValue.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcOrbitStateValue.")
    
    @property
    def calc_object_name(self) -> str:
        """The calculation object."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_calc_object_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @calc_object_name.setter
    def calc_object_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_calc_object_name"](arg_inVal.COM_val))

    @property
    def input_coord_system_name(self) -> str:
        """The coordinate system of the input state."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_input_coord_system_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @input_coord_system_name.setter
    def input_coord_system_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_input_coord_system_name"](arg_inVal.COM_val))

    @property
    def x(self) -> typing.Any:
        """The x position component. Uses Distance Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_x"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @x.setter
    def x(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_x"](arg_inVal.COM_val))

    @property
    def y(self) -> typing.Any:
        """The y position component. Uses Distance Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_y"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @y.setter
    def y(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_y"](arg_inVal.COM_val))

    @property
    def z(self) -> typing.Any:
        """The z position component. Uses Distance Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_z"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @z.setter
    def z(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_z"](arg_inVal.COM_val))

    @property
    def vx(self) -> typing.Any:
        """The x velocity component. Uses Rate Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_vx"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @vx.setter
    def vx(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_vx"](arg_inVal.COM_val))

    @property
    def vy(self) -> typing.Any:
        """The y velocity component. Uses Rate Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_vy"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @vy.setter
    def vy(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_vy"](arg_inVal.COM_val))

    @property
    def vz(self) -> typing.Any:
        """The z velocity component. Uses Rate Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_vz"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @vz.setter
    def vz(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_vz"](arg_inVal.COM_val))

    def enable_control_parameter(self, param:"AgEVAControlOrbitStateValue") -> None:
        """Enables the specified control parameter"""
        with agmarshall.AgEnum_arg(AgEVAControlOrbitStateValue, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_enable_control_parameter"](arg_param.COM_val))

    def disable_control_parameter(self, param:"AgEVAControlOrbitStateValue") -> None:
        """Disables the specified control parameter"""
        with agmarshall.AgEnum_arg(AgEVAControlOrbitStateValue, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_disable_control_parameter"](arg_param.COM_val))

    def is_control_parameter_enabled(self, param:"AgEVAControlOrbitStateValue") -> bool:
        """Sees if the specified control is enabled"""
        with agmarshall.AgEnum_arg(AgEVAControlOrbitStateValue, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_is_control_parameter_enabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_parameters_available(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_parameters_available"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{BE928A27-517C-4D52-A681-DA6CFC89E59F}", IStateCalcOrbitStateValue)
agcls.AgTypeNameMap["IStateCalcOrbitStateValue"] = IStateCalcOrbitStateValue

class IStateCalcSignedEccentricity(object):
    """Properties for a SignedEccentricity calculation object."""
    _uuid = "{CCBD1A51-0C24-4FEA-936D-F8E173931C30}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_element_type"] = _raise_uninitialized_error
        self.__dict__["_set_element_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcSignedEccentricity._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcSignedEccentricity from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcSignedEccentricity = agcom.GUID(IStateCalcSignedEccentricity._uuid)
        vtable_offset_local = IStateCalcSignedEccentricity._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSignedEccentricity, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSignedEccentricity, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSignedEccentricity, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSignedEccentricity, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcSignedEccentricity.__dict__ and type(IStateCalcSignedEccentricity.__dict__[attrname]) == property:
            return IStateCalcSignedEccentricity.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcSignedEccentricity.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def element_type(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_element_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @element_type.setter
    def element_type(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_element_type"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{CCBD1A51-0C24-4FEA-936D-F8E173931C30}", IStateCalcSignedEccentricity)
agcls.AgTypeNameMap["IStateCalcSignedEccentricity"] = IStateCalcSignedEccentricity

class IStateCalcTrueLon(object):
    """Properties for a True Longitude calculation object."""
    _uuid = "{E7F127C5-C675-4952-A10C-17AFCBB90F1B}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_set_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_get_element_type"] = _raise_uninitialized_error
        self.__dict__["_set_element_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcTrueLon._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcTrueLon from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcTrueLon = agcom.GUID(IStateCalcTrueLon._uuid)
        vtable_offset_local = IStateCalcTrueLon._vtable_offset - 1
        self.__dict__["_get_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcTrueLon, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcTrueLon, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcTrueLon, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcTrueLon, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcTrueLon.__dict__ and type(IStateCalcTrueLon.__dict__[attrname]) == property:
            return IStateCalcTrueLon.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcTrueLon.")
    
    @property
    def coord_system_name(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_system_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_system_name.setter
    def coord_system_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_system_name"](arg_inVal.COM_val))

    @property
    def element_type(self) -> "AgEVACalcObjectElem":
        """The element type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_element_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @element_type.setter
    def element_type(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_element_type"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E7F127C5-C675-4952-A10C-17AFCBB90F1B}", IStateCalcTrueLon)
agcls.AgTypeNameMap["IStateCalcTrueLon"] = IStateCalcTrueLon

class IStateCalcPower(object):
    """Properties for a Power calculation object."""
    _uuid = "{748E8F67-4505-4DE7-8206-4752EF3A9158}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_power_source_name"] = _raise_uninitialized_error
        self.__dict__["_set_power_source_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcPower._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcPower from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcPower = agcom.GUID(IStateCalcPower._uuid)
        vtable_offset_local = IStateCalcPower._vtable_offset - 1
        self.__dict__["_get_power_source_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcPower, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_power_source_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcPower, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcPower.__dict__ and type(IStateCalcPower.__dict__[attrname]) == property:
            return IStateCalcPower.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcPower.")
    
    @property
    def power_source_name(self) -> str:
        """The power source."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_power_source_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @power_source_name.setter
    def power_source_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_power_source_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{748E8F67-4505-4DE7-8206-4752EF3A9158}", IStateCalcPower)
agcls.AgTypeNameMap["IStateCalcPower"] = IStateCalcPower

class IStateCalcRelMotion(object):
    """Properties for a Relative Motion calculation object."""
    _uuid = "{9B36C269-5E68-456B-A2BD-B9BEA9B131DB}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_origin_at_master"] = _raise_uninitialized_error
        self.__dict__["_set_origin_at_master"] = _raise_uninitialized_error
        self.__dict__["_get_reference_selection"] = _raise_uninitialized_error
        self.__dict__["_set_reference_selection"] = _raise_uninitialized_error
        self.__dict__["_get_reference"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcRelMotion._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcRelMotion from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcRelMotion = agcom.GUID(IStateCalcRelMotion._uuid)
        vtable_offset_local = IStateCalcRelMotion._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelMotion, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelMotion, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_origin_at_master"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelMotion, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_origin_at_master"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelMotion, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_get_reference_selection"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelMotion, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_reference_selection"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelMotion, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_reference"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelMotion, vtable_offset_local+7, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcRelMotion.__dict__ and type(IStateCalcRelMotion.__dict__[attrname]) == property:
            return IStateCalcRelMotion.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcRelMotion.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def origin_at_master(self) -> bool:
        """True if the origin is at the reference satellite, false if the origin is at the current satellite."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_origin_at_master"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @origin_at_master.setter
    def origin_at_master(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_origin_at_master"](arg_inVal.COM_val))

    @property
    def reference_selection(self) -> "AgEVACalcObjectReference":
        """The reference object selection."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_selection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_selection.setter
    def reference_selection(self, inVal:"AgEVACalcObjectReference") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_selection"](arg_inVal.COM_val))

    @property
    def reference(self) -> "ILinkToObject":
        """The reference object."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_get_reference"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val


agcls.AgClassCatalog.add_catalog_entry("{9B36C269-5E68-456B-A2BD-B9BEA9B131DB}", IStateCalcRelMotion)
agcls.AgTypeNameMap["IStateCalcRelMotion"] = IStateCalcRelMotion

class IStateCalcSolarBetaAngle(object):
    """Properties for a Solar Beta Angle calculation object."""
    _uuid = "{1CBEFF7B-1B28-4AEB-A8BD-B329419FC824}"
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_orbit_plane_source"] = _raise_uninitialized_error
        self.__dict__["_set_orbit_plane_source"] = _raise_uninitialized_error
        self.__dict__["_get_element_type"] = _raise_uninitialized_error
        self.__dict__["_set_element_type"] = _raise_uninitialized_error
        self.__dict__["_get_reference_selection"] = _raise_uninitialized_error
        self.__dict__["_set_reference_selection"] = _raise_uninitialized_error
        self.__dict__["_get_reference"] = _raise_uninitialized_error
        self.__dict__["_get_sun_position"] = _raise_uninitialized_error
        self.__dict__["_set_sun_position"] = _raise_uninitialized_error
        self.__dict__["_get_sign_convention"] = _raise_uninitialized_error
        self.__dict__["_set_sign_convention"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcSolarBetaAngle._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcSolarBetaAngle from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcSolarBetaAngle = agcom.GUID(IStateCalcSolarBetaAngle._uuid)
        vtable_offset_local = IStateCalcSolarBetaAngle._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSolarBetaAngle, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSolarBetaAngle, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_orbit_plane_source"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSolarBetaAngle, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_orbit_plane_source"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSolarBetaAngle, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSolarBetaAngle, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSolarBetaAngle, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_reference_selection"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSolarBetaAngle, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_reference_selection"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSolarBetaAngle, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_reference"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSolarBetaAngle, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_get_sun_position"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSolarBetaAngle, vtable_offset_local+10, POINTER(agcom.LONG))
        self.__dict__["_set_sun_position"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSolarBetaAngle, vtable_offset_local+11, agcom.LONG)
        self.__dict__["_get_sign_convention"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSolarBetaAngle, vtable_offset_local+12, POINTER(agcom.LONG))
        self.__dict__["_set_sign_convention"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSolarBetaAngle, vtable_offset_local+13, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcSolarBetaAngle.__dict__ and type(IStateCalcSolarBetaAngle.__dict__[attrname]) == property:
            return IStateCalcSolarBetaAngle.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcSolarBetaAngle.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def orbit_plane_source(self) -> "AgEVACalcObjectOrbitPlaneSource":
        """Selection of the satellite that will generate the orbit plane."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectOrbitPlaneSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_orbit_plane_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @orbit_plane_source.setter
    def orbit_plane_source(self, inVal:"AgEVACalcObjectOrbitPlaneSource") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectOrbitPlaneSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_orbit_plane_source"](arg_inVal.COM_val))

    @property
    def element_type(self) -> "AgEVACalcObjectElem":
        """Choice of osculating or mean elements"""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_element_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @element_type.setter
    def element_type(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_element_type"](arg_inVal.COM_val))

    @property
    def reference_selection(self) -> "AgEVACalcObjectReference":
        """The reference object selection."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_selection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_selection.setter
    def reference_selection(self, inVal:"AgEVACalcObjectReference") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_selection"](arg_inVal.COM_val))

    @property
    def reference(self) -> "ILinkToObject":
        """The reference object."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_get_reference"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val

    @property
    def sun_position(self) -> "AgEVACalcObjectSunPosition":
        """The type of the Sun location."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectSunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sun_position"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sun_position.setter
    def sun_position(self, inVal:"AgEVACalcObjectSunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectSunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_sun_position"](arg_inVal.COM_val))

    @property
    def sign_convention(self) -> "AgEVACalcObjectAngleSign":
        """Sets the sign of the angle when the relative position has a positive component along the orbit normal."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectAngleSign) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sign_convention"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sign_convention.setter
    def sign_convention(self, inVal:"AgEVACalcObjectAngleSign") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectAngleSign, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_sign_convention"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{1CBEFF7B-1B28-4AEB-A8BD-B329419FC824}", IStateCalcSolarBetaAngle)
agcls.AgTypeNameMap["IStateCalcSolarBetaAngle"] = IStateCalcSolarBetaAngle

class IStateCalcSolarInPlaneAngle(object):
    """Properties for a Solar In Plane Angle calculation object."""
    _uuid = "{08345343-C64C-4CAF-B1C4-EE76DC4917B5}"
    _num_methods = 15
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_orbit_plane_source"] = _raise_uninitialized_error
        self.__dict__["_set_orbit_plane_source"] = _raise_uninitialized_error
        self.__dict__["_get_element_type"] = _raise_uninitialized_error
        self.__dict__["_set_element_type"] = _raise_uninitialized_error
        self.__dict__["_get_reference_selection"] = _raise_uninitialized_error
        self.__dict__["_set_reference_selection"] = _raise_uninitialized_error
        self.__dict__["_get_reference"] = _raise_uninitialized_error
        self.__dict__["_get_sun_position"] = _raise_uninitialized_error
        self.__dict__["_set_sun_position"] = _raise_uninitialized_error
        self.__dict__["_get_counter_clockwise_rotation"] = _raise_uninitialized_error
        self.__dict__["_set_counter_clockwise_rotation"] = _raise_uninitialized_error
        self.__dict__["_get_reference_direction"] = _raise_uninitialized_error
        self.__dict__["_set_reference_direction"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcSolarInPlaneAngle._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcSolarInPlaneAngle from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcSolarInPlaneAngle = agcom.GUID(IStateCalcSolarInPlaneAngle._uuid)
        vtable_offset_local = IStateCalcSolarInPlaneAngle._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSolarInPlaneAngle, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSolarInPlaneAngle, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_orbit_plane_source"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSolarInPlaneAngle, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_orbit_plane_source"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSolarInPlaneAngle, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSolarInPlaneAngle, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSolarInPlaneAngle, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_reference_selection"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSolarInPlaneAngle, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_reference_selection"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSolarInPlaneAngle, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_reference"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSolarInPlaneAngle, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_get_sun_position"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSolarInPlaneAngle, vtable_offset_local+10, POINTER(agcom.LONG))
        self.__dict__["_set_sun_position"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSolarInPlaneAngle, vtable_offset_local+11, agcom.LONG)
        self.__dict__["_get_counter_clockwise_rotation"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSolarInPlaneAngle, vtable_offset_local+12, POINTER(agcom.LONG))
        self.__dict__["_set_counter_clockwise_rotation"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSolarInPlaneAngle, vtable_offset_local+13, agcom.LONG)
        self.__dict__["_get_reference_direction"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSolarInPlaneAngle, vtable_offset_local+14, POINTER(agcom.LONG))
        self.__dict__["_set_reference_direction"] = IAGFUNCTYPE(pUnk, IID_IStateCalcSolarInPlaneAngle, vtable_offset_local+15, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcSolarInPlaneAngle.__dict__ and type(IStateCalcSolarInPlaneAngle.__dict__[attrname]) == property:
            return IStateCalcSolarInPlaneAngle.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcSolarInPlaneAngle.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def orbit_plane_source(self) -> "AgEVACalcObjectOrbitPlaneSource":
        """Selection of the satellite that will generate the orbit plane."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectOrbitPlaneSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_orbit_plane_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @orbit_plane_source.setter
    def orbit_plane_source(self, inVal:"AgEVACalcObjectOrbitPlaneSource") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectOrbitPlaneSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_orbit_plane_source"](arg_inVal.COM_val))

    @property
    def element_type(self) -> "AgEVACalcObjectElem":
        """Choice of osculating or mean elements"""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_element_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @element_type.setter
    def element_type(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_element_type"](arg_inVal.COM_val))

    @property
    def reference_selection(self) -> "AgEVACalcObjectReference":
        """The reference object selection."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_selection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_selection.setter
    def reference_selection(self, inVal:"AgEVACalcObjectReference") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_selection"](arg_inVal.COM_val))

    @property
    def reference(self) -> "ILinkToObject":
        """The reference object."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_get_reference"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val

    @property
    def sun_position(self) -> "AgEVACalcObjectSunPosition":
        """The type of the Sun location."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectSunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sun_position"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sun_position.setter
    def sun_position(self, inVal:"AgEVACalcObjectSunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectSunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_sun_position"](arg_inVal.COM_val))

    @property
    def counter_clockwise_rotation(self) -> "AgEVACalcObjectAngleSign":
        """Sets sign of the angle for counterclockwise rotation about orbit normal."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectAngleSign) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_counter_clockwise_rotation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @counter_clockwise_rotation.setter
    def counter_clockwise_rotation(self, inVal:"AgEVACalcObjectAngleSign") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectAngleSign, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_counter_clockwise_rotation"](arg_inVal.COM_val))

    @property
    def reference_direction(self) -> "AgEVACalcObjectReferenceDirection":
        """Direction that establishes the zero value when projected into the orbit plane."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReferenceDirection) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_direction"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_direction.setter
    def reference_direction(self, inVal:"AgEVACalcObjectReferenceDirection") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReferenceDirection, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_direction"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{08345343-C64C-4CAF-B1C4-EE76DC4917B5}", IStateCalcSolarInPlaneAngle)
agcls.AgTypeNameMap["IStateCalcSolarInPlaneAngle"] = IStateCalcSolarInPlaneAngle

class IStateCalcRelPositionDecAngle(object):
    """Properties for a Relative Position Declination Angle calculation object."""
    _uuid = "{259D6521-23C1-48B4-A718-27AB113952E9}"
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_orbit_plane_source"] = _raise_uninitialized_error
        self.__dict__["_set_orbit_plane_source"] = _raise_uninitialized_error
        self.__dict__["_get_element_type"] = _raise_uninitialized_error
        self.__dict__["_set_element_type"] = _raise_uninitialized_error
        self.__dict__["_get_reference_selection"] = _raise_uninitialized_error
        self.__dict__["_set_reference_selection"] = _raise_uninitialized_error
        self.__dict__["_get_reference"] = _raise_uninitialized_error
        self.__dict__["_get_relative_position_type"] = _raise_uninitialized_error
        self.__dict__["_set_relative_position_type"] = _raise_uninitialized_error
        self.__dict__["_get_sign_convention"] = _raise_uninitialized_error
        self.__dict__["_set_sign_convention"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcRelPositionDecAngle._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcRelPositionDecAngle from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcRelPositionDecAngle = agcom.GUID(IStateCalcRelPositionDecAngle._uuid)
        vtable_offset_local = IStateCalcRelPositionDecAngle._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelPositionDecAngle, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelPositionDecAngle, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_orbit_plane_source"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelPositionDecAngle, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_orbit_plane_source"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelPositionDecAngle, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelPositionDecAngle, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelPositionDecAngle, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_reference_selection"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelPositionDecAngle, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_reference_selection"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelPositionDecAngle, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_reference"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelPositionDecAngle, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_get_relative_position_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelPositionDecAngle, vtable_offset_local+10, POINTER(agcom.LONG))
        self.__dict__["_set_relative_position_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelPositionDecAngle, vtable_offset_local+11, agcom.LONG)
        self.__dict__["_get_sign_convention"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelPositionDecAngle, vtable_offset_local+12, POINTER(agcom.LONG))
        self.__dict__["_set_sign_convention"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelPositionDecAngle, vtable_offset_local+13, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcRelPositionDecAngle.__dict__ and type(IStateCalcRelPositionDecAngle.__dict__[attrname]) == property:
            return IStateCalcRelPositionDecAngle.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcRelPositionDecAngle.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def orbit_plane_source(self) -> "AgEVACalcObjectOrbitPlaneSource":
        """Selection of the satellite that will generate the orbit plane."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectOrbitPlaneSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_orbit_plane_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @orbit_plane_source.setter
    def orbit_plane_source(self, inVal:"AgEVACalcObjectOrbitPlaneSource") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectOrbitPlaneSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_orbit_plane_source"](arg_inVal.COM_val))

    @property
    def element_type(self) -> "AgEVACalcObjectElem":
        """Choice of osculating or mean elements"""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_element_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @element_type.setter
    def element_type(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_element_type"](arg_inVal.COM_val))

    @property
    def reference_selection(self) -> "AgEVACalcObjectReference":
        """The reference object selection."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_selection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_selection.setter
    def reference_selection(self, inVal:"AgEVACalcObjectReference") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_selection"](arg_inVal.COM_val))

    @property
    def reference(self) -> "ILinkToObject":
        """The reference object."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_get_reference"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val

    @property
    def relative_position_type(self) -> "AgEVACalcObjectRelativePosition":
        """The type of the relative position."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectRelativePosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_relative_position_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @relative_position_type.setter
    def relative_position_type(self, inVal:"AgEVACalcObjectRelativePosition") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectRelativePosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_relative_position_type"](arg_inVal.COM_val))

    @property
    def sign_convention(self) -> "AgEVACalcObjectAngleSign":
        """Sets the sign of the angle when the relative position has a positive component along the orbit normal."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectAngleSign) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sign_convention"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sign_convention.setter
    def sign_convention(self, inVal:"AgEVACalcObjectAngleSign") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectAngleSign, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_sign_convention"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{259D6521-23C1-48B4-A718-27AB113952E9}", IStateCalcRelPositionDecAngle)
agcls.AgTypeNameMap["IStateCalcRelPositionDecAngle"] = IStateCalcRelPositionDecAngle

class IStateCalcRelPositionInPlaneAngle(object):
    """Properties for a Relative Position In Plane Angle calculation object."""
    _uuid = "{E00BF049-7F38-4938-986F-8AB987CE84D2}"
    _num_methods = 15
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_orbit_plane_source"] = _raise_uninitialized_error
        self.__dict__["_set_orbit_plane_source"] = _raise_uninitialized_error
        self.__dict__["_get_element_type"] = _raise_uninitialized_error
        self.__dict__["_set_element_type"] = _raise_uninitialized_error
        self.__dict__["_get_reference_selection"] = _raise_uninitialized_error
        self.__dict__["_set_reference_selection"] = _raise_uninitialized_error
        self.__dict__["_get_reference"] = _raise_uninitialized_error
        self.__dict__["_get_relative_position_type"] = _raise_uninitialized_error
        self.__dict__["_set_relative_position_type"] = _raise_uninitialized_error
        self.__dict__["_get_counter_clockwise_rotation"] = _raise_uninitialized_error
        self.__dict__["_set_counter_clockwise_rotation"] = _raise_uninitialized_error
        self.__dict__["_get_reference_direction"] = _raise_uninitialized_error
        self.__dict__["_set_reference_direction"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcRelPositionInPlaneAngle._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcRelPositionInPlaneAngle from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcRelPositionInPlaneAngle = agcom.GUID(IStateCalcRelPositionInPlaneAngle._uuid)
        vtable_offset_local = IStateCalcRelPositionInPlaneAngle._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelPositionInPlaneAngle, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelPositionInPlaneAngle, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_orbit_plane_source"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelPositionInPlaneAngle, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_orbit_plane_source"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelPositionInPlaneAngle, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelPositionInPlaneAngle, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelPositionInPlaneAngle, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_reference_selection"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelPositionInPlaneAngle, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_reference_selection"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelPositionInPlaneAngle, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_reference"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelPositionInPlaneAngle, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_get_relative_position_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelPositionInPlaneAngle, vtable_offset_local+10, POINTER(agcom.LONG))
        self.__dict__["_set_relative_position_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelPositionInPlaneAngle, vtable_offset_local+11, agcom.LONG)
        self.__dict__["_get_counter_clockwise_rotation"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelPositionInPlaneAngle, vtable_offset_local+12, POINTER(agcom.LONG))
        self.__dict__["_set_counter_clockwise_rotation"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelPositionInPlaneAngle, vtable_offset_local+13, agcom.LONG)
        self.__dict__["_get_reference_direction"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelPositionInPlaneAngle, vtable_offset_local+14, POINTER(agcom.LONG))
        self.__dict__["_set_reference_direction"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelPositionInPlaneAngle, vtable_offset_local+15, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcRelPositionInPlaneAngle.__dict__ and type(IStateCalcRelPositionInPlaneAngle.__dict__[attrname]) == property:
            return IStateCalcRelPositionInPlaneAngle.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcRelPositionInPlaneAngle.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def orbit_plane_source(self) -> "AgEVACalcObjectOrbitPlaneSource":
        """Selection of the satellite that will generate the orbit plane."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectOrbitPlaneSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_orbit_plane_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @orbit_plane_source.setter
    def orbit_plane_source(self, inVal:"AgEVACalcObjectOrbitPlaneSource") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectOrbitPlaneSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_orbit_plane_source"](arg_inVal.COM_val))

    @property
    def element_type(self) -> "AgEVACalcObjectElem":
        """Choice of osculating or mean elements"""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_element_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @element_type.setter
    def element_type(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_element_type"](arg_inVal.COM_val))

    @property
    def reference_selection(self) -> "AgEVACalcObjectReference":
        """The reference object selection."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_selection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_selection.setter
    def reference_selection(self, inVal:"AgEVACalcObjectReference") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_selection"](arg_inVal.COM_val))

    @property
    def reference(self) -> "ILinkToObject":
        """The reference object."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_get_reference"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val

    @property
    def relative_position_type(self) -> "AgEVACalcObjectRelativePosition":
        """The type of the relative position."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectRelativePosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_relative_position_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @relative_position_type.setter
    def relative_position_type(self, inVal:"AgEVACalcObjectRelativePosition") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectRelativePosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_relative_position_type"](arg_inVal.COM_val))

    @property
    def counter_clockwise_rotation(self) -> "AgEVACalcObjectAngleSign":
        """Sets sign of the angle for counterclockwise rotation about orbit normal."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectAngleSign) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_counter_clockwise_rotation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @counter_clockwise_rotation.setter
    def counter_clockwise_rotation(self, inVal:"AgEVACalcObjectAngleSign") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectAngleSign, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_counter_clockwise_rotation"](arg_inVal.COM_val))

    @property
    def reference_direction(self) -> "AgEVACalcObjectReferenceDirection":
        """Direction that establishes the zero value when projected into the orbit plane."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReferenceDirection) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_direction"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_direction.setter
    def reference_direction(self, inVal:"AgEVACalcObjectReferenceDirection") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReferenceDirection, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_direction"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E00BF049-7F38-4938-986F-8AB987CE84D2}", IStateCalcRelPositionInPlaneAngle)
agcls.AgTypeNameMap["IStateCalcRelPositionInPlaneAngle"] = IStateCalcRelPositionInPlaneAngle

class IStateCalcRelativeInclination(object):
    """Properties for a Relative Inclination Angle calculation object."""
    _uuid = "{D0299E22-99A9-4FEF-82B3-A1A7E9B9C3C1}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_satellite_orbit_normal_type"] = _raise_uninitialized_error
        self.__dict__["_set_satellite_orbit_normal_type"] = _raise_uninitialized_error
        self.__dict__["_get_ref_satellite_orbit_normal_type"] = _raise_uninitialized_error
        self.__dict__["_set_ref_satellite_orbit_normal_type"] = _raise_uninitialized_error
        self.__dict__["_get_reference_selection"] = _raise_uninitialized_error
        self.__dict__["_set_reference_selection"] = _raise_uninitialized_error
        self.__dict__["_get_reference"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcRelativeInclination._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcRelativeInclination from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcRelativeInclination = agcom.GUID(IStateCalcRelativeInclination._uuid)
        vtable_offset_local = IStateCalcRelativeInclination._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelativeInclination, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelativeInclination, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_satellite_orbit_normal_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelativeInclination, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_satellite_orbit_normal_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelativeInclination, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_ref_satellite_orbit_normal_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelativeInclination, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_ref_satellite_orbit_normal_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelativeInclination, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_reference_selection"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelativeInclination, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_reference_selection"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelativeInclination, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_reference"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRelativeInclination, vtable_offset_local+9, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcRelativeInclination.__dict__ and type(IStateCalcRelativeInclination.__dict__[attrname]) == property:
            return IStateCalcRelativeInclination.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcRelativeInclination.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def satellite_orbit_normal_type(self) -> "AgEVACalcObjectElem":
        """Choice of osculating or mean elements for describing the orbit plane."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_satellite_orbit_normal_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @satellite_orbit_normal_type.setter
    def satellite_orbit_normal_type(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_satellite_orbit_normal_type"](arg_inVal.COM_val))

    @property
    def ref_satellite_orbit_normal_type(self) -> "AgEVACalcObjectElem":
        """Choice of osculating or mean elements for describing the orbit plane"""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_ref_satellite_orbit_normal_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ref_satellite_orbit_normal_type.setter
    def ref_satellite_orbit_normal_type(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_ref_satellite_orbit_normal_type"](arg_inVal.COM_val))

    @property
    def reference_selection(self) -> "AgEVACalcObjectReference":
        """The reference object selection."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_selection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_selection.setter
    def reference_selection(self, inVal:"AgEVACalcObjectReference") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_selection"](arg_inVal.COM_val))

    @property
    def reference(self) -> "ILinkToObject":
        """The reference object."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_get_reference"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val


agcls.AgClassCatalog.add_catalog_entry("{D0299E22-99A9-4FEF-82B3-A1A7E9B9C3C1}", IStateCalcRelativeInclination)
agcls.AgTypeNameMap["IStateCalcRelativeInclination"] = IStateCalcRelativeInclination

class IStateCalcCurvilinearRelMotion(object):
    """Properties for Curvilinear Relative Motion  calculation object."""
    _uuid = "{5658DCFF-6F7B-4935-BA41-135F502DDC07}"
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_reference_ellipse"] = _raise_uninitialized_error
        self.__dict__["_set_reference_ellipse"] = _raise_uninitialized_error
        self.__dict__["_get_location_source"] = _raise_uninitialized_error
        self.__dict__["_set_location_source"] = _raise_uninitialized_error
        self.__dict__["_get_reference_selection"] = _raise_uninitialized_error
        self.__dict__["_set_reference_selection"] = _raise_uninitialized_error
        self.__dict__["_get_reference"] = _raise_uninitialized_error
        self.__dict__["_get_element_type"] = _raise_uninitialized_error
        self.__dict__["_set_element_type"] = _raise_uninitialized_error
        self.__dict__["_get_sign_convention"] = _raise_uninitialized_error
        self.__dict__["_set_sign_convention"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcCurvilinearRelMotion._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcCurvilinearRelMotion from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcCurvilinearRelMotion = agcom.GUID(IStateCalcCurvilinearRelMotion._uuid)
        vtable_offset_local = IStateCalcCurvilinearRelMotion._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCurvilinearRelMotion, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCurvilinearRelMotion, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_reference_ellipse"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCurvilinearRelMotion, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_reference_ellipse"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCurvilinearRelMotion, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_location_source"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCurvilinearRelMotion, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_location_source"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCurvilinearRelMotion, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_reference_selection"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCurvilinearRelMotion, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_reference_selection"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCurvilinearRelMotion, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_reference"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCurvilinearRelMotion, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_get_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCurvilinearRelMotion, vtable_offset_local+10, POINTER(agcom.LONG))
        self.__dict__["_set_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCurvilinearRelMotion, vtable_offset_local+11, agcom.LONG)
        self.__dict__["_get_sign_convention"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCurvilinearRelMotion, vtable_offset_local+12, POINTER(agcom.LONG))
        self.__dict__["_set_sign_convention"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCurvilinearRelMotion, vtable_offset_local+13, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcCurvilinearRelMotion.__dict__ and type(IStateCalcCurvilinearRelMotion.__dict__[attrname]) == property:
            return IStateCalcCurvilinearRelMotion.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcCurvilinearRelMotion.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def reference_ellipse(self) -> "AgEVACalcObjectReferenceEllipse":
        """Selection of the satellite orbit that is used as the reference ellipse."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReferenceEllipse) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_ellipse"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_ellipse.setter
    def reference_ellipse(self, inVal:"AgEVACalcObjectReferenceEllipse") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReferenceEllipse, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_ellipse"](arg_inVal.COM_val))

    @property
    def location_source(self) -> "AgEVACalcObjectLocationSource":
        """Selection of the satellite whose location is being reported with respect to the reference ellipse."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectLocationSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_location_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @location_source.setter
    def location_source(self, inVal:"AgEVACalcObjectLocationSource") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectLocationSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_location_source"](arg_inVal.COM_val))

    @property
    def reference_selection(self) -> "AgEVACalcObjectReference":
        """The reference object selection."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_selection"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_selection.setter
    def reference_selection(self, inVal:"AgEVACalcObjectReference") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectReference, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_selection"](arg_inVal.COM_val))

    @property
    def reference(self) -> "ILinkToObject":
        """The reference object."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_get_reference"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val

    @property
    def element_type(self) -> "AgEVACalcObjectElem":
        """Choice of osculating or mean elements"""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_element_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @element_type.setter
    def element_type(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_element_type"](arg_inVal.COM_val))

    @property
    def sign_convention(self) -> "AgEVACalcObjectAngleSign":
        """Sets the sign of the angle when the relative position has a positive component along the orbit normal."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectAngleSign) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sign_convention"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sign_convention.setter
    def sign_convention(self, inVal:"AgEVACalcObjectAngleSign") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectAngleSign, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_sign_convention"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{5658DCFF-6F7B-4935-BA41-135F502DDC07}", IStateCalcCurvilinearRelMotion)
agcls.AgTypeNameMap["IStateCalcCurvilinearRelMotion"] = IStateCalcCurvilinearRelMotion

class IStateCalcCustomFunction(object):
    """Properties for a Custom Function calculation object."""
    _uuid = "{0943C88D-EE8E-48B1-8C5B-79A4748452C8}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_reset_function_name"] = _raise_uninitialized_error
        self.__dict__["_set_reset_function_name"] = _raise_uninitialized_error
        self.__dict__["_get_eval_function_name"] = _raise_uninitialized_error
        self.__dict__["_set_eval_function_name"] = _raise_uninitialized_error
        self.__dict__["_get_unit_dimension"] = _raise_uninitialized_error
        self.__dict__["_set_unit_dimension"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcCustomFunction._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcCustomFunction from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcCustomFunction = agcom.GUID(IStateCalcCustomFunction._uuid)
        vtable_offset_local = IStateCalcCustomFunction._vtable_offset - 1
        self.__dict__["_get_reset_function_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCustomFunction, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_reset_function_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCustomFunction, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_eval_function_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCustomFunction, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_eval_function_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCustomFunction, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_get_unit_dimension"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCustomFunction, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_set_unit_dimension"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCustomFunction, vtable_offset_local+6, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcCustomFunction.__dict__ and type(IStateCalcCustomFunction.__dict__[attrname]) == property:
            return IStateCalcCustomFunction.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcCustomFunction.")
    
    @property
    def reset_function_name(self) -> str:
        """The custom function called before computing, before each segment runs, and before reporting."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reset_function_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reset_function_name.setter
    def reset_function_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_reset_function_name"](arg_inVal.COM_val))

    @property
    def eval_function_name(self) -> str:
        """The custom function used to calculate this object's value."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_eval_function_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @eval_function_name.setter
    def eval_function_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_eval_function_name"](arg_inVal.COM_val))

    @property
    def unit_dimension(self) -> str:
        """The unit dimension."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_unit_dimension"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @unit_dimension.setter
    def unit_dimension(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_unit_dimension"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{0943C88D-EE8E-48B1-8C5B-79A4748452C8}", IStateCalcCustomFunction)
agcls.AgTypeNameMap["IStateCalcCustomFunction"] = IStateCalcCustomFunction

class IStateCalcScript(object):
    """Properties for a Script calculation object."""
    _uuid = "{42A2EAD1-9982-4895-9637-4C83524F2A02}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_calc_arguments"] = _raise_uninitialized_error
        self.__dict__["_get_inline_func"] = _raise_uninitialized_error
        self.__dict__["_set_inline_func"] = _raise_uninitialized_error
        self.__dict__["_get_unit_dimension"] = _raise_uninitialized_error
        self.__dict__["_set_unit_dimension"] = _raise_uninitialized_error
        self.__dict__["_get_calc_arguments_link_embed"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcScript._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcScript from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcScript = agcom.GUID(IStateCalcScript._uuid)
        vtable_offset_local = IStateCalcScript._vtable_offset - 1
        self.__dict__["_get_calc_arguments"] = IAGFUNCTYPE(pUnk, IID_IStateCalcScript, vtable_offset_local+1, POINTER(agcom.PVOID))
        self.__dict__["_get_inline_func"] = IAGFUNCTYPE(pUnk, IID_IStateCalcScript, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_set_inline_func"] = IAGFUNCTYPE(pUnk, IID_IStateCalcScript, vtable_offset_local+3, agcom.BSTR)
        self.__dict__["_get_unit_dimension"] = IAGFUNCTYPE(pUnk, IID_IStateCalcScript, vtable_offset_local+4, POINTER(agcom.BSTR))
        self.__dict__["_set_unit_dimension"] = IAGFUNCTYPE(pUnk, IID_IStateCalcScript, vtable_offset_local+5, agcom.BSTR)
        self.__dict__["_get_calc_arguments_link_embed"] = IAGFUNCTYPE(pUnk, IID_IStateCalcScript, vtable_offset_local+6, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcScript.__dict__ and type(IStateCalcScript.__dict__[attrname]) == property:
            return IStateCalcScript.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcScript.")
    
    @property
    def calc_arguments(self) -> "ICalcObjectCollection":
        """The arguments to be applied to the function."""
        with agmarshall.AgInterface_out_arg() as arg_ppVACalcObjectCollection:
            agcls.evaluate_hresult(self.__dict__["_get_calc_arguments"](byref(arg_ppVACalcObjectCollection.COM_val)))
            return arg_ppVACalcObjectCollection.python_val

    @property
    def inline_func(self) -> str:
        """The expression to be applied as a function."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_inline_func"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @inline_func.setter
    def inline_func(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_inline_func"](arg_inVal.COM_val))

    @property
    def unit_dimension(self) -> str:
        """The unit dimension."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_unit_dimension"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @unit_dimension.setter
    def unit_dimension(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_unit_dimension"](arg_inVal.COM_val))

    @property
    def calc_arguments_link_embed(self) -> "ICalcObjectLinkEmbedControlCollection":
        """The arguments to be applied to the function."""
        with agmarshall.AgInterface_out_arg() as arg_ppVACalcObjectLinkEmbedControlCollection:
            agcls.evaluate_hresult(self.__dict__["_get_calc_arguments_link_embed"](byref(arg_ppVACalcObjectLinkEmbedControlCollection.COM_val)))
            return arg_ppVACalcObjectLinkEmbedControlCollection.python_val


agcls.AgClassCatalog.add_catalog_entry("{42A2EAD1-9982-4895-9637-4C83524F2A02}", IStateCalcScript)
agcls.AgTypeNameMap["IStateCalcScript"] = IStateCalcScript

class IStateCalcCd(object):
    """Properties for a Cd calculation object."""
    _uuid = "{18430B84-59EA-4D47-84B4-E7D5589F1931}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcCd._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcCd from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcCd = agcom.GUID(IStateCalcCd._uuid)
        vtable_offset_local = IStateCalcCd._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcCd.__dict__ and type(IStateCalcCd.__dict__[attrname]) == property:
            return IStateCalcCd.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcCd.")
    

agcls.AgClassCatalog.add_catalog_entry("{18430B84-59EA-4D47-84B4-E7D5589F1931}", IStateCalcCd)
agcls.AgTypeNameMap["IStateCalcCd"] = IStateCalcCd

class IStateCalcCr(object):
    """Properties for a Cr calculation object."""
    _uuid = "{BC4AD651-BFCA-4E69-8409-54BB0880F9E6}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcCr._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcCr from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcCr = agcom.GUID(IStateCalcCr._uuid)
        vtable_offset_local = IStateCalcCr._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcCr.__dict__ and type(IStateCalcCr.__dict__[attrname]) == property:
            return IStateCalcCr.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcCr.")
    

agcls.AgClassCatalog.add_catalog_entry("{BC4AD651-BFCA-4E69-8409-54BB0880F9E6}", IStateCalcCr)
agcls.AgTypeNameMap["IStateCalcCr"] = IStateCalcCr

class IStateCalcDragArea(object):
    """Properties for a DragArea calculation object. CAgAsStateCalcDragArea"""
    _uuid = "{0D264D3F-4409-4CF7-95AD-0129F85F2A72}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcDragArea._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcDragArea from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcDragArea = agcom.GUID(IStateCalcDragArea._uuid)
        vtable_offset_local = IStateCalcDragArea._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcDragArea.__dict__ and type(IStateCalcDragArea.__dict__[attrname]) == property:
            return IStateCalcDragArea.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcDragArea.")
    

agcls.AgClassCatalog.add_catalog_entry("{0D264D3F-4409-4CF7-95AD-0129F85F2A72}", IStateCalcDragArea)
agcls.AgTypeNameMap["IStateCalcDragArea"] = IStateCalcDragArea

class IStateCalcRadiationPressureArea(object):
    """Properties for a RadPressureArea calculation object."""
    _uuid = "{F6C33B19-2B4F-4DBB-8CA0-B3E8B971BC49}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcRadiationPressureArea._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcRadiationPressureArea from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcRadiationPressureArea = agcom.GUID(IStateCalcRadiationPressureArea._uuid)
        vtable_offset_local = IStateCalcRadiationPressureArea._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcRadiationPressureArea.__dict__ and type(IStateCalcRadiationPressureArea.__dict__[attrname]) == property:
            return IStateCalcRadiationPressureArea.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcRadiationPressureArea.")
    

agcls.AgClassCatalog.add_catalog_entry("{F6C33B19-2B4F-4DBB-8CA0-B3E8B971BC49}", IStateCalcRadiationPressureArea)
agcls.AgTypeNameMap["IStateCalcRadiationPressureArea"] = IStateCalcRadiationPressureArea

class IStateCalcRadiationPressureCoefficient(object):
    """Properties for a RadiationPressureCoefficient calculation object."""
    _uuid = "{9AE54040-18D2-46FC-A12C-C03BDA65FE22}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcRadiationPressureCoefficient._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcRadiationPressureCoefficient from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcRadiationPressureCoefficient = agcom.GUID(IStateCalcRadiationPressureCoefficient._uuid)
        vtable_offset_local = IStateCalcRadiationPressureCoefficient._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcRadiationPressureCoefficient.__dict__ and type(IStateCalcRadiationPressureCoefficient.__dict__[attrname]) == property:
            return IStateCalcRadiationPressureCoefficient.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcRadiationPressureCoefficient.")
    

agcls.AgClassCatalog.add_catalog_entry("{9AE54040-18D2-46FC-A12C-C03BDA65FE22}", IStateCalcRadiationPressureCoefficient)
agcls.AgTypeNameMap["IStateCalcRadiationPressureCoefficient"] = IStateCalcRadiationPressureCoefficient

class IStateCalcSRPArea(object):
    """Properties for an SRPArea calculation object."""
    _uuid = "{776A4C17-4D73-4ED0-A564-E9BD0D1788EC}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcSRPArea._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcSRPArea from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcSRPArea = agcom.GUID(IStateCalcSRPArea._uuid)
        vtable_offset_local = IStateCalcSRPArea._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcSRPArea.__dict__ and type(IStateCalcSRPArea.__dict__[attrname]) == property:
            return IStateCalcSRPArea.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcSRPArea.")
    

agcls.AgClassCatalog.add_catalog_entry("{776A4C17-4D73-4ED0-A564-E9BD0D1788EC}", IStateCalcSRPArea)
agcls.AgTypeNameMap["IStateCalcSRPArea"] = IStateCalcSRPArea

class IStateCalcCosOfVerticalFPA(object):
    """Properties for a Cosine of Vertical FPA calculation object."""
    _uuid = "{D2C32FFB-6C5C-46E8-B386-2E69262118C8}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcCosOfVerticalFPA._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcCosOfVerticalFPA from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcCosOfVerticalFPA = agcom.GUID(IStateCalcCosOfVerticalFPA._uuid)
        vtable_offset_local = IStateCalcCosOfVerticalFPA._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCosOfVerticalFPA, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcCosOfVerticalFPA, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcCosOfVerticalFPA.__dict__ and type(IStateCalcCosOfVerticalFPA.__dict__[attrname]) == property:
            return IStateCalcCosOfVerticalFPA.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcCosOfVerticalFPA.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{D2C32FFB-6C5C-46E8-B386-2E69262118C8}", IStateCalcCosOfVerticalFPA)
agcls.AgTypeNameMap["IStateCalcCosOfVerticalFPA"] = IStateCalcCosOfVerticalFPA

class IStateCalcDec(object):
    """Properties for a Declination calculation object."""
    _uuid = "{B3277FB5-1B7A-4A02-91B1-F6682F29CB87}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_set_coord_system_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcDec._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcDec from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcDec = agcom.GUID(IStateCalcDec._uuid)
        vtable_offset_local = IStateCalcDec._vtable_offset - 1
        self.__dict__["_get_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDec, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDec, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcDec.__dict__ and type(IStateCalcDec.__dict__[attrname]) == property:
            return IStateCalcDec.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcDec.")
    
    @property
    def coord_system_name(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_system_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_system_name.setter
    def coord_system_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_system_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{B3277FB5-1B7A-4A02-91B1-F6682F29CB87}", IStateCalcDec)
agcls.AgTypeNameMap["IStateCalcDec"] = IStateCalcDec

class IStateCalcFPA(object):
    """Properties for a Flight Path Angle calculation object."""
    _uuid = "{0A7406E7-049A-4054-A1FE-3E86D1998733}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_set_coord_system_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcFPA._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcFPA from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcFPA = agcom.GUID(IStateCalcFPA._uuid)
        vtable_offset_local = IStateCalcFPA._vtable_offset - 1
        self.__dict__["_get_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcFPA, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcFPA, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcFPA.__dict__ and type(IStateCalcFPA.__dict__[attrname]) == property:
            return IStateCalcFPA.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcFPA.")
    
    @property
    def coord_system_name(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_system_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_system_name.setter
    def coord_system_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_system_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{0A7406E7-049A-4054-A1FE-3E86D1998733}", IStateCalcFPA)
agcls.AgTypeNameMap["IStateCalcFPA"] = IStateCalcFPA

class IStateCalcRMagnitude(object):
    """Properties for an R Mag calculation object. AsStateCalcRMag"""
    _uuid = "{3E6FAE70-AA94-4036-9FBA-75954E96D759}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_reference_point_name"] = _raise_uninitialized_error
        self.__dict__["_set_reference_point_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcRMagnitude._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcRMagnitude from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcRMagnitude = agcom.GUID(IStateCalcRMagnitude._uuid)
        vtable_offset_local = IStateCalcRMagnitude._vtable_offset - 1
        self.__dict__["_get_reference_point_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRMagnitude, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_reference_point_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRMagnitude, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcRMagnitude.__dict__ and type(IStateCalcRMagnitude.__dict__[attrname]) == property:
            return IStateCalcRMagnitude.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcRMagnitude.")
    
    @property
    def reference_point_name(self) -> str:
        """Reference point used for calculation."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_point_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_point_name.setter
    def reference_point_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_point_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3E6FAE70-AA94-4036-9FBA-75954E96D759}", IStateCalcRMagnitude)
agcls.AgTypeNameMap["IStateCalcRMagnitude"] = IStateCalcRMagnitude

class IStateCalcRA(object):
    """Properties for a Right Asc calculation object."""
    _uuid = "{3D404DD1-E609-4CA0-87BE-3D9EDD9A7BCE}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_set_coord_system_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcRA._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcRA from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcRA = agcom.GUID(IStateCalcRA._uuid)
        vtable_offset_local = IStateCalcRA._vtable_offset - 1
        self.__dict__["_get_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRA, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRA, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcRA.__dict__ and type(IStateCalcRA.__dict__[attrname]) == property:
            return IStateCalcRA.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcRA.")
    
    @property
    def coord_system_name(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_system_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_system_name.setter
    def coord_system_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_system_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3D404DD1-E609-4CA0-87BE-3D9EDD9A7BCE}", IStateCalcRA)
agcls.AgTypeNameMap["IStateCalcRA"] = IStateCalcRA

class IStateCalcVMagnitude(object):
    """Properties for a V Mag calculation object."""
    _uuid = "{6795C6E5-3D87-42A9-A40F-DAFEDA08235B}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_set_coord_system_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcVMagnitude._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcVMagnitude from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcVMagnitude = agcom.GUID(IStateCalcVMagnitude._uuid)
        vtable_offset_local = IStateCalcVMagnitude._vtable_offset - 1
        self.__dict__["_get_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVMagnitude, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVMagnitude, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcVMagnitude.__dict__ and type(IStateCalcVMagnitude.__dict__[attrname]) == property:
            return IStateCalcVMagnitude.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcVMagnitude.")
    
    @property
    def coord_system_name(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_system_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_system_name.setter
    def coord_system_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_system_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{6795C6E5-3D87-42A9-A40F-DAFEDA08235B}", IStateCalcVMagnitude)
agcls.AgTypeNameMap["IStateCalcVMagnitude"] = IStateCalcVMagnitude

class IStateCalcVelAz(object):
    """Properties for a Velocity Azimuth calculation object."""
    _uuid = "{5B86F143-59CB-4014-A920-7F46613F2FB5}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_set_coord_system_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcVelAz._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcVelAz from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcVelAz = agcom.GUID(IStateCalcVelAz._uuid)
        vtable_offset_local = IStateCalcVelAz._vtable_offset - 1
        self.__dict__["_get_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVelAz, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVelAz, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcVelAz.__dict__ and type(IStateCalcVelAz.__dict__[attrname]) == property:
            return IStateCalcVelAz.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcVelAz.")
    
    @property
    def coord_system_name(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_system_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_system_name.setter
    def coord_system_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_system_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{5B86F143-59CB-4014-A920-7F46613F2FB5}", IStateCalcVelAz)
agcls.AgTypeNameMap["IStateCalcVelAz"] = IStateCalcVelAz

class IStateCalcC3Energy(object):
    """Properties for a C3 Energy calculation object."""
    _uuid = "{23937635-E460-428B-90CC-2EAA1C51870B}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_element_type"] = _raise_uninitialized_error
        self.__dict__["_set_element_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcC3Energy._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcC3Energy from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcC3Energy = agcom.GUID(IStateCalcC3Energy._uuid)
        vtable_offset_local = IStateCalcC3Energy._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcC3Energy, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcC3Energy, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcC3Energy, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_element_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcC3Energy, vtable_offset_local+4, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcC3Energy.__dict__ and type(IStateCalcC3Energy.__dict__[attrname]) == property:
            return IStateCalcC3Energy.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcC3Energy.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def element_type(self) -> "AgEVACalcObjectElem":
        """The element type - osculating or a mean type."""
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_element_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @element_type.setter
    def element_type(self, inVal:"AgEVACalcObjectElem") -> None:
        with agmarshall.AgEnum_arg(AgEVACalcObjectElem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_element_type"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{23937635-E460-428B-90CC-2EAA1C51870B}", IStateCalcC3Energy)
agcls.AgTypeNameMap["IStateCalcC3Energy"] = IStateCalcC3Energy

class IStateCalcInAsympDec(object):
    """Properties for an Incoming Asymptote Dec calculation object."""
    _uuid = "{BE07A06D-B79A-45C7-A460-A2D22467F1CF}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_set_coord_system_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcInAsympDec._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcInAsympDec from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcInAsympDec = agcom.GUID(IStateCalcInAsympDec._uuid)
        vtable_offset_local = IStateCalcInAsympDec._vtable_offset - 1
        self.__dict__["_get_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcInAsympDec, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcInAsympDec, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcInAsympDec.__dict__ and type(IStateCalcInAsympDec.__dict__[attrname]) == property:
            return IStateCalcInAsympDec.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcInAsympDec.")
    
    @property
    def coord_system_name(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_system_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_system_name.setter
    def coord_system_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_system_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{BE07A06D-B79A-45C7-A460-A2D22467F1CF}", IStateCalcInAsympDec)
agcls.AgTypeNameMap["IStateCalcInAsympDec"] = IStateCalcInAsympDec

class IStateCalcInAsympRA(object):
    """Properties for a Incoming Asymptote RA calculation object."""
    _uuid = "{732CE68C-1443-4C38-A037-BD228DD1DD50}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_set_coord_system_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcInAsympRA._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcInAsympRA from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcInAsympRA = agcom.GUID(IStateCalcInAsympRA._uuid)
        vtable_offset_local = IStateCalcInAsympRA._vtable_offset - 1
        self.__dict__["_get_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcInAsympRA, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcInAsympRA, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcInAsympRA.__dict__ and type(IStateCalcInAsympRA.__dict__[attrname]) == property:
            return IStateCalcInAsympRA.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcInAsympRA.")
    
    @property
    def coord_system_name(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_system_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_system_name.setter
    def coord_system_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_system_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{732CE68C-1443-4C38-A037-BD228DD1DD50}", IStateCalcInAsympRA)
agcls.AgTypeNameMap["IStateCalcInAsympRA"] = IStateCalcInAsympRA

class IStateCalcInVelAzAtPeriapsis(object):
    """Properties for an Incoming Vel Az at Periapsis calculation object."""
    _uuid = "{10C8047E-4366-4951-A479-BEB44FE74322}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_set_coord_system_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcInVelAzAtPeriapsis._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcInVelAzAtPeriapsis from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcInVelAzAtPeriapsis = agcom.GUID(IStateCalcInVelAzAtPeriapsis._uuid)
        vtable_offset_local = IStateCalcInVelAzAtPeriapsis._vtable_offset - 1
        self.__dict__["_get_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcInVelAzAtPeriapsis, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcInVelAzAtPeriapsis, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcInVelAzAtPeriapsis.__dict__ and type(IStateCalcInVelAzAtPeriapsis.__dict__[attrname]) == property:
            return IStateCalcInVelAzAtPeriapsis.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcInVelAzAtPeriapsis.")
    
    @property
    def coord_system_name(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_system_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_system_name.setter
    def coord_system_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_system_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{10C8047E-4366-4951-A479-BEB44FE74322}", IStateCalcInVelAzAtPeriapsis)
agcls.AgTypeNameMap["IStateCalcInVelAzAtPeriapsis"] = IStateCalcInVelAzAtPeriapsis

class IStateCalcOutAsympDec(object):
    """Properties for a Outgoing Asymptote Dec calculation object."""
    _uuid = "{0DB1FF5A-2DA1-4472-A3DF-52B52989E27B}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_set_coord_system_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcOutAsympDec._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcOutAsympDec from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcOutAsympDec = agcom.GUID(IStateCalcOutAsympDec._uuid)
        vtable_offset_local = IStateCalcOutAsympDec._vtable_offset - 1
        self.__dict__["_get_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOutAsympDec, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOutAsympDec, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcOutAsympDec.__dict__ and type(IStateCalcOutAsympDec.__dict__[attrname]) == property:
            return IStateCalcOutAsympDec.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcOutAsympDec.")
    
    @property
    def coord_system_name(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_system_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_system_name.setter
    def coord_system_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_system_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{0DB1FF5A-2DA1-4472-A3DF-52B52989E27B}", IStateCalcOutAsympDec)
agcls.AgTypeNameMap["IStateCalcOutAsympDec"] = IStateCalcOutAsympDec

class IStateCalcOutAsympRA(object):
    """Properties for a Outgoing Asymptote RA calculation object."""
    _uuid = "{F2386148-5F54-40D2-91DD-322B912712B3}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_set_coord_system_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcOutAsympRA._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcOutAsympRA from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcOutAsympRA = agcom.GUID(IStateCalcOutAsympRA._uuid)
        vtable_offset_local = IStateCalcOutAsympRA._vtable_offset - 1
        self.__dict__["_get_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOutAsympRA, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOutAsympRA, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcOutAsympRA.__dict__ and type(IStateCalcOutAsympRA.__dict__[attrname]) == property:
            return IStateCalcOutAsympRA.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcOutAsympRA.")
    
    @property
    def coord_system_name(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_system_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_system_name.setter
    def coord_system_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_system_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{F2386148-5F54-40D2-91DD-322B912712B3}", IStateCalcOutAsympRA)
agcls.AgTypeNameMap["IStateCalcOutAsympRA"] = IStateCalcOutAsympRA

class IStateCalcOutVelAzAtPeriapsis(object):
    """Properties for a Outgoing Vel Az at Periapsis calculation object."""
    _uuid = "{F908643D-9C89-4EDF-B45F-948B9303F260}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_set_coord_system_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcOutVelAzAtPeriapsis._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcOutVelAzAtPeriapsis from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcOutVelAzAtPeriapsis = agcom.GUID(IStateCalcOutVelAzAtPeriapsis._uuid)
        vtable_offset_local = IStateCalcOutVelAzAtPeriapsis._vtable_offset - 1
        self.__dict__["_get_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOutVelAzAtPeriapsis, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOutVelAzAtPeriapsis, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcOutVelAzAtPeriapsis.__dict__ and type(IStateCalcOutVelAzAtPeriapsis.__dict__[attrname]) == property:
            return IStateCalcOutVelAzAtPeriapsis.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcOutVelAzAtPeriapsis.")
    
    @property
    def coord_system_name(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_system_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_system_name.setter
    def coord_system_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_system_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{F908643D-9C89-4EDF-B45F-948B9303F260}", IStateCalcOutVelAzAtPeriapsis)
agcls.AgTypeNameMap["IStateCalcOutVelAzAtPeriapsis"] = IStateCalcOutVelAzAtPeriapsis

class IStateCalcDuration(object):
    """Properties for a Duration calculation object."""
    _uuid = "{429E860D-8706-4C30-9F40-B0113E00BAF8}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcDuration._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcDuration from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcDuration = agcom.GUID(IStateCalcDuration._uuid)
        vtable_offset_local = IStateCalcDuration._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcDuration.__dict__ and type(IStateCalcDuration.__dict__[attrname]) == property:
            return IStateCalcDuration.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcDuration.")
    

agcls.AgClassCatalog.add_catalog_entry("{429E860D-8706-4C30-9F40-B0113E00BAF8}", IStateCalcDuration)
agcls.AgTypeNameMap["IStateCalcDuration"] = IStateCalcDuration

class IStateCalcUserValue(object):
    """Interface for CAgAsStateCalcUserValue"""
    _uuid = "{BB517244-9226-45E2-9048-9D4E289BA920}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_variable_name"] = _raise_uninitialized_error
        self.__dict__["_set_variable_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcUserValue._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcUserValue from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcUserValue = agcom.GUID(IStateCalcUserValue._uuid)
        vtable_offset_local = IStateCalcUserValue._vtable_offset - 1
        self.__dict__["_get_variable_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcUserValue, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_variable_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcUserValue, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcUserValue.__dict__ and type(IStateCalcUserValue.__dict__[attrname]) == property:
            return IStateCalcUserValue.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcUserValue.")
    
    @property
    def variable_name(self) -> str:
        """Name of the user variable"""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_variable_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @variable_name.setter
    def variable_name(self, inVal:str) -> None:
        """Name of the user variable"""
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_variable_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{BB517244-9226-45E2-9048-9D4E289BA920}", IStateCalcUserValue)
agcls.AgTypeNameMap["IStateCalcUserValue"] = IStateCalcUserValue

class IStateCalcVectorGeometryToolAngle(object):
    """Properties for an Vector Geometry Tool Angle calculation object."""
    _uuid = "{7EC926A3-7ED6-4091-9E74-EBA5700075A5}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_angle_name"] = _raise_uninitialized_error
        self.__dict__["_set_angle_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcVectorGeometryToolAngle._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcVectorGeometryToolAngle from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcVectorGeometryToolAngle = agcom.GUID(IStateCalcVectorGeometryToolAngle._uuid)
        vtable_offset_local = IStateCalcVectorGeometryToolAngle._vtable_offset - 1
        self.__dict__["_get_angle_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorGeometryToolAngle, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_angle_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorGeometryToolAngle, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcVectorGeometryToolAngle.__dict__ and type(IStateCalcVectorGeometryToolAngle.__dict__[attrname]) == property:
            return IStateCalcVectorGeometryToolAngle.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcVectorGeometryToolAngle.")
    
    @property
    def angle_name(self) -> str:
        """The angle."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_angle_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @angle_name.setter
    def angle_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_angle_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7EC926A3-7ED6-4091-9E74-EBA5700075A5}", IStateCalcVectorGeometryToolAngle)
agcls.AgTypeNameMap["IStateCalcVectorGeometryToolAngle"] = IStateCalcVectorGeometryToolAngle

class IStateCalcAngle(object):
    """Properties for an Angle Between Vectors calculation object."""
    _uuid = "{E703F5BA-3C07-407B-8BE6-5361172E97FF}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_vector1_name"] = _raise_uninitialized_error
        self.__dict__["_set_vector1_name"] = _raise_uninitialized_error
        self.__dict__["_get_vector2_name"] = _raise_uninitialized_error
        self.__dict__["_set_vector2_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcAngle._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcAngle from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcAngle = agcom.GUID(IStateCalcAngle._uuid)
        vtable_offset_local = IStateCalcAngle._vtable_offset - 1
        self.__dict__["_get_vector1_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcAngle, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_vector1_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcAngle, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_vector2_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcAngle, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_vector2_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcAngle, vtable_offset_local+4, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcAngle.__dict__ and type(IStateCalcAngle.__dict__[attrname]) == property:
            return IStateCalcAngle.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcAngle.")
    
    @property
    def vector1_name(self) -> str:
        """The first vector of the angle."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_vector1_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @vector1_name.setter
    def vector1_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_vector1_name"](arg_inVal.COM_val))

    @property
    def vector2_name(self) -> str:
        """The second vector of the angle."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_vector2_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @vector2_name.setter
    def vector2_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_vector2_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E703F5BA-3C07-407B-8BE6-5361172E97FF}", IStateCalcAngle)
agcls.AgTypeNameMap["IStateCalcAngle"] = IStateCalcAngle

class IStateCalcDotProduct(object):
    """Properties for a Dot Product calculation object."""
    _uuid = "{8B3C8283-79EC-48D1-BFBD-66775AA10803}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_vector1_name"] = _raise_uninitialized_error
        self.__dict__["_set_vector1_name"] = _raise_uninitialized_error
        self.__dict__["_get_vector2_name"] = _raise_uninitialized_error
        self.__dict__["_set_vector2_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcDotProduct._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcDotProduct from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcDotProduct = agcom.GUID(IStateCalcDotProduct._uuid)
        vtable_offset_local = IStateCalcDotProduct._vtable_offset - 1
        self.__dict__["_get_vector1_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDotProduct, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_vector1_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDotProduct, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_vector2_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDotProduct, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_vector2_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDotProduct, vtable_offset_local+4, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcDotProduct.__dict__ and type(IStateCalcDotProduct.__dict__[attrname]) == property:
            return IStateCalcDotProduct.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcDotProduct.")
    
    @property
    def vector1_name(self) -> str:
        """The first vector."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_vector1_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @vector1_name.setter
    def vector1_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_vector1_name"](arg_inVal.COM_val))

    @property
    def vector2_name(self) -> str:
        """The second vector."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_vector2_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @vector2_name.setter
    def vector2_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_vector2_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{8B3C8283-79EC-48D1-BFBD-66775AA10803}", IStateCalcDotProduct)
agcls.AgTypeNameMap["IStateCalcDotProduct"] = IStateCalcDotProduct

class IStateCalcVectorDec(object):
    """Properties for a Vector Dec calculation object."""
    _uuid = "{5709E392-CEF3-4D83-BC2C-FD3F67EE363F}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_coord_axes_name"] = _raise_uninitialized_error
        self.__dict__["_set_coord_axes_name"] = _raise_uninitialized_error
        self.__dict__["_get_vector_name"] = _raise_uninitialized_error
        self.__dict__["_set_vector_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcVectorDec._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcVectorDec from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcVectorDec = agcom.GUID(IStateCalcVectorDec._uuid)
        vtable_offset_local = IStateCalcVectorDec._vtable_offset - 1
        self.__dict__["_get_coord_axes_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorDec, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_coord_axes_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorDec, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_vector_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorDec, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_vector_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorDec, vtable_offset_local+4, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcVectorDec.__dict__ and type(IStateCalcVectorDec.__dict__[attrname]) == property:
            return IStateCalcVectorDec.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcVectorDec.")
    
    @property
    def coord_axes_name(self) -> str:
        """The coordinate axes."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_axes_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_axes_name.setter
    def coord_axes_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_axes_name"](arg_inVal.COM_val))

    @property
    def vector_name(self) -> str:
        """The vector."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_vector_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @vector_name.setter
    def vector_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_vector_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{5709E392-CEF3-4D83-BC2C-FD3F67EE363F}", IStateCalcVectorDec)
agcls.AgTypeNameMap["IStateCalcVectorDec"] = IStateCalcVectorDec

class IStateCalcVectorMagnitude(object):
    """Properties for a Vector Mag calculation object."""
    _uuid = "{522AF5A3-02FE-49E3-931A-3E8234EF896F}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_vector_name"] = _raise_uninitialized_error
        self.__dict__["_set_vector_name"] = _raise_uninitialized_error
        self.__dict__["_get_unit_dimension"] = _raise_uninitialized_error
        self.__dict__["_set_unit_dimension"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcVectorMagnitude._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcVectorMagnitude from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcVectorMagnitude = agcom.GUID(IStateCalcVectorMagnitude._uuid)
        vtable_offset_local = IStateCalcVectorMagnitude._vtable_offset - 1
        self.__dict__["_get_vector_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorMagnitude, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_vector_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorMagnitude, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_unit_dimension"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorMagnitude, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_unit_dimension"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorMagnitude, vtable_offset_local+4, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcVectorMagnitude.__dict__ and type(IStateCalcVectorMagnitude.__dict__[attrname]) == property:
            return IStateCalcVectorMagnitude.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcVectorMagnitude.")
    
    @property
    def vector_name(self) -> str:
        """The vector."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_vector_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @vector_name.setter
    def vector_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_vector_name"](arg_inVal.COM_val))

    @property
    def unit_dimension(self) -> str:
        """The unit dimension."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_unit_dimension"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @unit_dimension.setter
    def unit_dimension(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_unit_dimension"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{522AF5A3-02FE-49E3-931A-3E8234EF896F}", IStateCalcVectorMagnitude)
agcls.AgTypeNameMap["IStateCalcVectorMagnitude"] = IStateCalcVectorMagnitude

class IStateCalcVectorRA(object):
    """Properties for a Vector RA calculation object."""
    _uuid = "{E6AF6E11-F9BC-46E0-83C0-ACD79B45B4AD}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_coord_axes_name"] = _raise_uninitialized_error
        self.__dict__["_set_coord_axes_name"] = _raise_uninitialized_error
        self.__dict__["_get_vector_name"] = _raise_uninitialized_error
        self.__dict__["_set_vector_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcVectorRA._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcVectorRA from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcVectorRA = agcom.GUID(IStateCalcVectorRA._uuid)
        vtable_offset_local = IStateCalcVectorRA._vtable_offset - 1
        self.__dict__["_get_coord_axes_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorRA, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_coord_axes_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorRA, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_vector_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorRA, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_vector_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcVectorRA, vtable_offset_local+4, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcVectorRA.__dict__ and type(IStateCalcVectorRA.__dict__[attrname]) == property:
            return IStateCalcVectorRA.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcVectorRA.")
    
    @property
    def coord_axes_name(self) -> str:
        """The coordinate axes."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_axes_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_axes_name.setter
    def coord_axes_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_axes_name"](arg_inVal.COM_val))

    @property
    def vector_name(self) -> str:
        """The vector."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_vector_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @vector_name.setter
    def vector_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_vector_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E6AF6E11-F9BC-46E0-83C0-ACD79B45B4AD}", IStateCalcVectorRA)
agcls.AgTypeNameMap["IStateCalcVectorRA"] = IStateCalcVectorRA

class IStateCalcOnePointAccess(object):
    """Properties for an Access calculation object."""
    _uuid = "{EE091E20-3104-48F9-8163-29272A8B81C8}"
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_aberration_type"] = _raise_uninitialized_error
        self.__dict__["_set_aberration_type"] = _raise_uninitialized_error
        self.__dict__["_set_base_selection"] = _raise_uninitialized_error
        self.__dict__["_get_base_selection_type"] = _raise_uninitialized_error
        self.__dict__["_get_base_selection"] = _raise_uninitialized_error
        self.__dict__["_get_clock_host"] = _raise_uninitialized_error
        self.__dict__["_set_clock_host"] = _raise_uninitialized_error
        self.__dict__["_get_signal_sense"] = _raise_uninitialized_error
        self.__dict__["_set_signal_sense"] = _raise_uninitialized_error
        self.__dict__["_get_target_object"] = _raise_uninitialized_error
        self.__dict__["_get_time_delay_convergence_tolerance"] = _raise_uninitialized_error
        self.__dict__["_set_time_delay_convergence_tolerance"] = _raise_uninitialized_error
        self.__dict__["_get_use_light_time_delay"] = _raise_uninitialized_error
        self.__dict__["_set_use_light_time_delay"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcOnePointAccess._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcOnePointAccess from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcOnePointAccess = agcom.GUID(IStateCalcOnePointAccess._uuid)
        vtable_offset_local = IStateCalcOnePointAccess._vtable_offset - 1
        self.__dict__["_get_aberration_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOnePointAccess, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_aberration_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOnePointAccess, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_set_base_selection"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOnePointAccess, vtable_offset_local+3, agcom.LONG)
        self.__dict__["_get_base_selection_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOnePointAccess, vtable_offset_local+4, POINTER(agcom.LONG))
        self.__dict__["_get_base_selection"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOnePointAccess, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_clock_host"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOnePointAccess, vtable_offset_local+6, POINTER(agcom.LONG))
        self.__dict__["_set_clock_host"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOnePointAccess, vtable_offset_local+7, agcom.LONG)
        self.__dict__["_get_signal_sense"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOnePointAccess, vtable_offset_local+8, POINTER(agcom.LONG))
        self.__dict__["_set_signal_sense"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOnePointAccess, vtable_offset_local+9, agcom.LONG)
        self.__dict__["_get_target_object"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOnePointAccess, vtable_offset_local+10, POINTER(agcom.PVOID))
        self.__dict__["_get_time_delay_convergence_tolerance"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOnePointAccess, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_time_delay_convergence_tolerance"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOnePointAccess, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_use_light_time_delay"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOnePointAccess, vtable_offset_local+13, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_light_time_delay"] = IAGFUNCTYPE(pUnk, IID_IStateCalcOnePointAccess, vtable_offset_local+14, agcom.VARIANT_BOOL)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcOnePointAccess.__dict__ and type(IStateCalcOnePointAccess.__dict__[attrname]) == property:
            return IStateCalcOnePointAccess.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcOnePointAccess.")
    
    @property
    def aberration_type(self) -> "AgEAberrationType":
        """The type of aberration to use, if light time delay is applied."""
        with agmarshall.AgEnum_arg(AgEAberrationType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_aberration_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @aberration_type.setter
    def aberration_type(self, inVal:"AgEAberrationType") -> None:
        with agmarshall.AgEnum_arg(AgEAberrationType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_aberration_type"](arg_inVal.COM_val))

    def set_base_selection(self, selection:"AgEVABaseSelection") -> None:
        """Base Selection"""
        with agmarshall.AgEnum_arg(AgEVABaseSelection, selection) as arg_selection:
            agcls.evaluate_hresult(self.__dict__["_set_base_selection"](arg_selection.COM_val))

    @property
    def base_selection_type(self) -> "AgEVABaseSelection":
        """The base selection type."""
        with agmarshall.AgEnum_arg(AgEVABaseSelection) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_base_selection_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def base_selection(self) -> "ILinkToObject":
        """The base selection object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_base_selection"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def clock_host(self) -> "AgEIvClockHost":
        """The object whose location is associated with time."""
        with agmarshall.AgEnum_arg(AgEIvClockHost) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_clock_host"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @clock_host.setter
    def clock_host(self, inVal:"AgEIvClockHost") -> None:
        with agmarshall.AgEnum_arg(AgEIvClockHost, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_clock_host"](arg_inVal.COM_val))

    @property
    def signal_sense(self) -> "AgEIvTimeSense":
        """Sense of the signal at the base object."""
        with agmarshall.AgEnum_arg(AgEIvTimeSense) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_signal_sense"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @signal_sense.setter
    def signal_sense(self, inVal:"AgEIvTimeSense") -> None:
        with agmarshall.AgEnum_arg(AgEIvTimeSense, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_signal_sense"](arg_inVal.COM_val))

    @property
    def target_object(self) -> "ILinkToObject":
        """The target object."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_target_object"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def time_delay_convergence_tolerance(self) -> float:
        """The time delay convergence tolerance, if light time delay is applied. Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_time_delay_convergence_tolerance"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @time_delay_convergence_tolerance.setter
    def time_delay_convergence_tolerance(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_time_delay_convergence_tolerance"](arg_inVal.COM_val))

    @property
    def use_light_time_delay(self) -> bool:
        """Tue if light time delay is applied."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_light_time_delay"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_light_time_delay.setter
    def use_light_time_delay(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_light_time_delay"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{EE091E20-3104-48F9-8163-29272A8B81C8}", IStateCalcOnePointAccess)
agcls.AgTypeNameMap["IStateCalcOnePointAccess"] = IStateCalcOnePointAccess

class IStateCalcDifferenceAcrossSegmentsOtherSat(object):
    """Properties for a Difference Across Segments Across Satellites calculation object."""
    _uuid = "{C5C0E056-EC28-4D88-A55F-6BA6D2F2976E}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_calc_object_name"] = _raise_uninitialized_error
        self.__dict__["_set_calc_object_name"] = _raise_uninitialized_error
        self.__dict__["_get_other_segment_name"] = _raise_uninitialized_error
        self.__dict__["_set_other_segment_name"] = _raise_uninitialized_error
        self.__dict__["_get_segment_state_to_use"] = _raise_uninitialized_error
        self.__dict__["_set_segment_state_to_use"] = _raise_uninitialized_error
        self.__dict__["_get_difference_order"] = _raise_uninitialized_error
        self.__dict__["_set_difference_order"] = _raise_uninitialized_error
        self.__dict__["_get_reference_sat"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcDifferenceAcrossSegmentsOtherSat._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcDifferenceAcrossSegmentsOtherSat from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcDifferenceAcrossSegmentsOtherSat = agcom.GUID(IStateCalcDifferenceAcrossSegmentsOtherSat._uuid)
        vtable_offset_local = IStateCalcDifferenceAcrossSegmentsOtherSat._vtable_offset - 1
        self.__dict__["_get_calc_object_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDifferenceAcrossSegmentsOtherSat, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_calc_object_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDifferenceAcrossSegmentsOtherSat, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_other_segment_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDifferenceAcrossSegmentsOtherSat, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_other_segment_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDifferenceAcrossSegmentsOtherSat, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_get_segment_state_to_use"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDifferenceAcrossSegmentsOtherSat, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_segment_state_to_use"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDifferenceAcrossSegmentsOtherSat, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_difference_order"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDifferenceAcrossSegmentsOtherSat, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_difference_order"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDifferenceAcrossSegmentsOtherSat, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_reference_sat"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDifferenceAcrossSegmentsOtherSat, vtable_offset_local+9, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcDifferenceAcrossSegmentsOtherSat.__dict__ and type(IStateCalcDifferenceAcrossSegmentsOtherSat.__dict__[attrname]) == property:
            return IStateCalcDifferenceAcrossSegmentsOtherSat.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcDifferenceAcrossSegmentsOtherSat.")
    
    @property
    def calc_object_name(self) -> str:
        """The calculation object."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_calc_object_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @calc_object_name.setter
    def calc_object_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_calc_object_name"](arg_inVal.COM_val))

    @property
    def other_segment_name(self) -> str:
        """The segment to be compared against."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_other_segment_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @other_segment_name.setter
    def other_segment_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_other_segment_name"](arg_inVal.COM_val))

    @property
    def segment_state_to_use(self) -> "AgEVASegmentState":
        """The segment state to use in the calculation."""
        with agmarshall.AgEnum_arg(AgEVASegmentState) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_segment_state_to_use"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @segment_state_to_use.setter
    def segment_state_to_use(self, inVal:"AgEVASegmentState") -> None:
        with agmarshall.AgEnum_arg(AgEVASegmentState, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_segment_state_to_use"](arg_inVal.COM_val))

    @property
    def difference_order(self) -> "AgEVASegmentDifferenceOrder":
        """The order of the difference calculation."""
        with agmarshall.AgEnum_arg(AgEVASegmentDifferenceOrder) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_difference_order"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @difference_order.setter
    def difference_order(self, inVal:"AgEVASegmentDifferenceOrder") -> None:
        with agmarshall.AgEnum_arg(AgEVASegmentDifferenceOrder, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_difference_order"](arg_inVal.COM_val))

    @property
    def reference_sat(self) -> "ILinkToObject":
        """The Astrogator satellite on which the segment to be compared exists."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_get_reference_sat"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val


agcls.AgClassCatalog.add_catalog_entry("{C5C0E056-EC28-4D88-A55F-6BA6D2F2976E}", IStateCalcDifferenceAcrossSegmentsOtherSat)
agcls.AgTypeNameMap["IStateCalcDifferenceAcrossSegmentsOtherSat"] = IStateCalcDifferenceAcrossSegmentsOtherSat

class IStateCalcValueAtSegmentOtherSat(object):
    """Properties for a Value At Segment Across Satellites calculation object."""
    _uuid = "{1F7F3653-10FD-4377-B8FB-8C42DABDACC3}"
    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_calc_object_name"] = _raise_uninitialized_error
        self.__dict__["_set_calc_object_name"] = _raise_uninitialized_error
        self.__dict__["_get_other_segment_name"] = _raise_uninitialized_error
        self.__dict__["_set_other_segment_name"] = _raise_uninitialized_error
        self.__dict__["_get_segment_state_to_use"] = _raise_uninitialized_error
        self.__dict__["_set_segment_state_to_use"] = _raise_uninitialized_error
        self.__dict__["_get_reference_sat"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcValueAtSegmentOtherSat._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcValueAtSegmentOtherSat from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcValueAtSegmentOtherSat = agcom.GUID(IStateCalcValueAtSegmentOtherSat._uuid)
        vtable_offset_local = IStateCalcValueAtSegmentOtherSat._vtable_offset - 1
        self.__dict__["_get_calc_object_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcValueAtSegmentOtherSat, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_calc_object_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcValueAtSegmentOtherSat, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_other_segment_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcValueAtSegmentOtherSat, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_other_segment_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcValueAtSegmentOtherSat, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_get_segment_state_to_use"] = IAGFUNCTYPE(pUnk, IID_IStateCalcValueAtSegmentOtherSat, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_segment_state_to_use"] = IAGFUNCTYPE(pUnk, IID_IStateCalcValueAtSegmentOtherSat, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_reference_sat"] = IAGFUNCTYPE(pUnk, IID_IStateCalcValueAtSegmentOtherSat, vtable_offset_local+7, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcValueAtSegmentOtherSat.__dict__ and type(IStateCalcValueAtSegmentOtherSat.__dict__[attrname]) == property:
            return IStateCalcValueAtSegmentOtherSat.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcValueAtSegmentOtherSat.")
    
    @property
    def calc_object_name(self) -> str:
        """The calculation object."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_calc_object_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @calc_object_name.setter
    def calc_object_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_calc_object_name"](arg_inVal.COM_val))

    @property
    def other_segment_name(self) -> str:
        """The segment to be compared against."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_other_segment_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @other_segment_name.setter
    def other_segment_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_other_segment_name"](arg_inVal.COM_val))

    @property
    def segment_state_to_use(self) -> "AgEVASegmentState":
        """The segment state to use in the calculation."""
        with agmarshall.AgEnum_arg(AgEVASegmentState) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_segment_state_to_use"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @segment_state_to_use.setter
    def segment_state_to_use(self, inVal:"AgEVASegmentState") -> None:
        with agmarshall.AgEnum_arg(AgEVASegmentState, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_segment_state_to_use"](arg_inVal.COM_val))

    @property
    def reference_sat(self) -> "ILinkToObject":
        """The Astrogator satellite on which the segment to be compared exists."""
        with agmarshall.AgInterface_out_arg() as arg_ppLinkToObject:
            agcls.evaluate_hresult(self.__dict__["_get_reference_sat"](byref(arg_ppLinkToObject.COM_val)))
            return arg_ppLinkToObject.python_val


agcls.AgClassCatalog.add_catalog_entry("{1F7F3653-10FD-4377-B8FB-8C42DABDACC3}", IStateCalcValueAtSegmentOtherSat)
agcls.AgTypeNameMap["IStateCalcValueAtSegmentOtherSat"] = IStateCalcValueAtSegmentOtherSat

class IStateCalcRARate(object):
    """Properties for a Right Ascension Rate calculation object"""
    _uuid = "{69DDD91C-168B-47BD-9977-EB8431B4C112}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_set_coord_system_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcRARate._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcRARate from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcRARate = agcom.GUID(IStateCalcRARate._uuid)
        vtable_offset_local = IStateCalcRARate._vtable_offset - 1
        self.__dict__["_get_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRARate, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcRARate, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcRARate.__dict__ and type(IStateCalcRARate.__dict__[attrname]) == property:
            return IStateCalcRARate.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcRARate.")
    
    @property
    def coord_system_name(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_system_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_system_name.setter
    def coord_system_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_system_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{69DDD91C-168B-47BD-9977-EB8431B4C112}", IStateCalcRARate)
agcls.AgTypeNameMap["IStateCalcRARate"] = IStateCalcRARate

class IStateCalcDecRate(object):
    """Properties for a Declination Rate calculation object"""
    _uuid = "{EE447FA6-4B21-4823-8811-E0E3C38A29E2}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_coord_system_name"] = _raise_uninitialized_error
        self.__dict__["_set_coord_system_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcDecRate._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcDecRate from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcDecRate = agcom.GUID(IStateCalcDecRate._uuid)
        vtable_offset_local = IStateCalcDecRate._vtable_offset - 1
        self.__dict__["_get_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDecRate, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_coord_system_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcDecRate, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcDecRate.__dict__ and type(IStateCalcDecRate.__dict__[attrname]) == property:
            return IStateCalcDecRate.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcDecRate.")
    
    @property
    def coord_system_name(self) -> str:
        """The coordinate system within which the element is defined."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coord_system_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coord_system_name.setter
    def coord_system_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_coord_system_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{EE447FA6-4B21-4823-8811-E0E3C38A29E2}", IStateCalcDecRate)
agcls.AgTypeNameMap["IStateCalcDecRate"] = IStateCalcDecRate

class IStateCalcGravitationalParameter(object):
    """Properties for a Gravitational Parameter calculation object."""
    _uuid = "{1FE2F1B7-9FE8-409E-AAD8-92CC002CDED0}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_grav_source"] = _raise_uninitialized_error
        self.__dict__["_set_grav_source"] = _raise_uninitialized_error
        self.__dict__["_get_gravity_filename"] = _raise_uninitialized_error
        self.__dict__["_set_gravity_filename"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcGravitationalParameter._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcGravitationalParameter from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcGravitationalParameter = agcom.GUID(IStateCalcGravitationalParameter._uuid)
        vtable_offset_local = IStateCalcGravitationalParameter._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcGravitationalParameter, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcGravitationalParameter, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_grav_source"] = IAGFUNCTYPE(pUnk, IID_IStateCalcGravitationalParameter, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_grav_source"] = IAGFUNCTYPE(pUnk, IID_IStateCalcGravitationalParameter, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_gravity_filename"] = IAGFUNCTYPE(pUnk, IID_IStateCalcGravitationalParameter, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_set_gravity_filename"] = IAGFUNCTYPE(pUnk, IID_IStateCalcGravitationalParameter, vtable_offset_local+6, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcGravitationalParameter.__dict__ and type(IStateCalcGravitationalParameter.__dict__[attrname]) == property:
            return IStateCalcGravitationalParameter.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcGravitationalParameter.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def grav_source(self) -> "AgEVAGravitationalParameterSource":
        """The source for the gravitational parameter."""
        with agmarshall.AgEnum_arg(AgEVAGravitationalParameterSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_grav_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @grav_source.setter
    def grav_source(self, inVal:"AgEVAGravitationalParameterSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAGravitationalParameterSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_grav_source"](arg_inVal.COM_val))

    @property
    def gravity_filename(self) -> str:
        """Source for the gravitational parameter if GravSource is set to Gravity File."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_gravity_filename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @gravity_filename.setter
    def gravity_filename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_gravity_filename"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{1FE2F1B7-9FE8-409E-AAD8-92CC002CDED0}", IStateCalcGravitationalParameter)
agcls.AgTypeNameMap["IStateCalcGravitationalParameter"] = IStateCalcGravitationalParameter

class IStateCalcReferenceRadius(object):
    """Properties for a Reference Radius calculation object."""
    _uuid = "{E736A217-0B66-48F6-99FA-D338835B4D40}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_reference_radius_source"] = _raise_uninitialized_error
        self.__dict__["_set_reference_radius_source"] = _raise_uninitialized_error
        self.__dict__["_get_gravity_filename"] = _raise_uninitialized_error
        self.__dict__["_set_gravity_filename"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcReferenceRadius._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcReferenceRadius from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcReferenceRadius = agcom.GUID(IStateCalcReferenceRadius._uuid)
        vtable_offset_local = IStateCalcReferenceRadius._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcReferenceRadius, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcReferenceRadius, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_reference_radius_source"] = IAGFUNCTYPE(pUnk, IID_IStateCalcReferenceRadius, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_reference_radius_source"] = IAGFUNCTYPE(pUnk, IID_IStateCalcReferenceRadius, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_gravity_filename"] = IAGFUNCTYPE(pUnk, IID_IStateCalcReferenceRadius, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_set_gravity_filename"] = IAGFUNCTYPE(pUnk, IID_IStateCalcReferenceRadius, vtable_offset_local+6, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcReferenceRadius.__dict__ and type(IStateCalcReferenceRadius.__dict__[attrname]) == property:
            return IStateCalcReferenceRadius.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcReferenceRadius.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def reference_radius_source(self) -> "AgEVAReferenceRadiusSource":
        """The source for the reference radius."""
        with agmarshall.AgEnum_arg(AgEVAReferenceRadiusSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_radius_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_radius_source.setter
    def reference_radius_source(self, inVal:"AgEVAReferenceRadiusSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAReferenceRadiusSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_radius_source"](arg_inVal.COM_val))

    @property
    def gravity_filename(self) -> str:
        """Source for the reference radius if RefRadSource is set to Gravity File."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_gravity_filename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @gravity_filename.setter
    def gravity_filename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_gravity_filename"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E736A217-0B66-48F6-99FA-D338835B4D40}", IStateCalcReferenceRadius)
agcls.AgTypeNameMap["IStateCalcReferenceRadius"] = IStateCalcReferenceRadius

class IStateCalcGravCoeff(object):
    """Properties for a gravity coefficient calculation object."""
    _uuid = "{057976B1-EBDA-4674-9FC0-556D7BD87599}"
    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_gravity_filename"] = _raise_uninitialized_error
        self.__dict__["_set_gravity_filename"] = _raise_uninitialized_error
        self.__dict__["_get_coefficient_type"] = _raise_uninitialized_error
        self.__dict__["_set_coefficient_type"] = _raise_uninitialized_error
        self.__dict__["_get_degree"] = _raise_uninitialized_error
        self.__dict__["_set_degree"] = _raise_uninitialized_error
        self.__dict__["_get_order"] = _raise_uninitialized_error
        self.__dict__["_set_order"] = _raise_uninitialized_error
        self.__dict__["_get_normalization_type"] = _raise_uninitialized_error
        self.__dict__["_set_normalization_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcGravCoeff._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcGravCoeff from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcGravCoeff = agcom.GUID(IStateCalcGravCoeff._uuid)
        vtable_offset_local = IStateCalcGravCoeff._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcGravCoeff, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcGravCoeff, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_gravity_filename"] = IAGFUNCTYPE(pUnk, IID_IStateCalcGravCoeff, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_gravity_filename"] = IAGFUNCTYPE(pUnk, IID_IStateCalcGravCoeff, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_get_coefficient_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcGravCoeff, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_coefficient_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcGravCoeff, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_degree"] = IAGFUNCTYPE(pUnk, IID_IStateCalcGravCoeff, vtable_offset_local+7, POINTER(agcom.INT))
        self.__dict__["_set_degree"] = IAGFUNCTYPE(pUnk, IID_IStateCalcGravCoeff, vtable_offset_local+8, agcom.INT)
        self.__dict__["_get_order"] = IAGFUNCTYPE(pUnk, IID_IStateCalcGravCoeff, vtable_offset_local+9, POINTER(agcom.INT))
        self.__dict__["_set_order"] = IAGFUNCTYPE(pUnk, IID_IStateCalcGravCoeff, vtable_offset_local+10, agcom.INT)
        self.__dict__["_get_normalization_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcGravCoeff, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_set_normalization_type"] = IAGFUNCTYPE(pUnk, IID_IStateCalcGravCoeff, vtable_offset_local+12, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcGravCoeff.__dict__ and type(IStateCalcGravCoeff.__dict__[attrname]) == property:
            return IStateCalcGravCoeff.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcGravCoeff.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def gravity_filename(self) -> str:
        """Source for the gravity coefficient."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_gravity_filename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @gravity_filename.setter
    def gravity_filename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_gravity_filename"](arg_inVal.COM_val))

    @property
    def coefficient_type(self) -> "AgEVAGravCoeffCoefficientType":
        """Coefficient type."""
        with agmarshall.AgEnum_arg(AgEVAGravCoeffCoefficientType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coefficient_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coefficient_type.setter
    def coefficient_type(self, inVal:"AgEVAGravCoeffCoefficientType") -> None:
        with agmarshall.AgEnum_arg(AgEVAGravCoeffCoefficientType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_coefficient_type"](arg_inVal.COM_val))

    @property
    def degree(self) -> int:
        """Degree of the coefficient."""
        with agmarshall.INT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_degree"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @degree.setter
    def degree(self, inVal:int) -> None:
        with agmarshall.INT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_degree"](arg_inVal.COM_val))

    @property
    def order(self) -> int:
        """Order of the coefficient."""
        with agmarshall.INT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_order"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @order.setter
    def order(self, inVal:int) -> None:
        with agmarshall.INT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_order"](arg_inVal.COM_val))

    @property
    def normalization_type(self) -> "AgEVAGravCoeffNormalizationType":
        """Normalization type."""
        with agmarshall.AgEnum_arg(AgEVAGravCoeffNormalizationType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_normalization_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @normalization_type.setter
    def normalization_type(self, inVal:"AgEVAGravCoeffNormalizationType") -> None:
        with agmarshall.AgEnum_arg(AgEVAGravCoeffNormalizationType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_normalization_type"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{057976B1-EBDA-4674-9FC0-556D7BD87599}", IStateCalcGravCoeff)
agcls.AgTypeNameMap["IStateCalcGravCoeff"] = IStateCalcGravCoeff

class IStateCalcSpeedOfLight(object):
    """Properties for a Speed of Light calculation object."""
    _uuid = "{6B7D157C-43CA-4ED4-9C3C-DF8E4ABAE4E0}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcSpeedOfLight._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcSpeedOfLight from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcSpeedOfLight = agcom.GUID(IStateCalcSpeedOfLight._uuid)
        vtable_offset_local = IStateCalcSpeedOfLight._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcSpeedOfLight.__dict__ and type(IStateCalcSpeedOfLight.__dict__[attrname]) == property:
            return IStateCalcSpeedOfLight.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcSpeedOfLight.")
    

agcls.AgClassCatalog.add_catalog_entry("{6B7D157C-43CA-4ED4-9C3C-DF8E4ABAE4E0}", IStateCalcSpeedOfLight)
agcls.AgTypeNameMap["IStateCalcSpeedOfLight"] = IStateCalcSpeedOfLight

class IStateCalcPi(object):
    """Properties for a Pi calculation object."""
    _uuid = "{DDE94FB4-1751-4F38-9304-5ACC35CDC811}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcPi._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcPi from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcPi = agcom.GUID(IStateCalcPi._uuid)
        vtable_offset_local = IStateCalcPi._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcPi.__dict__ and type(IStateCalcPi.__dict__[attrname]) == property:
            return IStateCalcPi.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcPi.")
    

agcls.AgClassCatalog.add_catalog_entry("{DDE94FB4-1751-4F38-9304-5ACC35CDC811}", IStateCalcPi)
agcls.AgTypeNameMap["IStateCalcPi"] = IStateCalcPi

class IStateCalcScalar(object):
    """Properties for a Scalar calculation object."""
    _uuid = "{D792B480-CCC7-4040-BD41-A26E56DE6CA8}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_scalar_name"] = _raise_uninitialized_error
        self.__dict__["_set_scalar_name"] = _raise_uninitialized_error
        self.__dict__["_get_unit_dimension"] = _raise_uninitialized_error
        self.__dict__["_set_unit_dimension"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcScalar._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcScalar from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcScalar = agcom.GUID(IStateCalcScalar._uuid)
        vtable_offset_local = IStateCalcScalar._vtable_offset - 1
        self.__dict__["_get_scalar_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcScalar, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_scalar_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcScalar, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_unit_dimension"] = IAGFUNCTYPE(pUnk, IID_IStateCalcScalar, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_unit_dimension"] = IAGFUNCTYPE(pUnk, IID_IStateCalcScalar, vtable_offset_local+4, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcScalar.__dict__ and type(IStateCalcScalar.__dict__[attrname]) == property:
            return IStateCalcScalar.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcScalar.")
    
    @property
    def scalar_name(self) -> str:
        """The scalar name."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_scalar_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @scalar_name.setter
    def scalar_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_scalar_name"](arg_inVal.COM_val))

    @property
    def unit_dimension(self) -> str:
        """The unit dimension."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_unit_dimension"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @unit_dimension.setter
    def unit_dimension(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_unit_dimension"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{D792B480-CCC7-4040-BD41-A26E56DE6CA8}", IStateCalcScalar)
agcls.AgTypeNameMap["IStateCalcScalar"] = IStateCalcScalar

class IStateCalcApparentSolarTime(object):
    """Properties for an Apparent Solar Time calculation object."""
    _uuid = "{439AD289-B0FE-4596-A6AC-A29B6F98C313}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcApparentSolarTime._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcApparentSolarTime from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcApparentSolarTime = agcom.GUID(IStateCalcApparentSolarTime._uuid)
        vtable_offset_local = IStateCalcApparentSolarTime._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcApparentSolarTime, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcApparentSolarTime, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcApparentSolarTime.__dict__ and type(IStateCalcApparentSolarTime.__dict__[attrname]) == property:
            return IStateCalcApparentSolarTime.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcApparentSolarTime.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{439AD289-B0FE-4596-A6AC-A29B6F98C313}", IStateCalcApparentSolarTime)
agcls.AgTypeNameMap["IStateCalcApparentSolarTime"] = IStateCalcApparentSolarTime

class IStateCalcEarthMeanSolarTime(object):
    """Properties for an Earth Mean Solar Time calculation object."""
    _uuid = "{45C37D81-A752-4AA8-AC7D-7FAD78AA7763}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcEarthMeanSolarTime._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcEarthMeanSolarTime from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcEarthMeanSolarTime = agcom.GUID(IStateCalcEarthMeanSolarTime._uuid)
        vtable_offset_local = IStateCalcEarthMeanSolarTime._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcEarthMeanSolarTime, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcEarthMeanSolarTime, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcEarthMeanSolarTime.__dict__ and type(IStateCalcEarthMeanSolarTime.__dict__[attrname]) == property:
            return IStateCalcEarthMeanSolarTime.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcEarthMeanSolarTime.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{45C37D81-A752-4AA8-AC7D-7FAD78AA7763}", IStateCalcEarthMeanSolarTime)
agcls.AgTypeNameMap["IStateCalcEarthMeanSolarTime"] = IStateCalcEarthMeanSolarTime

class IStateCalcEarthMeanLocTimeAN(object):
    """Properties for an Earth Mean Local Time of Ascending Node calculation object."""
    _uuid = "{325E3769-FB5E-4B6B-AC89-48CD5A09C528}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateCalcEarthMeanLocTimeAN._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateCalcEarthMeanLocTimeAN from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateCalcEarthMeanLocTimeAN = agcom.GUID(IStateCalcEarthMeanLocTimeAN._uuid)
        vtable_offset_local = IStateCalcEarthMeanLocTimeAN._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcEarthMeanLocTimeAN, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IStateCalcEarthMeanLocTimeAN, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateCalcEarthMeanLocTimeAN.__dict__ and type(IStateCalcEarthMeanLocTimeAN.__dict__[attrname]) == property:
            return IStateCalcEarthMeanLocTimeAN.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateCalcEarthMeanLocTimeAN.")
    
    @property
    def central_body_name(self) -> str:
        """The central body of the component."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{325E3769-FB5E-4B6B-AC89-48CD5A09C528}", IStateCalcEarthMeanLocTimeAN)
agcls.AgTypeNameMap["IStateCalcEarthMeanLocTimeAN"] = IStateCalcEarthMeanLocTimeAN

class ICentralBodyCollection(object):
    """The list of central bodies."""
    _uuid = "{6A2BFAF1-F26A-439B-AF23-AD83B82A0D4A}"
    _num_methods = 8
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_add"] = _raise_uninitialized_error
        self.__dict__["_remove"] = _raise_uninitialized_error
        self.__dict__["_remove_all"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_index"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICentralBodyCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICentralBodyCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICentralBodyCollection = agcom.GUID(ICentralBodyCollection._uuid)
        vtable_offset_local = ICentralBodyCollection._vtable_offset - 1
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyCollection, vtable_offset_local+1, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyCollection, vtable_offset_local+2, POINTER(agcom.LONG))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyCollection, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_add"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyCollection, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_remove"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyCollection, vtable_offset_local+5, agcom.VARIANT)
        self.__dict__["_remove_all"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyCollection, vtable_offset_local+6, )
        self.__dict__["_get_item_by_index"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyCollection, vtable_offset_local+7, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_get_item_by_name"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyCollection, vtable_offset_local+8, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICentralBodyCollection.__dict__ and type(ICentralBodyCollection.__dict__[attrname]) == property:
            return ICentralBodyCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICentralBodyCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IAstrogatorCentralBody":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def item(self, indexOrCbName:typing.Any) -> "IAstrogatorCentralBody":
        """Allows you to iterate through the collection."""
        with agmarshall.VARIANT_arg(indexOrCbName) as arg_indexOrCbName, \
             agmarshall.AgInterface_out_arg() as arg_ppCentralBody:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_indexOrCbName.COM_val, byref(arg_ppCentralBody.COM_val)))
            return arg_ppCentralBody.python_val

    @property
    def count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Iterates through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def add(self, cbName:str) -> None:
        """Adds a central body to the collection."""
        with agmarshall.BSTR_arg(cbName) as arg_cbName:
            agcls.evaluate_hresult(self.__dict__["_add"](arg_cbName.COM_val))

    def remove(self, indexOrName:typing.Any) -> None:
        """Removes a central body from the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_remove"](arg_indexOrName.COM_val))

    def remove_all(self) -> None:
        """Remove all central bodies from the collection."""
        agcls.evaluate_hresult(self.__dict__["_remove_all"]())

    def get_item_by_index(self, index:int) -> "IAstrogatorCentralBody":
        """Retrieves a central body from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppCentralBody:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_index"](arg_index.COM_val, byref(arg_ppCentralBody.COM_val)))
            return arg_ppCentralBody.python_val

    def get_item_by_name(self, cbName:str) -> "IAstrogatorCentralBody":
        """Retrieves a central body from the collection by name."""
        with agmarshall.BSTR_arg(cbName) as arg_cbName, \
             agmarshall.AgInterface_out_arg() as arg_ppCentralBody:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_name"](arg_cbName.COM_val, byref(arg_ppCentralBody.COM_val)))
            return arg_ppCentralBody.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{6A2BFAF1-F26A-439B-AF23-AD83B82A0D4A}", ICentralBodyCollection)
agcls.AgTypeNameMap["ICentralBodyCollection"] = ICentralBodyCollection

class ICentralBodyEphemeris(object):
    """The central body ephemeris source."""
    _uuid = "{AE91748E-8A2D-4D9D-9C39-88017D0CB591}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICentralBodyEphemeris._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICentralBodyEphemeris from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICentralBodyEphemeris = agcom.GUID(ICentralBodyEphemeris._uuid)
        vtable_offset_local = ICentralBodyEphemeris._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICentralBodyEphemeris.__dict__ and type(ICentralBodyEphemeris.__dict__[attrname]) == property:
            return ICentralBodyEphemeris.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICentralBodyEphemeris.")
    

agcls.AgClassCatalog.add_catalog_entry("{AE91748E-8A2D-4D9D-9C39-88017D0CB591}", ICentralBodyEphemeris)
agcls.AgTypeNameMap["ICentralBodyEphemeris"] = ICentralBodyEphemeris

class ICentralBodyGravityModel(object):
    """Properties for a central body gravity model."""
    _uuid = "{B20E4246-ED81-4131-82AF-C76FAD7C57A8}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_gravitational_param"] = _raise_uninitialized_error
        self.__dict__["_set_gravitational_param"] = _raise_uninitialized_error
        self.__dict__["_get_ref_distance"] = _raise_uninitialized_error
        self.__dict__["_set_ref_distance"] = _raise_uninitialized_error
        self.__dict__["_get_j2"] = _raise_uninitialized_error
        self.__dict__["_set_j2"] = _raise_uninitialized_error
        self.__dict__["_get_j3"] = _raise_uninitialized_error
        self.__dict__["_set_j3"] = _raise_uninitialized_error
        self.__dict__["_get_j4"] = _raise_uninitialized_error
        self.__dict__["_set_j4"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICentralBodyGravityModel._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICentralBodyGravityModel from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICentralBodyGravityModel = agcom.GUID(ICentralBodyGravityModel._uuid)
        vtable_offset_local = ICentralBodyGravityModel._vtable_offset - 1
        self.__dict__["_get_gravitational_param"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGravityModel, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_gravitational_param"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGravityModel, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_ref_distance"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGravityModel, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_ref_distance"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGravityModel, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_j2"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGravityModel, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_j2"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGravityModel, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_j3"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGravityModel, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_j3"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGravityModel, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_j4"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGravityModel, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_j4"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyGravityModel, vtable_offset_local+10, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICentralBodyGravityModel.__dict__ and type(ICentralBodyGravityModel.__dict__[attrname]) == property:
            return ICentralBodyGravityModel.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICentralBodyGravityModel.")
    
    @property
    def gravitational_param(self) -> float:
        """The gravitational parameter to be used for purposes of this gravity model. Uses Gravitational Param Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_gravitational_param"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @gravitational_param.setter
    def gravitational_param(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_gravitational_param"](arg_newVal.COM_val))

    @property
    def ref_distance(self) -> float:
        """Distance from the center of mass of the central body to its surface. Typically defaults to the Maximum Radius entered in the Shape frame of the Central Body parameters window. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_ref_distance"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ref_distance.setter
    def ref_distance(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_ref_distance"](arg_newVal.COM_val))

    @property
    def j2(self) -> float:
        """The J2 property. Taking into account first order Earth oblateness effects. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_j2"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @j2.setter
    def j2(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_j2"](arg_newVal.COM_val))

    @property
    def j3(self) -> float:
        """The J3 property. Taking into account first order longitudinal variations of the Earth's shape. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_j3"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @j3.setter
    def j3(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_j3"](arg_newVal.COM_val))

    @property
    def j4(self) -> float:
        """The J4 property. Taking into account first and second order Earth oblateness effects. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_j4"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @j4.setter
    def j4(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_j4"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{B20E4246-ED81-4131-82AF-C76FAD7C57A8}", ICentralBodyGravityModel)
agcls.AgTypeNameMap["ICentralBodyGravityModel"] = ICentralBodyGravityModel

class ICentralBodyShape(object):
    """The central body shape."""
    _uuid = "{4DD8FE3F-7B64-4477-9D9E-97226A04584D}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICentralBodyShape._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICentralBodyShape from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICentralBodyShape = agcom.GUID(ICentralBodyShape._uuid)
        vtable_offset_local = ICentralBodyShape._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICentralBodyShape.__dict__ and type(ICentralBodyShape.__dict__[attrname]) == property:
            return ICentralBodyShape.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICentralBodyShape.")
    

agcls.AgClassCatalog.add_catalog_entry("{4DD8FE3F-7B64-4477-9D9E-97226A04584D}", ICentralBodyShape)
agcls.AgTypeNameMap["ICentralBodyShape"] = ICentralBodyShape

class ICentralBodyShapeSphere(ICentralBodyShape):
    """Properties for the central body sphere shape."""
    _uuid = "{BF7B6D1A-62E6-4897-8861-233465975488}"
    _num_methods = 2
    _vtable_offset = ICentralBodyShape._vtable_offset + ICentralBodyShape._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_radius"] = _raise_uninitialized_error
        self.__dict__["_set_radius"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICentralBodyShapeSphere._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICentralBodyShapeSphere from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICentralBodyShape._private_init(self, pUnk)
        IID_ICentralBodyShapeSphere = agcom.GUID(ICentralBodyShapeSphere._uuid)
        vtable_offset_local = ICentralBodyShapeSphere._vtable_offset - 1
        self.__dict__["_get_radius"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyShapeSphere, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_radius"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyShapeSphere, vtable_offset_local+2, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICentralBodyShapeSphere.__dict__ and type(ICentralBodyShapeSphere.__dict__[attrname]) == property:
            return ICentralBodyShapeSphere.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            ICentralBodyShape.__setattr__(self, attrname, value)
    
    @property
    def radius(self) -> float:
        """The radius. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_radius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @radius.setter
    def radius(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_radius"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{BF7B6D1A-62E6-4897-8861-233465975488}", ICentralBodyShapeSphere)
agcls.AgTypeNameMap["ICentralBodyShapeSphere"] = ICentralBodyShapeSphere

class ICentralBodyShapeOblateSpheroid(ICentralBodyShape):
    """Properties for the central body oblate spheroid shape."""
    _uuid = "{583AE2E3-8639-4C1F-B188-3C6AF867F0CD}"
    _num_methods = 5
    _vtable_offset = ICentralBodyShape._vtable_offset + ICentralBodyShape._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_min_radius"] = _raise_uninitialized_error
        self.__dict__["_set_min_radius"] = _raise_uninitialized_error
        self.__dict__["_get_max_radius"] = _raise_uninitialized_error
        self.__dict__["_set_max_radius"] = _raise_uninitialized_error
        self.__dict__["_get_flattening_coefficient"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICentralBodyShapeOblateSpheroid._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICentralBodyShapeOblateSpheroid from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICentralBodyShape._private_init(self, pUnk)
        IID_ICentralBodyShapeOblateSpheroid = agcom.GUID(ICentralBodyShapeOblateSpheroid._uuid)
        vtable_offset_local = ICentralBodyShapeOblateSpheroid._vtable_offset - 1
        self.__dict__["_get_min_radius"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyShapeOblateSpheroid, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_min_radius"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyShapeOblateSpheroid, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_max_radius"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyShapeOblateSpheroid, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_radius"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyShapeOblateSpheroid, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_flattening_coefficient"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyShapeOblateSpheroid, vtable_offset_local+5, POINTER(agcom.DOUBLE))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICentralBodyShapeOblateSpheroid.__dict__ and type(ICentralBodyShapeOblateSpheroid.__dict__[attrname]) == property:
            return ICentralBodyShapeOblateSpheroid.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            ICentralBodyShape.__setattr__(self, attrname, value)
    
    @property
    def min_radius(self) -> float:
        """The minimum radius. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_radius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @min_radius.setter
    def min_radius(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_min_radius"](arg_newVal.COM_val))

    @property
    def max_radius(self) -> float:
        """The maximum radius. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_radius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_radius.setter
    def max_radius(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_radius"](arg_newVal.COM_val))

    @property
    def flattening_coefficient(self) -> float:
        """The flattening coefficient; automatically derived from the minimum and maximum radii. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_flattening_coefficient"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{583AE2E3-8639-4C1F-B188-3C6AF867F0CD}", ICentralBodyShapeOblateSpheroid)
agcls.AgTypeNameMap["ICentralBodyShapeOblateSpheroid"] = ICentralBodyShapeOblateSpheroid

class ICentralBodyShapeTriaxialEllipsoid(ICentralBodyShape):
    """Properties for the central body triaxial ellipsoid shape."""
    _uuid = "{E446F44B-EDEB-4643-BEDA-6EA807C27882}"
    _num_methods = 6
    _vtable_offset = ICentralBodyShape._vtable_offset + ICentralBodyShape._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_semi_major_axis"] = _raise_uninitialized_error
        self.__dict__["_set_semi_major_axis"] = _raise_uninitialized_error
        self.__dict__["_get_semi_mid_axis"] = _raise_uninitialized_error
        self.__dict__["_set_semi_mid_axis"] = _raise_uninitialized_error
        self.__dict__["_get_semi_minor_axis"] = _raise_uninitialized_error
        self.__dict__["_set_semi_minor_axis"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICentralBodyShapeTriaxialEllipsoid._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICentralBodyShapeTriaxialEllipsoid from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICentralBodyShape._private_init(self, pUnk)
        IID_ICentralBodyShapeTriaxialEllipsoid = agcom.GUID(ICentralBodyShapeTriaxialEllipsoid._uuid)
        vtable_offset_local = ICentralBodyShapeTriaxialEllipsoid._vtable_offset - 1
        self.__dict__["_get_semi_major_axis"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyShapeTriaxialEllipsoid, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_semi_major_axis"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyShapeTriaxialEllipsoid, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_semi_mid_axis"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyShapeTriaxialEllipsoid, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_semi_mid_axis"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyShapeTriaxialEllipsoid, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_semi_minor_axis"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyShapeTriaxialEllipsoid, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_semi_minor_axis"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyShapeTriaxialEllipsoid, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICentralBodyShapeTriaxialEllipsoid.__dict__ and type(ICentralBodyShapeTriaxialEllipsoid.__dict__[attrname]) == property:
            return ICentralBodyShapeTriaxialEllipsoid.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            ICentralBodyShape.__setattr__(self, attrname, value)
    
    @property
    def semi_major_axis(self) -> float:
        """The semi-major axis. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_semi_major_axis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @semi_major_axis.setter
    def semi_major_axis(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_semi_major_axis"](arg_newVal.COM_val))

    @property
    def semi_mid_axis(self) -> float:
        """The semi-mid axis. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_semi_mid_axis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @semi_mid_axis.setter
    def semi_mid_axis(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_semi_mid_axis"](arg_newVal.COM_val))

    @property
    def semi_minor_axis(self) -> float:
        """The semi-minor axis. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_semi_minor_axis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @semi_minor_axis.setter
    def semi_minor_axis(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_semi_minor_axis"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E446F44B-EDEB-4643-BEDA-6EA807C27882}", ICentralBodyShapeTriaxialEllipsoid)
agcls.AgTypeNameMap["ICentralBodyShapeTriaxialEllipsoid"] = ICentralBodyShapeTriaxialEllipsoid

class ICentralBodyAttitude(object):
    """The central body attitude."""
    _uuid = "{DF0EB27A-4546-4A2C-B154-49E86527784D}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICentralBodyAttitude._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICentralBodyAttitude from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICentralBodyAttitude = agcom.GUID(ICentralBodyAttitude._uuid)
        vtable_offset_local = ICentralBodyAttitude._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICentralBodyAttitude.__dict__ and type(ICentralBodyAttitude.__dict__[attrname]) == property:
            return ICentralBodyAttitude.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICentralBodyAttitude.")
    

agcls.AgClassCatalog.add_catalog_entry("{DF0EB27A-4546-4A2C-B154-49E86527784D}", ICentralBodyAttitude)
agcls.AgTypeNameMap["ICentralBodyAttitude"] = ICentralBodyAttitude

class ICentralBodyAttitudeRotationCoefficientsFile(ICentralBodyAttitude):
    """Properties for a rotation coefficients file attitude definition."""
    _uuid = "{E0F3153F-7F2D-46B7-B317-99EDABD12360}"
    _num_methods = 2
    _vtable_offset = ICentralBodyAttitude._vtable_offset + ICentralBodyAttitude._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_filename"] = _raise_uninitialized_error
        self.__dict__["_set_filename"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICentralBodyAttitudeRotationCoefficientsFile._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICentralBodyAttitudeRotationCoefficientsFile from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICentralBodyAttitude._private_init(self, pUnk)
        IID_ICentralBodyAttitudeRotationCoefficientsFile = agcom.GUID(ICentralBodyAttitudeRotationCoefficientsFile._uuid)
        vtable_offset_local = ICentralBodyAttitudeRotationCoefficientsFile._vtable_offset - 1
        self.__dict__["_get_filename"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyAttitudeRotationCoefficientsFile, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_filename"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyAttitudeRotationCoefficientsFile, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICentralBodyAttitudeRotationCoefficientsFile.__dict__ and type(ICentralBodyAttitudeRotationCoefficientsFile.__dict__[attrname]) == property:
            return ICentralBodyAttitudeRotationCoefficientsFile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            ICentralBodyAttitude.__setattr__(self, attrname, value)
    
    @property
    def filename(self) -> str:
        """The name of the rotation coefficients file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_filename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @filename.setter
    def filename(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_filename"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E0F3153F-7F2D-46B7-B317-99EDABD12360}", ICentralBodyAttitudeRotationCoefficientsFile)
agcls.AgTypeNameMap["ICentralBodyAttitudeRotationCoefficientsFile"] = ICentralBodyAttitudeRotationCoefficientsFile

class ICentralBodyAttitudeIAU1994(ICentralBodyAttitude):
    """Properties for an IAU1994 attitude definition."""
    _uuid = "{7F28E973-1139-4D02-8F8C-C0F68E3035A9}"
    _num_methods = 12
    _vtable_offset = ICentralBodyAttitude._vtable_offset + ICentralBodyAttitude._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_right_ascension"] = _raise_uninitialized_error
        self.__dict__["_set_right_ascension"] = _raise_uninitialized_error
        self.__dict__["_get_declination"] = _raise_uninitialized_error
        self.__dict__["_set_declination"] = _raise_uninitialized_error
        self.__dict__["_get_right_ascension_rate"] = _raise_uninitialized_error
        self.__dict__["_set_right_ascension_rate"] = _raise_uninitialized_error
        self.__dict__["_get_declination_rate"] = _raise_uninitialized_error
        self.__dict__["_set_declination_rate"] = _raise_uninitialized_error
        self.__dict__["_get_rotation_offset"] = _raise_uninitialized_error
        self.__dict__["_set_rotation_offset"] = _raise_uninitialized_error
        self.__dict__["_get_rotation_rate"] = _raise_uninitialized_error
        self.__dict__["_set_rotation_rate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICentralBodyAttitudeIAU1994._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICentralBodyAttitudeIAU1994 from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICentralBodyAttitude._private_init(self, pUnk)
        IID_ICentralBodyAttitudeIAU1994 = agcom.GUID(ICentralBodyAttitudeIAU1994._uuid)
        vtable_offset_local = ICentralBodyAttitudeIAU1994._vtable_offset - 1
        self.__dict__["_get_right_ascension"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyAttitudeIAU1994, vtable_offset_local+1, POINTER(agcom.VARIANT))
        self.__dict__["_set_right_ascension"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyAttitudeIAU1994, vtable_offset_local+2, agcom.VARIANT)
        self.__dict__["_get_declination"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyAttitudeIAU1994, vtable_offset_local+3, POINTER(agcom.VARIANT))
        self.__dict__["_set_declination"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyAttitudeIAU1994, vtable_offset_local+4, agcom.VARIANT)
        self.__dict__["_get_right_ascension_rate"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyAttitudeIAU1994, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_right_ascension_rate"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyAttitudeIAU1994, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_declination_rate"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyAttitudeIAU1994, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_declination_rate"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyAttitudeIAU1994, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_rotation_offset"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyAttitudeIAU1994, vtable_offset_local+9, POINTER(agcom.VARIANT))
        self.__dict__["_set_rotation_offset"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyAttitudeIAU1994, vtable_offset_local+10, agcom.VARIANT)
        self.__dict__["_get_rotation_rate"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyAttitudeIAU1994, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_rotation_rate"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyAttitudeIAU1994, vtable_offset_local+12, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICentralBodyAttitudeIAU1994.__dict__ and type(ICentralBodyAttitudeIAU1994.__dict__[attrname]) == property:
            return ICentralBodyAttitudeIAU1994.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            ICentralBodyAttitude.__setattr__(self, attrname, value)
    
    @property
    def right_ascension(self) -> typing.Any:
        """The right ascension; the angle measured in the inertial equatorial plane from the inertial X axis in a right-handed sense about the inertial Z axis to the spin axis -- the angle  in the drawing below. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_right_ascension"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @right_ascension.setter
    def right_ascension(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_right_ascension"](arg_newVal.COM_val))

    @property
    def declination(self) -> typing.Any:
        """The declination; the angle from the X-Y plane of the coordinate system to the spin axis vector. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_declination"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @declination.setter
    def declination(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_declination"](arg_newVal.COM_val))

    @property
    def right_ascension_rate(self) -> float:
        """The right ascension rate; the rate of change in the right ascension. Uses AngleRate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_right_ascension_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @right_ascension_rate.setter
    def right_ascension_rate(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_right_ascension_rate"](arg_newVal.COM_val))

    @property
    def declination_rate(self) -> float:
        """The declination rate; the rate of change in the declination. Uses AngleRate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_declination_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @declination_rate.setter
    def declination_rate(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_declination_rate"](arg_newVal.COM_val))

    @property
    def rotation_offset(self) -> typing.Any:
        """The rotation offset; the angle from the inertially fixed reference direction to the body-fixed prime meridian (0 deg longitude) at the time of epoch. Uses AngleUnit Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_rotation_offset"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @rotation_offset.setter
    def rotation_offset(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_rotation_offset"](arg_newVal.COM_val))

    @property
    def rotation_rate(self) -> float:
        """The rotation rate; the rate of the central body's rotation. Uses AngleRate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_rotation_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @rotation_rate.setter
    def rotation_rate(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_rotation_rate"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7F28E973-1139-4D02-8F8C-C0F68E3035A9}", ICentralBodyAttitudeIAU1994)
agcls.AgTypeNameMap["ICentralBodyAttitudeIAU1994"] = ICentralBodyAttitudeIAU1994

class ICentralBodyEphemerisAnalyticOrbit(ICentralBodyEphemeris):
    """Properties for the Analytic Orbit ephemeris source."""
    _uuid = "{662F2BBE-2CFB-41F7-A928-26A4909C31AB}"
    _num_methods = 26
    _vtable_offset = ICentralBodyEphemeris._vtable_offset + ICentralBodyEphemeris._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_epoch"] = _raise_uninitialized_error
        self.__dict__["_set_epoch"] = _raise_uninitialized_error
        self.__dict__["_get_semi_major_axis"] = _raise_uninitialized_error
        self.__dict__["_set_semi_major_axis"] = _raise_uninitialized_error
        self.__dict__["_get_semi_major_axis_rate"] = _raise_uninitialized_error
        self.__dict__["_set_semi_major_axis_rate"] = _raise_uninitialized_error
        self.__dict__["_get_eccentricity"] = _raise_uninitialized_error
        self.__dict__["_set_eccentricity"] = _raise_uninitialized_error
        self.__dict__["_get_eccentricity_rate"] = _raise_uninitialized_error
        self.__dict__["_set_eccentricity_rate"] = _raise_uninitialized_error
        self.__dict__["_get_inclination"] = _raise_uninitialized_error
        self.__dict__["_set_inclination"] = _raise_uninitialized_error
        self.__dict__["_get_inclination_rate"] = _raise_uninitialized_error
        self.__dict__["_set_inclination_rate"] = _raise_uninitialized_error
        self.__dict__["_get_raan"] = _raise_uninitialized_error
        self.__dict__["_set_raan"] = _raise_uninitialized_error
        self.__dict__["_get_raan_rate"] = _raise_uninitialized_error
        self.__dict__["_set_raan_rate"] = _raise_uninitialized_error
        self.__dict__["_get_arg_of_periapsis"] = _raise_uninitialized_error
        self.__dict__["_set_arg_of_periapsis"] = _raise_uninitialized_error
        self.__dict__["_get_arg_of_periapsis_rate"] = _raise_uninitialized_error
        self.__dict__["_set_arg_of_periapsis_rate"] = _raise_uninitialized_error
        self.__dict__["_get_mean_longitude"] = _raise_uninitialized_error
        self.__dict__["_set_mean_longitude"] = _raise_uninitialized_error
        self.__dict__["_get_mean_longitude_rate"] = _raise_uninitialized_error
        self.__dict__["_set_mean_longitude_rate"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICentralBodyEphemerisAnalyticOrbit._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICentralBodyEphemerisAnalyticOrbit from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICentralBodyEphemeris._private_init(self, pUnk)
        IID_ICentralBodyEphemerisAnalyticOrbit = agcom.GUID(ICentralBodyEphemerisAnalyticOrbit._uuid)
        vtable_offset_local = ICentralBodyEphemerisAnalyticOrbit._vtable_offset - 1
        self.__dict__["_get_epoch"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyEphemerisAnalyticOrbit, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_epoch"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyEphemerisAnalyticOrbit, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_semi_major_axis"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyEphemerisAnalyticOrbit, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_semi_major_axis"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyEphemerisAnalyticOrbit, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_semi_major_axis_rate"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyEphemerisAnalyticOrbit, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_semi_major_axis_rate"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyEphemerisAnalyticOrbit, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_eccentricity"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyEphemerisAnalyticOrbit, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_eccentricity"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyEphemerisAnalyticOrbit, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_eccentricity_rate"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyEphemerisAnalyticOrbit, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_eccentricity_rate"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyEphemerisAnalyticOrbit, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_inclination"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyEphemerisAnalyticOrbit, vtable_offset_local+11, POINTER(agcom.VARIANT))
        self.__dict__["_set_inclination"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyEphemerisAnalyticOrbit, vtable_offset_local+12, agcom.VARIANT)
        self.__dict__["_get_inclination_rate"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyEphemerisAnalyticOrbit, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_inclination_rate"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyEphemerisAnalyticOrbit, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_raan"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyEphemerisAnalyticOrbit, vtable_offset_local+15, POINTER(agcom.VARIANT))
        self.__dict__["_set_raan"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyEphemerisAnalyticOrbit, vtable_offset_local+16, agcom.VARIANT)
        self.__dict__["_get_raan_rate"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyEphemerisAnalyticOrbit, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_raan_rate"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyEphemerisAnalyticOrbit, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_arg_of_periapsis"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyEphemerisAnalyticOrbit, vtable_offset_local+19, POINTER(agcom.VARIANT))
        self.__dict__["_set_arg_of_periapsis"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyEphemerisAnalyticOrbit, vtable_offset_local+20, agcom.VARIANT)
        self.__dict__["_get_arg_of_periapsis_rate"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyEphemerisAnalyticOrbit, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_set_arg_of_periapsis_rate"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyEphemerisAnalyticOrbit, vtable_offset_local+22, agcom.DOUBLE)
        self.__dict__["_get_mean_longitude"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyEphemerisAnalyticOrbit, vtable_offset_local+23, POINTER(agcom.VARIANT))
        self.__dict__["_set_mean_longitude"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyEphemerisAnalyticOrbit, vtable_offset_local+24, agcom.VARIANT)
        self.__dict__["_get_mean_longitude_rate"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyEphemerisAnalyticOrbit, vtable_offset_local+25, POINTER(agcom.DOUBLE))
        self.__dict__["_set_mean_longitude_rate"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyEphemerisAnalyticOrbit, vtable_offset_local+26, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICentralBodyEphemerisAnalyticOrbit.__dict__ and type(ICentralBodyEphemerisAnalyticOrbit.__dict__[attrname]) == property:
            return ICentralBodyEphemerisAnalyticOrbit.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            ICentralBodyEphemeris.__setattr__(self, attrname, value)
    
    @property
    def epoch(self) -> float:
        """The epoch. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_epoch"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @epoch.setter
    def epoch(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_epoch"](arg_newVal.COM_val))

    @property
    def semi_major_axis(self) -> float:
        """The semi-major axis; one-half the distance along the long axis of the elliptical orbit. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_semi_major_axis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @semi_major_axis.setter
    def semi_major_axis(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_semi_major_axis"](arg_newVal.COM_val))

    @property
    def semi_major_axis_rate(self) -> float:
        """The semi-major axis rate of change. Uses Rate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_semi_major_axis_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @semi_major_axis_rate.setter
    def semi_major_axis_rate(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_semi_major_axis_rate"](arg_newVal.COM_val))

    @property
    def eccentricity(self) -> float:
        """The eccentricity; the ratio of the distance between the two foci of the ellipse and its major axis. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_eccentricity"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @eccentricity.setter
    def eccentricity(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_eccentricity"](arg_newVal.COM_val))

    @property
    def eccentricity_rate(self) -> float:
        """The eccentricity rate of change. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_eccentricity_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @eccentricity_rate.setter
    def eccentricity_rate(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_eccentricity_rate"](arg_newVal.COM_val))

    @property
    def inclination(self) -> typing.Any:
        """The inclination; the angle from the Z axis of the inertial coordinate system to the orbit angular velocity vector. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_inclination"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @inclination.setter
    def inclination(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_inclination"](arg_newVal.COM_val))

    @property
    def inclination_rate(self) -> float:
        """The inclination rate of change. Uses AngleRate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_inclination_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @inclination_rate.setter
    def inclination_rate(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_inclination_rate"](arg_newVal.COM_val))

    @property
    def raan(self) -> typing.Any:
        """The right ascension; the angle from the X axis of the inertial coordinate system to the point where the orbit crosses the X-Y plane in the +Z direction. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_raan"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @raan.setter
    def raan(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_raan"](arg_newVal.COM_val))

    @property
    def raan_rate(self) -> float:
        """The right ascension rate of change. Uses AngleRate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_raan_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @raan_rate.setter
    def raan_rate(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_raan_rate"](arg_newVal.COM_val))

    @property
    def arg_of_periapsis(self) -> typing.Any:
        """The argument of periapsis; The angle measured in direction of the body's orbital motion, and in the orbit plane, from the ascending node to the periapsis of the orbit. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_arg_of_periapsis"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @arg_of_periapsis.setter
    def arg_of_periapsis(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_arg_of_periapsis"](arg_newVal.COM_val))

    @property
    def arg_of_periapsis_rate(self) -> float:
        """The argument of periapsis rate of change. Uses AngleRate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_arg_of_periapsis_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @arg_of_periapsis_rate.setter
    def arg_of_periapsis_rate(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_arg_of_periapsis_rate"](arg_newVal.COM_val))

    @property
    def mean_longitude(self) -> typing.Any:
        """The mean longitude; the sum of the Right Ascension of the Ascending Node, the Argument of Periapsis and the Mean Anomaly. Uses Angle Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_mean_longitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @mean_longitude.setter
    def mean_longitude(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_mean_longitude"](arg_newVal.COM_val))

    @property
    def mean_longitude_rate(self) -> float:
        """The mean longitude rate of change. Uses AngleRate Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_mean_longitude_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @mean_longitude_rate.setter
    def mean_longitude_rate(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_mean_longitude_rate"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{662F2BBE-2CFB-41F7-A928-26A4909C31AB}", ICentralBodyEphemerisAnalyticOrbit)
agcls.AgTypeNameMap["ICentralBodyEphemerisAnalyticOrbit"] = ICentralBodyEphemerisAnalyticOrbit

class ICentralBodyEphemerisJPLSpice(ICentralBodyEphemeris):
    """Properties for the JPL SPICE ephemeris source."""
    _uuid = "{B6A4A547-92B1-4584-B8E9-D3C12ED6CC9C}"
    _num_methods = 2
    _vtable_offset = ICentralBodyEphemeris._vtable_offset + ICentralBodyEphemeris._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_jpl_spice_id"] = _raise_uninitialized_error
        self.__dict__["_set_jpl_spice_id"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICentralBodyEphemerisJPLSpice._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICentralBodyEphemerisJPLSpice from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICentralBodyEphemeris._private_init(self, pUnk)
        IID_ICentralBodyEphemerisJPLSpice = agcom.GUID(ICentralBodyEphemerisJPLSpice._uuid)
        vtable_offset_local = ICentralBodyEphemerisJPLSpice._vtable_offset - 1
        self.__dict__["_get_jpl_spice_id"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyEphemerisJPLSpice, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_jpl_spice_id"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyEphemerisJPLSpice, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICentralBodyEphemerisJPLSpice.__dict__ and type(ICentralBodyEphemerisJPLSpice.__dict__[attrname]) == property:
            return ICentralBodyEphemerisJPLSpice.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            ICentralBodyEphemeris.__setattr__(self, attrname, value)
    
    @property
    def jpl_spice_id(self) -> str:
        """The SPICE file name."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_jpl_spice_id"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @jpl_spice_id.setter
    def jpl_spice_id(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_jpl_spice_id"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{B6A4A547-92B1-4584-B8E9-D3C12ED6CC9C}", ICentralBodyEphemerisJPLSpice)
agcls.AgTypeNameMap["ICentralBodyEphemerisJPLSpice"] = ICentralBodyEphemerisJPLSpice

class ICentralBodyEphemerisFile(ICentralBodyEphemeris):
    """Properties for the Ephemeris File ephemeris source."""
    _uuid = "{8B38CE6C-B8E1-489F-8ED1-B3703A13D986}"
    _num_methods = 2
    _vtable_offset = ICentralBodyEphemeris._vtable_offset + ICentralBodyEphemeris._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_filename"] = _raise_uninitialized_error
        self.__dict__["_set_filename"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICentralBodyEphemerisFile._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICentralBodyEphemerisFile from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICentralBodyEphemeris._private_init(self, pUnk)
        IID_ICentralBodyEphemerisFile = agcom.GUID(ICentralBodyEphemerisFile._uuid)
        vtable_offset_local = ICentralBodyEphemerisFile._vtable_offset - 1
        self.__dict__["_get_filename"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyEphemerisFile, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_filename"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyEphemerisFile, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICentralBodyEphemerisFile.__dict__ and type(ICentralBodyEphemerisFile.__dict__[attrname]) == property:
            return ICentralBodyEphemerisFile.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            ICentralBodyEphemeris.__setattr__(self, attrname, value)
    
    @property
    def filename(self) -> str:
        """The ephemeris file name."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_filename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @filename.setter
    def filename(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_filename"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{8B38CE6C-B8E1-489F-8ED1-B3703A13D986}", ICentralBodyEphemerisFile)
agcls.AgTypeNameMap["ICentralBodyEphemerisFile"] = ICentralBodyEphemerisFile

class ICentralBodyEphemerisJPLDesignExplorerOptimizer(ICentralBodyEphemeris):
    """Properties for the JPL DE ephemeris source."""
    _uuid = "{FCD86AB9-0919-46BC-BF99-287F49837BD5}"
    _num_methods = 2
    _vtable_offset = ICentralBodyEphemeris._vtable_offset + ICentralBodyEphemeris._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_jplde_filename"] = _raise_uninitialized_error
        self.__dict__["_set_jplde_filename"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICentralBodyEphemerisJPLDesignExplorerOptimizer._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICentralBodyEphemerisJPLDesignExplorerOptimizer from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICentralBodyEphemeris._private_init(self, pUnk)
        IID_ICentralBodyEphemerisJPLDesignExplorerOptimizer = agcom.GUID(ICentralBodyEphemerisJPLDesignExplorerOptimizer._uuid)
        vtable_offset_local = ICentralBodyEphemerisJPLDesignExplorerOptimizer._vtable_offset - 1
        self.__dict__["_get_jplde_filename"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyEphemerisJPLDesignExplorerOptimizer, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_jplde_filename"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyEphemerisJPLDesignExplorerOptimizer, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICentralBodyEphemerisJPLDesignExplorerOptimizer.__dict__ and type(ICentralBodyEphemerisJPLDesignExplorerOptimizer.__dict__[attrname]) == property:
            return ICentralBodyEphemerisJPLDesignExplorerOptimizer.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            ICentralBodyEphemeris.__setattr__(self, attrname, value)
    
    @property
    def jplde_filename(self) -> str:
        """The DE file name."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_jplde_filename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @jplde_filename.setter
    def jplde_filename(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_jplde_filename"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{FCD86AB9-0919-46BC-BF99-287F49837BD5}", ICentralBodyEphemerisJPLDesignExplorerOptimizer)
agcls.AgTypeNameMap["ICentralBodyEphemerisJPLDesignExplorerOptimizer"] = ICentralBodyEphemerisJPLDesignExplorerOptimizer

class ICentralBodyEphemerisPlanetary(ICentralBodyEphemeris):
    """Properties for the Planetary Ephemeris file ephemeris source."""
    _uuid = "{471AE49F-1C98-4572-9EDD-16060AFA9208}"
    _num_methods = 2
    _vtable_offset = ICentralBodyEphemeris._vtable_offset + ICentralBodyEphemeris._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_planetary_filename"] = _raise_uninitialized_error
        self.__dict__["_set_planetary_filename"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICentralBodyEphemerisPlanetary._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICentralBodyEphemerisPlanetary from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICentralBodyEphemeris._private_init(self, pUnk)
        IID_ICentralBodyEphemerisPlanetary = agcom.GUID(ICentralBodyEphemerisPlanetary._uuid)
        vtable_offset_local = ICentralBodyEphemerisPlanetary._vtable_offset - 1
        self.__dict__["_get_planetary_filename"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyEphemerisPlanetary, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_planetary_filename"] = IAGFUNCTYPE(pUnk, IID_ICentralBodyEphemerisPlanetary, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICentralBodyEphemerisPlanetary.__dict__ and type(ICentralBodyEphemerisPlanetary.__dict__[attrname]) == property:
            return ICentralBodyEphemerisPlanetary.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            ICentralBodyEphemeris.__setattr__(self, attrname, value)
    
    @property
    def planetary_filename(self) -> str:
        """The planetary ephemeris file name."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_planetary_filename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @planetary_filename.setter
    def planetary_filename(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_planetary_filename"](arg_newVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{471AE49F-1C98-4572-9EDD-16060AFA9208}", ICentralBodyEphemerisPlanetary)
agcls.AgTypeNameMap["ICentralBodyEphemerisPlanetary"] = ICentralBodyEphemerisPlanetary

class IAstrogatorCentralBody(object):
    """General properties for a central body."""
    _uuid = "{5AA2ACF6-1764-4E46-BA4F-4619640CBC83}"
    _num_methods = 41
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_gravitational_param"] = _raise_uninitialized_error
        self.__dict__["_set_gravitational_param"] = _raise_uninitialized_error
        self.__dict__["_get_parent_name"] = _raise_uninitialized_error
        self.__dict__["_set_parent_name"] = _raise_uninitialized_error
        self.__dict__["_get_children"] = _raise_uninitialized_error
        self.__dict__["_get_default_gravity_model_name"] = _raise_uninitialized_error
        self.__dict__["_set_default_gravity_model_by_name"] = _raise_uninitialized_error
        self.__dict__["_get_default_gravity_model_data"] = _raise_uninitialized_error
        self.__dict__["_add_gravity_model"] = _raise_uninitialized_error
        self.__dict__["_remove_gravity_model_by_name"] = _raise_uninitialized_error
        self.__dict__["_get_default_shape_name"] = _raise_uninitialized_error
        self.__dict__["_get_default_shape_data"] = _raise_uninitialized_error
        self.__dict__["_set_default_shape_by_name"] = _raise_uninitialized_error
        self.__dict__["_add_shape"] = _raise_uninitialized_error
        self.__dict__["_remove_shape_by_name"] = _raise_uninitialized_error
        self.__dict__["_get_default_attitude_name"] = _raise_uninitialized_error
        self.__dict__["_get_default_attitude_data"] = _raise_uninitialized_error
        self.__dict__["_set_default_attitude_by_name"] = _raise_uninitialized_error
        self.__dict__["_add_attitude"] = _raise_uninitialized_error
        self.__dict__["_remove_attitude_by_name"] = _raise_uninitialized_error
        self.__dict__["_get_default_ephemeris_name"] = _raise_uninitialized_error
        self.__dict__["_set_default_ephemeris_by_name"] = _raise_uninitialized_error
        self.__dict__["_get_default_ephemeris_data"] = _raise_uninitialized_error
        self.__dict__["_add_ephemeris"] = _raise_uninitialized_error
        self.__dict__["_remove_ephemeris_by_name"] = _raise_uninitialized_error
        self.__dict__["_cut_gravity_model_by_name"] = _raise_uninitialized_error
        self.__dict__["_copy_gravity_model_by_name"] = _raise_uninitialized_error
        self.__dict__["_paste_gravity_model"] = _raise_uninitialized_error
        self.__dict__["_add_copy_of_gravity_model"] = _raise_uninitialized_error
        self.__dict__["_cut_shape_by_name"] = _raise_uninitialized_error
        self.__dict__["_copy_shape_by_name"] = _raise_uninitialized_error
        self.__dict__["_paste_shape"] = _raise_uninitialized_error
        self.__dict__["_add_copy_of_shape"] = _raise_uninitialized_error
        self.__dict__["_cut_attitude_by_name"] = _raise_uninitialized_error
        self.__dict__["_copy_attitude_by_name"] = _raise_uninitialized_error
        self.__dict__["_paste_attitude"] = _raise_uninitialized_error
        self.__dict__["_add_copy_of_attitude"] = _raise_uninitialized_error
        self.__dict__["_cut_ephemeris_by_name"] = _raise_uninitialized_error
        self.__dict__["_copy_ephemeris_by_name"] = _raise_uninitialized_error
        self.__dict__["_paste_ephemeris"] = _raise_uninitialized_error
        self.__dict__["_add_copy_of_ephemeris"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAstrogatorCentralBody._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAstrogatorCentralBody from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAstrogatorCentralBody = agcom.GUID(IAstrogatorCentralBody._uuid)
        vtable_offset_local = IAstrogatorCentralBody._vtable_offset - 1
        self.__dict__["_get_gravitational_param"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_gravitational_param"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_parent_name"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_parent_name"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_get_children"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_default_gravity_model_name"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+6, POINTER(agcom.BSTR))
        self.__dict__["_set_default_gravity_model_by_name"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+7, agcom.BSTR)
        self.__dict__["_get_default_gravity_model_data"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_add_gravity_model"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+9, agcom.LONG, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_remove_gravity_model_by_name"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+10, agcom.BSTR)
        self.__dict__["_get_default_shape_name"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+11, POINTER(agcom.BSTR))
        self.__dict__["_get_default_shape_data"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+12, POINTER(agcom.PVOID))
        self.__dict__["_set_default_shape_by_name"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+13, agcom.BSTR)
        self.__dict__["_add_shape"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+14, agcom.LONG, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_remove_shape_by_name"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+15, agcom.BSTR)
        self.__dict__["_get_default_attitude_name"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+16, POINTER(agcom.BSTR))
        self.__dict__["_get_default_attitude_data"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+17, POINTER(agcom.PVOID))
        self.__dict__["_set_default_attitude_by_name"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+18, agcom.BSTR)
        self.__dict__["_add_attitude"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+19, agcom.LONG, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_remove_attitude_by_name"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+20, agcom.BSTR)
        self.__dict__["_get_default_ephemeris_name"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+21, POINTER(agcom.BSTR))
        self.__dict__["_set_default_ephemeris_by_name"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+22, agcom.BSTR)
        self.__dict__["_get_default_ephemeris_data"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+23, POINTER(agcom.PVOID))
        self.__dict__["_add_ephemeris"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+24, agcom.LONG, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_remove_ephemeris_by_name"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+25, agcom.BSTR)
        self.__dict__["_cut_gravity_model_by_name"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+26, agcom.BSTR)
        self.__dict__["_copy_gravity_model_by_name"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+27, agcom.BSTR)
        self.__dict__["_paste_gravity_model"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+28, POINTER(agcom.PVOID))
        self.__dict__["_add_copy_of_gravity_model"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+29, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_cut_shape_by_name"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+30, agcom.BSTR)
        self.__dict__["_copy_shape_by_name"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+31, agcom.BSTR)
        self.__dict__["_paste_shape"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+32, POINTER(agcom.PVOID))
        self.__dict__["_add_copy_of_shape"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+33, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_cut_attitude_by_name"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+34, agcom.BSTR)
        self.__dict__["_copy_attitude_by_name"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+35, agcom.BSTR)
        self.__dict__["_paste_attitude"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+36, POINTER(agcom.PVOID))
        self.__dict__["_add_copy_of_attitude"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+37, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_cut_ephemeris_by_name"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+38, agcom.BSTR)
        self.__dict__["_copy_ephemeris_by_name"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+39, agcom.BSTR)
        self.__dict__["_paste_ephemeris"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+40, POINTER(agcom.PVOID))
        self.__dict__["_add_copy_of_ephemeris"] = IAGFUNCTYPE(pUnk, IID_IAstrogatorCentralBody, vtable_offset_local+41, agcom.PVOID, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAstrogatorCentralBody.__dict__ and type(IAstrogatorCentralBody.__dict__[attrname]) == property:
            return IAstrogatorCentralBody.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAstrogatorCentralBody.")
    
    @property
    def gravitational_param(self) -> float:
        """The gravitational parameter to be used. Uses Gravity Parameter Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_gravitational_param"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @gravitational_param.setter
    def gravitational_param(self, newVal:float) -> None:
        with agmarshall.DOUBLE_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_gravitational_param"](arg_newVal.COM_val))

    @property
    def parent_name(self) -> str:
        """The parent of this central body."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_parent_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @parent_name.setter
    def parent_name(self, newVal:str) -> None:
        with agmarshall.BSTR_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_parent_name"](arg_newVal.COM_val))

    @property
    def children(self) -> "ICentralBodyCollection":
        """The children of this central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppCentralBodyCollection:
            agcls.evaluate_hresult(self.__dict__["_get_children"](byref(arg_ppCentralBodyCollection.COM_val)))
            return arg_ppCentralBodyCollection.python_val

    @property
    def default_gravity_model_name(self) -> str:
        """The gravity model."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_default_gravity_model_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_default_gravity_model_by_name(self, gravityModelName:str) -> None:
        """Selects a gravity model"""
        with agmarshall.BSTR_arg(gravityModelName) as arg_gravityModelName:
            agcls.evaluate_hresult(self.__dict__["_set_default_gravity_model_by_name"](arg_gravityModelName.COM_val))

    @property
    def default_gravity_model_data(self) -> "ICentralBodyGravityModel":
        """The gravity model parameters."""
        with agmarshall.AgInterface_out_arg() as arg_ppCbGravityModel:
            agcls.evaluate_hresult(self.__dict__["_get_default_gravity_model_data"](byref(arg_ppCbGravityModel.COM_val)))
            return arg_ppCbGravityModel.python_val

    def add_gravity_model(self, eGravityModel:"AgEVACbGravityModel", uniqueName:str) -> "ICentralBodyGravityModel":
        """Adds a central body gravity model type."""
        with agmarshall.AgEnum_arg(AgEVACbGravityModel, eGravityModel) as arg_eGravityModel, \
             agmarshall.BSTR_arg(uniqueName) as arg_uniqueName, \
             agmarshall.AgInterface_out_arg() as arg_ppCbGravityModel:
            agcls.evaluate_hresult(self.__dict__["_add_gravity_model"](arg_eGravityModel.COM_val, arg_uniqueName.COM_val, byref(arg_ppCbGravityModel.COM_val)))
            return arg_ppCbGravityModel.python_val

    def remove_gravity_model_by_name(self, gravityModelName:str) -> None:
        """Removes a central body gravity model type."""
        with agmarshall.BSTR_arg(gravityModelName) as arg_gravityModelName:
            agcls.evaluate_hresult(self.__dict__["_remove_gravity_model_by_name"](arg_gravityModelName.COM_val))

    @property
    def default_shape_name(self) -> str:
        """The shape of the central body."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_default_shape_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def default_shape_data(self) -> "ICentralBodyShape":
        """The parameters of the central body shape."""
        with agmarshall.AgInterface_out_arg() as arg_ppCbShape:
            agcls.evaluate_hresult(self.__dict__["_get_default_shape_data"](byref(arg_ppCbShape.COM_val)))
            return arg_ppCbShape.python_val

    def set_default_shape_by_name(self, shapeName:str) -> None:
        """Selects a central body shape."""
        with agmarshall.BSTR_arg(shapeName) as arg_shapeName:
            agcls.evaluate_hresult(self.__dict__["_set_default_shape_by_name"](arg_shapeName.COM_val))

    def add_shape(self, eShape:"AgEVACbShape", uniqueName:str) -> "ICentralBodyShape":
        """Adds a central body shape type from the available types."""
        with agmarshall.AgEnum_arg(AgEVACbShape, eShape) as arg_eShape, \
             agmarshall.BSTR_arg(uniqueName) as arg_uniqueName, \
             agmarshall.AgInterface_out_arg() as arg_ppCbShape:
            agcls.evaluate_hresult(self.__dict__["_add_shape"](arg_eShape.COM_val, arg_uniqueName.COM_val, byref(arg_ppCbShape.COM_val)))
            return arg_ppCbShape.python_val

    def remove_shape_by_name(self, shapeName:str) -> None:
        """Removes a central body shape type."""
        with agmarshall.BSTR_arg(shapeName) as arg_shapeName:
            agcls.evaluate_hresult(self.__dict__["_remove_shape_by_name"](arg_shapeName.COM_val))

    @property
    def default_attitude_name(self) -> str:
        """The attitude of the central body."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_default_attitude_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def default_attitude_data(self) -> "ICentralBodyAttitude":
        """The parameters of the central body attitude."""
        with agmarshall.AgInterface_out_arg() as arg_ppCbAttitude:
            agcls.evaluate_hresult(self.__dict__["_get_default_attitude_data"](byref(arg_ppCbAttitude.COM_val)))
            return arg_ppCbAttitude.python_val

    def set_default_attitude_by_name(self, attitudeName:str) -> None:
        """Selects a central body attitude."""
        with agmarshall.BSTR_arg(attitudeName) as arg_attitudeName:
            agcls.evaluate_hresult(self.__dict__["_set_default_attitude_by_name"](arg_attitudeName.COM_val))

    def add_attitude(self, eAttitude:"AgEVACbAttitude", uniqueName:str) -> "ICentralBodyAttitude":
        """Adds a central body attitude type from the available types."""
        with agmarshall.AgEnum_arg(AgEVACbAttitude, eAttitude) as arg_eAttitude, \
             agmarshall.BSTR_arg(uniqueName) as arg_uniqueName, \
             agmarshall.AgInterface_out_arg() as arg_ppCbAttitude:
            agcls.evaluate_hresult(self.__dict__["_add_attitude"](arg_eAttitude.COM_val, arg_uniqueName.COM_val, byref(arg_ppCbAttitude.COM_val)))
            return arg_ppCbAttitude.python_val

    def remove_attitude_by_name(self, attitudeName:str) -> None:
        """Removes a central body attitude type."""
        with agmarshall.BSTR_arg(attitudeName) as arg_attitudeName:
            agcls.evaluate_hresult(self.__dict__["_remove_attitude_by_name"](arg_attitudeName.COM_val))

    @property
    def default_ephemeris_name(self) -> str:
        """The ephemeris of the central body."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_default_ephemeris_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_default_ephemeris_by_name(self, ephemerisName:str) -> None:
        """Selects an ephemeris type."""
        with agmarshall.BSTR_arg(ephemerisName) as arg_ephemerisName:
            agcls.evaluate_hresult(self.__dict__["_set_default_ephemeris_by_name"](arg_ephemerisName.COM_val))

    @property
    def default_ephemeris_data(self) -> "ICentralBodyEphemeris":
        """The  parameters of the central body ephemeris."""
        with agmarshall.AgInterface_out_arg() as arg_ppCbEphemeris:
            agcls.evaluate_hresult(self.__dict__["_get_default_ephemeris_data"](byref(arg_ppCbEphemeris.COM_val)))
            return arg_ppCbEphemeris.python_val

    def add_ephemeris(self, eEphemeris:"AgEVACbEphemeris", uniqueName:str) -> "ICentralBodyEphemeris":
        """Adds an ephemeris type from the available types."""
        with agmarshall.AgEnum_arg(AgEVACbEphemeris, eEphemeris) as arg_eEphemeris, \
             agmarshall.BSTR_arg(uniqueName) as arg_uniqueName, \
             agmarshall.AgInterface_out_arg() as arg_ppCbEphemeris:
            agcls.evaluate_hresult(self.__dict__["_add_ephemeris"](arg_eEphemeris.COM_val, arg_uniqueName.COM_val, byref(arg_ppCbEphemeris.COM_val)))
            return arg_ppCbEphemeris.python_val

    def remove_ephemeris_by_name(self, ephemerisName:str) -> None:
        """Removes an ephemeris type."""
        with agmarshall.BSTR_arg(ephemerisName) as arg_ephemerisName:
            agcls.evaluate_hresult(self.__dict__["_remove_ephemeris_by_name"](arg_ephemerisName.COM_val))

    def cut_gravity_model_by_name(self, gravityModelName:str) -> None:
        """Copies a gravity model to the clipboard and removes it from the central body"""
        with agmarshall.BSTR_arg(gravityModelName) as arg_gravityModelName:
            agcls.evaluate_hresult(self.__dict__["_cut_gravity_model_by_name"](arg_gravityModelName.COM_val))

    def copy_gravity_model_by_name(self, gravityModelName:str) -> None:
        """Copies a gravity model to the clipboard."""
        with agmarshall.BSTR_arg(gravityModelName) as arg_gravityModelName:
            agcls.evaluate_hresult(self.__dict__["_copy_gravity_model_by_name"](arg_gravityModelName.COM_val))

    def paste_gravity_model(self) -> "ICentralBodyGravityModel":
        """Adds the gravity model in the clipboard to the central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppCbGravityModel:
            agcls.evaluate_hresult(self.__dict__["_paste_gravity_model"](byref(arg_ppCbGravityModel.COM_val)))
            return arg_ppCbGravityModel.python_val

    def add_copy_of_gravity_model(self, gravityModel:"ICentralBodyGravityModel") -> "ICentralBodyGravityModel":
        """Adds the gravity model to the central body"""
        with agmarshall.AgInterface_in_arg(gravityModel, ICentralBodyGravityModel) as arg_gravityModel, \
             agmarshall.AgInterface_out_arg() as arg_ppCbGravityModel:
            agcls.evaluate_hresult(self.__dict__["_add_copy_of_gravity_model"](arg_gravityModel.COM_val, byref(arg_ppCbGravityModel.COM_val)))
            return arg_ppCbGravityModel.python_val

    def cut_shape_by_name(self, shapeName:str) -> None:
        """Copies a central body shape to the clipboard and removes it from the central body"""
        with agmarshall.BSTR_arg(shapeName) as arg_shapeName:
            agcls.evaluate_hresult(self.__dict__["_cut_shape_by_name"](arg_shapeName.COM_val))

    def copy_shape_by_name(self, shapeName:str) -> None:
        """Copies a central body shape to the clipboard."""
        with agmarshall.BSTR_arg(shapeName) as arg_shapeName:
            agcls.evaluate_hresult(self.__dict__["_copy_shape_by_name"](arg_shapeName.COM_val))

    def paste_shape(self) -> "ICentralBodyShape":
        """Adds the central body shape in the clipboard to the central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppCbShape:
            agcls.evaluate_hresult(self.__dict__["_paste_shape"](byref(arg_ppCbShape.COM_val)))
            return arg_ppCbShape.python_val

    def add_copy_of_shape(self, shape:"ICentralBodyShape") -> "ICentralBodyShape":
        """Adds the central body shape to the central body"""
        with agmarshall.AgInterface_in_arg(shape, ICentralBodyShape) as arg_shape, \
             agmarshall.AgInterface_out_arg() as arg_ppCbShape:
            agcls.evaluate_hresult(self.__dict__["_add_copy_of_shape"](arg_shape.COM_val, byref(arg_ppCbShape.COM_val)))
            return arg_ppCbShape.python_val

    def cut_attitude_by_name(self, attitudeName:str) -> None:
        """Copies a central body attitude definition to the clipboard and removes it from the central body"""
        with agmarshall.BSTR_arg(attitudeName) as arg_attitudeName:
            agcls.evaluate_hresult(self.__dict__["_cut_attitude_by_name"](arg_attitudeName.COM_val))

    def copy_attitude_by_name(self, attitudeName:str) -> None:
        """Copies a central body attitude definition to the clipboard."""
        with agmarshall.BSTR_arg(attitudeName) as arg_attitudeName:
            agcls.evaluate_hresult(self.__dict__["_copy_attitude_by_name"](arg_attitudeName.COM_val))

    def paste_attitude(self) -> "ICentralBodyAttitude":
        """Adds the central body attitude definition in the clipboard to the central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppCbAttitude:
            agcls.evaluate_hresult(self.__dict__["_paste_attitude"](byref(arg_ppCbAttitude.COM_val)))
            return arg_ppCbAttitude.python_val

    def add_copy_of_attitude(self, attitude:"ICentralBodyAttitude") -> "ICentralBodyAttitude":
        """Adds the central body attitude definition to the central body"""
        with agmarshall.AgInterface_in_arg(attitude, ICentralBodyAttitude) as arg_attitude, \
             agmarshall.AgInterface_out_arg() as arg_ppCbAttitude:
            agcls.evaluate_hresult(self.__dict__["_add_copy_of_attitude"](arg_attitude.COM_val, byref(arg_ppCbAttitude.COM_val)))
            return arg_ppCbAttitude.python_val

    def cut_ephemeris_by_name(self, ephemerisName:str) -> None:
        """Copies a central body ephemeris definition to the clipboard and removes it from the central body"""
        with agmarshall.BSTR_arg(ephemerisName) as arg_ephemerisName:
            agcls.evaluate_hresult(self.__dict__["_cut_ephemeris_by_name"](arg_ephemerisName.COM_val))

    def copy_ephemeris_by_name(self, ephemerisName:str) -> None:
        """Copies a central body ephemeris definition to the clipboard."""
        with agmarshall.BSTR_arg(ephemerisName) as arg_ephemerisName:
            agcls.evaluate_hresult(self.__dict__["_copy_ephemeris_by_name"](arg_ephemerisName.COM_val))

    def paste_ephemeris(self) -> "ICentralBodyEphemeris":
        """Adds the central body ephemeris definition in the clipboard to the central body."""
        with agmarshall.AgInterface_out_arg() as arg_ppCbEphemeris:
            agcls.evaluate_hresult(self.__dict__["_paste_ephemeris"](byref(arg_ppCbEphemeris.COM_val)))
            return arg_ppCbEphemeris.python_val

    def add_copy_of_ephemeris(self, ephemeris:"ICentralBodyEphemeris") -> "ICentralBodyEphemeris":
        """Adds the central body ephemeris definition to the central body"""
        with agmarshall.AgInterface_in_arg(ephemeris, ICentralBodyEphemeris) as arg_ephemeris, \
             agmarshall.AgInterface_out_arg() as arg_ppCbEphemeris:
            agcls.evaluate_hresult(self.__dict__["_add_copy_of_ephemeris"](arg_ephemeris.COM_val, byref(arg_ppCbEphemeris.COM_val)))
            return arg_ppCbEphemeris.python_val


agcls.AgClassCatalog.add_catalog_entry("{5AA2ACF6-1764-4E46-BA4F-4619640CBC83}", IAstrogatorCentralBody)
agcls.AgTypeNameMap["IAstrogatorCentralBody"] = IAstrogatorCentralBody

class IPowerInternal(object):
    """Properties for the Internal Power power source component."""
    _uuid = "{8ACB8A4A-52E8-4E71-8FD1-37B53E392858}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_generated_power"] = _raise_uninitialized_error
        self.__dict__["_set_generated_power"] = _raise_uninitialized_error
        self.__dict__["_get_percent_degradation_per_year"] = _raise_uninitialized_error
        self.__dict__["_set_percent_degradation_per_year"] = _raise_uninitialized_error
        self.__dict__["_get_reference_epoch"] = _raise_uninitialized_error
        self.__dict__["_set_reference_epoch"] = _raise_uninitialized_error
        self.__dict__["_enable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_disable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_is_control_parameter_enabled"] = _raise_uninitialized_error
        self.__dict__["_get_control_parameters_available"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPowerInternal._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPowerInternal from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPowerInternal = agcom.GUID(IPowerInternal._uuid)
        vtable_offset_local = IPowerInternal._vtable_offset - 1
        self.__dict__["_get_generated_power"] = IAGFUNCTYPE(pUnk, IID_IPowerInternal, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_generated_power"] = IAGFUNCTYPE(pUnk, IID_IPowerInternal, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_percent_degradation_per_year"] = IAGFUNCTYPE(pUnk, IID_IPowerInternal, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_percent_degradation_per_year"] = IAGFUNCTYPE(pUnk, IID_IPowerInternal, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_reference_epoch"] = IAGFUNCTYPE(pUnk, IID_IPowerInternal, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_set_reference_epoch"] = IAGFUNCTYPE(pUnk, IID_IPowerInternal, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_enable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IPowerInternal, vtable_offset_local+7, agcom.LONG)
        self.__dict__["_disable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IPowerInternal, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_is_control_parameter_enabled"] = IAGFUNCTYPE(pUnk, IID_IPowerInternal, vtable_offset_local+9, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_control_parameters_available"] = IAGFUNCTYPE(pUnk, IID_IPowerInternal, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPowerInternal.__dict__ and type(IPowerInternal.__dict__[attrname]) == property:
            return IPowerInternal.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPowerInternal.")
    
    @property
    def generated_power(self) -> float:
        """The power generated by the spacecraft from internal sources. Uses Power Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_generated_power"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @generated_power.setter
    def generated_power(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_generated_power"](arg_inVal.COM_val))

    @property
    def percent_degradation_per_year(self) -> float:
        """The percent degradation per year; degradation factor is (1-x%/yr)^(timeSinceRefEpoch). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_percent_degradation_per_year"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @percent_degradation_per_year.setter
    def percent_degradation_per_year(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_percent_degradation_per_year"](arg_inVal.COM_val))

    @property
    def reference_epoch(self) -> typing.Any:
        """The date and Time used as reference epoch for degradation. Uses DateFormat Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_epoch"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_epoch.setter
    def reference_epoch(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_epoch"](arg_inVal.COM_val))

    def enable_control_parameter(self, param:"AgEVAControlPowerInternal") -> None:
        """Enables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlPowerInternal, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_enable_control_parameter"](arg_param.COM_val))

    def disable_control_parameter(self, param:"AgEVAControlPowerInternal") -> None:
        """Disables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlPowerInternal, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_disable_control_parameter"](arg_param.COM_val))

    def is_control_parameter_enabled(self, param:"AgEVAControlPowerInternal") -> bool:
        """Sees if the specified control is enabled."""
        with agmarshall.AgEnum_arg(AgEVAControlPowerInternal, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_is_control_parameter_enabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_parameters_available(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_parameters_available"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{8ACB8A4A-52E8-4E71-8FD1-37B53E392858}", IPowerInternal)
agcls.AgTypeNameMap["IPowerInternal"] = IPowerInternal

class IPowerProcessed(object):
    """Properties for the Processed Power power source component."""
    _uuid = "{D3C19CA2-B73F-48BB-9B24-A7860136AE03}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_load"] = _raise_uninitialized_error
        self.__dict__["_set_load"] = _raise_uninitialized_error
        self.__dict__["_get_efficiency"] = _raise_uninitialized_error
        self.__dict__["_set_efficiency"] = _raise_uninitialized_error
        self.__dict__["_get_input_power_source_name"] = _raise_uninitialized_error
        self.__dict__["_set_input_power_source_name"] = _raise_uninitialized_error
        self.__dict__["_enable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_disable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_is_control_parameter_enabled"] = _raise_uninitialized_error
        self.__dict__["_get_control_parameters_available"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPowerProcessed._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPowerProcessed from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPowerProcessed = agcom.GUID(IPowerProcessed._uuid)
        vtable_offset_local = IPowerProcessed._vtable_offset - 1
        self.__dict__["_get_load"] = IAGFUNCTYPE(pUnk, IID_IPowerProcessed, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_load"] = IAGFUNCTYPE(pUnk, IID_IPowerProcessed, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_efficiency"] = IAGFUNCTYPE(pUnk, IID_IPowerProcessed, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_efficiency"] = IAGFUNCTYPE(pUnk, IID_IPowerProcessed, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_input_power_source_name"] = IAGFUNCTYPE(pUnk, IID_IPowerProcessed, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_set_input_power_source_name"] = IAGFUNCTYPE(pUnk, IID_IPowerProcessed, vtable_offset_local+6, agcom.BSTR)
        self.__dict__["_enable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IPowerProcessed, vtable_offset_local+7, agcom.LONG)
        self.__dict__["_disable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IPowerProcessed, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_is_control_parameter_enabled"] = IAGFUNCTYPE(pUnk, IID_IPowerProcessed, vtable_offset_local+9, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_control_parameters_available"] = IAGFUNCTYPE(pUnk, IID_IPowerProcessed, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPowerProcessed.__dict__ and type(IPowerProcessed.__dict__[attrname]) == property:
            return IPowerProcessed.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPowerProcessed.")
    
    @property
    def load(self) -> float:
        """The power diverted from power source and unavailable to PPU. Uses Power Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_load"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @load.setter
    def load(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_load"](arg_inVal.COM_val))

    @property
    def efficiency(self) -> float:
        """The efficiency of the PPU unit. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_efficiency"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @efficiency.setter
    def efficiency(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_efficiency"](arg_inVal.COM_val))

    @property
    def input_power_source_name(self) -> str:
        """The source of power available to PPU."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_input_power_source_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @input_power_source_name.setter
    def input_power_source_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_input_power_source_name"](arg_inVal.COM_val))

    def enable_control_parameter(self, param:"AgEVAControlPowerProcessed") -> None:
        """Enables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlPowerProcessed, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_enable_control_parameter"](arg_param.COM_val))

    def disable_control_parameter(self, param:"AgEVAControlPowerProcessed") -> None:
        """Disables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlPowerProcessed, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_disable_control_parameter"](arg_param.COM_val))

    def is_control_parameter_enabled(self, param:"AgEVAControlPowerProcessed") -> bool:
        """Sees if the specified control is enabled."""
        with agmarshall.AgEnum_arg(AgEVAControlPowerProcessed, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_is_control_parameter_enabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_parameters_available(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_parameters_available"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{D3C19CA2-B73F-48BB-9B24-A7860136AE03}", IPowerProcessed)
agcls.AgTypeNameMap["IPowerProcessed"] = IPowerProcessed

class IPowerSolarArray(object):
    """Properties for the Solar Array Power power source component."""
    _uuid = "{E8776401-2DE0-49E8-8080-FD0442E57701}"
    _num_methods = 29
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_area"] = _raise_uninitialized_error
        self.__dict__["_set_area"] = _raise_uninitialized_error
        self.__dict__["_get_concentration"] = _raise_uninitialized_error
        self.__dict__["_set_concentration"] = _raise_uninitialized_error
        self.__dict__["_get_cell_efficiency_percent"] = _raise_uninitialized_error
        self.__dict__["_set_cell_efficiency_percent"] = _raise_uninitialized_error
        self.__dict__["_get_array_efficiency_percent"] = _raise_uninitialized_error
        self.__dict__["_set_array_efficiency_percent"] = _raise_uninitialized_error
        self.__dict__["_get_percent_degradation_per_year"] = _raise_uninitialized_error
        self.__dict__["_set_percent_degradation_per_year"] = _raise_uninitialized_error
        self.__dict__["_get_reference_epoch"] = _raise_uninitialized_error
        self.__dict__["_set_reference_epoch"] = _raise_uninitialized_error
        self.__dict__["_get_inclination_to_sun_line"] = _raise_uninitialized_error
        self.__dict__["_set_inclination_to_sun_line"] = _raise_uninitialized_error
        self.__dict__["_get_c0"] = _raise_uninitialized_error
        self.__dict__["_set_c0"] = _raise_uninitialized_error
        self.__dict__["_get_c1"] = _raise_uninitialized_error
        self.__dict__["_set_c1"] = _raise_uninitialized_error
        self.__dict__["_get_c2"] = _raise_uninitialized_error
        self.__dict__["_set_c2"] = _raise_uninitialized_error
        self.__dict__["_get_c3"] = _raise_uninitialized_error
        self.__dict__["_set_c3"] = _raise_uninitialized_error
        self.__dict__["_get_c4"] = _raise_uninitialized_error
        self.__dict__["_set_c4"] = _raise_uninitialized_error
        self.__dict__["_get_approximation_formula"] = _raise_uninitialized_error
        self.__dict__["_enable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_disable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_is_control_parameter_enabled"] = _raise_uninitialized_error
        self.__dict__["_get_control_parameters_available"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPowerSolarArray._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPowerSolarArray from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPowerSolarArray = agcom.GUID(IPowerSolarArray._uuid)
        vtable_offset_local = IPowerSolarArray._vtable_offset - 1
        self.__dict__["_get_area"] = IAGFUNCTYPE(pUnk, IID_IPowerSolarArray, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_area"] = IAGFUNCTYPE(pUnk, IID_IPowerSolarArray, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_concentration"] = IAGFUNCTYPE(pUnk, IID_IPowerSolarArray, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_concentration"] = IAGFUNCTYPE(pUnk, IID_IPowerSolarArray, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_cell_efficiency_percent"] = IAGFUNCTYPE(pUnk, IID_IPowerSolarArray, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_cell_efficiency_percent"] = IAGFUNCTYPE(pUnk, IID_IPowerSolarArray, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_array_efficiency_percent"] = IAGFUNCTYPE(pUnk, IID_IPowerSolarArray, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_array_efficiency_percent"] = IAGFUNCTYPE(pUnk, IID_IPowerSolarArray, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_percent_degradation_per_year"] = IAGFUNCTYPE(pUnk, IID_IPowerSolarArray, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_percent_degradation_per_year"] = IAGFUNCTYPE(pUnk, IID_IPowerSolarArray, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_reference_epoch"] = IAGFUNCTYPE(pUnk, IID_IPowerSolarArray, vtable_offset_local+11, POINTER(agcom.VARIANT))
        self.__dict__["_set_reference_epoch"] = IAGFUNCTYPE(pUnk, IID_IPowerSolarArray, vtable_offset_local+12, agcom.VARIANT)
        self.__dict__["_get_inclination_to_sun_line"] = IAGFUNCTYPE(pUnk, IID_IPowerSolarArray, vtable_offset_local+13, POINTER(agcom.VARIANT))
        self.__dict__["_set_inclination_to_sun_line"] = IAGFUNCTYPE(pUnk, IID_IPowerSolarArray, vtable_offset_local+14, agcom.VARIANT)
        self.__dict__["_get_c0"] = IAGFUNCTYPE(pUnk, IID_IPowerSolarArray, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_c0"] = IAGFUNCTYPE(pUnk, IID_IPowerSolarArray, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_c1"] = IAGFUNCTYPE(pUnk, IID_IPowerSolarArray, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_c1"] = IAGFUNCTYPE(pUnk, IID_IPowerSolarArray, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_c2"] = IAGFUNCTYPE(pUnk, IID_IPowerSolarArray, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_set_c2"] = IAGFUNCTYPE(pUnk, IID_IPowerSolarArray, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_get_c3"] = IAGFUNCTYPE(pUnk, IID_IPowerSolarArray, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_set_c3"] = IAGFUNCTYPE(pUnk, IID_IPowerSolarArray, vtable_offset_local+22, agcom.DOUBLE)
        self.__dict__["_get_c4"] = IAGFUNCTYPE(pUnk, IID_IPowerSolarArray, vtable_offset_local+23, POINTER(agcom.DOUBLE))
        self.__dict__["_set_c4"] = IAGFUNCTYPE(pUnk, IID_IPowerSolarArray, vtable_offset_local+24, agcom.DOUBLE)
        self.__dict__["_get_approximation_formula"] = IAGFUNCTYPE(pUnk, IID_IPowerSolarArray, vtable_offset_local+25, POINTER(agcom.BSTR))
        self.__dict__["_enable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IPowerSolarArray, vtable_offset_local+26, agcom.LONG)
        self.__dict__["_disable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IPowerSolarArray, vtable_offset_local+27, agcom.LONG)
        self.__dict__["_is_control_parameter_enabled"] = IAGFUNCTYPE(pUnk, IID_IPowerSolarArray, vtable_offset_local+28, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_control_parameters_available"] = IAGFUNCTYPE(pUnk, IID_IPowerSolarArray, vtable_offset_local+29, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPowerSolarArray.__dict__ and type(IPowerSolarArray.__dict__[attrname]) == property:
            return IPowerSolarArray.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPowerSolarArray.")
    
    @property
    def area(self) -> float:
        """The solar array panel area. Uses Area Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_area"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @area.setter
    def area(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_area"](arg_inVal.COM_val))

    @property
    def concentration(self) -> float:
        """The solar array concentrator factor. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_concentration"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @concentration.setter
    def concentration(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_concentration"](arg_inVal.COM_val))

    @property
    def cell_efficiency_percent(self) -> float:
        """The cell efficiency in producing output power from incident sunlight. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_cell_efficiency_percent"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @cell_efficiency_percent.setter
    def cell_efficiency_percent(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_cell_efficiency_percent"](arg_inVal.COM_val))

    @property
    def array_efficiency_percent(self) -> float:
        """The array efficiency in producing output power from a collection of cells. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_array_efficiency_percent"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @array_efficiency_percent.setter
    def array_efficiency_percent(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_array_efficiency_percent"](arg_inVal.COM_val))

    @property
    def percent_degradation_per_year(self) -> float:
        """The percent degradation per year; degradation factor is (1-x%/yr)^(timeSinceRefEpoch). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_percent_degradation_per_year"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @percent_degradation_per_year.setter
    def percent_degradation_per_year(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_percent_degradation_per_year"](arg_inVal.COM_val))

    @property
    def reference_epoch(self) -> typing.Any:
        """The date and Time used as reference epoch for degradation. Uses DateFormat Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_epoch"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_epoch.setter
    def reference_epoch(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_epoch"](arg_inVal.COM_val))

    @property
    def inclination_to_sun_line(self) -> typing.Any:
        """The angle between the panel normal vector to the apparent sun line. Uses AngleUnit Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_inclination_to_sun_line"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @inclination_to_sun_line.setter
    def inclination_to_sun_line(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_inclination_to_sun_line"](arg_inVal.COM_val))

    @property
    def c0(self) -> float:
        """The ThermalModel.C0 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_c0"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @c0.setter
    def c0(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_c0"](arg_inVal.COM_val))

    @property
    def c1(self) -> float:
        """The ThermalModel.C1 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_c1"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @c1.setter
    def c1(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_c1"](arg_inVal.COM_val))

    @property
    def c2(self) -> float:
        """The ThermalModel.C2 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_c2"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @c2.setter
    def c2(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_c2"](arg_inVal.COM_val))

    @property
    def c3(self) -> float:
        """The ThermalModel.C3 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_c3"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @c3.setter
    def c3(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_c3"](arg_inVal.COM_val))

    @property
    def c4(self) -> float:
        """The ThermalModel.C4 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_c4"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @c4.setter
    def c4(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_c4"](arg_inVal.COM_val))

    @property
    def approximation_formula(self) -> str:
        """The thermal factor as function of distance (in AU) to Sun."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_approximation_formula"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def enable_control_parameter(self, param:"AgEVAControlPowerSolarArray") -> None:
        """Enables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlPowerSolarArray, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_enable_control_parameter"](arg_param.COM_val))

    def disable_control_parameter(self, param:"AgEVAControlPowerSolarArray") -> None:
        """Disables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlPowerSolarArray, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_disable_control_parameter"](arg_param.COM_val))

    def is_control_parameter_enabled(self, param:"AgEVAControlPowerSolarArray") -> bool:
        """Sees if the specified control is enabled."""
        with agmarshall.AgEnum_arg(AgEVAControlPowerSolarArray, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_is_control_parameter_enabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_parameters_available(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_parameters_available"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{E8776401-2DE0-49E8-8080-FD0442E57701}", IPowerSolarArray)
agcls.AgTypeNameMap["IPowerSolarArray"] = IPowerSolarArray

class IGeneralRelativityFunction(object):
    """Properties for the General Relativity propagator function."""
    _uuid = "{020E7294-1784-40AA-95C2-153F87CB086F}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IGeneralRelativityFunction._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IGeneralRelativityFunction from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IGeneralRelativityFunction = agcom.GUID(IGeneralRelativityFunction._uuid)
        vtable_offset_local = IGeneralRelativityFunction._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IGeneralRelativityFunction.__dict__ and type(IGeneralRelativityFunction.__dict__[attrname]) == property:
            return IGeneralRelativityFunction.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IGeneralRelativityFunction.")
    

agcls.AgClassCatalog.add_catalog_entry("{020E7294-1784-40AA-95C2-153F87CB086F}", IGeneralRelativityFunction)
agcls.AgTypeNameMap["IGeneralRelativityFunction"] = IGeneralRelativityFunction

class IStateTransformationFunction(object):
    """Properties for the State Transition propagator function."""
    _uuid = "{67F8B465-6BC4-4736-8A83-EC7E55D45177}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IStateTransformationFunction._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IStateTransformationFunction from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IStateTransformationFunction = agcom.GUID(IStateTransformationFunction._uuid)
        vtable_offset_local = IStateTransformationFunction._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IStateTransformationFunction.__dict__ and type(IStateTransformationFunction.__dict__[attrname]) == property:
            return IStateTransformationFunction.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IStateTransformationFunction.")
    

agcls.AgClassCatalog.add_catalog_entry("{67F8B465-6BC4-4736-8A83-EC7E55D45177}", IStateTransformationFunction)
agcls.AgTypeNameMap["IStateTransformationFunction"] = IStateTransformationFunction

class ICR3BPFunc(object):
    """Properties for the CR3BP propagator function."""
    _uuid = "{1A2E3655-CF88-4272-8B52-257397D913BF}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_secondary_name"] = _raise_uninitialized_error
        self.__dict__["_set_secondary_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICR3BPFunc._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICR3BPFunc from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICR3BPFunc = agcom.GUID(ICR3BPFunc._uuid)
        vtable_offset_local = ICR3BPFunc._vtable_offset - 1
        self.__dict__["_get_secondary_name"] = IAGFUNCTYPE(pUnk, IID_ICR3BPFunc, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_secondary_name"] = IAGFUNCTYPE(pUnk, IID_ICR3BPFunc, vtable_offset_local+2, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICR3BPFunc.__dict__ and type(ICR3BPFunc.__dict__[attrname]) == property:
            return ICR3BPFunc.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICR3BPFunc.")
    
    @property
    def secondary_name(self) -> str:
        """The secondary body following CR3BP model definitions."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_secondary_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @secondary_name.setter
    def secondary_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_secondary_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{1A2E3655-CF88-4272-8B52-257397D913BF}", ICR3BPFunc)
agcls.AgTypeNameMap["ICR3BPFunc"] = ICR3BPFunc

class IRadiationPressureFunction(object):
    """Properties for the Radiation Pressure propagator function."""
    _uuid = "{CED70D8F-A1BF-402D-A767-E7A6E857507C}"
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_include_albedo"] = _raise_uninitialized_error
        self.__dict__["_set_include_albedo"] = _raise_uninitialized_error
        self.__dict__["_get_include_thermal_radiation_pressure"] = _raise_uninitialized_error
        self.__dict__["_set_include_thermal_radiation_pressure"] = _raise_uninitialized_error
        self.__dict__["_get_ground_reflection_model_filename"] = _raise_uninitialized_error
        self.__dict__["_set_ground_reflection_model_filename"] = _raise_uninitialized_error
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_override_segment_settings"] = _raise_uninitialized_error
        self.__dict__["_set_override_segment_settings"] = _raise_uninitialized_error
        self.__dict__["_get_rad_pressure_coeff"] = _raise_uninitialized_error
        self.__dict__["_set_rad_pressure_coeff"] = _raise_uninitialized_error
        self.__dict__["_get_rad_pressure_area"] = _raise_uninitialized_error
        self.__dict__["_set_rad_pressure_area"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IRadiationPressureFunction._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IRadiationPressureFunction from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IRadiationPressureFunction = agcom.GUID(IRadiationPressureFunction._uuid)
        vtable_offset_local = IRadiationPressureFunction._vtable_offset - 1
        self.__dict__["_get_include_albedo"] = IAGFUNCTYPE(pUnk, IID_IRadiationPressureFunction, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_include_albedo"] = IAGFUNCTYPE(pUnk, IID_IRadiationPressureFunction, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_include_thermal_radiation_pressure"] = IAGFUNCTYPE(pUnk, IID_IRadiationPressureFunction, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_include_thermal_radiation_pressure"] = IAGFUNCTYPE(pUnk, IID_IRadiationPressureFunction, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_get_ground_reflection_model_filename"] = IAGFUNCTYPE(pUnk, IID_IRadiationPressureFunction, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_set_ground_reflection_model_filename"] = IAGFUNCTYPE(pUnk, IID_IRadiationPressureFunction, vtable_offset_local+6, agcom.BSTR)
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IRadiationPressureFunction, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_get_override_segment_settings"] = IAGFUNCTYPE(pUnk, IID_IRadiationPressureFunction, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_override_segment_settings"] = IAGFUNCTYPE(pUnk, IID_IRadiationPressureFunction, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_get_rad_pressure_coeff"] = IAGFUNCTYPE(pUnk, IID_IRadiationPressureFunction, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_set_rad_pressure_coeff"] = IAGFUNCTYPE(pUnk, IID_IRadiationPressureFunction, vtable_offset_local+11, agcom.DOUBLE)
        self.__dict__["_get_rad_pressure_area"] = IAGFUNCTYPE(pUnk, IID_IRadiationPressureFunction, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_set_rad_pressure_area"] = IAGFUNCTYPE(pUnk, IID_IRadiationPressureFunction, vtable_offset_local+13, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRadiationPressureFunction.__dict__ and type(IRadiationPressureFunction.__dict__[attrname]) == property:
            return IRadiationPressureFunction.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRadiationPressureFunction.")
    
    @property
    def include_albedo(self) -> bool:
        """True if including accelerations derived from albedo (reflected sunlight radiation from the central body)."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_include_albedo"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @include_albedo.setter
    def include_albedo(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_include_albedo"](arg_inVal.COM_val))

    @property
    def include_thermal_radiation_pressure(self) -> bool:
        """True if including accelerations derived from thermal radiation pressure from the central body."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_include_thermal_radiation_pressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @include_thermal_radiation_pressure.setter
    def include_thermal_radiation_pressure(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_include_thermal_radiation_pressure"](arg_inVal.COM_val))

    @property
    def ground_reflection_model_filename(self) -> str:
        """A file containing a ground reflection model used for albedo and thermal radiation pressure."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_ground_reflection_model_filename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ground_reflection_model_filename.setter
    def ground_reflection_model_filename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_ground_reflection_model_filename"](arg_inVal.COM_val))

    @property
    def central_body_name(self) -> str:
        """Name of the central body."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def override_segment_settings(self) -> bool:
        """True to use Ck and area values defined on this component for radiation pressure computations, rather than those defined in the MCS segments."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_override_segment_settings"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @override_segment_settings.setter
    def override_segment_settings(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_override_segment_settings"](arg_inVal.COM_val))

    @property
    def rad_pressure_coeff(self) -> float:
        """Coefficient, Ck, for use with radiation pressure computation."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_rad_pressure_coeff"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @rad_pressure_coeff.setter
    def rad_pressure_coeff(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_rad_pressure_coeff"](arg_inVal.COM_val))

    @property
    def rad_pressure_area(self) -> float:
        """Area to be used for radiation pressure computations. Small area dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_rad_pressure_area"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @rad_pressure_area.setter
    def rad_pressure_area(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_rad_pressure_area"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{CED70D8F-A1BF-402D-A767-E7A6E857507C}", IRadiationPressureFunction)
agcls.AgTypeNameMap["IRadiationPressureFunction"] = IRadiationPressureFunction

class IYarkovskyFunc(object):
    """Properties for the Yarkovsky Effect propagator function."""
    _uuid = "{AA6781B4-EACD-4100-8E23-C2771351BD7A}"
    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_alpha"] = _raise_uninitialized_error
        self.__dict__["_set_alpha"] = _raise_uninitialized_error
        self.__dict__["_get_r0"] = _raise_uninitialized_error
        self.__dict__["_set_r0"] = _raise_uninitialized_error
        self.__dict__["_get_nm"] = _raise_uninitialized_error
        self.__dict__["_set_nm"] = _raise_uninitialized_error
        self.__dict__["_get_nn"] = _raise_uninitialized_error
        self.__dict__["_set_nn"] = _raise_uninitialized_error
        self.__dict__["_get_nk"] = _raise_uninitialized_error
        self.__dict__["_set_nk"] = _raise_uninitialized_error
        self.__dict__["_get_a1"] = _raise_uninitialized_error
        self.__dict__["_set_a1"] = _raise_uninitialized_error
        self.__dict__["_get_a2"] = _raise_uninitialized_error
        self.__dict__["_set_a2"] = _raise_uninitialized_error
        self.__dict__["_get_a3"] = _raise_uninitialized_error
        self.__dict__["_set_a3"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IYarkovskyFunc._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IYarkovskyFunc from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IYarkovskyFunc = agcom.GUID(IYarkovskyFunc._uuid)
        vtable_offset_local = IYarkovskyFunc._vtable_offset - 1
        self.__dict__["_get_alpha"] = IAGFUNCTYPE(pUnk, IID_IYarkovskyFunc, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_alpha"] = IAGFUNCTYPE(pUnk, IID_IYarkovskyFunc, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_r0"] = IAGFUNCTYPE(pUnk, IID_IYarkovskyFunc, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_r0"] = IAGFUNCTYPE(pUnk, IID_IYarkovskyFunc, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_nm"] = IAGFUNCTYPE(pUnk, IID_IYarkovskyFunc, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_nm"] = IAGFUNCTYPE(pUnk, IID_IYarkovskyFunc, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_nn"] = IAGFUNCTYPE(pUnk, IID_IYarkovskyFunc, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_nn"] = IAGFUNCTYPE(pUnk, IID_IYarkovskyFunc, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_nk"] = IAGFUNCTYPE(pUnk, IID_IYarkovskyFunc, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_nk"] = IAGFUNCTYPE(pUnk, IID_IYarkovskyFunc, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_a1"] = IAGFUNCTYPE(pUnk, IID_IYarkovskyFunc, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_a1"] = IAGFUNCTYPE(pUnk, IID_IYarkovskyFunc, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_a2"] = IAGFUNCTYPE(pUnk, IID_IYarkovskyFunc, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_a2"] = IAGFUNCTYPE(pUnk, IID_IYarkovskyFunc, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_a3"] = IAGFUNCTYPE(pUnk, IID_IYarkovskyFunc, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_a3"] = IAGFUNCTYPE(pUnk, IID_IYarkovskyFunc, vtable_offset_local+16, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IYarkovskyFunc.__dict__ and type(IYarkovskyFunc.__dict__[attrname]) == property:
            return IYarkovskyFunc.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IYarkovskyFunc.")
    
    @property
    def alpha(self) -> float:
        """Yarkovsky effect alpha constant. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_alpha"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @alpha.setter
    def alpha(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_alpha"](arg_inVal.COM_val))

    @property
    def r0(self) -> float:
        """Heliocentric sublimation distance. Uses distance dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_r0"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @r0.setter
    def r0(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_r0"](arg_inVal.COM_val))

    @property
    def nm(self) -> float:
        """Yarkovsky effect m exponent. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_nm"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @nm.setter
    def nm(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_nm"](arg_inVal.COM_val))

    @property
    def nn(self) -> float:
        """Yarkovsky effect n exponent. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_nn"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @nn.setter
    def nn(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_nn"](arg_inVal.COM_val))

    @property
    def nk(self) -> float:
        """Yarkovsky effect k exponent. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_nk"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @nk.setter
    def nk(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_nk"](arg_inVal.COM_val))

    @property
    def a1(self) -> float:
        """Radial acceleration multiplier. Uses acceleration dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_a1"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @a1.setter
    def a1(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_a1"](arg_inVal.COM_val))

    @property
    def a2(self) -> float:
        """Velocity tangent acceleration multiplier. Uses acceleration dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_a2"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @a2.setter
    def a2(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_a2"](arg_inVal.COM_val))

    @property
    def a3(self) -> float:
        """Orbit normal acceleration multiplier. Uses acceleration dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_a3"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @a3.setter
    def a3(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_a3"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{AA6781B4-EACD-4100-8E23-C2771351BD7A}", IYarkovskyFunc)
agcls.AgTypeNameMap["IYarkovskyFunc"] = IYarkovskyFunc

class IBlendedDensity(object):
    """Properties for the blended atmospheric density propagator function."""
    _uuid = "{E1951825-092B-48C8-88AE-7C878FBF40C3}"
    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_atm_density_model"] = _raise_uninitialized_error
        self.__dict__["_low_alt_atm_density_model"] = _raise_uninitialized_error
        self.__dict__["_get_density_blending_alt_range"] = _raise_uninitialized_error
        self.__dict__["_set_density_blending_alt_range"] = _raise_uninitialized_error
        self.__dict__["_get_atm_density_model_name"] = _raise_uninitialized_error
        self.__dict__["_get_low_alt_atm_density_model_name"] = _raise_uninitialized_error
        self.__dict__["_get_use_approx_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_use_approx_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_lower_bound_upper_atm_model"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBlendedDensity._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBlendedDensity from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBlendedDensity = agcom.GUID(IBlendedDensity._uuid)
        vtable_offset_local = IBlendedDensity._vtable_offset - 1
        self.__dict__["_atm_density_model"] = IAGFUNCTYPE(pUnk, IID_IBlendedDensity, vtable_offset_local+1, agcom.PVOID)
        self.__dict__["_low_alt_atm_density_model"] = IAGFUNCTYPE(pUnk, IID_IBlendedDensity, vtable_offset_local+2, agcom.PVOID)
        self.__dict__["_get_density_blending_alt_range"] = IAGFUNCTYPE(pUnk, IID_IBlendedDensity, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_density_blending_alt_range"] = IAGFUNCTYPE(pUnk, IID_IBlendedDensity, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_atm_density_model_name"] = IAGFUNCTYPE(pUnk, IID_IBlendedDensity, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_get_low_alt_atm_density_model_name"] = IAGFUNCTYPE(pUnk, IID_IBlendedDensity, vtable_offset_local+6, POINTER(agcom.BSTR))
        self.__dict__["_get_use_approx_altitude"] = IAGFUNCTYPE(pUnk, IID_IBlendedDensity, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_approx_altitude"] = IAGFUNCTYPE(pUnk, IID_IBlendedDensity, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_get_lower_bound_upper_atm_model"] = IAGFUNCTYPE(pUnk, IID_IBlendedDensity, vtable_offset_local+9, POINTER(agcom.DOUBLE))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBlendedDensity.__dict__ and type(IBlendedDensity.__dict__[attrname]) == property:
            return IBlendedDensity.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBlendedDensity.")
    
    def atm_density_model(self, pInVal:"IComponentInfo") -> None:
        """Embeds a nominal atmosphere model from the component browser."""
        with agmarshall.AgInterface_in_arg(pInVal, IComponentInfo) as arg_pInVal:
            agcls.evaluate_hresult(self.__dict__["_atm_density_model"](arg_pInVal.COM_val))

    def low_alt_atm_density_model(self, pInVal:"IComponentInfo") -> None:
        """Embeds a low altitude atmosphere model from the component browser."""
        with agmarshall.AgInterface_in_arg(pInVal, IComponentInfo) as arg_pInVal:
            agcls.evaluate_hresult(self.__dict__["_low_alt_atm_density_model"](arg_pInVal.COM_val))

    @property
    def density_blending_alt_range(self) -> float:
        """The blending range (distance dimension), begins at lower bound of upper model."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_density_blending_alt_range"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @density_blending_alt_range.setter
    def density_blending_alt_range(self, inVal:float) -> None:
        """Set the blending range."""
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_density_blending_alt_range"](arg_inVal.COM_val))

    @property
    def atm_density_model_name(self) -> str:
        """Returns the name of the embedded nominal atmospheric model."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atm_density_model_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def low_alt_atm_density_model_name(self) -> str:
        """Returns the name of the embedded low altitude atmospheric model."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_low_alt_atm_density_model_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def use_approx_altitude(self) -> bool:
        """True if using approximate altitude formula (enforced on embedded models)."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_approx_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_approx_altitude.setter
    def use_approx_altitude(self, pVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_approx_altitude"](arg_pVal.COM_val))

    @property
    def lower_bound_upper_atm_model(self) -> float:
        """The lowest valid altitude of the upper atmospheric density model."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_lower_bound_upper_atm_model"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{E1951825-092B-48C8-88AE-7C878FBF40C3}", IBlendedDensity)
agcls.AgTypeNameMap["IBlendedDensity"] = IBlendedDensity

class IDragModelPlugin(object):
    """Properties for the Drag Model plugin."""
    _uuid = "{00D06156-07AD-4321-9741-9722A3D7BF85}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_plugin_identifier"] = _raise_uninitialized_error
        self.__dict__["_set_plugin_identifier"] = _raise_uninitialized_error
        self.__dict__["_get_plugin_config"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IDragModelPlugin._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IDragModelPlugin from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IDragModelPlugin = agcom.GUID(IDragModelPlugin._uuid)
        vtable_offset_local = IDragModelPlugin._vtable_offset - 1
        self.__dict__["_get_plugin_identifier"] = IAGFUNCTYPE(pUnk, IID_IDragModelPlugin, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_plugin_identifier"] = IAGFUNCTYPE(pUnk, IID_IDragModelPlugin, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_plugin_config"] = IAGFUNCTYPE(pUnk, IID_IDragModelPlugin, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IDragModelPlugin.__dict__ and type(IDragModelPlugin.__dict__[attrname]) == property:
            return IDragModelPlugin.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IDragModelPlugin.")
    
    @property
    def plugin_identifier(self) -> str:
        """The plugin name."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_plugin_identifier"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @plugin_identifier.setter
    def plugin_identifier(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_plugin_identifier"](arg_inVal.COM_val))

    @property
    def plugin_config(self) -> "IPluginProperties":
        """The properties of the selected plugin."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_plugin_config"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{00D06156-07AD-4321-9741-9722A3D7BF85}", IDragModelPlugin)
agcls.AgTypeNameMap["IDragModelPlugin"] = IDragModelPlugin

class ICira72Function(object):
    """Properties for the CIRA 72 atmospheric model."""
    _uuid = "{9FFC517F-7B30-4780-8028-A3E309E5BAE4}"
    _num_methods = 29
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_computes_temperature"] = _raise_uninitialized_error
        self.__dict__["_get_computes_pressure"] = _raise_uninitialized_error
        self.__dict__["_get_sun_position"] = _raise_uninitialized_error
        self.__dict__["_set_sun_position"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_source"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_source"] = _raise_uninitialized_error
        self.__dict__["_get_f_10_p7"] = _raise_uninitialized_error
        self.__dict__["_set_f_10_p7"] = _raise_uninitialized_error
        self.__dict__["_get_f_10_p7_avg"] = _raise_uninitialized_error
        self.__dict__["_set_f_10_p7_avg"] = _raise_uninitialized_error
        self.__dict__["_get_kp"] = _raise_uninitialized_error
        self.__dict__["_set_kp"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_geo_magnetic_flux_source"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_geo_magnetic_flux_source"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_geo_magnetic_flux_update_rate"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_geo_magnetic_flux_update_rate"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_filename"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_filename"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin"] = _raise_uninitialized_error
        self.__dict__["_get_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_set_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_get_n_plate_definition_file"] = _raise_uninitialized_error
        self.__dict__["_set_n_plate_definition_file"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICira72Function._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICira72Function from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICira72Function = agcom.GUID(ICira72Function._uuid)
        vtable_offset_local = ICira72Function._vtable_offset - 1
        self.__dict__["_get_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_ICira72Function, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_ICira72Function, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_computes_temperature"] = IAGFUNCTYPE(pUnk, IID_ICira72Function, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_computes_pressure"] = IAGFUNCTYPE(pUnk, IID_ICira72Function, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_sun_position"] = IAGFUNCTYPE(pUnk, IID_ICira72Function, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_sun_position"] = IAGFUNCTYPE(pUnk, IID_ICira72Function, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_atmos_data_source"] = IAGFUNCTYPE(pUnk, IID_ICira72Function, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_atmos_data_source"] = IAGFUNCTYPE(pUnk, IID_ICira72Function, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_f_10_p7"] = IAGFUNCTYPE(pUnk, IID_ICira72Function, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_f_10_p7"] = IAGFUNCTYPE(pUnk, IID_ICira72Function, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_f_10_p7_avg"] = IAGFUNCTYPE(pUnk, IID_ICira72Function, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_f_10_p7_avg"] = IAGFUNCTYPE(pUnk, IID_ICira72Function, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_kp"] = IAGFUNCTYPE(pUnk, IID_ICira72Function, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_kp"] = IAGFUNCTYPE(pUnk, IID_ICira72Function, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_atmos_data_geo_magnetic_flux_source"] = IAGFUNCTYPE(pUnk, IID_ICira72Function, vtable_offset_local+15, POINTER(agcom.LONG))
        self.__dict__["_set_atmos_data_geo_magnetic_flux_source"] = IAGFUNCTYPE(pUnk, IID_ICira72Function, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_get_atmos_data_geo_magnetic_flux_update_rate"] = IAGFUNCTYPE(pUnk, IID_ICira72Function, vtable_offset_local+17, POINTER(agcom.LONG))
        self.__dict__["_set_atmos_data_geo_magnetic_flux_update_rate"] = IAGFUNCTYPE(pUnk, IID_ICira72Function, vtable_offset_local+18, agcom.LONG)
        self.__dict__["_get_atmos_data_filename"] = IAGFUNCTYPE(pUnk, IID_ICira72Function, vtable_offset_local+19, POINTER(agcom.BSTR))
        self.__dict__["_set_atmos_data_filename"] = IAGFUNCTYPE(pUnk, IID_ICira72Function, vtable_offset_local+20, agcom.BSTR)
        self.__dict__["_get_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_ICira72Function, vtable_offset_local+21, POINTER(agcom.LONG))
        self.__dict__["_set_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_ICira72Function, vtable_offset_local+22, agcom.LONG)
        self.__dict__["_get_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_ICira72Function, vtable_offset_local+23, POINTER(agcom.BSTR))
        self.__dict__["_set_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_ICira72Function, vtable_offset_local+24, agcom.BSTR)
        self.__dict__["_get_drag_model_plugin"] = IAGFUNCTYPE(pUnk, IID_ICira72Function, vtable_offset_local+25, POINTER(agcom.PVOID))
        self.__dict__["_get_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_ICira72Function, vtable_offset_local+26, POINTER(agcom.BSTR))
        self.__dict__["_set_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_ICira72Function, vtable_offset_local+27, agcom.BSTR)
        self.__dict__["_get_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_ICira72Function, vtable_offset_local+28, POINTER(agcom.BSTR))
        self.__dict__["_set_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_ICira72Function, vtable_offset_local+29, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICira72Function.__dict__ and type(ICira72Function.__dict__[attrname]) == property:
            return ICira72Function.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICira72Function.")
    
    @property
    def use_approximate_altitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_approximate_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_approximate_altitude.setter
    def use_approximate_altitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_approximate_altitude"](arg_inVal.COM_val))

    @property
    def computes_temperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_temperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def computes_pressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_pressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def sun_position(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sun_position"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sun_position.setter
    def sun_position(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_sun_position"](arg_inVal.COM_val))

    @property
    def atmos_data_source(self) -> "AgEVAAtmosDataSource":
        """The atmospheric model data source - data file or constant values."""
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_source.setter
    def atmos_data_source(self, inVal:"AgEVAAtmosDataSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_source"](arg_inVal.COM_val))

    @property
    def f_10_p7(self) -> float:
        """Solar Flux (F10.7); the daily Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_f_10_p7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @f_10_p7.setter
    def f_10_p7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_f_10_p7"](arg_inVal.COM_val))

    @property
    def f_10_p7_avg(self) -> float:
        """Average solar Flux (F10.7); the 81-day averaged Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_f_10_p7_avg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @f_10_p7_avg.setter
    def f_10_p7_avg(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_f_10_p7_avg"](arg_inVal.COM_val))

    @property
    def kp(self) -> float:
        """Geomagnetic Index (Kp). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_kp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @kp.setter
    def kp(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_kp"](arg_inVal.COM_val))

    @property
    def atmos_data_geo_magnetic_flux_source(self) -> "AgEVAGeoMagneticFluxSource":
        """Whether to use Kp or Ap data from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_geo_magnetic_flux_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_geo_magnetic_flux_source.setter
    def atmos_data_geo_magnetic_flux_source(self, inVal:"AgEVAGeoMagneticFluxSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_geo_magnetic_flux_source"](arg_inVal.COM_val))

    @property
    def atmos_data_geo_magnetic_flux_update_rate(self) -> "AgEVAGeoMagneticFluxUpdateRate":
        """The update rate of geomagnetic flux values from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_geo_magnetic_flux_update_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_geo_magnetic_flux_update_rate.setter
    def atmos_data_geo_magnetic_flux_update_rate(self, inVal:"AgEVAGeoMagneticFluxUpdateRate") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_geo_magnetic_flux_update_rate"](arg_inVal.COM_val))

    @property
    def atmos_data_filename(self) -> str:
        """Flux file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_filename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_filename.setter
    def atmos_data_filename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_filename"](arg_inVal.COM_val))

    @property
    def drag_model_type(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_type.setter
    def drag_model_type(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_type"](arg_inVal.COM_val))

    @property
    def drag_model_plugin_name(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_plugin_name.setter
    def drag_model_plugin_name(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_plugin_name"](arg_pVal.COM_val))

    @property
    def drag_model_plugin(self) -> "IDragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def variable_area_history_file(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_variable_area_history_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @variable_area_history_file.setter
    def variable_area_history_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_variable_area_history_file"](arg_inVal.COM_val))

    @property
    def n_plate_definition_file(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_n_plate_definition_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @n_plate_definition_file.setter
    def n_plate_definition_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_n_plate_definition_file"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{9FFC517F-7B30-4780-8028-A3E309E5BAE4}", ICira72Function)
agcls.AgTypeNameMap["ICira72Function"] = ICira72Function

class IExponential(object):
    """Properties for the Exponential atmospheric model - a model that calculates atmospheric density using an equation involving a reference density, reference altitude, and scale altitude."""
    _uuid = "{987B718C-47F4-4638-900E-B87B0AAFEFBA}"
    _num_methods = 17
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_reference_density"] = _raise_uninitialized_error
        self.__dict__["_set_reference_density"] = _raise_uninitialized_error
        self.__dict__["_get_reference_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_reference_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_scale_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_scale_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin"] = _raise_uninitialized_error
        self.__dict__["_get_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_set_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_get_n_plate_definition_file"] = _raise_uninitialized_error
        self.__dict__["_set_n_plate_definition_file"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IExponential._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IExponential from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IExponential = agcom.GUID(IExponential._uuid)
        vtable_offset_local = IExponential._vtable_offset - 1
        self.__dict__["_get_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IExponential, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IExponential, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_reference_density"] = IAGFUNCTYPE(pUnk, IID_IExponential, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_reference_density"] = IAGFUNCTYPE(pUnk, IID_IExponential, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_reference_altitude"] = IAGFUNCTYPE(pUnk, IID_IExponential, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_reference_altitude"] = IAGFUNCTYPE(pUnk, IID_IExponential, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_scale_altitude"] = IAGFUNCTYPE(pUnk, IID_IExponential, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_scale_altitude"] = IAGFUNCTYPE(pUnk, IID_IExponential, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IExponential, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_set_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IExponential, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_get_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IExponential, vtable_offset_local+11, POINTER(agcom.BSTR))
        self.__dict__["_set_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IExponential, vtable_offset_local+12, agcom.BSTR)
        self.__dict__["_get_drag_model_plugin"] = IAGFUNCTYPE(pUnk, IID_IExponential, vtable_offset_local+13, POINTER(agcom.PVOID))
        self.__dict__["_get_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IExponential, vtable_offset_local+14, POINTER(agcom.BSTR))
        self.__dict__["_set_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IExponential, vtable_offset_local+15, agcom.BSTR)
        self.__dict__["_get_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IExponential, vtable_offset_local+16, POINTER(agcom.BSTR))
        self.__dict__["_set_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IExponential, vtable_offset_local+17, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IExponential.__dict__ and type(IExponential.__dict__[attrname]) == property:
            return IExponential.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IExponential.")
    
    @property
    def use_approximate_altitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_approximate_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_approximate_altitude.setter
    def use_approximate_altitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_approximate_altitude"](arg_inVal.COM_val))

    @property
    def reference_density(self) -> float:
        """The reference density. Uses Density Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_density"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_density.setter
    def reference_density(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_density"](arg_inVal.COM_val))

    @property
    def reference_altitude(self) -> float:
        """The reference altitude. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_altitude.setter
    def reference_altitude(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_altitude"](arg_inVal.COM_val))

    @property
    def scale_altitude(self) -> float:
        """The scale altitude. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_scale_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @scale_altitude.setter
    def scale_altitude(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_scale_altitude"](arg_inVal.COM_val))

    @property
    def drag_model_type(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_type.setter
    def drag_model_type(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_type"](arg_inVal.COM_val))

    @property
    def drag_model_plugin_name(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_plugin_name.setter
    def drag_model_plugin_name(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_plugin_name"](arg_pVal.COM_val))

    @property
    def drag_model_plugin(self) -> "IDragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def variable_area_history_file(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_variable_area_history_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @variable_area_history_file.setter
    def variable_area_history_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_variable_area_history_file"](arg_inVal.COM_val))

    @property
    def n_plate_definition_file(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_n_plate_definition_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @n_plate_definition_file.setter
    def n_plate_definition_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_n_plate_definition_file"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{987B718C-47F4-4638-900E-B87B0AAFEFBA}", IExponential)
agcls.AgTypeNameMap["IExponential"] = IExponential

class IHarrisPriester(object):
    """Properties for the Harris-Priester atmospheric model - a model that takes into account a 10.7 cm solar flux level and diurnal bulge."""
    _uuid = "{4481139D-2D5D-48F0-9372-2385F8F95658}"
    _num_methods = 21
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_computes_temperature"] = _raise_uninitialized_error
        self.__dict__["_get_computes_pressure"] = _raise_uninitialized_error
        self.__dict__["_get_sun_position"] = _raise_uninitialized_error
        self.__dict__["_set_sun_position"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_source"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_source"] = _raise_uninitialized_error
        self.__dict__["_get_f_10_p7_avg"] = _raise_uninitialized_error
        self.__dict__["_set_f_10_p7_avg"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_filename"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_filename"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin"] = _raise_uninitialized_error
        self.__dict__["_get_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_set_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_get_n_plate_definition_file"] = _raise_uninitialized_error
        self.__dict__["_set_n_plate_definition_file"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IHarrisPriester._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IHarrisPriester from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IHarrisPriester = agcom.GUID(IHarrisPriester._uuid)
        vtable_offset_local = IHarrisPriester._vtable_offset - 1
        self.__dict__["_get_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IHarrisPriester, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IHarrisPriester, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_computes_temperature"] = IAGFUNCTYPE(pUnk, IID_IHarrisPriester, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_computes_pressure"] = IAGFUNCTYPE(pUnk, IID_IHarrisPriester, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_sun_position"] = IAGFUNCTYPE(pUnk, IID_IHarrisPriester, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_sun_position"] = IAGFUNCTYPE(pUnk, IID_IHarrisPriester, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_atmos_data_source"] = IAGFUNCTYPE(pUnk, IID_IHarrisPriester, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_atmos_data_source"] = IAGFUNCTYPE(pUnk, IID_IHarrisPriester, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_f_10_p7_avg"] = IAGFUNCTYPE(pUnk, IID_IHarrisPriester, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_f_10_p7_avg"] = IAGFUNCTYPE(pUnk, IID_IHarrisPriester, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_atmos_data_filename"] = IAGFUNCTYPE(pUnk, IID_IHarrisPriester, vtable_offset_local+11, POINTER(agcom.BSTR))
        self.__dict__["_set_atmos_data_filename"] = IAGFUNCTYPE(pUnk, IID_IHarrisPriester, vtable_offset_local+12, agcom.BSTR)
        self.__dict__["_get_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IHarrisPriester, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_set_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IHarrisPriester, vtable_offset_local+14, agcom.LONG)
        self.__dict__["_get_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IHarrisPriester, vtable_offset_local+15, POINTER(agcom.BSTR))
        self.__dict__["_set_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IHarrisPriester, vtable_offset_local+16, agcom.BSTR)
        self.__dict__["_get_drag_model_plugin"] = IAGFUNCTYPE(pUnk, IID_IHarrisPriester, vtable_offset_local+17, POINTER(agcom.PVOID))
        self.__dict__["_get_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IHarrisPriester, vtable_offset_local+18, POINTER(agcom.BSTR))
        self.__dict__["_set_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IHarrisPriester, vtable_offset_local+19, agcom.BSTR)
        self.__dict__["_get_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IHarrisPriester, vtable_offset_local+20, POINTER(agcom.BSTR))
        self.__dict__["_set_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IHarrisPriester, vtable_offset_local+21, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IHarrisPriester.__dict__ and type(IHarrisPriester.__dict__[attrname]) == property:
            return IHarrisPriester.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IHarrisPriester.")
    
    @property
    def use_approximate_altitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_approximate_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_approximate_altitude.setter
    def use_approximate_altitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_approximate_altitude"](arg_inVal.COM_val))

    @property
    def computes_temperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_temperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def computes_pressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_pressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def sun_position(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sun_position"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sun_position.setter
    def sun_position(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_sun_position"](arg_inVal.COM_val))

    @property
    def atmos_data_source(self) -> "AgEVAAtmosDataSource":
        """The atmospheric model data source - data file or constant values."""
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_source.setter
    def atmos_data_source(self, inVal:"AgEVAAtmosDataSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_source"](arg_inVal.COM_val))

    @property
    def f_10_p7_avg(self) -> float:
        """Average solar Flux (F10.7); the 81-day averaged Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_f_10_p7_avg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @f_10_p7_avg.setter
    def f_10_p7_avg(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_f_10_p7_avg"](arg_inVal.COM_val))

    @property
    def atmos_data_filename(self) -> str:
        """Flux file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_filename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_filename.setter
    def atmos_data_filename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_filename"](arg_inVal.COM_val))

    @property
    def drag_model_type(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_type.setter
    def drag_model_type(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_type"](arg_inVal.COM_val))

    @property
    def drag_model_plugin_name(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_plugin_name.setter
    def drag_model_plugin_name(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_plugin_name"](arg_pVal.COM_val))

    @property
    def drag_model_plugin(self) -> "IDragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def variable_area_history_file(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_variable_area_history_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @variable_area_history_file.setter
    def variable_area_history_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_variable_area_history_file"](arg_inVal.COM_val))

    @property
    def n_plate_definition_file(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_n_plate_definition_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @n_plate_definition_file.setter
    def n_plate_definition_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_n_plate_definition_file"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4481139D-2D5D-48F0-9372-2385F8F95658}", IHarrisPriester)
agcls.AgTypeNameMap["IHarrisPriester"] = IHarrisPriester

class IDensityModelPlugin(object):
    """Properties for the plugin atmospheric density model."""
    _uuid = "{FCE828BB-B2CE-4F2C-91EC-42ED00564FF4}"
    _num_methods = 51
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_plugin_identifier"] = _raise_uninitialized_error
        self.__dict__["_set_plugin_identifier"] = _raise_uninitialized_error
        self.__dict__["_get_plugin_config"] = _raise_uninitialized_error
        self.__dict__["_get_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_computes_temperature"] = _raise_uninitialized_error
        self.__dict__["_get_computes_pressure"] = _raise_uninitialized_error
        self.__dict__["_get_sun_position"] = _raise_uninitialized_error
        self.__dict__["_set_sun_position"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_source"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_source"] = _raise_uninitialized_error
        self.__dict__["_get_f10"] = _raise_uninitialized_error
        self.__dict__["_set_f10"] = _raise_uninitialized_error
        self.__dict__["_get_f10_avg"] = _raise_uninitialized_error
        self.__dict__["_set_f10_avg"] = _raise_uninitialized_error
        self.__dict__["_get_m10"] = _raise_uninitialized_error
        self.__dict__["_set_m10"] = _raise_uninitialized_error
        self.__dict__["_get_m10_avg"] = _raise_uninitialized_error
        self.__dict__["_set_m10_avg"] = _raise_uninitialized_error
        self.__dict__["_get_s10"] = _raise_uninitialized_error
        self.__dict__["_set_s10"] = _raise_uninitialized_error
        self.__dict__["_get_s10_avg"] = _raise_uninitialized_error
        self.__dict__["_set_s10_avg"] = _raise_uninitialized_error
        self.__dict__["_get_y10"] = _raise_uninitialized_error
        self.__dict__["_set_y10"] = _raise_uninitialized_error
        self.__dict__["_get_y10_avg"] = _raise_uninitialized_error
        self.__dict__["_set_y10_avg"] = _raise_uninitialized_error
        self.__dict__["_get_kp"] = _raise_uninitialized_error
        self.__dict__["_set_kp"] = _raise_uninitialized_error
        self.__dict__["_get_dst_d_tc"] = _raise_uninitialized_error
        self.__dict__["_set_dst_d_tc"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_geo_magnetic_flux_source"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_geo_magnetic_flux_source"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_geo_magnetic_flux_update_rate"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_geo_magnetic_flux_update_rate"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_filename"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_filename"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_aug_data_file"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_aug_data_file"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_aug_dtc_file"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_aug_dtc_file"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin"] = _raise_uninitialized_error
        self.__dict__["_get_uses_augmented_space_weather"] = _raise_uninitialized_error
        self.__dict__["_get_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_set_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_get_n_plate_definition_file"] = _raise_uninitialized_error
        self.__dict__["_set_n_plate_definition_file"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IDensityModelPlugin._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IDensityModelPlugin from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IDensityModelPlugin = agcom.GUID(IDensityModelPlugin._uuid)
        vtable_offset_local = IDensityModelPlugin._vtable_offset - 1
        self.__dict__["_get_plugin_identifier"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_plugin_identifier"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_plugin_config"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+5, agcom.VARIANT_BOOL)
        self.__dict__["_get_computes_temperature"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+6, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_computes_pressure"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_sun_position"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+8, POINTER(agcom.LONG))
        self.__dict__["_set_sun_position"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+9, agcom.LONG)
        self.__dict__["_get_atmos_data_source"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+10, POINTER(agcom.LONG))
        self.__dict__["_set_atmos_data_source"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+11, agcom.LONG)
        self.__dict__["_get_f10"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_set_f10"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+13, agcom.DOUBLE)
        self.__dict__["_get_f10_avg"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+14, POINTER(agcom.DOUBLE))
        self.__dict__["_set_f10_avg"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+15, agcom.DOUBLE)
        self.__dict__["_get_m10"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+16, POINTER(agcom.DOUBLE))
        self.__dict__["_set_m10"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+17, agcom.DOUBLE)
        self.__dict__["_get_m10_avg"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+18, POINTER(agcom.DOUBLE))
        self.__dict__["_set_m10_avg"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+19, agcom.DOUBLE)
        self.__dict__["_get_s10"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+20, POINTER(agcom.DOUBLE))
        self.__dict__["_set_s10"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+21, agcom.DOUBLE)
        self.__dict__["_get_s10_avg"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+22, POINTER(agcom.DOUBLE))
        self.__dict__["_set_s10_avg"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+23, agcom.DOUBLE)
        self.__dict__["_get_y10"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+24, POINTER(agcom.DOUBLE))
        self.__dict__["_set_y10"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+25, agcom.DOUBLE)
        self.__dict__["_get_y10_avg"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+26, POINTER(agcom.DOUBLE))
        self.__dict__["_set_y10_avg"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+27, agcom.DOUBLE)
        self.__dict__["_get_kp"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+28, POINTER(agcom.DOUBLE))
        self.__dict__["_set_kp"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+29, agcom.DOUBLE)
        self.__dict__["_get_dst_d_tc"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+30, POINTER(agcom.DOUBLE))
        self.__dict__["_set_dst_d_tc"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+31, agcom.DOUBLE)
        self.__dict__["_get_atmos_data_geo_magnetic_flux_source"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+32, POINTER(agcom.LONG))
        self.__dict__["_set_atmos_data_geo_magnetic_flux_source"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+33, agcom.LONG)
        self.__dict__["_get_atmos_data_geo_magnetic_flux_update_rate"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+34, POINTER(agcom.LONG))
        self.__dict__["_set_atmos_data_geo_magnetic_flux_update_rate"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+35, agcom.LONG)
        self.__dict__["_get_atmos_data_filename"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+36, POINTER(agcom.BSTR))
        self.__dict__["_set_atmos_data_filename"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+37, agcom.BSTR)
        self.__dict__["_get_atmos_aug_data_file"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+38, POINTER(agcom.BSTR))
        self.__dict__["_set_atmos_aug_data_file"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+39, agcom.BSTR)
        self.__dict__["_get_atmos_aug_dtc_file"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+40, POINTER(agcom.BSTR))
        self.__dict__["_set_atmos_aug_dtc_file"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+41, agcom.BSTR)
        self.__dict__["_get_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+42, POINTER(agcom.LONG))
        self.__dict__["_set_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+43, agcom.LONG)
        self.__dict__["_get_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+44, POINTER(agcom.BSTR))
        self.__dict__["_set_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+45, agcom.BSTR)
        self.__dict__["_get_drag_model_plugin"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+46, POINTER(agcom.PVOID))
        self.__dict__["_get_uses_augmented_space_weather"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+47, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+48, POINTER(agcom.BSTR))
        self.__dict__["_set_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+49, agcom.BSTR)
        self.__dict__["_get_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+50, POINTER(agcom.BSTR))
        self.__dict__["_set_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IDensityModelPlugin, vtable_offset_local+51, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IDensityModelPlugin.__dict__ and type(IDensityModelPlugin.__dict__[attrname]) == property:
            return IDensityModelPlugin.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IDensityModelPlugin.")
    
    @property
    def plugin_identifier(self) -> str:
        """The plugin name."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_plugin_identifier"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @plugin_identifier.setter
    def plugin_identifier(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_plugin_identifier"](arg_inVal.COM_val))

    @property
    def plugin_config(self) -> "IPluginProperties":
        """The properties of the selected plugin."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_plugin_config"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def use_approximate_altitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_approximate_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_approximate_altitude.setter
    def use_approximate_altitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_approximate_altitude"](arg_inVal.COM_val))

    @property
    def computes_temperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_temperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def computes_pressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_pressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def sun_position(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sun_position"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sun_position.setter
    def sun_position(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_sun_position"](arg_inVal.COM_val))

    @property
    def atmos_data_source(self) -> "AgEVAAtmosDataSource":
        """The atmospheric model data source - data file or constant values."""
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_source.setter
    def atmos_data_source(self, inVal:"AgEVAAtmosDataSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_source"](arg_inVal.COM_val))

    @property
    def f10(self) -> float:
        """Solar Flux (F10). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_f10"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @f10.setter
    def f10(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_f10"](arg_inVal.COM_val))

    @property
    def f10_avg(self) -> float:
        """Average solar Flux (F10). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_f10_avg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @f10_avg.setter
    def f10_avg(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_f10_avg"](arg_inVal.COM_val))

    @property
    def m10(self) -> float:
        """Solar Flux (M10). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_m10"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @m10.setter
    def m10(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_m10"](arg_inVal.COM_val))

    @property
    def m10_avg(self) -> float:
        """Average solar Flux (M10). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_m10_avg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @m10_avg.setter
    def m10_avg(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_m10_avg"](arg_inVal.COM_val))

    @property
    def s10(self) -> float:
        """Solar Flux (S10). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_s10"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @s10.setter
    def s10(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_s10"](arg_inVal.COM_val))

    @property
    def s10_avg(self) -> float:
        """Average solar Flux (S10). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_s10_avg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @s10_avg.setter
    def s10_avg(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_s10_avg"](arg_inVal.COM_val))

    @property
    def y10(self) -> float:
        """Solar Flux (Y10). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_y10"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @y10.setter
    def y10(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_y10"](arg_inVal.COM_val))

    @property
    def y10_avg(self) -> float:
        """Average solar Flux (Y10). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_y10_avg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @y10_avg.setter
    def y10_avg(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_y10_avg"](arg_inVal.COM_val))

    @property
    def kp(self) -> float:
        """Geomagnetic Index (Kp). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_kp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @kp.setter
    def kp(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_kp"](arg_inVal.COM_val))

    @property
    def dst_d_tc(self) -> float:
        """Temperature change calculated from disturbance storm time (DstDTc). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_dst_d_tc"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @dst_d_tc.setter
    def dst_d_tc(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_dst_d_tc"](arg_inVal.COM_val))

    @property
    def atmos_data_geo_magnetic_flux_source(self) -> "AgEVAGeoMagneticFluxSource":
        """Whether to use Kp or Ap data from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_geo_magnetic_flux_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_geo_magnetic_flux_source.setter
    def atmos_data_geo_magnetic_flux_source(self, inVal:"AgEVAGeoMagneticFluxSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_geo_magnetic_flux_source"](arg_inVal.COM_val))

    @property
    def atmos_data_geo_magnetic_flux_update_rate(self) -> "AgEVAGeoMagneticFluxUpdateRate":
        """The update rate for geomagnetic flux values from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_geo_magnetic_flux_update_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_geo_magnetic_flux_update_rate.setter
    def atmos_data_geo_magnetic_flux_update_rate(self, inVal:"AgEVAGeoMagneticFluxUpdateRate") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_geo_magnetic_flux_update_rate"](arg_inVal.COM_val))

    @property
    def atmos_data_filename(self) -> str:
        """The atmospheric model data file path."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_filename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_filename.setter
    def atmos_data_filename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_filename"](arg_inVal.COM_val))

    @property
    def atmos_aug_data_file(self) -> str:
        """The atmospheric model augmented data file path."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_aug_data_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_aug_data_file.setter
    def atmos_aug_data_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_aug_data_file"](arg_inVal.COM_val))

    @property
    def atmos_aug_dtc_file(self) -> str:
        """The atmospheric model augmented geomagnetic data file path."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_aug_dtc_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_aug_dtc_file.setter
    def atmos_aug_dtc_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_aug_dtc_file"](arg_inVal.COM_val))

    @property
    def drag_model_type(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_type.setter
    def drag_model_type(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_type"](arg_inVal.COM_val))

    @property
    def drag_model_plugin_name(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_plugin_name.setter
    def drag_model_plugin_name(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_plugin_name"](arg_pVal.COM_val))

    @property
    def drag_model_plugin(self) -> "IDragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def uses_augmented_space_weather(self) -> bool:
        """Flag indicates whether this model uses augmented flux data."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_uses_augmented_space_weather"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def variable_area_history_file(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_variable_area_history_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @variable_area_history_file.setter
    def variable_area_history_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_variable_area_history_file"](arg_inVal.COM_val))

    @property
    def n_plate_definition_file(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_n_plate_definition_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @n_plate_definition_file.setter
    def n_plate_definition_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_n_plate_definition_file"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{FCE828BB-B2CE-4F2C-91EC-42ED00564FF4}", IDensityModelPlugin)
agcls.AgTypeNameMap["IDensityModelPlugin"] = IDensityModelPlugin

class IJacchiaRoberts(object):
    """Properties for the Jacchia-Roberts atmospheric model - a model that is similar to Jacchia 1971 but uses analytical methods to improve performance."""
    _uuid = "{EEC62B17-9E4D-4527-AC53-B8A7180A4A65}"
    _num_methods = 29
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_computes_temperature"] = _raise_uninitialized_error
        self.__dict__["_get_computes_pressure"] = _raise_uninitialized_error
        self.__dict__["_get_sun_position"] = _raise_uninitialized_error
        self.__dict__["_set_sun_position"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_source"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_source"] = _raise_uninitialized_error
        self.__dict__["_get_f_10_p7"] = _raise_uninitialized_error
        self.__dict__["_set_f_10_p7"] = _raise_uninitialized_error
        self.__dict__["_get_f_10_p7_avg"] = _raise_uninitialized_error
        self.__dict__["_set_f_10_p7_avg"] = _raise_uninitialized_error
        self.__dict__["_get_kp"] = _raise_uninitialized_error
        self.__dict__["_set_kp"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_geo_magnetic_flux_source"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_geo_magnetic_flux_source"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_geo_magnetic_flux_update_rate"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_geo_magnetic_flux_update_rate"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_filename"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_filename"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin"] = _raise_uninitialized_error
        self.__dict__["_get_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_set_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_get_n_plate_definition_file"] = _raise_uninitialized_error
        self.__dict__["_set_n_plate_definition_file"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IJacchiaRoberts._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IJacchiaRoberts from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IJacchiaRoberts = agcom.GUID(IJacchiaRoberts._uuid)
        vtable_offset_local = IJacchiaRoberts._vtable_offset - 1
        self.__dict__["_get_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IJacchiaRoberts, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IJacchiaRoberts, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_computes_temperature"] = IAGFUNCTYPE(pUnk, IID_IJacchiaRoberts, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_computes_pressure"] = IAGFUNCTYPE(pUnk, IID_IJacchiaRoberts, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_sun_position"] = IAGFUNCTYPE(pUnk, IID_IJacchiaRoberts, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_sun_position"] = IAGFUNCTYPE(pUnk, IID_IJacchiaRoberts, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_atmos_data_source"] = IAGFUNCTYPE(pUnk, IID_IJacchiaRoberts, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_atmos_data_source"] = IAGFUNCTYPE(pUnk, IID_IJacchiaRoberts, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_f_10_p7"] = IAGFUNCTYPE(pUnk, IID_IJacchiaRoberts, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_f_10_p7"] = IAGFUNCTYPE(pUnk, IID_IJacchiaRoberts, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_f_10_p7_avg"] = IAGFUNCTYPE(pUnk, IID_IJacchiaRoberts, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_f_10_p7_avg"] = IAGFUNCTYPE(pUnk, IID_IJacchiaRoberts, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_kp"] = IAGFUNCTYPE(pUnk, IID_IJacchiaRoberts, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_kp"] = IAGFUNCTYPE(pUnk, IID_IJacchiaRoberts, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_atmos_data_geo_magnetic_flux_source"] = IAGFUNCTYPE(pUnk, IID_IJacchiaRoberts, vtable_offset_local+15, POINTER(agcom.LONG))
        self.__dict__["_set_atmos_data_geo_magnetic_flux_source"] = IAGFUNCTYPE(pUnk, IID_IJacchiaRoberts, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_get_atmos_data_geo_magnetic_flux_update_rate"] = IAGFUNCTYPE(pUnk, IID_IJacchiaRoberts, vtable_offset_local+17, POINTER(agcom.LONG))
        self.__dict__["_set_atmos_data_geo_magnetic_flux_update_rate"] = IAGFUNCTYPE(pUnk, IID_IJacchiaRoberts, vtable_offset_local+18, agcom.LONG)
        self.__dict__["_get_atmos_data_filename"] = IAGFUNCTYPE(pUnk, IID_IJacchiaRoberts, vtable_offset_local+19, POINTER(agcom.BSTR))
        self.__dict__["_set_atmos_data_filename"] = IAGFUNCTYPE(pUnk, IID_IJacchiaRoberts, vtable_offset_local+20, agcom.BSTR)
        self.__dict__["_get_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IJacchiaRoberts, vtable_offset_local+21, POINTER(agcom.LONG))
        self.__dict__["_set_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IJacchiaRoberts, vtable_offset_local+22, agcom.LONG)
        self.__dict__["_get_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IJacchiaRoberts, vtable_offset_local+23, POINTER(agcom.BSTR))
        self.__dict__["_set_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IJacchiaRoberts, vtable_offset_local+24, agcom.BSTR)
        self.__dict__["_get_drag_model_plugin"] = IAGFUNCTYPE(pUnk, IID_IJacchiaRoberts, vtable_offset_local+25, POINTER(agcom.PVOID))
        self.__dict__["_get_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IJacchiaRoberts, vtable_offset_local+26, POINTER(agcom.BSTR))
        self.__dict__["_set_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IJacchiaRoberts, vtable_offset_local+27, agcom.BSTR)
        self.__dict__["_get_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IJacchiaRoberts, vtable_offset_local+28, POINTER(agcom.BSTR))
        self.__dict__["_set_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IJacchiaRoberts, vtable_offset_local+29, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IJacchiaRoberts.__dict__ and type(IJacchiaRoberts.__dict__[attrname]) == property:
            return IJacchiaRoberts.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IJacchiaRoberts.")
    
    @property
    def use_approximate_altitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_approximate_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_approximate_altitude.setter
    def use_approximate_altitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_approximate_altitude"](arg_inVal.COM_val))

    @property
    def computes_temperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_temperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def computes_pressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_pressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def sun_position(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sun_position"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sun_position.setter
    def sun_position(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_sun_position"](arg_inVal.COM_val))

    @property
    def atmos_data_source(self) -> "AgEVAAtmosDataSource":
        """The atmospheric model data source - data file or constant values."""
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_source.setter
    def atmos_data_source(self, inVal:"AgEVAAtmosDataSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_source"](arg_inVal.COM_val))

    @property
    def f_10_p7(self) -> float:
        """Solar Flux (F10.7); the daily Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_f_10_p7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @f_10_p7.setter
    def f_10_p7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_f_10_p7"](arg_inVal.COM_val))

    @property
    def f_10_p7_avg(self) -> float:
        """Average solar Flux (F10.7); the 81-day averaged Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_f_10_p7_avg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @f_10_p7_avg.setter
    def f_10_p7_avg(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_f_10_p7_avg"](arg_inVal.COM_val))

    @property
    def kp(self) -> float:
        """Geomagnetic Index (Kp). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_kp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @kp.setter
    def kp(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_kp"](arg_inVal.COM_val))

    @property
    def atmos_data_geo_magnetic_flux_source(self) -> "AgEVAGeoMagneticFluxSource":
        """Whether to use Kp or Ap data from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_geo_magnetic_flux_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_geo_magnetic_flux_source.setter
    def atmos_data_geo_magnetic_flux_source(self, inVal:"AgEVAGeoMagneticFluxSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_geo_magnetic_flux_source"](arg_inVal.COM_val))

    @property
    def atmos_data_geo_magnetic_flux_update_rate(self) -> "AgEVAGeoMagneticFluxUpdateRate":
        """The update rate for geomagnetic flux values from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_geo_magnetic_flux_update_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_geo_magnetic_flux_update_rate.setter
    def atmos_data_geo_magnetic_flux_update_rate(self, inVal:"AgEVAGeoMagneticFluxUpdateRate") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_geo_magnetic_flux_update_rate"](arg_inVal.COM_val))

    @property
    def atmos_data_filename(self) -> str:
        """The atmospheric model data file path."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_filename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_filename.setter
    def atmos_data_filename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_filename"](arg_inVal.COM_val))

    @property
    def drag_model_type(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_type.setter
    def drag_model_type(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_type"](arg_inVal.COM_val))

    @property
    def drag_model_plugin_name(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_plugin_name.setter
    def drag_model_plugin_name(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_plugin_name"](arg_pVal.COM_val))

    @property
    def drag_model_plugin(self) -> "IDragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def variable_area_history_file(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_variable_area_history_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @variable_area_history_file.setter
    def variable_area_history_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_variable_area_history_file"](arg_inVal.COM_val))

    @property
    def n_plate_definition_file(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_n_plate_definition_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @n_plate_definition_file.setter
    def n_plate_definition_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_n_plate_definition_file"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{EEC62B17-9E4D-4527-AC53-B8A7180A4A65}", IJacchiaRoberts)
agcls.AgTypeNameMap["IJacchiaRoberts"] = IJacchiaRoberts

class IJacchiaBowman2008(object):
    """Properties for the Jacchia Bowman 2008 atmospheric density model."""
    _uuid = "{49B828F8-A541-4E9E-99DD-DF3708B3559F}"
    _num_methods = 37
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_sun_position"] = _raise_uninitialized_error
        self.__dict__["_set_sun_position"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_source"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_source"] = _raise_uninitialized_error
        self.__dict__["_get_f10"] = _raise_uninitialized_error
        self.__dict__["_set_f10"] = _raise_uninitialized_error
        self.__dict__["_get_f10_avg"] = _raise_uninitialized_error
        self.__dict__["_set_f10_avg"] = _raise_uninitialized_error
        self.__dict__["_get_m10"] = _raise_uninitialized_error
        self.__dict__["_set_m10"] = _raise_uninitialized_error
        self.__dict__["_get_m10_avg"] = _raise_uninitialized_error
        self.__dict__["_set_m10_avg"] = _raise_uninitialized_error
        self.__dict__["_get_s10"] = _raise_uninitialized_error
        self.__dict__["_set_s10"] = _raise_uninitialized_error
        self.__dict__["_get_s10_avg"] = _raise_uninitialized_error
        self.__dict__["_set_s10_avg"] = _raise_uninitialized_error
        self.__dict__["_get_y10"] = _raise_uninitialized_error
        self.__dict__["_set_y10"] = _raise_uninitialized_error
        self.__dict__["_get_y10_avg"] = _raise_uninitialized_error
        self.__dict__["_set_y10_avg"] = _raise_uninitialized_error
        self.__dict__["_get_dst_d_tc"] = _raise_uninitialized_error
        self.__dict__["_set_dst_d_tc"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_aug_data_file"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_aug_data_file"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_aug_dtc_file"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_aug_dtc_file"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin"] = _raise_uninitialized_error
        self.__dict__["_get_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_set_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_get_n_plate_definition_file"] = _raise_uninitialized_error
        self.__dict__["_set_n_plate_definition_file"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IJacchiaBowman2008._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IJacchiaBowman2008 from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IJacchiaBowman2008 = agcom.GUID(IJacchiaBowman2008._uuid)
        vtable_offset_local = IJacchiaBowman2008._vtable_offset - 1
        self.__dict__["_get_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IJacchiaBowman2008, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IJacchiaBowman2008, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_sun_position"] = IAGFUNCTYPE(pUnk, IID_IJacchiaBowman2008, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_sun_position"] = IAGFUNCTYPE(pUnk, IID_IJacchiaBowman2008, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_atmos_data_source"] = IAGFUNCTYPE(pUnk, IID_IJacchiaBowman2008, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_atmos_data_source"] = IAGFUNCTYPE(pUnk, IID_IJacchiaBowman2008, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_f10"] = IAGFUNCTYPE(pUnk, IID_IJacchiaBowman2008, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_f10"] = IAGFUNCTYPE(pUnk, IID_IJacchiaBowman2008, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_f10_avg"] = IAGFUNCTYPE(pUnk, IID_IJacchiaBowman2008, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_f10_avg"] = IAGFUNCTYPE(pUnk, IID_IJacchiaBowman2008, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_m10"] = IAGFUNCTYPE(pUnk, IID_IJacchiaBowman2008, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_m10"] = IAGFUNCTYPE(pUnk, IID_IJacchiaBowman2008, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_m10_avg"] = IAGFUNCTYPE(pUnk, IID_IJacchiaBowman2008, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_m10_avg"] = IAGFUNCTYPE(pUnk, IID_IJacchiaBowman2008, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_s10"] = IAGFUNCTYPE(pUnk, IID_IJacchiaBowman2008, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_s10"] = IAGFUNCTYPE(pUnk, IID_IJacchiaBowman2008, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_s10_avg"] = IAGFUNCTYPE(pUnk, IID_IJacchiaBowman2008, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_s10_avg"] = IAGFUNCTYPE(pUnk, IID_IJacchiaBowman2008, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_y10"] = IAGFUNCTYPE(pUnk, IID_IJacchiaBowman2008, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_set_y10"] = IAGFUNCTYPE(pUnk, IID_IJacchiaBowman2008, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_get_y10_avg"] = IAGFUNCTYPE(pUnk, IID_IJacchiaBowman2008, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_set_y10_avg"] = IAGFUNCTYPE(pUnk, IID_IJacchiaBowman2008, vtable_offset_local+22, agcom.DOUBLE)
        self.__dict__["_get_dst_d_tc"] = IAGFUNCTYPE(pUnk, IID_IJacchiaBowman2008, vtable_offset_local+23, POINTER(agcom.DOUBLE))
        self.__dict__["_set_dst_d_tc"] = IAGFUNCTYPE(pUnk, IID_IJacchiaBowman2008, vtable_offset_local+24, agcom.DOUBLE)
        self.__dict__["_get_atmos_aug_data_file"] = IAGFUNCTYPE(pUnk, IID_IJacchiaBowman2008, vtable_offset_local+25, POINTER(agcom.BSTR))
        self.__dict__["_set_atmos_aug_data_file"] = IAGFUNCTYPE(pUnk, IID_IJacchiaBowman2008, vtable_offset_local+26, agcom.BSTR)
        self.__dict__["_get_atmos_aug_dtc_file"] = IAGFUNCTYPE(pUnk, IID_IJacchiaBowman2008, vtable_offset_local+27, POINTER(agcom.BSTR))
        self.__dict__["_set_atmos_aug_dtc_file"] = IAGFUNCTYPE(pUnk, IID_IJacchiaBowman2008, vtable_offset_local+28, agcom.BSTR)
        self.__dict__["_get_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IJacchiaBowman2008, vtable_offset_local+29, POINTER(agcom.LONG))
        self.__dict__["_set_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IJacchiaBowman2008, vtable_offset_local+30, agcom.LONG)
        self.__dict__["_get_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IJacchiaBowman2008, vtable_offset_local+31, POINTER(agcom.BSTR))
        self.__dict__["_set_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IJacchiaBowman2008, vtable_offset_local+32, agcom.BSTR)
        self.__dict__["_get_drag_model_plugin"] = IAGFUNCTYPE(pUnk, IID_IJacchiaBowman2008, vtable_offset_local+33, POINTER(agcom.PVOID))
        self.__dict__["_get_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IJacchiaBowman2008, vtable_offset_local+34, POINTER(agcom.BSTR))
        self.__dict__["_set_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IJacchiaBowman2008, vtable_offset_local+35, agcom.BSTR)
        self.__dict__["_get_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IJacchiaBowman2008, vtable_offset_local+36, POINTER(agcom.BSTR))
        self.__dict__["_set_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IJacchiaBowman2008, vtable_offset_local+37, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IJacchiaBowman2008.__dict__ and type(IJacchiaBowman2008.__dict__[attrname]) == property:
            return IJacchiaBowman2008.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IJacchiaBowman2008.")
    
    @property
    def use_approximate_altitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_approximate_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_approximate_altitude.setter
    def use_approximate_altitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_approximate_altitude"](arg_inVal.COM_val))

    @property
    def sun_position(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sun_position"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sun_position.setter
    def sun_position(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_sun_position"](arg_inVal.COM_val))

    @property
    def atmos_data_source(self) -> "AgEVAAtmosDataSource":
        """The atmospheric model data source - data file or constant values."""
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_source.setter
    def atmos_data_source(self, inVal:"AgEVAAtmosDataSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_source"](arg_inVal.COM_val))

    @property
    def f10(self) -> float:
        """Solar Flux (F10). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_f10"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @f10.setter
    def f10(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_f10"](arg_inVal.COM_val))

    @property
    def f10_avg(self) -> float:
        """Average solar Flux (F10). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_f10_avg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @f10_avg.setter
    def f10_avg(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_f10_avg"](arg_inVal.COM_val))

    @property
    def m10(self) -> float:
        """Solar Flux (M10). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_m10"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @m10.setter
    def m10(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_m10"](arg_inVal.COM_val))

    @property
    def m10_avg(self) -> float:
        """Average solar Flux (M10). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_m10_avg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @m10_avg.setter
    def m10_avg(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_m10_avg"](arg_inVal.COM_val))

    @property
    def s10(self) -> float:
        """Solar Flux (S10). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_s10"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @s10.setter
    def s10(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_s10"](arg_inVal.COM_val))

    @property
    def s10_avg(self) -> float:
        """Average solar Flux (S10). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_s10_avg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @s10_avg.setter
    def s10_avg(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_s10_avg"](arg_inVal.COM_val))

    @property
    def y10(self) -> float:
        """Solar Flux (Y10). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_y10"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @y10.setter
    def y10(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_y10"](arg_inVal.COM_val))

    @property
    def y10_avg(self) -> float:
        """Average solar Flux (Y10). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_y10_avg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @y10_avg.setter
    def y10_avg(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_y10_avg"](arg_inVal.COM_val))

    @property
    def dst_d_tc(self) -> float:
        """Temperature change calculated from disturbance storm time (DstDTc). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_dst_d_tc"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @dst_d_tc.setter
    def dst_d_tc(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_dst_d_tc"](arg_inVal.COM_val))

    @property
    def atmos_aug_data_file(self) -> str:
        """The atmospheric model space weather data file path."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_aug_data_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_aug_data_file.setter
    def atmos_aug_data_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_aug_data_file"](arg_inVal.COM_val))

    @property
    def atmos_aug_dtc_file(self) -> str:
        """The atmospheric model DTC file path."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_aug_dtc_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_aug_dtc_file.setter
    def atmos_aug_dtc_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_aug_dtc_file"](arg_inVal.COM_val))

    @property
    def drag_model_type(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_type.setter
    def drag_model_type(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_type"](arg_inVal.COM_val))

    @property
    def drag_model_plugin_name(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_plugin_name.setter
    def drag_model_plugin_name(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_plugin_name"](arg_pVal.COM_val))

    @property
    def drag_model_plugin(self) -> "IDragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def variable_area_history_file(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_variable_area_history_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @variable_area_history_file.setter
    def variable_area_history_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_variable_area_history_file"](arg_inVal.COM_val))

    @property
    def n_plate_definition_file(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_n_plate_definition_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @n_plate_definition_file.setter
    def n_plate_definition_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_n_plate_definition_file"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{49B828F8-A541-4E9E-99DD-DF3708B3559F}", IJacchiaBowman2008)
agcls.AgTypeNameMap["IJacchiaBowman2008"] = IJacchiaBowman2008

class IJacchia_1960(object):
    """Properties for the Jacchia 1960 atmospheric model - an outdated atmospheric model provided for making comparisons with other software."""
    _uuid = "{B32376D4-28EE-4D16-820F-A3A553103168}"
    _num_methods = 15
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_computes_temperature"] = _raise_uninitialized_error
        self.__dict__["_get_computes_pressure"] = _raise_uninitialized_error
        self.__dict__["_get_sun_position"] = _raise_uninitialized_error
        self.__dict__["_set_sun_position"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin"] = _raise_uninitialized_error
        self.__dict__["_get_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_set_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_get_n_plate_definition_file"] = _raise_uninitialized_error
        self.__dict__["_set_n_plate_definition_file"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IJacchia_1960._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IJacchia_1960 from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IJacchia_1960 = agcom.GUID(IJacchia_1960._uuid)
        vtable_offset_local = IJacchia_1960._vtable_offset - 1
        self.__dict__["_get_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1960, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1960, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_computes_temperature"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1960, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_computes_pressure"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1960, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_sun_position"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1960, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_sun_position"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1960, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1960, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1960, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1960, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_set_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1960, vtable_offset_local+10, agcom.BSTR)
        self.__dict__["_get_drag_model_plugin"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1960, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_get_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1960, vtable_offset_local+12, POINTER(agcom.BSTR))
        self.__dict__["_set_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1960, vtable_offset_local+13, agcom.BSTR)
        self.__dict__["_get_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1960, vtable_offset_local+14, POINTER(agcom.BSTR))
        self.__dict__["_set_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1960, vtable_offset_local+15, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IJacchia_1960.__dict__ and type(IJacchia_1960.__dict__[attrname]) == property:
            return IJacchia_1960.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IJacchia_1960.")
    
    @property
    def use_approximate_altitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_approximate_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_approximate_altitude.setter
    def use_approximate_altitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_approximate_altitude"](arg_inVal.COM_val))

    @property
    def computes_temperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_temperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def computes_pressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_pressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def sun_position(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sun_position"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sun_position.setter
    def sun_position(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_sun_position"](arg_inVal.COM_val))

    @property
    def drag_model_type(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_type.setter
    def drag_model_type(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_type"](arg_inVal.COM_val))

    @property
    def drag_model_plugin_name(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_plugin_name.setter
    def drag_model_plugin_name(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_plugin_name"](arg_pVal.COM_val))

    @property
    def drag_model_plugin(self) -> "IDragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def variable_area_history_file(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_variable_area_history_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @variable_area_history_file.setter
    def variable_area_history_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_variable_area_history_file"](arg_inVal.COM_val))

    @property
    def n_plate_definition_file(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_n_plate_definition_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @n_plate_definition_file.setter
    def n_plate_definition_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_n_plate_definition_file"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{B32376D4-28EE-4D16-820F-A3A553103168}", IJacchia_1960)
agcls.AgTypeNameMap["IJacchia_1960"] = IJacchia_1960

class IJacchia_1970(object):
    """Properties for the Jacchia 1970 atmospheric model - a model that computes atmospheric density based on the composition of the atmosphere, which depends on altitude as well as seasonal variation. Valid range is 100-2500 km."""
    _uuid = "{7308B6EE-F3DF-4B83-A9FB-F750AAE436F5}"
    _num_methods = 29
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_computes_temperature"] = _raise_uninitialized_error
        self.__dict__["_get_computes_pressure"] = _raise_uninitialized_error
        self.__dict__["_get_sun_position"] = _raise_uninitialized_error
        self.__dict__["_set_sun_position"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_source"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_source"] = _raise_uninitialized_error
        self.__dict__["_get_f_10_p7"] = _raise_uninitialized_error
        self.__dict__["_set_f_10_p7"] = _raise_uninitialized_error
        self.__dict__["_get_f_10_p7_avg"] = _raise_uninitialized_error
        self.__dict__["_set_f_10_p7_avg"] = _raise_uninitialized_error
        self.__dict__["_get_kp"] = _raise_uninitialized_error
        self.__dict__["_set_kp"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_geo_magnetic_flux_source"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_geo_magnetic_flux_source"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_geo_magnetic_flux_update_rate"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_geo_magnetic_flux_update_rate"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_filename"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_filename"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin"] = _raise_uninitialized_error
        self.__dict__["_get_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_set_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_get_n_plate_definition_file"] = _raise_uninitialized_error
        self.__dict__["_set_n_plate_definition_file"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IJacchia_1970._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IJacchia_1970 from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IJacchia_1970 = agcom.GUID(IJacchia_1970._uuid)
        vtable_offset_local = IJacchia_1970._vtable_offset - 1
        self.__dict__["_get_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1970, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1970, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_computes_temperature"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1970, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_computes_pressure"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1970, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_sun_position"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1970, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_sun_position"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1970, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_atmos_data_source"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1970, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_atmos_data_source"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1970, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_f_10_p7"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1970, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_f_10_p7"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1970, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_f_10_p7_avg"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1970, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_f_10_p7_avg"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1970, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_kp"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1970, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_kp"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1970, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_atmos_data_geo_magnetic_flux_source"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1970, vtable_offset_local+15, POINTER(agcom.LONG))
        self.__dict__["_set_atmos_data_geo_magnetic_flux_source"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1970, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_get_atmos_data_geo_magnetic_flux_update_rate"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1970, vtable_offset_local+17, POINTER(agcom.LONG))
        self.__dict__["_set_atmos_data_geo_magnetic_flux_update_rate"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1970, vtable_offset_local+18, agcom.LONG)
        self.__dict__["_get_atmos_data_filename"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1970, vtable_offset_local+19, POINTER(agcom.BSTR))
        self.__dict__["_set_atmos_data_filename"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1970, vtable_offset_local+20, agcom.BSTR)
        self.__dict__["_get_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1970, vtable_offset_local+21, POINTER(agcom.LONG))
        self.__dict__["_set_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1970, vtable_offset_local+22, agcom.LONG)
        self.__dict__["_get_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1970, vtable_offset_local+23, POINTER(agcom.BSTR))
        self.__dict__["_set_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1970, vtable_offset_local+24, agcom.BSTR)
        self.__dict__["_get_drag_model_plugin"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1970, vtable_offset_local+25, POINTER(agcom.PVOID))
        self.__dict__["_get_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1970, vtable_offset_local+26, POINTER(agcom.BSTR))
        self.__dict__["_set_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1970, vtable_offset_local+27, agcom.BSTR)
        self.__dict__["_get_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1970, vtable_offset_local+28, POINTER(agcom.BSTR))
        self.__dict__["_set_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1970, vtable_offset_local+29, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IJacchia_1970.__dict__ and type(IJacchia_1970.__dict__[attrname]) == property:
            return IJacchia_1970.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IJacchia_1970.")
    
    @property
    def use_approximate_altitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_approximate_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_approximate_altitude.setter
    def use_approximate_altitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_approximate_altitude"](arg_inVal.COM_val))

    @property
    def computes_temperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_temperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def computes_pressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_pressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def sun_position(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sun_position"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sun_position.setter
    def sun_position(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_sun_position"](arg_inVal.COM_val))

    @property
    def atmos_data_source(self) -> "AgEVAAtmosDataSource":
        """The atmospheric model data source - data file or constant values."""
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_source.setter
    def atmos_data_source(self, inVal:"AgEVAAtmosDataSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_source"](arg_inVal.COM_val))

    @property
    def f_10_p7(self) -> float:
        """Solar Flux (F10.7); the daily Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_f_10_p7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @f_10_p7.setter
    def f_10_p7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_f_10_p7"](arg_inVal.COM_val))

    @property
    def f_10_p7_avg(self) -> float:
        """Average solar Flux (F10.7); the 81-day averaged Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_f_10_p7_avg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @f_10_p7_avg.setter
    def f_10_p7_avg(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_f_10_p7_avg"](arg_inVal.COM_val))

    @property
    def kp(self) -> float:
        """Geomagnetic Index (Kp). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_kp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @kp.setter
    def kp(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_kp"](arg_inVal.COM_val))

    @property
    def atmos_data_geo_magnetic_flux_source(self) -> "AgEVAGeoMagneticFluxSource":
        """Whether to use Kp or Ap data from the flux file"""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_geo_magnetic_flux_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_geo_magnetic_flux_source.setter
    def atmos_data_geo_magnetic_flux_source(self, inVal:"AgEVAGeoMagneticFluxSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_geo_magnetic_flux_source"](arg_inVal.COM_val))

    @property
    def atmos_data_geo_magnetic_flux_update_rate(self) -> "AgEVAGeoMagneticFluxUpdateRate":
        """The update rate for geomagnetic flux values from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_geo_magnetic_flux_update_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_geo_magnetic_flux_update_rate.setter
    def atmos_data_geo_magnetic_flux_update_rate(self, inVal:"AgEVAGeoMagneticFluxUpdateRate") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_geo_magnetic_flux_update_rate"](arg_inVal.COM_val))

    @property
    def atmos_data_filename(self) -> str:
        """The atmospheric model data file path."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_filename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_filename.setter
    def atmos_data_filename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_filename"](arg_inVal.COM_val))

    @property
    def drag_model_type(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_type.setter
    def drag_model_type(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_type"](arg_inVal.COM_val))

    @property
    def drag_model_plugin_name(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_plugin_name.setter
    def drag_model_plugin_name(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_plugin_name"](arg_pVal.COM_val))

    @property
    def drag_model_plugin(self) -> "IDragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def variable_area_history_file(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_variable_area_history_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @variable_area_history_file.setter
    def variable_area_history_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_variable_area_history_file"](arg_inVal.COM_val))

    @property
    def n_plate_definition_file(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_n_plate_definition_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @n_plate_definition_file.setter
    def n_plate_definition_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_n_plate_definition_file"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{7308B6EE-F3DF-4B83-A9FB-F750AAE436F5}", IJacchia_1970)
agcls.AgTypeNameMap["IJacchia_1970"] = IJacchia_1970

class IJacchia_1971(object):
    """Properties for the Jacchia 1971 atmospheric model - a model that is similar to Jacchia 1970, with improved treatment of certain solar effects."""
    _uuid = "{36089BD6-3BB0-4B0F-B8D8-81F6492E3309}"
    _num_methods = 29
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_computes_temperature"] = _raise_uninitialized_error
        self.__dict__["_get_computes_pressure"] = _raise_uninitialized_error
        self.__dict__["_get_sun_position"] = _raise_uninitialized_error
        self.__dict__["_set_sun_position"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_source"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_source"] = _raise_uninitialized_error
        self.__dict__["_get_f_10_p7"] = _raise_uninitialized_error
        self.__dict__["_set_f_10_p7"] = _raise_uninitialized_error
        self.__dict__["_get_f_10_p7_avg"] = _raise_uninitialized_error
        self.__dict__["_set_f_10_p7_avg"] = _raise_uninitialized_error
        self.__dict__["_get_kp"] = _raise_uninitialized_error
        self.__dict__["_set_kp"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_geo_magnetic_flux_source"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_geo_magnetic_flux_source"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_geo_magnetic_flux_update_rate"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_geo_magnetic_flux_update_rate"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_filename"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_filename"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin"] = _raise_uninitialized_error
        self.__dict__["_get_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_set_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_get_n_plate_definition_file"] = _raise_uninitialized_error
        self.__dict__["_set_n_plate_definition_file"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IJacchia_1971._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IJacchia_1971 from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IJacchia_1971 = agcom.GUID(IJacchia_1971._uuid)
        vtable_offset_local = IJacchia_1971._vtable_offset - 1
        self.__dict__["_get_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1971, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1971, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_computes_temperature"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1971, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_computes_pressure"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1971, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_sun_position"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1971, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_sun_position"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1971, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_atmos_data_source"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1971, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_atmos_data_source"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1971, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_f_10_p7"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1971, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_f_10_p7"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1971, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_f_10_p7_avg"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1971, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_f_10_p7_avg"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1971, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_kp"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1971, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_kp"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1971, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_atmos_data_geo_magnetic_flux_source"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1971, vtable_offset_local+15, POINTER(agcom.LONG))
        self.__dict__["_set_atmos_data_geo_magnetic_flux_source"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1971, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_get_atmos_data_geo_magnetic_flux_update_rate"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1971, vtable_offset_local+17, POINTER(agcom.LONG))
        self.__dict__["_set_atmos_data_geo_magnetic_flux_update_rate"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1971, vtable_offset_local+18, agcom.LONG)
        self.__dict__["_get_atmos_data_filename"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1971, vtable_offset_local+19, POINTER(agcom.BSTR))
        self.__dict__["_set_atmos_data_filename"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1971, vtable_offset_local+20, agcom.BSTR)
        self.__dict__["_get_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1971, vtable_offset_local+21, POINTER(agcom.LONG))
        self.__dict__["_set_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1971, vtable_offset_local+22, agcom.LONG)
        self.__dict__["_get_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1971, vtable_offset_local+23, POINTER(agcom.BSTR))
        self.__dict__["_set_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1971, vtable_offset_local+24, agcom.BSTR)
        self.__dict__["_get_drag_model_plugin"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1971, vtable_offset_local+25, POINTER(agcom.PVOID))
        self.__dict__["_get_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1971, vtable_offset_local+26, POINTER(agcom.BSTR))
        self.__dict__["_set_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1971, vtable_offset_local+27, agcom.BSTR)
        self.__dict__["_get_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1971, vtable_offset_local+28, POINTER(agcom.BSTR))
        self.__dict__["_set_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IJacchia_1971, vtable_offset_local+29, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IJacchia_1971.__dict__ and type(IJacchia_1971.__dict__[attrname]) == property:
            return IJacchia_1971.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IJacchia_1971.")
    
    @property
    def use_approximate_altitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_approximate_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_approximate_altitude.setter
    def use_approximate_altitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_approximate_altitude"](arg_inVal.COM_val))

    @property
    def computes_temperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_temperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def computes_pressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_pressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def sun_position(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sun_position"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sun_position.setter
    def sun_position(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_sun_position"](arg_inVal.COM_val))

    @property
    def atmos_data_source(self) -> "AgEVAAtmosDataSource":
        """The atmospheric model data source - data file or constant values."""
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_source.setter
    def atmos_data_source(self, inVal:"AgEVAAtmosDataSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_source"](arg_inVal.COM_val))

    @property
    def f_10_p7(self) -> float:
        """Solar Flux (F10.7); the daily Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_f_10_p7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @f_10_p7.setter
    def f_10_p7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_f_10_p7"](arg_inVal.COM_val))

    @property
    def f_10_p7_avg(self) -> float:
        """Average solar Flux (F10.7); the 81-day averaged Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_f_10_p7_avg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @f_10_p7_avg.setter
    def f_10_p7_avg(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_f_10_p7_avg"](arg_inVal.COM_val))

    @property
    def kp(self) -> float:
        """Geomagnetic Index (Kp). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_kp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @kp.setter
    def kp(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_kp"](arg_inVal.COM_val))

    @property
    def atmos_data_geo_magnetic_flux_source(self) -> "AgEVAGeoMagneticFluxSource":
        """Whether to use Kp or Ap data from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_geo_magnetic_flux_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_geo_magnetic_flux_source.setter
    def atmos_data_geo_magnetic_flux_source(self, inVal:"AgEVAGeoMagneticFluxSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_geo_magnetic_flux_source"](arg_inVal.COM_val))

    @property
    def atmos_data_geo_magnetic_flux_update_rate(self) -> "AgEVAGeoMagneticFluxUpdateRate":
        """The update rate for geomagnetic flux values from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_geo_magnetic_flux_update_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_geo_magnetic_flux_update_rate.setter
    def atmos_data_geo_magnetic_flux_update_rate(self, inVal:"AgEVAGeoMagneticFluxUpdateRate") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_geo_magnetic_flux_update_rate"](arg_inVal.COM_val))

    @property
    def atmos_data_filename(self) -> str:
        """The atmospheric model data file path."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_filename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_filename.setter
    def atmos_data_filename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_filename"](arg_inVal.COM_val))

    @property
    def drag_model_type(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_type.setter
    def drag_model_type(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_type"](arg_inVal.COM_val))

    @property
    def drag_model_plugin_name(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_plugin_name.setter
    def drag_model_plugin_name(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_plugin_name"](arg_pVal.COM_val))

    @property
    def drag_model_plugin(self) -> "IDragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def variable_area_history_file(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_variable_area_history_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @variable_area_history_file.setter
    def variable_area_history_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_variable_area_history_file"](arg_inVal.COM_val))

    @property
    def n_plate_definition_file(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_n_plate_definition_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @n_plate_definition_file.setter
    def n_plate_definition_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_n_plate_definition_file"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{36089BD6-3BB0-4B0F-B8D8-81F6492E3309}", IJacchia_1971)
agcls.AgTypeNameMap["IJacchia_1971"] = IJacchia_1971

class IMSISE_1990(object):
    """Properties for the MSISE 1990 atmospheric model - an empirical density model developed by Hedin based on satellite data. Finds the total density by accounting for the contribution of N2, O, O2, He, Ar and H. 1990 version, valid range of 0-1000 km."""
    _uuid = "{C6AE62A3-103D-4E39-9F25-6AD5CCFF9530}"
    _num_methods = 29
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_computes_temperature"] = _raise_uninitialized_error
        self.__dict__["_get_computes_pressure"] = _raise_uninitialized_error
        self.__dict__["_get_sun_position"] = _raise_uninitialized_error
        self.__dict__["_set_sun_position"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_source"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_source"] = _raise_uninitialized_error
        self.__dict__["_get_f_10_p7"] = _raise_uninitialized_error
        self.__dict__["_set_f_10_p7"] = _raise_uninitialized_error
        self.__dict__["_get_f_10_p7_avg"] = _raise_uninitialized_error
        self.__dict__["_set_f_10_p7_avg"] = _raise_uninitialized_error
        self.__dict__["_get_kp"] = _raise_uninitialized_error
        self.__dict__["_set_kp"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_geo_magnetic_flux_source"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_geo_magnetic_flux_source"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_geo_magnetic_flux_update_rate"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_geo_magnetic_flux_update_rate"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_filename"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_filename"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin"] = _raise_uninitialized_error
        self.__dict__["_get_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_set_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_get_n_plate_definition_file"] = _raise_uninitialized_error
        self.__dict__["_set_n_plate_definition_file"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMSISE_1990._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMSISE_1990 from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMSISE_1990 = agcom.GUID(IMSISE_1990._uuid)
        vtable_offset_local = IMSISE_1990._vtable_offset - 1
        self.__dict__["_get_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IMSISE_1990, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IMSISE_1990, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_computes_temperature"] = IAGFUNCTYPE(pUnk, IID_IMSISE_1990, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_computes_pressure"] = IAGFUNCTYPE(pUnk, IID_IMSISE_1990, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_sun_position"] = IAGFUNCTYPE(pUnk, IID_IMSISE_1990, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_sun_position"] = IAGFUNCTYPE(pUnk, IID_IMSISE_1990, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_atmos_data_source"] = IAGFUNCTYPE(pUnk, IID_IMSISE_1990, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_atmos_data_source"] = IAGFUNCTYPE(pUnk, IID_IMSISE_1990, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_f_10_p7"] = IAGFUNCTYPE(pUnk, IID_IMSISE_1990, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_f_10_p7"] = IAGFUNCTYPE(pUnk, IID_IMSISE_1990, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_f_10_p7_avg"] = IAGFUNCTYPE(pUnk, IID_IMSISE_1990, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_f_10_p7_avg"] = IAGFUNCTYPE(pUnk, IID_IMSISE_1990, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_kp"] = IAGFUNCTYPE(pUnk, IID_IMSISE_1990, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_kp"] = IAGFUNCTYPE(pUnk, IID_IMSISE_1990, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_atmos_data_geo_magnetic_flux_source"] = IAGFUNCTYPE(pUnk, IID_IMSISE_1990, vtable_offset_local+15, POINTER(agcom.LONG))
        self.__dict__["_set_atmos_data_geo_magnetic_flux_source"] = IAGFUNCTYPE(pUnk, IID_IMSISE_1990, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_get_atmos_data_geo_magnetic_flux_update_rate"] = IAGFUNCTYPE(pUnk, IID_IMSISE_1990, vtable_offset_local+17, POINTER(agcom.LONG))
        self.__dict__["_set_atmos_data_geo_magnetic_flux_update_rate"] = IAGFUNCTYPE(pUnk, IID_IMSISE_1990, vtable_offset_local+18, agcom.LONG)
        self.__dict__["_get_atmos_data_filename"] = IAGFUNCTYPE(pUnk, IID_IMSISE_1990, vtable_offset_local+19, POINTER(agcom.BSTR))
        self.__dict__["_set_atmos_data_filename"] = IAGFUNCTYPE(pUnk, IID_IMSISE_1990, vtable_offset_local+20, agcom.BSTR)
        self.__dict__["_get_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IMSISE_1990, vtable_offset_local+21, POINTER(agcom.LONG))
        self.__dict__["_set_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IMSISE_1990, vtable_offset_local+22, agcom.LONG)
        self.__dict__["_get_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IMSISE_1990, vtable_offset_local+23, POINTER(agcom.BSTR))
        self.__dict__["_set_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IMSISE_1990, vtable_offset_local+24, agcom.BSTR)
        self.__dict__["_get_drag_model_plugin"] = IAGFUNCTYPE(pUnk, IID_IMSISE_1990, vtable_offset_local+25, POINTER(agcom.PVOID))
        self.__dict__["_get_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IMSISE_1990, vtable_offset_local+26, POINTER(agcom.BSTR))
        self.__dict__["_set_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IMSISE_1990, vtable_offset_local+27, agcom.BSTR)
        self.__dict__["_get_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IMSISE_1990, vtable_offset_local+28, POINTER(agcom.BSTR))
        self.__dict__["_set_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IMSISE_1990, vtable_offset_local+29, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMSISE_1990.__dict__ and type(IMSISE_1990.__dict__[attrname]) == property:
            return IMSISE_1990.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMSISE_1990.")
    
    @property
    def use_approximate_altitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_approximate_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_approximate_altitude.setter
    def use_approximate_altitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_approximate_altitude"](arg_inVal.COM_val))

    @property
    def computes_temperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_temperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def computes_pressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_pressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def sun_position(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sun_position"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sun_position.setter
    def sun_position(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_sun_position"](arg_inVal.COM_val))

    @property
    def atmos_data_source(self) -> "AgEVAAtmosDataSource":
        """The atmospheric model data source - data file or constant values."""
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_source.setter
    def atmos_data_source(self, inVal:"AgEVAAtmosDataSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_source"](arg_inVal.COM_val))

    @property
    def f_10_p7(self) -> float:
        """Solar Flux (F10.7); the daily Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_f_10_p7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @f_10_p7.setter
    def f_10_p7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_f_10_p7"](arg_inVal.COM_val))

    @property
    def f_10_p7_avg(self) -> float:
        """Average solar Flux (F10.7); the 81-day averaged Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_f_10_p7_avg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @f_10_p7_avg.setter
    def f_10_p7_avg(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_f_10_p7_avg"](arg_inVal.COM_val))

    @property
    def kp(self) -> float:
        """Geomagnetic Index (Kp). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_kp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @kp.setter
    def kp(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_kp"](arg_inVal.COM_val))

    @property
    def atmos_data_geo_magnetic_flux_source(self) -> "AgEVAGeoMagneticFluxSource":
        """Whether to use Kp or Ap data from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_geo_magnetic_flux_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_geo_magnetic_flux_source.setter
    def atmos_data_geo_magnetic_flux_source(self, inVal:"AgEVAGeoMagneticFluxSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_geo_magnetic_flux_source"](arg_inVal.COM_val))

    @property
    def atmos_data_geo_magnetic_flux_update_rate(self) -> "AgEVAGeoMagneticFluxUpdateRate":
        """The update rate for geomagnetic flux values from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_geo_magnetic_flux_update_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_geo_magnetic_flux_update_rate.setter
    def atmos_data_geo_magnetic_flux_update_rate(self, inVal:"AgEVAGeoMagneticFluxUpdateRate") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_geo_magnetic_flux_update_rate"](arg_inVal.COM_val))

    @property
    def atmos_data_filename(self) -> str:
        """The atmospheric model data file path."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_filename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_filename.setter
    def atmos_data_filename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_filename"](arg_inVal.COM_val))

    @property
    def drag_model_type(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_type.setter
    def drag_model_type(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_type"](arg_inVal.COM_val))

    @property
    def drag_model_plugin_name(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_plugin_name.setter
    def drag_model_plugin_name(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_plugin_name"](arg_pVal.COM_val))

    @property
    def drag_model_plugin(self) -> "IDragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def variable_area_history_file(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_variable_area_history_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @variable_area_history_file.setter
    def variable_area_history_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_variable_area_history_file"](arg_inVal.COM_val))

    @property
    def n_plate_definition_file(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_n_plate_definition_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @n_plate_definition_file.setter
    def n_plate_definition_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_n_plate_definition_file"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{C6AE62A3-103D-4E39-9F25-6AD5CCFF9530}", IMSISE_1990)
agcls.AgTypeNameMap["IMSISE_1990"] = IMSISE_1990

class IMSIS_1986(object):
    """Properties for the MSIS 1986 atmospheric model - an empirical density model developed by Hedin based on satellite data. Finds the total density by accounting for the contribution of N2, O, O2, He, Ar and H. 1986 version, valid range of 90-1000 km."""
    _uuid = "{F7608E83-8539-4B2E-B0DB-F4F1010DDDED}"
    _num_methods = 29
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_computes_temperature"] = _raise_uninitialized_error
        self.__dict__["_get_computes_pressure"] = _raise_uninitialized_error
        self.__dict__["_get_sun_position"] = _raise_uninitialized_error
        self.__dict__["_set_sun_position"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_source"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_source"] = _raise_uninitialized_error
        self.__dict__["_get_f_10_p7"] = _raise_uninitialized_error
        self.__dict__["_set_f_10_p7"] = _raise_uninitialized_error
        self.__dict__["_get_f_10_p7_avg"] = _raise_uninitialized_error
        self.__dict__["_set_f_10_p7_avg"] = _raise_uninitialized_error
        self.__dict__["_get_kp"] = _raise_uninitialized_error
        self.__dict__["_set_kp"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_geo_magnetic_flux_source"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_geo_magnetic_flux_source"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_geo_magnetic_flux_update_rate"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_geo_magnetic_flux_update_rate"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_filename"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_filename"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin"] = _raise_uninitialized_error
        self.__dict__["_get_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_set_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_get_n_plate_definition_file"] = _raise_uninitialized_error
        self.__dict__["_set_n_plate_definition_file"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMSIS_1986._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMSIS_1986 from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMSIS_1986 = agcom.GUID(IMSIS_1986._uuid)
        vtable_offset_local = IMSIS_1986._vtable_offset - 1
        self.__dict__["_get_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IMSIS_1986, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IMSIS_1986, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_computes_temperature"] = IAGFUNCTYPE(pUnk, IID_IMSIS_1986, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_computes_pressure"] = IAGFUNCTYPE(pUnk, IID_IMSIS_1986, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_sun_position"] = IAGFUNCTYPE(pUnk, IID_IMSIS_1986, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_sun_position"] = IAGFUNCTYPE(pUnk, IID_IMSIS_1986, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_atmos_data_source"] = IAGFUNCTYPE(pUnk, IID_IMSIS_1986, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_atmos_data_source"] = IAGFUNCTYPE(pUnk, IID_IMSIS_1986, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_f_10_p7"] = IAGFUNCTYPE(pUnk, IID_IMSIS_1986, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_f_10_p7"] = IAGFUNCTYPE(pUnk, IID_IMSIS_1986, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_f_10_p7_avg"] = IAGFUNCTYPE(pUnk, IID_IMSIS_1986, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_f_10_p7_avg"] = IAGFUNCTYPE(pUnk, IID_IMSIS_1986, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_kp"] = IAGFUNCTYPE(pUnk, IID_IMSIS_1986, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_kp"] = IAGFUNCTYPE(pUnk, IID_IMSIS_1986, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_atmos_data_geo_magnetic_flux_source"] = IAGFUNCTYPE(pUnk, IID_IMSIS_1986, vtable_offset_local+15, POINTER(agcom.LONG))
        self.__dict__["_set_atmos_data_geo_magnetic_flux_source"] = IAGFUNCTYPE(pUnk, IID_IMSIS_1986, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_get_atmos_data_geo_magnetic_flux_update_rate"] = IAGFUNCTYPE(pUnk, IID_IMSIS_1986, vtable_offset_local+17, POINTER(agcom.LONG))
        self.__dict__["_set_atmos_data_geo_magnetic_flux_update_rate"] = IAGFUNCTYPE(pUnk, IID_IMSIS_1986, vtable_offset_local+18, agcom.LONG)
        self.__dict__["_get_atmos_data_filename"] = IAGFUNCTYPE(pUnk, IID_IMSIS_1986, vtable_offset_local+19, POINTER(agcom.BSTR))
        self.__dict__["_set_atmos_data_filename"] = IAGFUNCTYPE(pUnk, IID_IMSIS_1986, vtable_offset_local+20, agcom.BSTR)
        self.__dict__["_get_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IMSIS_1986, vtable_offset_local+21, POINTER(agcom.LONG))
        self.__dict__["_set_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IMSIS_1986, vtable_offset_local+22, agcom.LONG)
        self.__dict__["_get_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IMSIS_1986, vtable_offset_local+23, POINTER(agcom.BSTR))
        self.__dict__["_set_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IMSIS_1986, vtable_offset_local+24, agcom.BSTR)
        self.__dict__["_get_drag_model_plugin"] = IAGFUNCTYPE(pUnk, IID_IMSIS_1986, vtable_offset_local+25, POINTER(agcom.PVOID))
        self.__dict__["_get_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IMSIS_1986, vtable_offset_local+26, POINTER(agcom.BSTR))
        self.__dict__["_set_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IMSIS_1986, vtable_offset_local+27, agcom.BSTR)
        self.__dict__["_get_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IMSIS_1986, vtable_offset_local+28, POINTER(agcom.BSTR))
        self.__dict__["_set_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IMSIS_1986, vtable_offset_local+29, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMSIS_1986.__dict__ and type(IMSIS_1986.__dict__[attrname]) == property:
            return IMSIS_1986.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMSIS_1986.")
    
    @property
    def use_approximate_altitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_approximate_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_approximate_altitude.setter
    def use_approximate_altitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_approximate_altitude"](arg_inVal.COM_val))

    @property
    def computes_temperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_temperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def computes_pressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_pressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def sun_position(self) -> "AgEVASunPosition":
        """The sun position computation"""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sun_position"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sun_position.setter
    def sun_position(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_sun_position"](arg_inVal.COM_val))

    @property
    def atmos_data_source(self) -> "AgEVAAtmosDataSource":
        """The atmospheric model data source - data file or constant values."""
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_source.setter
    def atmos_data_source(self, inVal:"AgEVAAtmosDataSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_source"](arg_inVal.COM_val))

    @property
    def f_10_p7(self) -> float:
        """Solar Flux (F10.7); the daily Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_f_10_p7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @f_10_p7.setter
    def f_10_p7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_f_10_p7"](arg_inVal.COM_val))

    @property
    def f_10_p7_avg(self) -> float:
        """Average solar Flux (F10.7); the 81-day averaged Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_f_10_p7_avg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @f_10_p7_avg.setter
    def f_10_p7_avg(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_f_10_p7_avg"](arg_inVal.COM_val))

    @property
    def kp(self) -> float:
        """Geomagnetic Index (Kp). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_kp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @kp.setter
    def kp(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_kp"](arg_inVal.COM_val))

    @property
    def atmos_data_geo_magnetic_flux_source(self) -> "AgEVAGeoMagneticFluxSource":
        """Whether to use Kp or Ap data from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_geo_magnetic_flux_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_geo_magnetic_flux_source.setter
    def atmos_data_geo_magnetic_flux_source(self, inVal:"AgEVAGeoMagneticFluxSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_geo_magnetic_flux_source"](arg_inVal.COM_val))

    @property
    def atmos_data_geo_magnetic_flux_update_rate(self) -> "AgEVAGeoMagneticFluxUpdateRate":
        """The update rate for geomagnetic flux values from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_geo_magnetic_flux_update_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_geo_magnetic_flux_update_rate.setter
    def atmos_data_geo_magnetic_flux_update_rate(self, inVal:"AgEVAGeoMagneticFluxUpdateRate") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_geo_magnetic_flux_update_rate"](arg_inVal.COM_val))

    @property
    def atmos_data_filename(self) -> str:
        """The atmospheric model data file path."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_filename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_filename.setter
    def atmos_data_filename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_filename"](arg_inVal.COM_val))

    @property
    def drag_model_type(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_type.setter
    def drag_model_type(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_type"](arg_inVal.COM_val))

    @property
    def drag_model_plugin_name(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_plugin_name.setter
    def drag_model_plugin_name(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_plugin_name"](arg_pVal.COM_val))

    @property
    def drag_model_plugin(self) -> "IDragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def variable_area_history_file(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_variable_area_history_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @variable_area_history_file.setter
    def variable_area_history_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_variable_area_history_file"](arg_inVal.COM_val))

    @property
    def n_plate_definition_file(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_n_plate_definition_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @n_plate_definition_file.setter
    def n_plate_definition_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_n_plate_definition_file"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{F7608E83-8539-4B2E-B0DB-F4F1010DDDED}", IMSIS_1986)
agcls.AgTypeNameMap["IMSIS_1986"] = IMSIS_1986

class INRLMSISE_2000(object):
    """Properties for the NRLMSISE 2000 atmospheric model."""
    _uuid = "{A2CAC8B0-74EF-4067-9B76-9B2D6938303D}"
    _num_methods = 29
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_computes_temperature"] = _raise_uninitialized_error
        self.__dict__["_get_computes_pressure"] = _raise_uninitialized_error
        self.__dict__["_get_sun_position"] = _raise_uninitialized_error
        self.__dict__["_set_sun_position"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_source"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_source"] = _raise_uninitialized_error
        self.__dict__["_get_f_10_p7"] = _raise_uninitialized_error
        self.__dict__["_set_f_10_p7"] = _raise_uninitialized_error
        self.__dict__["_get_f_10_p7_avg"] = _raise_uninitialized_error
        self.__dict__["_set_f_10_p7_avg"] = _raise_uninitialized_error
        self.__dict__["_get_kp"] = _raise_uninitialized_error
        self.__dict__["_set_kp"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_geo_magnetic_flux_source"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_geo_magnetic_flux_source"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_geo_magnetic_flux_update_rate"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_geo_magnetic_flux_update_rate"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_filename"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_filename"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin"] = _raise_uninitialized_error
        self.__dict__["_get_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_set_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_get_n_plate_definition_file"] = _raise_uninitialized_error
        self.__dict__["_set_n_plate_definition_file"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(INRLMSISE_2000._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create INRLMSISE_2000 from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_INRLMSISE_2000 = agcom.GUID(INRLMSISE_2000._uuid)
        vtable_offset_local = INRLMSISE_2000._vtable_offset - 1
        self.__dict__["_get_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_INRLMSISE_2000, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_INRLMSISE_2000, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_computes_temperature"] = IAGFUNCTYPE(pUnk, IID_INRLMSISE_2000, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_computes_pressure"] = IAGFUNCTYPE(pUnk, IID_INRLMSISE_2000, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_sun_position"] = IAGFUNCTYPE(pUnk, IID_INRLMSISE_2000, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_sun_position"] = IAGFUNCTYPE(pUnk, IID_INRLMSISE_2000, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_atmos_data_source"] = IAGFUNCTYPE(pUnk, IID_INRLMSISE_2000, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_atmos_data_source"] = IAGFUNCTYPE(pUnk, IID_INRLMSISE_2000, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_f_10_p7"] = IAGFUNCTYPE(pUnk, IID_INRLMSISE_2000, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_f_10_p7"] = IAGFUNCTYPE(pUnk, IID_INRLMSISE_2000, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_f_10_p7_avg"] = IAGFUNCTYPE(pUnk, IID_INRLMSISE_2000, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_f_10_p7_avg"] = IAGFUNCTYPE(pUnk, IID_INRLMSISE_2000, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_kp"] = IAGFUNCTYPE(pUnk, IID_INRLMSISE_2000, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_kp"] = IAGFUNCTYPE(pUnk, IID_INRLMSISE_2000, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_atmos_data_geo_magnetic_flux_source"] = IAGFUNCTYPE(pUnk, IID_INRLMSISE_2000, vtable_offset_local+15, POINTER(agcom.LONG))
        self.__dict__["_set_atmos_data_geo_magnetic_flux_source"] = IAGFUNCTYPE(pUnk, IID_INRLMSISE_2000, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_get_atmos_data_geo_magnetic_flux_update_rate"] = IAGFUNCTYPE(pUnk, IID_INRLMSISE_2000, vtable_offset_local+17, POINTER(agcom.LONG))
        self.__dict__["_set_atmos_data_geo_magnetic_flux_update_rate"] = IAGFUNCTYPE(pUnk, IID_INRLMSISE_2000, vtable_offset_local+18, agcom.LONG)
        self.__dict__["_get_atmos_data_filename"] = IAGFUNCTYPE(pUnk, IID_INRLMSISE_2000, vtable_offset_local+19, POINTER(agcom.BSTR))
        self.__dict__["_set_atmos_data_filename"] = IAGFUNCTYPE(pUnk, IID_INRLMSISE_2000, vtable_offset_local+20, agcom.BSTR)
        self.__dict__["_get_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_INRLMSISE_2000, vtable_offset_local+21, POINTER(agcom.LONG))
        self.__dict__["_set_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_INRLMSISE_2000, vtable_offset_local+22, agcom.LONG)
        self.__dict__["_get_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_INRLMSISE_2000, vtable_offset_local+23, POINTER(agcom.BSTR))
        self.__dict__["_set_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_INRLMSISE_2000, vtable_offset_local+24, agcom.BSTR)
        self.__dict__["_get_drag_model_plugin"] = IAGFUNCTYPE(pUnk, IID_INRLMSISE_2000, vtable_offset_local+25, POINTER(agcom.PVOID))
        self.__dict__["_get_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_INRLMSISE_2000, vtable_offset_local+26, POINTER(agcom.BSTR))
        self.__dict__["_set_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_INRLMSISE_2000, vtable_offset_local+27, agcom.BSTR)
        self.__dict__["_get_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_INRLMSISE_2000, vtable_offset_local+28, POINTER(agcom.BSTR))
        self.__dict__["_set_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_INRLMSISE_2000, vtable_offset_local+29, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in INRLMSISE_2000.__dict__ and type(INRLMSISE_2000.__dict__[attrname]) == property:
            return INRLMSISE_2000.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in INRLMSISE_2000.")
    
    @property
    def use_approximate_altitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_approximate_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_approximate_altitude.setter
    def use_approximate_altitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_approximate_altitude"](arg_inVal.COM_val))

    @property
    def computes_temperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_temperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def computes_pressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_pressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def sun_position(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sun_position"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sun_position.setter
    def sun_position(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_sun_position"](arg_inVal.COM_val))

    @property
    def atmos_data_source(self) -> "AgEVAAtmosDataSource":
        """The atmospheric model data source - data file or constant values."""
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_source.setter
    def atmos_data_source(self, inVal:"AgEVAAtmosDataSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_source"](arg_inVal.COM_val))

    @property
    def f_10_p7(self) -> float:
        """Solar Flux (F10.7); the daily Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_f_10_p7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @f_10_p7.setter
    def f_10_p7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_f_10_p7"](arg_inVal.COM_val))

    @property
    def f_10_p7_avg(self) -> float:
        """Average solar Flux (F10.7); the 81-day averaged Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_f_10_p7_avg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @f_10_p7_avg.setter
    def f_10_p7_avg(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_f_10_p7_avg"](arg_inVal.COM_val))

    @property
    def kp(self) -> float:
        """Geomagnetic Index (Kp). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_kp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @kp.setter
    def kp(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_kp"](arg_inVal.COM_val))

    @property
    def atmos_data_geo_magnetic_flux_source(self) -> "AgEVAGeoMagneticFluxSource":
        """Whether to use Kp or Ap data from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_geo_magnetic_flux_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_geo_magnetic_flux_source.setter
    def atmos_data_geo_magnetic_flux_source(self, inVal:"AgEVAGeoMagneticFluxSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_geo_magnetic_flux_source"](arg_inVal.COM_val))

    @property
    def atmos_data_geo_magnetic_flux_update_rate(self) -> "AgEVAGeoMagneticFluxUpdateRate":
        """The update rate for geomagnetic flux values from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_geo_magnetic_flux_update_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_geo_magnetic_flux_update_rate.setter
    def atmos_data_geo_magnetic_flux_update_rate(self, inVal:"AgEVAGeoMagneticFluxUpdateRate") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_geo_magnetic_flux_update_rate"](arg_inVal.COM_val))

    @property
    def atmos_data_filename(self) -> str:
        """The atmospheric model data file path."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_filename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_filename.setter
    def atmos_data_filename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_filename"](arg_inVal.COM_val))

    @property
    def drag_model_type(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_type.setter
    def drag_model_type(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_type"](arg_inVal.COM_val))

    @property
    def drag_model_plugin_name(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_plugin_name.setter
    def drag_model_plugin_name(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_plugin_name"](arg_pVal.COM_val))

    @property
    def drag_model_plugin(self) -> "IDragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def variable_area_history_file(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_variable_area_history_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @variable_area_history_file.setter
    def variable_area_history_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_variable_area_history_file"](arg_inVal.COM_val))

    @property
    def n_plate_definition_file(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_n_plate_definition_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @n_plate_definition_file.setter
    def n_plate_definition_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_n_plate_definition_file"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{A2CAC8B0-74EF-4067-9B76-9B2D6938303D}", INRLMSISE_2000)
agcls.AgTypeNameMap["INRLMSISE_2000"] = INRLMSISE_2000

class IUS_Standard_Atmosphere(object):
    """Properties for the US Standard Atmosphere atmospheric model."""
    _uuid = "{C1E85F74-4770-4D1F-B2D9-0AE42AC245EA}"
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_computes_temperature"] = _raise_uninitialized_error
        self.__dict__["_get_computes_pressure"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin"] = _raise_uninitialized_error
        self.__dict__["_get_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_set_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_get_n_plate_definition_file"] = _raise_uninitialized_error
        self.__dict__["_set_n_plate_definition_file"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IUS_Standard_Atmosphere._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IUS_Standard_Atmosphere from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IUS_Standard_Atmosphere = agcom.GUID(IUS_Standard_Atmosphere._uuid)
        vtable_offset_local = IUS_Standard_Atmosphere._vtable_offset - 1
        self.__dict__["_get_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IUS_Standard_Atmosphere, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IUS_Standard_Atmosphere, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_computes_temperature"] = IAGFUNCTYPE(pUnk, IID_IUS_Standard_Atmosphere, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_computes_pressure"] = IAGFUNCTYPE(pUnk, IID_IUS_Standard_Atmosphere, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IUS_Standard_Atmosphere, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IUS_Standard_Atmosphere, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IUS_Standard_Atmosphere, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_set_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IUS_Standard_Atmosphere, vtable_offset_local+8, agcom.BSTR)
        self.__dict__["_get_drag_model_plugin"] = IAGFUNCTYPE(pUnk, IID_IUS_Standard_Atmosphere, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_get_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IUS_Standard_Atmosphere, vtable_offset_local+10, POINTER(agcom.BSTR))
        self.__dict__["_set_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IUS_Standard_Atmosphere, vtable_offset_local+11, agcom.BSTR)
        self.__dict__["_get_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IUS_Standard_Atmosphere, vtable_offset_local+12, POINTER(agcom.BSTR))
        self.__dict__["_set_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IUS_Standard_Atmosphere, vtable_offset_local+13, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IUS_Standard_Atmosphere.__dict__ and type(IUS_Standard_Atmosphere.__dict__[attrname]) == property:
            return IUS_Standard_Atmosphere.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IUS_Standard_Atmosphere.")
    
    @property
    def use_approximate_altitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_approximate_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_approximate_altitude.setter
    def use_approximate_altitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_approximate_altitude"](arg_inVal.COM_val))

    @property
    def computes_temperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_temperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def computes_pressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_pressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def drag_model_type(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_type.setter
    def drag_model_type(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_type"](arg_inVal.COM_val))

    @property
    def drag_model_plugin_name(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_plugin_name.setter
    def drag_model_plugin_name(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_plugin_name"](arg_pVal.COM_val))

    @property
    def drag_model_plugin(self) -> "IDragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def variable_area_history_file(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_variable_area_history_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @variable_area_history_file.setter
    def variable_area_history_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_variable_area_history_file"](arg_inVal.COM_val))

    @property
    def n_plate_definition_file(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_n_plate_definition_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @n_plate_definition_file.setter
    def n_plate_definition_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_n_plate_definition_file"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{C1E85F74-4770-4D1F-B2D9-0AE42AC245EA}", IUS_Standard_Atmosphere)
agcls.AgTypeNameMap["IUS_Standard_Atmosphere"] = IUS_Standard_Atmosphere

class IMarsGRAM37(object):
    """Properties for the Mars-GRAM 3.7 atmospheric model."""
    _uuid = "{2855777F-3062-4699-AB5D-2FE73D161472}"
    _num_methods = 27
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_computes_temperature"] = _raise_uninitialized_error
        self.__dict__["_get_computes_pressure"] = _raise_uninitialized_error
        self.__dict__["_get_sun_position"] = _raise_uninitialized_error
        self.__dict__["_set_sun_position"] = _raise_uninitialized_error
        self.__dict__["_get_data_directory"] = _raise_uninitialized_error
        self.__dict__["_set_data_directory"] = _raise_uninitialized_error
        self.__dict__["_get_namelist_file"] = _raise_uninitialized_error
        self.__dict__["_set_namelist_file"] = _raise_uninitialized_error
        self.__dict__["_get_density_type"] = _raise_uninitialized_error
        self.__dict__["_set_density_type"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_source"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_source"] = _raise_uninitialized_error
        self.__dict__["_get_f_10_p7"] = _raise_uninitialized_error
        self.__dict__["_set_f_10_p7"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_filename"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_filename"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin"] = _raise_uninitialized_error
        self.__dict__["_get_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_set_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_get_n_plate_definition_file"] = _raise_uninitialized_error
        self.__dict__["_set_n_plate_definition_file"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMarsGRAM37._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMarsGRAM37 from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMarsGRAM37 = agcom.GUID(IMarsGRAM37._uuid)
        vtable_offset_local = IMarsGRAM37._vtable_offset - 1
        self.__dict__["_get_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM37, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM37, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_computes_temperature"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM37, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_computes_pressure"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM37, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_sun_position"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM37, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_sun_position"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM37, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_data_directory"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM37, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_set_data_directory"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM37, vtable_offset_local+8, agcom.BSTR)
        self.__dict__["_get_namelist_file"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM37, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_set_namelist_file"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM37, vtable_offset_local+10, agcom.BSTR)
        self.__dict__["_get_density_type"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM37, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_set_density_type"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM37, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_get_atmos_data_source"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM37, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_set_atmos_data_source"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM37, vtable_offset_local+14, agcom.LONG)
        self.__dict__["_get_f_10_p7"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM37, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_f_10_p7"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM37, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_atmos_data_filename"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM37, vtable_offset_local+17, POINTER(agcom.BSTR))
        self.__dict__["_set_atmos_data_filename"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM37, vtable_offset_local+18, agcom.BSTR)
        self.__dict__["_get_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM37, vtable_offset_local+19, POINTER(agcom.LONG))
        self.__dict__["_set_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM37, vtable_offset_local+20, agcom.LONG)
        self.__dict__["_get_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM37, vtable_offset_local+21, POINTER(agcom.BSTR))
        self.__dict__["_set_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM37, vtable_offset_local+22, agcom.BSTR)
        self.__dict__["_get_drag_model_plugin"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM37, vtable_offset_local+23, POINTER(agcom.PVOID))
        self.__dict__["_get_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM37, vtable_offset_local+24, POINTER(agcom.BSTR))
        self.__dict__["_set_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM37, vtable_offset_local+25, agcom.BSTR)
        self.__dict__["_get_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM37, vtable_offset_local+26, POINTER(agcom.BSTR))
        self.__dict__["_set_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM37, vtable_offset_local+27, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMarsGRAM37.__dict__ and type(IMarsGRAM37.__dict__[attrname]) == property:
            return IMarsGRAM37.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMarsGRAM37.")
    
    @property
    def use_approximate_altitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_approximate_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_approximate_altitude.setter
    def use_approximate_altitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_approximate_altitude"](arg_inVal.COM_val))

    @property
    def computes_temperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_temperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def computes_pressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_pressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def sun_position(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sun_position"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sun_position.setter
    def sun_position(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_sun_position"](arg_inVal.COM_val))

    @property
    def data_directory(self) -> str:
        """Path to the data directory."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_data_directory"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @data_directory.setter
    def data_directory(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_data_directory"](arg_inVal.COM_val))

    @property
    def namelist_file(self) -> str:
        """Full path of namelist file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_namelist_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @namelist_file.setter
    def namelist_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_namelist_file"](arg_inVal.COM_val))

    @property
    def density_type(self) -> "AgEVAMarsGRAMDensityType":
        """Low, mean or high density type."""
        with agmarshall.AgEnum_arg(AgEVAMarsGRAMDensityType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_density_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @density_type.setter
    def density_type(self, inVal:"AgEVAMarsGRAMDensityType") -> None:
        with agmarshall.AgEnum_arg(AgEVAMarsGRAMDensityType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_density_type"](arg_inVal.COM_val))

    @property
    def atmos_data_source(self) -> "AgEVAAtmosDataSource":
        """The atmospheric model data source - data file or constant values."""
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_source.setter
    def atmos_data_source(self, inVal:"AgEVAAtmosDataSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_source"](arg_inVal.COM_val))

    @property
    def f_10_p7(self) -> float:
        """Solar Flux (F10.7); the daily Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_f_10_p7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @f_10_p7.setter
    def f_10_p7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_f_10_p7"](arg_inVal.COM_val))

    @property
    def atmos_data_filename(self) -> str:
        """The atmospheric model data file path."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_filename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_filename.setter
    def atmos_data_filename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_filename"](arg_inVal.COM_val))

    @property
    def drag_model_type(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_type.setter
    def drag_model_type(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_type"](arg_inVal.COM_val))

    @property
    def drag_model_plugin_name(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_plugin_name.setter
    def drag_model_plugin_name(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_plugin_name"](arg_pVal.COM_val))

    @property
    def drag_model_plugin(self) -> "IDragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def variable_area_history_file(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_variable_area_history_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @variable_area_history_file.setter
    def variable_area_history_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_variable_area_history_file"](arg_inVal.COM_val))

    @property
    def n_plate_definition_file(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_n_plate_definition_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @n_plate_definition_file.setter
    def n_plate_definition_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_n_plate_definition_file"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2855777F-3062-4699-AB5D-2FE73D161472}", IMarsGRAM37)
agcls.AgTypeNameMap["IMarsGRAM37"] = IMarsGRAM37

class IMarsGRAM2005(object):
    """Properties for the Mars-GRAM 2005 atmospheric model."""
    _uuid = "{E8649FED-5172-444A-9FC2-3B69586A8B91}"
    _num_methods = 27
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_computes_temperature"] = _raise_uninitialized_error
        self.__dict__["_get_computes_pressure"] = _raise_uninitialized_error
        self.__dict__["_get_sun_position"] = _raise_uninitialized_error
        self.__dict__["_set_sun_position"] = _raise_uninitialized_error
        self.__dict__["_get_data_directory"] = _raise_uninitialized_error
        self.__dict__["_set_data_directory"] = _raise_uninitialized_error
        self.__dict__["_get_namelist_file"] = _raise_uninitialized_error
        self.__dict__["_set_namelist_file"] = _raise_uninitialized_error
        self.__dict__["_get_density_type"] = _raise_uninitialized_error
        self.__dict__["_set_density_type"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_source"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_source"] = _raise_uninitialized_error
        self.__dict__["_get_f_10_p7"] = _raise_uninitialized_error
        self.__dict__["_set_f_10_p7"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_filename"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_filename"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin"] = _raise_uninitialized_error
        self.__dict__["_get_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_set_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_get_n_plate_definition_file"] = _raise_uninitialized_error
        self.__dict__["_set_n_plate_definition_file"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMarsGRAM2005._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMarsGRAM2005 from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMarsGRAM2005 = agcom.GUID(IMarsGRAM2005._uuid)
        vtable_offset_local = IMarsGRAM2005._vtable_offset - 1
        self.__dict__["_get_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2005, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2005, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_computes_temperature"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2005, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_computes_pressure"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2005, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_sun_position"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2005, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_sun_position"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2005, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_data_directory"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2005, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_set_data_directory"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2005, vtable_offset_local+8, agcom.BSTR)
        self.__dict__["_get_namelist_file"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2005, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_set_namelist_file"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2005, vtable_offset_local+10, agcom.BSTR)
        self.__dict__["_get_density_type"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2005, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_set_density_type"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2005, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_get_atmos_data_source"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2005, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_set_atmos_data_source"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2005, vtable_offset_local+14, agcom.LONG)
        self.__dict__["_get_f_10_p7"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2005, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_f_10_p7"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2005, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_atmos_data_filename"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2005, vtable_offset_local+17, POINTER(agcom.BSTR))
        self.__dict__["_set_atmos_data_filename"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2005, vtable_offset_local+18, agcom.BSTR)
        self.__dict__["_get_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2005, vtable_offset_local+19, POINTER(agcom.LONG))
        self.__dict__["_set_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2005, vtable_offset_local+20, agcom.LONG)
        self.__dict__["_get_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2005, vtable_offset_local+21, POINTER(agcom.BSTR))
        self.__dict__["_set_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2005, vtable_offset_local+22, agcom.BSTR)
        self.__dict__["_get_drag_model_plugin"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2005, vtable_offset_local+23, POINTER(agcom.PVOID))
        self.__dict__["_get_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2005, vtable_offset_local+24, POINTER(agcom.BSTR))
        self.__dict__["_set_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2005, vtable_offset_local+25, agcom.BSTR)
        self.__dict__["_get_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2005, vtable_offset_local+26, POINTER(agcom.BSTR))
        self.__dict__["_set_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2005, vtable_offset_local+27, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMarsGRAM2005.__dict__ and type(IMarsGRAM2005.__dict__[attrname]) == property:
            return IMarsGRAM2005.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMarsGRAM2005.")
    
    @property
    def use_approximate_altitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_approximate_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_approximate_altitude.setter
    def use_approximate_altitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_approximate_altitude"](arg_inVal.COM_val))

    @property
    def computes_temperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_temperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def computes_pressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_pressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def sun_position(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sun_position"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sun_position.setter
    def sun_position(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_sun_position"](arg_inVal.COM_val))

    @property
    def data_directory(self) -> str:
        """Path to the data directory."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_data_directory"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @data_directory.setter
    def data_directory(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_data_directory"](arg_inVal.COM_val))

    @property
    def namelist_file(self) -> str:
        """Full path of namelist file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_namelist_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @namelist_file.setter
    def namelist_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_namelist_file"](arg_inVal.COM_val))

    @property
    def density_type(self) -> "AgEVAMarsGRAMDensityType":
        """Low, mean, high or randomly perturbed density type."""
        with agmarshall.AgEnum_arg(AgEVAMarsGRAMDensityType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_density_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @density_type.setter
    def density_type(self, inVal:"AgEVAMarsGRAMDensityType") -> None:
        with agmarshall.AgEnum_arg(AgEVAMarsGRAMDensityType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_density_type"](arg_inVal.COM_val))

    @property
    def atmos_data_source(self) -> "AgEVAAtmosDataSource":
        """The atmospheric model data source - data file or constant values."""
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_source.setter
    def atmos_data_source(self, inVal:"AgEVAAtmosDataSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_source"](arg_inVal.COM_val))

    @property
    def f_10_p7(self) -> float:
        """Solar Flux (F10.7); the daily Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_f_10_p7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @f_10_p7.setter
    def f_10_p7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_f_10_p7"](arg_inVal.COM_val))

    @property
    def atmos_data_filename(self) -> str:
        """The atmospheric model data file path."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_filename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_filename.setter
    def atmos_data_filename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_filename"](arg_inVal.COM_val))

    @property
    def drag_model_type(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_type.setter
    def drag_model_type(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_type"](arg_inVal.COM_val))

    @property
    def drag_model_plugin_name(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_plugin_name.setter
    def drag_model_plugin_name(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_plugin_name"](arg_pVal.COM_val))

    @property
    def drag_model_plugin(self) -> "IDragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def variable_area_history_file(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_variable_area_history_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @variable_area_history_file.setter
    def variable_area_history_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_variable_area_history_file"](arg_inVal.COM_val))

    @property
    def n_plate_definition_file(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_n_plate_definition_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @n_plate_definition_file.setter
    def n_plate_definition_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_n_plate_definition_file"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E8649FED-5172-444A-9FC2-3B69586A8B91}", IMarsGRAM2005)
agcls.AgTypeNameMap["IMarsGRAM2005"] = IMarsGRAM2005

class IVenusGRAM2005(object):
    """Properties for the Venus-GRAM 2005 atmospheric model."""
    _uuid = "{270C541C-FF9B-4E56-81B0-36CF43D3BE54}"
    _num_methods = 19
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_computes_temperature"] = _raise_uninitialized_error
        self.__dict__["_get_computes_pressure"] = _raise_uninitialized_error
        self.__dict__["_get_data_directory"] = _raise_uninitialized_error
        self.__dict__["_set_data_directory"] = _raise_uninitialized_error
        self.__dict__["_get_namelist_file"] = _raise_uninitialized_error
        self.__dict__["_set_namelist_file"] = _raise_uninitialized_error
        self.__dict__["_get_density_type"] = _raise_uninitialized_error
        self.__dict__["_set_density_type"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin"] = _raise_uninitialized_error
        self.__dict__["_get_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_set_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_get_n_plate_definition_file"] = _raise_uninitialized_error
        self.__dict__["_set_n_plate_definition_file"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IVenusGRAM2005._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IVenusGRAM2005 from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IVenusGRAM2005 = agcom.GUID(IVenusGRAM2005._uuid)
        vtable_offset_local = IVenusGRAM2005._vtable_offset - 1
        self.__dict__["_get_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IVenusGRAM2005, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IVenusGRAM2005, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_computes_temperature"] = IAGFUNCTYPE(pUnk, IID_IVenusGRAM2005, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_computes_pressure"] = IAGFUNCTYPE(pUnk, IID_IVenusGRAM2005, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_data_directory"] = IAGFUNCTYPE(pUnk, IID_IVenusGRAM2005, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_set_data_directory"] = IAGFUNCTYPE(pUnk, IID_IVenusGRAM2005, vtable_offset_local+6, agcom.BSTR)
        self.__dict__["_get_namelist_file"] = IAGFUNCTYPE(pUnk, IID_IVenusGRAM2005, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_set_namelist_file"] = IAGFUNCTYPE(pUnk, IID_IVenusGRAM2005, vtable_offset_local+8, agcom.BSTR)
        self.__dict__["_get_density_type"] = IAGFUNCTYPE(pUnk, IID_IVenusGRAM2005, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_set_density_type"] = IAGFUNCTYPE(pUnk, IID_IVenusGRAM2005, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_get_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IVenusGRAM2005, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_set_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IVenusGRAM2005, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_get_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IVenusGRAM2005, vtable_offset_local+13, POINTER(agcom.BSTR))
        self.__dict__["_set_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IVenusGRAM2005, vtable_offset_local+14, agcom.BSTR)
        self.__dict__["_get_drag_model_plugin"] = IAGFUNCTYPE(pUnk, IID_IVenusGRAM2005, vtable_offset_local+15, POINTER(agcom.PVOID))
        self.__dict__["_get_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IVenusGRAM2005, vtable_offset_local+16, POINTER(agcom.BSTR))
        self.__dict__["_set_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IVenusGRAM2005, vtable_offset_local+17, agcom.BSTR)
        self.__dict__["_get_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IVenusGRAM2005, vtable_offset_local+18, POINTER(agcom.BSTR))
        self.__dict__["_set_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IVenusGRAM2005, vtable_offset_local+19, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IVenusGRAM2005.__dict__ and type(IVenusGRAM2005.__dict__[attrname]) == property:
            return IVenusGRAM2005.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IVenusGRAM2005.")
    
    @property
    def use_approximate_altitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_approximate_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_approximate_altitude.setter
    def use_approximate_altitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_approximate_altitude"](arg_inVal.COM_val))

    @property
    def computes_temperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_temperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def computes_pressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_pressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def data_directory(self) -> str:
        """Path to the data directory."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_data_directory"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @data_directory.setter
    def data_directory(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_data_directory"](arg_inVal.COM_val))

    @property
    def namelist_file(self) -> str:
        """Full path of namelist file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_namelist_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @namelist_file.setter
    def namelist_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_namelist_file"](arg_inVal.COM_val))

    @property
    def density_type(self) -> "AgEVAVenusGRAMDensityType":
        """Low, mean, high or randomly perturbed density type."""
        with agmarshall.AgEnum_arg(AgEVAVenusGRAMDensityType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_density_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @density_type.setter
    def density_type(self, inVal:"AgEVAVenusGRAMDensityType") -> None:
        with agmarshall.AgEnum_arg(AgEVAVenusGRAMDensityType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_density_type"](arg_inVal.COM_val))

    @property
    def drag_model_type(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_type.setter
    def drag_model_type(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_type"](arg_inVal.COM_val))

    @property
    def drag_model_plugin_name(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_plugin_name.setter
    def drag_model_plugin_name(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_plugin_name"](arg_pVal.COM_val))

    @property
    def drag_model_plugin(self) -> "IDragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def variable_area_history_file(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_variable_area_history_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @variable_area_history_file.setter
    def variable_area_history_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_variable_area_history_file"](arg_inVal.COM_val))

    @property
    def n_plate_definition_file(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_n_plate_definition_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @n_plate_definition_file.setter
    def n_plate_definition_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_n_plate_definition_file"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{270C541C-FF9B-4E56-81B0-36CF43D3BE54}", IVenusGRAM2005)
agcls.AgTypeNameMap["IVenusGRAM2005"] = IVenusGRAM2005

class IMarsGRAM2010(object):
    """Properties for the Mars-GRAM 2010 atmospheric model."""
    _uuid = "{C9E4AA59-8B84-4AC1-938E-E5E92A12EC4F}"
    _num_methods = 27
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_computes_temperature"] = _raise_uninitialized_error
        self.__dict__["_get_computes_pressure"] = _raise_uninitialized_error
        self.__dict__["_get_sun_position"] = _raise_uninitialized_error
        self.__dict__["_set_sun_position"] = _raise_uninitialized_error
        self.__dict__["_get_data_directory"] = _raise_uninitialized_error
        self.__dict__["_set_data_directory"] = _raise_uninitialized_error
        self.__dict__["_get_namelist_file"] = _raise_uninitialized_error
        self.__dict__["_set_namelist_file"] = _raise_uninitialized_error
        self.__dict__["_get_density_type"] = _raise_uninitialized_error
        self.__dict__["_set_density_type"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_source"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_source"] = _raise_uninitialized_error
        self.__dict__["_get_f_10_p7"] = _raise_uninitialized_error
        self.__dict__["_set_f_10_p7"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_filename"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_filename"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin"] = _raise_uninitialized_error
        self.__dict__["_get_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_set_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_get_n_plate_definition_file"] = _raise_uninitialized_error
        self.__dict__["_set_n_plate_definition_file"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMarsGRAM2010._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMarsGRAM2010 from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMarsGRAM2010 = agcom.GUID(IMarsGRAM2010._uuid)
        vtable_offset_local = IMarsGRAM2010._vtable_offset - 1
        self.__dict__["_get_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2010, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2010, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_computes_temperature"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2010, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_computes_pressure"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2010, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_sun_position"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2010, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_sun_position"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2010, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_data_directory"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2010, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_set_data_directory"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2010, vtable_offset_local+8, agcom.BSTR)
        self.__dict__["_get_namelist_file"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2010, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_set_namelist_file"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2010, vtable_offset_local+10, agcom.BSTR)
        self.__dict__["_get_density_type"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2010, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_set_density_type"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2010, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_get_atmos_data_source"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2010, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_set_atmos_data_source"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2010, vtable_offset_local+14, agcom.LONG)
        self.__dict__["_get_f_10_p7"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2010, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_f_10_p7"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2010, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_atmos_data_filename"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2010, vtable_offset_local+17, POINTER(agcom.BSTR))
        self.__dict__["_set_atmos_data_filename"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2010, vtable_offset_local+18, agcom.BSTR)
        self.__dict__["_get_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2010, vtable_offset_local+19, POINTER(agcom.LONG))
        self.__dict__["_set_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2010, vtable_offset_local+20, agcom.LONG)
        self.__dict__["_get_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2010, vtable_offset_local+21, POINTER(agcom.BSTR))
        self.__dict__["_set_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2010, vtable_offset_local+22, agcom.BSTR)
        self.__dict__["_get_drag_model_plugin"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2010, vtable_offset_local+23, POINTER(agcom.PVOID))
        self.__dict__["_get_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2010, vtable_offset_local+24, POINTER(agcom.BSTR))
        self.__dict__["_set_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2010, vtable_offset_local+25, agcom.BSTR)
        self.__dict__["_get_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2010, vtable_offset_local+26, POINTER(agcom.BSTR))
        self.__dict__["_set_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2010, vtable_offset_local+27, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMarsGRAM2010.__dict__ and type(IMarsGRAM2010.__dict__[attrname]) == property:
            return IMarsGRAM2010.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMarsGRAM2010.")
    
    @property
    def use_approximate_altitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_approximate_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_approximate_altitude.setter
    def use_approximate_altitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_approximate_altitude"](arg_inVal.COM_val))

    @property
    def computes_temperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_temperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def computes_pressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_pressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def sun_position(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sun_position"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sun_position.setter
    def sun_position(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_sun_position"](arg_inVal.COM_val))

    @property
    def data_directory(self) -> str:
        """Path to the data directory."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_data_directory"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @data_directory.setter
    def data_directory(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_data_directory"](arg_inVal.COM_val))

    @property
    def namelist_file(self) -> str:
        """Full path of namelist file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_namelist_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @namelist_file.setter
    def namelist_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_namelist_file"](arg_inVal.COM_val))

    @property
    def density_type(self) -> "AgEVAMarsGRAMDensityType":
        """Low, mean, high or randomly perturbed density type."""
        with agmarshall.AgEnum_arg(AgEVAMarsGRAMDensityType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_density_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @density_type.setter
    def density_type(self, inVal:"AgEVAMarsGRAMDensityType") -> None:
        with agmarshall.AgEnum_arg(AgEVAMarsGRAMDensityType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_density_type"](arg_inVal.COM_val))

    @property
    def atmos_data_source(self) -> "AgEVAAtmosDataSource":
        """The atmospheric model data source - data file or constant values."""
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_source.setter
    def atmos_data_source(self, inVal:"AgEVAAtmosDataSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_source"](arg_inVal.COM_val))

    @property
    def f_10_p7(self) -> float:
        """Solar Flux (F10.7); the daily Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_f_10_p7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @f_10_p7.setter
    def f_10_p7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_f_10_p7"](arg_inVal.COM_val))

    @property
    def atmos_data_filename(self) -> str:
        """The atmospheric model data file path."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_filename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_filename.setter
    def atmos_data_filename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_filename"](arg_inVal.COM_val))

    @property
    def drag_model_type(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_type.setter
    def drag_model_type(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_type"](arg_inVal.COM_val))

    @property
    def drag_model_plugin_name(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_plugin_name.setter
    def drag_model_plugin_name(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_plugin_name"](arg_pVal.COM_val))

    @property
    def drag_model_plugin(self) -> "IDragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def variable_area_history_file(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_variable_area_history_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @variable_area_history_file.setter
    def variable_area_history_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_variable_area_history_file"](arg_inVal.COM_val))

    @property
    def n_plate_definition_file(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_n_plate_definition_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @n_plate_definition_file.setter
    def n_plate_definition_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_n_plate_definition_file"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{C9E4AA59-8B84-4AC1-938E-E5E92A12EC4F}", IMarsGRAM2010)
agcls.AgTypeNameMap["IMarsGRAM2010"] = IMarsGRAM2010

class IMarsGRAM2001(object):
    """Properties for the Mars-GRAM 2001 atmospheric model."""
    _uuid = "{D9213F74-E8C9-4251-9BD6-FA0C0138AFCD}"
    _num_methods = 27
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_computes_temperature"] = _raise_uninitialized_error
        self.__dict__["_get_computes_pressure"] = _raise_uninitialized_error
        self.__dict__["_get_sun_position"] = _raise_uninitialized_error
        self.__dict__["_set_sun_position"] = _raise_uninitialized_error
        self.__dict__["_get_data_directory"] = _raise_uninitialized_error
        self.__dict__["_set_data_directory"] = _raise_uninitialized_error
        self.__dict__["_get_namelist_file"] = _raise_uninitialized_error
        self.__dict__["_set_namelist_file"] = _raise_uninitialized_error
        self.__dict__["_get_density_type"] = _raise_uninitialized_error
        self.__dict__["_set_density_type"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_source"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_source"] = _raise_uninitialized_error
        self.__dict__["_get_f_10_p7"] = _raise_uninitialized_error
        self.__dict__["_set_f_10_p7"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_filename"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_filename"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin"] = _raise_uninitialized_error
        self.__dict__["_get_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_set_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_get_n_plate_definition_file"] = _raise_uninitialized_error
        self.__dict__["_set_n_plate_definition_file"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMarsGRAM2001._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMarsGRAM2001 from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMarsGRAM2001 = agcom.GUID(IMarsGRAM2001._uuid)
        vtable_offset_local = IMarsGRAM2001._vtable_offset - 1
        self.__dict__["_get_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2001, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2001, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_computes_temperature"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2001, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_computes_pressure"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2001, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_sun_position"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2001, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_sun_position"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2001, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_data_directory"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2001, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_set_data_directory"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2001, vtable_offset_local+8, agcom.BSTR)
        self.__dict__["_get_namelist_file"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2001, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_set_namelist_file"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2001, vtable_offset_local+10, agcom.BSTR)
        self.__dict__["_get_density_type"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2001, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_set_density_type"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2001, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_get_atmos_data_source"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2001, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_set_atmos_data_source"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2001, vtable_offset_local+14, agcom.LONG)
        self.__dict__["_get_f_10_p7"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2001, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_f_10_p7"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2001, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_atmos_data_filename"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2001, vtable_offset_local+17, POINTER(agcom.BSTR))
        self.__dict__["_set_atmos_data_filename"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2001, vtable_offset_local+18, agcom.BSTR)
        self.__dict__["_get_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2001, vtable_offset_local+19, POINTER(agcom.LONG))
        self.__dict__["_set_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2001, vtable_offset_local+20, agcom.LONG)
        self.__dict__["_get_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2001, vtable_offset_local+21, POINTER(agcom.BSTR))
        self.__dict__["_set_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2001, vtable_offset_local+22, agcom.BSTR)
        self.__dict__["_get_drag_model_plugin"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2001, vtable_offset_local+23, POINTER(agcom.PVOID))
        self.__dict__["_get_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2001, vtable_offset_local+24, POINTER(agcom.BSTR))
        self.__dict__["_set_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2001, vtable_offset_local+25, agcom.BSTR)
        self.__dict__["_get_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2001, vtable_offset_local+26, POINTER(agcom.BSTR))
        self.__dict__["_set_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2001, vtable_offset_local+27, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMarsGRAM2001.__dict__ and type(IMarsGRAM2001.__dict__[attrname]) == property:
            return IMarsGRAM2001.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMarsGRAM2001.")
    
    @property
    def use_approximate_altitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_approximate_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_approximate_altitude.setter
    def use_approximate_altitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_approximate_altitude"](arg_inVal.COM_val))

    @property
    def computes_temperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_temperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def computes_pressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_pressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def sun_position(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sun_position"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sun_position.setter
    def sun_position(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_sun_position"](arg_inVal.COM_val))

    @property
    def data_directory(self) -> str:
        """Path to the data directory."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_data_directory"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @data_directory.setter
    def data_directory(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_data_directory"](arg_inVal.COM_val))

    @property
    def namelist_file(self) -> str:
        """Path to namelist file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_namelist_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @namelist_file.setter
    def namelist_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_namelist_file"](arg_inVal.COM_val))

    @property
    def density_type(self) -> "AgEVAMarsGRAMDensityType":
        """Low, mean, high or randomly perturbed density type."""
        with agmarshall.AgEnum_arg(AgEVAMarsGRAMDensityType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_density_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @density_type.setter
    def density_type(self, inVal:"AgEVAMarsGRAMDensityType") -> None:
        with agmarshall.AgEnum_arg(AgEVAMarsGRAMDensityType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_density_type"](arg_inVal.COM_val))

    @property
    def atmos_data_source(self) -> "AgEVAAtmosDataSource":
        """The atmospheric model data source - data file or constant values."""
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_source.setter
    def atmos_data_source(self, inVal:"AgEVAAtmosDataSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_source"](arg_inVal.COM_val))

    @property
    def f_10_p7(self) -> float:
        """Solar Flux (F10.7); the daily Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_f_10_p7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @f_10_p7.setter
    def f_10_p7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_f_10_p7"](arg_inVal.COM_val))

    @property
    def atmos_data_filename(self) -> str:
        """The atmospheric model data file path."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_filename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_filename.setter
    def atmos_data_filename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_filename"](arg_inVal.COM_val))

    @property
    def drag_model_type(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_type.setter
    def drag_model_type(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_type"](arg_inVal.COM_val))

    @property
    def drag_model_plugin_name(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_plugin_name.setter
    def drag_model_plugin_name(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_plugin_name"](arg_pVal.COM_val))

    @property
    def drag_model_plugin(self) -> "IDragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def variable_area_history_file(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_variable_area_history_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @variable_area_history_file.setter
    def variable_area_history_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_variable_area_history_file"](arg_inVal.COM_val))

    @property
    def n_plate_definition_file(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_n_plate_definition_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @n_plate_definition_file.setter
    def n_plate_definition_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_n_plate_definition_file"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{D9213F74-E8C9-4251-9BD6-FA0C0138AFCD}", IMarsGRAM2001)
agcls.AgTypeNameMap["IMarsGRAM2001"] = IMarsGRAM2001

class IMarsGRAM2000(object):
    """Properties for the Mars-GRAM 2000 atmospheric model."""
    _uuid = "{E3458F58-63AD-4974-9EDA-524E9418A1DF}"
    _num_methods = 27
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_computes_temperature"] = _raise_uninitialized_error
        self.__dict__["_get_computes_pressure"] = _raise_uninitialized_error
        self.__dict__["_get_sun_position"] = _raise_uninitialized_error
        self.__dict__["_set_sun_position"] = _raise_uninitialized_error
        self.__dict__["_get_data_directory"] = _raise_uninitialized_error
        self.__dict__["_set_data_directory"] = _raise_uninitialized_error
        self.__dict__["_get_namelist_file"] = _raise_uninitialized_error
        self.__dict__["_set_namelist_file"] = _raise_uninitialized_error
        self.__dict__["_get_density_type"] = _raise_uninitialized_error
        self.__dict__["_set_density_type"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_source"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_source"] = _raise_uninitialized_error
        self.__dict__["_get_f_10_p7"] = _raise_uninitialized_error
        self.__dict__["_set_f_10_p7"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_filename"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_filename"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin"] = _raise_uninitialized_error
        self.__dict__["_get_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_set_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_get_n_plate_definition_file"] = _raise_uninitialized_error
        self.__dict__["_set_n_plate_definition_file"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IMarsGRAM2000._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IMarsGRAM2000 from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IMarsGRAM2000 = agcom.GUID(IMarsGRAM2000._uuid)
        vtable_offset_local = IMarsGRAM2000._vtable_offset - 1
        self.__dict__["_get_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2000, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2000, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_computes_temperature"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2000, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_computes_pressure"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2000, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_sun_position"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2000, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_sun_position"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2000, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_data_directory"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2000, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_set_data_directory"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2000, vtable_offset_local+8, agcom.BSTR)
        self.__dict__["_get_namelist_file"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2000, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_set_namelist_file"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2000, vtable_offset_local+10, agcom.BSTR)
        self.__dict__["_get_density_type"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2000, vtable_offset_local+11, POINTER(agcom.LONG))
        self.__dict__["_set_density_type"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2000, vtable_offset_local+12, agcom.LONG)
        self.__dict__["_get_atmos_data_source"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2000, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_set_atmos_data_source"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2000, vtable_offset_local+14, agcom.LONG)
        self.__dict__["_get_f_10_p7"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2000, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_f_10_p7"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2000, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_atmos_data_filename"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2000, vtable_offset_local+17, POINTER(agcom.BSTR))
        self.__dict__["_set_atmos_data_filename"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2000, vtable_offset_local+18, agcom.BSTR)
        self.__dict__["_get_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2000, vtable_offset_local+19, POINTER(agcom.LONG))
        self.__dict__["_set_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2000, vtable_offset_local+20, agcom.LONG)
        self.__dict__["_get_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2000, vtable_offset_local+21, POINTER(agcom.BSTR))
        self.__dict__["_set_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2000, vtable_offset_local+22, agcom.BSTR)
        self.__dict__["_get_drag_model_plugin"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2000, vtable_offset_local+23, POINTER(agcom.PVOID))
        self.__dict__["_get_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2000, vtable_offset_local+24, POINTER(agcom.BSTR))
        self.__dict__["_set_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2000, vtable_offset_local+25, agcom.BSTR)
        self.__dict__["_get_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2000, vtable_offset_local+26, POINTER(agcom.BSTR))
        self.__dict__["_set_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IMarsGRAM2000, vtable_offset_local+27, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IMarsGRAM2000.__dict__ and type(IMarsGRAM2000.__dict__[attrname]) == property:
            return IMarsGRAM2000.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IMarsGRAM2000.")
    
    @property
    def use_approximate_altitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_approximate_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_approximate_altitude.setter
    def use_approximate_altitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_approximate_altitude"](arg_inVal.COM_val))

    @property
    def computes_temperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_temperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def computes_pressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_pressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def sun_position(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sun_position"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sun_position.setter
    def sun_position(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_sun_position"](arg_inVal.COM_val))

    @property
    def data_directory(self) -> str:
        """Path to the data directory."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_data_directory"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @data_directory.setter
    def data_directory(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_data_directory"](arg_inVal.COM_val))

    @property
    def namelist_file(self) -> str:
        """Full path of namelist file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_namelist_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @namelist_file.setter
    def namelist_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_namelist_file"](arg_inVal.COM_val))

    @property
    def density_type(self) -> "AgEVAMarsGRAMDensityType":
        """Low, mean, high or randomly perturbed density type."""
        with agmarshall.AgEnum_arg(AgEVAMarsGRAMDensityType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_density_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @density_type.setter
    def density_type(self, inVal:"AgEVAMarsGRAMDensityType") -> None:
        with agmarshall.AgEnum_arg(AgEVAMarsGRAMDensityType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_density_type"](arg_inVal.COM_val))

    @property
    def atmos_data_source(self) -> "AgEVAAtmosDataSource":
        """The atmospheric model data source - data file or constant values."""
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_source.setter
    def atmos_data_source(self, inVal:"AgEVAAtmosDataSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_source"](arg_inVal.COM_val))

    @property
    def f_10_p7(self) -> float:
        """Solar Flux (F10.7); the daily Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_f_10_p7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @f_10_p7.setter
    def f_10_p7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_f_10_p7"](arg_inVal.COM_val))

    @property
    def atmos_data_filename(self) -> str:
        """The atmospheric model data file path."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_filename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_filename.setter
    def atmos_data_filename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_filename"](arg_inVal.COM_val))

    @property
    def drag_model_type(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_type.setter
    def drag_model_type(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_type"](arg_inVal.COM_val))

    @property
    def drag_model_plugin_name(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_plugin_name.setter
    def drag_model_plugin_name(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_plugin_name"](arg_pVal.COM_val))

    @property
    def drag_model_plugin(self) -> "IDragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def variable_area_history_file(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_variable_area_history_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @variable_area_history_file.setter
    def variable_area_history_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_variable_area_history_file"](arg_inVal.COM_val))

    @property
    def n_plate_definition_file(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_n_plate_definition_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @n_plate_definition_file.setter
    def n_plate_definition_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_n_plate_definition_file"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E3458F58-63AD-4974-9EDA-524E9418A1DF}", IMarsGRAM2000)
agcls.AgTypeNameMap["IMarsGRAM2000"] = IMarsGRAM2000

class IDTM2012(object):
    """Properties for the DTM 2012 atmospheric model."""
    _uuid = "{4840E65F-6197-4A64-A80A-E0DF1E1048E0}"
    _num_methods = 29
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_computes_temperature"] = _raise_uninitialized_error
        self.__dict__["_get_computes_pressure"] = _raise_uninitialized_error
        self.__dict__["_get_sun_position"] = _raise_uninitialized_error
        self.__dict__["_set_sun_position"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_source"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_source"] = _raise_uninitialized_error
        self.__dict__["_get_f_10_p7_avg"] = _raise_uninitialized_error
        self.__dict__["_set_f_10_p7_avg"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_filename"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_filename"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin"] = _raise_uninitialized_error
        self.__dict__["_get_f_10_p7"] = _raise_uninitialized_error
        self.__dict__["_set_f_10_p7"] = _raise_uninitialized_error
        self.__dict__["_get_kp"] = _raise_uninitialized_error
        self.__dict__["_set_kp"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_geo_magnetic_flux_source"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_geo_magnetic_flux_source"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_geo_magnetic_flux_update_rate"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_geo_magnetic_flux_update_rate"] = _raise_uninitialized_error
        self.__dict__["_get_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_set_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_get_n_plate_definition_file"] = _raise_uninitialized_error
        self.__dict__["_set_n_plate_definition_file"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IDTM2012._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IDTM2012 from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IDTM2012 = agcom.GUID(IDTM2012._uuid)
        vtable_offset_local = IDTM2012._vtable_offset - 1
        self.__dict__["_get_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IDTM2012, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IDTM2012, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_computes_temperature"] = IAGFUNCTYPE(pUnk, IID_IDTM2012, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_computes_pressure"] = IAGFUNCTYPE(pUnk, IID_IDTM2012, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_sun_position"] = IAGFUNCTYPE(pUnk, IID_IDTM2012, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_sun_position"] = IAGFUNCTYPE(pUnk, IID_IDTM2012, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_atmos_data_source"] = IAGFUNCTYPE(pUnk, IID_IDTM2012, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_atmos_data_source"] = IAGFUNCTYPE(pUnk, IID_IDTM2012, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_f_10_p7_avg"] = IAGFUNCTYPE(pUnk, IID_IDTM2012, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_f_10_p7_avg"] = IAGFUNCTYPE(pUnk, IID_IDTM2012, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_atmos_data_filename"] = IAGFUNCTYPE(pUnk, IID_IDTM2012, vtable_offset_local+11, POINTER(agcom.BSTR))
        self.__dict__["_set_atmos_data_filename"] = IAGFUNCTYPE(pUnk, IID_IDTM2012, vtable_offset_local+12, agcom.BSTR)
        self.__dict__["_get_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IDTM2012, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_set_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IDTM2012, vtable_offset_local+14, agcom.LONG)
        self.__dict__["_get_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IDTM2012, vtable_offset_local+15, POINTER(agcom.BSTR))
        self.__dict__["_set_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IDTM2012, vtable_offset_local+16, agcom.BSTR)
        self.__dict__["_get_drag_model_plugin"] = IAGFUNCTYPE(pUnk, IID_IDTM2012, vtable_offset_local+17, POINTER(agcom.PVOID))
        self.__dict__["_get_f_10_p7"] = IAGFUNCTYPE(pUnk, IID_IDTM2012, vtable_offset_local+18, POINTER(agcom.DOUBLE))
        self.__dict__["_set_f_10_p7"] = IAGFUNCTYPE(pUnk, IID_IDTM2012, vtable_offset_local+19, agcom.DOUBLE)
        self.__dict__["_get_kp"] = IAGFUNCTYPE(pUnk, IID_IDTM2012, vtable_offset_local+20, POINTER(agcom.DOUBLE))
        self.__dict__["_set_kp"] = IAGFUNCTYPE(pUnk, IID_IDTM2012, vtable_offset_local+21, agcom.DOUBLE)
        self.__dict__["_get_atmos_data_geo_magnetic_flux_source"] = IAGFUNCTYPE(pUnk, IID_IDTM2012, vtable_offset_local+22, POINTER(agcom.LONG))
        self.__dict__["_set_atmos_data_geo_magnetic_flux_source"] = IAGFUNCTYPE(pUnk, IID_IDTM2012, vtable_offset_local+23, agcom.LONG)
        self.__dict__["_get_atmos_data_geo_magnetic_flux_update_rate"] = IAGFUNCTYPE(pUnk, IID_IDTM2012, vtable_offset_local+24, POINTER(agcom.LONG))
        self.__dict__["_set_atmos_data_geo_magnetic_flux_update_rate"] = IAGFUNCTYPE(pUnk, IID_IDTM2012, vtable_offset_local+25, agcom.LONG)
        self.__dict__["_get_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IDTM2012, vtable_offset_local+26, POINTER(agcom.BSTR))
        self.__dict__["_set_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IDTM2012, vtable_offset_local+27, agcom.BSTR)
        self.__dict__["_get_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IDTM2012, vtable_offset_local+28, POINTER(agcom.BSTR))
        self.__dict__["_set_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IDTM2012, vtable_offset_local+29, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IDTM2012.__dict__ and type(IDTM2012.__dict__[attrname]) == property:
            return IDTM2012.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IDTM2012.")
    
    @property
    def use_approximate_altitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_approximate_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_approximate_altitude.setter
    def use_approximate_altitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_approximate_altitude"](arg_inVal.COM_val))

    @property
    def computes_temperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_temperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def computes_pressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_pressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def sun_position(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sun_position"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sun_position.setter
    def sun_position(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_sun_position"](arg_inVal.COM_val))

    @property
    def atmos_data_source(self) -> "AgEVAAtmosDataSource":
        """The atmospheric model data source - data file or constant values."""
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_source.setter
    def atmos_data_source(self, inVal:"AgEVAAtmosDataSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_source"](arg_inVal.COM_val))

    @property
    def f_10_p7_avg(self) -> float:
        """Average solar Flux (F10.7); the 81-day averaged Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_f_10_p7_avg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @f_10_p7_avg.setter
    def f_10_p7_avg(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_f_10_p7_avg"](arg_inVal.COM_val))

    @property
    def atmos_data_filename(self) -> str:
        """Flux file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_filename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_filename.setter
    def atmos_data_filename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_filename"](arg_inVal.COM_val))

    @property
    def drag_model_type(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_type.setter
    def drag_model_type(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_type"](arg_inVal.COM_val))

    @property
    def drag_model_plugin_name(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_plugin_name.setter
    def drag_model_plugin_name(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_plugin_name"](arg_pVal.COM_val))

    @property
    def drag_model_plugin(self) -> "IDragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def f_10_p7(self) -> float:
        """Solar Flux (F10.7); the daily Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_f_10_p7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @f_10_p7.setter
    def f_10_p7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_f_10_p7"](arg_inVal.COM_val))

    @property
    def kp(self) -> float:
        """Geomagnetic Index (Kp). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_kp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @kp.setter
    def kp(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_kp"](arg_inVal.COM_val))

    @property
    def atmos_data_geo_magnetic_flux_source(self) -> "AgEVAGeoMagneticFluxSource":
        """Whether to use Kp or Ap data from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_geo_magnetic_flux_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_geo_magnetic_flux_source.setter
    def atmos_data_geo_magnetic_flux_source(self, inVal:"AgEVAGeoMagneticFluxSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_geo_magnetic_flux_source"](arg_inVal.COM_val))

    @property
    def atmos_data_geo_magnetic_flux_update_rate(self) -> "AgEVAGeoMagneticFluxUpdateRate":
        """The update rate of geomagnetic flux values from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_geo_magnetic_flux_update_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_geo_magnetic_flux_update_rate.setter
    def atmos_data_geo_magnetic_flux_update_rate(self, inVal:"AgEVAGeoMagneticFluxUpdateRate") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_geo_magnetic_flux_update_rate"](arg_inVal.COM_val))

    @property
    def variable_area_history_file(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_variable_area_history_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @variable_area_history_file.setter
    def variable_area_history_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_variable_area_history_file"](arg_inVal.COM_val))

    @property
    def n_plate_definition_file(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_n_plate_definition_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @n_plate_definition_file.setter
    def n_plate_definition_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_n_plate_definition_file"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4840E65F-6197-4A64-A80A-E0DF1E1048E0}", IDTM2012)
agcls.AgTypeNameMap["IDTM2012"] = IDTM2012

class IDTM2020(object):
    """Properties for the DTM 2020 atmospheric model."""
    _uuid = "{50AA8B32-1905-416D-B45E-631E78F5F174}"
    _num_methods = 29
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_set_use_approximate_altitude"] = _raise_uninitialized_error
        self.__dict__["_get_computes_temperature"] = _raise_uninitialized_error
        self.__dict__["_get_computes_pressure"] = _raise_uninitialized_error
        self.__dict__["_get_sun_position"] = _raise_uninitialized_error
        self.__dict__["_set_sun_position"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_source"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_source"] = _raise_uninitialized_error
        self.__dict__["_get_f_10_p7_avg"] = _raise_uninitialized_error
        self.__dict__["_set_f_10_p7_avg"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_filename"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_filename"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_type"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_set_drag_model_plugin_name"] = _raise_uninitialized_error
        self.__dict__["_get_drag_model_plugin"] = _raise_uninitialized_error
        self.__dict__["_get_f_10_p7"] = _raise_uninitialized_error
        self.__dict__["_set_f_10_p7"] = _raise_uninitialized_error
        self.__dict__["_get_kp"] = _raise_uninitialized_error
        self.__dict__["_set_kp"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_geo_magnetic_flux_source"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_geo_magnetic_flux_source"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_data_geo_magnetic_flux_update_rate"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_data_geo_magnetic_flux_update_rate"] = _raise_uninitialized_error
        self.__dict__["_get_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_set_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_get_n_plate_definition_file"] = _raise_uninitialized_error
        self.__dict__["_set_n_plate_definition_file"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IDTM2020._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IDTM2020 from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IDTM2020 = agcom.GUID(IDTM2020._uuid)
        vtable_offset_local = IDTM2020._vtable_offset - 1
        self.__dict__["_get_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IDTM2020, vtable_offset_local+1, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_approximate_altitude"] = IAGFUNCTYPE(pUnk, IID_IDTM2020, vtable_offset_local+2, agcom.VARIANT_BOOL)
        self.__dict__["_get_computes_temperature"] = IAGFUNCTYPE(pUnk, IID_IDTM2020, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_computes_pressure"] = IAGFUNCTYPE(pUnk, IID_IDTM2020, vtable_offset_local+4, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_sun_position"] = IAGFUNCTYPE(pUnk, IID_IDTM2020, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_sun_position"] = IAGFUNCTYPE(pUnk, IID_IDTM2020, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_atmos_data_source"] = IAGFUNCTYPE(pUnk, IID_IDTM2020, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_atmos_data_source"] = IAGFUNCTYPE(pUnk, IID_IDTM2020, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_f_10_p7_avg"] = IAGFUNCTYPE(pUnk, IID_IDTM2020, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_f_10_p7_avg"] = IAGFUNCTYPE(pUnk, IID_IDTM2020, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_atmos_data_filename"] = IAGFUNCTYPE(pUnk, IID_IDTM2020, vtable_offset_local+11, POINTER(agcom.BSTR))
        self.__dict__["_set_atmos_data_filename"] = IAGFUNCTYPE(pUnk, IID_IDTM2020, vtable_offset_local+12, agcom.BSTR)
        self.__dict__["_get_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IDTM2020, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_set_drag_model_type"] = IAGFUNCTYPE(pUnk, IID_IDTM2020, vtable_offset_local+14, agcom.LONG)
        self.__dict__["_get_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IDTM2020, vtable_offset_local+15, POINTER(agcom.BSTR))
        self.__dict__["_set_drag_model_plugin_name"] = IAGFUNCTYPE(pUnk, IID_IDTM2020, vtable_offset_local+16, agcom.BSTR)
        self.__dict__["_get_drag_model_plugin"] = IAGFUNCTYPE(pUnk, IID_IDTM2020, vtable_offset_local+17, POINTER(agcom.PVOID))
        self.__dict__["_get_f_10_p7"] = IAGFUNCTYPE(pUnk, IID_IDTM2020, vtable_offset_local+18, POINTER(agcom.DOUBLE))
        self.__dict__["_set_f_10_p7"] = IAGFUNCTYPE(pUnk, IID_IDTM2020, vtable_offset_local+19, agcom.DOUBLE)
        self.__dict__["_get_kp"] = IAGFUNCTYPE(pUnk, IID_IDTM2020, vtable_offset_local+20, POINTER(agcom.DOUBLE))
        self.__dict__["_set_kp"] = IAGFUNCTYPE(pUnk, IID_IDTM2020, vtable_offset_local+21, agcom.DOUBLE)
        self.__dict__["_get_atmos_data_geo_magnetic_flux_source"] = IAGFUNCTYPE(pUnk, IID_IDTM2020, vtable_offset_local+22, POINTER(agcom.LONG))
        self.__dict__["_set_atmos_data_geo_magnetic_flux_source"] = IAGFUNCTYPE(pUnk, IID_IDTM2020, vtable_offset_local+23, agcom.LONG)
        self.__dict__["_get_atmos_data_geo_magnetic_flux_update_rate"] = IAGFUNCTYPE(pUnk, IID_IDTM2020, vtable_offset_local+24, POINTER(agcom.LONG))
        self.__dict__["_set_atmos_data_geo_magnetic_flux_update_rate"] = IAGFUNCTYPE(pUnk, IID_IDTM2020, vtable_offset_local+25, agcom.LONG)
        self.__dict__["_get_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IDTM2020, vtable_offset_local+26, POINTER(agcom.BSTR))
        self.__dict__["_set_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_IDTM2020, vtable_offset_local+27, agcom.BSTR)
        self.__dict__["_get_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IDTM2020, vtable_offset_local+28, POINTER(agcom.BSTR))
        self.__dict__["_set_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_IDTM2020, vtable_offset_local+29, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IDTM2020.__dict__ and type(IDTM2020.__dict__[attrname]) == property:
            return IDTM2020.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IDTM2020.")
    
    @property
    def use_approximate_altitude(self) -> bool:
        """True if using approximate altitude formula."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_approximate_altitude"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_approximate_altitude.setter
    def use_approximate_altitude(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_approximate_altitude"](arg_inVal.COM_val))

    @property
    def computes_temperature(self) -> bool:
        """Flag indicates whether this model computes temperature."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_temperature"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def computes_pressure(self) -> bool:
        """Flag indicates whether this model computes pressure."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_computes_pressure"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def sun_position(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sun_position"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sun_position.setter
    def sun_position(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_sun_position"](arg_inVal.COM_val))

    @property
    def atmos_data_source(self) -> "AgEVAAtmosDataSource":
        """The atmospheric model data source - data file or constant values."""
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_source.setter
    def atmos_data_source(self, inVal:"AgEVAAtmosDataSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAAtmosDataSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_source"](arg_inVal.COM_val))

    @property
    def f_10_p7_avg(self) -> float:
        """Average solar Flux (F10.7); the 81-day averaged Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_f_10_p7_avg"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @f_10_p7_avg.setter
    def f_10_p7_avg(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_f_10_p7_avg"](arg_inVal.COM_val))

    @property
    def atmos_data_filename(self) -> str:
        """Flux file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_filename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_filename.setter
    def atmos_data_filename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_filename"](arg_inVal.COM_val))

    @property
    def drag_model_type(self) -> "AgEVADragModelType":
        """Drag model type."""
        with agmarshall.AgEnum_arg(AgEVADragModelType) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_type.setter
    def drag_model_type(self, inVal:"AgEVADragModelType") -> None:
        with agmarshall.AgEnum_arg(AgEVADragModelType, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_type"](arg_inVal.COM_val))

    @property
    def drag_model_plugin_name(self) -> str:
        """The name of the drag model plugin."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @drag_model_plugin_name.setter
    def drag_model_plugin_name(self, pVal:str) -> None:
        with agmarshall.BSTR_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_drag_model_plugin_name"](arg_pVal.COM_val))

    @property
    def drag_model_plugin(self) -> "IDragModelPlugin":
        """Drag model plugin properties."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_drag_model_plugin"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def f_10_p7(self) -> float:
        """Solar Flux (F10.7); the daily Ottawa 10.7 cm solar flux value. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_f_10_p7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @f_10_p7.setter
    def f_10_p7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_f_10_p7"](arg_inVal.COM_val))

    @property
    def kp(self) -> float:
        """Geomagnetic Index (Kp). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_kp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @kp.setter
    def kp(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_kp"](arg_inVal.COM_val))

    @property
    def atmos_data_geo_magnetic_flux_source(self) -> "AgEVAGeoMagneticFluxSource":
        """Whether to use Kp or Ap data from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_geo_magnetic_flux_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_geo_magnetic_flux_source.setter
    def atmos_data_geo_magnetic_flux_source(self, inVal:"AgEVAGeoMagneticFluxSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_geo_magnetic_flux_source"](arg_inVal.COM_val))

    @property
    def atmos_data_geo_magnetic_flux_update_rate(self) -> "AgEVAGeoMagneticFluxUpdateRate":
        """The update rate of geomagnetic flux values from the flux file."""
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_data_geo_magnetic_flux_update_rate"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_data_geo_magnetic_flux_update_rate.setter
    def atmos_data_geo_magnetic_flux_update_rate(self, inVal:"AgEVAGeoMagneticFluxUpdateRate") -> None:
        with agmarshall.AgEnum_arg(AgEVAGeoMagneticFluxUpdateRate, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_data_geo_magnetic_flux_update_rate"](arg_inVal.COM_val))

    @property
    def variable_area_history_file(self) -> str:
        """Drag variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_variable_area_history_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @variable_area_history_file.setter
    def variable_area_history_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_variable_area_history_file"](arg_inVal.COM_val))

    @property
    def n_plate_definition_file(self) -> str:
        """Drag N-Plate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_n_plate_definition_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @n_plate_definition_file.setter
    def n_plate_definition_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_n_plate_definition_file"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{50AA8B32-1905-416D-B45E-631E78F5F174}", IDTM2020)
agcls.AgTypeNameMap["IDTM2020"] = IDTM2020

class IGravityFieldFunction(object):
    """Properties for the Gravitational Force gravity model - a complex gravitational force calculation, optionally including solid and ocean tide effects."""
    _uuid = "{B199E3B6-9964-4CAA-A824-1F106886E0DE}"
    _num_methods = 35
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_gravity_filename"] = _raise_uninitialized_error
        self.__dict__["_set_gravity_filename"] = _raise_uninitialized_error
        self.__dict__["_get_degree"] = _raise_uninitialized_error
        self.__dict__["_set_degree"] = _raise_uninitialized_error
        self.__dict__["_get_order"] = _raise_uninitialized_error
        self.__dict__["_set_order"] = _raise_uninitialized_error
        self.__dict__["_get_max_degree_text"] = _raise_uninitialized_error
        self.__dict__["_get_max_order_text"] = _raise_uninitialized_error
        self.__dict__["_get_include_time_dependent_solid_tides"] = _raise_uninitialized_error
        self.__dict__["_set_include_time_dependent_solid_tides"] = _raise_uninitialized_error
        self.__dict__["_get_solid_tide_min_amp"] = _raise_uninitialized_error
        self.__dict__["_set_solid_tide_min_amp"] = _raise_uninitialized_error
        self.__dict__["_get_use_ocean_tides"] = _raise_uninitialized_error
        self.__dict__["_set_use_ocean_tides"] = _raise_uninitialized_error
        self.__dict__["_get_ocean_tide_min_amp"] = _raise_uninitialized_error
        self.__dict__["_set_ocean_tide_min_amp"] = _raise_uninitialized_error
        self.__dict__["_get_min_radius_percent"] = _raise_uninitialized_error
        self.__dict__["_set_min_radius_percent"] = _raise_uninitialized_error
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_ocean_tide_max_degree"] = _raise_uninitialized_error
        self.__dict__["_set_ocean_tide_max_degree"] = _raise_uninitialized_error
        self.__dict__["_get_ocean_tide_max_order"] = _raise_uninitialized_error
        self.__dict__["_set_ocean_tide_max_order"] = _raise_uninitialized_error
        self.__dict__["_get_solid_tide_type"] = _raise_uninitialized_error
        self.__dict__["_set_solid_tide_type"] = _raise_uninitialized_error
        self.__dict__["_get_truncate_solid_tides"] = _raise_uninitialized_error
        self.__dict__["_set_truncate_solid_tides"] = _raise_uninitialized_error
        self.__dict__["_get_use_secular_variations"] = _raise_uninitialized_error
        self.__dict__["_set_use_secular_variations"] = _raise_uninitialized_error
        self.__dict__["_get_partials_degree"] = _raise_uninitialized_error
        self.__dict__["_set_partials_degree"] = _raise_uninitialized_error
        self.__dict__["_get_partials_order"] = _raise_uninitialized_error
        self.__dict__["_set_partials_order"] = _raise_uninitialized_error
        self.__dict__["_get_max_partials_degree_text"] = _raise_uninitialized_error
        self.__dict__["_get_max_partials_order_text"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IGravityFieldFunction._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IGravityFieldFunction from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IGravityFieldFunction = agcom.GUID(IGravityFieldFunction._uuid)
        vtable_offset_local = IGravityFieldFunction._vtable_offset - 1
        self.__dict__["_get_gravity_filename"] = IAGFUNCTYPE(pUnk, IID_IGravityFieldFunction, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_gravity_filename"] = IAGFUNCTYPE(pUnk, IID_IGravityFieldFunction, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_degree"] = IAGFUNCTYPE(pUnk, IID_IGravityFieldFunction, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_degree"] = IAGFUNCTYPE(pUnk, IID_IGravityFieldFunction, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_order"] = IAGFUNCTYPE(pUnk, IID_IGravityFieldFunction, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_order"] = IAGFUNCTYPE(pUnk, IID_IGravityFieldFunction, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_max_degree_text"] = IAGFUNCTYPE(pUnk, IID_IGravityFieldFunction, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_get_max_order_text"] = IAGFUNCTYPE(pUnk, IID_IGravityFieldFunction, vtable_offset_local+8, POINTER(agcom.BSTR))
        self.__dict__["_get_include_time_dependent_solid_tides"] = IAGFUNCTYPE(pUnk, IID_IGravityFieldFunction, vtable_offset_local+9, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_include_time_dependent_solid_tides"] = IAGFUNCTYPE(pUnk, IID_IGravityFieldFunction, vtable_offset_local+10, agcom.VARIANT_BOOL)
        self.__dict__["_get_solid_tide_min_amp"] = IAGFUNCTYPE(pUnk, IID_IGravityFieldFunction, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_solid_tide_min_amp"] = IAGFUNCTYPE(pUnk, IID_IGravityFieldFunction, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_use_ocean_tides"] = IAGFUNCTYPE(pUnk, IID_IGravityFieldFunction, vtable_offset_local+13, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_ocean_tides"] = IAGFUNCTYPE(pUnk, IID_IGravityFieldFunction, vtable_offset_local+14, agcom.VARIANT_BOOL)
        self.__dict__["_get_ocean_tide_min_amp"] = IAGFUNCTYPE(pUnk, IID_IGravityFieldFunction, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_ocean_tide_min_amp"] = IAGFUNCTYPE(pUnk, IID_IGravityFieldFunction, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_min_radius_percent"] = IAGFUNCTYPE(pUnk, IID_IGravityFieldFunction, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_min_radius_percent"] = IAGFUNCTYPE(pUnk, IID_IGravityFieldFunction, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IGravityFieldFunction, vtable_offset_local+19, POINTER(agcom.BSTR))
        self.__dict__["_get_ocean_tide_max_degree"] = IAGFUNCTYPE(pUnk, IID_IGravityFieldFunction, vtable_offset_local+20, POINTER(agcom.LONG))
        self.__dict__["_set_ocean_tide_max_degree"] = IAGFUNCTYPE(pUnk, IID_IGravityFieldFunction, vtable_offset_local+21, agcom.LONG)
        self.__dict__["_get_ocean_tide_max_order"] = IAGFUNCTYPE(pUnk, IID_IGravityFieldFunction, vtable_offset_local+22, POINTER(agcom.LONG))
        self.__dict__["_set_ocean_tide_max_order"] = IAGFUNCTYPE(pUnk, IID_IGravityFieldFunction, vtable_offset_local+23, agcom.LONG)
        self.__dict__["_get_solid_tide_type"] = IAGFUNCTYPE(pUnk, IID_IGravityFieldFunction, vtable_offset_local+24, POINTER(agcom.LONG))
        self.__dict__["_set_solid_tide_type"] = IAGFUNCTYPE(pUnk, IID_IGravityFieldFunction, vtable_offset_local+25, agcom.LONG)
        self.__dict__["_get_truncate_solid_tides"] = IAGFUNCTYPE(pUnk, IID_IGravityFieldFunction, vtable_offset_local+26, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_truncate_solid_tides"] = IAGFUNCTYPE(pUnk, IID_IGravityFieldFunction, vtable_offset_local+27, agcom.VARIANT_BOOL)
        self.__dict__["_get_use_secular_variations"] = IAGFUNCTYPE(pUnk, IID_IGravityFieldFunction, vtable_offset_local+28, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_secular_variations"] = IAGFUNCTYPE(pUnk, IID_IGravityFieldFunction, vtable_offset_local+29, agcom.VARIANT_BOOL)
        self.__dict__["_get_partials_degree"] = IAGFUNCTYPE(pUnk, IID_IGravityFieldFunction, vtable_offset_local+30, POINTER(agcom.LONG))
        self.__dict__["_set_partials_degree"] = IAGFUNCTYPE(pUnk, IID_IGravityFieldFunction, vtable_offset_local+31, agcom.LONG)
        self.__dict__["_get_partials_order"] = IAGFUNCTYPE(pUnk, IID_IGravityFieldFunction, vtable_offset_local+32, POINTER(agcom.LONG))
        self.__dict__["_set_partials_order"] = IAGFUNCTYPE(pUnk, IID_IGravityFieldFunction, vtable_offset_local+33, agcom.LONG)
        self.__dict__["_get_max_partials_degree_text"] = IAGFUNCTYPE(pUnk, IID_IGravityFieldFunction, vtable_offset_local+34, POINTER(agcom.BSTR))
        self.__dict__["_get_max_partials_order_text"] = IAGFUNCTYPE(pUnk, IID_IGravityFieldFunction, vtable_offset_local+35, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IGravityFieldFunction.__dict__ and type(IGravityFieldFunction.__dict__[attrname]) == property:
            return IGravityFieldFunction.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IGravityFieldFunction.")
    
    @property
    def gravity_filename(self) -> str:
        """The name of the file containing the gravity field."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_gravity_filename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @gravity_filename.setter
    def gravity_filename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_gravity_filename"](arg_inVal.COM_val))

    @property
    def degree(self) -> int:
        """The degree of geopotential coefficients to be included for Central Body gravity computations. Valid range is from 0 to 90, depending on the gravity model. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_degree"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @degree.setter
    def degree(self, inVal:int) -> None:
        with agmarshall.LONG_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_degree"](arg_inVal.COM_val))

    @property
    def order(self) -> int:
        """The order of geopotential coefficients to be included for Central Body gravity computations. Valid range is from 0 to 90, depending on the gravity model. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_order"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @order.setter
    def order(self, inVal:int) -> None:
        with agmarshall.LONG_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_order"](arg_inVal.COM_val))

    @property
    def max_degree_text(self) -> str:
        """Displays the maximum degree permissible for the gravity model."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_degree_text"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def max_order_text(self) -> str:
        """Displays the maximum order permissible for the gravity model."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_order_text"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def include_time_dependent_solid_tides(self) -> bool:
        """True if including time dependent solid tides."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_include_time_dependent_solid_tides"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @include_time_dependent_solid_tides.setter
    def include_time_dependent_solid_tides(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_include_time_dependent_solid_tides"](arg_inVal.COM_val))

    @property
    def solid_tide_min_amp(self) -> float:
        """The minimum amplitude for solid tides; contributors that are below the minimum amplitude will not be factored into the computation. Uses SmallDistance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_solid_tide_min_amp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @solid_tide_min_amp.setter
    def solid_tide_min_amp(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_solid_tide_min_amp"](arg_inVal.COM_val))

    @property
    def use_ocean_tides(self) -> bool:
        """True if using ocean tides/"""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_ocean_tides"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_ocean_tides.setter
    def use_ocean_tides(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_ocean_tides"](arg_inVal.COM_val))

    @property
    def ocean_tide_min_amp(self) -> float:
        """The minimum amplitude for ocean tides; contributors that are below the minimum amplitude will not be factored into the computation. Uses SmallDistance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_ocean_tide_min_amp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ocean_tide_min_amp.setter
    def ocean_tide_min_amp(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_ocean_tide_min_amp"](arg_inVal.COM_val))

    @property
    def min_radius_percent(self) -> float:
        """The percentage of the central body's minimum radius at which a modified force model (only the two-body force) will be used - provided there is no altitude stopping condition. Uses Percent Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_radius_percent"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @min_radius_percent.setter
    def min_radius_percent(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_min_radius_percent"](arg_inVal.COM_val))

    @property
    def central_body_name(self) -> str:
        """The name of the central body"""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ocean_tide_max_degree(self) -> int:
        """The maximum degree for force contributions from ocean tides that will be included in the computation. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_ocean_tide_max_degree"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ocean_tide_max_degree.setter
    def ocean_tide_max_degree(self, inVal:int) -> None:
        with agmarshall.LONG_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_ocean_tide_max_degree"](arg_inVal.COM_val))

    @property
    def ocean_tide_max_order(self) -> int:
        """The maximum order for force contributions from ocean tides that will be included in the computation. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_ocean_tide_max_order"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ocean_tide_max_order.setter
    def ocean_tide_max_order(self, inVal:int) -> None:
        with agmarshall.LONG_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_ocean_tide_max_order"](arg_inVal.COM_val))

    @property
    def solid_tide_type(self) -> "AgESolidTide":
        """The type of solid tide contribution to be modeled."""
        with agmarshall.AgEnum_arg(AgESolidTide) as arg_pSolidTide:
            agcls.evaluate_hresult(self.__dict__["_get_solid_tide_type"](byref(arg_pSolidTide.COM_val)))
            return arg_pSolidTide.python_val

    @solid_tide_type.setter
    def solid_tide_type(self, solidTide:"AgESolidTide") -> None:
        with agmarshall.AgEnum_arg(AgESolidTide, solidTide) as arg_solidTide:
            agcls.evaluate_hresult(self.__dict__["_set_solid_tide_type"](arg_solidTide.COM_val))

    @property
    def truncate_solid_tides(self) -> bool:
        """True if solid tide terms (including permanent tide) won't be included beyond the degree and order selected for the gravity model."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_truncate_solid_tides"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @truncate_solid_tides.setter
    def truncate_solid_tides(self, pVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_truncate_solid_tides"](arg_pVal.COM_val))

    @property
    def use_secular_variations(self) -> bool:
        """Opt whether to include or ignore secular variations defined by the gravity field model."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_secular_variations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_secular_variations.setter
    def use_secular_variations(self, pVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(pVal) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_secular_variations"](arg_pVal.COM_val))

    @property
    def partials_degree(self) -> int:
        """The degree of geopotential coefficients to be included for Central Body gravity state transition matrix computations. Valid range is from 0 to 90, depending on the gravity model and the degree used for state computations. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_partials_degree"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @partials_degree.setter
    def partials_degree(self, inVal:int) -> None:
        with agmarshall.LONG_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_partials_degree"](arg_inVal.COM_val))

    @property
    def partials_order(self) -> int:
        """The order of geopotential coefficients to be included for Central Body gravity state transition matrix computations. Valid range is from 0 to 90, depending on the gravity model and the order used for state computations. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_partials_order"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @partials_order.setter
    def partials_order(self, inVal:int) -> None:
        with agmarshall.LONG_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_partials_order"](arg_inVal.COM_val))

    @property
    def max_partials_degree_text(self) -> str:
        """Displays the maximum degree permissible for the gravity model partials used in the STM."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_partials_degree_text"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def max_partials_order_text(self) -> str:
        """Displays the maximum order permissible for the gravity model partials used in the STM."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_partials_order_text"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{B199E3B6-9964-4CAA-A824-1F106886E0DE}", IGravityFieldFunction)
agcls.AgTypeNameMap["IGravityFieldFunction"] = IGravityFieldFunction

class IPointMassFunction(object):
    """Properties for the Point Mass Function."""
    _uuid = "{DF0A48DA-12AA-4BCF-A9E1-CDE80A2C89A3}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_grav_source"] = _raise_uninitialized_error
        self.__dict__["_set_grav_source"] = _raise_uninitialized_error
        self.__dict__["_get_mu"] = _raise_uninitialized_error
        self.__dict__["_set_mu"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPointMassFunction._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPointMassFunction from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPointMassFunction = agcom.GUID(IPointMassFunction._uuid)
        vtable_offset_local = IPointMassFunction._vtable_offset - 1
        self.__dict__["_get_grav_source"] = IAGFUNCTYPE(pUnk, IID_IPointMassFunction, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_grav_source"] = IAGFUNCTYPE(pUnk, IID_IPointMassFunction, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_mu"] = IAGFUNCTYPE(pUnk, IID_IPointMassFunction, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_mu"] = IAGFUNCTYPE(pUnk, IID_IPointMassFunction, vtable_offset_local+4, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPointMassFunction.__dict__ and type(IPointMassFunction.__dict__[attrname]) == property:
            return IPointMassFunction.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPointMassFunction.")
    
    @property
    def grav_source(self) -> "AgEVAGravParamSource":
        """The source for the third body's gravitational parameter."""
        with agmarshall.AgEnum_arg(AgEVAGravParamSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_grav_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @grav_source.setter
    def grav_source(self, inVal:"AgEVAGravParamSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAGravParamSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_grav_source"](arg_inVal.COM_val))

    @property
    def mu(self) -> float:
        """The gravitational parameter. Uses Gravity Param Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_mu"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @mu.setter
    def mu(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_mu"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{DF0A48DA-12AA-4BCF-A9E1-CDE80A2C89A3}", IPointMassFunction)
agcls.AgTypeNameMap["IPointMassFunction"] = IPointMassFunction

class ITwoBodyFunction(object):
    """Properties for the Two Body gravity model - a standard point mass model."""
    _uuid = "{827AF54A-9389-4151-8193-7B3FAE64E66D}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_grav_source"] = _raise_uninitialized_error
        self.__dict__["_set_grav_source"] = _raise_uninitialized_error
        self.__dict__["_get_mu"] = _raise_uninitialized_error
        self.__dict__["_set_mu"] = _raise_uninitialized_error
        self.__dict__["_get_min_radius_percent"] = _raise_uninitialized_error
        self.__dict__["_set_min_radius_percent"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ITwoBodyFunction._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ITwoBodyFunction from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ITwoBodyFunction = agcom.GUID(ITwoBodyFunction._uuid)
        vtable_offset_local = ITwoBodyFunction._vtable_offset - 1
        self.__dict__["_get_grav_source"] = IAGFUNCTYPE(pUnk, IID_ITwoBodyFunction, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_grav_source"] = IAGFUNCTYPE(pUnk, IID_ITwoBodyFunction, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_mu"] = IAGFUNCTYPE(pUnk, IID_ITwoBodyFunction, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_mu"] = IAGFUNCTYPE(pUnk, IID_ITwoBodyFunction, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_min_radius_percent"] = IAGFUNCTYPE(pUnk, IID_ITwoBodyFunction, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_min_radius_percent"] = IAGFUNCTYPE(pUnk, IID_ITwoBodyFunction, vtable_offset_local+6, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ITwoBodyFunction.__dict__ and type(ITwoBodyFunction.__dict__[attrname]) == property:
            return ITwoBodyFunction.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ITwoBodyFunction.")
    
    @property
    def grav_source(self) -> "AgEVAGravParamSource":
        """The source for the gravitational parameter."""
        with agmarshall.AgEnum_arg(AgEVAGravParamSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_grav_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @grav_source.setter
    def grav_source(self, inVal:"AgEVAGravParamSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAGravParamSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_grav_source"](arg_inVal.COM_val))

    @property
    def mu(self) -> float:
        """The gravitational parameter. Uses Gravity Param Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_mu"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @mu.setter
    def mu(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_mu"](arg_inVal.COM_val))

    @property
    def min_radius_percent(self) -> float:
        """The percentage of the central body's minimum radius at which a modified force model (only the two-body force) will be used - provided there is no altitude stopping condition. Uses Percent Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_radius_percent"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @min_radius_percent.setter
    def min_radius_percent(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_min_radius_percent"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{827AF54A-9389-4151-8193-7B3FAE64E66D}", ITwoBodyFunction)
agcls.AgTypeNameMap["ITwoBodyFunction"] = ITwoBodyFunction

class IHPOPPluginFunction(object):
    """Properties for the HPOP Plugin propagator function."""
    _uuid = "{53854E6C-8125-44F8-B0B3-8CB5175C8AE9}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_plugin_identifier"] = _raise_uninitialized_error
        self.__dict__["_set_plugin_identifier"] = _raise_uninitialized_error
        self.__dict__["_get_plugin_config"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IHPOPPluginFunction._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IHPOPPluginFunction from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IHPOPPluginFunction = agcom.GUID(IHPOPPluginFunction._uuid)
        vtable_offset_local = IHPOPPluginFunction._vtable_offset - 1
        self.__dict__["_get_plugin_identifier"] = IAGFUNCTYPE(pUnk, IID_IHPOPPluginFunction, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_plugin_identifier"] = IAGFUNCTYPE(pUnk, IID_IHPOPPluginFunction, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_plugin_config"] = IAGFUNCTYPE(pUnk, IID_IHPOPPluginFunction, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IHPOPPluginFunction.__dict__ and type(IHPOPPluginFunction.__dict__[attrname]) == property:
            return IHPOPPluginFunction.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IHPOPPluginFunction.")
    
    @property
    def plugin_identifier(self) -> str:
        """The plugin name."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_plugin_identifier"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @plugin_identifier.setter
    def plugin_identifier(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_plugin_identifier"](arg_inVal.COM_val))

    @property
    def plugin_config(self) -> "IPluginProperties":
        """The properties of the selected plugin."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_plugin_config"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{53854E6C-8125-44F8-B0B3-8CB5175C8AE9}", IHPOPPluginFunction)
agcls.AgTypeNameMap["IHPOPPluginFunction"] = IHPOPPluginFunction

class IEOMFuncPluginFunction(object):
    """Properties for the EOM Function Plugin propagator function."""
    _uuid = "{D652969D-D848-4AF2-91C9-8BD479D0F681}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_plugin_identifier"] = _raise_uninitialized_error
        self.__dict__["_set_plugin_identifier"] = _raise_uninitialized_error
        self.__dict__["_get_plugin_config"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEOMFuncPluginFunction._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEOMFuncPluginFunction from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEOMFuncPluginFunction = agcom.GUID(IEOMFuncPluginFunction._uuid)
        vtable_offset_local = IEOMFuncPluginFunction._vtable_offset - 1
        self.__dict__["_get_plugin_identifier"] = IAGFUNCTYPE(pUnk, IID_IEOMFuncPluginFunction, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_plugin_identifier"] = IAGFUNCTYPE(pUnk, IID_IEOMFuncPluginFunction, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_plugin_config"] = IAGFUNCTYPE(pUnk, IID_IEOMFuncPluginFunction, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEOMFuncPluginFunction.__dict__ and type(IEOMFuncPluginFunction.__dict__[attrname]) == property:
            return IEOMFuncPluginFunction.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEOMFuncPluginFunction.")
    
    @property
    def plugin_identifier(self) -> str:
        """The plugin name."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_plugin_identifier"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @plugin_identifier.setter
    def plugin_identifier(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_plugin_identifier"](arg_inVal.COM_val))

    @property
    def plugin_config(self) -> "IPluginProperties":
        """The properties of the selected plugin."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_plugin_config"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{D652969D-D848-4AF2-91C9-8BD479D0F681}", IEOMFuncPluginFunction)
agcls.AgTypeNameMap["IEOMFuncPluginFunction"] = IEOMFuncPluginFunction

class ISRPAeroT20(object):
    """Properties for the Aerospace T20 solar radiation pressure model for GPS block IIA."""
    _uuid = "{1B712154-4552-4453-B784-5C773A9F88C0}"
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_atmos_alt"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_alt"] = _raise_uninitialized_error
        self.__dict__["_get_shadow_model"] = _raise_uninitialized_error
        self.__dict__["_set_shadow_model"] = _raise_uninitialized_error
        self.__dict__["_get_sun_position"] = _raise_uninitialized_error
        self.__dict__["_set_sun_position"] = _raise_uninitialized_error
        self.__dict__["_get_eclipsing_bodies"] = _raise_uninitialized_error
        self.__dict__["_get_include_boundary_mitigation"] = _raise_uninitialized_error
        self.__dict__["_set_include_boundary_mitigation"] = _raise_uninitialized_error
        self.__dict__["_get_use_sun_cb_file_values"] = _raise_uninitialized_error
        self.__dict__["_set_use_sun_cb_file_values"] = _raise_uninitialized_error
        self.__dict__["_get_solar_radius"] = _raise_uninitialized_error
        self.__dict__["_set_solar_radius"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISRPAeroT20._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISRPAeroT20 from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISRPAeroT20 = agcom.GUID(ISRPAeroT20._uuid)
        vtable_offset_local = ISRPAeroT20._vtable_offset - 1
        self.__dict__["_get_atmos_alt"] = IAGFUNCTYPE(pUnk, IID_ISRPAeroT20, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_atmos_alt"] = IAGFUNCTYPE(pUnk, IID_ISRPAeroT20, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_shadow_model"] = IAGFUNCTYPE(pUnk, IID_ISRPAeroT20, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_shadow_model"] = IAGFUNCTYPE(pUnk, IID_ISRPAeroT20, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_sun_position"] = IAGFUNCTYPE(pUnk, IID_ISRPAeroT20, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_sun_position"] = IAGFUNCTYPE(pUnk, IID_ISRPAeroT20, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_eclipsing_bodies"] = IAGFUNCTYPE(pUnk, IID_ISRPAeroT20, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_get_include_boundary_mitigation"] = IAGFUNCTYPE(pUnk, IID_ISRPAeroT20, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_include_boundary_mitigation"] = IAGFUNCTYPE(pUnk, IID_ISRPAeroT20, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_get_use_sun_cb_file_values"] = IAGFUNCTYPE(pUnk, IID_ISRPAeroT20, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_sun_cb_file_values"] = IAGFUNCTYPE(pUnk, IID_ISRPAeroT20, vtable_offset_local+11, agcom.VARIANT_BOOL)
        self.__dict__["_get_solar_radius"] = IAGFUNCTYPE(pUnk, IID_ISRPAeroT20, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_set_solar_radius"] = IAGFUNCTYPE(pUnk, IID_ISRPAeroT20, vtable_offset_local+13, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISRPAeroT20.__dict__ and type(ISRPAeroT20.__dict__[attrname]) == property:
            return ISRPAeroT20.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISRPAeroT20.")
    
    @property
    def atmos_alt(self) -> float:
        """The atmospheric altitude for eclipse. A simple model to account for some measure of attenuation that simply increases the shape of the Earth by the defined altitude height, often taken to be 23 km. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_alt"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_alt.setter
    def atmos_alt(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_alt"](arg_inVal.COM_val))

    @property
    def shadow_model(self) -> "AgEVAShadowModel":
        """The shadow model type."""
        with agmarshall.AgEnum_arg(AgEVAShadowModel) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_shadow_model"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @shadow_model.setter
    def shadow_model(self, inVal:"AgEVAShadowModel") -> None:
        with agmarshall.AgEnum_arg(AgEVAShadowModel, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_shadow_model"](arg_inVal.COM_val))

    @property
    def sun_position(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sun_position"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sun_position.setter
    def sun_position(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_sun_position"](arg_inVal.COM_val))

    @property
    def eclipsing_bodies(self) -> "ICentralBodyCollection":
        """Other eclipsing bodies."""
        with agmarshall.AgInterface_out_arg() as arg_ppCentralBodyCollection:
            agcls.evaluate_hresult(self.__dict__["_get_eclipsing_bodies"](byref(arg_ppCentralBodyCollection.COM_val)))
            return arg_ppCentralBodyCollection.python_val

    @property
    def include_boundary_mitigation(self) -> bool:
        """True if shadow boundary mitigation should be performed; the state of the satellite after crossing a shadow boundary will be corrected for errors possibly caused by the sudden change in SRP which occurred during the integration step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pMitigation:
            agcls.evaluate_hresult(self.__dict__["_get_include_boundary_mitigation"](byref(arg_pMitigation.COM_val)))
            return arg_pMitigation.python_val

    @include_boundary_mitigation.setter
    def include_boundary_mitigation(self, mitigation:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(mitigation) as arg_mitigation:
            agcls.evaluate_hresult(self.__dict__["_set_include_boundary_mitigation"](arg_mitigation.COM_val))

    @property
    def use_sun_cb_file_values(self) -> bool:
        """True if solar radius should come from the Sun.cb file."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_sun_cb_file_values"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_sun_cb_file_values.setter
    def use_sun_cb_file_values(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_sun_cb_file_values"](arg_inVal.COM_val))

    @property
    def solar_radius(self) -> float:
        """The solar radius value to use in eclipse calculations.  Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_solar_radius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @solar_radius.setter
    def solar_radius(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_solar_radius"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{1B712154-4552-4453-B784-5C773A9F88C0}", ISRPAeroT20)
agcls.AgTypeNameMap["ISRPAeroT20"] = ISRPAeroT20

class ISRPAeroT30(object):
    """Properties for the Aerospace T30 solar radiation pressure model for GPS block IIR."""
    _uuid = "{E29DBFD3-883F-465C-A4D4-D090A83F5EBC}"
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_atmos_alt"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_alt"] = _raise_uninitialized_error
        self.__dict__["_get_shadow_model"] = _raise_uninitialized_error
        self.__dict__["_set_shadow_model"] = _raise_uninitialized_error
        self.__dict__["_get_sun_position"] = _raise_uninitialized_error
        self.__dict__["_set_sun_position"] = _raise_uninitialized_error
        self.__dict__["_get_eclipsing_bodies"] = _raise_uninitialized_error
        self.__dict__["_get_include_boundary_mitigation"] = _raise_uninitialized_error
        self.__dict__["_set_include_boundary_mitigation"] = _raise_uninitialized_error
        self.__dict__["_get_use_sun_cb_file_values"] = _raise_uninitialized_error
        self.__dict__["_set_use_sun_cb_file_values"] = _raise_uninitialized_error
        self.__dict__["_get_solar_radius"] = _raise_uninitialized_error
        self.__dict__["_set_solar_radius"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISRPAeroT30._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISRPAeroT30 from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISRPAeroT30 = agcom.GUID(ISRPAeroT30._uuid)
        vtable_offset_local = ISRPAeroT30._vtable_offset - 1
        self.__dict__["_get_atmos_alt"] = IAGFUNCTYPE(pUnk, IID_ISRPAeroT30, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_atmos_alt"] = IAGFUNCTYPE(pUnk, IID_ISRPAeroT30, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_shadow_model"] = IAGFUNCTYPE(pUnk, IID_ISRPAeroT30, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_shadow_model"] = IAGFUNCTYPE(pUnk, IID_ISRPAeroT30, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_sun_position"] = IAGFUNCTYPE(pUnk, IID_ISRPAeroT30, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_sun_position"] = IAGFUNCTYPE(pUnk, IID_ISRPAeroT30, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_eclipsing_bodies"] = IAGFUNCTYPE(pUnk, IID_ISRPAeroT30, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_get_include_boundary_mitigation"] = IAGFUNCTYPE(pUnk, IID_ISRPAeroT30, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_include_boundary_mitigation"] = IAGFUNCTYPE(pUnk, IID_ISRPAeroT30, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_get_use_sun_cb_file_values"] = IAGFUNCTYPE(pUnk, IID_ISRPAeroT30, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_sun_cb_file_values"] = IAGFUNCTYPE(pUnk, IID_ISRPAeroT30, vtable_offset_local+11, agcom.VARIANT_BOOL)
        self.__dict__["_get_solar_radius"] = IAGFUNCTYPE(pUnk, IID_ISRPAeroT30, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_set_solar_radius"] = IAGFUNCTYPE(pUnk, IID_ISRPAeroT30, vtable_offset_local+13, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISRPAeroT30.__dict__ and type(ISRPAeroT30.__dict__[attrname]) == property:
            return ISRPAeroT30.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISRPAeroT30.")
    
    @property
    def atmos_alt(self) -> float:
        """The atmospheric altitude for eclipse. A simple model to account for some measure of attenuation that simply increases the shape of the Earth by the defined altitude height, often taken to be 23 km. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_alt"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_alt.setter
    def atmos_alt(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_alt"](arg_inVal.COM_val))

    @property
    def shadow_model(self) -> "AgEVAShadowModel":
        """The shadow model type."""
        with agmarshall.AgEnum_arg(AgEVAShadowModel) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_shadow_model"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @shadow_model.setter
    def shadow_model(self, inVal:"AgEVAShadowModel") -> None:
        with agmarshall.AgEnum_arg(AgEVAShadowModel, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_shadow_model"](arg_inVal.COM_val))

    @property
    def sun_position(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sun_position"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sun_position.setter
    def sun_position(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_sun_position"](arg_inVal.COM_val))

    @property
    def eclipsing_bodies(self) -> "ICentralBodyCollection":
        """Other eclipsing bodies."""
        with agmarshall.AgInterface_out_arg() as arg_ppCentralBodyCollection:
            agcls.evaluate_hresult(self.__dict__["_get_eclipsing_bodies"](byref(arg_ppCentralBodyCollection.COM_val)))
            return arg_ppCentralBodyCollection.python_val

    @property
    def include_boundary_mitigation(self) -> bool:
        """True if shadow boundary mitigation should be performed; the state of the satellite after crossing a shadow boundary will be corrected for errors possibly caused by the sudden change in SRP which occurred during the integration step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pMitigation:
            agcls.evaluate_hresult(self.__dict__["_get_include_boundary_mitigation"](byref(arg_pMitigation.COM_val)))
            return arg_pMitigation.python_val

    @include_boundary_mitigation.setter
    def include_boundary_mitigation(self, mitigation:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(mitigation) as arg_mitigation:
            agcls.evaluate_hresult(self.__dict__["_set_include_boundary_mitigation"](arg_mitigation.COM_val))

    @property
    def use_sun_cb_file_values(self) -> bool:
        """True if solar radius should come from the Sun.cb file."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_sun_cb_file_values"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_sun_cb_file_values.setter
    def use_sun_cb_file_values(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_sun_cb_file_values"](arg_inVal.COM_val))

    @property
    def solar_radius(self) -> float:
        """The solar radius value to use in eclipse calculations.  Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_solar_radius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @solar_radius.setter
    def solar_radius(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_solar_radius"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E29DBFD3-883F-465C-A4D4-D090A83F5EBC}", ISRPAeroT30)
agcls.AgTypeNameMap["ISRPAeroT30"] = ISRPAeroT30

class ISRPGSPM04aIIA(object):
    """Properties for the Bar-Sever GPS Solar Pressure Model 04a for block IIA."""
    _uuid = "{73504326-18B8-40FB-A466-DB8908769B9D}"
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_atmos_alt"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_alt"] = _raise_uninitialized_error
        self.__dict__["_get_shadow_model"] = _raise_uninitialized_error
        self.__dict__["_set_shadow_model"] = _raise_uninitialized_error
        self.__dict__["_get_sun_position"] = _raise_uninitialized_error
        self.__dict__["_set_sun_position"] = _raise_uninitialized_error
        self.__dict__["_get_eclipsing_bodies"] = _raise_uninitialized_error
        self.__dict__["_get_include_boundary_mitigation"] = _raise_uninitialized_error
        self.__dict__["_set_include_boundary_mitigation"] = _raise_uninitialized_error
        self.__dict__["_get_use_sun_cb_file_values"] = _raise_uninitialized_error
        self.__dict__["_set_use_sun_cb_file_values"] = _raise_uninitialized_error
        self.__dict__["_get_solar_radius"] = _raise_uninitialized_error
        self.__dict__["_set_solar_radius"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISRPGSPM04aIIA._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISRPGSPM04aIIA from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISRPGSPM04aIIA = agcom.GUID(ISRPGSPM04aIIA._uuid)
        vtable_offset_local = ISRPGSPM04aIIA._vtable_offset - 1
        self.__dict__["_get_atmos_alt"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aIIA, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_atmos_alt"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aIIA, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_shadow_model"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aIIA, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_shadow_model"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aIIA, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_sun_position"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aIIA, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_sun_position"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aIIA, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_eclipsing_bodies"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aIIA, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_get_include_boundary_mitigation"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aIIA, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_include_boundary_mitigation"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aIIA, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_get_use_sun_cb_file_values"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aIIA, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_sun_cb_file_values"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aIIA, vtable_offset_local+11, agcom.VARIANT_BOOL)
        self.__dict__["_get_solar_radius"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aIIA, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_set_solar_radius"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aIIA, vtable_offset_local+13, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISRPGSPM04aIIA.__dict__ and type(ISRPGSPM04aIIA.__dict__[attrname]) == property:
            return ISRPGSPM04aIIA.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISRPGSPM04aIIA.")
    
    @property
    def atmos_alt(self) -> float:
        """The atmospheric altitude for eclipse. A simple model to account for some measure of attenuation that simply increases the shape of the Earth by the defined altitude height, often taken to be 23 km. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_alt"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_alt.setter
    def atmos_alt(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_alt"](arg_inVal.COM_val))

    @property
    def shadow_model(self) -> "AgEVAShadowModel":
        """The shadow model type."""
        with agmarshall.AgEnum_arg(AgEVAShadowModel) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_shadow_model"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @shadow_model.setter
    def shadow_model(self, inVal:"AgEVAShadowModel") -> None:
        with agmarshall.AgEnum_arg(AgEVAShadowModel, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_shadow_model"](arg_inVal.COM_val))

    @property
    def sun_position(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sun_position"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sun_position.setter
    def sun_position(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_sun_position"](arg_inVal.COM_val))

    @property
    def eclipsing_bodies(self) -> "ICentralBodyCollection":
        """Other eclipsing bodies."""
        with agmarshall.AgInterface_out_arg() as arg_ppCentralBodyCollection:
            agcls.evaluate_hresult(self.__dict__["_get_eclipsing_bodies"](byref(arg_ppCentralBodyCollection.COM_val)))
            return arg_ppCentralBodyCollection.python_val

    @property
    def include_boundary_mitigation(self) -> bool:
        """True if shadow boundary mitigation should be performed; the state of the satellite after crossing a shadow boundary will be corrected for errors possibly caused by the sudden change in SRP which occurred during the integration step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pMitigation:
            agcls.evaluate_hresult(self.__dict__["_get_include_boundary_mitigation"](byref(arg_pMitigation.COM_val)))
            return arg_pMitigation.python_val

    @include_boundary_mitigation.setter
    def include_boundary_mitigation(self, mitigation:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(mitigation) as arg_mitigation:
            agcls.evaluate_hresult(self.__dict__["_set_include_boundary_mitigation"](arg_mitigation.COM_val))

    @property
    def use_sun_cb_file_values(self) -> bool:
        """True if solar radius should come from the Sun.cb file."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_sun_cb_file_values"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_sun_cb_file_values.setter
    def use_sun_cb_file_values(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_sun_cb_file_values"](arg_inVal.COM_val))

    @property
    def solar_radius(self) -> float:
        """The solar radius value to use in eclipse calculations.  Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_solar_radius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @solar_radius.setter
    def solar_radius(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_solar_radius"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{73504326-18B8-40FB-A466-DB8908769B9D}", ISRPGSPM04aIIA)
agcls.AgTypeNameMap["ISRPGSPM04aIIA"] = ISRPGSPM04aIIA

class ISRPGSPM04aIIR(object):
    """Properties for the Bar-Sever GPS Solar Pressure Model 04a for block IIR."""
    _uuid = "{79FEA80C-9B5F-4FDE-9661-286B1DAFF645}"
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_atmos_alt"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_alt"] = _raise_uninitialized_error
        self.__dict__["_get_shadow_model"] = _raise_uninitialized_error
        self.__dict__["_set_shadow_model"] = _raise_uninitialized_error
        self.__dict__["_get_sun_position"] = _raise_uninitialized_error
        self.__dict__["_set_sun_position"] = _raise_uninitialized_error
        self.__dict__["_get_eclipsing_bodies"] = _raise_uninitialized_error
        self.__dict__["_get_include_boundary_mitigation"] = _raise_uninitialized_error
        self.__dict__["_set_include_boundary_mitigation"] = _raise_uninitialized_error
        self.__dict__["_get_use_sun_cb_file_values"] = _raise_uninitialized_error
        self.__dict__["_set_use_sun_cb_file_values"] = _raise_uninitialized_error
        self.__dict__["_get_solar_radius"] = _raise_uninitialized_error
        self.__dict__["_set_solar_radius"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISRPGSPM04aIIR._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISRPGSPM04aIIR from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISRPGSPM04aIIR = agcom.GUID(ISRPGSPM04aIIR._uuid)
        vtable_offset_local = ISRPGSPM04aIIR._vtable_offset - 1
        self.__dict__["_get_atmos_alt"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aIIR, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_atmos_alt"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aIIR, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_shadow_model"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aIIR, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_shadow_model"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aIIR, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_sun_position"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aIIR, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_sun_position"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aIIR, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_eclipsing_bodies"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aIIR, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_get_include_boundary_mitigation"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aIIR, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_include_boundary_mitigation"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aIIR, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_get_use_sun_cb_file_values"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aIIR, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_sun_cb_file_values"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aIIR, vtable_offset_local+11, agcom.VARIANT_BOOL)
        self.__dict__["_get_solar_radius"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aIIR, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_set_solar_radius"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aIIR, vtable_offset_local+13, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISRPGSPM04aIIR.__dict__ and type(ISRPGSPM04aIIR.__dict__[attrname]) == property:
            return ISRPGSPM04aIIR.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISRPGSPM04aIIR.")
    
    @property
    def atmos_alt(self) -> float:
        """The atmospheric altitude for eclipse. A simple model to account for some measure of attenuation that simply increases the shape of the Earth by the defined altitude height, often taken to be 23 km. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_alt"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_alt.setter
    def atmos_alt(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_alt"](arg_inVal.COM_val))

    @property
    def shadow_model(self) -> "AgEVAShadowModel":
        """The shadow model type."""
        with agmarshall.AgEnum_arg(AgEVAShadowModel) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_shadow_model"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @shadow_model.setter
    def shadow_model(self, inVal:"AgEVAShadowModel") -> None:
        with agmarshall.AgEnum_arg(AgEVAShadowModel, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_shadow_model"](arg_inVal.COM_val))

    @property
    def sun_position(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sun_position"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sun_position.setter
    def sun_position(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_sun_position"](arg_inVal.COM_val))

    @property
    def eclipsing_bodies(self) -> "ICentralBodyCollection":
        """Other eclipsing bodies."""
        with agmarshall.AgInterface_out_arg() as arg_ppCentralBodyCollection:
            agcls.evaluate_hresult(self.__dict__["_get_eclipsing_bodies"](byref(arg_ppCentralBodyCollection.COM_val)))
            return arg_ppCentralBodyCollection.python_val

    @property
    def include_boundary_mitigation(self) -> bool:
        """True if shadow boundary mitigation should be performed; the state of the satellite after crossing a shadow boundary will be corrected for errors possibly caused by the sudden change in SRP which occurred during the integration step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pMitigation:
            agcls.evaluate_hresult(self.__dict__["_get_include_boundary_mitigation"](byref(arg_pMitigation.COM_val)))
            return arg_pMitigation.python_val

    @include_boundary_mitigation.setter
    def include_boundary_mitigation(self, mitigation:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(mitigation) as arg_mitigation:
            agcls.evaluate_hresult(self.__dict__["_set_include_boundary_mitigation"](arg_mitigation.COM_val))

    @property
    def use_sun_cb_file_values(self) -> bool:
        """True if solar radius should come from the Sun.cb file."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_sun_cb_file_values"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_sun_cb_file_values.setter
    def use_sun_cb_file_values(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_sun_cb_file_values"](arg_inVal.COM_val))

    @property
    def solar_radius(self) -> float:
        """The solar radius value to use in eclipse calculations.  Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_solar_radius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @solar_radius.setter
    def solar_radius(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_solar_radius"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{79FEA80C-9B5F-4FDE-9661-286B1DAFF645}", ISRPGSPM04aIIR)
agcls.AgTypeNameMap["ISRPGSPM04aIIR"] = ISRPGSPM04aIIR

class ISRPGSPM04aeIIA(object):
    """Properties for the Bar-Sever GPS Solar Pressure Model 04ae for block IIA."""
    _uuid = "{3F99DF3B-1BC5-40F2-826D-751DCE4BB77C}"
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_atmos_alt"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_alt"] = _raise_uninitialized_error
        self.__dict__["_get_shadow_model"] = _raise_uninitialized_error
        self.__dict__["_set_shadow_model"] = _raise_uninitialized_error
        self.__dict__["_get_sun_position"] = _raise_uninitialized_error
        self.__dict__["_set_sun_position"] = _raise_uninitialized_error
        self.__dict__["_get_eclipsing_bodies"] = _raise_uninitialized_error
        self.__dict__["_get_include_boundary_mitigation"] = _raise_uninitialized_error
        self.__dict__["_set_include_boundary_mitigation"] = _raise_uninitialized_error
        self.__dict__["_get_use_sun_cb_file_values"] = _raise_uninitialized_error
        self.__dict__["_set_use_sun_cb_file_values"] = _raise_uninitialized_error
        self.__dict__["_get_solar_radius"] = _raise_uninitialized_error
        self.__dict__["_set_solar_radius"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISRPGSPM04aeIIA._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISRPGSPM04aeIIA from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISRPGSPM04aeIIA = agcom.GUID(ISRPGSPM04aeIIA._uuid)
        vtable_offset_local = ISRPGSPM04aeIIA._vtable_offset - 1
        self.__dict__["_get_atmos_alt"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aeIIA, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_atmos_alt"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aeIIA, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_shadow_model"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aeIIA, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_shadow_model"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aeIIA, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_sun_position"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aeIIA, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_sun_position"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aeIIA, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_eclipsing_bodies"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aeIIA, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_get_include_boundary_mitigation"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aeIIA, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_include_boundary_mitigation"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aeIIA, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_get_use_sun_cb_file_values"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aeIIA, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_sun_cb_file_values"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aeIIA, vtable_offset_local+11, agcom.VARIANT_BOOL)
        self.__dict__["_get_solar_radius"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aeIIA, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_set_solar_radius"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aeIIA, vtable_offset_local+13, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISRPGSPM04aeIIA.__dict__ and type(ISRPGSPM04aeIIA.__dict__[attrname]) == property:
            return ISRPGSPM04aeIIA.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISRPGSPM04aeIIA.")
    
    @property
    def atmos_alt(self) -> float:
        """The atmospheric altitude for eclipse. A simple model to account for some measure of attenuation that simply increases the shape of the Earth by the defined altitude height, often taken to be 23 km. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_alt"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_alt.setter
    def atmos_alt(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_alt"](arg_inVal.COM_val))

    @property
    def shadow_model(self) -> "AgEVAShadowModel":
        """The shadow model type."""
        with agmarshall.AgEnum_arg(AgEVAShadowModel) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_shadow_model"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @shadow_model.setter
    def shadow_model(self, inVal:"AgEVAShadowModel") -> None:
        with agmarshall.AgEnum_arg(AgEVAShadowModel, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_shadow_model"](arg_inVal.COM_val))

    @property
    def sun_position(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sun_position"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sun_position.setter
    def sun_position(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_sun_position"](arg_inVal.COM_val))

    @property
    def eclipsing_bodies(self) -> "ICentralBodyCollection":
        """Other eclipsing bodies."""
        with agmarshall.AgInterface_out_arg() as arg_ppCentralBodyCollection:
            agcls.evaluate_hresult(self.__dict__["_get_eclipsing_bodies"](byref(arg_ppCentralBodyCollection.COM_val)))
            return arg_ppCentralBodyCollection.python_val

    @property
    def include_boundary_mitigation(self) -> bool:
        """True if shadow boundary mitigation should be performed; the state of the satellite after crossing a shadow boundary will be corrected for errors possibly caused by the sudden change in SRP which occurred during the integration step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pMitigation:
            agcls.evaluate_hresult(self.__dict__["_get_include_boundary_mitigation"](byref(arg_pMitigation.COM_val)))
            return arg_pMitigation.python_val

    @include_boundary_mitigation.setter
    def include_boundary_mitigation(self, mitigation:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(mitigation) as arg_mitigation:
            agcls.evaluate_hresult(self.__dict__["_set_include_boundary_mitigation"](arg_mitigation.COM_val))

    @property
    def use_sun_cb_file_values(self) -> bool:
        """True if solar radius should come from the Sun.cb file."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_sun_cb_file_values"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_sun_cb_file_values.setter
    def use_sun_cb_file_values(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_sun_cb_file_values"](arg_inVal.COM_val))

    @property
    def solar_radius(self) -> float:
        """The solar radius value to use in eclipse calculations.  Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_solar_radius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @solar_radius.setter
    def solar_radius(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_solar_radius"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3F99DF3B-1BC5-40F2-826D-751DCE4BB77C}", ISRPGSPM04aeIIA)
agcls.AgTypeNameMap["ISRPGSPM04aeIIA"] = ISRPGSPM04aeIIA

class ISRPGSPM04aeIIR(object):
    """Properties for the Bar-Sever GPS Solar Pressure Model 04ae for block IIR."""
    _uuid = "{8A1CAF39-9680-4405-942D-A86D279EAE24}"
    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_atmos_alt"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_alt"] = _raise_uninitialized_error
        self.__dict__["_get_shadow_model"] = _raise_uninitialized_error
        self.__dict__["_set_shadow_model"] = _raise_uninitialized_error
        self.__dict__["_get_sun_position"] = _raise_uninitialized_error
        self.__dict__["_set_sun_position"] = _raise_uninitialized_error
        self.__dict__["_get_eclipsing_bodies"] = _raise_uninitialized_error
        self.__dict__["_get_include_boundary_mitigation"] = _raise_uninitialized_error
        self.__dict__["_set_include_boundary_mitigation"] = _raise_uninitialized_error
        self.__dict__["_get_use_sun_cb_file_values"] = _raise_uninitialized_error
        self.__dict__["_set_use_sun_cb_file_values"] = _raise_uninitialized_error
        self.__dict__["_get_solar_radius"] = _raise_uninitialized_error
        self.__dict__["_set_solar_radius"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISRPGSPM04aeIIR._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISRPGSPM04aeIIR from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISRPGSPM04aeIIR = agcom.GUID(ISRPGSPM04aeIIR._uuid)
        vtable_offset_local = ISRPGSPM04aeIIR._vtable_offset - 1
        self.__dict__["_get_atmos_alt"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aeIIR, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_atmos_alt"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aeIIR, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_shadow_model"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aeIIR, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_shadow_model"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aeIIR, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_sun_position"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aeIIR, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_sun_position"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aeIIR, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_eclipsing_bodies"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aeIIR, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_get_include_boundary_mitigation"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aeIIR, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_include_boundary_mitigation"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aeIIR, vtable_offset_local+9, agcom.VARIANT_BOOL)
        self.__dict__["_get_use_sun_cb_file_values"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aeIIR, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_sun_cb_file_values"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aeIIR, vtable_offset_local+11, agcom.VARIANT_BOOL)
        self.__dict__["_get_solar_radius"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aeIIR, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_set_solar_radius"] = IAGFUNCTYPE(pUnk, IID_ISRPGSPM04aeIIR, vtable_offset_local+13, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISRPGSPM04aeIIR.__dict__ and type(ISRPGSPM04aeIIR.__dict__[attrname]) == property:
            return ISRPGSPM04aeIIR.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISRPGSPM04aeIIR.")
    
    @property
    def atmos_alt(self) -> float:
        """The atmospheric altitude for eclipse. A simple model to account for some measure of attenuation that simply increases the shape of the Earth by the defined altitude height, often taken to be 23 km. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_alt"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_alt.setter
    def atmos_alt(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_alt"](arg_inVal.COM_val))

    @property
    def shadow_model(self) -> "AgEVAShadowModel":
        """The shadow model type."""
        with agmarshall.AgEnum_arg(AgEVAShadowModel) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_shadow_model"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @shadow_model.setter
    def shadow_model(self, inVal:"AgEVAShadowModel") -> None:
        with agmarshall.AgEnum_arg(AgEVAShadowModel, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_shadow_model"](arg_inVal.COM_val))

    @property
    def sun_position(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sun_position"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sun_position.setter
    def sun_position(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_sun_position"](arg_inVal.COM_val))

    @property
    def eclipsing_bodies(self) -> "ICentralBodyCollection":
        """Other eclipsing bodies."""
        with agmarshall.AgInterface_out_arg() as arg_ppCentralBodyCollection:
            agcls.evaluate_hresult(self.__dict__["_get_eclipsing_bodies"](byref(arg_ppCentralBodyCollection.COM_val)))
            return arg_ppCentralBodyCollection.python_val

    @property
    def include_boundary_mitigation(self) -> bool:
        """True if shadow boundary mitigation should be performed; the state of the satellite after crossing a shadow boundary will be corrected for errors possibly caused by the sudden change in SRP which occurred during the integration step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pMitigation:
            agcls.evaluate_hresult(self.__dict__["_get_include_boundary_mitigation"](byref(arg_pMitigation.COM_val)))
            return arg_pMitigation.python_val

    @include_boundary_mitigation.setter
    def include_boundary_mitigation(self, mitigation:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(mitigation) as arg_mitigation:
            agcls.evaluate_hresult(self.__dict__["_set_include_boundary_mitigation"](arg_mitigation.COM_val))

    @property
    def use_sun_cb_file_values(self) -> bool:
        """True if solar radius should come from the Sun.cb file."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_sun_cb_file_values"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_sun_cb_file_values.setter
    def use_sun_cb_file_values(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_sun_cb_file_values"](arg_inVal.COM_val))

    @property
    def solar_radius(self) -> float:
        """The solar radius value to use in eclipse calculations.  Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_solar_radius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @solar_radius.setter
    def solar_radius(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_solar_radius"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{8A1CAF39-9680-4405-942D-A86D279EAE24}", ISRPGSPM04aeIIR)
agcls.AgTypeNameMap["ISRPGSPM04aeIIR"] = ISRPGSPM04aeIIR

class ISRPSpherical(object):
    """Properties for the Spherical SRP model; assumes a spherical spacecraft. The equation used by STK is described in the Solar Radiation technical note."""
    _uuid = "{B8F7E804-16B0-447F-A75A-B75DF05287B0}"
    _num_methods = 19
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_atmos_alt"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_alt"] = _raise_uninitialized_error
        self.__dict__["_get_shadow_model"] = _raise_uninitialized_error
        self.__dict__["_set_shadow_model"] = _raise_uninitialized_error
        self.__dict__["_get_sun_position"] = _raise_uninitialized_error
        self.__dict__["_set_sun_position"] = _raise_uninitialized_error
        self.__dict__["_get_eclipsing_bodies"] = _raise_uninitialized_error
        self.__dict__["_get_mean_flux"] = _raise_uninitialized_error
        self.__dict__["_set_mean_flux"] = _raise_uninitialized_error
        self.__dict__["_get_luminosity"] = _raise_uninitialized_error
        self.__dict__["_set_luminosity"] = _raise_uninitialized_error
        self.__dict__["_get_solar_force_method"] = _raise_uninitialized_error
        self.__dict__["_set_solar_force_method"] = _raise_uninitialized_error
        self.__dict__["_get_include_boundary_mitigation"] = _raise_uninitialized_error
        self.__dict__["_set_include_boundary_mitigation"] = _raise_uninitialized_error
        self.__dict__["_get_use_sun_cb_file_values"] = _raise_uninitialized_error
        self.__dict__["_set_use_sun_cb_file_values"] = _raise_uninitialized_error
        self.__dict__["_get_solar_radius"] = _raise_uninitialized_error
        self.__dict__["_set_solar_radius"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISRPSpherical._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISRPSpherical from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISRPSpherical = agcom.GUID(ISRPSpherical._uuid)
        vtable_offset_local = ISRPSpherical._vtable_offset - 1
        self.__dict__["_get_atmos_alt"] = IAGFUNCTYPE(pUnk, IID_ISRPSpherical, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_atmos_alt"] = IAGFUNCTYPE(pUnk, IID_ISRPSpherical, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_shadow_model"] = IAGFUNCTYPE(pUnk, IID_ISRPSpherical, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_shadow_model"] = IAGFUNCTYPE(pUnk, IID_ISRPSpherical, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_sun_position"] = IAGFUNCTYPE(pUnk, IID_ISRPSpherical, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_sun_position"] = IAGFUNCTYPE(pUnk, IID_ISRPSpherical, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_eclipsing_bodies"] = IAGFUNCTYPE(pUnk, IID_ISRPSpherical, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_get_mean_flux"] = IAGFUNCTYPE(pUnk, IID_ISRPSpherical, vtable_offset_local+8, POINTER(agcom.DOUBLE))
        self.__dict__["_set_mean_flux"] = IAGFUNCTYPE(pUnk, IID_ISRPSpherical, vtable_offset_local+9, agcom.DOUBLE)
        self.__dict__["_get_luminosity"] = IAGFUNCTYPE(pUnk, IID_ISRPSpherical, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_set_luminosity"] = IAGFUNCTYPE(pUnk, IID_ISRPSpherical, vtable_offset_local+11, agcom.DOUBLE)
        self.__dict__["_get_solar_force_method"] = IAGFUNCTYPE(pUnk, IID_ISRPSpherical, vtable_offset_local+12, POINTER(agcom.LONG))
        self.__dict__["_set_solar_force_method"] = IAGFUNCTYPE(pUnk, IID_ISRPSpherical, vtable_offset_local+13, agcom.LONG)
        self.__dict__["_get_include_boundary_mitigation"] = IAGFUNCTYPE(pUnk, IID_ISRPSpherical, vtable_offset_local+14, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_include_boundary_mitigation"] = IAGFUNCTYPE(pUnk, IID_ISRPSpherical, vtable_offset_local+15, agcom.VARIANT_BOOL)
        self.__dict__["_get_use_sun_cb_file_values"] = IAGFUNCTYPE(pUnk, IID_ISRPSpherical, vtable_offset_local+16, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_sun_cb_file_values"] = IAGFUNCTYPE(pUnk, IID_ISRPSpherical, vtable_offset_local+17, agcom.VARIANT_BOOL)
        self.__dict__["_get_solar_radius"] = IAGFUNCTYPE(pUnk, IID_ISRPSpherical, vtable_offset_local+18, POINTER(agcom.DOUBLE))
        self.__dict__["_set_solar_radius"] = IAGFUNCTYPE(pUnk, IID_ISRPSpherical, vtable_offset_local+19, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISRPSpherical.__dict__ and type(ISRPSpherical.__dict__[attrname]) == property:
            return ISRPSpherical.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISRPSpherical.")
    
    @property
    def atmos_alt(self) -> float:
        """The atmospheric altitude for eclipse. A simple model to account for some measure of attenuation that simply increases the shape of the Earth by the defined altitude height, often taken to be 23 km. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_alt"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_alt.setter
    def atmos_alt(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_alt"](arg_inVal.COM_val))

    @property
    def shadow_model(self) -> "AgEVAShadowModel":
        """The shadow model type."""
        with agmarshall.AgEnum_arg(AgEVAShadowModel) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_shadow_model"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @shadow_model.setter
    def shadow_model(self, inVal:"AgEVAShadowModel") -> None:
        with agmarshall.AgEnum_arg(AgEVAShadowModel, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_shadow_model"](arg_inVal.COM_val))

    @property
    def sun_position(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sun_position"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sun_position.setter
    def sun_position(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_sun_position"](arg_inVal.COM_val))

    @property
    def eclipsing_bodies(self) -> "ICentralBodyCollection":
        """Other eclipsing bodies."""
        with agmarshall.AgInterface_out_arg() as arg_ppCentralBodyCollection:
            agcls.evaluate_hresult(self.__dict__["_get_eclipsing_bodies"](byref(arg_ppCentralBodyCollection.COM_val)))
            return arg_ppCentralBodyCollection.python_val

    @property
    def mean_flux(self) -> float:
        """The mean solar flux at 1 au (W/m^2)."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_mean_flux"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @mean_flux.setter
    def mean_flux(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_mean_flux"](arg_inVal.COM_val))

    @property
    def luminosity(self) -> float:
        """The luminosity of sun. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_luminosity"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @luminosity.setter
    def luminosity(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_luminosity"](arg_inVal.COM_val))

    @property
    def solar_force_method(self) -> "AgEVASolarForceMethod":
        """The solar force method"""
        with agmarshall.AgEnum_arg(AgEVASolarForceMethod) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_solar_force_method"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @solar_force_method.setter
    def solar_force_method(self, inVal:"AgEVASolarForceMethod") -> None:
        with agmarshall.AgEnum_arg(AgEVASolarForceMethod, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_solar_force_method"](arg_inVal.COM_val))

    @property
    def include_boundary_mitigation(self) -> bool:
        """True if shadow boundary mitigation should be performed; the state of the satellite after crossing a shadow boundary will be corrected for errors possibly caused by the sudden change in SRP which occurred during the integration step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pMitigation:
            agcls.evaluate_hresult(self.__dict__["_get_include_boundary_mitigation"](byref(arg_pMitigation.COM_val)))
            return arg_pMitigation.python_val

    @include_boundary_mitigation.setter
    def include_boundary_mitigation(self, mitigation:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(mitigation) as arg_mitigation:
            agcls.evaluate_hresult(self.__dict__["_set_include_boundary_mitigation"](arg_mitigation.COM_val))

    @property
    def use_sun_cb_file_values(self) -> bool:
        """True if solar values should come from the Sun.cb file."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_sun_cb_file_values"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_sun_cb_file_values.setter
    def use_sun_cb_file_values(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_sun_cb_file_values"](arg_inVal.COM_val))

    @property
    def solar_radius(self) -> float:
        """The solar radius value to use in eclipse calculations.  Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_solar_radius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @solar_radius.setter
    def solar_radius(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_solar_radius"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{B8F7E804-16B0-447F-A75A-B75DF05287B0}", ISRPSpherical)
agcls.AgTypeNameMap["ISRPSpherical"] = ISRPSpherical

class ISRPNPlate(object):
    """Properties for the N-plate SRP model."""
    _uuid = "{5DE80C27-861E-4596-9461-414741A793D1}"
    _num_methods = 21
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_atmos_alt"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_alt"] = _raise_uninitialized_error
        self.__dict__["_get_shadow_model"] = _raise_uninitialized_error
        self.__dict__["_set_shadow_model"] = _raise_uninitialized_error
        self.__dict__["_get_sun_position"] = _raise_uninitialized_error
        self.__dict__["_set_sun_position"] = _raise_uninitialized_error
        self.__dict__["_get_eclipsing_bodies"] = _raise_uninitialized_error
        self.__dict__["_get_mean_flux"] = _raise_uninitialized_error
        self.__dict__["_set_mean_flux"] = _raise_uninitialized_error
        self.__dict__["_get_luminosity"] = _raise_uninitialized_error
        self.__dict__["_set_luminosity"] = _raise_uninitialized_error
        self.__dict__["_get_solar_force_method"] = _raise_uninitialized_error
        self.__dict__["_set_solar_force_method"] = _raise_uninitialized_error
        self.__dict__["_get_include_boundary_mitigation"] = _raise_uninitialized_error
        self.__dict__["_set_include_boundary_mitigation"] = _raise_uninitialized_error
        self.__dict__["_get_use_sun_cb_file_values"] = _raise_uninitialized_error
        self.__dict__["_set_use_sun_cb_file_values"] = _raise_uninitialized_error
        self.__dict__["_get_solar_radius"] = _raise_uninitialized_error
        self.__dict__["_set_solar_radius"] = _raise_uninitialized_error
        self.__dict__["_get_n_plate_definition_file"] = _raise_uninitialized_error
        self.__dict__["_set_n_plate_definition_file"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISRPNPlate._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISRPNPlate from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISRPNPlate = agcom.GUID(ISRPNPlate._uuid)
        vtable_offset_local = ISRPNPlate._vtable_offset - 1
        self.__dict__["_get_atmos_alt"] = IAGFUNCTYPE(pUnk, IID_ISRPNPlate, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_atmos_alt"] = IAGFUNCTYPE(pUnk, IID_ISRPNPlate, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_shadow_model"] = IAGFUNCTYPE(pUnk, IID_ISRPNPlate, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_shadow_model"] = IAGFUNCTYPE(pUnk, IID_ISRPNPlate, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_sun_position"] = IAGFUNCTYPE(pUnk, IID_ISRPNPlate, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_sun_position"] = IAGFUNCTYPE(pUnk, IID_ISRPNPlate, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_eclipsing_bodies"] = IAGFUNCTYPE(pUnk, IID_ISRPNPlate, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_get_mean_flux"] = IAGFUNCTYPE(pUnk, IID_ISRPNPlate, vtable_offset_local+8, POINTER(agcom.DOUBLE))
        self.__dict__["_set_mean_flux"] = IAGFUNCTYPE(pUnk, IID_ISRPNPlate, vtable_offset_local+9, agcom.DOUBLE)
        self.__dict__["_get_luminosity"] = IAGFUNCTYPE(pUnk, IID_ISRPNPlate, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_set_luminosity"] = IAGFUNCTYPE(pUnk, IID_ISRPNPlate, vtable_offset_local+11, agcom.DOUBLE)
        self.__dict__["_get_solar_force_method"] = IAGFUNCTYPE(pUnk, IID_ISRPNPlate, vtable_offset_local+12, POINTER(agcom.LONG))
        self.__dict__["_set_solar_force_method"] = IAGFUNCTYPE(pUnk, IID_ISRPNPlate, vtable_offset_local+13, agcom.LONG)
        self.__dict__["_get_include_boundary_mitigation"] = IAGFUNCTYPE(pUnk, IID_ISRPNPlate, vtable_offset_local+14, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_include_boundary_mitigation"] = IAGFUNCTYPE(pUnk, IID_ISRPNPlate, vtable_offset_local+15, agcom.VARIANT_BOOL)
        self.__dict__["_get_use_sun_cb_file_values"] = IAGFUNCTYPE(pUnk, IID_ISRPNPlate, vtable_offset_local+16, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_sun_cb_file_values"] = IAGFUNCTYPE(pUnk, IID_ISRPNPlate, vtable_offset_local+17, agcom.VARIANT_BOOL)
        self.__dict__["_get_solar_radius"] = IAGFUNCTYPE(pUnk, IID_ISRPNPlate, vtable_offset_local+18, POINTER(agcom.DOUBLE))
        self.__dict__["_set_solar_radius"] = IAGFUNCTYPE(pUnk, IID_ISRPNPlate, vtable_offset_local+19, agcom.DOUBLE)
        self.__dict__["_get_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_ISRPNPlate, vtable_offset_local+20, POINTER(agcom.BSTR))
        self.__dict__["_set_n_plate_definition_file"] = IAGFUNCTYPE(pUnk, IID_ISRPNPlate, vtable_offset_local+21, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISRPNPlate.__dict__ and type(ISRPNPlate.__dict__[attrname]) == property:
            return ISRPNPlate.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISRPNPlate.")
    
    @property
    def atmos_alt(self) -> float:
        """The atmospheric altitude for eclipse. A simple model to account for some measure of attenuation that simply increases the shape of the Earth by the defined altitude height, often taken to be 23 km. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_alt"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_alt.setter
    def atmos_alt(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_alt"](arg_inVal.COM_val))

    @property
    def shadow_model(self) -> "AgEVAShadowModel":
        """The shadow model type."""
        with agmarshall.AgEnum_arg(AgEVAShadowModel) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_shadow_model"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @shadow_model.setter
    def shadow_model(self, inVal:"AgEVAShadowModel") -> None:
        with agmarshall.AgEnum_arg(AgEVAShadowModel, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_shadow_model"](arg_inVal.COM_val))

    @property
    def sun_position(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sun_position"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sun_position.setter
    def sun_position(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_sun_position"](arg_inVal.COM_val))

    @property
    def eclipsing_bodies(self) -> "ICentralBodyCollection":
        """Other eclipsing bodies."""
        with agmarshall.AgInterface_out_arg() as arg_ppCentralBodyCollection:
            agcls.evaluate_hresult(self.__dict__["_get_eclipsing_bodies"](byref(arg_ppCentralBodyCollection.COM_val)))
            return arg_ppCentralBodyCollection.python_val

    @property
    def mean_flux(self) -> float:
        """The mean solar flux at 1 au (W/m^2)."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_mean_flux"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @mean_flux.setter
    def mean_flux(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_mean_flux"](arg_inVal.COM_val))

    @property
    def luminosity(self) -> float:
        """The luminosity of sun. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_luminosity"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @luminosity.setter
    def luminosity(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_luminosity"](arg_inVal.COM_val))

    @property
    def solar_force_method(self) -> "AgEVASolarForceMethod":
        """The solar force method"""
        with agmarshall.AgEnum_arg(AgEVASolarForceMethod) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_solar_force_method"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @solar_force_method.setter
    def solar_force_method(self, inVal:"AgEVASolarForceMethod") -> None:
        with agmarshall.AgEnum_arg(AgEVASolarForceMethod, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_solar_force_method"](arg_inVal.COM_val))

    @property
    def include_boundary_mitigation(self) -> bool:
        """True if shadow boundary mitigation should be performed; the state of the satellite after crossing a shadow boundary will be corrected for errors possibly caused by the sudden change in SRP which occurred during the integration step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pMitigation:
            agcls.evaluate_hresult(self.__dict__["_get_include_boundary_mitigation"](byref(arg_pMitigation.COM_val)))
            return arg_pMitigation.python_val

    @include_boundary_mitigation.setter
    def include_boundary_mitigation(self, mitigation:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(mitigation) as arg_mitigation:
            agcls.evaluate_hresult(self.__dict__["_set_include_boundary_mitigation"](arg_mitigation.COM_val))

    @property
    def use_sun_cb_file_values(self) -> bool:
        """True if solar values should come from the Sun.cb file."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_sun_cb_file_values"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_sun_cb_file_values.setter
    def use_sun_cb_file_values(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_sun_cb_file_values"](arg_inVal.COM_val))

    @property
    def solar_radius(self) -> float:
        """The solar radius value to use in eclipse calculations.  Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_solar_radius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @solar_radius.setter
    def solar_radius(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_solar_radius"](arg_inVal.COM_val))

    @property
    def n_plate_definition_file(self) -> str:
        """Full path of NPlate definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_n_plate_definition_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @n_plate_definition_file.setter
    def n_plate_definition_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_n_plate_definition_file"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{5DE80C27-861E-4596-9461-414741A793D1}", ISRPNPlate)
agcls.AgTypeNameMap["ISRPNPlate"] = ISRPNPlate

class ISRPTabAreaVec(object):
    """Properties for the tabulated area vector SRP model."""
    _uuid = "{796EAE38-5298-4315-AA74-29C810F2E3FE}"
    _num_methods = 23
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_atmos_alt"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_alt"] = _raise_uninitialized_error
        self.__dict__["_get_shadow_model"] = _raise_uninitialized_error
        self.__dict__["_set_shadow_model"] = _raise_uninitialized_error
        self.__dict__["_get_sun_position"] = _raise_uninitialized_error
        self.__dict__["_set_sun_position"] = _raise_uninitialized_error
        self.__dict__["_get_eclipsing_bodies"] = _raise_uninitialized_error
        self.__dict__["_get_mean_flux"] = _raise_uninitialized_error
        self.__dict__["_set_mean_flux"] = _raise_uninitialized_error
        self.__dict__["_get_luminosity"] = _raise_uninitialized_error
        self.__dict__["_set_luminosity"] = _raise_uninitialized_error
        self.__dict__["_get_solar_force_method"] = _raise_uninitialized_error
        self.__dict__["_set_solar_force_method"] = _raise_uninitialized_error
        self.__dict__["_get_include_boundary_mitigation"] = _raise_uninitialized_error
        self.__dict__["_set_include_boundary_mitigation"] = _raise_uninitialized_error
        self.__dict__["_get_use_sun_cb_file_values"] = _raise_uninitialized_error
        self.__dict__["_set_use_sun_cb_file_values"] = _raise_uninitialized_error
        self.__dict__["_get_solar_radius"] = _raise_uninitialized_error
        self.__dict__["_set_solar_radius"] = _raise_uninitialized_error
        self.__dict__["_get_tab_area_vector_definition_file"] = _raise_uninitialized_error
        self.__dict__["_set_tab_area_vector_definition_file"] = _raise_uninitialized_error
        self.__dict__["_get_interpolation_method"] = _raise_uninitialized_error
        self.__dict__["_set_interpolation_method"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISRPTabAreaVec._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISRPTabAreaVec from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISRPTabAreaVec = agcom.GUID(ISRPTabAreaVec._uuid)
        vtable_offset_local = ISRPTabAreaVec._vtable_offset - 1
        self.__dict__["_get_atmos_alt"] = IAGFUNCTYPE(pUnk, IID_ISRPTabAreaVec, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_atmos_alt"] = IAGFUNCTYPE(pUnk, IID_ISRPTabAreaVec, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_shadow_model"] = IAGFUNCTYPE(pUnk, IID_ISRPTabAreaVec, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_shadow_model"] = IAGFUNCTYPE(pUnk, IID_ISRPTabAreaVec, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_sun_position"] = IAGFUNCTYPE(pUnk, IID_ISRPTabAreaVec, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_sun_position"] = IAGFUNCTYPE(pUnk, IID_ISRPTabAreaVec, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_eclipsing_bodies"] = IAGFUNCTYPE(pUnk, IID_ISRPTabAreaVec, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_get_mean_flux"] = IAGFUNCTYPE(pUnk, IID_ISRPTabAreaVec, vtable_offset_local+8, POINTER(agcom.DOUBLE))
        self.__dict__["_set_mean_flux"] = IAGFUNCTYPE(pUnk, IID_ISRPTabAreaVec, vtable_offset_local+9, agcom.DOUBLE)
        self.__dict__["_get_luminosity"] = IAGFUNCTYPE(pUnk, IID_ISRPTabAreaVec, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_set_luminosity"] = IAGFUNCTYPE(pUnk, IID_ISRPTabAreaVec, vtable_offset_local+11, agcom.DOUBLE)
        self.__dict__["_get_solar_force_method"] = IAGFUNCTYPE(pUnk, IID_ISRPTabAreaVec, vtable_offset_local+12, POINTER(agcom.LONG))
        self.__dict__["_set_solar_force_method"] = IAGFUNCTYPE(pUnk, IID_ISRPTabAreaVec, vtable_offset_local+13, agcom.LONG)
        self.__dict__["_get_include_boundary_mitigation"] = IAGFUNCTYPE(pUnk, IID_ISRPTabAreaVec, vtable_offset_local+14, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_include_boundary_mitigation"] = IAGFUNCTYPE(pUnk, IID_ISRPTabAreaVec, vtable_offset_local+15, agcom.VARIANT_BOOL)
        self.__dict__["_get_use_sun_cb_file_values"] = IAGFUNCTYPE(pUnk, IID_ISRPTabAreaVec, vtable_offset_local+16, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_sun_cb_file_values"] = IAGFUNCTYPE(pUnk, IID_ISRPTabAreaVec, vtable_offset_local+17, agcom.VARIANT_BOOL)
        self.__dict__["_get_solar_radius"] = IAGFUNCTYPE(pUnk, IID_ISRPTabAreaVec, vtable_offset_local+18, POINTER(agcom.DOUBLE))
        self.__dict__["_set_solar_radius"] = IAGFUNCTYPE(pUnk, IID_ISRPTabAreaVec, vtable_offset_local+19, agcom.DOUBLE)
        self.__dict__["_get_tab_area_vector_definition_file"] = IAGFUNCTYPE(pUnk, IID_ISRPTabAreaVec, vtable_offset_local+20, POINTER(agcom.BSTR))
        self.__dict__["_set_tab_area_vector_definition_file"] = IAGFUNCTYPE(pUnk, IID_ISRPTabAreaVec, vtable_offset_local+21, agcom.BSTR)
        self.__dict__["_get_interpolation_method"] = IAGFUNCTYPE(pUnk, IID_ISRPTabAreaVec, vtable_offset_local+22, POINTER(agcom.LONG))
        self.__dict__["_set_interpolation_method"] = IAGFUNCTYPE(pUnk, IID_ISRPTabAreaVec, vtable_offset_local+23, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISRPTabAreaVec.__dict__ and type(ISRPTabAreaVec.__dict__[attrname]) == property:
            return ISRPTabAreaVec.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISRPTabAreaVec.")
    
    @property
    def atmos_alt(self) -> float:
        """The atmospheric altitude for eclipse. A simple model to account for some measure of attenuation that simply increases the shape of the Earth by the defined altitude height, often taken to be 23 km. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_alt"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_alt.setter
    def atmos_alt(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_alt"](arg_inVal.COM_val))

    @property
    def shadow_model(self) -> "AgEVAShadowModel":
        """The shadow model type."""
        with agmarshall.AgEnum_arg(AgEVAShadowModel) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_shadow_model"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @shadow_model.setter
    def shadow_model(self, inVal:"AgEVAShadowModel") -> None:
        with agmarshall.AgEnum_arg(AgEVAShadowModel, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_shadow_model"](arg_inVal.COM_val))

    @property
    def sun_position(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sun_position"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sun_position.setter
    def sun_position(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_sun_position"](arg_inVal.COM_val))

    @property
    def eclipsing_bodies(self) -> "ICentralBodyCollection":
        """Other eclipsing bodies."""
        with agmarshall.AgInterface_out_arg() as arg_ppCentralBodyCollection:
            agcls.evaluate_hresult(self.__dict__["_get_eclipsing_bodies"](byref(arg_ppCentralBodyCollection.COM_val)))
            return arg_ppCentralBodyCollection.python_val

    @property
    def mean_flux(self) -> float:
        """The mean solar flux at 1 au (W/m^2)."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_mean_flux"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @mean_flux.setter
    def mean_flux(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_mean_flux"](arg_inVal.COM_val))

    @property
    def luminosity(self) -> float:
        """The luminosity of sun. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_luminosity"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @luminosity.setter
    def luminosity(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_luminosity"](arg_inVal.COM_val))

    @property
    def solar_force_method(self) -> "AgEVASolarForceMethod":
        """The solar force method"""
        with agmarshall.AgEnum_arg(AgEVASolarForceMethod) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_solar_force_method"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @solar_force_method.setter
    def solar_force_method(self, inVal:"AgEVASolarForceMethod") -> None:
        with agmarshall.AgEnum_arg(AgEVASolarForceMethod, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_solar_force_method"](arg_inVal.COM_val))

    @property
    def include_boundary_mitigation(self) -> bool:
        """True if shadow boundary mitigation should be performed; the state of the satellite after crossing a shadow boundary will be corrected for errors possibly caused by the sudden change in SRP which occurred during the integration step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pMitigation:
            agcls.evaluate_hresult(self.__dict__["_get_include_boundary_mitigation"](byref(arg_pMitigation.COM_val)))
            return arg_pMitigation.python_val

    @include_boundary_mitigation.setter
    def include_boundary_mitigation(self, mitigation:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(mitigation) as arg_mitigation:
            agcls.evaluate_hresult(self.__dict__["_set_include_boundary_mitigation"](arg_mitigation.COM_val))

    @property
    def use_sun_cb_file_values(self) -> bool:
        """True if solar values should come from the Sun.cb file."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_sun_cb_file_values"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_sun_cb_file_values.setter
    def use_sun_cb_file_values(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_sun_cb_file_values"](arg_inVal.COM_val))

    @property
    def solar_radius(self) -> float:
        """The solar radius value to use in eclipse calculations.  Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_solar_radius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @solar_radius.setter
    def solar_radius(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_solar_radius"](arg_inVal.COM_val))

    @property
    def tab_area_vector_definition_file(self) -> str:
        """Full path of the tabulated area vector definition file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_tab_area_vector_definition_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @tab_area_vector_definition_file.setter
    def tab_area_vector_definition_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_tab_area_vector_definition_file"](arg_inVal.COM_val))

    @property
    def interpolation_method(self) -> "AgEVATabVecInterpMethod":
        """The file interpolation method."""
        with agmarshall.AgEnum_arg(AgEVATabVecInterpMethod) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_interpolation_method"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @interpolation_method.setter
    def interpolation_method(self, inVal:"AgEVATabVecInterpMethod") -> None:
        with agmarshall.AgEnum_arg(AgEVATabVecInterpMethod, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_interpolation_method"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{796EAE38-5298-4315-AA74-29C810F2E3FE}", ISRPTabAreaVec)
agcls.AgTypeNameMap["ISRPTabAreaVec"] = ISRPTabAreaVec

class ISRPVariableArea(object):
    """Properties for the Variable Area SRP model."""
    _uuid = "{4124EBC1-ABC6-4933-84D2-0F1232D8B630}"
    _num_methods = 21
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_atmos_alt"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_alt"] = _raise_uninitialized_error
        self.__dict__["_get_shadow_model"] = _raise_uninitialized_error
        self.__dict__["_set_shadow_model"] = _raise_uninitialized_error
        self.__dict__["_get_sun_position"] = _raise_uninitialized_error
        self.__dict__["_set_sun_position"] = _raise_uninitialized_error
        self.__dict__["_get_eclipsing_bodies"] = _raise_uninitialized_error
        self.__dict__["_get_mean_flux"] = _raise_uninitialized_error
        self.__dict__["_set_mean_flux"] = _raise_uninitialized_error
        self.__dict__["_get_luminosity"] = _raise_uninitialized_error
        self.__dict__["_set_luminosity"] = _raise_uninitialized_error
        self.__dict__["_get_solar_force_method"] = _raise_uninitialized_error
        self.__dict__["_set_solar_force_method"] = _raise_uninitialized_error
        self.__dict__["_get_include_boundary_mitigation"] = _raise_uninitialized_error
        self.__dict__["_set_include_boundary_mitigation"] = _raise_uninitialized_error
        self.__dict__["_get_use_sun_cb_file_values"] = _raise_uninitialized_error
        self.__dict__["_set_use_sun_cb_file_values"] = _raise_uninitialized_error
        self.__dict__["_get_solar_radius"] = _raise_uninitialized_error
        self.__dict__["_set_solar_radius"] = _raise_uninitialized_error
        self.__dict__["_get_variable_area_history_file"] = _raise_uninitialized_error
        self.__dict__["_set_variable_area_history_file"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISRPVariableArea._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISRPVariableArea from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISRPVariableArea = agcom.GUID(ISRPVariableArea._uuid)
        vtable_offset_local = ISRPVariableArea._vtable_offset - 1
        self.__dict__["_get_atmos_alt"] = IAGFUNCTYPE(pUnk, IID_ISRPVariableArea, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_atmos_alt"] = IAGFUNCTYPE(pUnk, IID_ISRPVariableArea, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_shadow_model"] = IAGFUNCTYPE(pUnk, IID_ISRPVariableArea, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_shadow_model"] = IAGFUNCTYPE(pUnk, IID_ISRPVariableArea, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_sun_position"] = IAGFUNCTYPE(pUnk, IID_ISRPVariableArea, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_sun_position"] = IAGFUNCTYPE(pUnk, IID_ISRPVariableArea, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_eclipsing_bodies"] = IAGFUNCTYPE(pUnk, IID_ISRPVariableArea, vtable_offset_local+7, POINTER(agcom.PVOID))
        self.__dict__["_get_mean_flux"] = IAGFUNCTYPE(pUnk, IID_ISRPVariableArea, vtable_offset_local+8, POINTER(agcom.DOUBLE))
        self.__dict__["_set_mean_flux"] = IAGFUNCTYPE(pUnk, IID_ISRPVariableArea, vtable_offset_local+9, agcom.DOUBLE)
        self.__dict__["_get_luminosity"] = IAGFUNCTYPE(pUnk, IID_ISRPVariableArea, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_set_luminosity"] = IAGFUNCTYPE(pUnk, IID_ISRPVariableArea, vtable_offset_local+11, agcom.DOUBLE)
        self.__dict__["_get_solar_force_method"] = IAGFUNCTYPE(pUnk, IID_ISRPVariableArea, vtable_offset_local+12, POINTER(agcom.LONG))
        self.__dict__["_set_solar_force_method"] = IAGFUNCTYPE(pUnk, IID_ISRPVariableArea, vtable_offset_local+13, agcom.LONG)
        self.__dict__["_get_include_boundary_mitigation"] = IAGFUNCTYPE(pUnk, IID_ISRPVariableArea, vtable_offset_local+14, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_include_boundary_mitigation"] = IAGFUNCTYPE(pUnk, IID_ISRPVariableArea, vtable_offset_local+15, agcom.VARIANT_BOOL)
        self.__dict__["_get_use_sun_cb_file_values"] = IAGFUNCTYPE(pUnk, IID_ISRPVariableArea, vtable_offset_local+16, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_sun_cb_file_values"] = IAGFUNCTYPE(pUnk, IID_ISRPVariableArea, vtable_offset_local+17, agcom.VARIANT_BOOL)
        self.__dict__["_get_solar_radius"] = IAGFUNCTYPE(pUnk, IID_ISRPVariableArea, vtable_offset_local+18, POINTER(agcom.DOUBLE))
        self.__dict__["_set_solar_radius"] = IAGFUNCTYPE(pUnk, IID_ISRPVariableArea, vtable_offset_local+19, agcom.DOUBLE)
        self.__dict__["_get_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_ISRPVariableArea, vtable_offset_local+20, POINTER(agcom.BSTR))
        self.__dict__["_set_variable_area_history_file"] = IAGFUNCTYPE(pUnk, IID_ISRPVariableArea, vtable_offset_local+21, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISRPVariableArea.__dict__ and type(ISRPVariableArea.__dict__[attrname]) == property:
            return ISRPVariableArea.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISRPVariableArea.")
    
    @property
    def atmos_alt(self) -> float:
        """The atmospheric altitude for eclipse. A simple model to account for some measure of attenuation that simply increases the shape of the Earth by the defined altitude height, often taken to be 23 km. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_alt"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_alt.setter
    def atmos_alt(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_alt"](arg_inVal.COM_val))

    @property
    def shadow_model(self) -> "AgEVAShadowModel":
        """The shadow model type."""
        with agmarshall.AgEnum_arg(AgEVAShadowModel) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_shadow_model"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @shadow_model.setter
    def shadow_model(self, inVal:"AgEVAShadowModel") -> None:
        with agmarshall.AgEnum_arg(AgEVAShadowModel, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_shadow_model"](arg_inVal.COM_val))

    @property
    def sun_position(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sun_position"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sun_position.setter
    def sun_position(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_sun_position"](arg_inVal.COM_val))

    @property
    def eclipsing_bodies(self) -> "ICentralBodyCollection":
        """Other eclipsing bodies."""
        with agmarshall.AgInterface_out_arg() as arg_ppCentralBodyCollection:
            agcls.evaluate_hresult(self.__dict__["_get_eclipsing_bodies"](byref(arg_ppCentralBodyCollection.COM_val)))
            return arg_ppCentralBodyCollection.python_val

    @property
    def mean_flux(self) -> float:
        """The mean solar flux at 1 au (W/m^2)."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_mean_flux"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @mean_flux.setter
    def mean_flux(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_mean_flux"](arg_inVal.COM_val))

    @property
    def luminosity(self) -> float:
        """The luminosity of sun. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_luminosity"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @luminosity.setter
    def luminosity(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_luminosity"](arg_inVal.COM_val))

    @property
    def solar_force_method(self) -> "AgEVASolarForceMethod":
        """The solar force method"""
        with agmarshall.AgEnum_arg(AgEVASolarForceMethod) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_solar_force_method"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @solar_force_method.setter
    def solar_force_method(self, inVal:"AgEVASolarForceMethod") -> None:
        with agmarshall.AgEnum_arg(AgEVASolarForceMethod, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_solar_force_method"](arg_inVal.COM_val))

    @property
    def include_boundary_mitigation(self) -> bool:
        """True if shadow boundary mitigation should be performed; the state of the satellite after crossing a shadow boundary will be corrected for errors possibly caused by the sudden change in SRP which occurred during the integration step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pMitigation:
            agcls.evaluate_hresult(self.__dict__["_get_include_boundary_mitigation"](byref(arg_pMitigation.COM_val)))
            return arg_pMitigation.python_val

    @include_boundary_mitigation.setter
    def include_boundary_mitigation(self, mitigation:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(mitigation) as arg_mitigation:
            agcls.evaluate_hresult(self.__dict__["_set_include_boundary_mitigation"](arg_mitigation.COM_val))

    @property
    def use_sun_cb_file_values(self) -> bool:
        """True if solar values should come from the Sun.cb file."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_sun_cb_file_values"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_sun_cb_file_values.setter
    def use_sun_cb_file_values(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_sun_cb_file_values"](arg_inVal.COM_val))

    @property
    def solar_radius(self) -> float:
        """The solar radius value to use in eclipse calculations.  Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_solar_radius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @solar_radius.setter
    def solar_radius(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_solar_radius"](arg_inVal.COM_val))

    @property
    def variable_area_history_file(self) -> str:
        """Full path of the variable area history file."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_variable_area_history_file"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @variable_area_history_file.setter
    def variable_area_history_file(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_variable_area_history_file"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{4124EBC1-ABC6-4933-84D2-0F1232D8B630}", ISRPVariableArea)
agcls.AgTypeNameMap["ISRPVariableArea"] = ISRPVariableArea

class IThirdBodyFunction(object):
    """Properties for a Third Body propagator function. The IComponentInfo object returned by the mode property can be cast to IGravityFieldFunction or IPointMassFunction depending on the selected ModeType."""
    _uuid = "{86FDAC1D-8E57-4915-AA9B-E6C35E06C9BC}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_third_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_third_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_ephem_source"] = _raise_uninitialized_error
        self.__dict__["_set_ephem_source"] = _raise_uninitialized_error
        self.__dict__["_get_mode"] = _raise_uninitialized_error
        self.__dict__["_set_mode_type"] = _raise_uninitialized_error
        self.__dict__["_get_mode_type"] = _raise_uninitialized_error
        self.__dict__["_get_ephemeris_source_warning"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IThirdBodyFunction._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IThirdBodyFunction from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IThirdBodyFunction = agcom.GUID(IThirdBodyFunction._uuid)
        vtable_offset_local = IThirdBodyFunction._vtable_offset - 1
        self.__dict__["_get_third_body_name"] = IAGFUNCTYPE(pUnk, IID_IThirdBodyFunction, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_third_body_name"] = IAGFUNCTYPE(pUnk, IID_IThirdBodyFunction, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_ephem_source"] = IAGFUNCTYPE(pUnk, IID_IThirdBodyFunction, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_ephem_source"] = IAGFUNCTYPE(pUnk, IID_IThirdBodyFunction, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_mode"] = IAGFUNCTYPE(pUnk, IID_IThirdBodyFunction, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_set_mode_type"] = IAGFUNCTYPE(pUnk, IID_IThirdBodyFunction, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_mode_type"] = IAGFUNCTYPE(pUnk, IID_IThirdBodyFunction, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_get_ephemeris_source_warning"] = IAGFUNCTYPE(pUnk, IID_IThirdBodyFunction, vtable_offset_local+8, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IThirdBodyFunction.__dict__ and type(IThirdBodyFunction.__dict__[attrname]) == property:
            return IThirdBodyFunction.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IThirdBodyFunction.")
    
    @property
    def third_body_name(self) -> str:
        """The selected third body model."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_third_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @third_body_name.setter
    def third_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_third_body_name"](arg_inVal.COM_val))

    @property
    def ephem_source(self) -> "AgEVAEphemSource":
        """Source for the third body's ephemeris"""
        with agmarshall.AgEnum_arg(AgEVAEphemSource) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_ephem_source"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ephem_source.setter
    def ephem_source(self, inVal:"AgEVAEphemSource") -> None:
        with agmarshall.AgEnum_arg(AgEVAEphemSource, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_ephem_source"](arg_inVal.COM_val))

    @property
    def mode(self) -> "IComponentInfo":
        """The third body gravity mode. The IComponentInfo object returned by this property can be cast to IGravityFieldFunction or IPointMassFunction depending on the selected ModeType."""
        with agmarshall.AgInterface_out_arg() as arg_ppComponent:
            agcls.evaluate_hresult(self.__dict__["_get_mode"](byref(arg_ppComponent.COM_val)))
            return arg_ppComponent.python_val

    def set_mode_type(self, mode:"AgEVAThirdBodyMode") -> None:
        """The third body gravity mode."""
        with agmarshall.AgEnum_arg(AgEVAThirdBodyMode, mode) as arg_mode:
            agcls.evaluate_hresult(self.__dict__["_set_mode_type"](arg_mode.COM_val))

    @property
    def mode_type(self) -> "AgEVAThirdBodyMode":
        """The third body gravity mode type."""
        with agmarshall.AgEnum_arg(AgEVAThirdBodyMode) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_mode_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def ephemeris_source_warning(self) -> str:
        """Returns a warning message if the Ephemeris source and the gravity are not compatible"""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_ephemeris_source_warning"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{86FDAC1D-8E57-4915-AA9B-E6C35E06C9BC}", IThirdBodyFunction)
agcls.AgTypeNameMap["IThirdBodyFunction"] = IThirdBodyFunction

class ISRPReflectionPlugin(object):
    """Properties for the plugin SRP Refelction."""
    _uuid = "{2DF13668-98B3-4E69-89CA-C8136EAE49D9}"
    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_plugin_identifier"] = _raise_uninitialized_error
        self.__dict__["_set_plugin_identifier"] = _raise_uninitialized_error
        self.__dict__["_get_plugin_config"] = _raise_uninitialized_error
        self.__dict__["_get_atmos_alt"] = _raise_uninitialized_error
        self.__dict__["_set_atmos_alt"] = _raise_uninitialized_error
        self.__dict__["_get_shadow_model"] = _raise_uninitialized_error
        self.__dict__["_set_shadow_model"] = _raise_uninitialized_error
        self.__dict__["_get_sun_position"] = _raise_uninitialized_error
        self.__dict__["_set_sun_position"] = _raise_uninitialized_error
        self.__dict__["_get_eclipsing_bodies"] = _raise_uninitialized_error
        self.__dict__["_get_include_boundary_mitigation"] = _raise_uninitialized_error
        self.__dict__["_set_include_boundary_mitigation"] = _raise_uninitialized_error
        self.__dict__["_get_use_sun_cb_file_values"] = _raise_uninitialized_error
        self.__dict__["_set_use_sun_cb_file_values"] = _raise_uninitialized_error
        self.__dict__["_get_solar_radius"] = _raise_uninitialized_error
        self.__dict__["_set_solar_radius"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ISRPReflectionPlugin._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ISRPReflectionPlugin from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ISRPReflectionPlugin = agcom.GUID(ISRPReflectionPlugin._uuid)
        vtable_offset_local = ISRPReflectionPlugin._vtable_offset - 1
        self.__dict__["_get_plugin_identifier"] = IAGFUNCTYPE(pUnk, IID_ISRPReflectionPlugin, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_plugin_identifier"] = IAGFUNCTYPE(pUnk, IID_ISRPReflectionPlugin, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_plugin_config"] = IAGFUNCTYPE(pUnk, IID_ISRPReflectionPlugin, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_atmos_alt"] = IAGFUNCTYPE(pUnk, IID_ISRPReflectionPlugin, vtable_offset_local+4, POINTER(agcom.DOUBLE))
        self.__dict__["_set_atmos_alt"] = IAGFUNCTYPE(pUnk, IID_ISRPReflectionPlugin, vtable_offset_local+5, agcom.DOUBLE)
        self.__dict__["_get_shadow_model"] = IAGFUNCTYPE(pUnk, IID_ISRPReflectionPlugin, vtable_offset_local+6, POINTER(agcom.LONG))
        self.__dict__["_set_shadow_model"] = IAGFUNCTYPE(pUnk, IID_ISRPReflectionPlugin, vtable_offset_local+7, agcom.LONG)
        self.__dict__["_get_sun_position"] = IAGFUNCTYPE(pUnk, IID_ISRPReflectionPlugin, vtable_offset_local+8, POINTER(agcom.LONG))
        self.__dict__["_set_sun_position"] = IAGFUNCTYPE(pUnk, IID_ISRPReflectionPlugin, vtable_offset_local+9, agcom.LONG)
        self.__dict__["_get_eclipsing_bodies"] = IAGFUNCTYPE(pUnk, IID_ISRPReflectionPlugin, vtable_offset_local+10, POINTER(agcom.PVOID))
        self.__dict__["_get_include_boundary_mitigation"] = IAGFUNCTYPE(pUnk, IID_ISRPReflectionPlugin, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_include_boundary_mitigation"] = IAGFUNCTYPE(pUnk, IID_ISRPReflectionPlugin, vtable_offset_local+12, agcom.VARIANT_BOOL)
        self.__dict__["_get_use_sun_cb_file_values"] = IAGFUNCTYPE(pUnk, IID_ISRPReflectionPlugin, vtable_offset_local+13, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_sun_cb_file_values"] = IAGFUNCTYPE(pUnk, IID_ISRPReflectionPlugin, vtable_offset_local+14, agcom.VARIANT_BOOL)
        self.__dict__["_get_solar_radius"] = IAGFUNCTYPE(pUnk, IID_ISRPReflectionPlugin, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_solar_radius"] = IAGFUNCTYPE(pUnk, IID_ISRPReflectionPlugin, vtable_offset_local+16, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ISRPReflectionPlugin.__dict__ and type(ISRPReflectionPlugin.__dict__[attrname]) == property:
            return ISRPReflectionPlugin.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ISRPReflectionPlugin.")
    
    @property
    def plugin_identifier(self) -> str:
        """The plugin name."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_plugin_identifier"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @plugin_identifier.setter
    def plugin_identifier(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_plugin_identifier"](arg_inVal.COM_val))

    @property
    def plugin_config(self) -> "IPluginProperties":
        """The properties of the selected plugin."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_plugin_config"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def atmos_alt(self) -> float:
        """The atmospheric altitude for eclipse. A simple model to account for some measure of attenuation that simply increases the shape of the Earth by the defined altitude height, often taken to be 23 km. Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_atmos_alt"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @atmos_alt.setter
    def atmos_alt(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_atmos_alt"](arg_inVal.COM_val))

    @property
    def shadow_model(self) -> "AgEVAShadowModel":
        """The shadow model type."""
        with agmarshall.AgEnum_arg(AgEVAShadowModel) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_shadow_model"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @shadow_model.setter
    def shadow_model(self, inVal:"AgEVAShadowModel") -> None:
        with agmarshall.AgEnum_arg(AgEVAShadowModel, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_shadow_model"](arg_inVal.COM_val))

    @property
    def sun_position(self) -> "AgEVASunPosition":
        """The sun position computation."""
        with agmarshall.AgEnum_arg(AgEVASunPosition) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_sun_position"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @sun_position.setter
    def sun_position(self, inVal:"AgEVASunPosition") -> None:
        with agmarshall.AgEnum_arg(AgEVASunPosition, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_sun_position"](arg_inVal.COM_val))

    @property
    def eclipsing_bodies(self) -> "ICentralBodyCollection":
        """Other eclipsing bodies."""
        with agmarshall.AgInterface_out_arg() as arg_ppCentralBodyCollection:
            agcls.evaluate_hresult(self.__dict__["_get_eclipsing_bodies"](byref(arg_ppCentralBodyCollection.COM_val)))
            return arg_ppCentralBodyCollection.python_val

    @property
    def include_boundary_mitigation(self) -> bool:
        """True if shadow boundary mitigation should be performed; the state of the satellite after crossing a shadow boundary will be corrected for errors possibly caused by the sudden change in SRP which occurred during the integration step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pMitigation:
            agcls.evaluate_hresult(self.__dict__["_get_include_boundary_mitigation"](byref(arg_pMitigation.COM_val)))
            return arg_pMitigation.python_val

    @include_boundary_mitigation.setter
    def include_boundary_mitigation(self, mitigation:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(mitigation) as arg_mitigation:
            agcls.evaluate_hresult(self.__dict__["_set_include_boundary_mitigation"](arg_mitigation.COM_val))

    @property
    def use_sun_cb_file_values(self) -> bool:
        """True if solar values should come from the Sun.cb file."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_sun_cb_file_values"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_sun_cb_file_values.setter
    def use_sun_cb_file_values(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_sun_cb_file_values"](arg_inVal.COM_val))

    @property
    def solar_radius(self) -> float:
        """The solar radius value to use in eclipse calculations.  Uses Distance Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_solar_radius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @solar_radius.setter
    def solar_radius(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_solar_radius"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2DF13668-98B3-4E69-89CA-C8136EAE49D9}", ISRPReflectionPlugin)
agcls.AgTypeNameMap["ISRPReflectionPlugin"] = ISRPReflectionPlugin

class IEngineModelThrustCoefficients(object):
    """Thrust coefficient properties for engine definition."""
    _uuid = "{2F905CDC-4D91-497F-85E2-AE1E2F3A4FA3}"
    _num_methods = 32
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_c0"] = _raise_uninitialized_error
        self.__dict__["_set_c0"] = _raise_uninitialized_error
        self.__dict__["_get_c1"] = _raise_uninitialized_error
        self.__dict__["_set_c1"] = _raise_uninitialized_error
        self.__dict__["_get_c2"] = _raise_uninitialized_error
        self.__dict__["_set_c2"] = _raise_uninitialized_error
        self.__dict__["_get_c3"] = _raise_uninitialized_error
        self.__dict__["_set_c3"] = _raise_uninitialized_error
        self.__dict__["_get_c4"] = _raise_uninitialized_error
        self.__dict__["_set_c4"] = _raise_uninitialized_error
        self.__dict__["_get_c5"] = _raise_uninitialized_error
        self.__dict__["_set_c5"] = _raise_uninitialized_error
        self.__dict__["_get_c6"] = _raise_uninitialized_error
        self.__dict__["_set_c6"] = _raise_uninitialized_error
        self.__dict__["_get_c7"] = _raise_uninitialized_error
        self.__dict__["_set_c7"] = _raise_uninitialized_error
        self.__dict__["_get_e4"] = _raise_uninitialized_error
        self.__dict__["_set_e4"] = _raise_uninitialized_error
        self.__dict__["_get_e5"] = _raise_uninitialized_error
        self.__dict__["_set_e5"] = _raise_uninitialized_error
        self.__dict__["_get_e6"] = _raise_uninitialized_error
        self.__dict__["_set_e6"] = _raise_uninitialized_error
        self.__dict__["_get_e7"] = _raise_uninitialized_error
        self.__dict__["_set_e7"] = _raise_uninitialized_error
        self.__dict__["_get_b7"] = _raise_uninitialized_error
        self.__dict__["_set_b7"] = _raise_uninitialized_error
        self.__dict__["_get_k0"] = _raise_uninitialized_error
        self.__dict__["_set_k0"] = _raise_uninitialized_error
        self.__dict__["_get_k1"] = _raise_uninitialized_error
        self.__dict__["_set_k1"] = _raise_uninitialized_error
        self.__dict__["_get_reference_temp"] = _raise_uninitialized_error
        self.__dict__["_set_reference_temp"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEngineModelThrustCoefficients._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEngineModelThrustCoefficients from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEngineModelThrustCoefficients = agcom.GUID(IEngineModelThrustCoefficients._uuid)
        vtable_offset_local = IEngineModelThrustCoefficients._vtable_offset - 1
        self.__dict__["_get_c0"] = IAGFUNCTYPE(pUnk, IID_IEngineModelThrustCoefficients, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_c0"] = IAGFUNCTYPE(pUnk, IID_IEngineModelThrustCoefficients, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_c1"] = IAGFUNCTYPE(pUnk, IID_IEngineModelThrustCoefficients, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_c1"] = IAGFUNCTYPE(pUnk, IID_IEngineModelThrustCoefficients, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_c2"] = IAGFUNCTYPE(pUnk, IID_IEngineModelThrustCoefficients, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_c2"] = IAGFUNCTYPE(pUnk, IID_IEngineModelThrustCoefficients, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_c3"] = IAGFUNCTYPE(pUnk, IID_IEngineModelThrustCoefficients, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_c3"] = IAGFUNCTYPE(pUnk, IID_IEngineModelThrustCoefficients, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_c4"] = IAGFUNCTYPE(pUnk, IID_IEngineModelThrustCoefficients, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_c4"] = IAGFUNCTYPE(pUnk, IID_IEngineModelThrustCoefficients, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_c5"] = IAGFUNCTYPE(pUnk, IID_IEngineModelThrustCoefficients, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_c5"] = IAGFUNCTYPE(pUnk, IID_IEngineModelThrustCoefficients, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_c6"] = IAGFUNCTYPE(pUnk, IID_IEngineModelThrustCoefficients, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_c6"] = IAGFUNCTYPE(pUnk, IID_IEngineModelThrustCoefficients, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_c7"] = IAGFUNCTYPE(pUnk, IID_IEngineModelThrustCoefficients, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_c7"] = IAGFUNCTYPE(pUnk, IID_IEngineModelThrustCoefficients, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_e4"] = IAGFUNCTYPE(pUnk, IID_IEngineModelThrustCoefficients, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_e4"] = IAGFUNCTYPE(pUnk, IID_IEngineModelThrustCoefficients, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_e5"] = IAGFUNCTYPE(pUnk, IID_IEngineModelThrustCoefficients, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_set_e5"] = IAGFUNCTYPE(pUnk, IID_IEngineModelThrustCoefficients, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_get_e6"] = IAGFUNCTYPE(pUnk, IID_IEngineModelThrustCoefficients, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_set_e6"] = IAGFUNCTYPE(pUnk, IID_IEngineModelThrustCoefficients, vtable_offset_local+22, agcom.DOUBLE)
        self.__dict__["_get_e7"] = IAGFUNCTYPE(pUnk, IID_IEngineModelThrustCoefficients, vtable_offset_local+23, POINTER(agcom.DOUBLE))
        self.__dict__["_set_e7"] = IAGFUNCTYPE(pUnk, IID_IEngineModelThrustCoefficients, vtable_offset_local+24, agcom.DOUBLE)
        self.__dict__["_get_b7"] = IAGFUNCTYPE(pUnk, IID_IEngineModelThrustCoefficients, vtable_offset_local+25, POINTER(agcom.DOUBLE))
        self.__dict__["_set_b7"] = IAGFUNCTYPE(pUnk, IID_IEngineModelThrustCoefficients, vtable_offset_local+26, agcom.DOUBLE)
        self.__dict__["_get_k0"] = IAGFUNCTYPE(pUnk, IID_IEngineModelThrustCoefficients, vtable_offset_local+27, POINTER(agcom.DOUBLE))
        self.__dict__["_set_k0"] = IAGFUNCTYPE(pUnk, IID_IEngineModelThrustCoefficients, vtable_offset_local+28, agcom.DOUBLE)
        self.__dict__["_get_k1"] = IAGFUNCTYPE(pUnk, IID_IEngineModelThrustCoefficients, vtable_offset_local+29, POINTER(agcom.DOUBLE))
        self.__dict__["_set_k1"] = IAGFUNCTYPE(pUnk, IID_IEngineModelThrustCoefficients, vtable_offset_local+30, agcom.DOUBLE)
        self.__dict__["_get_reference_temp"] = IAGFUNCTYPE(pUnk, IID_IEngineModelThrustCoefficients, vtable_offset_local+31, POINTER(agcom.DOUBLE))
        self.__dict__["_set_reference_temp"] = IAGFUNCTYPE(pUnk, IID_IEngineModelThrustCoefficients, vtable_offset_local+32, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEngineModelThrustCoefficients.__dict__ and type(IEngineModelThrustCoefficients.__dict__[attrname]) == property:
            return IEngineModelThrustCoefficients.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEngineModelThrustCoefficients.")
    
    @property
    def c0(self) -> float:
        """C0 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_c0"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @c0.setter
    def c0(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_c0"](arg_inVal.COM_val))

    @property
    def c1(self) -> float:
        """C1 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_c1"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @c1.setter
    def c1(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_c1"](arg_inVal.COM_val))

    @property
    def c2(self) -> float:
        """C2 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_c2"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @c2.setter
    def c2(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_c2"](arg_inVal.COM_val))

    @property
    def c3(self) -> float:
        """C3 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_c3"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @c3.setter
    def c3(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_c3"](arg_inVal.COM_val))

    @property
    def c4(self) -> float:
        """C4 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_c4"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @c4.setter
    def c4(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_c4"](arg_inVal.COM_val))

    @property
    def c5(self) -> float:
        """C5 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_c5"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @c5.setter
    def c5(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_c5"](arg_inVal.COM_val))

    @property
    def c6(self) -> float:
        """C6 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_c6"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @c6.setter
    def c6(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_c6"](arg_inVal.COM_val))

    @property
    def c7(self) -> float:
        """C7 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_c7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @c7.setter
    def c7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_c7"](arg_inVal.COM_val))

    @property
    def e4(self) -> float:
        """E4 exponent. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_e4"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @e4.setter
    def e4(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_e4"](arg_inVal.COM_val))

    @property
    def e5(self) -> float:
        """E5 exponent. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_e5"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @e5.setter
    def e5(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_e5"](arg_inVal.COM_val))

    @property
    def e6(self) -> float:
        """E6 exponent. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_e6"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @e6.setter
    def e6(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_e6"](arg_inVal.COM_val))

    @property
    def e7(self) -> float:
        """E7 exponent. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_e7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @e7.setter
    def e7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_e7"](arg_inVal.COM_val))

    @property
    def b7(self) -> float:
        """B7 base. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_b7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @b7.setter
    def b7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_b7"](arg_inVal.COM_val))

    @property
    def k0(self) -> float:
        """K0 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_k0"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @k0.setter
    def k0(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_k0"](arg_inVal.COM_val))

    @property
    def k1(self) -> float:
        """K1 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_k1"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @k1.setter
    def k1(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_k1"](arg_inVal.COM_val))

    @property
    def reference_temp(self) -> float:
        """Reference temperature for data. Uses Temperature Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_temp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_temp.setter
    def reference_temp(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_temp"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2F905CDC-4D91-497F-85E2-AE1E2F3A4FA3}", IEngineModelThrustCoefficients)
agcls.AgTypeNameMap["IEngineModelThrustCoefficients"] = IEngineModelThrustCoefficients

class IEngineModelIspCoefficients(object):
    """Isp coefficient properties for engine definition."""
    _uuid = "{3D092FFB-ED99-4F4A-94E5-8BFA7CEF328C}"
    _num_methods = 32
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_c0"] = _raise_uninitialized_error
        self.__dict__["_set_c0"] = _raise_uninitialized_error
        self.__dict__["_get_c1"] = _raise_uninitialized_error
        self.__dict__["_set_c1"] = _raise_uninitialized_error
        self.__dict__["_get_c2"] = _raise_uninitialized_error
        self.__dict__["_set_c2"] = _raise_uninitialized_error
        self.__dict__["_get_c3"] = _raise_uninitialized_error
        self.__dict__["_set_c3"] = _raise_uninitialized_error
        self.__dict__["_get_c4"] = _raise_uninitialized_error
        self.__dict__["_set_c4"] = _raise_uninitialized_error
        self.__dict__["_get_c5"] = _raise_uninitialized_error
        self.__dict__["_set_c5"] = _raise_uninitialized_error
        self.__dict__["_get_c6"] = _raise_uninitialized_error
        self.__dict__["_set_c6"] = _raise_uninitialized_error
        self.__dict__["_get_c7"] = _raise_uninitialized_error
        self.__dict__["_set_c7"] = _raise_uninitialized_error
        self.__dict__["_get_e4"] = _raise_uninitialized_error
        self.__dict__["_set_e4"] = _raise_uninitialized_error
        self.__dict__["_get_e5"] = _raise_uninitialized_error
        self.__dict__["_set_e5"] = _raise_uninitialized_error
        self.__dict__["_get_e6"] = _raise_uninitialized_error
        self.__dict__["_set_e6"] = _raise_uninitialized_error
        self.__dict__["_get_e7"] = _raise_uninitialized_error
        self.__dict__["_set_e7"] = _raise_uninitialized_error
        self.__dict__["_get_b7"] = _raise_uninitialized_error
        self.__dict__["_set_b7"] = _raise_uninitialized_error
        self.__dict__["_get_k0"] = _raise_uninitialized_error
        self.__dict__["_set_k0"] = _raise_uninitialized_error
        self.__dict__["_get_k1"] = _raise_uninitialized_error
        self.__dict__["_set_k1"] = _raise_uninitialized_error
        self.__dict__["_get_reference_temp"] = _raise_uninitialized_error
        self.__dict__["_set_reference_temp"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEngineModelIspCoefficients._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEngineModelIspCoefficients from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEngineModelIspCoefficients = agcom.GUID(IEngineModelIspCoefficients._uuid)
        vtable_offset_local = IEngineModelIspCoefficients._vtable_offset - 1
        self.__dict__["_get_c0"] = IAGFUNCTYPE(pUnk, IID_IEngineModelIspCoefficients, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_c0"] = IAGFUNCTYPE(pUnk, IID_IEngineModelIspCoefficients, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_c1"] = IAGFUNCTYPE(pUnk, IID_IEngineModelIspCoefficients, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_c1"] = IAGFUNCTYPE(pUnk, IID_IEngineModelIspCoefficients, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_c2"] = IAGFUNCTYPE(pUnk, IID_IEngineModelIspCoefficients, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_c2"] = IAGFUNCTYPE(pUnk, IID_IEngineModelIspCoefficients, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_c3"] = IAGFUNCTYPE(pUnk, IID_IEngineModelIspCoefficients, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_c3"] = IAGFUNCTYPE(pUnk, IID_IEngineModelIspCoefficients, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_c4"] = IAGFUNCTYPE(pUnk, IID_IEngineModelIspCoefficients, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_c4"] = IAGFUNCTYPE(pUnk, IID_IEngineModelIspCoefficients, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_c5"] = IAGFUNCTYPE(pUnk, IID_IEngineModelIspCoefficients, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_c5"] = IAGFUNCTYPE(pUnk, IID_IEngineModelIspCoefficients, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_c6"] = IAGFUNCTYPE(pUnk, IID_IEngineModelIspCoefficients, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_c6"] = IAGFUNCTYPE(pUnk, IID_IEngineModelIspCoefficients, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_c7"] = IAGFUNCTYPE(pUnk, IID_IEngineModelIspCoefficients, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_c7"] = IAGFUNCTYPE(pUnk, IID_IEngineModelIspCoefficients, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_e4"] = IAGFUNCTYPE(pUnk, IID_IEngineModelIspCoefficients, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_e4"] = IAGFUNCTYPE(pUnk, IID_IEngineModelIspCoefficients, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_e5"] = IAGFUNCTYPE(pUnk, IID_IEngineModelIspCoefficients, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_set_e5"] = IAGFUNCTYPE(pUnk, IID_IEngineModelIspCoefficients, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_get_e6"] = IAGFUNCTYPE(pUnk, IID_IEngineModelIspCoefficients, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_set_e6"] = IAGFUNCTYPE(pUnk, IID_IEngineModelIspCoefficients, vtable_offset_local+22, agcom.DOUBLE)
        self.__dict__["_get_e7"] = IAGFUNCTYPE(pUnk, IID_IEngineModelIspCoefficients, vtable_offset_local+23, POINTER(agcom.DOUBLE))
        self.__dict__["_set_e7"] = IAGFUNCTYPE(pUnk, IID_IEngineModelIspCoefficients, vtable_offset_local+24, agcom.DOUBLE)
        self.__dict__["_get_b7"] = IAGFUNCTYPE(pUnk, IID_IEngineModelIspCoefficients, vtable_offset_local+25, POINTER(agcom.DOUBLE))
        self.__dict__["_set_b7"] = IAGFUNCTYPE(pUnk, IID_IEngineModelIspCoefficients, vtable_offset_local+26, agcom.DOUBLE)
        self.__dict__["_get_k0"] = IAGFUNCTYPE(pUnk, IID_IEngineModelIspCoefficients, vtable_offset_local+27, POINTER(agcom.DOUBLE))
        self.__dict__["_set_k0"] = IAGFUNCTYPE(pUnk, IID_IEngineModelIspCoefficients, vtable_offset_local+28, agcom.DOUBLE)
        self.__dict__["_get_k1"] = IAGFUNCTYPE(pUnk, IID_IEngineModelIspCoefficients, vtable_offset_local+29, POINTER(agcom.DOUBLE))
        self.__dict__["_set_k1"] = IAGFUNCTYPE(pUnk, IID_IEngineModelIspCoefficients, vtable_offset_local+30, agcom.DOUBLE)
        self.__dict__["_get_reference_temp"] = IAGFUNCTYPE(pUnk, IID_IEngineModelIspCoefficients, vtable_offset_local+31, POINTER(agcom.DOUBLE))
        self.__dict__["_set_reference_temp"] = IAGFUNCTYPE(pUnk, IID_IEngineModelIspCoefficients, vtable_offset_local+32, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEngineModelIspCoefficients.__dict__ and type(IEngineModelIspCoefficients.__dict__[attrname]) == property:
            return IEngineModelIspCoefficients.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEngineModelIspCoefficients.")
    
    @property
    def c0(self) -> float:
        """C0 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_c0"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @c0.setter
    def c0(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_c0"](arg_inVal.COM_val))

    @property
    def c1(self) -> float:
        """C1 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_c1"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @c1.setter
    def c1(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_c1"](arg_inVal.COM_val))

    @property
    def c2(self) -> float:
        """C2 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_c2"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @c2.setter
    def c2(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_c2"](arg_inVal.COM_val))

    @property
    def c3(self) -> float:
        """C3 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_c3"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @c3.setter
    def c3(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_c3"](arg_inVal.COM_val))

    @property
    def c4(self) -> float:
        """C4 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_c4"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @c4.setter
    def c4(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_c4"](arg_inVal.COM_val))

    @property
    def c5(self) -> float:
        """C5 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_c5"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @c5.setter
    def c5(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_c5"](arg_inVal.COM_val))

    @property
    def c6(self) -> float:
        """C6 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_c6"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @c6.setter
    def c6(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_c6"](arg_inVal.COM_val))

    @property
    def c7(self) -> float:
        """C7 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_c7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @c7.setter
    def c7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_c7"](arg_inVal.COM_val))

    @property
    def e4(self) -> float:
        """E4 exponent. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_e4"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @e4.setter
    def e4(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_e4"](arg_inVal.COM_val))

    @property
    def e5(self) -> float:
        """E5 exponent. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_e5"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @e5.setter
    def e5(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_e5"](arg_inVal.COM_val))

    @property
    def e6(self) -> float:
        """E6 exponent. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_e6"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @e6.setter
    def e6(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_e6"](arg_inVal.COM_val))

    @property
    def e7(self) -> float:
        """E7 exponent. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_e7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @e7.setter
    def e7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_e7"](arg_inVal.COM_val))

    @property
    def b7(self) -> float:
        """B7 base. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_b7"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @b7.setter
    def b7(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_b7"](arg_inVal.COM_val))

    @property
    def k0(self) -> float:
        """K0 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_k0"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @k0.setter
    def k0(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_k0"](arg_inVal.COM_val))

    @property
    def k1(self) -> float:
        """K1 coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_k1"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @k1.setter
    def k1(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_k1"](arg_inVal.COM_val))

    @property
    def reference_temp(self) -> float:
        """Reference temperature for data. Uses Temperature Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_temp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_temp.setter
    def reference_temp(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_temp"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{3D092FFB-ED99-4F4A-94E5-8BFA7CEF328C}", IEngineModelIspCoefficients)
agcls.AgTypeNameMap["IEngineModelIspCoefficients"] = IEngineModelIspCoefficients

class IEngineConstAcc(object):
    """Properties for a Constant Acceleration and Isp engine model."""
    _uuid = "{32A0554F-7D4A-4A7E-80B7-5B57ED17B9D2}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_g"] = _raise_uninitialized_error
        self.__dict__["_set_g"] = _raise_uninitialized_error
        self.__dict__["_get_acceleration"] = _raise_uninitialized_error
        self.__dict__["_set_acceleration"] = _raise_uninitialized_error
        self.__dict__["_get_isp"] = _raise_uninitialized_error
        self.__dict__["_set_isp"] = _raise_uninitialized_error
        self.__dict__["_enable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_disable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_is_control_parameter_enabled"] = _raise_uninitialized_error
        self.__dict__["_get_control_parameters_available"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEngineConstAcc._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEngineConstAcc from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEngineConstAcc = agcom.GUID(IEngineConstAcc._uuid)
        vtable_offset_local = IEngineConstAcc._vtable_offset - 1
        self.__dict__["_get_g"] = IAGFUNCTYPE(pUnk, IID_IEngineConstAcc, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_g"] = IAGFUNCTYPE(pUnk, IID_IEngineConstAcc, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_acceleration"] = IAGFUNCTYPE(pUnk, IID_IEngineConstAcc, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_acceleration"] = IAGFUNCTYPE(pUnk, IID_IEngineConstAcc, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_isp"] = IAGFUNCTYPE(pUnk, IID_IEngineConstAcc, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_isp"] = IAGFUNCTYPE(pUnk, IID_IEngineConstAcc, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_enable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IEngineConstAcc, vtable_offset_local+7, agcom.LONG)
        self.__dict__["_disable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IEngineConstAcc, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_is_control_parameter_enabled"] = IAGFUNCTYPE(pUnk, IID_IEngineConstAcc, vtable_offset_local+9, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_control_parameters_available"] = IAGFUNCTYPE(pUnk, IID_IEngineConstAcc, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEngineConstAcc.__dict__ and type(IEngineConstAcc.__dict__[attrname]) == property:
            return IEngineConstAcc.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEngineConstAcc.")
    
    @property
    def g(self) -> float:
        """The gravitational acceleration constant at sea level on the Earth. Uses Acceleration Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_g"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @g.setter
    def g(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_g"](arg_inVal.COM_val))

    @property
    def acceleration(self) -> float:
        """The acceleration for this engine. Uses Acceleration Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_acceleration"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @acceleration.setter
    def acceleration(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_acceleration"](arg_inVal.COM_val))

    @property
    def isp(self) -> float:
        """The specific impulse for this engine. Uses SpecificImpulse Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_isp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @isp.setter
    def isp(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_isp"](arg_inVal.COM_val))

    def enable_control_parameter(self, param:"AgEVAControlEngineConstAcc") -> None:
        """Enables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlEngineConstAcc, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_enable_control_parameter"](arg_param.COM_val))

    def disable_control_parameter(self, param:"AgEVAControlEngineConstAcc") -> None:
        """Disables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlEngineConstAcc, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_disable_control_parameter"](arg_param.COM_val))

    def is_control_parameter_enabled(self, param:"AgEVAControlEngineConstAcc") -> bool:
        """Sees if the specified control is enabled."""
        with agmarshall.AgEnum_arg(AgEVAControlEngineConstAcc, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_is_control_parameter_enabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_parameters_available(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_parameters_available"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{32A0554F-7D4A-4A7E-80B7-5B57ED17B9D2}", IEngineConstAcc)
agcls.AgTypeNameMap["IEngineConstAcc"] = IEngineConstAcc

class IEngineConstant(object):
    """Properties for a Constant Thrust and Isp engine model."""
    _uuid = "{1BA84003-AFE1-4AD5-B36B-967D7B9FF8B0}"
    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_g"] = _raise_uninitialized_error
        self.__dict__["_set_g"] = _raise_uninitialized_error
        self.__dict__["_get_thrust"] = _raise_uninitialized_error
        self.__dict__["_set_thrust"] = _raise_uninitialized_error
        self.__dict__["_get_isp"] = _raise_uninitialized_error
        self.__dict__["_set_isp"] = _raise_uninitialized_error
        self.__dict__["_enable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_disable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_is_control_parameter_enabled"] = _raise_uninitialized_error
        self.__dict__["_get_control_parameters_available"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEngineConstant._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEngineConstant from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEngineConstant = agcom.GUID(IEngineConstant._uuid)
        vtable_offset_local = IEngineConstant._vtable_offset - 1
        self.__dict__["_get_g"] = IAGFUNCTYPE(pUnk, IID_IEngineConstant, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_g"] = IAGFUNCTYPE(pUnk, IID_IEngineConstant, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_thrust"] = IAGFUNCTYPE(pUnk, IID_IEngineConstant, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_thrust"] = IAGFUNCTYPE(pUnk, IID_IEngineConstant, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_isp"] = IAGFUNCTYPE(pUnk, IID_IEngineConstant, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_isp"] = IAGFUNCTYPE(pUnk, IID_IEngineConstant, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_enable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IEngineConstant, vtable_offset_local+7, agcom.LONG)
        self.__dict__["_disable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IEngineConstant, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_is_control_parameter_enabled"] = IAGFUNCTYPE(pUnk, IID_IEngineConstant, vtable_offset_local+9, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_control_parameters_available"] = IAGFUNCTYPE(pUnk, IID_IEngineConstant, vtable_offset_local+10, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEngineConstant.__dict__ and type(IEngineConstant.__dict__[attrname]) == property:
            return IEngineConstant.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEngineConstant.")
    
    @property
    def g(self) -> float:
        """The gravitational acceleration constant at sea level on the Earth. Uses Acceleration Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_g"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @g.setter
    def g(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_g"](arg_inVal.COM_val))

    @property
    def thrust(self) -> float:
        """The thrust for this engine. Uses Force Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_thrust"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @thrust.setter
    def thrust(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_thrust"](arg_inVal.COM_val))

    @property
    def isp(self) -> float:
        """The specific impulse for this engine. Uses SpecificImpulse Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_isp"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @isp.setter
    def isp(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_isp"](arg_inVal.COM_val))

    def enable_control_parameter(self, param:"AgEVAControlEngineConstant") -> None:
        """Enables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlEngineConstant, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_enable_control_parameter"](arg_param.COM_val))

    def disable_control_parameter(self, param:"AgEVAControlEngineConstant") -> None:
        """Disables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlEngineConstant, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_disable_control_parameter"](arg_param.COM_val))

    def is_control_parameter_enabled(self, param:"AgEVAControlEngineConstant") -> bool:
        """Sees if the specified control is enabled."""
        with agmarshall.AgEnum_arg(AgEVAControlEngineConstant, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_is_control_parameter_enabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_parameters_available(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_parameters_available"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{1BA84003-AFE1-4AD5-B36B-967D7B9FF8B0}", IEngineConstant)
agcls.AgTypeNameMap["IEngineConstant"] = IEngineConstant

class IEngineDefinition(object):
    """Properties for engine definition for an Ion engine model."""
    _uuid = "{74BF5209-9E9B-45E3-8AE0-E68971558447}"
    _num_methods = 42
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_isp_c0"] = _raise_uninitialized_error
        self.__dict__["_set_isp_c0"] = _raise_uninitialized_error
        self.__dict__["_get_isp_c1"] = _raise_uninitialized_error
        self.__dict__["_set_isp_c1"] = _raise_uninitialized_error
        self.__dict__["_get_isp_c2"] = _raise_uninitialized_error
        self.__dict__["_set_isp_c2"] = _raise_uninitialized_error
        self.__dict__["_get_isp_c3"] = _raise_uninitialized_error
        self.__dict__["_set_isp_c3"] = _raise_uninitialized_error
        self.__dict__["_get_mass_flow_rate_equation_type"] = _raise_uninitialized_error
        self.__dict__["_set_mass_flow_rate_equation_type"] = _raise_uninitialized_error
        self.__dict__["_get_mass_flow_rate_c0"] = _raise_uninitialized_error
        self.__dict__["_set_mass_flow_rate_c0"] = _raise_uninitialized_error
        self.__dict__["_get_mass_flow_rate_c1"] = _raise_uninitialized_error
        self.__dict__["_set_mass_flow_rate_c1"] = _raise_uninitialized_error
        self.__dict__["_get_mass_flow_rate_c2"] = _raise_uninitialized_error
        self.__dict__["_set_mass_flow_rate_c2"] = _raise_uninitialized_error
        self.__dict__["_get_mass_flow_rate_c3"] = _raise_uninitialized_error
        self.__dict__["_set_mass_flow_rate_c3"] = _raise_uninitialized_error
        self.__dict__["_get_mass_flow_rate_equation"] = _raise_uninitialized_error
        self.__dict__["_get_mass_flow_efficiency_c0"] = _raise_uninitialized_error
        self.__dict__["_set_mass_flow_efficiency_c0"] = _raise_uninitialized_error
        self.__dict__["_get_mass_flow_efficiency_c1"] = _raise_uninitialized_error
        self.__dict__["_set_mass_flow_efficiency_c1"] = _raise_uninitialized_error
        self.__dict__["_get_mass_flow_efficiency_c2"] = _raise_uninitialized_error
        self.__dict__["_set_mass_flow_efficiency_c2"] = _raise_uninitialized_error
        self.__dict__["_get_mass_flow_efficiency_c3"] = _raise_uninitialized_error
        self.__dict__["_set_mass_flow_efficiency_c3"] = _raise_uninitialized_error
        self.__dict__["_get_mass_flow_efficiency_independent_var"] = _raise_uninitialized_error
        self.__dict__["_set_mass_flow_efficiency_independent_var"] = _raise_uninitialized_error
        self.__dict__["_get_mass_flow_efficiency_equation"] = _raise_uninitialized_error
        self.__dict__["_get_power_efficiency_c0"] = _raise_uninitialized_error
        self.__dict__["_set_power_efficiency_c0"] = _raise_uninitialized_error
        self.__dict__["_get_power_efficiency_c1"] = _raise_uninitialized_error
        self.__dict__["_set_power_efficiency_c1"] = _raise_uninitialized_error
        self.__dict__["_get_power_efficiency_c2"] = _raise_uninitialized_error
        self.__dict__["_set_power_efficiency_c2"] = _raise_uninitialized_error
        self.__dict__["_get_power_efficiency_c3"] = _raise_uninitialized_error
        self.__dict__["_set_power_efficiency_c3"] = _raise_uninitialized_error
        self.__dict__["_get_power_efficiency_independent_var"] = _raise_uninitialized_error
        self.__dict__["_set_power_efficiency_independent_var"] = _raise_uninitialized_error
        self.__dict__["_get_power_efficiency_equation"] = _raise_uninitialized_error
        self.__dict__["_get_input_power_source_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEngineDefinition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEngineDefinition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEngineDefinition = agcom.GUID(IEngineDefinition._uuid)
        vtable_offset_local = IEngineDefinition._vtable_offset - 1
        self.__dict__["_get_isp_c0"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_isp_c0"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_isp_c1"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_isp_c1"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_isp_c2"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_isp_c2"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_isp_c3"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_isp_c3"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_mass_flow_rate_equation_type"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_set_mass_flow_rate_equation_type"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_get_mass_flow_rate_c0"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_mass_flow_rate_c0"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_mass_flow_rate_c1"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_mass_flow_rate_c1"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_mass_flow_rate_c2"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_mass_flow_rate_c2"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_mass_flow_rate_c3"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_mass_flow_rate_c3"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_mass_flow_rate_equation"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+19, POINTER(agcom.BSTR))
        self.__dict__["_get_mass_flow_efficiency_c0"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+20, POINTER(agcom.DOUBLE))
        self.__dict__["_set_mass_flow_efficiency_c0"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+21, agcom.DOUBLE)
        self.__dict__["_get_mass_flow_efficiency_c1"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+22, POINTER(agcom.DOUBLE))
        self.__dict__["_set_mass_flow_efficiency_c1"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+23, agcom.DOUBLE)
        self.__dict__["_get_mass_flow_efficiency_c2"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+24, POINTER(agcom.DOUBLE))
        self.__dict__["_set_mass_flow_efficiency_c2"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+25, agcom.DOUBLE)
        self.__dict__["_get_mass_flow_efficiency_c3"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+26, POINTER(agcom.DOUBLE))
        self.__dict__["_set_mass_flow_efficiency_c3"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+27, agcom.DOUBLE)
        self.__dict__["_get_mass_flow_efficiency_independent_var"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+28, POINTER(agcom.LONG))
        self.__dict__["_set_mass_flow_efficiency_independent_var"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+29, agcom.LONG)
        self.__dict__["_get_mass_flow_efficiency_equation"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+30, POINTER(agcom.BSTR))
        self.__dict__["_get_power_efficiency_c0"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+31, POINTER(agcom.DOUBLE))
        self.__dict__["_set_power_efficiency_c0"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+32, agcom.DOUBLE)
        self.__dict__["_get_power_efficiency_c1"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+33, POINTER(agcom.DOUBLE))
        self.__dict__["_set_power_efficiency_c1"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+34, agcom.DOUBLE)
        self.__dict__["_get_power_efficiency_c2"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+35, POINTER(agcom.DOUBLE))
        self.__dict__["_set_power_efficiency_c2"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+36, agcom.DOUBLE)
        self.__dict__["_get_power_efficiency_c3"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+37, POINTER(agcom.DOUBLE))
        self.__dict__["_set_power_efficiency_c3"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+38, agcom.DOUBLE)
        self.__dict__["_get_power_efficiency_independent_var"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+39, POINTER(agcom.LONG))
        self.__dict__["_set_power_efficiency_independent_var"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+40, agcom.LONG)
        self.__dict__["_get_power_efficiency_equation"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+41, POINTER(agcom.BSTR))
        self.__dict__["_get_input_power_source_name"] = IAGFUNCTYPE(pUnk, IID_IEngineDefinition, vtable_offset_local+42, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEngineDefinition.__dict__ and type(IEngineDefinition.__dict__[attrname]) == property:
            return IEngineDefinition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEngineDefinition.")
    
    @property
    def isp_c0(self) -> float:
        """The constant coefficient (C0). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_isp_c0"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @isp_c0.setter
    def isp_c0(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_isp_c0"](arg_inVal.COM_val))

    @property
    def isp_c1(self) -> float:
        """The linear coefficient (C1). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_isp_c1"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @isp_c1.setter
    def isp_c1(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_isp_c1"](arg_inVal.COM_val))

    @property
    def isp_c2(self) -> float:
        """The quadratic coefficient (C2). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_isp_c2"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @isp_c2.setter
    def isp_c2(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_isp_c2"](arg_inVal.COM_val))

    @property
    def isp_c3(self) -> float:
        """The cubic coefficient (C3). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_isp_c3"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @isp_c3.setter
    def isp_c3(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_isp_c3"](arg_inVal.COM_val))

    @property
    def mass_flow_rate_equation_type(self) -> "AgEVAEngineModelFunction":
        """The independent variable for the mass flow rate equation."""
        with agmarshall.AgEnum_arg(AgEVAEngineModelFunction) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_mass_flow_rate_equation_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @mass_flow_rate_equation_type.setter
    def mass_flow_rate_equation_type(self, inVal:"AgEVAEngineModelFunction") -> None:
        with agmarshall.AgEnum_arg(AgEVAEngineModelFunction, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_mass_flow_rate_equation_type"](arg_inVal.COM_val))

    @property
    def mass_flow_rate_c0(self) -> float:
        """The constant coefficient (C0). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_mass_flow_rate_c0"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @mass_flow_rate_c0.setter
    def mass_flow_rate_c0(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_mass_flow_rate_c0"](arg_inVal.COM_val))

    @property
    def mass_flow_rate_c1(self) -> float:
        """The linear coefficient (C1). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_mass_flow_rate_c1"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @mass_flow_rate_c1.setter
    def mass_flow_rate_c1(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_mass_flow_rate_c1"](arg_inVal.COM_val))

    @property
    def mass_flow_rate_c2(self) -> float:
        """The quadratic coefficient (C2). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_mass_flow_rate_c2"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @mass_flow_rate_c2.setter
    def mass_flow_rate_c2(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_mass_flow_rate_c2"](arg_inVal.COM_val))

    @property
    def mass_flow_rate_c3(self) -> float:
        """The cubic coefficient (C3). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_mass_flow_rate_c3"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @mass_flow_rate_c3.setter
    def mass_flow_rate_c3(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_mass_flow_rate_c3"](arg_inVal.COM_val))

    @property
    def mass_flow_rate_equation(self) -> str:
        """The equation for mass flow rate."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_mass_flow_rate_equation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def mass_flow_efficiency_c0(self) -> float:
        """The constant coefficient (C0). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_mass_flow_efficiency_c0"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @mass_flow_efficiency_c0.setter
    def mass_flow_efficiency_c0(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_mass_flow_efficiency_c0"](arg_inVal.COM_val))

    @property
    def mass_flow_efficiency_c1(self) -> float:
        """The linear coefficient (C1). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_mass_flow_efficiency_c1"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @mass_flow_efficiency_c1.setter
    def mass_flow_efficiency_c1(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_mass_flow_efficiency_c1"](arg_inVal.COM_val))

    @property
    def mass_flow_efficiency_c2(self) -> float:
        """The quadratic coefficient (C2). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_mass_flow_efficiency_c2"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @mass_flow_efficiency_c2.setter
    def mass_flow_efficiency_c2(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_mass_flow_efficiency_c2"](arg_inVal.COM_val))

    @property
    def mass_flow_efficiency_c3(self) -> float:
        """The cubic coefficient (C3). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_mass_flow_efficiency_c3"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @mass_flow_efficiency_c3.setter
    def mass_flow_efficiency_c3(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_mass_flow_efficiency_c3"](arg_inVal.COM_val))

    @property
    def mass_flow_efficiency_independent_var(self) -> "AgEVAEngineModelFunction":
        """The independent variable for the mass flow efficiency equation."""
        with agmarshall.AgEnum_arg(AgEVAEngineModelFunction) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_mass_flow_efficiency_independent_var"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @mass_flow_efficiency_independent_var.setter
    def mass_flow_efficiency_independent_var(self, inVal:"AgEVAEngineModelFunction") -> None:
        with agmarshall.AgEnum_arg(AgEVAEngineModelFunction, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_mass_flow_efficiency_independent_var"](arg_inVal.COM_val))

    @property
    def mass_flow_efficiency_equation(self) -> str:
        """The equation for mass flow efficiency."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_mass_flow_efficiency_equation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def power_efficiency_c0(self) -> float:
        """The constant coefficient (C0). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_power_efficiency_c0"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @power_efficiency_c0.setter
    def power_efficiency_c0(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_power_efficiency_c0"](arg_inVal.COM_val))

    @property
    def power_efficiency_c1(self) -> float:
        """The linear coefficient (C1). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_power_efficiency_c1"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @power_efficiency_c1.setter
    def power_efficiency_c1(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_power_efficiency_c1"](arg_inVal.COM_val))

    @property
    def power_efficiency_c2(self) -> float:
        """The quadratic coefficient (C2). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_power_efficiency_c2"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @power_efficiency_c2.setter
    def power_efficiency_c2(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_power_efficiency_c2"](arg_inVal.COM_val))

    @property
    def power_efficiency_c3(self) -> float:
        """The cubic coefficient (C3). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_power_efficiency_c3"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @power_efficiency_c3.setter
    def power_efficiency_c3(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_power_efficiency_c3"](arg_inVal.COM_val))

    @property
    def power_efficiency_independent_var(self) -> "AgEVAEngineModelFunction":
        """The independent variable for the power efficiency equation."""
        with agmarshall.AgEnum_arg(AgEVAEngineModelFunction) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_power_efficiency_independent_var"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @power_efficiency_independent_var.setter
    def power_efficiency_independent_var(self, inVal:"AgEVAEngineModelFunction") -> None:
        with agmarshall.AgEnum_arg(AgEVAEngineModelFunction, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_power_efficiency_independent_var"](arg_inVal.COM_val))

    @property
    def power_efficiency_equation(self) -> str:
        """The equation for power efficiency."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_power_efficiency_equation"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def input_power_source_name(self) -> str:
        """Object that computes the power input to the engine"""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_input_power_source_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{74BF5209-9E9B-45E3-8AE0-E68971558447}", IEngineDefinition)
agcls.AgTypeNameMap["IEngineDefinition"] = IEngineDefinition

class IEngineThrottleTable(object):
    """Properties for engine parameters for a Throttle Table engine model"""
    _uuid = "{74EFDF26-3F92-4664-8CA1-47E86FCAB002}"
    _num_methods = 18
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_throttle_table_filename"] = _raise_uninitialized_error
        self.__dict__["_set_throttle_table_filename"] = _raise_uninitialized_error
        self.__dict__["_get_operation_mode_definition"] = _raise_uninitialized_error
        self.__dict__["_set_operation_mode_definition"] = _raise_uninitialized_error
        self.__dict__["_get_regression_polynomial_degree"] = _raise_uninitialized_error
        self.__dict__["_set_regression_polynomial_degree"] = _raise_uninitialized_error
        self.__dict__["_get_g"] = _raise_uninitialized_error
        self.__dict__["_set_g"] = _raise_uninitialized_error
        self.__dict__["_get_input_power_source_name"] = _raise_uninitialized_error
        self.__dict__["_set_input_power_source_name"] = _raise_uninitialized_error
        self.__dict__["_get_percent_degradation_per_year"] = _raise_uninitialized_error
        self.__dict__["_set_percent_degradation_per_year"] = _raise_uninitialized_error
        self.__dict__["_get_reference_epoch"] = _raise_uninitialized_error
        self.__dict__["_set_reference_epoch"] = _raise_uninitialized_error
        self.__dict__["_enable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_disable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_is_control_parameter_enabled"] = _raise_uninitialized_error
        self.__dict__["_get_control_parameters_available"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEngineThrottleTable._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEngineThrottleTable from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEngineThrottleTable = agcom.GUID(IEngineThrottleTable._uuid)
        vtable_offset_local = IEngineThrottleTable._vtable_offset - 1
        self.__dict__["_get_throttle_table_filename"] = IAGFUNCTYPE(pUnk, IID_IEngineThrottleTable, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_throttle_table_filename"] = IAGFUNCTYPE(pUnk, IID_IEngineThrottleTable, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_operation_mode_definition"] = IAGFUNCTYPE(pUnk, IID_IEngineThrottleTable, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_set_operation_mode_definition"] = IAGFUNCTYPE(pUnk, IID_IEngineThrottleTable, vtable_offset_local+4, agcom.LONG)
        self.__dict__["_get_regression_polynomial_degree"] = IAGFUNCTYPE(pUnk, IID_IEngineThrottleTable, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_regression_polynomial_degree"] = IAGFUNCTYPE(pUnk, IID_IEngineThrottleTable, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_g"] = IAGFUNCTYPE(pUnk, IID_IEngineThrottleTable, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_g"] = IAGFUNCTYPE(pUnk, IID_IEngineThrottleTable, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_input_power_source_name"] = IAGFUNCTYPE(pUnk, IID_IEngineThrottleTable, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_set_input_power_source_name"] = IAGFUNCTYPE(pUnk, IID_IEngineThrottleTable, vtable_offset_local+10, agcom.BSTR)
        self.__dict__["_get_percent_degradation_per_year"] = IAGFUNCTYPE(pUnk, IID_IEngineThrottleTable, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_percent_degradation_per_year"] = IAGFUNCTYPE(pUnk, IID_IEngineThrottleTable, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_reference_epoch"] = IAGFUNCTYPE(pUnk, IID_IEngineThrottleTable, vtable_offset_local+13, POINTER(agcom.VARIANT))
        self.__dict__["_set_reference_epoch"] = IAGFUNCTYPE(pUnk, IID_IEngineThrottleTable, vtable_offset_local+14, agcom.VARIANT)
        self.__dict__["_enable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IEngineThrottleTable, vtable_offset_local+15, agcom.LONG)
        self.__dict__["_disable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IEngineThrottleTable, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_is_control_parameter_enabled"] = IAGFUNCTYPE(pUnk, IID_IEngineThrottleTable, vtable_offset_local+17, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_control_parameters_available"] = IAGFUNCTYPE(pUnk, IID_IEngineThrottleTable, vtable_offset_local+18, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEngineThrottleTable.__dict__ and type(IEngineThrottleTable.__dict__[attrname]) == property:
            return IEngineThrottleTable.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEngineThrottleTable.")
    
    @property
    def throttle_table_filename(self) -> str:
        """A file containing the engine performance data in the tabular format."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_throttle_table_filename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @throttle_table_filename.setter
    def throttle_table_filename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_throttle_table_filename"](arg_inVal.COM_val))

    @property
    def operation_mode_definition(self) -> "AgEVAThrottleTableOperationMode":
        """The engine operation mode definition."""
        with agmarshall.AgEnum_arg(AgEVAThrottleTableOperationMode) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_operation_mode_definition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @operation_mode_definition.setter
    def operation_mode_definition(self, inVal:"AgEVAThrottleTableOperationMode") -> None:
        with agmarshall.AgEnum_arg(AgEVAThrottleTableOperationMode, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_operation_mode_definition"](arg_inVal.COM_val))

    @property
    def regression_polynomial_degree(self) -> int:
        """The degree of the regression polynomial. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_regression_polynomial_degree"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @regression_polynomial_degree.setter
    def regression_polynomial_degree(self, inVal:int) -> None:
        with agmarshall.LONG_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_regression_polynomial_degree"](arg_inVal.COM_val))

    @property
    def g(self) -> float:
        """The gravitational acceleration constant at sea level on the Earth. Uses Acceleration Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_g"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @g.setter
    def g(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_g"](arg_inVal.COM_val))

    @property
    def input_power_source_name(self) -> str:
        """The object that computes the power input to the engine."""
        with agmarshall.BSTR_arg() as arg_pPowerSource:
            agcls.evaluate_hresult(self.__dict__["_get_input_power_source_name"](byref(arg_pPowerSource.COM_val)))
            return arg_pPowerSource.python_val

    @input_power_source_name.setter
    def input_power_source_name(self, powerSource:str) -> None:
        with agmarshall.BSTR_arg(powerSource) as arg_powerSource:
            agcls.evaluate_hresult(self.__dict__["_set_input_power_source_name"](arg_powerSource.COM_val))

    @property
    def percent_degradation_per_year(self) -> float:
        """The degradation factor is (1-x%/yr)^(timeSinceRefEpoch)"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_percent_degradation_per_year"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @percent_degradation_per_year.setter
    def percent_degradation_per_year(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_percent_degradation_per_year"](arg_inVal.COM_val))

    @property
    def reference_epoch(self) -> typing.Any:
        """The date and Time used as reference epoch for degradation. Uses DateFormat Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_epoch"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_epoch.setter
    def reference_epoch(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_epoch"](arg_inVal.COM_val))

    def enable_control_parameter(self, param:"AgEVAControlEngineThrottleTable") -> None:
        """Enables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlEngineThrottleTable, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_enable_control_parameter"](arg_param.COM_val))

    def disable_control_parameter(self, param:"AgEVAControlEngineThrottleTable") -> None:
        """Disables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlEngineThrottleTable, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_disable_control_parameter"](arg_param.COM_val))

    def is_control_parameter_enabled(self, param:"AgEVAControlEngineThrottleTable") -> bool:
        """Sees if the specified control is enabled."""
        with agmarshall.AgEnum_arg(AgEVAControlEngineThrottleTable, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_is_control_parameter_enabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_parameters_available(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_parameters_available"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{74EFDF26-3F92-4664-8CA1-47E86FCAB002}", IEngineThrottleTable)
agcls.AgTypeNameMap["IEngineThrottleTable"] = IEngineThrottleTable

class IEngineIon(object):
    """Properties for engine parameters for an Ion engine model"""
    _uuid = "{1A331BF6-2901-41F4-8A68-23DD4628A68D}"
    _num_methods = 19
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_g"] = _raise_uninitialized_error
        self.__dict__["_set_g"] = _raise_uninitialized_error
        self.__dict__["_get_input_power_source_name"] = _raise_uninitialized_error
        self.__dict__["_set_input_power_source_name"] = _raise_uninitialized_error
        self.__dict__["_get_min_required_power"] = _raise_uninitialized_error
        self.__dict__["_set_min_required_power"] = _raise_uninitialized_error
        self.__dict__["_get_max_input_power"] = _raise_uninitialized_error
        self.__dict__["_set_max_input_power"] = _raise_uninitialized_error
        self.__dict__["_get_percent_degradation_per_year"] = _raise_uninitialized_error
        self.__dict__["_set_percent_degradation_per_year"] = _raise_uninitialized_error
        self.__dict__["_get_reference_epoch"] = _raise_uninitialized_error
        self.__dict__["_set_reference_epoch"] = _raise_uninitialized_error
        self.__dict__["_get_percent_throttle"] = _raise_uninitialized_error
        self.__dict__["_set_percent_throttle"] = _raise_uninitialized_error
        self.__dict__["_get_engine_definition"] = _raise_uninitialized_error
        self.__dict__["_enable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_disable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_is_control_parameter_enabled"] = _raise_uninitialized_error
        self.__dict__["_get_control_parameters_available"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEngineIon._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEngineIon from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEngineIon = agcom.GUID(IEngineIon._uuid)
        vtable_offset_local = IEngineIon._vtable_offset - 1
        self.__dict__["_get_g"] = IAGFUNCTYPE(pUnk, IID_IEngineIon, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_g"] = IAGFUNCTYPE(pUnk, IID_IEngineIon, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_input_power_source_name"] = IAGFUNCTYPE(pUnk, IID_IEngineIon, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_input_power_source_name"] = IAGFUNCTYPE(pUnk, IID_IEngineIon, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_get_min_required_power"] = IAGFUNCTYPE(pUnk, IID_IEngineIon, vtable_offset_local+5, POINTER(agcom.DOUBLE))
        self.__dict__["_set_min_required_power"] = IAGFUNCTYPE(pUnk, IID_IEngineIon, vtable_offset_local+6, agcom.DOUBLE)
        self.__dict__["_get_max_input_power"] = IAGFUNCTYPE(pUnk, IID_IEngineIon, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_input_power"] = IAGFUNCTYPE(pUnk, IID_IEngineIon, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_percent_degradation_per_year"] = IAGFUNCTYPE(pUnk, IID_IEngineIon, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_percent_degradation_per_year"] = IAGFUNCTYPE(pUnk, IID_IEngineIon, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_reference_epoch"] = IAGFUNCTYPE(pUnk, IID_IEngineIon, vtable_offset_local+11, POINTER(agcom.VARIANT))
        self.__dict__["_set_reference_epoch"] = IAGFUNCTYPE(pUnk, IID_IEngineIon, vtable_offset_local+12, agcom.VARIANT)
        self.__dict__["_get_percent_throttle"] = IAGFUNCTYPE(pUnk, IID_IEngineIon, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_percent_throttle"] = IAGFUNCTYPE(pUnk, IID_IEngineIon, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_engine_definition"] = IAGFUNCTYPE(pUnk, IID_IEngineIon, vtable_offset_local+15, POINTER(agcom.PVOID))
        self.__dict__["_enable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IEngineIon, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_disable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IEngineIon, vtable_offset_local+17, agcom.LONG)
        self.__dict__["_is_control_parameter_enabled"] = IAGFUNCTYPE(pUnk, IID_IEngineIon, vtable_offset_local+18, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_control_parameters_available"] = IAGFUNCTYPE(pUnk, IID_IEngineIon, vtable_offset_local+19, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEngineIon.__dict__ and type(IEngineIon.__dict__[attrname]) == property:
            return IEngineIon.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEngineIon.")
    
    @property
    def g(self) -> float:
        """The gravitational acceleration constant at sea level on the Earth. Uses Acceleration Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_g"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @g.setter
    def g(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_g"](arg_inVal.COM_val))

    @property
    def input_power_source_name(self) -> str:
        """The object that computes the power input to the engine."""
        with agmarshall.BSTR_arg() as arg_pPowerSource:
            agcls.evaluate_hresult(self.__dict__["_get_input_power_source_name"](byref(arg_pPowerSource.COM_val)))
            return arg_pPowerSource.python_val

    @input_power_source_name.setter
    def input_power_source_name(self, powerSource:str) -> None:
        with agmarshall.BSTR_arg(powerSource) as arg_powerSource:
            agcls.evaluate_hresult(self.__dict__["_set_input_power_source_name"](arg_powerSource.COM_val))

    @property
    def min_required_power(self) -> float:
        """The minimum power required for engine to produce thrust. Uses Power Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_required_power"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @min_required_power.setter
    def min_required_power(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_min_required_power"](arg_inVal.COM_val))

    @property
    def max_input_power(self) -> float:
        """The maximum power that can be used by engine to produce thrust. Uses Power Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_input_power"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_input_power.setter
    def max_input_power(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_input_power"](arg_inVal.COM_val))

    @property
    def percent_degradation_per_year(self) -> float:
        """The degradation factor is (1-x%/yr)^(timeSinceRefEpoch)"""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_percent_degradation_per_year"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @percent_degradation_per_year.setter
    def percent_degradation_per_year(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_percent_degradation_per_year"](arg_inVal.COM_val))

    @property
    def reference_epoch(self) -> typing.Any:
        """The date and Time used as reference epoch for degradation. Uses DateFormat Dimension."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_reference_epoch"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @reference_epoch.setter
    def reference_epoch(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_reference_epoch"](arg_inVal.COM_val))

    @property
    def percent_throttle(self) -> float:
        """The percentage of available thrust to use (100 is full on, 0 is off). Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_percent_throttle"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @percent_throttle.setter
    def percent_throttle(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_percent_throttle"](arg_inVal.COM_val))

    @property
    def engine_definition(self) -> "IEngineDefinition":
        """The engine definition."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAEngineDefinition:
            agcls.evaluate_hresult(self.__dict__["_get_engine_definition"](byref(arg_ppVAEngineDefinition.COM_val)))
            return arg_ppVAEngineDefinition.python_val

    def enable_control_parameter(self, param:"AgEVAControlEngineIon") -> None:
        """Enables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlEngineIon, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_enable_control_parameter"](arg_param.COM_val))

    def disable_control_parameter(self, param:"AgEVAControlEngineIon") -> None:
        """Disables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlEngineIon, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_disable_control_parameter"](arg_param.COM_val))

    def is_control_parameter_enabled(self, param:"AgEVAControlEngineIon") -> bool:
        """Sees if the specified control is enabled."""
        with agmarshall.AgEnum_arg(AgEVAControlEngineIon, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_is_control_parameter_enabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_parameters_available(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_parameters_available"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{1A331BF6-2901-41F4-8A68-23DD4628A68D}", IEngineIon)
agcls.AgTypeNameMap["IEngineIon"] = IEngineIon

class IEngineCustom(object):
    """Properties for a Custom engine model."""
    _uuid = "{E17088BF-A34C-4C6B-8BF2-CEA2D489B428}"
    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_g"] = _raise_uninitialized_error
        self.__dict__["_set_g"] = _raise_uninitialized_error
        self.__dict__["_get_eval_function_name"] = _raise_uninitialized_error
        self.__dict__["_set_eval_function_name"] = _raise_uninitialized_error
        self.__dict__["_get_post_function_name"] = _raise_uninitialized_error
        self.__dict__["_set_post_function_name"] = _raise_uninitialized_error
        self.__dict__["_get_pre_function_name"] = _raise_uninitialized_error
        self.__dict__["_set_pre_function_name"] = _raise_uninitialized_error
        self.__dict__["_get_seg_start_function_name"] = _raise_uninitialized_error
        self.__dict__["_set_seg_start_function_name"] = _raise_uninitialized_error
        self.__dict__["_get_update_function_name"] = _raise_uninitialized_error
        self.__dict__["_set_update_function_name"] = _raise_uninitialized_error
        self.__dict__["_enable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_disable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_is_control_parameter_enabled"] = _raise_uninitialized_error
        self.__dict__["_get_control_parameters_available"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEngineCustom._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEngineCustom from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEngineCustom = agcom.GUID(IEngineCustom._uuid)
        vtable_offset_local = IEngineCustom._vtable_offset - 1
        self.__dict__["_get_g"] = IAGFUNCTYPE(pUnk, IID_IEngineCustom, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_g"] = IAGFUNCTYPE(pUnk, IID_IEngineCustom, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_eval_function_name"] = IAGFUNCTYPE(pUnk, IID_IEngineCustom, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_eval_function_name"] = IAGFUNCTYPE(pUnk, IID_IEngineCustom, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_get_post_function_name"] = IAGFUNCTYPE(pUnk, IID_IEngineCustom, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_set_post_function_name"] = IAGFUNCTYPE(pUnk, IID_IEngineCustom, vtable_offset_local+6, agcom.BSTR)
        self.__dict__["_get_pre_function_name"] = IAGFUNCTYPE(pUnk, IID_IEngineCustom, vtable_offset_local+7, POINTER(agcom.BSTR))
        self.__dict__["_set_pre_function_name"] = IAGFUNCTYPE(pUnk, IID_IEngineCustom, vtable_offset_local+8, agcom.BSTR)
        self.__dict__["_get_seg_start_function_name"] = IAGFUNCTYPE(pUnk, IID_IEngineCustom, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_set_seg_start_function_name"] = IAGFUNCTYPE(pUnk, IID_IEngineCustom, vtable_offset_local+10, agcom.BSTR)
        self.__dict__["_get_update_function_name"] = IAGFUNCTYPE(pUnk, IID_IEngineCustom, vtable_offset_local+11, POINTER(agcom.BSTR))
        self.__dict__["_set_update_function_name"] = IAGFUNCTYPE(pUnk, IID_IEngineCustom, vtable_offset_local+12, agcom.BSTR)
        self.__dict__["_enable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IEngineCustom, vtable_offset_local+13, agcom.LONG)
        self.__dict__["_disable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IEngineCustom, vtable_offset_local+14, agcom.LONG)
        self.__dict__["_is_control_parameter_enabled"] = IAGFUNCTYPE(pUnk, IID_IEngineCustom, vtable_offset_local+15, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_control_parameters_available"] = IAGFUNCTYPE(pUnk, IID_IEngineCustom, vtable_offset_local+16, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEngineCustom.__dict__ and type(IEngineCustom.__dict__[attrname]) == property:
            return IEngineCustom.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEngineCustom.")
    
    @property
    def g(self) -> float:
        """The earth surface gravity acceleration for Isp conversions. Uses Acceleration Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_g"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @g.setter
    def g(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_g"](arg_inVal.COM_val))

    @property
    def eval_function_name(self) -> str:
        """The EvalFunction - custom function to call at every thrust evaluation."""
        with agmarshall.BSTR_arg() as arg_pEvalFunction:
            agcls.evaluate_hresult(self.__dict__["_get_eval_function_name"](byref(arg_pEvalFunction.COM_val)))
            return arg_pEvalFunction.python_val

    @eval_function_name.setter
    def eval_function_name(self, evalFunction:str) -> None:
        with agmarshall.BSTR_arg(evalFunction) as arg_evalFunction:
            agcls.evaluate_hresult(self.__dict__["_set_eval_function_name"](arg_evalFunction.COM_val))

    @property
    def post_function_name(self) -> str:
        """The PostFunction - custom function to call after all propagation ends."""
        with agmarshall.BSTR_arg() as arg_pPostFunction:
            agcls.evaluate_hresult(self.__dict__["_get_post_function_name"](byref(arg_pPostFunction.COM_val)))
            return arg_pPostFunction.python_val

    @post_function_name.setter
    def post_function_name(self, postFunction:str) -> None:
        with agmarshall.BSTR_arg(postFunction) as arg_postFunction:
            agcls.evaluate_hresult(self.__dict__["_set_post_function_name"](arg_postFunction.COM_val))

    @property
    def pre_function_name(self) -> str:
        """The PreFunction - custom function to call before any propagation begins."""
        with agmarshall.BSTR_arg() as arg_pPreFunction:
            agcls.evaluate_hresult(self.__dict__["_get_pre_function_name"](byref(arg_pPreFunction.COM_val)))
            return arg_pPreFunction.python_val

    @pre_function_name.setter
    def pre_function_name(self, preFunction:str) -> None:
        with agmarshall.BSTR_arg(preFunction) as arg_preFunction:
            agcls.evaluate_hresult(self.__dict__["_set_pre_function_name"](arg_preFunction.COM_val))

    @property
    def seg_start_function_name(self) -> str:
        """The SegStartFunction - custom function to call at the beginning of each segment."""
        with agmarshall.BSTR_arg() as arg_pSegStartFunction:
            agcls.evaluate_hresult(self.__dict__["_get_seg_start_function_name"](byref(arg_pSegStartFunction.COM_val)))
            return arg_pSegStartFunction.python_val

    @seg_start_function_name.setter
    def seg_start_function_name(self, segStartFunction:str) -> None:
        with agmarshall.BSTR_arg(segStartFunction) as arg_segStartFunction:
            agcls.evaluate_hresult(self.__dict__["_set_seg_start_function_name"](arg_segStartFunction.COM_val))

    @property
    def update_function_name(self) -> str:
        """The UpdateFunction - custom function to call at the beginning of each integration step."""
        with agmarshall.BSTR_arg() as arg_pUpdateFunction:
            agcls.evaluate_hresult(self.__dict__["_get_update_function_name"](byref(arg_pUpdateFunction.COM_val)))
            return arg_pUpdateFunction.python_val

    @update_function_name.setter
    def update_function_name(self, updateFunction:str) -> None:
        with agmarshall.BSTR_arg(updateFunction) as arg_updateFunction:
            agcls.evaluate_hresult(self.__dict__["_set_update_function_name"](arg_updateFunction.COM_val))

    def enable_control_parameter(self, param:"AgEVAControlEngineCustom") -> None:
        """Enables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlEngineCustom, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_enable_control_parameter"](arg_param.COM_val))

    def disable_control_parameter(self, param:"AgEVAControlEngineCustom") -> None:
        """Disables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlEngineCustom, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_disable_control_parameter"](arg_param.COM_val))

    def is_control_parameter_enabled(self, param:"AgEVAControlEngineCustom") -> bool:
        """Sees if the specified control is enabled."""
        with agmarshall.AgEnum_arg(AgEVAControlEngineCustom, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_is_control_parameter_enabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_parameters_available(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_parameters_available"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{E17088BF-A34C-4C6B-8BF2-CEA2D489B428}", IEngineCustom)
agcls.AgTypeNameMap["IEngineCustom"] = IEngineCustom

class IEnginePlugin(object):
    """Properties for a Plugin engine model."""
    _uuid = "{68ED720F-ABB6-4891-A1B9-973719400161}"
    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_g"] = _raise_uninitialized_error
        self.__dict__["_set_g"] = _raise_uninitialized_error
        self.__dict__["_get_plugin_identifier"] = _raise_uninitialized_error
        self.__dict__["_set_plugin_identifier"] = _raise_uninitialized_error
        self.__dict__["_get_plugin_config"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEnginePlugin._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEnginePlugin from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEnginePlugin = agcom.GUID(IEnginePlugin._uuid)
        vtable_offset_local = IEnginePlugin._vtable_offset - 1
        self.__dict__["_get_g"] = IAGFUNCTYPE(pUnk, IID_IEnginePlugin, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_g"] = IAGFUNCTYPE(pUnk, IID_IEnginePlugin, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_plugin_identifier"] = IAGFUNCTYPE(pUnk, IID_IEnginePlugin, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_plugin_identifier"] = IAGFUNCTYPE(pUnk, IID_IEnginePlugin, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_get_plugin_config"] = IAGFUNCTYPE(pUnk, IID_IEnginePlugin, vtable_offset_local+5, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEnginePlugin.__dict__ and type(IEnginePlugin.__dict__[attrname]) == property:
            return IEnginePlugin.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEnginePlugin.")
    
    @property
    def g(self) -> float:
        """The gravitational acceleration constant at sea level on the Earth. Uses Acceleration Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_g"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @g.setter
    def g(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_g"](arg_inVal.COM_val))

    @property
    def plugin_identifier(self) -> str:
        """The PluginIdentifier - the ProgID of the COM component you are using for this model."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_plugin_identifier"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @plugin_identifier.setter
    def plugin_identifier(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_plugin_identifier"](arg_inVal.COM_val))

    @property
    def plugin_config(self) -> "IPluginProperties":
        """The properties of the plugin."""
        with agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_plugin_config"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{68ED720F-ABB6-4891-A1B9-973719400161}", IEnginePlugin)
agcls.AgTypeNameMap["IEnginePlugin"] = IEnginePlugin

class IEngineModelPoly(object):
    """Properties for a Polynomial Thrust and Isp engine model."""
    _uuid = "{4AC9E570-FB42-4636-B6DA-F9FEF353165B}"
    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_g"] = _raise_uninitialized_error
        self.__dict__["_set_g"] = _raise_uninitialized_error
        self.__dict__["_get_thrust_coefficients"] = _raise_uninitialized_error
        self.__dict__["_get_isp_coefficients"] = _raise_uninitialized_error
        self.__dict__["_enable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_disable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_is_control_parameter_enabled"] = _raise_uninitialized_error
        self.__dict__["_get_control_parameters_available"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IEngineModelPoly._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IEngineModelPoly from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IEngineModelPoly = agcom.GUID(IEngineModelPoly._uuid)
        vtable_offset_local = IEngineModelPoly._vtable_offset - 1
        self.__dict__["_get_g"] = IAGFUNCTYPE(pUnk, IID_IEngineModelPoly, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_g"] = IAGFUNCTYPE(pUnk, IID_IEngineModelPoly, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_thrust_coefficients"] = IAGFUNCTYPE(pUnk, IID_IEngineModelPoly, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_isp_coefficients"] = IAGFUNCTYPE(pUnk, IID_IEngineModelPoly, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_enable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IEngineModelPoly, vtable_offset_local+5, agcom.LONG)
        self.__dict__["_disable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IEngineModelPoly, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_is_control_parameter_enabled"] = IAGFUNCTYPE(pUnk, IID_IEngineModelPoly, vtable_offset_local+7, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_control_parameters_available"] = IAGFUNCTYPE(pUnk, IID_IEngineModelPoly, vtable_offset_local+8, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IEngineModelPoly.__dict__ and type(IEngineModelPoly.__dict__[attrname]) == property:
            return IEngineModelPoly.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IEngineModelPoly.")
    
    @property
    def g(self) -> float:
        """The gravitational acceleration constant at sea level on the Earth. Uses Acceleration Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_g"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @g.setter
    def g(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_g"](arg_inVal.COM_val))

    @property
    def thrust_coefficients(self) -> "IEngineModelThrustCoefficients":
        """The thrust Coefficients."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAEngineModelThrustCoefficients:
            agcls.evaluate_hresult(self.__dict__["_get_thrust_coefficients"](byref(arg_ppVAEngineModelThrustCoefficients.COM_val)))
            return arg_ppVAEngineModelThrustCoefficients.python_val

    @property
    def isp_coefficients(self) -> "IEngineModelIspCoefficients":
        """The Isp Coefficients."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAEngineModelIspCoefficients:
            agcls.evaluate_hresult(self.__dict__["_get_isp_coefficients"](byref(arg_ppVAEngineModelIspCoefficients.COM_val)))
            return arg_ppVAEngineModelIspCoefficients.python_val

    def enable_control_parameter(self, param:"AgEVAControlEngineModelPoly") -> None:
        """Enables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlEngineModelPoly, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_enable_control_parameter"](arg_param.COM_val))

    def disable_control_parameter(self, param:"AgEVAControlEngineModelPoly") -> None:
        """Disables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlEngineModelPoly, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_disable_control_parameter"](arg_param.COM_val))

    def is_control_parameter_enabled(self, param:"AgEVAControlEngineModelPoly") -> bool:
        """Sees if the specified control is enabled."""
        with agmarshall.AgEnum_arg(AgEVAControlEngineModelPoly, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_is_control_parameter_enabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_parameters_available(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_parameters_available"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{4AC9E570-FB42-4636-B6DA-F9FEF353165B}", IEngineModelPoly)
agcls.AgTypeNameMap["IEngineModelPoly"] = IEngineModelPoly

class IDesignCR3BPObjectCollection(object):
    """The list of asssociated CR3BP objects."""
    _uuid = "{554A8010-4514-4AD5-8FD8-F5FA1FC1D5FF}"
    _num_methods = 5
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_index"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IDesignCR3BPObjectCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IDesignCR3BPObjectCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IDesignCR3BPObjectCollection = agcom.GUID(IDesignCR3BPObjectCollection._uuid)
        vtable_offset_local = IDesignCR3BPObjectCollection._vtable_offset - 1
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IDesignCR3BPObjectCollection, vtable_offset_local+1, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IDesignCR3BPObjectCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IDesignCR3BPObjectCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_get_item_by_index"] = IAGFUNCTYPE(pUnk, IID_IDesignCR3BPObjectCollection, vtable_offset_local+4, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_get_item_by_name"] = IAGFUNCTYPE(pUnk, IID_IDesignCR3BPObjectCollection, vtable_offset_local+5, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IDesignCR3BPObjectCollection.__dict__ and type(IDesignCR3BPObjectCollection.__dict__[attrname]) == property:
            return IDesignCR3BPObjectCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IDesignCR3BPObjectCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IDesignCR3BPObject":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def item(self, indexOrName:typing.Any) -> "IDesignCR3BPObject":
        """A property that allows you to iterate through the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppVADesignCR3BPObject:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_indexOrName.COM_val, byref(arg_ppVADesignCR3BPObject.COM_val)))
            return arg_ppVADesignCR3BPObject.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """A property that allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def count(self) -> int:
        """The number of associated objects in the set."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def get_item_by_index(self, index:int) -> "IDesignCR3BPObject":
        """Retrieves an associated object from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppVADesignCR3BPObject:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_index"](arg_index.COM_val, byref(arg_ppVADesignCR3BPObject.COM_val)))
            return arg_ppVADesignCR3BPObject.python_val

    def get_item_by_name(self, name:str) -> "IDesignCR3BPObject":
        """Retrieves an associated object from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppVADesignCR3BPObject:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_name"](arg_name.COM_val, byref(arg_ppVADesignCR3BPObject.COM_val)))
            return arg_ppVADesignCR3BPObject.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{554A8010-4514-4AD5-8FD8-F5FA1FC1D5FF}", IDesignCR3BPObjectCollection)
agcls.AgTypeNameMap["IDesignCR3BPObjectCollection"] = IDesignCR3BPObjectCollection

class IDesignCR3BPSetup(object):
    """Properties for the CR3BP Setup Tool.."""
    _uuid = "{37C54765-E3FF-4910-9470-B1128666F5BB}"
    _num_methods = 25
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_secondary_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_secondary_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_initial_epoch"] = _raise_uninitialized_error
        self.__dict__["_set_initial_epoch"] = _raise_uninitialized_error
        self.__dict__["_get_ideal_orbit_radius"] = _raise_uninitialized_error
        self.__dict__["_set_ideal_orbit_radius"] = _raise_uninitialized_error
        self.__dict__["_get_ideal_secondary_name"] = _raise_uninitialized_error
        self.__dict__["_set_ideal_secondary_name"] = _raise_uninitialized_error
        self.__dict__["_get_mass_parameter"] = _raise_uninitialized_error
        self.__dict__["_get_characteristic_distance"] = _raise_uninitialized_error
        self.__dict__["_get_characteristic_time"] = _raise_uninitialized_error
        self.__dict__["_get_characteristic_velocity"] = _raise_uninitialized_error
        self.__dict__["_get_characteristic_acceleration"] = _raise_uninitialized_error
        self.__dict__["_get_rotating_system_choice"] = _raise_uninitialized_error
        self.__dict__["_set_rotating_system_choice"] = _raise_uninitialized_error
        self.__dict__["_create_ideal_secondary_cb"] = _raise_uninitialized_error
        self.__dict__["_reset_ideal_secondary_cb"] = _raise_uninitialized_error
        self.__dict__["_update_ideal_secondary_cb"] = _raise_uninitialized_error
        self.__dict__["_create_rotating_coordinate_system"] = _raise_uninitialized_error
        self.__dict__["_delete_rotating_coordinate_system"] = _raise_uninitialized_error
        self.__dict__["_create_calculation_objects"] = _raise_uninitialized_error
        self.__dict__["_delete_calculation_objects"] = _raise_uninitialized_error
        self.__dict__["_get_associated_objects"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IDesignCR3BPSetup._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IDesignCR3BPSetup from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IDesignCR3BPSetup = agcom.GUID(IDesignCR3BPSetup._uuid)
        vtable_offset_local = IDesignCR3BPSetup._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IDesignCR3BPSetup, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_IDesignCR3BPSetup, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_secondary_body_name"] = IAGFUNCTYPE(pUnk, IID_IDesignCR3BPSetup, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_secondary_body_name"] = IAGFUNCTYPE(pUnk, IID_IDesignCR3BPSetup, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_get_initial_epoch"] = IAGFUNCTYPE(pUnk, IID_IDesignCR3BPSetup, vtable_offset_local+5, POINTER(agcom.VARIANT))
        self.__dict__["_set_initial_epoch"] = IAGFUNCTYPE(pUnk, IID_IDesignCR3BPSetup, vtable_offset_local+6, agcom.VARIANT)
        self.__dict__["_get_ideal_orbit_radius"] = IAGFUNCTYPE(pUnk, IID_IDesignCR3BPSetup, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_ideal_orbit_radius"] = IAGFUNCTYPE(pUnk, IID_IDesignCR3BPSetup, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_ideal_secondary_name"] = IAGFUNCTYPE(pUnk, IID_IDesignCR3BPSetup, vtable_offset_local+9, POINTER(agcom.BSTR))
        self.__dict__["_set_ideal_secondary_name"] = IAGFUNCTYPE(pUnk, IID_IDesignCR3BPSetup, vtable_offset_local+10, agcom.BSTR)
        self.__dict__["_get_mass_parameter"] = IAGFUNCTYPE(pUnk, IID_IDesignCR3BPSetup, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_get_characteristic_distance"] = IAGFUNCTYPE(pUnk, IID_IDesignCR3BPSetup, vtable_offset_local+12, POINTER(agcom.DOUBLE))
        self.__dict__["_get_characteristic_time"] = IAGFUNCTYPE(pUnk, IID_IDesignCR3BPSetup, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_get_characteristic_velocity"] = IAGFUNCTYPE(pUnk, IID_IDesignCR3BPSetup, vtable_offset_local+14, POINTER(agcom.DOUBLE))
        self.__dict__["_get_characteristic_acceleration"] = IAGFUNCTYPE(pUnk, IID_IDesignCR3BPSetup, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_get_rotating_system_choice"] = IAGFUNCTYPE(pUnk, IID_IDesignCR3BPSetup, vtable_offset_local+16, POINTER(agcom.LONG))
        self.__dict__["_set_rotating_system_choice"] = IAGFUNCTYPE(pUnk, IID_IDesignCR3BPSetup, vtable_offset_local+17, agcom.LONG)
        self.__dict__["_create_ideal_secondary_cb"] = IAGFUNCTYPE(pUnk, IID_IDesignCR3BPSetup, vtable_offset_local+18, )
        self.__dict__["_reset_ideal_secondary_cb"] = IAGFUNCTYPE(pUnk, IID_IDesignCR3BPSetup, vtable_offset_local+19, )
        self.__dict__["_update_ideal_secondary_cb"] = IAGFUNCTYPE(pUnk, IID_IDesignCR3BPSetup, vtable_offset_local+20, )
        self.__dict__["_create_rotating_coordinate_system"] = IAGFUNCTYPE(pUnk, IID_IDesignCR3BPSetup, vtable_offset_local+21, )
        self.__dict__["_delete_rotating_coordinate_system"] = IAGFUNCTYPE(pUnk, IID_IDesignCR3BPSetup, vtable_offset_local+22, )
        self.__dict__["_create_calculation_objects"] = IAGFUNCTYPE(pUnk, IID_IDesignCR3BPSetup, vtable_offset_local+23, )
        self.__dict__["_delete_calculation_objects"] = IAGFUNCTYPE(pUnk, IID_IDesignCR3BPSetup, vtable_offset_local+24, )
        self.__dict__["_get_associated_objects"] = IAGFUNCTYPE(pUnk, IID_IDesignCR3BPSetup, vtable_offset_local+25, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IDesignCR3BPSetup.__dict__ and type(IDesignCR3BPSetup.__dict__[attrname]) == property:
            return IDesignCR3BPSetup.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IDesignCR3BPSetup.")
    
    @property
    def central_body_name(self) -> str:
        """Primary central body for the three-body system."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def secondary_body_name(self) -> str:
        """Secondary Body"""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_secondary_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @secondary_body_name.setter
    def secondary_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_secondary_body_name"](arg_inVal.COM_val))

    @property
    def initial_epoch(self) -> typing.Any:
        """Date and time for system construction."""
        with agmarshall.VARIANT_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_initial_epoch"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @initial_epoch.setter
    def initial_epoch(self, newVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(newVal) as arg_newVal:
            agcls.evaluate_hresult(self.__dict__["_set_initial_epoch"](arg_newVal.COM_val))

    @property
    def ideal_orbit_radius(self) -> "AgEVAIdealOrbitRadius":
        """Orbital radius of the idealized secondary definition."""
        with agmarshall.AgEnum_arg(AgEVAIdealOrbitRadius) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_ideal_orbit_radius"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ideal_orbit_radius.setter
    def ideal_orbit_radius(self, inVal:"AgEVAIdealOrbitRadius") -> None:
        with agmarshall.AgEnum_arg(AgEVAIdealOrbitRadius, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_ideal_orbit_radius"](arg_inVal.COM_val))

    @property
    def ideal_secondary_name(self) -> str:
        """Name to be used for the idealized secondary."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_ideal_secondary_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @ideal_secondary_name.setter
    def ideal_secondary_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_ideal_secondary_name"](arg_inVal.COM_val))

    @property
    def mass_parameter(self) -> float:
        """The mass parameter computed from the primary and secondary bodies."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_mass_parameter"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def characteristic_distance(self) -> float:
        """The characteristic distance computed from the primary and secondary bodies."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_characteristic_distance"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def characteristic_time(self) -> float:
        """The characteristic time computed from the primary and secondary bodies."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_characteristic_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def characteristic_velocity(self) -> float:
        """The characteristic velocity computed from the primary and secondary bodies."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_characteristic_velocity"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def characteristic_acceleration(self) -> float:
        """The characteristic acceleration computed from the primary and secondary bodies."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_characteristic_acceleration"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def rotating_system_choice(self) -> "AgEVARotatingCoordinateSystem":
        """The rotating coordinate system and associated calculation objects to interact with."""
        with agmarshall.AgEnum_arg(AgEVARotatingCoordinateSystem) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_rotating_system_choice"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @rotating_system_choice.setter
    def rotating_system_choice(self, inVal:"AgEVARotatingCoordinateSystem") -> None:
        with agmarshall.AgEnum_arg(AgEVARotatingCoordinateSystem, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_rotating_system_choice"](arg_inVal.COM_val))

    def create_ideal_secondary_cb(self) -> None:
        """Constructs the idealized secondary for the three-body system"""
        agcls.evaluate_hresult(self.__dict__["_create_ideal_secondary_cb"]())

    def reset_ideal_secondary_cb(self) -> None:
        """Reset the idealized secondary for the three-body system."""
        agcls.evaluate_hresult(self.__dict__["_reset_ideal_secondary_cb"]())

    def update_ideal_secondary_cb(self) -> None:
        """Update the idealized secondary for the three-body system."""
        agcls.evaluate_hresult(self.__dict__["_update_ideal_secondary_cb"]())

    def create_rotating_coordinate_system(self) -> None:
        """Creates the coordinate system for the RotatingSystemChoice selection."""
        agcls.evaluate_hresult(self.__dict__["_create_rotating_coordinate_system"]())

    def delete_rotating_coordinate_system(self) -> None:
        """Deletes the coordinate system for the RotatingSystemChoice selection."""
        agcls.evaluate_hresult(self.__dict__["_delete_rotating_coordinate_system"]())

    def create_calculation_objects(self) -> None:
        """Creates the calculation objects for the selected coordinate system."""
        agcls.evaluate_hresult(self.__dict__["_create_calculation_objects"]())

    def delete_calculation_objects(self) -> None:
        """Deletes the calculation objects for the selected coordinate system."""
        agcls.evaluate_hresult(self.__dict__["_delete_calculation_objects"]())

    @property
    def associated_objects(self) -> "IDesignCR3BPObjectCollection":
        """The list of associated objects."""
        with agmarshall.AgInterface_out_arg() as arg_ppVADesignCR3BPObjectCollection:
            agcls.evaluate_hresult(self.__dict__["_get_associated_objects"](byref(arg_ppVADesignCR3BPObjectCollection.COM_val)))
            return arg_ppVADesignCR3BPObjectCollection.python_val


agcls.AgClassCatalog.add_catalog_entry("{37C54765-E3FF-4910-9470-B1128666F5BB}", IDesignCR3BPSetup)
agcls.AgTypeNameMap["IDesignCR3BPSetup"] = IDesignCR3BPSetup

class IDesignCR3BPObject(object):
    """Properties for individual associated CR3BP object."""
    _uuid = "{994615DE-EF79-4D9A-BC63-0911FAE26842}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_object_name"] = _raise_uninitialized_error
        self.__dict__["_get_object_type"] = _raise_uninitialized_error
        self.__dict__["_get_object_depends_on"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IDesignCR3BPObject._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IDesignCR3BPObject from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IDesignCR3BPObject = agcom.GUID(IDesignCR3BPObject._uuid)
        vtable_offset_local = IDesignCR3BPObject._vtable_offset - 1
        self.__dict__["_get_object_name"] = IAGFUNCTYPE(pUnk, IID_IDesignCR3BPObject, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_get_object_type"] = IAGFUNCTYPE(pUnk, IID_IDesignCR3BPObject, vtable_offset_local+2, POINTER(agcom.BSTR))
        self.__dict__["_get_object_depends_on"] = IAGFUNCTYPE(pUnk, IID_IDesignCR3BPObject, vtable_offset_local+3, POINTER(agcom.BSTR))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IDesignCR3BPObject.__dict__ and type(IDesignCR3BPObject.__dict__[attrname]) == property:
            return IDesignCR3BPObject.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IDesignCR3BPObject.")
    
    @property
    def object_name(self) -> str:
        """The associated object name."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_object_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def object_type(self) -> str:
        """The associated object type."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_object_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def object_depends_on(self) -> str:
        """The associated object depends on."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_object_depends_on"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{994615DE-EF79-4D9A-BC63-0911FAE26842}", IDesignCR3BPObject)
agcls.AgTypeNameMap["IDesignCR3BPObject"] = IDesignCR3BPObject

class IThruster(object):
    """Properties for individual thrusters."""
    _uuid = "{61A386B1-675B-4DB6-85B9-078760AB8339}"
    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_name"] = _raise_uninitialized_error
        self.__dict__["_set_name"] = _raise_uninitialized_error
        self.__dict__["_get_user_comment"] = _raise_uninitialized_error
        self.__dict__["_set_user_comment"] = _raise_uninitialized_error
        self.__dict__["_copy"] = _raise_uninitialized_error
        self.__dict__["_get_engine_model_name"] = _raise_uninitialized_error
        self.__dict__["_set_engine_model_name"] = _raise_uninitialized_error
        self.__dict__["_get_thruster_efficiency"] = _raise_uninitialized_error
        self.__dict__["_set_thruster_efficiency"] = _raise_uninitialized_error
        self.__dict__["_get_equivalent_on_time"] = _raise_uninitialized_error
        self.__dict__["_set_equivalent_on_time"] = _raise_uninitialized_error
        self.__dict__["_get_thruster_direction"] = _raise_uninitialized_error
        self.__dict__["_enable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_disable_control_parameter"] = _raise_uninitialized_error
        self.__dict__["_is_control_parameter_enabled"] = _raise_uninitialized_error
        self.__dict__["_get_control_parameters_available"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IThruster._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IThruster from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IThruster = agcom.GUID(IThruster._uuid)
        vtable_offset_local = IThruster._vtable_offset - 1
        self.__dict__["_get_name"] = IAGFUNCTYPE(pUnk, IID_IThruster, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_name"] = IAGFUNCTYPE(pUnk, IID_IThruster, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_user_comment"] = IAGFUNCTYPE(pUnk, IID_IThruster, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_user_comment"] = IAGFUNCTYPE(pUnk, IID_IThruster, vtable_offset_local+4, agcom.BSTR)
        self.__dict__["_copy"] = IAGFUNCTYPE(pUnk, IID_IThruster, vtable_offset_local+5, POINTER(agcom.PVOID))
        self.__dict__["_get_engine_model_name"] = IAGFUNCTYPE(pUnk, IID_IThruster, vtable_offset_local+6, POINTER(agcom.BSTR))
        self.__dict__["_set_engine_model_name"] = IAGFUNCTYPE(pUnk, IID_IThruster, vtable_offset_local+7, agcom.BSTR)
        self.__dict__["_get_thruster_efficiency"] = IAGFUNCTYPE(pUnk, IID_IThruster, vtable_offset_local+8, POINTER(agcom.DOUBLE))
        self.__dict__["_set_thruster_efficiency"] = IAGFUNCTYPE(pUnk, IID_IThruster, vtable_offset_local+9, agcom.DOUBLE)
        self.__dict__["_get_equivalent_on_time"] = IAGFUNCTYPE(pUnk, IID_IThruster, vtable_offset_local+10, POINTER(agcom.DOUBLE))
        self.__dict__["_set_equivalent_on_time"] = IAGFUNCTYPE(pUnk, IID_IThruster, vtable_offset_local+11, agcom.DOUBLE)
        self.__dict__["_get_thruster_direction"] = IAGFUNCTYPE(pUnk, IID_IThruster, vtable_offset_local+12, POINTER(agcom.PVOID))
        self.__dict__["_enable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IThruster, vtable_offset_local+13, agcom.LONG)
        self.__dict__["_disable_control_parameter"] = IAGFUNCTYPE(pUnk, IID_IThruster, vtable_offset_local+14, agcom.LONG)
        self.__dict__["_is_control_parameter_enabled"] = IAGFUNCTYPE(pUnk, IID_IThruster, vtable_offset_local+15, agcom.LONG, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_get_control_parameters_available"] = IAGFUNCTYPE(pUnk, IID_IThruster, vtable_offset_local+16, POINTER(agcom.VARIANT_BOOL))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IThruster.__dict__ and type(IThruster.__dict__[attrname]) == property:
            return IThruster.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IThruster.")
    
    @property
    def name(self) -> str:
        """The thruster name."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @name.setter
    def name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_name"](arg_inVal.COM_val))

    @property
    def user_comment(self) -> str:
        """A user comment."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_user_comment"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @user_comment.setter
    def user_comment(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_user_comment"](arg_inVal.COM_val))

    def copy(self) -> "IThruster":
        """Makes a copy of the specified thruster."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAThruster:
            agcls.evaluate_hresult(self.__dict__["_copy"](byref(arg_ppVAThruster.COM_val)))
            return arg_ppVAThruster.python_val

    @property
    def engine_model_name(self) -> str:
        """The engine model."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_engine_model_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @engine_model_name.setter
    def engine_model_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_engine_model_name"](arg_inVal.COM_val))

    @property
    def thruster_efficiency(self) -> float:
        """The thruster efficiency. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_thruster_efficiency"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @thruster_efficiency.setter
    def thruster_efficiency(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_thruster_efficiency"](arg_inVal.COM_val))

    @property
    def equivalent_on_time(self) -> float:
        """The equivalent on-time percentage is a factor multiplied by the thrust. The thrust is applied continuously throughout the maneuver and is reduced by the percentage. The mass flow rate is likewise reduced. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_equivalent_on_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @equivalent_on_time.setter
    def equivalent_on_time(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_equivalent_on_time"](arg_inVal.COM_val))

    @property
    def thruster_direction(self) -> "IDirection":
        """A thruster direction value."""
        with agmarshall.AgInterface_out_arg() as arg_ppDirection:
            agcls.evaluate_hresult(self.__dict__["_get_thruster_direction"](byref(arg_ppDirection.COM_val)))
            return arg_ppDirection.python_val

    def enable_control_parameter(self, param:"AgEVAControlThrusters") -> None:
        """Enables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlThrusters, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_enable_control_parameter"](arg_param.COM_val))

    def disable_control_parameter(self, param:"AgEVAControlThrusters") -> None:
        """Disables the specified control parameter."""
        with agmarshall.AgEnum_arg(AgEVAControlThrusters, param) as arg_param:
            agcls.evaluate_hresult(self.__dict__["_disable_control_parameter"](arg_param.COM_val))

    def is_control_parameter_enabled(self, param:"AgEVAControlThrusters") -> bool:
        """Sees if the specified control is enabled."""
        with agmarshall.AgEnum_arg(AgEVAControlThrusters, param) as arg_param, \
             agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_is_control_parameter_enabled"](arg_param.COM_val, byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @property
    def control_parameters_available(self) -> bool:
        """Returns whether or not the control parameters can be set."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_control_parameters_available"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val


agcls.AgClassCatalog.add_catalog_entry("{61A386B1-675B-4DB6-85B9-078760AB8339}", IThruster)
agcls.AgTypeNameMap["IThruster"] = IThruster

class IThrusterSetCollection(object):
    """The list of thrusters in a thruster set."""
    _uuid = "{C60E997C-7AF3-477B-8B8A-8E1CA0D55681}"
    _num_methods = 11
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_add"] = _raise_uninitialized_error
        self.__dict__["_remove"] = _raise_uninitialized_error
        self.__dict__["_remove_all"] = _raise_uninitialized_error
        self.__dict__["_cut"] = _raise_uninitialized_error
        self.__dict__["_paste"] = _raise_uninitialized_error
        self.__dict__["_insert_copy"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_index"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IThrusterSetCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IThrusterSetCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IThrusterSetCollection = agcom.GUID(IThrusterSetCollection._uuid)
        vtable_offset_local = IThrusterSetCollection._vtable_offset - 1
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IThrusterSetCollection, vtable_offset_local+1, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IThrusterSetCollection, vtable_offset_local+2, POINTER(agcom.PVOID))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IThrusterSetCollection, vtable_offset_local+3, POINTER(agcom.LONG))
        self.__dict__["_add"] = IAGFUNCTYPE(pUnk, IID_IThrusterSetCollection, vtable_offset_local+4, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_remove"] = IAGFUNCTYPE(pUnk, IID_IThrusterSetCollection, vtable_offset_local+5, agcom.VARIANT)
        self.__dict__["_remove_all"] = IAGFUNCTYPE(pUnk, IID_IThrusterSetCollection, vtable_offset_local+6, )
        self.__dict__["_cut"] = IAGFUNCTYPE(pUnk, IID_IThrusterSetCollection, vtable_offset_local+7, agcom.VARIANT)
        self.__dict__["_paste"] = IAGFUNCTYPE(pUnk, IID_IThrusterSetCollection, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_insert_copy"] = IAGFUNCTYPE(pUnk, IID_IThrusterSetCollection, vtable_offset_local+9, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_get_item_by_index"] = IAGFUNCTYPE(pUnk, IID_IThrusterSetCollection, vtable_offset_local+10, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_get_item_by_name"] = IAGFUNCTYPE(pUnk, IID_IThrusterSetCollection, vtable_offset_local+11, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IThrusterSetCollection.__dict__ and type(IThrusterSetCollection.__dict__[attrname]) == property:
            return IThrusterSetCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IThrusterSetCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IThruster":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def item(self, indexOrName:typing.Any) -> "IThruster":
        """A property that allows you to iterate through the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppVAThruster:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_indexOrName.COM_val, byref(arg_ppVAThruster.COM_val)))
            return arg_ppVAThruster.python_val

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """A property that allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def count(self) -> int:
        """The number of thrusters in the set."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def add(self, thrusterName:str) -> "IThruster":
        """Adds a new thruster."""
        with agmarshall.BSTR_arg(thrusterName) as arg_thrusterName, \
             agmarshall.AgInterface_out_arg() as arg_ppVAThruster:
            agcls.evaluate_hresult(self.__dict__["_add"](arg_thrusterName.COM_val, byref(arg_ppVAThruster.COM_val)))
            return arg_ppVAThruster.python_val

    def remove(self, indexOrName:typing.Any) -> None:
        """Removes a specified thruster."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_remove"](arg_indexOrName.COM_val))

    def remove_all(self) -> None:
        """Removes all thrusters."""
        agcls.evaluate_hresult(self.__dict__["_remove_all"]())

    def cut(self, indexOrName:typing.Any) -> None:
        """Copies a thruster to the clipboard and removes the thruster from the list."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_cut"](arg_indexOrName.COM_val))

    def paste(self) -> "IThruster":
        """Pastes a thruster from the clipboard into the list."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAThruster:
            agcls.evaluate_hresult(self.__dict__["_paste"](byref(arg_ppVAThruster.COM_val)))
            return arg_ppVAThruster.python_val

    def insert_copy(self, thruster:"IThruster") -> "IThruster":
        """Copies a thruster and inserts the copy into the list."""
        with agmarshall.AgInterface_in_arg(thruster, IThruster) as arg_thruster, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_insert_copy"](arg_thruster.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def get_item_by_index(self, index:int) -> "IThruster":
        """Retrieves a thruster from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppVAThruster:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_index"](arg_index.COM_val, byref(arg_ppVAThruster.COM_val)))
            return arg_ppVAThruster.python_val

    def get_item_by_name(self, name:str) -> "IThruster":
        """Retrieves a thruster from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppVAThruster:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_name"](arg_name.COM_val, byref(arg_ppVAThruster.COM_val)))
            return arg_ppVAThruster.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{C60E997C-7AF3-477B-8B8A-8E1CA0D55681}", IThrusterSetCollection)
agcls.AgTypeNameMap["IThrusterSetCollection"] = IThrusterSetCollection

class IThrusterSet(object):
    """The properties of a thruster set."""
    _uuid = "{AA4BEFC3-C3E6-4888-B920-109F57621589}"
    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_direction_definition"] = _raise_uninitialized_error
        self.__dict__["_set_direction_definition"] = _raise_uninitialized_error
        self.__dict__["_get_thrusters"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IThrusterSet._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IThrusterSet from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IThrusterSet = agcom.GUID(IThrusterSet._uuid)
        vtable_offset_local = IThrusterSet._vtable_offset - 1
        self.__dict__["_get_direction_definition"] = IAGFUNCTYPE(pUnk, IID_IThrusterSet, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_direction_definition"] = IAGFUNCTYPE(pUnk, IID_IThrusterSet, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_thrusters"] = IAGFUNCTYPE(pUnk, IID_IThrusterSet, vtable_offset_local+3, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IThrusterSet.__dict__ and type(IThrusterSet.__dict__[attrname]) == property:
            return IThrusterSet.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IThrusterSet.")
    
    @property
    def direction_definition(self) -> "AgEVAThrusterDirection":
        """The thruster set direction definition."""
        with agmarshall.AgEnum_arg(AgEVAThrusterDirection) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_direction_definition"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @direction_definition.setter
    def direction_definition(self, inVal:"AgEVAThrusterDirection") -> None:
        with agmarshall.AgEnum_arg(AgEVAThrusterDirection, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_direction_definition"](arg_inVal.COM_val))

    @property
    def thrusters(self) -> "IThrusterSetCollection":
        """The list of thrusters."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAThrusterSetCollection:
            agcls.evaluate_hresult(self.__dict__["_get_thrusters"](byref(arg_ppVAThrusterSetCollection.COM_val)))
            return arg_ppVAThrusterSetCollection.python_val


agcls.AgClassCatalog.add_catalog_entry("{AA4BEFC3-C3E6-4888-B920-109F57621589}", IThrusterSet)
agcls.AgTypeNameMap["IThrusterSet"] = IThrusterSet

class IAsTriggerCondition(object):
    """Properties for a constraint - an additional condition to be met to satisfy a stopping condition."""
    _uuid = "{5670AC34-2864-42ED-B32A-5572363C0CE7}"
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_criteria"] = _raise_uninitialized_error
        self.__dict__["_set_criteria"] = _raise_uninitialized_error
        self.__dict__["_get_calc_object"] = _raise_uninitialized_error
        self.__dict__["_set_calc_object"] = _raise_uninitialized_error
        self.__dict__["_get_calc_object_name"] = _raise_uninitialized_error
        self.__dict__["_set_calc_object_name"] = _raise_uninitialized_error
        self.__dict__["_get_value"] = _raise_uninitialized_error
        self.__dict__["_set_value"] = _raise_uninitialized_error
        self.__dict__["_get_tolerance"] = _raise_uninitialized_error
        self.__dict__["_set_tolerance"] = _raise_uninitialized_error
        self.__dict__["_get_use_absolute_value"] = _raise_uninitialized_error
        self.__dict__["_set_use_absolute_value"] = _raise_uninitialized_error
        self.__dict__["_copy_calc_object_to_clipboard"] = _raise_uninitialized_error
        self.__dict__["_paste_calc_object_from_clipboard"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IAsTriggerCondition._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IAsTriggerCondition from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IAsTriggerCondition = agcom.GUID(IAsTriggerCondition._uuid)
        vtable_offset_local = IAsTriggerCondition._vtable_offset - 1
        self.__dict__["_get_criteria"] = IAGFUNCTYPE(pUnk, IID_IAsTriggerCondition, vtable_offset_local+1, POINTER(agcom.LONG))
        self.__dict__["_set_criteria"] = IAGFUNCTYPE(pUnk, IID_IAsTriggerCondition, vtable_offset_local+2, agcom.LONG)
        self.__dict__["_get_calc_object"] = IAGFUNCTYPE(pUnk, IID_IAsTriggerCondition, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_set_calc_object"] = IAGFUNCTYPE(pUnk, IID_IAsTriggerCondition, vtable_offset_local+4, agcom.PVOID)
        self.__dict__["_get_calc_object_name"] = IAGFUNCTYPE(pUnk, IID_IAsTriggerCondition, vtable_offset_local+5, POINTER(agcom.BSTR))
        self.__dict__["_set_calc_object_name"] = IAGFUNCTYPE(pUnk, IID_IAsTriggerCondition, vtable_offset_local+6, agcom.BSTR)
        self.__dict__["_get_value"] = IAGFUNCTYPE(pUnk, IID_IAsTriggerCondition, vtable_offset_local+7, POINTER(agcom.VARIANT))
        self.__dict__["_set_value"] = IAGFUNCTYPE(pUnk, IID_IAsTriggerCondition, vtable_offset_local+8, agcom.VARIANT)
        self.__dict__["_get_tolerance"] = IAGFUNCTYPE(pUnk, IID_IAsTriggerCondition, vtable_offset_local+9, POINTER(agcom.VARIANT))
        self.__dict__["_set_tolerance"] = IAGFUNCTYPE(pUnk, IID_IAsTriggerCondition, vtable_offset_local+10, agcom.VARIANT)
        self.__dict__["_get_use_absolute_value"] = IAGFUNCTYPE(pUnk, IID_IAsTriggerCondition, vtable_offset_local+11, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_absolute_value"] = IAGFUNCTYPE(pUnk, IID_IAsTriggerCondition, vtable_offset_local+12, agcom.VARIANT_BOOL)
        self.__dict__["_copy_calc_object_to_clipboard"] = IAGFUNCTYPE(pUnk, IID_IAsTriggerCondition, vtable_offset_local+13, )
        self.__dict__["_paste_calc_object_from_clipboard"] = IAGFUNCTYPE(pUnk, IID_IAsTriggerCondition, vtable_offset_local+14, )
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IAsTriggerCondition.__dict__ and type(IAsTriggerCondition.__dict__[attrname]) == property:
            return IAsTriggerCondition.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IAsTriggerCondition.")
    
    @property
    def criteria(self) -> "AgEVACriteria":
        """The criteria to be applied to the desired value."""
        with agmarshall.AgEnum_arg(AgEVACriteria) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_criteria"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @criteria.setter
    def criteria(self, inVal:"AgEVACriteria") -> None:
        with agmarshall.AgEnum_arg(AgEVACriteria, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_criteria"](arg_inVal.COM_val))

    @property
    def calc_object(self) -> "IComponentInfo":
        """The calculation object to perform calculation to evaluate condition."""
        with agmarshall.AgInterface_out_arg() as arg_ppComponent:
            agcls.evaluate_hresult(self.__dict__["_get_calc_object"](byref(arg_ppComponent.COM_val)))
            return arg_ppComponent.python_val

    @calc_object.setter
    def calc_object(self, inVal:"IComponentInfo") -> None:
        with agmarshall.AgInterface_in_arg(inVal, IComponentInfo) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_calc_object"](arg_inVal.COM_val))

    @property
    def calc_object_name(self) -> str:
        """The name of the calculation object to perform calculation to evaluate condition."""
        with agmarshall.BSTR_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_calc_object_name"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @calc_object_name.setter
    def calc_object_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_calc_object_name"](arg_inVal.COM_val))

    @property
    def value(self) -> typing.Any:
        """The value to satisfy the condition. Dimension depends on CalcObject."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_value"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @value.setter
    def value(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_value"](arg_inVal.COM_val))

    @property
    def tolerance(self) -> typing.Any:
        """How closely the test parameter must approximate the desired value for the constraint. Dimension depends on CalcObject."""
        with agmarshall.VARIANT_arg() as arg_pRetVal:
            agcls.evaluate_hresult(self.__dict__["_get_tolerance"](byref(arg_pRetVal.COM_val)))
            return arg_pRetVal.python_val

    @tolerance.setter
    def tolerance(self, inVal:typing.Any) -> None:
        with agmarshall.VARIANT_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_tolerance"](arg_inVal.COM_val))

    @property
    def use_absolute_value(self) -> bool:
        """Whether or not to take the absolute value of the calculation."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_absolute_value"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_absolute_value.setter
    def use_absolute_value(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_absolute_value"](arg_inVal.COM_val))

    def copy_calc_object_to_clipboard(self) -> None:
        """Copy calculation object to clipboard."""
        agcls.evaluate_hresult(self.__dict__["_copy_calc_object_to_clipboard"]())

    def paste_calc_object_from_clipboard(self) -> None:
        """Replace calculation object with instance in clipboard."""
        agcls.evaluate_hresult(self.__dict__["_paste_calc_object_from_clipboard"]())


agcls.AgClassCatalog.add_catalog_entry("{5670AC34-2864-42ED-B32A-5572363C0CE7}", IAsTriggerCondition)
agcls.AgTypeNameMap["IAsTriggerCondition"] = IAsTriggerCondition

class ICustomFunctionScriptEngine(object):
    """Properties for custom functions."""
    _uuid = "{02AA62BC-AA81-400C-83A0-961729880708}"
    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_script_filename"] = _raise_uninitialized_error
        self.__dict__["_set_script_filename"] = _raise_uninitialized_error
        self.__dict__["_get_file_extension_name"] = _raise_uninitialized_error
        self.__dict__["_set_file_extension_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(ICustomFunctionScriptEngine._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create ICustomFunctionScriptEngine from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_ICustomFunctionScriptEngine = agcom.GUID(ICustomFunctionScriptEngine._uuid)
        vtable_offset_local = ICustomFunctionScriptEngine._vtable_offset - 1
        self.__dict__["_get_script_filename"] = IAGFUNCTYPE(pUnk, IID_ICustomFunctionScriptEngine, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_script_filename"] = IAGFUNCTYPE(pUnk, IID_ICustomFunctionScriptEngine, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_file_extension_name"] = IAGFUNCTYPE(pUnk, IID_ICustomFunctionScriptEngine, vtable_offset_local+3, POINTER(agcom.BSTR))
        self.__dict__["_set_file_extension_name"] = IAGFUNCTYPE(pUnk, IID_ICustomFunctionScriptEngine, vtable_offset_local+4, agcom.BSTR)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in ICustomFunctionScriptEngine.__dict__ and type(ICustomFunctionScriptEngine.__dict__[attrname]) == property:
            return ICustomFunctionScriptEngine.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ICustomFunctionScriptEngine.")
    
    @property
    def script_filename(self) -> str:
        """The file containing the function to call."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_script_filename"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @script_filename.setter
    def script_filename(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_script_filename"](arg_inVal.COM_val))

    @property
    def file_extension_name(self) -> str:
        """The file extension."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_file_extension_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @file_extension_name.setter
    def file_extension_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_file_extension_name"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{02AA62BC-AA81-400C-83A0-961729880708}", ICustomFunctionScriptEngine)
agcls.AgTypeNameMap["ICustomFunctionScriptEngine"] = ICustomFunctionScriptEngine

class INumericalIntegrator(object):
    """The type of numerical integrator to be used by the propagator."""
    _uuid = "{5E802B1E-D8EF-4190-B238-7E0F4AFCA355}"
    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(INumericalIntegrator._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create INumericalIntegrator from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_INumericalIntegrator = agcom.GUID(INumericalIntegrator._uuid)
        vtable_offset_local = INumericalIntegrator._vtable_offset - 1
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in INumericalIntegrator.__dict__ and type(INumericalIntegrator.__dict__[attrname]) == property:
            return INumericalIntegrator.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in INumericalIntegrator.")
    

agcls.AgClassCatalog.add_catalog_entry("{5E802B1E-D8EF-4190-B238-7E0F4AFCA355}", INumericalIntegrator)
agcls.AgTypeNameMap["INumericalIntegrator"] = INumericalIntegrator

class IPropagatorFunctionCollection(object):
    """The list of propagator functions - affecting forces that you want to model for orbit propagation."""
    _uuid = "{373180B3-D083-4CB1-ACC8-9D6C738F19E6}"
    _num_methods = 11
    _vtable_offset = IDispatch._vtable_offset + IDispatch._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_add"] = _raise_uninitialized_error
        self.__dict__["_item"] = _raise_uninitialized_error
        self.__dict__["_remove"] = _raise_uninitialized_error
        self.__dict__["_get__NewEnum"] = _raise_uninitialized_error
        self.__dict__["_get_count"] = _raise_uninitialized_error
        self.__dict__["_remove_all"] = _raise_uninitialized_error
        self.__dict__["_cut"] = _raise_uninitialized_error
        self.__dict__["_paste"] = _raise_uninitialized_error
        self.__dict__["_insert_copy"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_index"] = _raise_uninitialized_error
        self.__dict__["_get_item_by_name"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IPropagatorFunctionCollection._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IPropagatorFunctionCollection from source object.")
        self.__dict__["enumerator"] = None
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IPropagatorFunctionCollection = agcom.GUID(IPropagatorFunctionCollection._uuid)
        vtable_offset_local = IPropagatorFunctionCollection._vtable_offset - 1
        self.__dict__["_add"] = IAGFUNCTYPE(pUnk, IID_IPropagatorFunctionCollection, vtable_offset_local+1, agcom.BSTR, POINTER(agcom.PVOID))
        self.__dict__["_item"] = IAGFUNCTYPE(pUnk, IID_IPropagatorFunctionCollection, vtable_offset_local+2, agcom.VARIANT, POINTER(agcom.PVOID))
        self.__dict__["_remove"] = IAGFUNCTYPE(pUnk, IID_IPropagatorFunctionCollection, vtable_offset_local+3, agcom.VARIANT)
        self.__dict__["_get__NewEnum"] = IAGFUNCTYPE(pUnk, IID_IPropagatorFunctionCollection, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_count"] = IAGFUNCTYPE(pUnk, IID_IPropagatorFunctionCollection, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_remove_all"] = IAGFUNCTYPE(pUnk, IID_IPropagatorFunctionCollection, vtable_offset_local+6, )
        self.__dict__["_cut"] = IAGFUNCTYPE(pUnk, IID_IPropagatorFunctionCollection, vtable_offset_local+7, agcom.VARIANT)
        self.__dict__["_paste"] = IAGFUNCTYPE(pUnk, IID_IPropagatorFunctionCollection, vtable_offset_local+8, POINTER(agcom.PVOID))
        self.__dict__["_insert_copy"] = IAGFUNCTYPE(pUnk, IID_IPropagatorFunctionCollection, vtable_offset_local+9, agcom.PVOID, POINTER(agcom.PVOID))
        self.__dict__["_get_item_by_index"] = IAGFUNCTYPE(pUnk, IID_IPropagatorFunctionCollection, vtable_offset_local+10, agcom.INT, POINTER(agcom.PVOID))
        self.__dict__["_get_item_by_name"] = IAGFUNCTYPE(pUnk, IID_IPropagatorFunctionCollection, vtable_offset_local+11, agcom.BSTR, POINTER(agcom.PVOID))
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IPropagatorFunctionCollection.__dict__ and type(IPropagatorFunctionCollection.__dict__[attrname]) == property:
            return IPropagatorFunctionCollection.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPropagatorFunctionCollection.")
    def __iter__(self):
        self.__dict__["enumerator"] = self._NewEnum
        self.__dict__["enumerator"].Reset()
        return self
    def __next__(self) -> "IComponentInfo":
        if self.__dict__["enumerator"] is None:
            raise StopIteration
        nextval = self.__dict__["enumerator"].Next()
        if nextval is None:
            raise StopIteration
        return agmarshall.python_val_from_VARIANT(nextval, clear_variant=True)
    
    def add(self, resultName:str) -> "IComponentInfo":
        """Adds a function to the collection."""
        with agmarshall.BSTR_arg(resultName) as arg_resultName, \
             agmarshall.AgInterface_out_arg() as arg_ppComponent:
            agcls.evaluate_hresult(self.__dict__["_add"](arg_resultName.COM_val, byref(arg_ppComponent.COM_val)))
            return arg_ppComponent.python_val

    def item(self, indexOrName:typing.Any) -> "IComponentInfo":
        """Allows you to iterate through the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName, \
             agmarshall.AgInterface_out_arg() as arg_ppComponent:
            agcls.evaluate_hresult(self.__dict__["_item"](arg_indexOrName.COM_val, byref(arg_ppComponent.COM_val)))
            return arg_ppComponent.python_val

    def remove(self, indexOrName:typing.Any) -> None:
        """Removes the specified function from the collection."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_remove"](arg_indexOrName.COM_val))

    @property
    def _NewEnum(self) -> IEnumVARIANT:
        """Allows you to enumerate through the collection."""
        with agmarshall.IEnumVARIANT_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_get__NewEnum"](byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    @property
    def count(self) -> int:
        """Returns the size of the collection."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_count"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def remove_all(self) -> None:
        """Removes all functions from the collection."""
        agcls.evaluate_hresult(self.__dict__["_remove_all"]())

    def cut(self, indexOrName:typing.Any) -> None:
        """Copies a propagator function to the clipboard and removes the propagator function from the list."""
        with agmarshall.VARIANT_arg(indexOrName) as arg_indexOrName:
            agcls.evaluate_hresult(self.__dict__["_cut"](arg_indexOrName.COM_val))

    def paste(self) -> "IComponentInfo":
        """Pastes a propagator function from the clipboard into the list."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAPropFunc:
            agcls.evaluate_hresult(self.__dict__["_paste"](byref(arg_ppVAPropFunc.COM_val)))
            return arg_ppVAPropFunc.python_val

    def insert_copy(self, propFunc:"IComponentInfo") -> "IComponentInfo":
        """Copies a propagator function and inserts the copy into the list."""
        with agmarshall.AgInterface_in_arg(propFunc, IComponentInfo) as arg_propFunc, \
             agmarshall.AgInterface_out_arg() as arg_ppRetVal:
            agcls.evaluate_hresult(self.__dict__["_insert_copy"](arg_propFunc.COM_val, byref(arg_ppRetVal.COM_val)))
            return arg_ppRetVal.python_val

    def get_item_by_index(self, index:int) -> "IComponentInfo":
        """Retrieves a propagator function from the collection by index."""
        with agmarshall.INT_arg(index) as arg_index, \
             agmarshall.AgInterface_out_arg() as arg_ppComponent:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_index"](arg_index.COM_val, byref(arg_ppComponent.COM_val)))
            return arg_ppComponent.python_val

    def get_item_by_name(self, name:str) -> "IComponentInfo":
        """Retrieves a propagator function from the collection by name."""
        with agmarshall.BSTR_arg(name) as arg_name, \
             agmarshall.AgInterface_out_arg() as arg_ppComponent:
            agcls.evaluate_hresult(self.__dict__["_get_item_by_name"](arg_name.COM_val, byref(arg_ppComponent.COM_val)))
            return arg_ppComponent.python_val

    __getitem__ = item



agcls.AgClassCatalog.add_catalog_entry("{373180B3-D083-4CB1-ACC8-9D6C738F19E6}", IPropagatorFunctionCollection)
agcls.AgTypeNameMap["IPropagatorFunctionCollection"] = IPropagatorFunctionCollection

class INumericalPropagatorWrapper(object):
    """General properties for propagators."""
    _uuid = "{5E7589D9-478E-4C8F-A856-2E548833C9C5}"
    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_use_variation_of_parameters"] = _raise_uninitialized_error
        self.__dict__["_set_use_variation_of_parameters"] = _raise_uninitialized_error
        self.__dict__["_get_use_regularized_time"] = _raise_uninitialized_error
        self.__dict__["_set_use_regularized_time"] = _raise_uninitialized_error
        self.__dict__["_get_regularized_time_exponent"] = _raise_uninitialized_error
        self.__dict__["_set_regularized_time_exponent"] = _raise_uninitialized_error
        self.__dict__["_get_regularized_time_steps_per_orbit"] = _raise_uninitialized_error
        self.__dict__["_set_regularized_time_steps_per_orbit"] = _raise_uninitialized_error
        self.__dict__["_get_propagator_functions"] = _raise_uninitialized_error
        self.__dict__["_get_numerical_integrator"] = _raise_uninitialized_error
        self.__dict__["_get_numerical_integrator_type"] = _raise_uninitialized_error
        self.__dict__["_set_numerical_integrator"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(INumericalPropagatorWrapper._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create INumericalPropagatorWrapper from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_INumericalPropagatorWrapper = agcom.GUID(INumericalPropagatorWrapper._uuid)
        vtable_offset_local = INumericalPropagatorWrapper._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_INumericalPropagatorWrapper, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_INumericalPropagatorWrapper, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_use_variation_of_parameters"] = IAGFUNCTYPE(pUnk, IID_INumericalPropagatorWrapper, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_variation_of_parameters"] = IAGFUNCTYPE(pUnk, IID_INumericalPropagatorWrapper, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_get_use_regularized_time"] = IAGFUNCTYPE(pUnk, IID_INumericalPropagatorWrapper, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_regularized_time"] = IAGFUNCTYPE(pUnk, IID_INumericalPropagatorWrapper, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_get_regularized_time_exponent"] = IAGFUNCTYPE(pUnk, IID_INumericalPropagatorWrapper, vtable_offset_local+7, POINTER(agcom.DOUBLE))
        self.__dict__["_set_regularized_time_exponent"] = IAGFUNCTYPE(pUnk, IID_INumericalPropagatorWrapper, vtable_offset_local+8, agcom.DOUBLE)
        self.__dict__["_get_regularized_time_steps_per_orbit"] = IAGFUNCTYPE(pUnk, IID_INumericalPropagatorWrapper, vtable_offset_local+9, POINTER(agcom.LONG))
        self.__dict__["_set_regularized_time_steps_per_orbit"] = IAGFUNCTYPE(pUnk, IID_INumericalPropagatorWrapper, vtable_offset_local+10, agcom.LONG)
        self.__dict__["_get_propagator_functions"] = IAGFUNCTYPE(pUnk, IID_INumericalPropagatorWrapper, vtable_offset_local+11, POINTER(agcom.PVOID))
        self.__dict__["_get_numerical_integrator"] = IAGFUNCTYPE(pUnk, IID_INumericalPropagatorWrapper, vtable_offset_local+12, POINTER(agcom.PVOID))
        self.__dict__["_get_numerical_integrator_type"] = IAGFUNCTYPE(pUnk, IID_INumericalPropagatorWrapper, vtable_offset_local+13, POINTER(agcom.LONG))
        self.__dict__["_set_numerical_integrator"] = IAGFUNCTYPE(pUnk, IID_INumericalPropagatorWrapper, vtable_offset_local+14, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in INumericalPropagatorWrapper.__dict__ and type(INumericalPropagatorWrapper.__dict__[attrname]) == property:
            return INumericalPropagatorWrapper.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in INumericalPropagatorWrapper.")
    
    @property
    def central_body_name(self) -> str:
        """The central body for Propagation."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def use_variation_of_parameters(self) -> bool:
        """Whether or not to use a variation of parameters(VOP) in universal variables formulation of the equations of motion; related to numerical integrator."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_variation_of_parameters"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_variation_of_parameters.setter
    def use_variation_of_parameters(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_variation_of_parameters"](arg_inVal.COM_val))

    @property
    def use_regularized_time(self) -> bool:
        """Whether or not to use regularized time; related to numerical integrator."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_regularized_time"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_regularized_time.setter
    def use_regularized_time(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_regularized_time"](arg_inVal.COM_val))

    @property
    def regularized_time_exponent(self) -> float:
        """The exponent to use in regularized time; related to numerical integrator. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_regularized_time_exponent"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @regularized_time_exponent.setter
    def regularized_time_exponent(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_regularized_time_exponent"](arg_inVal.COM_val))

    @property
    def regularized_time_steps_per_orbit(self) -> int:
        """The steps per orbit used in regularized time; related to numerical integrator. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_regularized_time_steps_per_orbit"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @regularized_time_steps_per_orbit.setter
    def regularized_time_steps_per_orbit(self, inVal:int) -> None:
        with agmarshall.LONG_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_regularized_time_steps_per_orbit"](arg_inVal.COM_val))

    @property
    def propagator_functions(self) -> "IPropagatorFunctionCollection":
        """The list of propagator functions."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAPropagatorFunctionCollection:
            agcls.evaluate_hresult(self.__dict__["_get_propagator_functions"](byref(arg_ppVAPropagatorFunctionCollection.COM_val)))
            return arg_ppVAPropagatorFunctionCollection.python_val

    @property
    def numerical_integrator(self) -> "INumericalIntegrator":
        """The numerical integrator."""
        with agmarshall.AgInterface_out_arg() as arg_ppVANumericalIntegrator:
            agcls.evaluate_hresult(self.__dict__["_get_numerical_integrator"](byref(arg_ppVANumericalIntegrator.COM_val)))
            return arg_ppVANumericalIntegrator.python_val

    @property
    def numerical_integrator_type(self) -> "AgEVANumericalIntegrator":
        """The single step integrator type."""
        with agmarshall.AgEnum_arg(AgEVANumericalIntegrator) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_numerical_integrator_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_numerical_integrator(self, integrator:"AgEVANumericalIntegrator") -> None:
        """Changes the single step integrator."""
        with agmarshall.AgEnum_arg(AgEVANumericalIntegrator, integrator) as arg_integrator:
            agcls.evaluate_hresult(self.__dict__["_set_numerical_integrator"](arg_integrator.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{5E7589D9-478E-4C8F-A856-2E548833C9C5}", INumericalPropagatorWrapper)
agcls.AgTypeNameMap["INumericalPropagatorWrapper"] = INumericalPropagatorWrapper

class INumericalPropagatorWrapperCR3BP(object):
    """General properties for three-body problem propagators."""
    _uuid = "{C0662E79-7987-4363-B97D-2277A12A7B5B}"
    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_set_central_body_name"] = _raise_uninitialized_error
        self.__dict__["_get_propagator_functions"] = _raise_uninitialized_error
        self.__dict__["_get_numerical_integrator"] = _raise_uninitialized_error
        self.__dict__["_get_numerical_integrator_type"] = _raise_uninitialized_error
        self.__dict__["_set_numerical_integrator"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(INumericalPropagatorWrapperCR3BP._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create INumericalPropagatorWrapperCR3BP from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_INumericalPropagatorWrapperCR3BP = agcom.GUID(INumericalPropagatorWrapperCR3BP._uuid)
        vtable_offset_local = INumericalPropagatorWrapperCR3BP._vtable_offset - 1
        self.__dict__["_get_central_body_name"] = IAGFUNCTYPE(pUnk, IID_INumericalPropagatorWrapperCR3BP, vtable_offset_local+1, POINTER(agcom.BSTR))
        self.__dict__["_set_central_body_name"] = IAGFUNCTYPE(pUnk, IID_INumericalPropagatorWrapperCR3BP, vtable_offset_local+2, agcom.BSTR)
        self.__dict__["_get_propagator_functions"] = IAGFUNCTYPE(pUnk, IID_INumericalPropagatorWrapperCR3BP, vtable_offset_local+3, POINTER(agcom.PVOID))
        self.__dict__["_get_numerical_integrator"] = IAGFUNCTYPE(pUnk, IID_INumericalPropagatorWrapperCR3BP, vtable_offset_local+4, POINTER(agcom.PVOID))
        self.__dict__["_get_numerical_integrator_type"] = IAGFUNCTYPE(pUnk, IID_INumericalPropagatorWrapperCR3BP, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_numerical_integrator"] = IAGFUNCTYPE(pUnk, IID_INumericalPropagatorWrapperCR3BP, vtable_offset_local+6, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in INumericalPropagatorWrapperCR3BP.__dict__ and type(INumericalPropagatorWrapperCR3BP.__dict__[attrname]) == property:
            return INumericalPropagatorWrapperCR3BP.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in INumericalPropagatorWrapperCR3BP.")
    
    @property
    def central_body_name(self) -> str:
        """The central body for Propagation."""
        with agmarshall.BSTR_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_central_body_name"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @central_body_name.setter
    def central_body_name(self, inVal:str) -> None:
        with agmarshall.BSTR_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_central_body_name"](arg_inVal.COM_val))

    @property
    def propagator_functions(self) -> "IPropagatorFunctionCollection":
        """The list of propagator functions."""
        with agmarshall.AgInterface_out_arg() as arg_ppVAPropagatorFunctionCollection:
            agcls.evaluate_hresult(self.__dict__["_get_propagator_functions"](byref(arg_ppVAPropagatorFunctionCollection.COM_val)))
            return arg_ppVAPropagatorFunctionCollection.python_val

    @property
    def numerical_integrator(self) -> "INumericalIntegrator":
        """The numerical integrator."""
        with agmarshall.AgInterface_out_arg() as arg_ppVANumericalIntegrator:
            agcls.evaluate_hresult(self.__dict__["_get_numerical_integrator"](byref(arg_ppVANumericalIntegrator.COM_val)))
            return arg_ppVANumericalIntegrator.python_val

    @property
    def numerical_integrator_type(self) -> "AgEVANumericalIntegrator":
        """The numerical integrator type."""
        with agmarshall.AgEnum_arg(AgEVANumericalIntegrator) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_numerical_integrator_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_numerical_integrator(self, integrator:"AgEVANumericalIntegrator") -> None:
        """Changes the numerical integrator."""
        with agmarshall.AgEnum_arg(AgEVANumericalIntegrator, integrator) as arg_integrator:
            agcls.evaluate_hresult(self.__dict__["_set_numerical_integrator"](arg_integrator.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{C0662E79-7987-4363-B97D-2277A12A7B5B}", INumericalPropagatorWrapperCR3BP)
agcls.AgTypeNameMap["INumericalPropagatorWrapperCR3BP"] = INumericalPropagatorWrapperCR3BP

class IBulirschStoerIntegrator(object):
    """Properties for the Bulirsch-Stoer numerical integrator."""
    _uuid = "{2A307A62-0365-405B-B493-5F11810DF50C}"
    _num_methods = 24
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_initial_step"] = _raise_uninitialized_error
        self.__dict__["_set_initial_step"] = _raise_uninitialized_error
        self.__dict__["_get_use_fixed_step"] = _raise_uninitialized_error
        self.__dict__["_set_use_fixed_step"] = _raise_uninitialized_error
        self.__dict__["_get_use_max_step"] = _raise_uninitialized_error
        self.__dict__["_set_use_max_step"] = _raise_uninitialized_error
        self.__dict__["_get_use_min_step"] = _raise_uninitialized_error
        self.__dict__["_set_use_min_step"] = _raise_uninitialized_error
        self.__dict__["_get_max_step"] = _raise_uninitialized_error
        self.__dict__["_set_max_step"] = _raise_uninitialized_error
        self.__dict__["_get_min_step"] = _raise_uninitialized_error
        self.__dict__["_set_min_step"] = _raise_uninitialized_error
        self.__dict__["_get_max_rel_err"] = _raise_uninitialized_error
        self.__dict__["_set_max_rel_err"] = _raise_uninitialized_error
        self.__dict__["_get_max_sequences"] = _raise_uninitialized_error
        self.__dict__["_set_max_sequences"] = _raise_uninitialized_error
        self.__dict__["_get_max_iterations"] = _raise_uninitialized_error
        self.__dict__["_set_max_iterations"] = _raise_uninitialized_error
        self.__dict__["_get_tolerance"] = _raise_uninitialized_error
        self.__dict__["_set_tolerance"] = _raise_uninitialized_error
        self.__dict__["_get_first_safety_coefficient"] = _raise_uninitialized_error
        self.__dict__["_set_first_safety_coefficient"] = _raise_uninitialized_error
        self.__dict__["_get_second_safety_coefficient"] = _raise_uninitialized_error
        self.__dict__["_set_second_safety_coefficient"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IBulirschStoerIntegrator._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IBulirschStoerIntegrator from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IBulirschStoerIntegrator = agcom.GUID(IBulirschStoerIntegrator._uuid)
        vtable_offset_local = IBulirschStoerIntegrator._vtable_offset - 1
        self.__dict__["_get_initial_step"] = IAGFUNCTYPE(pUnk, IID_IBulirschStoerIntegrator, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_initial_step"] = IAGFUNCTYPE(pUnk, IID_IBulirschStoerIntegrator, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_use_fixed_step"] = IAGFUNCTYPE(pUnk, IID_IBulirschStoerIntegrator, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_fixed_step"] = IAGFUNCTYPE(pUnk, IID_IBulirschStoerIntegrator, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_get_use_max_step"] = IAGFUNCTYPE(pUnk, IID_IBulirschStoerIntegrator, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_max_step"] = IAGFUNCTYPE(pUnk, IID_IBulirschStoerIntegrator, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_get_use_min_step"] = IAGFUNCTYPE(pUnk, IID_IBulirschStoerIntegrator, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_min_step"] = IAGFUNCTYPE(pUnk, IID_IBulirschStoerIntegrator, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_get_max_step"] = IAGFUNCTYPE(pUnk, IID_IBulirschStoerIntegrator, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_step"] = IAGFUNCTYPE(pUnk, IID_IBulirschStoerIntegrator, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_min_step"] = IAGFUNCTYPE(pUnk, IID_IBulirschStoerIntegrator, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_min_step"] = IAGFUNCTYPE(pUnk, IID_IBulirschStoerIntegrator, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_max_rel_err"] = IAGFUNCTYPE(pUnk, IID_IBulirschStoerIntegrator, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_rel_err"] = IAGFUNCTYPE(pUnk, IID_IBulirschStoerIntegrator, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_max_sequences"] = IAGFUNCTYPE(pUnk, IID_IBulirschStoerIntegrator, vtable_offset_local+15, POINTER(agcom.LONG))
        self.__dict__["_set_max_sequences"] = IAGFUNCTYPE(pUnk, IID_IBulirschStoerIntegrator, vtable_offset_local+16, agcom.LONG)
        self.__dict__["_get_max_iterations"] = IAGFUNCTYPE(pUnk, IID_IBulirschStoerIntegrator, vtable_offset_local+17, POINTER(agcom.LONG))
        self.__dict__["_set_max_iterations"] = IAGFUNCTYPE(pUnk, IID_IBulirschStoerIntegrator, vtable_offset_local+18, agcom.LONG)
        self.__dict__["_get_tolerance"] = IAGFUNCTYPE(pUnk, IID_IBulirschStoerIntegrator, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_set_tolerance"] = IAGFUNCTYPE(pUnk, IID_IBulirschStoerIntegrator, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_get_first_safety_coefficient"] = IAGFUNCTYPE(pUnk, IID_IBulirschStoerIntegrator, vtable_offset_local+21, POINTER(agcom.DOUBLE))
        self.__dict__["_set_first_safety_coefficient"] = IAGFUNCTYPE(pUnk, IID_IBulirschStoerIntegrator, vtable_offset_local+22, agcom.DOUBLE)
        self.__dict__["_get_second_safety_coefficient"] = IAGFUNCTYPE(pUnk, IID_IBulirschStoerIntegrator, vtable_offset_local+23, POINTER(agcom.DOUBLE))
        self.__dict__["_set_second_safety_coefficient"] = IAGFUNCTYPE(pUnk, IID_IBulirschStoerIntegrator, vtable_offset_local+24, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IBulirschStoerIntegrator.__dict__ and type(IBulirschStoerIntegrator.__dict__[attrname]) == property:
            return IBulirschStoerIntegrator.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IBulirschStoerIntegrator.")
    
    @property
    def initial_step(self) -> float:
        """The initial step. Uses time dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_initial_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @initial_step.setter
    def initial_step(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_initial_step"](arg_inVal.COM_val))

    @property
    def use_fixed_step(self) -> bool:
        """True if running in fixed-step mode."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_fixed_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_fixed_step.setter
    def use_fixed_step(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_fixed_step"](arg_inVal.COM_val))

    @property
    def use_max_step(self) -> bool:
        """Whether or not to enforce the maximum step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_max_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_max_step.setter
    def use_max_step(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_max_step"](arg_inVal.COM_val))

    @property
    def use_min_step(self) -> bool:
        """Whether or not to enforce the minimum step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_min_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_min_step.setter
    def use_min_step(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_min_step"](arg_inVal.COM_val))

    @property
    def max_step(self) -> float:
        """The maximum step size to allow (absolute value). Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_step.setter
    def max_step(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_step"](arg_inVal.COM_val))

    @property
    def min_step(self) -> float:
        """The minimum step size to allow (absolute value). Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @min_step.setter
    def min_step(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_min_step"](arg_inVal.COM_val))

    @property
    def max_rel_err(self) -> float:
        """The maximum relative error used to control step size. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_rel_err"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_rel_err.setter
    def max_rel_err(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_rel_err"](arg_inVal.COM_val))

    @property
    def max_sequences(self) -> int:
        """The maximum number of sequences. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_sequences"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_sequences.setter
    def max_sequences(self, inVal:int) -> None:
        with agmarshall.LONG_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_sequences"](arg_inVal.COM_val))

    @property
    def max_iterations(self) -> int:
        """The maximum number of iterations. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_iterations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_iterations.setter
    def max_iterations(self, inVal:int) -> None:
        with agmarshall.LONG_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_iterations"](arg_inVal.COM_val))

    @property
    def tolerance(self) -> float:
        """The error tolerance for step size control. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_tolerance"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @tolerance.setter
    def tolerance(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_tolerance"](arg_inVal.COM_val))

    @property
    def first_safety_coefficient(self) -> float:
        """The first safety coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_first_safety_coefficient"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @first_safety_coefficient.setter
    def first_safety_coefficient(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_first_safety_coefficient"](arg_inVal.COM_val))

    @property
    def second_safety_coefficient(self) -> float:
        """The second safety coefficient. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_second_safety_coefficient"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @second_safety_coefficient.setter
    def second_safety_coefficient(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_second_safety_coefficient"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2A307A62-0365-405B-B493-5F11810DF50C}", IBulirschStoerIntegrator)
agcls.AgTypeNameMap["IBulirschStoerIntegrator"] = IBulirschStoerIntegrator

class IGaussJacksonIntegrator(object):
    """Properties for the Gauss-Jackson numerical integrator."""
    _uuid = "{C68E6FDF-DA4F-4FA6-A313-3CA4EF865E0C}"
    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_initial_step"] = _raise_uninitialized_error
        self.__dict__["_set_initial_step"] = _raise_uninitialized_error
        self.__dict__["_get_max_corrector_rel_err"] = _raise_uninitialized_error
        self.__dict__["_set_max_corrector_rel_err"] = _raise_uninitialized_error
        self.__dict__["_get_corrector_mode"] = _raise_uninitialized_error
        self.__dict__["_set_corrector_mode"] = _raise_uninitialized_error
        self.__dict__["_get_max_corrector_iterations"] = _raise_uninitialized_error
        self.__dict__["_set_max_corrector_iterations"] = _raise_uninitialized_error
        self.__dict__["_get_single_step_integrator"] = _raise_uninitialized_error
        self.__dict__["_get_single_step_integrator_type"] = _raise_uninitialized_error
        self.__dict__["_set_single_step_integrator"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IGaussJacksonIntegrator._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IGaussJacksonIntegrator from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IGaussJacksonIntegrator = agcom.GUID(IGaussJacksonIntegrator._uuid)
        vtable_offset_local = IGaussJacksonIntegrator._vtable_offset - 1
        self.__dict__["_get_initial_step"] = IAGFUNCTYPE(pUnk, IID_IGaussJacksonIntegrator, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_initial_step"] = IAGFUNCTYPE(pUnk, IID_IGaussJacksonIntegrator, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_max_corrector_rel_err"] = IAGFUNCTYPE(pUnk, IID_IGaussJacksonIntegrator, vtable_offset_local+3, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_corrector_rel_err"] = IAGFUNCTYPE(pUnk, IID_IGaussJacksonIntegrator, vtable_offset_local+4, agcom.DOUBLE)
        self.__dict__["_get_corrector_mode"] = IAGFUNCTYPE(pUnk, IID_IGaussJacksonIntegrator, vtable_offset_local+5, POINTER(agcom.LONG))
        self.__dict__["_set_corrector_mode"] = IAGFUNCTYPE(pUnk, IID_IGaussJacksonIntegrator, vtable_offset_local+6, agcom.LONG)
        self.__dict__["_get_max_corrector_iterations"] = IAGFUNCTYPE(pUnk, IID_IGaussJacksonIntegrator, vtable_offset_local+7, POINTER(agcom.LONG))
        self.__dict__["_set_max_corrector_iterations"] = IAGFUNCTYPE(pUnk, IID_IGaussJacksonIntegrator, vtable_offset_local+8, agcom.LONG)
        self.__dict__["_get_single_step_integrator"] = IAGFUNCTYPE(pUnk, IID_IGaussJacksonIntegrator, vtable_offset_local+9, POINTER(agcom.PVOID))
        self.__dict__["_get_single_step_integrator_type"] = IAGFUNCTYPE(pUnk, IID_IGaussJacksonIntegrator, vtable_offset_local+10, POINTER(agcom.LONG))
        self.__dict__["_set_single_step_integrator"] = IAGFUNCTYPE(pUnk, IID_IGaussJacksonIntegrator, vtable_offset_local+11, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IGaussJacksonIntegrator.__dict__ and type(IGaussJacksonIntegrator.__dict__[attrname]) == property:
            return IGaussJacksonIntegrator.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IGaussJacksonIntegrator.")
    
    @property
    def initial_step(self) -> float:
        """The initial step. Uses time dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_initial_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @initial_step.setter
    def initial_step(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_initial_step"](arg_inVal.COM_val))

    @property
    def max_corrector_rel_err(self) -> float:
        """The maximum relative error between corrector iterations. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_corrector_rel_err"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_corrector_rel_err.setter
    def max_corrector_rel_err(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_corrector_rel_err"](arg_inVal.COM_val))

    @property
    def corrector_mode(self) -> "AgEVAPredictorCorrector":
        """The Predictor Corrector scheme."""
        with agmarshall.AgEnum_arg(AgEVAPredictorCorrector) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_corrector_mode"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @corrector_mode.setter
    def corrector_mode(self, inVal:"AgEVAPredictorCorrector") -> None:
        with agmarshall.AgEnum_arg(AgEVAPredictorCorrector, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_corrector_mode"](arg_inVal.COM_val))

    @property
    def max_corrector_iterations(self) -> int:
        """The maximum corrector iterations. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_corrector_iterations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_corrector_iterations.setter
    def max_corrector_iterations(self, inVal:int) -> None:
        with agmarshall.LONG_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_corrector_iterations"](arg_inVal.COM_val))

    @property
    def single_step_integrator(self) -> "INumericalIntegrator":
        """The stopping integrator; a single-step integrator."""
        with agmarshall.AgInterface_out_arg() as arg_ppVANumericalIntegrator:
            agcls.evaluate_hresult(self.__dict__["_get_single_step_integrator"](byref(arg_ppVANumericalIntegrator.COM_val)))
            return arg_ppVANumericalIntegrator.python_val

    @property
    def single_step_integrator_type(self) -> "AgEVANumericalIntegrator":
        """The stopping integrator type."""
        with agmarshall.AgEnum_arg(AgEVANumericalIntegrator) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_single_step_integrator_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    def set_single_step_integrator(self, integrator:"AgEVANumericalIntegrator") -> None:
        """Changes the stopping integrator."""
        with agmarshall.AgEnum_arg(AgEVANumericalIntegrator, integrator) as arg_integrator:
            agcls.evaluate_hresult(self.__dict__["_set_single_step_integrator"](arg_integrator.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{C68E6FDF-DA4F-4FA6-A313-3CA4EF865E0C}", IGaussJacksonIntegrator)
agcls.AgTypeNameMap["IGaussJacksonIntegrator"] = IGaussJacksonIntegrator

class IRungeKutta2nd3rd(object):
    """Properties for the RK2nd3rd numerical integrator."""
    _uuid = "{B45A629D-EAD2-45CB-9757-0AF4BBC0967A}"
    _num_methods = 24
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_initial_step"] = _raise_uninitialized_error
        self.__dict__["_set_initial_step"] = _raise_uninitialized_error
        self.__dict__["_get_use_fixed_step"] = _raise_uninitialized_error
        self.__dict__["_set_use_fixed_step"] = _raise_uninitialized_error
        self.__dict__["_get_use_max_step"] = _raise_uninitialized_error
        self.__dict__["_set_use_max_step"] = _raise_uninitialized_error
        self.__dict__["_get_use_min_step"] = _raise_uninitialized_error
        self.__dict__["_set_use_min_step"] = _raise_uninitialized_error
        self.__dict__["_get_max_step"] = _raise_uninitialized_error
        self.__dict__["_set_max_step"] = _raise_uninitialized_error
        self.__dict__["_get_min_step"] = _raise_uninitialized_error
        self.__dict__["_set_min_step"] = _raise_uninitialized_error
        self.__dict__["_get_max_rel_err"] = _raise_uninitialized_error
        self.__dict__["_set_max_rel_err"] = _raise_uninitialized_error
        self.__dict__["_get_max_abs_err"] = _raise_uninitialized_error
        self.__dict__["_set_max_abs_err"] = _raise_uninitialized_error
        self.__dict__["_get_high_safety_coefficient"] = _raise_uninitialized_error
        self.__dict__["_set_high_safety_coefficient"] = _raise_uninitialized_error
        self.__dict__["_get_low_safety_coefficient"] = _raise_uninitialized_error
        self.__dict__["_set_low_safety_coefficient"] = _raise_uninitialized_error
        self.__dict__["_get_error_control"] = _raise_uninitialized_error
        self.__dict__["_set_error_control"] = _raise_uninitialized_error
        self.__dict__["_get_max_iterations"] = _raise_uninitialized_error
        self.__dict__["_set_max_iterations"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IRungeKutta2nd3rd._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IRungeKutta2nd3rd from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IRungeKutta2nd3rd = agcom.GUID(IRungeKutta2nd3rd._uuid)
        vtable_offset_local = IRungeKutta2nd3rd._vtable_offset - 1
        self.__dict__["_get_initial_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta2nd3rd, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_initial_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta2nd3rd, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_use_fixed_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta2nd3rd, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_fixed_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta2nd3rd, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_get_use_max_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta2nd3rd, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_max_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta2nd3rd, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_get_use_min_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta2nd3rd, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_min_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta2nd3rd, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_get_max_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta2nd3rd, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta2nd3rd, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_min_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta2nd3rd, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_min_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta2nd3rd, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_max_rel_err"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta2nd3rd, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_rel_err"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta2nd3rd, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_max_abs_err"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta2nd3rd, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_abs_err"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta2nd3rd, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_high_safety_coefficient"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta2nd3rd, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_high_safety_coefficient"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta2nd3rd, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_low_safety_coefficient"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta2nd3rd, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_set_low_safety_coefficient"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta2nd3rd, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_get_error_control"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta2nd3rd, vtable_offset_local+21, POINTER(agcom.LONG))
        self.__dict__["_set_error_control"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta2nd3rd, vtable_offset_local+22, agcom.LONG)
        self.__dict__["_get_max_iterations"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta2nd3rd, vtable_offset_local+23, POINTER(agcom.LONG))
        self.__dict__["_set_max_iterations"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta2nd3rd, vtable_offset_local+24, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRungeKutta2nd3rd.__dict__ and type(IRungeKutta2nd3rd.__dict__[attrname]) == property:
            return IRungeKutta2nd3rd.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRungeKutta2nd3rd.")
    
    @property
    def initial_step(self) -> float:
        """The initial step. Uses time dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_initial_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @initial_step.setter
    def initial_step(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_initial_step"](arg_inVal.COM_val))

    @property
    def use_fixed_step(self) -> bool:
        """True if running in fixed-step mode."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_fixed_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_fixed_step.setter
    def use_fixed_step(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_fixed_step"](arg_inVal.COM_val))

    @property
    def use_max_step(self) -> bool:
        """Whether or not to enforce the maximum step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_max_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_max_step.setter
    def use_max_step(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_max_step"](arg_inVal.COM_val))

    @property
    def use_min_step(self) -> bool:
        """Whether or not to enforce the minimum step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_min_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_min_step.setter
    def use_min_step(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_min_step"](arg_inVal.COM_val))

    @property
    def max_step(self) -> float:
        """The maximum step size to allow (absolute value). Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_step.setter
    def max_step(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_step"](arg_inVal.COM_val))

    @property
    def min_step(self) -> float:
        """The minimum step size to allow (absolute value). Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @min_step.setter
    def min_step(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_min_step"](arg_inVal.COM_val))

    @property
    def max_rel_err(self) -> float:
        """The maximum relative error used to control step size. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_rel_err"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_rel_err.setter
    def max_rel_err(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_rel_err"](arg_inVal.COM_val))

    @property
    def max_abs_err(self) -> float:
        """The maximum absolute error; Also used if relative scale is too small. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_abs_err"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_abs_err.setter
    def max_abs_err(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_abs_err"](arg_inVal.COM_val))

    @property
    def high_safety_coefficient(self) -> float:
        """The 'safety' coefficient used to decrease step size if the error is too high. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_high_safety_coefficient"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @high_safety_coefficient.setter
    def high_safety_coefficient(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_high_safety_coefficient"](arg_inVal.COM_val))

    @property
    def low_safety_coefficient(self) -> float:
        """The 'safety' coefficient used to increase step size if the error is too low. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_low_safety_coefficient"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @low_safety_coefficient.setter
    def low_safety_coefficient(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_low_safety_coefficient"](arg_inVal.COM_val))

    @property
    def error_control(self) -> "AgEVAErrorControl":
        """The error control method."""
        with agmarshall.AgEnum_arg(AgEVAErrorControl) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_error_control"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @error_control.setter
    def error_control(self, inVal:"AgEVAErrorControl") -> None:
        with agmarshall.AgEnum_arg(AgEVAErrorControl, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_error_control"](arg_inVal.COM_val))

    @property
    def max_iterations(self) -> int:
        """The maximum iterations. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_iterations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_iterations.setter
    def max_iterations(self, inVal:int) -> None:
        with agmarshall.LONG_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_iterations"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{B45A629D-EAD2-45CB-9757-0AF4BBC0967A}", IRungeKutta2nd3rd)
agcls.AgTypeNameMap["IRungeKutta2nd3rd"] = IRungeKutta2nd3rd

class IRungeKutta4th(object):
    """Properties for the RK4th numerical integrator."""
    _uuid = "{AC6ACE9D-D174-4A09-9E10-7EE104ED8E9C}"
    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_initial_step"] = _raise_uninitialized_error
        self.__dict__["_set_initial_step"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IRungeKutta4th._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IRungeKutta4th from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IRungeKutta4th = agcom.GUID(IRungeKutta4th._uuid)
        vtable_offset_local = IRungeKutta4th._vtable_offset - 1
        self.__dict__["_get_initial_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4th, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_initial_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4th, vtable_offset_local+2, agcom.DOUBLE)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRungeKutta4th.__dict__ and type(IRungeKutta4th.__dict__[attrname]) == property:
            return IRungeKutta4th.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRungeKutta4th.")
    
    @property
    def initial_step(self) -> float:
        """The initial step. Uses time dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_initial_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @initial_step.setter
    def initial_step(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_initial_step"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{AC6ACE9D-D174-4A09-9E10-7EE104ED8E9C}", IRungeKutta4th)
agcls.AgTypeNameMap["IRungeKutta4th"] = IRungeKutta4th

class IRungeKutta4th5th(object):
    """Properties for the RK4th5th numerical integrator."""
    _uuid = "{F71F9E83-14BD-4BA3-BB99-AD7CDA3FCA40}"
    _num_methods = 24
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_initial_step"] = _raise_uninitialized_error
        self.__dict__["_set_initial_step"] = _raise_uninitialized_error
        self.__dict__["_get_use_fixed_step"] = _raise_uninitialized_error
        self.__dict__["_set_use_fixed_step"] = _raise_uninitialized_error
        self.__dict__["_get_use_max_step"] = _raise_uninitialized_error
        self.__dict__["_set_use_max_step"] = _raise_uninitialized_error
        self.__dict__["_get_use_min_step"] = _raise_uninitialized_error
        self.__dict__["_set_use_min_step"] = _raise_uninitialized_error
        self.__dict__["_get_max_step"] = _raise_uninitialized_error
        self.__dict__["_set_max_step"] = _raise_uninitialized_error
        self.__dict__["_get_min_step"] = _raise_uninitialized_error
        self.__dict__["_set_min_step"] = _raise_uninitialized_error
        self.__dict__["_get_max_rel_err"] = _raise_uninitialized_error
        self.__dict__["_set_max_rel_err"] = _raise_uninitialized_error
        self.__dict__["_get_max_abs_err"] = _raise_uninitialized_error
        self.__dict__["_set_max_abs_err"] = _raise_uninitialized_error
        self.__dict__["_get_high_safety_coefficient"] = _raise_uninitialized_error
        self.__dict__["_set_high_safety_coefficient"] = _raise_uninitialized_error
        self.__dict__["_get_low_safety_coefficient"] = _raise_uninitialized_error
        self.__dict__["_set_low_safety_coefficient"] = _raise_uninitialized_error
        self.__dict__["_get_error_control"] = _raise_uninitialized_error
        self.__dict__["_set_error_control"] = _raise_uninitialized_error
        self.__dict__["_get_max_iterations"] = _raise_uninitialized_error
        self.__dict__["_set_max_iterations"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IRungeKutta4th5th._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IRungeKutta4th5th from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IRungeKutta4th5th = agcom.GUID(IRungeKutta4th5th._uuid)
        vtable_offset_local = IRungeKutta4th5th._vtable_offset - 1
        self.__dict__["_get_initial_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4th5th, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_initial_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4th5th, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_use_fixed_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4th5th, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_fixed_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4th5th, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_get_use_max_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4th5th, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_max_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4th5th, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_get_use_min_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4th5th, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_min_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4th5th, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_get_max_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4th5th, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4th5th, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_min_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4th5th, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_min_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4th5th, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_max_rel_err"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4th5th, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_rel_err"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4th5th, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_max_abs_err"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4th5th, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_abs_err"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4th5th, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_high_safety_coefficient"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4th5th, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_high_safety_coefficient"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4th5th, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_low_safety_coefficient"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4th5th, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_set_low_safety_coefficient"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4th5th, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_get_error_control"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4th5th, vtable_offset_local+21, POINTER(agcom.LONG))
        self.__dict__["_set_error_control"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4th5th, vtable_offset_local+22, agcom.LONG)
        self.__dict__["_get_max_iterations"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4th5th, vtable_offset_local+23, POINTER(agcom.LONG))
        self.__dict__["_set_max_iterations"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4th5th, vtable_offset_local+24, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRungeKutta4th5th.__dict__ and type(IRungeKutta4th5th.__dict__[attrname]) == property:
            return IRungeKutta4th5th.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRungeKutta4th5th.")
    
    @property
    def initial_step(self) -> float:
        """The initial step. Uses time dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_initial_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @initial_step.setter
    def initial_step(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_initial_step"](arg_inVal.COM_val))

    @property
    def use_fixed_step(self) -> bool:
        """True if running in fixed-step mode."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_fixed_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_fixed_step.setter
    def use_fixed_step(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_fixed_step"](arg_inVal.COM_val))

    @property
    def use_max_step(self) -> bool:
        """Whether or not to enforce the maximum step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_max_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_max_step.setter
    def use_max_step(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_max_step"](arg_inVal.COM_val))

    @property
    def use_min_step(self) -> bool:
        """Whether or not to enforce the minimum step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_min_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_min_step.setter
    def use_min_step(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_min_step"](arg_inVal.COM_val))

    @property
    def max_step(self) -> float:
        """The maximum step size to allow (absolute value). Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_step.setter
    def max_step(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_step"](arg_inVal.COM_val))

    @property
    def min_step(self) -> float:
        """The minimum step size to allow (absolute value). Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @min_step.setter
    def min_step(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_min_step"](arg_inVal.COM_val))

    @property
    def max_rel_err(self) -> float:
        """The maximum relative error used to control step size. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_rel_err"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_rel_err.setter
    def max_rel_err(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_rel_err"](arg_inVal.COM_val))

    @property
    def max_abs_err(self) -> float:
        """The maximum absolute error; Also used if relative scale is too small. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_abs_err"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_abs_err.setter
    def max_abs_err(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_abs_err"](arg_inVal.COM_val))

    @property
    def high_safety_coefficient(self) -> float:
        """The 'safety' coefficient used to decrease step size if the error is too high. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_high_safety_coefficient"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @high_safety_coefficient.setter
    def high_safety_coefficient(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_high_safety_coefficient"](arg_inVal.COM_val))

    @property
    def low_safety_coefficient(self) -> float:
        """The 'safety' coefficient used to increase step size if the error is too low. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_low_safety_coefficient"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @low_safety_coefficient.setter
    def low_safety_coefficient(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_low_safety_coefficient"](arg_inVal.COM_val))

    @property
    def error_control(self) -> "AgEVAErrorControl":
        """The error control method."""
        with agmarshall.AgEnum_arg(AgEVAErrorControl) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_error_control"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @error_control.setter
    def error_control(self, inVal:"AgEVAErrorControl") -> None:
        with agmarshall.AgEnum_arg(AgEVAErrorControl, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_error_control"](arg_inVal.COM_val))

    @property
    def max_iterations(self) -> int:
        """The maximum iterations. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_iterations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_iterations.setter
    def max_iterations(self, inVal:int) -> None:
        with agmarshall.LONG_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_iterations"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{F71F9E83-14BD-4BA3-BB99-AD7CDA3FCA40}", IRungeKutta4th5th)
agcls.AgTypeNameMap["IRungeKutta4th5th"] = IRungeKutta4th5th

class IRungeKutta4thAdapt(object):
    """Properties for the RK4thAdapt numerical integrator."""
    _uuid = "{2FD2C00D-0DB5-4933-99A1-759E7D0F6A85}"
    _num_methods = 24
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_initial_step"] = _raise_uninitialized_error
        self.__dict__["_set_initial_step"] = _raise_uninitialized_error
        self.__dict__["_get_use_fixed_step"] = _raise_uninitialized_error
        self.__dict__["_set_use_fixed_step"] = _raise_uninitialized_error
        self.__dict__["_get_use_max_step"] = _raise_uninitialized_error
        self.__dict__["_set_use_max_step"] = _raise_uninitialized_error
        self.__dict__["_get_use_min_step"] = _raise_uninitialized_error
        self.__dict__["_set_use_min_step"] = _raise_uninitialized_error
        self.__dict__["_get_max_step"] = _raise_uninitialized_error
        self.__dict__["_set_max_step"] = _raise_uninitialized_error
        self.__dict__["_get_min_step"] = _raise_uninitialized_error
        self.__dict__["_set_min_step"] = _raise_uninitialized_error
        self.__dict__["_get_max_rel_err"] = _raise_uninitialized_error
        self.__dict__["_set_max_rel_err"] = _raise_uninitialized_error
        self.__dict__["_get_max_abs_err"] = _raise_uninitialized_error
        self.__dict__["_set_max_abs_err"] = _raise_uninitialized_error
        self.__dict__["_get_high_safety_coefficient"] = _raise_uninitialized_error
        self.__dict__["_set_high_safety_coefficient"] = _raise_uninitialized_error
        self.__dict__["_get_low_safety_coefficient"] = _raise_uninitialized_error
        self.__dict__["_set_low_safety_coefficient"] = _raise_uninitialized_error
        self.__dict__["_get_error_control"] = _raise_uninitialized_error
        self.__dict__["_set_error_control"] = _raise_uninitialized_error
        self.__dict__["_get_max_iterations"] = _raise_uninitialized_error
        self.__dict__["_set_max_iterations"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IRungeKutta4thAdapt._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IRungeKutta4thAdapt from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IRungeKutta4thAdapt = agcom.GUID(IRungeKutta4thAdapt._uuid)
        vtable_offset_local = IRungeKutta4thAdapt._vtable_offset - 1
        self.__dict__["_get_initial_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4thAdapt, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_initial_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4thAdapt, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_use_fixed_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4thAdapt, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_fixed_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4thAdapt, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_get_use_max_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4thAdapt, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_max_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4thAdapt, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_get_use_min_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4thAdapt, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_min_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4thAdapt, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_get_max_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4thAdapt, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4thAdapt, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_min_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4thAdapt, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_min_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4thAdapt, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_max_rel_err"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4thAdapt, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_rel_err"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4thAdapt, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_max_abs_err"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4thAdapt, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_abs_err"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4thAdapt, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_high_safety_coefficient"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4thAdapt, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_high_safety_coefficient"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4thAdapt, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_low_safety_coefficient"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4thAdapt, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_set_low_safety_coefficient"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4thAdapt, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_get_error_control"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4thAdapt, vtable_offset_local+21, POINTER(agcom.LONG))
        self.__dict__["_set_error_control"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4thAdapt, vtable_offset_local+22, agcom.LONG)
        self.__dict__["_get_max_iterations"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4thAdapt, vtable_offset_local+23, POINTER(agcom.LONG))
        self.__dict__["_set_max_iterations"] = IAGFUNCTYPE(pUnk, IID_IRungeKutta4thAdapt, vtable_offset_local+24, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRungeKutta4thAdapt.__dict__ and type(IRungeKutta4thAdapt.__dict__[attrname]) == property:
            return IRungeKutta4thAdapt.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRungeKutta4thAdapt.")
    
    @property
    def initial_step(self) -> float:
        """The initial step. Uses time dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_initial_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @initial_step.setter
    def initial_step(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_initial_step"](arg_inVal.COM_val))

    @property
    def use_fixed_step(self) -> bool:
        """True if running in fixed-step mode."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_fixed_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_fixed_step.setter
    def use_fixed_step(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_fixed_step"](arg_inVal.COM_val))

    @property
    def use_max_step(self) -> bool:
        """Whether or not to enforce the maximum step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_max_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_max_step.setter
    def use_max_step(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_max_step"](arg_inVal.COM_val))

    @property
    def use_min_step(self) -> bool:
        """Whether or not to enforce the minimum step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_min_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_min_step.setter
    def use_min_step(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_min_step"](arg_inVal.COM_val))

    @property
    def max_step(self) -> float:
        """The maximum step size to allow (absolute value). Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_step.setter
    def max_step(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_step"](arg_inVal.COM_val))

    @property
    def min_step(self) -> float:
        """The minimum step size to allow (absolute value). Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @min_step.setter
    def min_step(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_min_step"](arg_inVal.COM_val))

    @property
    def max_rel_err(self) -> float:
        """The maximum relative error used to control step size. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_rel_err"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_rel_err.setter
    def max_rel_err(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_rel_err"](arg_inVal.COM_val))

    @property
    def max_abs_err(self) -> float:
        """The maximum absolute error; Also used if relative scale is too small. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_abs_err"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_abs_err.setter
    def max_abs_err(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_abs_err"](arg_inVal.COM_val))

    @property
    def high_safety_coefficient(self) -> float:
        """The 'safety' coefficient used to decrease step size if the error is too high. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_high_safety_coefficient"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @high_safety_coefficient.setter
    def high_safety_coefficient(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_high_safety_coefficient"](arg_inVal.COM_val))

    @property
    def low_safety_coefficient(self) -> float:
        """The 'safety' coefficient used to increase step size if the error is too low. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_low_safety_coefficient"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @low_safety_coefficient.setter
    def low_safety_coefficient(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_low_safety_coefficient"](arg_inVal.COM_val))

    @property
    def error_control(self) -> "AgEVAErrorControl":
        """The error control method."""
        with agmarshall.AgEnum_arg(AgEVAErrorControl) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_error_control"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @error_control.setter
    def error_control(self, inVal:"AgEVAErrorControl") -> None:
        with agmarshall.AgEnum_arg(AgEVAErrorControl, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_error_control"](arg_inVal.COM_val))

    @property
    def max_iterations(self) -> int:
        """The maximum iterations. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_iterations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_iterations.setter
    def max_iterations(self, inVal:int) -> None:
        with agmarshall.LONG_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_iterations"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{2FD2C00D-0DB5-4933-99A1-759E7D0F6A85}", IRungeKutta4thAdapt)
agcls.AgTypeNameMap["IRungeKutta4thAdapt"] = IRungeKutta4thAdapt

class IRungeKuttaF7th8th(object):
    """Properties for the RK7th8th numerical integrator."""
    _uuid = "{05ADCD42-57F9-456E-B29A-AB3AADD9DB1C}"
    _num_methods = 24
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_initial_step"] = _raise_uninitialized_error
        self.__dict__["_set_initial_step"] = _raise_uninitialized_error
        self.__dict__["_get_use_fixed_step"] = _raise_uninitialized_error
        self.__dict__["_set_use_fixed_step"] = _raise_uninitialized_error
        self.__dict__["_get_use_max_step"] = _raise_uninitialized_error
        self.__dict__["_set_use_max_step"] = _raise_uninitialized_error
        self.__dict__["_get_use_min_step"] = _raise_uninitialized_error
        self.__dict__["_set_use_min_step"] = _raise_uninitialized_error
        self.__dict__["_get_max_step"] = _raise_uninitialized_error
        self.__dict__["_set_max_step"] = _raise_uninitialized_error
        self.__dict__["_get_min_step"] = _raise_uninitialized_error
        self.__dict__["_set_min_step"] = _raise_uninitialized_error
        self.__dict__["_get_max_rel_err"] = _raise_uninitialized_error
        self.__dict__["_set_max_rel_err"] = _raise_uninitialized_error
        self.__dict__["_get_max_abs_err"] = _raise_uninitialized_error
        self.__dict__["_set_max_abs_err"] = _raise_uninitialized_error
        self.__dict__["_get_high_safety_coefficient"] = _raise_uninitialized_error
        self.__dict__["_set_high_safety_coefficient"] = _raise_uninitialized_error
        self.__dict__["_get_low_safety_coefficient"] = _raise_uninitialized_error
        self.__dict__["_set_low_safety_coefficient"] = _raise_uninitialized_error
        self.__dict__["_get_error_control"] = _raise_uninitialized_error
        self.__dict__["_set_error_control"] = _raise_uninitialized_error
        self.__dict__["_get_max_iterations"] = _raise_uninitialized_error
        self.__dict__["_set_max_iterations"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IRungeKuttaF7th8th._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IRungeKuttaF7th8th from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IRungeKuttaF7th8th = agcom.GUID(IRungeKuttaF7th8th._uuid)
        vtable_offset_local = IRungeKuttaF7th8th._vtable_offset - 1
        self.__dict__["_get_initial_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaF7th8th, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_initial_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaF7th8th, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_use_fixed_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaF7th8th, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_fixed_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaF7th8th, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_get_use_max_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaF7th8th, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_max_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaF7th8th, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_get_use_min_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaF7th8th, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_min_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaF7th8th, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_get_max_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaF7th8th, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaF7th8th, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_min_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaF7th8th, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_min_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaF7th8th, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_max_rel_err"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaF7th8th, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_rel_err"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaF7th8th, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_max_abs_err"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaF7th8th, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_abs_err"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaF7th8th, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_high_safety_coefficient"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaF7th8th, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_high_safety_coefficient"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaF7th8th, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_low_safety_coefficient"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaF7th8th, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_set_low_safety_coefficient"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaF7th8th, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_get_error_control"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaF7th8th, vtable_offset_local+21, POINTER(agcom.LONG))
        self.__dict__["_set_error_control"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaF7th8th, vtable_offset_local+22, agcom.LONG)
        self.__dict__["_get_max_iterations"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaF7th8th, vtable_offset_local+23, POINTER(agcom.LONG))
        self.__dict__["_set_max_iterations"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaF7th8th, vtable_offset_local+24, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRungeKuttaF7th8th.__dict__ and type(IRungeKuttaF7th8th.__dict__[attrname]) == property:
            return IRungeKuttaF7th8th.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRungeKuttaF7th8th.")
    
    @property
    def initial_step(self) -> float:
        """The initial step. Uses time dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_initial_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @initial_step.setter
    def initial_step(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_initial_step"](arg_inVal.COM_val))

    @property
    def use_fixed_step(self) -> bool:
        """True if running in fixed-step mode."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_fixed_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_fixed_step.setter
    def use_fixed_step(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_fixed_step"](arg_inVal.COM_val))

    @property
    def use_max_step(self) -> bool:
        """Whether or not to enforce the maximum step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_max_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_max_step.setter
    def use_max_step(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_max_step"](arg_inVal.COM_val))

    @property
    def use_min_step(self) -> bool:
        """Whether or not to enforce the minimum step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_min_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_min_step.setter
    def use_min_step(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_min_step"](arg_inVal.COM_val))

    @property
    def max_step(self) -> float:
        """The maximum step size to allow (absolute value). Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_step.setter
    def max_step(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_step"](arg_inVal.COM_val))

    @property
    def min_step(self) -> float:
        """The minimum step size to allow (absolute value). Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @min_step.setter
    def min_step(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_min_step"](arg_inVal.COM_val))

    @property
    def max_rel_err(self) -> float:
        """The maximum relative error used to control step size. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_rel_err"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_rel_err.setter
    def max_rel_err(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_rel_err"](arg_inVal.COM_val))

    @property
    def max_abs_err(self) -> float:
        """The maximum absolute error; Also used if relative scale is too small. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_abs_err"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_abs_err.setter
    def max_abs_err(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_abs_err"](arg_inVal.COM_val))

    @property
    def high_safety_coefficient(self) -> float:
        """The 'safety' coefficient used to decrease step size if the error is too high. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_high_safety_coefficient"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @high_safety_coefficient.setter
    def high_safety_coefficient(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_high_safety_coefficient"](arg_inVal.COM_val))

    @property
    def low_safety_coefficient(self) -> float:
        """The 'safety' coefficient used to increase step size if the error is too low. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_low_safety_coefficient"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @low_safety_coefficient.setter
    def low_safety_coefficient(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_low_safety_coefficient"](arg_inVal.COM_val))

    @property
    def error_control(self) -> "AgEVAErrorControl":
        """The error control method."""
        with agmarshall.AgEnum_arg(AgEVAErrorControl) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_error_control"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @error_control.setter
    def error_control(self, inVal:"AgEVAErrorControl") -> None:
        with agmarshall.AgEnum_arg(AgEVAErrorControl, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_error_control"](arg_inVal.COM_val))

    @property
    def max_iterations(self) -> int:
        """The maximum iterations. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_iterations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_iterations.setter
    def max_iterations(self, inVal:int) -> None:
        with agmarshall.LONG_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_iterations"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{05ADCD42-57F9-456E-B29A-AB3AADD9DB1C}", IRungeKuttaF7th8th)
agcls.AgTypeNameMap["IRungeKuttaF7th8th"] = IRungeKuttaF7th8th

class IRungeKuttaV8th9th(object):
    """Properties for the RK8th9th numerical integrator."""
    _uuid = "{E4CEAA67-BE78-472F-B746-52878835E818}"
    _num_methods = 26
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    def __init__(self, sourceObject=None):
        self.__dict__["_pUnk"] = None
        self.__dict__["_get_initial_step"] = _raise_uninitialized_error
        self.__dict__["_set_initial_step"] = _raise_uninitialized_error
        self.__dict__["_get_use_fixed_step"] = _raise_uninitialized_error
        self.__dict__["_set_use_fixed_step"] = _raise_uninitialized_error
        self.__dict__["_get_use_max_step"] = _raise_uninitialized_error
        self.__dict__["_set_use_max_step"] = _raise_uninitialized_error
        self.__dict__["_get_use_min_step"] = _raise_uninitialized_error
        self.__dict__["_set_use_min_step"] = _raise_uninitialized_error
        self.__dict__["_get_max_step"] = _raise_uninitialized_error
        self.__dict__["_set_max_step"] = _raise_uninitialized_error
        self.__dict__["_get_min_step"] = _raise_uninitialized_error
        self.__dict__["_set_min_step"] = _raise_uninitialized_error
        self.__dict__["_get_max_rel_err"] = _raise_uninitialized_error
        self.__dict__["_set_max_rel_err"] = _raise_uninitialized_error
        self.__dict__["_get_max_abs_err"] = _raise_uninitialized_error
        self.__dict__["_set_max_abs_err"] = _raise_uninitialized_error
        self.__dict__["_get_high_safety_coefficient"] = _raise_uninitialized_error
        self.__dict__["_set_high_safety_coefficient"] = _raise_uninitialized_error
        self.__dict__["_get_low_safety_coefficient"] = _raise_uninitialized_error
        self.__dict__["_set_low_safety_coefficient"] = _raise_uninitialized_error
        self.__dict__["_get_error_control"] = _raise_uninitialized_error
        self.__dict__["_set_error_control"] = _raise_uninitialized_error
        self.__dict__["_get_max_iterations"] = _raise_uninitialized_error
        self.__dict__["_set_max_iterations"] = _raise_uninitialized_error
        self.__dict__["_get_coeff_type"] = _raise_uninitialized_error
        self.__dict__["_set_coeff_type"] = _raise_uninitialized_error
        if sourceObject is not None and sourceObject.__dict__["_pUnk"] is not None:
            pUnk = sourceObject.__dict__["_pUnk"].QueryInterface(agcom.GUID(IRungeKuttaV8th9th._uuid))
            if pUnk is not None:
                self._private_init(pUnk)
                del(pUnk)
            else:
                raise STKInvalidCastError("Failed to create IRungeKuttaV8th9th from source object.")
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IID_IRungeKuttaV8th9th = agcom.GUID(IRungeKuttaV8th9th._uuid)
        vtable_offset_local = IRungeKuttaV8th9th._vtable_offset - 1
        self.__dict__["_get_initial_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaV8th9th, vtable_offset_local+1, POINTER(agcom.DOUBLE))
        self.__dict__["_set_initial_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaV8th9th, vtable_offset_local+2, agcom.DOUBLE)
        self.__dict__["_get_use_fixed_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaV8th9th, vtable_offset_local+3, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_fixed_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaV8th9th, vtable_offset_local+4, agcom.VARIANT_BOOL)
        self.__dict__["_get_use_max_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaV8th9th, vtable_offset_local+5, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_max_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaV8th9th, vtable_offset_local+6, agcom.VARIANT_BOOL)
        self.__dict__["_get_use_min_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaV8th9th, vtable_offset_local+7, POINTER(agcom.VARIANT_BOOL))
        self.__dict__["_set_use_min_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaV8th9th, vtable_offset_local+8, agcom.VARIANT_BOOL)
        self.__dict__["_get_max_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaV8th9th, vtable_offset_local+9, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaV8th9th, vtable_offset_local+10, agcom.DOUBLE)
        self.__dict__["_get_min_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaV8th9th, vtable_offset_local+11, POINTER(agcom.DOUBLE))
        self.__dict__["_set_min_step"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaV8th9th, vtable_offset_local+12, agcom.DOUBLE)
        self.__dict__["_get_max_rel_err"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaV8th9th, vtable_offset_local+13, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_rel_err"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaV8th9th, vtable_offset_local+14, agcom.DOUBLE)
        self.__dict__["_get_max_abs_err"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaV8th9th, vtable_offset_local+15, POINTER(agcom.DOUBLE))
        self.__dict__["_set_max_abs_err"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaV8th9th, vtable_offset_local+16, agcom.DOUBLE)
        self.__dict__["_get_high_safety_coefficient"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaV8th9th, vtable_offset_local+17, POINTER(agcom.DOUBLE))
        self.__dict__["_set_high_safety_coefficient"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaV8th9th, vtable_offset_local+18, agcom.DOUBLE)
        self.__dict__["_get_low_safety_coefficient"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaV8th9th, vtable_offset_local+19, POINTER(agcom.DOUBLE))
        self.__dict__["_set_low_safety_coefficient"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaV8th9th, vtable_offset_local+20, agcom.DOUBLE)
        self.__dict__["_get_error_control"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaV8th9th, vtable_offset_local+21, POINTER(agcom.LONG))
        self.__dict__["_set_error_control"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaV8th9th, vtable_offset_local+22, agcom.LONG)
        self.__dict__["_get_max_iterations"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaV8th9th, vtable_offset_local+23, POINTER(agcom.LONG))
        self.__dict__["_set_max_iterations"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaV8th9th, vtable_offset_local+24, agcom.LONG)
        self.__dict__["_get_coeff_type"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaV8th9th, vtable_offset_local+25, POINTER(agcom.LONG))
        self.__dict__["_set_coeff_type"] = IAGFUNCTYPE(pUnk, IID_IRungeKuttaV8th9th, vtable_offset_local+26, agcom.LONG)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        if attrname in IRungeKuttaV8th9th.__dict__ and type(IRungeKuttaV8th9th.__dict__[attrname]) == property:
            return IRungeKuttaV8th9th.__dict__[attrname]
        return None
    def __setattr__(self, attrname, value):
        if self._get_property(attrname) is not None:
            self._get_property(attrname).__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IRungeKuttaV8th9th.")
    
    @property
    def initial_step(self) -> float:
        """The initial step. Uses time dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_initial_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @initial_step.setter
    def initial_step(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_initial_step"](arg_inVal.COM_val))

    @property
    def use_fixed_step(self) -> bool:
        """True if running in fixed-step mode."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_fixed_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_fixed_step.setter
    def use_fixed_step(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_fixed_step"](arg_inVal.COM_val))

    @property
    def use_max_step(self) -> bool:
        """Whether or not to enforce the maximum step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_max_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_max_step.setter
    def use_max_step(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_max_step"](arg_inVal.COM_val))

    @property
    def use_min_step(self) -> bool:
        """Whether or not to enforce the minimum step."""
        with agmarshall.VARIANT_BOOL_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_use_min_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @use_min_step.setter
    def use_min_step(self, inVal:bool) -> None:
        with agmarshall.VARIANT_BOOL_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_use_min_step"](arg_inVal.COM_val))

    @property
    def max_step(self) -> float:
        """The maximum step size to allow (absolute value). Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_step.setter
    def max_step(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_step"](arg_inVal.COM_val))

    @property
    def min_step(self) -> float:
        """The minimum step size to allow (absolute value). Uses Time Dimension."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_min_step"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @min_step.setter
    def min_step(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_min_step"](arg_inVal.COM_val))

    @property
    def max_rel_err(self) -> float:
        """The maximum relative error used to control step size. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_rel_err"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_rel_err.setter
    def max_rel_err(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_rel_err"](arg_inVal.COM_val))

    @property
    def max_abs_err(self) -> float:
        """The maximum absolute error; Also used if relative scale is too small. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_abs_err"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_abs_err.setter
    def max_abs_err(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_abs_err"](arg_inVal.COM_val))

    @property
    def high_safety_coefficient(self) -> float:
        """The 'safety' coefficient used to decrease step size if the error is too high. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_high_safety_coefficient"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @high_safety_coefficient.setter
    def high_safety_coefficient(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_high_safety_coefficient"](arg_inVal.COM_val))

    @property
    def low_safety_coefficient(self) -> float:
        """The 'safety' coefficient used to increase step size if the error is too low. Dimensionless."""
        with agmarshall.DOUBLE_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_low_safety_coefficient"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @low_safety_coefficient.setter
    def low_safety_coefficient(self, inVal:float) -> None:
        with agmarshall.DOUBLE_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_low_safety_coefficient"](arg_inVal.COM_val))

    @property
    def error_control(self) -> "AgEVAErrorControl":
        """The error control method."""
        with agmarshall.AgEnum_arg(AgEVAErrorControl) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_error_control"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @error_control.setter
    def error_control(self, inVal:"AgEVAErrorControl") -> None:
        with agmarshall.AgEnum_arg(AgEVAErrorControl, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_error_control"](arg_inVal.COM_val))

    @property
    def max_iterations(self) -> int:
        """The maximum iterations. Dimensionless."""
        with agmarshall.LONG_arg() as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_max_iterations"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @max_iterations.setter
    def max_iterations(self, inVal:int) -> None:
        with agmarshall.LONG_arg(inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_max_iterations"](arg_inVal.COM_val))

    @property
    def coeff_type(self) -> "AgEVACoeffRKV8th9th":
        """The set of coefficients to use."""
        with agmarshall.AgEnum_arg(AgEVACoeffRKV8th9th) as arg_pVal:
            agcls.evaluate_hresult(self.__dict__["_get_coeff_type"](byref(arg_pVal.COM_val)))
            return arg_pVal.python_val

    @coeff_type.setter
    def coeff_type(self, inVal:"AgEVACoeffRKV8th9th") -> None:
        with agmarshall.AgEnum_arg(AgEVACoeffRKV8th9th, inVal) as arg_inVal:
            agcls.evaluate_hresult(self.__dict__["_set_coeff_type"](arg_inVal.COM_val))


agcls.AgClassCatalog.add_catalog_entry("{E4CEAA67-BE78-472F-B746-52878835E818}", IRungeKuttaV8th9th)
agcls.AgTypeNameMap["IRungeKuttaV8th9th"] = IRungeKuttaV8th9th



class DriverMissionControlSequence(IDriverMissionControlSequence, IVehiclePropagator):
    """Basic properties of an Astrogator satellite."""
    def __init__(self, sourceObject=None):
        IDriverMissionControlSequence.__init__(self, sourceObject)
        IVehiclePropagator.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IDriverMissionControlSequence._private_init(self, pUnk)
        IVehiclePropagator._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IDriverMissionControlSequence._get_property(self, attrname) is not None: found_prop = IDriverMissionControlSequence._get_property(self, attrname)
        if IVehiclePropagator._get_property(self, attrname) is not None: found_prop = IVehiclePropagator._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in DriverMissionControlSequence.")
        
agcls.AgClassCatalog.add_catalog_entry("{56D84C70-9D0D-4ACA-8CE5-C41E951E024C}", DriverMissionControlSequence)


class MissionControlSequenceSegmentCollection(IMissionControlSequenceSegmentCollection, IRuntimeTypeInfoProvider):
    """The Mission Control Sequence."""
    def __init__(self, sourceObject=None):
        IMissionControlSequenceSegmentCollection.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMissionControlSequenceSegmentCollection._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissionControlSequenceSegmentCollection._get_property(self, attrname) is not None: found_prop = IMissionControlSequenceSegmentCollection._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissionControlSequenceSegmentCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{B2F91182-1E74-4422-A660-6250A42732C3}", MissionControlSequenceSegmentCollection)


class MissionControlSequenceEnd(IMissionControlSequenceEnd, IMissionControlSequenceSegment, IRuntimeTypeInfoProvider, IComponentInfo):
    """The End segment."""
    def __init__(self, sourceObject=None):
        IMissionControlSequenceEnd.__init__(self, sourceObject)
        IMissionControlSequenceSegment.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMissionControlSequenceEnd._private_init(self, pUnk)
        IMissionControlSequenceSegment._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissionControlSequenceEnd._get_property(self, attrname) is not None: found_prop = IMissionControlSequenceEnd._get_property(self, attrname)
        if IMissionControlSequenceSegment._get_property(self, attrname) is not None: found_prop = IMissionControlSequenceSegment._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissionControlSequenceEnd.")
        
agcls.AgClassCatalog.add_catalog_entry("{048FE652-88E7-4000-B371-A2D708599F34}", MissionControlSequenceEnd)


class MissionControlSequenceInitialState(IMissionControlSequenceInitialState, IMissionControlSequenceSegment, IRuntimeTypeInfoProvider, IComponentInfo, ICloneable):
    """The Initial State segment."""
    def __init__(self, sourceObject=None):
        IMissionControlSequenceInitialState.__init__(self, sourceObject)
        IMissionControlSequenceSegment.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMissionControlSequenceInitialState._private_init(self, pUnk)
        IMissionControlSequenceSegment._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissionControlSequenceInitialState._get_property(self, attrname) is not None: found_prop = IMissionControlSequenceInitialState._get_property(self, attrname)
        if IMissionControlSequenceSegment._get_property(self, attrname) is not None: found_prop = IMissionControlSequenceSegment._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissionControlSequenceInitialState.")
        
agcls.AgClassCatalog.add_catalog_entry("{E3010ADE-CB96-470C-B380-3C58B23173AC}", MissionControlSequenceInitialState)


class SpacecraftParameters(ISpacecraftParameters, IRuntimeTypeInfoProvider):
    """Spacecraft parameters."""
    def __init__(self, sourceObject=None):
        ISpacecraftParameters.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISpacecraftParameters._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISpacecraftParameters._get_property(self, attrname) is not None: found_prop = ISpacecraftParameters._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SpacecraftParameters.")
        
agcls.AgClassCatalog.add_catalog_entry("{75F1E929-B0B9-4AE8-8C84-7273B9211771}", SpacecraftParameters)


class FuelTank(IFuelTank, IRuntimeTypeInfoProvider):
    """Fuel Tank parameters."""
    def __init__(self, sourceObject=None):
        IFuelTank.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IFuelTank._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IFuelTank._get_property(self, attrname) is not None: found_prop = IFuelTank._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in FuelTank.")
        
agcls.AgClassCatalog.add_catalog_entry("{03CC0FE4-A9E2-4F80-8AC8-C510F9691D3B}", FuelTank)


class ElementCartesian(IElementCartesian, IElement, IRuntimeTypeInfoProvider):
    """Cartesian elements."""
    def __init__(self, sourceObject=None):
        IElementCartesian.__init__(self, sourceObject)
        IElement.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IElementCartesian._private_init(self, pUnk)
        IElement._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IElementCartesian._get_property(self, attrname) is not None: found_prop = IElementCartesian._get_property(self, attrname)
        if IElement._get_property(self, attrname) is not None: found_prop = IElement._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ElementCartesian.")
        
agcls.AgClassCatalog.add_catalog_entry("{8C98158E-6B98-4C50-8500-7ABCE96A049E}", ElementCartesian)


class ElementKeplerian(IElementKeplerian, IElement):
    """Keplerian elements."""
    def __init__(self, sourceObject=None):
        IElementKeplerian.__init__(self, sourceObject)
        IElement.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IElementKeplerian._private_init(self, pUnk)
        IElement._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IElementKeplerian._get_property(self, attrname) is not None: found_prop = IElementKeplerian._get_property(self, attrname)
        if IElement._get_property(self, attrname) is not None: found_prop = IElement._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ElementKeplerian.")
        
agcls.AgClassCatalog.add_catalog_entry("{F34624C5-E351-4321-B16E-04DB098F9E29}", ElementKeplerian)


class ElementEquinoctial(IElementEquinoctial, IElement):
    """Equinoctial elements."""
    def __init__(self, sourceObject=None):
        IElementEquinoctial.__init__(self, sourceObject)
        IElement.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IElementEquinoctial._private_init(self, pUnk)
        IElement._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IElementEquinoctial._get_property(self, attrname) is not None: found_prop = IElementEquinoctial._get_property(self, attrname)
        if IElement._get_property(self, attrname) is not None: found_prop = IElement._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ElementEquinoctial.")
        
agcls.AgClassCatalog.add_catalog_entry("{5588137F-A05E-4011-A219-925F175F1447}", ElementEquinoctial)


class ElementDelaunay(IElementDelaunay, IElement):
    """Delaunay elements."""
    def __init__(self, sourceObject=None):
        IElementDelaunay.__init__(self, sourceObject)
        IElement.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IElementDelaunay._private_init(self, pUnk)
        IElement._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IElementDelaunay._get_property(self, attrname) is not None: found_prop = IElementDelaunay._get_property(self, attrname)
        if IElement._get_property(self, attrname) is not None: found_prop = IElement._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ElementDelaunay.")
        
agcls.AgClassCatalog.add_catalog_entry("{FDE891B2-2C91-48A8-B4C0-956BD55B8496}", ElementDelaunay)


class ElementMixedSpherical(IElementMixedSpherical, IElement):
    """Mixed Spherical elements."""
    def __init__(self, sourceObject=None):
        IElementMixedSpherical.__init__(self, sourceObject)
        IElement.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IElementMixedSpherical._private_init(self, pUnk)
        IElement._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IElementMixedSpherical._get_property(self, attrname) is not None: found_prop = IElementMixedSpherical._get_property(self, attrname)
        if IElement._get_property(self, attrname) is not None: found_prop = IElement._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ElementMixedSpherical.")
        
agcls.AgClassCatalog.add_catalog_entry("{C6E11D55-8708-4667-AC84-8FC413A32FF0}", ElementMixedSpherical)


class ElementSpherical(IElementSpherical, IElement):
    """Spherical elements."""
    def __init__(self, sourceObject=None):
        IElementSpherical.__init__(self, sourceObject)
        IElement.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IElementSpherical._private_init(self, pUnk)
        IElement._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IElementSpherical._get_property(self, attrname) is not None: found_prop = IElementSpherical._get_property(self, attrname)
        if IElement._get_property(self, attrname) is not None: found_prop = IElement._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ElementSpherical.")
        
agcls.AgClassCatalog.add_catalog_entry("{ECF59D66-A748-47DD-BD0E-C8FD0CD78D05}", ElementSpherical)


class ElementTargetVectorIncomingAsymptote(IElementTargetVectorIncomingAsymptote, IElement):
    """Target Vector Incoming Asymptote elements."""
    def __init__(self, sourceObject=None):
        IElementTargetVectorIncomingAsymptote.__init__(self, sourceObject)
        IElement.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IElementTargetVectorIncomingAsymptote._private_init(self, pUnk)
        IElement._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IElementTargetVectorIncomingAsymptote._get_property(self, attrname) is not None: found_prop = IElementTargetVectorIncomingAsymptote._get_property(self, attrname)
        if IElement._get_property(self, attrname) is not None: found_prop = IElement._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ElementTargetVectorIncomingAsymptote.")
        
agcls.AgClassCatalog.add_catalog_entry("{E05BEA68-902F-427F-9E65-A33FBE044A75}", ElementTargetVectorIncomingAsymptote)


class ElementTargetVectorOutgoingAsymptote(IElementTargetVectorOutgoingAsymptote, IElement):
    """Target Vector Outgoing Asymptote elements."""
    def __init__(self, sourceObject=None):
        IElementTargetVectorOutgoingAsymptote.__init__(self, sourceObject)
        IElement.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IElementTargetVectorOutgoingAsymptote._private_init(self, pUnk)
        IElement._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IElementTargetVectorOutgoingAsymptote._get_property(self, attrname) is not None: found_prop = IElementTargetVectorOutgoingAsymptote._get_property(self, attrname)
        if IElement._get_property(self, attrname) is not None: found_prop = IElement._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ElementTargetVectorOutgoingAsymptote.")
        
agcls.AgClassCatalog.add_catalog_entry("{95B24C8E-7781-4FA6-8A70-49443C5FFCF9}", ElementTargetVectorOutgoingAsymptote)


class ElementGeodetic(IElementGeodetic, IElement):
    """Geodetic elements."""
    def __init__(self, sourceObject=None):
        IElementGeodetic.__init__(self, sourceObject)
        IElement.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IElementGeodetic._private_init(self, pUnk)
        IElement._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IElementGeodetic._get_property(self, attrname) is not None: found_prop = IElementGeodetic._get_property(self, attrname)
        if IElement._get_property(self, attrname) is not None: found_prop = IElement._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ElementGeodetic.")
        
agcls.AgClassCatalog.add_catalog_entry("{6E74D006-FB3C-4085-810E-9B1E5AE73905}", ElementGeodetic)


class ElementBPlane(IElementBPlane, IElement):
    """Bplane elements."""
    def __init__(self, sourceObject=None):
        IElementBPlane.__init__(self, sourceObject)
        IElement.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IElementBPlane._private_init(self, pUnk)
        IElement._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IElementBPlane._get_property(self, attrname) is not None: found_prop = IElementBPlane._get_property(self, attrname)
        if IElement._get_property(self, attrname) is not None: found_prop = IElement._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ElementBPlane.")
        
agcls.AgClassCatalog.add_catalog_entry("{3F43BB61-B15A-479A-AE38-567C7FEE6A7B}", ElementBPlane)


class MissionControlSequencePropagate(IMissionControlSequenceSegment, IMissionControlSequencePropagate, IComponentInfo, ICloneable, IRuntimeTypeInfoProvider):
    """The Propagate segment."""
    def __init__(self, sourceObject=None):
        IMissionControlSequenceSegment.__init__(self, sourceObject)
        IMissionControlSequencePropagate.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMissionControlSequenceSegment._private_init(self, pUnk)
        IMissionControlSequencePropagate._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissionControlSequenceSegment._get_property(self, attrname) is not None: found_prop = IMissionControlSequenceSegment._get_property(self, attrname)
        if IMissionControlSequencePropagate._get_property(self, attrname) is not None: found_prop = IMissionControlSequencePropagate._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissionControlSequencePropagate.")
        
agcls.AgClassCatalog.add_catalog_entry("{172B88CD-3CDC-4818-A03E-6538C4FD3B8D}", MissionControlSequencePropagate)


class State(IState, IRuntimeTypeInfoProvider):
    """The orbit state."""
    def __init__(self, sourceObject=None):
        IState.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IState._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IState._get_property(self, attrname) is not None: found_prop = IState._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in State.")
        
agcls.AgClassCatalog.add_catalog_entry("{D09183D5-B72C-428B-B586-CD67D09B7BC1}", State)


class StoppingConditionCollection(IStoppingConditionCollection, IRuntimeTypeInfoProvider):
    """The stopping conditions collection."""
    def __init__(self, sourceObject=None):
        IStoppingConditionCollection.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IStoppingConditionCollection._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IStoppingConditionCollection._get_property(self, attrname) is not None: found_prop = IStoppingConditionCollection._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StoppingConditionCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{9301C787-450F-49B9-B5BD-E263F5DEF4AF}", StoppingConditionCollection)


class AccessStoppingCondition(IComponentInfo, ICloneable, IAccessStoppingCondition, IStoppingConditionComponent, IRuntimeTypeInfoProvider):
    """The Access stopping condition."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IAccessStoppingCondition.__init__(self, sourceObject)
        IStoppingConditionComponent.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IAccessStoppingCondition._private_init(self, pUnk)
        IStoppingConditionComponent._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IAccessStoppingCondition._get_property(self, attrname) is not None: found_prop = IAccessStoppingCondition._get_property(self, attrname)
        if IStoppingConditionComponent._get_property(self, attrname) is not None: found_prop = IStoppingConditionComponent._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AccessStoppingCondition.")
        
agcls.AgClassCatalog.add_catalog_entry("{7526A10E-68CF-42C7-A1B6-DC58E4C83F8B}", AccessStoppingCondition)


class LightingStoppingCondition(IComponentInfo, ICloneable, ILightingStoppingCondition, IStoppingConditionComponent, IRuntimeTypeInfoProvider):
    """The Lighting stopping condition."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        ILightingStoppingCondition.__init__(self, sourceObject)
        IStoppingConditionComponent.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        ILightingStoppingCondition._private_init(self, pUnk)
        IStoppingConditionComponent._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if ILightingStoppingCondition._get_property(self, attrname) is not None: found_prop = ILightingStoppingCondition._get_property(self, attrname)
        if IStoppingConditionComponent._get_property(self, attrname) is not None: found_prop = IStoppingConditionComponent._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in LightingStoppingCondition.")
        
agcls.AgClassCatalog.add_catalog_entry("{9AE4C815-0880-4912-A024-7A326AF7F9BB}", LightingStoppingCondition)


class StoppingCondition(IStoppingCondition, IComponentInfo, ICloneable, IStoppingConditionComponent, IRuntimeTypeInfoProvider):
    """A stopping condition."""
    def __init__(self, sourceObject=None):
        IStoppingCondition.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStoppingConditionComponent.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IStoppingCondition._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStoppingConditionComponent._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IStoppingCondition._get_property(self, attrname) is not None: found_prop = IStoppingCondition._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStoppingConditionComponent._get_property(self, attrname) is not None: found_prop = IStoppingConditionComponent._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StoppingCondition.")
        
agcls.AgClassCatalog.add_catalog_entry("{87FDFED8-E83F-4963-92BD-4F151BE3E5CA}", StoppingCondition)


class StoppingConditionElement(IStoppingConditionElement, IComponentInfo, IRuntimeTypeInfoProvider):
    """A stopping condition."""
    def __init__(self, sourceObject=None):
        IStoppingConditionElement.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IStoppingConditionElement._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IStoppingConditionElement._get_property(self, attrname) is not None: found_prop = IStoppingConditionElement._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StoppingConditionElement.")
        
agcls.AgClassCatalog.add_catalog_entry("{EBE02320-241C-462D-93F5-1BE2B72C8FB5}", StoppingConditionElement)


class MissionControlSequenceSequence(IMissionControlSequenceSegment, IRuntimeTypeInfoProvider, IMissionControlSequenceSequence, IComponentInfo, ICloneable):
    """The Sequence segment."""
    def __init__(self, sourceObject=None):
        IMissionControlSequenceSegment.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
        IMissionControlSequenceSequence.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMissionControlSequenceSegment._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
        IMissionControlSequenceSequence._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissionControlSequenceSegment._get_property(self, attrname) is not None: found_prop = IMissionControlSequenceSegment._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if IMissionControlSequenceSequence._get_property(self, attrname) is not None: found_prop = IMissionControlSequenceSequence._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissionControlSequenceSequence.")
        
agcls.AgClassCatalog.add_catalog_entry("{9D98B9CE-047C-419E-9A58-5939ECD853EF}", MissionControlSequenceSequence)


class MissionControlSequenceBackwardSequence(IMissionControlSequenceSegment, IRuntimeTypeInfoProvider, IMissionControlSequenceBackwardSequence, IMissionControlSequenceSequence, IComponentInfo, ICloneable):
    """The Backward Sequence segment."""
    def __init__(self, sourceObject=None):
        IMissionControlSequenceSegment.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
        IMissionControlSequenceBackwardSequence.__init__(self, sourceObject)
        IMissionControlSequenceSequence.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMissionControlSequenceSegment._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
        IMissionControlSequenceBackwardSequence._private_init(self, pUnk)
        IMissionControlSequenceSequence._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissionControlSequenceSegment._get_property(self, attrname) is not None: found_prop = IMissionControlSequenceSegment._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if IMissionControlSequenceBackwardSequence._get_property(self, attrname) is not None: found_prop = IMissionControlSequenceBackwardSequence._get_property(self, attrname)
        if IMissionControlSequenceSequence._get_property(self, attrname) is not None: found_prop = IMissionControlSequenceSequence._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissionControlSequenceBackwardSequence.")
        
agcls.AgClassCatalog.add_catalog_entry("{EDA33DE4-2AE3-4C19-87A4-2A3215ADB6FE}", MissionControlSequenceBackwardSequence)


class MissionControlSequenceLaunch(IMissionControlSequenceSegment, IRuntimeTypeInfoProvider, IMissionControlSequenceLaunch, IComponentInfo, ICloneable):
    """The Launch segment."""
    def __init__(self, sourceObject=None):
        IMissionControlSequenceSegment.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
        IMissionControlSequenceLaunch.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMissionControlSequenceSegment._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
        IMissionControlSequenceLaunch._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissionControlSequenceSegment._get_property(self, attrname) is not None: found_prop = IMissionControlSequenceSegment._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if IMissionControlSequenceLaunch._get_property(self, attrname) is not None: found_prop = IMissionControlSequenceLaunch._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissionControlSequenceLaunch.")
        
agcls.AgClassCatalog.add_catalog_entry("{1540C136-4AA5-449B-A845-A822E99422E2}", MissionControlSequenceLaunch)


class DisplaySystemGeodetic(IDisplaySystemGeodetic, IDisplaySystem):
    """The geodetic launch location."""
    def __init__(self, sourceObject=None):
        IDisplaySystemGeodetic.__init__(self, sourceObject)
        IDisplaySystem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IDisplaySystemGeodetic._private_init(self, pUnk)
        IDisplaySystem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IDisplaySystemGeodetic._get_property(self, attrname) is not None: found_prop = IDisplaySystemGeodetic._get_property(self, attrname)
        if IDisplaySystem._get_property(self, attrname) is not None: found_prop = IDisplaySystem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in DisplaySystemGeodetic.")
        
agcls.AgClassCatalog.add_catalog_entry("{792B26D7-7643-47F5-8BBD-B4FE0708F3AB}", DisplaySystemGeodetic)


class DisplaySystemGeocentric(IDisplaySystemGeocentric, IDisplaySystem):
    """The geocentric launch location."""
    def __init__(self, sourceObject=None):
        IDisplaySystemGeocentric.__init__(self, sourceObject)
        IDisplaySystem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IDisplaySystemGeocentric._private_init(self, pUnk)
        IDisplaySystem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IDisplaySystemGeocentric._get_property(self, attrname) is not None: found_prop = IDisplaySystemGeocentric._get_property(self, attrname)
        if IDisplaySystem._get_property(self, attrname) is not None: found_prop = IDisplaySystem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in DisplaySystemGeocentric.")
        
agcls.AgClassCatalog.add_catalog_entry("{32F981ED-81EA-4C65-87DF-DC725A979056}", DisplaySystemGeocentric)


class BurnoutGeodetic(IBurnoutGeodetic, IBurnout):
    """The geodetic burnout point."""
    def __init__(self, sourceObject=None):
        IBurnoutGeodetic.__init__(self, sourceObject)
        IBurnout.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBurnoutGeodetic._private_init(self, pUnk)
        IBurnout._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBurnoutGeodetic._get_property(self, attrname) is not None: found_prop = IBurnoutGeodetic._get_property(self, attrname)
        if IBurnout._get_property(self, attrname) is not None: found_prop = IBurnout._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BurnoutGeodetic.")
        
agcls.AgClassCatalog.add_catalog_entry("{011100E5-8DE0-4CE1-BC6D-F66B77814B78}", BurnoutGeodetic)


class BurnoutCBFCartesian(IBurnoutCBFCartesian, IBurnout):
    """The burnout state in CBF Cartesian coordinates."""
    def __init__(self, sourceObject=None):
        IBurnoutCBFCartesian.__init__(self, sourceObject)
        IBurnout.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBurnoutCBFCartesian._private_init(self, pUnk)
        IBurnout._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBurnoutCBFCartesian._get_property(self, attrname) is not None: found_prop = IBurnoutCBFCartesian._get_property(self, attrname)
        if IBurnout._get_property(self, attrname) is not None: found_prop = IBurnout._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BurnoutCBFCartesian.")
        
agcls.AgClassCatalog.add_catalog_entry("{3EE3ED29-6154-49CA-93C4-8623E801B58F}", BurnoutCBFCartesian)


class BurnoutGeocentric(IBurnoutGeocentric, IBurnout):
    """The geocentric burnout point."""
    def __init__(self, sourceObject=None):
        IBurnoutGeocentric.__init__(self, sourceObject)
        IBurnout.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBurnoutGeocentric._private_init(self, pUnk)
        IBurnout._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBurnoutGeocentric._get_property(self, attrname) is not None: found_prop = IBurnoutGeocentric._get_property(self, attrname)
        if IBurnout._get_property(self, attrname) is not None: found_prop = IBurnout._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BurnoutGeocentric.")
        
agcls.AgClassCatalog.add_catalog_entry("{B7BD1F63-9D91-4DA5-9099-D6BE607F2702}", BurnoutGeocentric)


class BurnoutLaunchAzAltitude(IBurnoutLaunchAzAltitude, IBurnout):
    """The launch azimuth and altitude burnout point."""
    def __init__(self, sourceObject=None):
        IBurnoutLaunchAzAltitude.__init__(self, sourceObject)
        IBurnout.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBurnoutLaunchAzAltitude._private_init(self, pUnk)
        IBurnout._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBurnoutLaunchAzAltitude._get_property(self, attrname) is not None: found_prop = IBurnoutLaunchAzAltitude._get_property(self, attrname)
        if IBurnout._get_property(self, attrname) is not None: found_prop = IBurnout._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BurnoutLaunchAzAltitude.")
        
agcls.AgClassCatalog.add_catalog_entry("{E5A780AE-0173-4FF8-AD0F-43886E1FAE85}", BurnoutLaunchAzAltitude)


class BurnoutLaunchAzRadius(IBurnoutLaunchAzRadius, IBurnout):
    """The launch azimuth and radius burnout point."""
    def __init__(self, sourceObject=None):
        IBurnoutLaunchAzRadius.__init__(self, sourceObject)
        IBurnout.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBurnoutLaunchAzRadius._private_init(self, pUnk)
        IBurnout._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBurnoutLaunchAzRadius._get_property(self, attrname) is not None: found_prop = IBurnoutLaunchAzRadius._get_property(self, attrname)
        if IBurnout._get_property(self, attrname) is not None: found_prop = IBurnout._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BurnoutLaunchAzRadius.")
        
agcls.AgClassCatalog.add_catalog_entry("{ABC361CE-B104-427C-BDDB-CF77EBDC9B8E}", BurnoutLaunchAzRadius)


class BurnoutVelocity(IBurnoutVelocity):
    """The burnout velocity."""
    def __init__(self, sourceObject=None):
        IBurnoutVelocity.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBurnoutVelocity._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBurnoutVelocity._get_property(self, attrname) is not None: found_prop = IBurnoutVelocity._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BurnoutVelocity.")
        
agcls.AgClassCatalog.add_catalog_entry("{DFD439A9-42BD-4A59-9681-A70BBC94E083}", BurnoutVelocity)


class MissionControlSequenceFollow(IMissionControlSequenceSegment, IRuntimeTypeInfoProvider, IMissionControlSequenceFollow, IComponentInfo, ICloneable):
    """The Follow segment."""
    def __init__(self, sourceObject=None):
        IMissionControlSequenceSegment.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
        IMissionControlSequenceFollow.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMissionControlSequenceSegment._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
        IMissionControlSequenceFollow._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissionControlSequenceSegment._get_property(self, attrname) is not None: found_prop = IMissionControlSequenceSegment._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if IMissionControlSequenceFollow._get_property(self, attrname) is not None: found_prop = IMissionControlSequenceFollow._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissionControlSequenceFollow.")
        
agcls.AgClassCatalog.add_catalog_entry("{322FC7F6-FCDF-408B-A31C-F25A1F5456EB}", MissionControlSequenceFollow)


class MissionControlSequenceManeuver(IMissionControlSequenceSegment, IRuntimeTypeInfoProvider, IMissionControlSequenceManeuver, IComponentInfo, ICloneable):
    """The Maneuver segment."""
    def __init__(self, sourceObject=None):
        IMissionControlSequenceSegment.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
        IMissionControlSequenceManeuver.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMissionControlSequenceSegment._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
        IMissionControlSequenceManeuver._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissionControlSequenceSegment._get_property(self, attrname) is not None: found_prop = IMissionControlSequenceSegment._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if IMissionControlSequenceManeuver._get_property(self, attrname) is not None: found_prop = IMissionControlSequenceManeuver._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissionControlSequenceManeuver.")
        
agcls.AgClassCatalog.add_catalog_entry("{1EE05100-A5B8-4820-9C6D-F4AE0639E1EE}", MissionControlSequenceManeuver)


class ManeuverFinite(IManeuverFinite, IManeuver, IRuntimeTypeInfoProvider):
    """The Finite Maneuver."""
    def __init__(self, sourceObject=None):
        IManeuverFinite.__init__(self, sourceObject)
        IManeuver.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IManeuverFinite._private_init(self, pUnk)
        IManeuver._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IManeuverFinite._get_property(self, attrname) is not None: found_prop = IManeuverFinite._get_property(self, attrname)
        if IManeuver._get_property(self, attrname) is not None: found_prop = IManeuver._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ManeuverFinite.")
        
agcls.AgClassCatalog.add_catalog_entry("{22EAD08A-6355-48BA-96EC-5DD996A5D926}", ManeuverFinite)


class ManeuverImpulsive(IManeuverImpulsive, IManeuver, IRuntimeTypeInfoProvider):
    """The Impulsive Maneuver."""
    def __init__(self, sourceObject=None):
        IManeuverImpulsive.__init__(self, sourceObject)
        IManeuver.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IManeuverImpulsive._private_init(self, pUnk)
        IManeuver._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IManeuverImpulsive._get_property(self, attrname) is not None: found_prop = IManeuverImpulsive._get_property(self, attrname)
        if IManeuver._get_property(self, attrname) is not None: found_prop = IManeuver._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ManeuverImpulsive.")
        
agcls.AgClassCatalog.add_catalog_entry("{E4DCF8C5-987F-4739-9592-E4C49B9A827E}", ManeuverImpulsive)


class AttitudeControlImpulsiveVelocityVector(IAttitudeControlImpulsiveVelocityVector, IAttitudeControlImpulsive, IAttitudeControl, IRuntimeTypeInfoProvider):
    """The velocity vector attitude control for an impulsive maneuver."""
    def __init__(self, sourceObject=None):
        IAttitudeControlImpulsiveVelocityVector.__init__(self, sourceObject)
        IAttitudeControlImpulsive.__init__(self, sourceObject)
        IAttitudeControl.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAttitudeControlImpulsiveVelocityVector._private_init(self, pUnk)
        IAttitudeControlImpulsive._private_init(self, pUnk)
        IAttitudeControl._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAttitudeControlImpulsiveVelocityVector._get_property(self, attrname) is not None: found_prop = IAttitudeControlImpulsiveVelocityVector._get_property(self, attrname)
        if IAttitudeControlImpulsive._get_property(self, attrname) is not None: found_prop = IAttitudeControlImpulsive._get_property(self, attrname)
        if IAttitudeControl._get_property(self, attrname) is not None: found_prop = IAttitudeControl._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AttitudeControlImpulsiveVelocityVector.")
        
agcls.AgClassCatalog.add_catalog_entry("{C466E73A-E301-43C8-8402-700D0CE8DE41}", AttitudeControlImpulsiveVelocityVector)


class AttitudeControlImpulsiveAntiVelocityVector(IAttitudeControlImpulsiveAntiVelocityVector, IAttitudeControlImpulsive, IAttitudeControl, IRuntimeTypeInfoProvider):
    """The anti-velocity vector attitude control for an impulsive maneuver."""
    def __init__(self, sourceObject=None):
        IAttitudeControlImpulsiveAntiVelocityVector.__init__(self, sourceObject)
        IAttitudeControlImpulsive.__init__(self, sourceObject)
        IAttitudeControl.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAttitudeControlImpulsiveAntiVelocityVector._private_init(self, pUnk)
        IAttitudeControlImpulsive._private_init(self, pUnk)
        IAttitudeControl._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAttitudeControlImpulsiveAntiVelocityVector._get_property(self, attrname) is not None: found_prop = IAttitudeControlImpulsiveAntiVelocityVector._get_property(self, attrname)
        if IAttitudeControlImpulsive._get_property(self, attrname) is not None: found_prop = IAttitudeControlImpulsive._get_property(self, attrname)
        if IAttitudeControl._get_property(self, attrname) is not None: found_prop = IAttitudeControl._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AttitudeControlImpulsiveAntiVelocityVector.")
        
agcls.AgClassCatalog.add_catalog_entry("{B51D8BDC-E2A5-484C-8CB8-88E4D1BBC5A1}", AttitudeControlImpulsiveAntiVelocityVector)


class AttitudeControlImpulsiveAttitude(IAttitudeControlImpulsiveAttitude, IAttitudeControlImpulsive, IAttitudeControl, IRuntimeTypeInfoProvider):
    """The attitude attitude control for an impulsive maneuver."""
    def __init__(self, sourceObject=None):
        IAttitudeControlImpulsiveAttitude.__init__(self, sourceObject)
        IAttitudeControlImpulsive.__init__(self, sourceObject)
        IAttitudeControl.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAttitudeControlImpulsiveAttitude._private_init(self, pUnk)
        IAttitudeControlImpulsive._private_init(self, pUnk)
        IAttitudeControl._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAttitudeControlImpulsiveAttitude._get_property(self, attrname) is not None: found_prop = IAttitudeControlImpulsiveAttitude._get_property(self, attrname)
        if IAttitudeControlImpulsive._get_property(self, attrname) is not None: found_prop = IAttitudeControlImpulsive._get_property(self, attrname)
        if IAttitudeControl._get_property(self, attrname) is not None: found_prop = IAttitudeControl._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AttitudeControlImpulsiveAttitude.")
        
agcls.AgClassCatalog.add_catalog_entry("{8854FD36-7CEA-4FBC-B699-E47007BA7825}", AttitudeControlImpulsiveAttitude)


class AttitudeControlImpulsiveFile(IAttitudeControlImpulsiveFile, IAttitudeControlImpulsive, IAttitudeControl, IRuntimeTypeInfoProvider):
    """The file attitude control for an impulsive maneuver."""
    def __init__(self, sourceObject=None):
        IAttitudeControlImpulsiveFile.__init__(self, sourceObject)
        IAttitudeControlImpulsive.__init__(self, sourceObject)
        IAttitudeControl.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAttitudeControlImpulsiveFile._private_init(self, pUnk)
        IAttitudeControlImpulsive._private_init(self, pUnk)
        IAttitudeControl._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAttitudeControlImpulsiveFile._get_property(self, attrname) is not None: found_prop = IAttitudeControlImpulsiveFile._get_property(self, attrname)
        if IAttitudeControlImpulsive._get_property(self, attrname) is not None: found_prop = IAttitudeControlImpulsive._get_property(self, attrname)
        if IAttitudeControl._get_property(self, attrname) is not None: found_prop = IAttitudeControl._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AttitudeControlImpulsiveFile.")
        
agcls.AgClassCatalog.add_catalog_entry("{18E769AB-177B-4575-A9E0-BBB5BEEA78AE}", AttitudeControlImpulsiveFile)


class AttitudeControlImpulsiveThrustVector(IAttitudeControlImpulsiveThrustVector, IAttitudeControlImpulsive, IAttitudeControl, IRuntimeTypeInfoProvider):
    """The thrust vector attitude control for an impulsive maneuver."""
    def __init__(self, sourceObject=None):
        IAttitudeControlImpulsiveThrustVector.__init__(self, sourceObject)
        IAttitudeControlImpulsive.__init__(self, sourceObject)
        IAttitudeControl.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAttitudeControlImpulsiveThrustVector._private_init(self, pUnk)
        IAttitudeControlImpulsive._private_init(self, pUnk)
        IAttitudeControl._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAttitudeControlImpulsiveThrustVector._get_property(self, attrname) is not None: found_prop = IAttitudeControlImpulsiveThrustVector._get_property(self, attrname)
        if IAttitudeControlImpulsive._get_property(self, attrname) is not None: found_prop = IAttitudeControlImpulsive._get_property(self, attrname)
        if IAttitudeControl._get_property(self, attrname) is not None: found_prop = IAttitudeControl._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AttitudeControlImpulsiveThrustVector.")
        
agcls.AgClassCatalog.add_catalog_entry("{B17F3D0C-2021-4D60-80B7-1F55934FACAF}", AttitudeControlImpulsiveThrustVector)


class AttitudeControlFiniteAntiVelocityVector(IAttitudeControlFiniteAntiVelocityVector, IAttitudeControlFinite, IAttitudeControl, IRuntimeTypeInfoProvider):
    """The anti-velocity vector attitude control for a finite maneuver."""
    def __init__(self, sourceObject=None):
        IAttitudeControlFiniteAntiVelocityVector.__init__(self, sourceObject)
        IAttitudeControlFinite.__init__(self, sourceObject)
        IAttitudeControl.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAttitudeControlFiniteAntiVelocityVector._private_init(self, pUnk)
        IAttitudeControlFinite._private_init(self, pUnk)
        IAttitudeControl._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAttitudeControlFiniteAntiVelocityVector._get_property(self, attrname) is not None: found_prop = IAttitudeControlFiniteAntiVelocityVector._get_property(self, attrname)
        if IAttitudeControlFinite._get_property(self, attrname) is not None: found_prop = IAttitudeControlFinite._get_property(self, attrname)
        if IAttitudeControl._get_property(self, attrname) is not None: found_prop = IAttitudeControl._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AttitudeControlFiniteAntiVelocityVector.")
        
agcls.AgClassCatalog.add_catalog_entry("{2C11B410-A573-446A-9637-A472B987A987}", AttitudeControlFiniteAntiVelocityVector)


class AttitudeControlFiniteAttitude(IAttitudeControlFiniteAttitude, IAttitudeControlFinite, IAttitudeControl, IRuntimeTypeInfoProvider):
    """The attitude attitude control for a finite maneuver."""
    def __init__(self, sourceObject=None):
        IAttitudeControlFiniteAttitude.__init__(self, sourceObject)
        IAttitudeControlFinite.__init__(self, sourceObject)
        IAttitudeControl.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAttitudeControlFiniteAttitude._private_init(self, pUnk)
        IAttitudeControlFinite._private_init(self, pUnk)
        IAttitudeControl._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAttitudeControlFiniteAttitude._get_property(self, attrname) is not None: found_prop = IAttitudeControlFiniteAttitude._get_property(self, attrname)
        if IAttitudeControlFinite._get_property(self, attrname) is not None: found_prop = IAttitudeControlFinite._get_property(self, attrname)
        if IAttitudeControl._get_property(self, attrname) is not None: found_prop = IAttitudeControl._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AttitudeControlFiniteAttitude.")
        
agcls.AgClassCatalog.add_catalog_entry("{EA2C6994-7191-4CEF-9C8D-3BE0AA6BB756}", AttitudeControlFiniteAttitude)


class AttitudeControlFiniteFile(IAttitudeControlFiniteFile, IAttitudeControlFinite, IAttitudeControl, IRuntimeTypeInfoProvider):
    """The file attitude control for a finite maneuver."""
    def __init__(self, sourceObject=None):
        IAttitudeControlFiniteFile.__init__(self, sourceObject)
        IAttitudeControlFinite.__init__(self, sourceObject)
        IAttitudeControl.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAttitudeControlFiniteFile._private_init(self, pUnk)
        IAttitudeControlFinite._private_init(self, pUnk)
        IAttitudeControl._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAttitudeControlFiniteFile._get_property(self, attrname) is not None: found_prop = IAttitudeControlFiniteFile._get_property(self, attrname)
        if IAttitudeControlFinite._get_property(self, attrname) is not None: found_prop = IAttitudeControlFinite._get_property(self, attrname)
        if IAttitudeControl._get_property(self, attrname) is not None: found_prop = IAttitudeControl._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AttitudeControlFiniteFile.")
        
agcls.AgClassCatalog.add_catalog_entry("{7F2333DC-4E2B-499C-9F14-A4F1932F9C62}", AttitudeControlFiniteFile)


class AttitudeControlFiniteThrustVector(IAttitudeControlFiniteThrustVector, IAttitudeControlFinite, IAttitudeControl, IRuntimeTypeInfoProvider):
    """The thrust vector attitude control for a finite maneuver."""
    def __init__(self, sourceObject=None):
        IAttitudeControlFiniteThrustVector.__init__(self, sourceObject)
        IAttitudeControlFinite.__init__(self, sourceObject)
        IAttitudeControl.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAttitudeControlFiniteThrustVector._private_init(self, pUnk)
        IAttitudeControlFinite._private_init(self, pUnk)
        IAttitudeControl._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAttitudeControlFiniteThrustVector._get_property(self, attrname) is not None: found_prop = IAttitudeControlFiniteThrustVector._get_property(self, attrname)
        if IAttitudeControlFinite._get_property(self, attrname) is not None: found_prop = IAttitudeControlFinite._get_property(self, attrname)
        if IAttitudeControl._get_property(self, attrname) is not None: found_prop = IAttitudeControl._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AttitudeControlFiniteThrustVector.")
        
agcls.AgClassCatalog.add_catalog_entry("{9B31C16F-C862-498D-ADFB-5C4F50D45DF1}", AttitudeControlFiniteThrustVector)


class AttitudeControlFiniteTimeVarying(IAttitudeControlFiniteTimeVarying, IAttitudeControlFinite, IAttitudeControl, IRuntimeTypeInfoProvider):
    """The time varying attitude control for a finite maneuver."""
    def __init__(self, sourceObject=None):
        IAttitudeControlFiniteTimeVarying.__init__(self, sourceObject)
        IAttitudeControlFinite.__init__(self, sourceObject)
        IAttitudeControl.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAttitudeControlFiniteTimeVarying._private_init(self, pUnk)
        IAttitudeControlFinite._private_init(self, pUnk)
        IAttitudeControl._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAttitudeControlFiniteTimeVarying._get_property(self, attrname) is not None: found_prop = IAttitudeControlFiniteTimeVarying._get_property(self, attrname)
        if IAttitudeControlFinite._get_property(self, attrname) is not None: found_prop = IAttitudeControlFinite._get_property(self, attrname)
        if IAttitudeControl._get_property(self, attrname) is not None: found_prop = IAttitudeControl._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AttitudeControlFiniteTimeVarying.")
        
agcls.AgClassCatalog.add_catalog_entry("{F28DCCA6-0AFE-4142-BDB1-0957F1B3CB6F}", AttitudeControlFiniteTimeVarying)


class AttitudeControlFiniteVelocityVector(IAttitudeControlFiniteVelocityVector, IAttitudeControlFinite, IAttitudeControl, IRuntimeTypeInfoProvider):
    """The velocity vector attitude control for a finite maneuver."""
    def __init__(self, sourceObject=None):
        IAttitudeControlFiniteVelocityVector.__init__(self, sourceObject)
        IAttitudeControlFinite.__init__(self, sourceObject)
        IAttitudeControl.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAttitudeControlFiniteVelocityVector._private_init(self, pUnk)
        IAttitudeControlFinite._private_init(self, pUnk)
        IAttitudeControl._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAttitudeControlFiniteVelocityVector._get_property(self, attrname) is not None: found_prop = IAttitudeControlFiniteVelocityVector._get_property(self, attrname)
        if IAttitudeControlFinite._get_property(self, attrname) is not None: found_prop = IAttitudeControlFinite._get_property(self, attrname)
        if IAttitudeControl._get_property(self, attrname) is not None: found_prop = IAttitudeControl._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AttitudeControlFiniteVelocityVector.")
        
agcls.AgClassCatalog.add_catalog_entry("{90EE5B69-A270-4A1D-862F-C7A9A532F33F}", AttitudeControlFiniteVelocityVector)


class AttitudeControlFinitePlugin(IAttitudeControlFinitePlugin, IAttitudeControlFinite, IAttitudeControl, IRuntimeTypeInfoProvider):
    """The plugin attitude control for a finite maneuver."""
    def __init__(self, sourceObject=None):
        IAttitudeControlFinitePlugin.__init__(self, sourceObject)
        IAttitudeControlFinite.__init__(self, sourceObject)
        IAttitudeControl.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAttitudeControlFinitePlugin._private_init(self, pUnk)
        IAttitudeControlFinite._private_init(self, pUnk)
        IAttitudeControl._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAttitudeControlFinitePlugin._get_property(self, attrname) is not None: found_prop = IAttitudeControlFinitePlugin._get_property(self, attrname)
        if IAttitudeControlFinite._get_property(self, attrname) is not None: found_prop = IAttitudeControlFinite._get_property(self, attrname)
        if IAttitudeControl._get_property(self, attrname) is not None: found_prop = IAttitudeControl._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AttitudeControlFinitePlugin.")
        
agcls.AgClassCatalog.add_catalog_entry("{41C29436-C581-4FD2-BFFB-090FCDA9C090}", AttitudeControlFinitePlugin)


class AttitudeControlOptimalFiniteLagrange(IAttitudeControlOptimalFiniteLagrange, IAttitudeControlOptimalFinite, IAttitudeControl, IRuntimeTypeInfoProvider):
    """The Lagrange Interpolation attitude control for a optimal finite maneuver."""
    def __init__(self, sourceObject=None):
        IAttitudeControlOptimalFiniteLagrange.__init__(self, sourceObject)
        IAttitudeControlOptimalFinite.__init__(self, sourceObject)
        IAttitudeControl.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAttitudeControlOptimalFiniteLagrange._private_init(self, pUnk)
        IAttitudeControlOptimalFinite._private_init(self, pUnk)
        IAttitudeControl._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAttitudeControlOptimalFiniteLagrange._get_property(self, attrname) is not None: found_prop = IAttitudeControlOptimalFiniteLagrange._get_property(self, attrname)
        if IAttitudeControlOptimalFinite._get_property(self, attrname) is not None: found_prop = IAttitudeControlOptimalFinite._get_property(self, attrname)
        if IAttitudeControl._get_property(self, attrname) is not None: found_prop = IAttitudeControl._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AttitudeControlOptimalFiniteLagrange.")
        
agcls.AgClassCatalog.add_catalog_entry("{AE88E914-B911-41DB-9811-37CFBC7DAECC}", AttitudeControlOptimalFiniteLagrange)


class ManeuverFinitePropagator(IManeuverFinitePropagator, IRuntimeTypeInfoProvider):
    """Propagation for a finite maneuver."""
    def __init__(self, sourceObject=None):
        IManeuverFinitePropagator.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IManeuverFinitePropagator._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IManeuverFinitePropagator._get_property(self, attrname) is not None: found_prop = IManeuverFinitePropagator._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ManeuverFinitePropagator.")
        
agcls.AgClassCatalog.add_catalog_entry("{4F2C7CA9-D775-4CE0-8297-A8806F56F094}", ManeuverFinitePropagator)


class MissionControlSequenceHold(IMissionControlSequenceSegment, IRuntimeTypeInfoProvider, IMissionControlSequenceHold, IComponentInfo, ICloneable):
    """The Hold segment."""
    def __init__(self, sourceObject=None):
        IMissionControlSequenceSegment.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
        IMissionControlSequenceHold.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMissionControlSequenceSegment._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
        IMissionControlSequenceHold._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissionControlSequenceSegment._get_property(self, attrname) is not None: found_prop = IMissionControlSequenceSegment._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if IMissionControlSequenceHold._get_property(self, attrname) is not None: found_prop = IMissionControlSequenceHold._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissionControlSequenceHold.")
        
agcls.AgClassCatalog.add_catalog_entry("{51159257-B7FD-45E5-AB02-7FEB20D924E5}", MissionControlSequenceHold)


class MissionControlSequenceUpdate(IMissionControlSequenceSegment, IRuntimeTypeInfoProvider, IMissionControlSequenceUpdate, IComponentInfo, ICloneable):
    """The Update segment."""
    def __init__(self, sourceObject=None):
        IMissionControlSequenceSegment.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
        IMissionControlSequenceUpdate.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMissionControlSequenceSegment._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
        IMissionControlSequenceUpdate._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissionControlSequenceSegment._get_property(self, attrname) is not None: found_prop = IMissionControlSequenceSegment._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if IMissionControlSequenceUpdate._get_property(self, attrname) is not None: found_prop = IMissionControlSequenceUpdate._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissionControlSequenceUpdate.")
        
agcls.AgClassCatalog.add_catalog_entry("{3A975A07-EB14-4231-B8E7-C977B091D8B0}", MissionControlSequenceUpdate)


class MissionControlSequenceReturn(IMissionControlSequenceSegment, IRuntimeTypeInfoProvider, IMissionControlSequenceReturn, IComponentInfo, ICloneable):
    """The Return segment."""
    def __init__(self, sourceObject=None):
        IMissionControlSequenceSegment.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
        IMissionControlSequenceReturn.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMissionControlSequenceSegment._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
        IMissionControlSequenceReturn._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissionControlSequenceSegment._get_property(self, attrname) is not None: found_prop = IMissionControlSequenceSegment._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if IMissionControlSequenceReturn._get_property(self, attrname) is not None: found_prop = IMissionControlSequenceReturn._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissionControlSequenceReturn.")
        
agcls.AgClassCatalog.add_catalog_entry("{0D4E769A-CBA7-4A17-89BA-F61B59F15D09}", MissionControlSequenceReturn)


class MissionControlSequenceStop(IMissionControlSequenceSegment, IRuntimeTypeInfoProvider, IMissionControlSequenceStop, IComponentInfo, ICloneable):
    """The Stop segment."""
    def __init__(self, sourceObject=None):
        IMissionControlSequenceSegment.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
        IMissionControlSequenceStop.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMissionControlSequenceSegment._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
        IMissionControlSequenceStop._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissionControlSequenceSegment._get_property(self, attrname) is not None: found_prop = IMissionControlSequenceSegment._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if IMissionControlSequenceStop._get_property(self, attrname) is not None: found_prop = IMissionControlSequenceStop._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissionControlSequenceStop.")
        
agcls.AgClassCatalog.add_catalog_entry("{59CF0A59-0E77-4D5F-BE88-E151D8899331}", MissionControlSequenceStop)


class MissionControlSequenceTargetSequence(IMissionControlSequenceSegment, IRuntimeTypeInfoProvider, IMissionControlSequenceTargetSequence, IComponentInfo, ICloneable):
    """The Target Sequence segment."""
    def __init__(self, sourceObject=None):
        IMissionControlSequenceSegment.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
        IMissionControlSequenceTargetSequence.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMissionControlSequenceSegment._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
        IMissionControlSequenceTargetSequence._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissionControlSequenceSegment._get_property(self, attrname) is not None: found_prop = IMissionControlSequenceSegment._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if IMissionControlSequenceTargetSequence._get_property(self, attrname) is not None: found_prop = IMissionControlSequenceTargetSequence._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissionControlSequenceTargetSequence.")
        
agcls.AgClassCatalog.add_catalog_entry("{DF528E2E-3CFD-4935-9A24-B9C9D8C0E727}", MissionControlSequenceTargetSequence)


class ProfileCollection(IProfileCollection, IRuntimeTypeInfoProvider):
    """The Profiles of a Target Sequence."""
    def __init__(self, sourceObject=None):
        IProfileCollection.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProfileCollection._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProfileCollection._get_property(self, attrname) is not None: found_prop = IProfileCollection._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProfileCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{37B58077-200F-4763-8ED2-C4B5AFA97B2E}", ProfileCollection)


class MissionControlSequenceOptions(IMissionControlSequenceOptions):
    """The MCS Options."""
    def __init__(self, sourceObject=None):
        IMissionControlSequenceOptions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMissionControlSequenceOptions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissionControlSequenceOptions._get_property(self, attrname) is not None: found_prop = IMissionControlSequenceOptions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissionControlSequenceOptions.")
        
agcls.AgClassCatalog.add_catalog_entry("{0A469F1B-225A-48E3-9B89-0EC63C95D705}", MissionControlSequenceOptions)


class CalcObjectCollection(ICalcObjectCollection):
    """The Calculation Object component folder."""
    def __init__(self, sourceObject=None):
        ICalcObjectCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalcObjectCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalcObjectCollection._get_property(self, attrname) is not None: found_prop = ICalcObjectCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalcObjectCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{9C6165FC-8537-4B53-AC20-66F2C670A7A9}", CalcObjectCollection)


class ConstraintCollection(IConstraintCollection):
    """The Constraint component folder."""
    def __init__(self, sourceObject=None):
        IConstraintCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IConstraintCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IConstraintCollection._get_property(self, attrname) is not None: found_prop = IConstraintCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ConstraintCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{D992E5D5-AE65-4041-B3A8-DF2244DE2068}", ConstraintCollection)


class PluginProperties(IPluginProperties):
    """The plugin attitude control type."""
    def __init__(self, sourceObject=None):
        IPluginProperties.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPluginProperties._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPluginProperties._get_property(self, attrname) is not None: found_prop = IPluginProperties._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PluginProperties.")
        
agcls.AgClassCatalog.add_catalog_entry("{A115E060-4BB8-430F-AB23-2BBE3C0C2087}", PluginProperties)


class ProfileSearchPlugin(IProfileSearchPlugin, IProfile, IRuntimeTypeInfoProvider):
    """The plugin search profile."""
    def __init__(self, sourceObject=None):
        IProfileSearchPlugin.__init__(self, sourceObject)
        IProfile.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProfileSearchPlugin._private_init(self, pUnk)
        IProfile._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProfileSearchPlugin._get_property(self, attrname) is not None: found_prop = IProfileSearchPlugin._get_property(self, attrname)
        if IProfile._get_property(self, attrname) is not None: found_prop = IProfile._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProfileSearchPlugin.")
        
agcls.AgClassCatalog.add_catalog_entry("{25E94763-B5B1-4964-B563-9AEED96D9D54}", ProfileSearchPlugin)


class TargeterGraph(ITargeterGraph, IRuntimeTypeInfoProvider):
    """Targeter Graph."""
    def __init__(self, sourceObject=None):
        ITargeterGraph.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITargeterGraph._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITargeterGraph._get_property(self, attrname) is not None: found_prop = ITargeterGraph._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TargeterGraph.")
        
agcls.AgClassCatalog.add_catalog_entry("{BF6E6956-1E2A-42E5-A56C-1BEF9EFB8A29}", TargeterGraph)


class TargeterGraphCollection(ITargeterGraphCollection, IRuntimeTypeInfoProvider):
    """Targeter Graphs."""
    def __init__(self, sourceObject=None):
        ITargeterGraphCollection.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITargeterGraphCollection._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITargeterGraphCollection._get_property(self, attrname) is not None: found_prop = ITargeterGraphCollection._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TargeterGraphCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{322FC0D0-8F69-4F4B-9247-2558D6AFF63F}", TargeterGraphCollection)


class TargeterGraphResultCollection(ITargeterGraphResultCollection, IRuntimeTypeInfoProvider):
    """Targeter Graph Result Collection."""
    def __init__(self, sourceObject=None):
        ITargeterGraphResultCollection.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITargeterGraphResultCollection._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITargeterGraphResultCollection._get_property(self, attrname) is not None: found_prop = ITargeterGraphResultCollection._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TargeterGraphResultCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{87090DB9-4866-40E4-BA58-BDF7C8EACCEB}", TargeterGraphResultCollection)


class TargeterGraphActiveControlCollection(ITargeterGraphActiveControlCollection, IRuntimeTypeInfoProvider):
    """Targeter Graph Active Control Collection."""
    def __init__(self, sourceObject=None):
        ITargeterGraphActiveControlCollection.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITargeterGraphActiveControlCollection._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITargeterGraphActiveControlCollection._get_property(self, attrname) is not None: found_prop = ITargeterGraphActiveControlCollection._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TargeterGraphActiveControlCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{7FB70374-2313-463C-A69E-C5111C4BC1E4}", TargeterGraphActiveControlCollection)


class TargeterGraphActiveControl(ITargeterGraphActiveControl, IRuntimeTypeInfoProvider):
    """Targeter Graph Active Control."""
    def __init__(self, sourceObject=None):
        ITargeterGraphActiveControl.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITargeterGraphActiveControl._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITargeterGraphActiveControl._get_property(self, attrname) is not None: found_prop = ITargeterGraphActiveControl._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TargeterGraphActiveControl.")
        
agcls.AgClassCatalog.add_catalog_entry("{E6457FA2-28BF-471B-9DCF-575B27BF588B}", TargeterGraphActiveControl)


class TargeterGraphResult(ITargeterGraphResult, IRuntimeTypeInfoProvider):
    """Targeter Graph Result."""
    def __init__(self, sourceObject=None):
        ITargeterGraphResult.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITargeterGraphResult._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITargeterGraphResult._get_property(self, attrname) is not None: found_prop = ITargeterGraphResult._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TargeterGraphResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{AB6CA723-1634-4A90-AD8C-4DB34D7A2925}", TargeterGraphResult)


class ProfileDifferentialCorrector(IProfileDifferentialCorrector, IProfile, IRuntimeTypeInfoProvider):
    """The Differential Corrector profile."""
    def __init__(self, sourceObject=None):
        IProfileDifferentialCorrector.__init__(self, sourceObject)
        IProfile.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProfileDifferentialCorrector._private_init(self, pUnk)
        IProfile._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProfileDifferentialCorrector._get_property(self, attrname) is not None: found_prop = IProfileDifferentialCorrector._get_property(self, attrname)
        if IProfile._get_property(self, attrname) is not None: found_prop = IProfile._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProfileDifferentialCorrector.")
        
agcls.AgClassCatalog.add_catalog_entry("{4446E46E-A169-4F12-AE14-562D35A6BC60}", ProfileDifferentialCorrector)


class ProfileScriptingTool(IProfileScriptingTool, IProfile, IRuntimeTypeInfoProvider):
    """The Scripting Tool profile."""
    def __init__(self, sourceObject=None):
        IProfileScriptingTool.__init__(self, sourceObject)
        IProfile.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProfileScriptingTool._private_init(self, pUnk)
        IProfile._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProfileScriptingTool._get_property(self, attrname) is not None: found_prop = IProfileScriptingTool._get_property(self, attrname)
        if IProfile._get_property(self, attrname) is not None: found_prop = IProfile._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProfileScriptingTool.")
        
agcls.AgClassCatalog.add_catalog_entry("{EC9D1E6F-4155-4685-AFE9-785DE109564A}", ProfileScriptingTool)


class DifferentialCorrectorControl(IDifferentialCorrectorControl, IRuntimeTypeInfoProvider):
    """Control Parameters for a Target Sequence."""
    def __init__(self, sourceObject=None):
        IDifferentialCorrectorControl.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IDifferentialCorrectorControl._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IDifferentialCorrectorControl._get_property(self, attrname) is not None: found_prop = IDifferentialCorrectorControl._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in DifferentialCorrectorControl.")
        
agcls.AgClassCatalog.add_catalog_entry("{5D59626C-A2D6-4D23-91C8-43D3764115C9}", DifferentialCorrectorControl)


class DifferentialCorrectorResult(IDifferentialCorrectorResult, IRuntimeTypeInfoProvider):
    """Differential Corrector equality constraints."""
    def __init__(self, sourceObject=None):
        IDifferentialCorrectorResult.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IDifferentialCorrectorResult._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IDifferentialCorrectorResult._get_property(self, attrname) is not None: found_prop = IDifferentialCorrectorResult._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in DifferentialCorrectorResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{1F4606B6-6EB5-4349-90AD-E607DBBC6AB5}", DifferentialCorrectorResult)


class DifferentialCorrectorControlCollection(IDifferentialCorrectorControlCollection, IRuntimeTypeInfoProvider):
    """The collection of Control Parameters for a differential corrector profile."""
    def __init__(self, sourceObject=None):
        IDifferentialCorrectorControlCollection.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IDifferentialCorrectorControlCollection._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IDifferentialCorrectorControlCollection._get_property(self, attrname) is not None: found_prop = IDifferentialCorrectorControlCollection._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in DifferentialCorrectorControlCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{61729FE0-729A-461C-8C94-6816EC0F88E8}", DifferentialCorrectorControlCollection)


class DifferentialCorrectorResultCollection(IDifferentialCorrectorResultCollection, IRuntimeTypeInfoProvider):
    """The collection of results for a differential corrector."""
    def __init__(self, sourceObject=None):
        IDifferentialCorrectorResultCollection.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IDifferentialCorrectorResultCollection._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IDifferentialCorrectorResultCollection._get_property(self, attrname) is not None: found_prop = IDifferentialCorrectorResultCollection._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in DifferentialCorrectorResultCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{703FFB61-063E-4B38-AC0A-968903E6E929}", DifferentialCorrectorResultCollection)


class SearchPluginControl(ISearchPluginControl):
    """Control parameters for a plugin search profile."""
    def __init__(self, sourceObject=None):
        ISearchPluginControl.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISearchPluginControl._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISearchPluginControl._get_property(self, attrname) is not None: found_prop = ISearchPluginControl._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SearchPluginControl.")
        
agcls.AgClassCatalog.add_catalog_entry("{C127E67D-2078-4605-BB16-BF4049CBDEF0}", SearchPluginControl)


class SearchPluginControlCollection(ISearchPluginControlCollection):
    """The list of search plugin control parameters"""
    def __init__(self, sourceObject=None):
        ISearchPluginControlCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISearchPluginControlCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISearchPluginControlCollection._get_property(self, attrname) is not None: found_prop = ISearchPluginControlCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SearchPluginControlCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{78A7975A-C0F5-434A-9902-411C3E975F7E}", SearchPluginControlCollection)


class SearchPluginResult(ISearchPluginResult):
    """Equality constraints for a plugin search profile."""
    def __init__(self, sourceObject=None):
        ISearchPluginResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISearchPluginResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISearchPluginResult._get_property(self, attrname) is not None: found_prop = ISearchPluginResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SearchPluginResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{7A3345FE-C088-4CFA-84BE-5E997BB15CF8}", SearchPluginResult)


class SearchPluginResultCollection(ISearchPluginResultCollection):
    """The list of search plugin equality constraints."""
    def __init__(self, sourceObject=None):
        ISearchPluginResultCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISearchPluginResultCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISearchPluginResultCollection._get_property(self, attrname) is not None: found_prop = ISearchPluginResultCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SearchPluginResultCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{8D37CDE6-2358-4419-9297-0032314ACB35}", SearchPluginResultCollection)


class ProfileChangeManeuverType(IProfileChangeManeuverType, IProfile, IRuntimeTypeInfoProvider):
    """The Change Maneuver Type profile."""
    def __init__(self, sourceObject=None):
        IProfileChangeManeuverType.__init__(self, sourceObject)
        IProfile.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProfileChangeManeuverType._private_init(self, pUnk)
        IProfile._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProfileChangeManeuverType._get_property(self, attrname) is not None: found_prop = IProfileChangeManeuverType._get_property(self, attrname)
        if IProfile._get_property(self, attrname) is not None: found_prop = IProfile._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProfileChangeManeuverType.")
        
agcls.AgClassCatalog.add_catalog_entry("{8FCD3010-988A-4C88-A3E8-FB0D991B1DA3}", ProfileChangeManeuverType)


class ProfileChangeReturnSegment(IProfileChangeReturnSegment, IProfile, IRuntimeTypeInfoProvider):
    """The Change Return Segment profile."""
    def __init__(self, sourceObject=None):
        IProfileChangeReturnSegment.__init__(self, sourceObject)
        IProfile.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProfileChangeReturnSegment._private_init(self, pUnk)
        IProfile._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProfileChangeReturnSegment._get_property(self, attrname) is not None: found_prop = IProfileChangeReturnSegment._get_property(self, attrname)
        if IProfile._get_property(self, attrname) is not None: found_prop = IProfile._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProfileChangeReturnSegment.")
        
agcls.AgClassCatalog.add_catalog_entry("{D7436885-84AD-41DE-9D0F-7A6F001A863B}", ProfileChangeReturnSegment)


class ProfileChangePropagator(IProfileChangePropagator, IProfile, IRuntimeTypeInfoProvider):
    """The Change Propagator profile."""
    def __init__(self, sourceObject=None):
        IProfileChangePropagator.__init__(self, sourceObject)
        IProfile.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProfileChangePropagator._private_init(self, pUnk)
        IProfile._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProfileChangePropagator._get_property(self, attrname) is not None: found_prop = IProfileChangePropagator._get_property(self, attrname)
        if IProfile._get_property(self, attrname) is not None: found_prop = IProfile._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProfileChangePropagator.")
        
agcls.AgClassCatalog.add_catalog_entry("{3EB69307-370B-443E-AB4F-1463A80142CD}", ProfileChangePropagator)


class ProfileChangeStopSegment(IProfileChangeStopSegment, IProfile, IRuntimeTypeInfoProvider):
    """The Change Stop Segment profile."""
    def __init__(self, sourceObject=None):
        IProfileChangeStopSegment.__init__(self, sourceObject)
        IProfile.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProfileChangeStopSegment._private_init(self, pUnk)
        IProfile._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProfileChangeStopSegment._get_property(self, attrname) is not None: found_prop = IProfileChangeStopSegment._get_property(self, attrname)
        if IProfile._get_property(self, attrname) is not None: found_prop = IProfile._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProfileChangeStopSegment.")
        
agcls.AgClassCatalog.add_catalog_entry("{73CD0F57-2A67-47D7-BFAD-4E07D5045AB1}", ProfileChangeStopSegment)


class ProfileChangeStoppingConditionState(IProfileChangeStoppingConditionState, IProfile, IRuntimeTypeInfoProvider):
    """The Change Stopping Condition State profile."""
    def __init__(self, sourceObject=None):
        IProfileChangeStoppingConditionState.__init__(self, sourceObject)
        IProfile.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProfileChangeStoppingConditionState._private_init(self, pUnk)
        IProfile._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProfileChangeStoppingConditionState._get_property(self, attrname) is not None: found_prop = IProfileChangeStoppingConditionState._get_property(self, attrname)
        if IProfile._get_property(self, attrname) is not None: found_prop = IProfile._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProfileChangeStoppingConditionState.")
        
agcls.AgClassCatalog.add_catalog_entry("{593BF97D-DA25-40EC-832A-2514939CCCCB}", ProfileChangeStoppingConditionState)


class ProfileSeedFiniteManeuver(IProfileSeedFiniteManeuver, IProfile, IRuntimeTypeInfoProvider):
    """The Seed Finite Maneuver profile."""
    def __init__(self, sourceObject=None):
        IProfileSeedFiniteManeuver.__init__(self, sourceObject)
        IProfile.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProfileSeedFiniteManeuver._private_init(self, pUnk)
        IProfile._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProfileSeedFiniteManeuver._get_property(self, attrname) is not None: found_prop = IProfileSeedFiniteManeuver._get_property(self, attrname)
        if IProfile._get_property(self, attrname) is not None: found_prop = IProfile._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProfileSeedFiniteManeuver.")
        
agcls.AgClassCatalog.add_catalog_entry("{4524367A-A29D-401A-8B98-82FB06E4D2B3}", ProfileSeedFiniteManeuver)


class ProfileRunOnce(IProfileRunOnce, IProfile, IRuntimeTypeInfoProvider):
    """The Run Once profile."""
    def __init__(self, sourceObject=None):
        IProfileRunOnce.__init__(self, sourceObject)
        IProfile.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProfileRunOnce._private_init(self, pUnk)
        IProfile._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProfileRunOnce._get_property(self, attrname) is not None: found_prop = IProfileRunOnce._get_property(self, attrname)
        if IProfile._get_property(self, attrname) is not None: found_prop = IProfile._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProfileRunOnce.")
        
agcls.AgClassCatalog.add_catalog_entry("{6B7DC440-DAE4-4F68-BD3A-D431EF7460B4}", ProfileRunOnce)


class BPlaneCollection(IBPlaneCollection):
    """The collection of B-Planes."""
    def __init__(self, sourceObject=None):
        IBPlaneCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBPlaneCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBPlaneCollection._get_property(self, attrname) is not None: found_prop = IBPlaneCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BPlaneCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{4A33E12D-FC24-46EB-8AD4-752E5534168D}", BPlaneCollection)


class StateCalcDamageFlux(IStateCalcDamageFlux, IComponentInfo, ICloneable):
    """CoClass StateCalcDamageFlux."""
    def __init__(self, sourceObject=None):
        IStateCalcDamageFlux.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IStateCalcDamageFlux._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IStateCalcDamageFlux._get_property(self, attrname) is not None: found_prop = IStateCalcDamageFlux._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcDamageFlux.")
        
agcls.AgClassCatalog.add_catalog_entry("{EFD8FBFA-6ACF-463D-9857-7C272440314F}", StateCalcDamageFlux)


class StateCalcDamageMassFlux(IStateCalcDamageMassFlux, IComponentInfo, ICloneable):
    """CoClass StateCalcDamageMassFlux."""
    def __init__(self, sourceObject=None):
        IStateCalcDamageMassFlux.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IStateCalcDamageMassFlux._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IStateCalcDamageMassFlux._get_property(self, attrname) is not None: found_prop = IStateCalcDamageMassFlux._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcDamageMassFlux.")
        
agcls.AgClassCatalog.add_catalog_entry("{05A46EDD-2B3D-4505-BD42-DB7516899060}", StateCalcDamageMassFlux)


class StateCalcMagnitudeFieldDipoleL(IStateCalcMagnitudeFieldDipoleL, IComponentInfo, ICloneable):
    """CoClass StateCalcMagFieldDipoleL."""
    def __init__(self, sourceObject=None):
        IStateCalcMagnitudeFieldDipoleL.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IStateCalcMagnitudeFieldDipoleL._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IStateCalcMagnitudeFieldDipoleL._get_property(self, attrname) is not None: found_prop = IStateCalcMagnitudeFieldDipoleL._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcMagnitudeFieldDipoleL.")
        
agcls.AgClassCatalog.add_catalog_entry("{C1FD9D99-42EF-40F2-9E53-AEBAEC1A5573}", StateCalcMagnitudeFieldDipoleL)


class StateCalcSEETMagnitudeFieldFieldLineSepAngle(IComponentInfo, ICloneable, IStateCalcSEETMagnitudeFieldFieldLineSepAngle):
    """SEETMagFieldFieldLineSepAngle Calc object."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcSEETMagnitudeFieldFieldLineSepAngle.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcSEETMagnitudeFieldFieldLineSepAngle._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcSEETMagnitudeFieldFieldLineSepAngle._get_property(self, attrname) is not None: found_prop = IStateCalcSEETMagnitudeFieldFieldLineSepAngle._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcSEETMagnitudeFieldFieldLineSepAngle.")
        
agcls.AgClassCatalog.add_catalog_entry("{585BF1E2-E8E0-4D8B-9101-7BDC793D6E68}", StateCalcSEETMagnitudeFieldFieldLineSepAngle)


class StateCalcImpactFlux(IStateCalcImpactFlux, IComponentInfo, ICloneable):
    """CoClass StateCalcImpactFlux."""
    def __init__(self, sourceObject=None):
        IStateCalcImpactFlux.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IStateCalcImpactFlux._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IStateCalcImpactFlux._get_property(self, attrname) is not None: found_prop = IStateCalcImpactFlux._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcImpactFlux.")
        
agcls.AgClassCatalog.add_catalog_entry("{2F537C47-80E4-483C-9C6F-A82F91EC5F24}", StateCalcImpactFlux)


class StateCalcImpactMassFlux(IStateCalcImpactMassFlux, IComponentInfo, ICloneable):
    """CoClass StateCalcImpactMassFlux."""
    def __init__(self, sourceObject=None):
        IStateCalcImpactMassFlux.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IStateCalcImpactMassFlux._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IStateCalcImpactMassFlux._get_property(self, attrname) is not None: found_prop = IStateCalcImpactMassFlux._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcImpactMassFlux.")
        
agcls.AgClassCatalog.add_catalog_entry("{9D64EF8C-63C9-4924-BE13-8176E3DAB180}", StateCalcImpactMassFlux)


class StateCalcSEETSAAFlux(IStateCalcSEETSAAFlux, IComponentInfo, ICloneable):
    """CoClass StateCalcSEETSAAFlux."""
    def __init__(self, sourceObject=None):
        IStateCalcSEETSAAFlux.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IStateCalcSEETSAAFlux._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IStateCalcSEETSAAFlux._get_property(self, attrname) is not None: found_prop = IStateCalcSEETSAAFlux._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcSEETSAAFlux.")
        
agcls.AgClassCatalog.add_catalog_entry("{3C766F5E-9727-4ACD-9E5D-D08684116A79}", StateCalcSEETSAAFlux)


class StateCalcSEETVehTemp(IStateCalcSEETVehTemp, IComponentInfo, ICloneable):
    """CoClass StateCalcSEETVehTemp."""
    def __init__(self, sourceObject=None):
        IStateCalcSEETVehTemp.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IStateCalcSEETVehTemp._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IStateCalcSEETVehTemp._get_property(self, attrname) is not None: found_prop = IStateCalcSEETVehTemp._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcSEETVehTemp.")
        
agcls.AgClassCatalog.add_catalog_entry("{082CAA56-3DB0-4BA5-BE14-B84D93A32504}", StateCalcSEETVehTemp)


class StateCalcEpoch(IComponentInfo, ICloneable, IStateCalcEpoch):
    """Epoch Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcEpoch.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcEpoch._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcEpoch._get_property(self, attrname) is not None: found_prop = IStateCalcEpoch._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcEpoch.")
        
agcls.AgClassCatalog.add_catalog_entry("{CC140708-1576-4CFA-9A28-BC454B33DE02}", StateCalcEpoch)


class StateCalcJacobiConstant(IComponentInfo, ICloneable, IStateCalcJacobiConstant):
    """Jacobi Constant Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcJacobiConstant.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcJacobiConstant._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcJacobiConstant._get_property(self, attrname) is not None: found_prop = IStateCalcJacobiConstant._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcJacobiConstant.")
        
agcls.AgClassCatalog.add_catalog_entry("{FFF1FA69-1E24-445E-A239-41E2AB0D373B}", StateCalcJacobiConstant)


class StateCalcCartesianElem(IComponentInfo, ICloneable, IStateCalcCartesianElem):
    """Cartesian Elements Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcCartesianElem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcCartesianElem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcCartesianElem._get_property(self, attrname) is not None: found_prop = IStateCalcCartesianElem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcCartesianElem.")
        
agcls.AgClassCatalog.add_catalog_entry("{AECA6CA7-7D04-4EB5-95D9-216BBCCD0EC1}", StateCalcCartesianElem)


class StateCalcCartSTMElem(IComponentInfo, ICloneable, IStateCalcCartSTMElem):
    """Cartesian STM Elements Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcCartSTMElem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcCartSTMElem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcCartSTMElem._get_property(self, attrname) is not None: found_prop = IStateCalcCartSTMElem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcCartSTMElem.")
        
agcls.AgClassCatalog.add_catalog_entry("{84EAF6DB-A535-421E-8CCF-95A142E3B2FE}", StateCalcCartSTMElem)


class StateCalcSTMEigenval(IComponentInfo, ICloneable, IStateCalcSTMEigenval):
    """Cartesian STM Eigenvalues Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcSTMEigenval.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcSTMEigenval._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcSTMEigenval._get_property(self, attrname) is not None: found_prop = IStateCalcSTMEigenval._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcSTMEigenval.")
        
agcls.AgClassCatalog.add_catalog_entry("{F3AC2C6F-7A0A-40CA-A7EC-230D9EC2D75E}", StateCalcSTMEigenval)


class StateCalcSTMEigenvecElem(IComponentInfo, ICloneable, IStateCalcSTMEigenvecElem):
    """Cartesian STM Eigenvector Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcSTMEigenvecElem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcSTMEigenvecElem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcSTMEigenvecElem._get_property(self, attrname) is not None: found_prop = IStateCalcSTMEigenvecElem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcSTMEigenvecElem.")
        
agcls.AgClassCatalog.add_catalog_entry("{53BF2ADA-8B4D-4E64-BC61-AFA201DAB3C7}", StateCalcSTMEigenvecElem)


class StateCalcEnvironment(IComponentInfo, ICloneable, IStateCalcEnvironment):
    """Environment Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcEnvironment.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcEnvironment._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcEnvironment._get_property(self, attrname) is not None: found_prop = IStateCalcEnvironment._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcEnvironment.")
        
agcls.AgClassCatalog.add_catalog_entry("{A8319DEC-F018-4890-AC98-9F7B2AF96DF6}", StateCalcEnvironment)


class StateCalcOrbitDelaunayG(IStateCalcOrbitDelaunayG, IComponentInfo, ICloneable):
    """CoClass AsStateCalcOrbitDelaunayG."""
    def __init__(self, sourceObject=None):
        IStateCalcOrbitDelaunayG.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IStateCalcOrbitDelaunayG._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IStateCalcOrbitDelaunayG._get_property(self, attrname) is not None: found_prop = IStateCalcOrbitDelaunayG._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcOrbitDelaunayG.")
        
agcls.AgClassCatalog.add_catalog_entry("{5DE99D8D-DB40-4107-9D79-03D51AEAA4E8}", StateCalcOrbitDelaunayG)


class StateCalcOrbitDelaunayH(IStateCalcOrbitDelaunayH, IComponentInfo, ICloneable):
    """CoClass AsStateCalcOrbitDelaunayH."""
    def __init__(self, sourceObject=None):
        IStateCalcOrbitDelaunayH.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IStateCalcOrbitDelaunayH._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IStateCalcOrbitDelaunayH._get_property(self, attrname) is not None: found_prop = IStateCalcOrbitDelaunayH._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcOrbitDelaunayH.")
        
agcls.AgClassCatalog.add_catalog_entry("{4C7CDC1F-79EA-412B-A1E3-7E519CCAA4F0}", StateCalcOrbitDelaunayH)


class StateCalcOrbitDelaunayL(IStateCalcOrbitDelaunayL, IComponentInfo, ICloneable):
    """CoClass AsStateCalcOrbitDelaunayL."""
    def __init__(self, sourceObject=None):
        IStateCalcOrbitDelaunayL.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IStateCalcOrbitDelaunayL._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IStateCalcOrbitDelaunayL._get_property(self, attrname) is not None: found_prop = IStateCalcOrbitDelaunayL._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcOrbitDelaunayL.")
        
agcls.AgClassCatalog.add_catalog_entry("{299A4FF6-0636-4A25-AC74-4FF7D0A33F30}", StateCalcOrbitDelaunayL)


class StateCalcOrbitSemiLatusRectum(IStateCalcOrbitSemiLatusRectum, IComponentInfo, ICloneable):
    """CoClass AsStateCalcOrbitSemiLatusRectum."""
    def __init__(self, sourceObject=None):
        IStateCalcOrbitSemiLatusRectum.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IStateCalcOrbitSemiLatusRectum._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IStateCalcOrbitSemiLatusRectum._get_property(self, attrname) is not None: found_prop = IStateCalcOrbitSemiLatusRectum._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcOrbitSemiLatusRectum.")
        
agcls.AgClassCatalog.add_catalog_entry("{9A0EF481-BE9B-47B7-81D5-CAFF636B8E31}", StateCalcOrbitSemiLatusRectum)


class StateCalcEquinoctialElem(IComponentInfo, ICloneable, IStateCalcEquinoctialElem):
    """Equinoctial Elements Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcEquinoctialElem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcEquinoctialElem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcEquinoctialElem._get_property(self, attrname) is not None: found_prop = IStateCalcEquinoctialElem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcEquinoctialElem.")
        
agcls.AgClassCatalog.add_catalog_entry("{5C90B745-3002-4AEC-9613-0FE8168F2903}", StateCalcEquinoctialElem)


class StateCalcCloseApproachBearing(IComponentInfo, ICloneable, IStateCalcCloseApproachBearing):
    """CloseApproachBearing Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcCloseApproachBearing.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcCloseApproachBearing._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcCloseApproachBearing._get_property(self, attrname) is not None: found_prop = IStateCalcCloseApproachBearing._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcCloseApproachBearing.")
        
agcls.AgClassCatalog.add_catalog_entry("{E0AD9FFF-8F9D-4EBD-A41D-2982A60968AB}", StateCalcCloseApproachBearing)


class StateCalcCloseApproachMagnitude(IComponentInfo, ICloneable, IStateCalcCloseApproachMagnitude):
    """CloseApproachMag Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcCloseApproachMagnitude.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcCloseApproachMagnitude._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcCloseApproachMagnitude._get_property(self, attrname) is not None: found_prop = IStateCalcCloseApproachMagnitude._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcCloseApproachMagnitude.")
        
agcls.AgClassCatalog.add_catalog_entry("{70461F34-33C2-42B4-9591-5A2F2C5EB8D2}", StateCalcCloseApproachMagnitude)


class StateCalcCloseApproachTheta(IComponentInfo, ICloneable, IStateCalcCloseApproachTheta):
    """CloseApproachTheta Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcCloseApproachTheta.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcCloseApproachTheta._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcCloseApproachTheta._get_property(self, attrname) is not None: found_prop = IStateCalcCloseApproachTheta._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcCloseApproachTheta.")
        
agcls.AgClassCatalog.add_catalog_entry("{950DA5FA-29AA-4422-B760-AD23CB6A33FB}", StateCalcCloseApproachTheta)


class StateCalcCloseApproachX(IComponentInfo, ICloneable, IStateCalcCloseApproachX):
    """CloseApproachX Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcCloseApproachX.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcCloseApproachX._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcCloseApproachX._get_property(self, attrname) is not None: found_prop = IStateCalcCloseApproachX._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcCloseApproachX.")
        
agcls.AgClassCatalog.add_catalog_entry("{FD980AD5-6212-4A4A-AC05-4453F9015301}", StateCalcCloseApproachX)


class StateCalcCloseApproachY(IComponentInfo, ICloneable, IStateCalcCloseApproachY):
    """CloseApproachY Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcCloseApproachY.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcCloseApproachY._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcCloseApproachY._get_property(self, attrname) is not None: found_prop = IStateCalcCloseApproachY._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcCloseApproachY.")
        
agcls.AgClassCatalog.add_catalog_entry("{D04565A4-C1F2-4A3D-A304-FB3CB2887087}", StateCalcCloseApproachY)


class StateCalcCloseApproachCosBearing(IComponentInfo, ICloneable, IStateCalcCloseApproachCosBearing):
    """CloseApproachCosBearing Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcCloseApproachCosBearing.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcCloseApproachCosBearing._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcCloseApproachCosBearing._get_property(self, attrname) is not None: found_prop = IStateCalcCloseApproachCosBearing._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcCloseApproachCosBearing.")
        
agcls.AgClassCatalog.add_catalog_entry("{EDAFFF24-75C9-4C68-9E4B-00DEFD89DAE1}", StateCalcCloseApproachCosBearing)


class StateCalcRelGroundTrackError(IComponentInfo, ICloneable, IStateCalcRelGroundTrackError):
    """RelGroundTrackError Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcRelGroundTrackError.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcRelGroundTrackError._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcRelGroundTrackError._get_property(self, attrname) is not None: found_prop = IStateCalcRelGroundTrackError._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcRelGroundTrackError.")
        
agcls.AgClassCatalog.add_catalog_entry("{42632E47-2FF5-4183-BB7F-9A3CDAB5E80D}", StateCalcRelGroundTrackError)


class StateCalcRelAtAOLMaster(IComponentInfo, ICloneable, IStateCalcRelAtAOLMaster):
    """RelAOLMaster Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcRelAtAOLMaster.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcRelAtAOLMaster._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcRelAtAOLMaster._get_property(self, attrname) is not None: found_prop = IStateCalcRelAtAOLMaster._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcRelAtAOLMaster.")
        
agcls.AgClassCatalog.add_catalog_entry("{4ADF0E11-ECD1-434B-AD01-57FD9F0A692A}", StateCalcRelAtAOLMaster)


class StateCalcDeltaFromMaster(IComponentInfo, ICloneable, IStateCalcDeltaFromMaster):
    """DeltaFromMaster Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcDeltaFromMaster.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcDeltaFromMaster._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcDeltaFromMaster._get_property(self, attrname) is not None: found_prop = IStateCalcDeltaFromMaster._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcDeltaFromMaster.")
        
agcls.AgClassCatalog.add_catalog_entry("{F88A3044-F12D-4147-8609-B71F3AD972F4}", StateCalcDeltaFromMaster)


class StateCalcLonDriftRate(IComponentInfo, ICloneable, IStateCalcLonDriftRate):
    """LongDriftRate Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcLonDriftRate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcLonDriftRate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcLonDriftRate._get_property(self, attrname) is not None: found_prop = IStateCalcLonDriftRate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcLonDriftRate.")
        
agcls.AgClassCatalog.add_catalog_entry("{87C78155-DC4F-42C1-B2A6-D48E10F79594}", StateCalcLonDriftRate)


class StateCalcMeanEarthLon(IComponentInfo, ICloneable, IStateCalcMeanEarthLon):
    """MeanEarthLon Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcMeanEarthLon.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcMeanEarthLon._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcMeanEarthLon._get_property(self, attrname) is not None: found_prop = IStateCalcMeanEarthLon._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcMeanEarthLon.")
        
agcls.AgClassCatalog.add_catalog_entry("{0D4E3AF8-45A3-4000-BB8A-B6D8323627AD}", StateCalcMeanEarthLon)


class StateCalcRectifiedLon(IComponentInfo, ICloneable, IStateCalcRectifiedLon):
    """RectifiedLongitude Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcRectifiedLon.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcRectifiedLon._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcRectifiedLon._get_property(self, attrname) is not None: found_prop = IStateCalcRectifiedLon._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcRectifiedLon.")
        
agcls.AgClassCatalog.add_catalog_entry("{ED61CCC5-71C7-4D2D-BB7D-BF177E6B9D7A}", StateCalcRectifiedLon)


class StateCalcTrueLongitude(IComponentInfo, ICloneable, IStateCalcTrueLongitude):
    """TrueLongitude Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcTrueLongitude.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcTrueLongitude._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcTrueLongitude._get_property(self, attrname) is not None: found_prop = IStateCalcTrueLongitude._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcTrueLongitude.")
        
agcls.AgClassCatalog.add_catalog_entry("{EB667B87-04A5-4685-9F72-DBB764F488B5}", StateCalcTrueLongitude)


class StateCalcGeodeticTrueLongitude(IComponentInfo, ICloneable, IStateCalcGeodeticTrueLongitude):
    """GeodeticTrueLongitude Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcGeodeticTrueLongitude.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcGeodeticTrueLongitude._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcGeodeticTrueLongitude._get_property(self, attrname) is not None: found_prop = IStateCalcGeodeticTrueLongitude._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcGeodeticTrueLongitude.")
        
agcls.AgClassCatalog.add_catalog_entry("{619B549B-4824-4D2D-A11B-EB8398871C67}", StateCalcGeodeticTrueLongitude)


class StateCalcGeodeticTrueLongitudeAtTimeOfPerigee(IComponentInfo, ICloneable, IStateCalcGeodeticTrueLongitudeAtTimeOfPerigee):
    """GeodeticTrueLongitudeAtTimeOfPerigee Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcGeodeticTrueLongitudeAtTimeOfPerigee.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcGeodeticTrueLongitudeAtTimeOfPerigee._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcGeodeticTrueLongitudeAtTimeOfPerigee._get_property(self, attrname) is not None: found_prop = IStateCalcGeodeticTrueLongitudeAtTimeOfPerigee._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcGeodeticTrueLongitudeAtTimeOfPerigee.")
        
agcls.AgClassCatalog.add_catalog_entry("{C6C19B72-22D7-4871-A658-5A2C46FA1DE5}", StateCalcGeodeticTrueLongitudeAtTimeOfPerigee)


class StateCalcMeanRightAscension(IComponentInfo, ICloneable, IStateCalcMeanRightAscension):
    """MeanRightAscension Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcMeanRightAscension.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcMeanRightAscension._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcMeanRightAscension._get_property(self, attrname) is not None: found_prop = IStateCalcMeanRightAscension._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcMeanRightAscension.")
        
agcls.AgClassCatalog.add_catalog_entry("{A98B4722-77F9-4EB8-B9BC-D36C8D56AEA9}", StateCalcMeanRightAscension)


class StateCalcGeodeticMeanRightAscension(IComponentInfo, ICloneable, IStateCalcGeodeticMeanRightAscension):
    """GeodeticMeanRightAscension Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcGeodeticMeanRightAscension.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcGeodeticMeanRightAscension._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcGeodeticMeanRightAscension._get_property(self, attrname) is not None: found_prop = IStateCalcGeodeticMeanRightAscension._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcGeodeticMeanRightAscension.")
        
agcls.AgClassCatalog.add_catalog_entry("{143B6D03-5CAE-4AA3-84EE-3D83A1BA9BD9}", StateCalcGeodeticMeanRightAscension)


class StateCalcTwoBodyDriftRate(IComponentInfo, ICloneable, IStateCalcTwoBodyDriftRate):
    """TwoBodyDriftRate Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcTwoBodyDriftRate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcTwoBodyDriftRate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcTwoBodyDriftRate._get_property(self, attrname) is not None: found_prop = IStateCalcTwoBodyDriftRate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcTwoBodyDriftRate.")
        
agcls.AgClassCatalog.add_catalog_entry("{117D07A4-0253-4AB7-B96C-17B1350EB663}", StateCalcTwoBodyDriftRate)


class StateCalcDriftRateFactor(IComponentInfo, ICloneable, IStateCalcDriftRateFactor):
    """DriftRateFactor Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcDriftRateFactor.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcDriftRateFactor._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcDriftRateFactor._get_property(self, attrname) is not None: found_prop = IStateCalcDriftRateFactor._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcDriftRateFactor.")
        
agcls.AgClassCatalog.add_catalog_entry("{01BCEE54-F8E9-4E89-B154-951ECD5A0A3D}", StateCalcDriftRateFactor)


class StateCalcEccentricityX(IComponentInfo, ICloneable, IStateCalcEccentricityX):
    """EccentricityX Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcEccentricityX.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcEccentricityX._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcEccentricityX._get_property(self, attrname) is not None: found_prop = IStateCalcEccentricityX._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcEccentricityX.")
        
agcls.AgClassCatalog.add_catalog_entry("{4BBA291A-C5F4-43DC-8394-34BC45F744A5}", StateCalcEccentricityX)


class StateCalcEccentricityY(IComponentInfo, ICloneable, IStateCalcEccentricityY):
    """EccentricityY Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcEccentricityY.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcEccentricityY._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcEccentricityY._get_property(self, attrname) is not None: found_prop = IStateCalcEccentricityY._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcEccentricityY.")
        
agcls.AgClassCatalog.add_catalog_entry("{807AD8EE-0486-481B-9EEC-C9406E8D1FF1}", StateCalcEccentricityY)


class StateCalcInclinationX(IComponentInfo, ICloneable, IStateCalcInclinationX):
    """InclinationX Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcInclinationX.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcInclinationX._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcInclinationX._get_property(self, attrname) is not None: found_prop = IStateCalcInclinationX._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcInclinationX.")
        
agcls.AgClassCatalog.add_catalog_entry("{0041C813-5B5A-4A26-A56F-A9823EF778E3}", StateCalcInclinationX)


class StateCalcInclinationY(IComponentInfo, ICloneable, IStateCalcInclinationY):
    """InclinationY Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcInclinationY.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcInclinationY._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcInclinationY._get_property(self, attrname) is not None: found_prop = IStateCalcInclinationY._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcInclinationY.")
        
agcls.AgClassCatalog.add_catalog_entry("{ED938D28-BA63-437E-B1DB-A7D8115B328C}", StateCalcInclinationY)


class StateCalcUnitAngularMomentumX(IComponentInfo, ICloneable, IStateCalcUnitAngularMomentumX):
    """UnitAngularMomentumX Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcUnitAngularMomentumX.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcUnitAngularMomentumX._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcUnitAngularMomentumX._get_property(self, attrname) is not None: found_prop = IStateCalcUnitAngularMomentumX._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcUnitAngularMomentumX.")
        
agcls.AgClassCatalog.add_catalog_entry("{53357EF4-239F-4B9A-A438-B51790C448BF}", StateCalcUnitAngularMomentumX)


class StateCalcUnitAngularMomentumY(IComponentInfo, ICloneable, IStateCalcUnitAngularMomentumY):
    """UnitAngularMomentumY Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcUnitAngularMomentumY.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcUnitAngularMomentumY._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcUnitAngularMomentumY._get_property(self, attrname) is not None: found_prop = IStateCalcUnitAngularMomentumY._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcUnitAngularMomentumY.")
        
agcls.AgClassCatalog.add_catalog_entry("{900693FD-BAAC-426E-8682-EEC85D239CB6}", StateCalcUnitAngularMomentumY)


class StateCalcUnitAngularMomentumZ(IComponentInfo, ICloneable, IStateCalcUnitAngularMomentumZ):
    """UnitAngularMomentumZ Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcUnitAngularMomentumZ.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcUnitAngularMomentumZ._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcUnitAngularMomentumZ._get_property(self, attrname) is not None: found_prop = IStateCalcUnitAngularMomentumZ._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcUnitAngularMomentumZ.")
        
agcls.AgClassCatalog.add_catalog_entry("{560184A9-46F4-4B62-8742-E72700D90640}", StateCalcUnitAngularMomentumZ)


class StateCalcHeightAboveTerrain(IStateCalcHeightAboveTerrain, IComponentInfo, ICloneable):
    """CoClass AsStateCalcHeightAboveTerrain."""
    def __init__(self, sourceObject=None):
        IStateCalcHeightAboveTerrain.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IStateCalcHeightAboveTerrain._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IStateCalcHeightAboveTerrain._get_property(self, attrname) is not None: found_prop = IStateCalcHeightAboveTerrain._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcHeightAboveTerrain.")
        
agcls.AgClassCatalog.add_catalog_entry("{3212361D-8A8B-4ED0-94C8-2D6F69BC3A12}", StateCalcHeightAboveTerrain)


class StateCalcGeodeticElem(IComponentInfo, ICloneable, IStateCalcGeodeticElem):
    """Geodetic Elements Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcGeodeticElem.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcGeodeticElem._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcGeodeticElem._get_property(self, attrname) is not None: found_prop = IStateCalcGeodeticElem._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcGeodeticElem.")
        
agcls.AgClassCatalog.add_catalog_entry("{C22E7F23-171B-4A81-AF2B-6A3747D92FDA}", StateCalcGeodeticElem)


class StateCalcRepeatingGroundTrackErr(IComponentInfo, ICloneable, IStateCalcRepeatingGroundTrackErr):
    """RepeatingGrTrackErr Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcRepeatingGroundTrackErr.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcRepeatingGroundTrackErr._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcRepeatingGroundTrackErr._get_property(self, attrname) is not None: found_prop = IStateCalcRepeatingGroundTrackErr._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcRepeatingGroundTrackErr.")
        
agcls.AgClassCatalog.add_catalog_entry("{2D4ADF81-8403-42A7-9CD8-969B9C5FEF33}", StateCalcRepeatingGroundTrackErr)


class StateCalcAltitudeOfApoapsis(IComponentInfo, ICloneable, IStateCalcAltitudeOfApoapsis):
    """AltitudeOfApoapsis Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcAltitudeOfApoapsis.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcAltitudeOfApoapsis._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcAltitudeOfApoapsis._get_property(self, attrname) is not None: found_prop = IStateCalcAltitudeOfApoapsis._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcAltitudeOfApoapsis.")
        
agcls.AgClassCatalog.add_catalog_entry("{A9398A62-DC62-40F2-8C71-C4D10D180C28}", StateCalcAltitudeOfApoapsis)


class StateCalcAltitudeOfPeriapsis(IComponentInfo, ICloneable, IStateCalcAltitudeOfPeriapsis):
    """AltitudeOfPeriapsis Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcAltitudeOfPeriapsis.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcAltitudeOfPeriapsis._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcAltitudeOfPeriapsis._get_property(self, attrname) is not None: found_prop = IStateCalcAltitudeOfPeriapsis._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcAltitudeOfPeriapsis.")
        
agcls.AgClassCatalog.add_catalog_entry("{700481E3-804B-4F43-B0AB-D58472F26302}", StateCalcAltitudeOfPeriapsis)


class StateCalcArgOfLat(IComponentInfo, ICloneable, IStateCalcArgOfLat):
    """Argument of Latitude Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcArgOfLat.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcArgOfLat._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcArgOfLat._get_property(self, attrname) is not None: found_prop = IStateCalcArgOfLat._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcArgOfLat.")
        
agcls.AgClassCatalog.add_catalog_entry("{E3D0D3CF-1181-4F67-98D9-2CA6A5530372}", StateCalcArgOfLat)


class StateCalcArgOfPeriapsis(IComponentInfo, ICloneable, IStateCalcArgOfPeriapsis):
    """Argument of Periapsis Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcArgOfPeriapsis.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcArgOfPeriapsis._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcArgOfPeriapsis._get_property(self, attrname) is not None: found_prop = IStateCalcArgOfPeriapsis._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcArgOfPeriapsis.")
        
agcls.AgClassCatalog.add_catalog_entry("{64C0F0D2-889C-4EE2-BD26-B32BC6880733}", StateCalcArgOfPeriapsis)


class StateCalcEccentricityAnomaly(IComponentInfo, ICloneable, IStateCalcEccentricityAnomaly):
    """EccAnomaly Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcEccentricityAnomaly.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcEccentricityAnomaly._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcEccentricityAnomaly._get_property(self, attrname) is not None: found_prop = IStateCalcEccentricityAnomaly._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcEccentricityAnomaly.")
        
agcls.AgClassCatalog.add_catalog_entry("{56C8EC47-95B0-4BF3-8D07-1F51630C285B}", StateCalcEccentricityAnomaly)


class StateCalcLonOfAscNode(IComponentInfo, ICloneable, IStateCalcLonOfAscNode):
    """LongitudeOfAscendingNode Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcLonOfAscNode.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcLonOfAscNode._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcLonOfAscNode._get_property(self, attrname) is not None: found_prop = IStateCalcLonOfAscNode._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcLonOfAscNode.")
        
agcls.AgClassCatalog.add_catalog_entry("{2B606060-6816-4394-B4C5-C527490F9329}", StateCalcLonOfAscNode)


class StateCalcMeanMotion(IComponentInfo, ICloneable, IStateCalcMeanMotion):
    """MeanMotion Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcMeanMotion.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcMeanMotion._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcMeanMotion._get_property(self, attrname) is not None: found_prop = IStateCalcMeanMotion._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcMeanMotion.")
        
agcls.AgClassCatalog.add_catalog_entry("{B18119FD-D9C9-41E2-A7EB-46ACDA5CA8D5}", StateCalcMeanMotion)


class StateCalcOrbitPeriod(IComponentInfo, ICloneable, IStateCalcOrbitPeriod):
    """OrbitPeriod Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcOrbitPeriod.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcOrbitPeriod._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcOrbitPeriod._get_property(self, attrname) is not None: found_prop = IStateCalcOrbitPeriod._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcOrbitPeriod.")
        
agcls.AgClassCatalog.add_catalog_entry("{D7563267-B5E5-43C5-8062-E07CCA0F2B84}", StateCalcOrbitPeriod)


class StateCalcNumRevs(IComponentInfo, ICloneable, IStateCalcNumRevs):
    """NumRevs Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcNumRevs.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcNumRevs._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcNumRevs._get_property(self, attrname) is not None: found_prop = IStateCalcNumRevs._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcNumRevs.")
        
agcls.AgClassCatalog.add_catalog_entry("{D0585F2A-3F22-472C-B134-5A6DE1873010}", StateCalcNumRevs)


class StateCalcRadOfApoapsis(IComponentInfo, ICloneable, IStateCalcRadOfApoapsis):
    """RadiusOfApoapsis Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcRadOfApoapsis.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcRadOfApoapsis._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcRadOfApoapsis._get_property(self, attrname) is not None: found_prop = IStateCalcRadOfApoapsis._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcRadOfApoapsis.")
        
agcls.AgClassCatalog.add_catalog_entry("{C0BE1DA2-4518-4DDC-9E9F-C270EECC9CD9}", StateCalcRadOfApoapsis)


class StateCalcRadOfPeriapsis(IComponentInfo, ICloneable, IStateCalcRadOfPeriapsis):
    """RadiusOfPeriapsis Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcRadOfPeriapsis.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcRadOfPeriapsis._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcRadOfPeriapsis._get_property(self, attrname) is not None: found_prop = IStateCalcRadOfPeriapsis._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcRadOfPeriapsis.")
        
agcls.AgClassCatalog.add_catalog_entry("{3992203A-6D30-4430-AB47-184058ADB753}", StateCalcRadOfPeriapsis)


class StateCalcSemiMajorAxis(IComponentInfo, ICloneable, IStateCalcSemiMajorAxis):
    """SemiMajorAxis Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcSemiMajorAxis.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcSemiMajorAxis._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcSemiMajorAxis._get_property(self, attrname) is not None: found_prop = IStateCalcSemiMajorAxis._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcSemiMajorAxis.")
        
agcls.AgClassCatalog.add_catalog_entry("{2E89613E-B6BE-4708-9642-8C1A7734E695}", StateCalcSemiMajorAxis)


class StateCalcTimePastAscNode(IComponentInfo, ICloneable, IStateCalcTimePastAscNode):
    """TimePastAscNode Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcTimePastAscNode.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcTimePastAscNode._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcTimePastAscNode._get_property(self, attrname) is not None: found_prop = IStateCalcTimePastAscNode._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcTimePastAscNode.")
        
agcls.AgClassCatalog.add_catalog_entry("{0D19A235-5062-4D39-9D24-5BE1951E8982}", StateCalcTimePastAscNode)


class StateCalcTimePastPeriapsis(IComponentInfo, ICloneable, IStateCalcTimePastPeriapsis):
    """TimePastPeriapsis Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcTimePastPeriapsis.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcTimePastPeriapsis._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcTimePastPeriapsis._get_property(self, attrname) is not None: found_prop = IStateCalcTimePastPeriapsis._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcTimePastPeriapsis.")
        
agcls.AgClassCatalog.add_catalog_entry("{98C81CE6-0D11-4B0B-A6E6-3BD36BBCB98E}", StateCalcTimePastPeriapsis)


class StateCalcTrueAnomaly(IComponentInfo, ICloneable, IStateCalcTrueAnomaly):
    """TrueAnomaly Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcTrueAnomaly.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcTrueAnomaly._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcTrueAnomaly._get_property(self, attrname) is not None: found_prop = IStateCalcTrueAnomaly._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcTrueAnomaly.")
        
agcls.AgClassCatalog.add_catalog_entry("{4F084E44-4214-46EF-B67C-0A0B160F6475}", StateCalcTrueAnomaly)


class StateCalcDeltaV(IComponentInfo, ICloneable, IStateCalcDeltaV):
    """DeltaV Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcDeltaV.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcDeltaV._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcDeltaV._get_property(self, attrname) is not None: found_prop = IStateCalcDeltaV._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcDeltaV.")
        
agcls.AgClassCatalog.add_catalog_entry("{1609A9CD-8AA8-4F97-A00F-35F014FCCE44}", StateCalcDeltaV)


class StateCalcDeltaVSquared(IComponentInfo, ICloneable, IStateCalcDeltaVSquared):
    """DeltaV Squared Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcDeltaVSquared.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcDeltaVSquared._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcDeltaVSquared._get_property(self, attrname) is not None: found_prop = IStateCalcDeltaVSquared._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcDeltaVSquared.")
        
agcls.AgClassCatalog.add_catalog_entry("{CF7792EC-113B-45A7-AD9E-ECC908EBE1FD}", StateCalcDeltaVSquared)


class StateCalcMissionControlSequenceDeltaV(IComponentInfo, ICloneable, IStateCalcMissionControlSequenceDeltaV):
    """MCS DeltaV Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcMissionControlSequenceDeltaV.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcMissionControlSequenceDeltaV._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcMissionControlSequenceDeltaV._get_property(self, attrname) is not None: found_prop = IStateCalcMissionControlSequenceDeltaV._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcMissionControlSequenceDeltaV.")
        
agcls.AgClassCatalog.add_catalog_entry("{8E6614E7-7F46-4A9C-B155-FD8ED6C08D94}", StateCalcMissionControlSequenceDeltaV)


class StateCalcMissionControlSequenceDeltaVSquared(IComponentInfo, ICloneable, IStateCalcMissionControlSequenceDeltaVSquared):
    """MCS DeltaV Squared Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcMissionControlSequenceDeltaVSquared.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcMissionControlSequenceDeltaVSquared._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcMissionControlSequenceDeltaVSquared._get_property(self, attrname) is not None: found_prop = IStateCalcMissionControlSequenceDeltaVSquared._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcMissionControlSequenceDeltaVSquared.")
        
agcls.AgClassCatalog.add_catalog_entry("{DA10B4C1-62C7-4E1C-8B86-A355667DF9AE}", StateCalcMissionControlSequenceDeltaVSquared)


class StateCalcSequenceDeltaV(IComponentInfo, ICloneable, IStateCalcSequenceDeltaV):
    """Sequence DeltaV Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcSequenceDeltaV.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcSequenceDeltaV._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcSequenceDeltaV._get_property(self, attrname) is not None: found_prop = IStateCalcSequenceDeltaV._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcSequenceDeltaV.")
        
agcls.AgClassCatalog.add_catalog_entry("{138B7BC6-2338-46BE-83E9-5099C4D45811}", StateCalcSequenceDeltaV)


class StateCalcSequenceDeltaVSquared(IComponentInfo, ICloneable, IStateCalcSequenceDeltaVSquared):
    """Sequence DeltaV Squared Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcSequenceDeltaVSquared.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcSequenceDeltaVSquared._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcSequenceDeltaVSquared._get_property(self, attrname) is not None: found_prop = IStateCalcSequenceDeltaVSquared._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcSequenceDeltaVSquared.")
        
agcls.AgClassCatalog.add_catalog_entry("{27E104DF-B5FF-4E24-B397-06D264C0EADA}", StateCalcSequenceDeltaVSquared)


class StateCalcFuelMass(IComponentInfo, ICloneable, IStateCalcFuelMass):
    """FuelMass Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcFuelMass.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcFuelMass._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcFuelMass._get_property(self, attrname) is not None: found_prop = IStateCalcFuelMass._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcFuelMass.")
        
agcls.AgClassCatalog.add_catalog_entry("{3C37AFCA-696D-4A00-9E7B-7DCE928F0E7E}", StateCalcFuelMass)


class StateCalcDensity(IComponentInfo, ICloneable, IStateCalcDensity):
    """Density  Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcDensity.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcDensity._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcDensity._get_property(self, attrname) is not None: found_prop = IStateCalcDensity._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcDensity.")
        
agcls.AgClassCatalog.add_catalog_entry("{61D869F6-7B1C-4B5D-A046-AE495AE0FA7E}", StateCalcDensity)


class StateCalcInertialDeltaVMagnitude(IComponentInfo, ICloneable, IStateCalcInertialDeltaVMagnitude):
    """InertialDeltaVMag Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcInertialDeltaVMagnitude.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcInertialDeltaVMagnitude._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcInertialDeltaVMagnitude._get_property(self, attrname) is not None: found_prop = IStateCalcInertialDeltaVMagnitude._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcInertialDeltaVMagnitude.")
        
agcls.AgClassCatalog.add_catalog_entry("{E12A8E9C-C11A-43D1-AE06-C659B87574D3}", StateCalcInertialDeltaVMagnitude)


class StateCalcInertialDeltaVx(IComponentInfo, ICloneable, IStateCalcInertialDeltaVx):
    """InertialDeltaVx Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcInertialDeltaVx.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcInertialDeltaVx._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcInertialDeltaVx._get_property(self, attrname) is not None: found_prop = IStateCalcInertialDeltaVx._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcInertialDeltaVx.")
        
agcls.AgClassCatalog.add_catalog_entry("{43875512-BFCF-42E9-ACC8-BA7AE9E498A9}", StateCalcInertialDeltaVx)


class StateCalcInertialDeltaVy(IComponentInfo, ICloneable, IStateCalcInertialDeltaVy):
    """InertialDeltaVy Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcInertialDeltaVy.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcInertialDeltaVy._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcInertialDeltaVy._get_property(self, attrname) is not None: found_prop = IStateCalcInertialDeltaVy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcInertialDeltaVy.")
        
agcls.AgClassCatalog.add_catalog_entry("{04689A0A-12D1-4362-B5C8-497CF2E4D72E}", StateCalcInertialDeltaVy)


class StateCalcInertialDeltaVz(IComponentInfo, ICloneable, IStateCalcInertialDeltaVz):
    """InertialDeltaVz Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcInertialDeltaVz.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcInertialDeltaVz._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcInertialDeltaVz._get_property(self, attrname) is not None: found_prop = IStateCalcInertialDeltaVz._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcInertialDeltaVz.")
        
agcls.AgClassCatalog.add_catalog_entry("{4A160495-31AE-42EE-8D2D-B945D10E86B8}", StateCalcInertialDeltaVz)


class StateCalcManeuverSpecificImpulse(IComponentInfo, ICloneable, IStateCalcManeuverSpecificImpulse):
    """ManeuverSpecificImpulse Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcManeuverSpecificImpulse.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcManeuverSpecificImpulse._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcManeuverSpecificImpulse._get_property(self, attrname) is not None: found_prop = IStateCalcManeuverSpecificImpulse._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcManeuverSpecificImpulse.")
        
agcls.AgClassCatalog.add_catalog_entry("{8FEFF2C1-6E15-4026-95B3-1985DB40C154}", StateCalcManeuverSpecificImpulse)


class StateCalcPressure(IComponentInfo, ICloneable, IStateCalcPressure):
    """Pressure Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcPressure.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcPressure._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcPressure._get_property(self, attrname) is not None: found_prop = IStateCalcPressure._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcPressure.")
        
agcls.AgClassCatalog.add_catalog_entry("{B12DCC30-F655-428A-BDE1-6D46900A7152}", StateCalcPressure)


class StateCalcTemperature(IComponentInfo, ICloneable, IStateCalcTemperature):
    """Temperature Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcTemperature.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcTemperature._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcTemperature._get_property(self, attrname) is not None: found_prop = IStateCalcTemperature._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcTemperature.")
        
agcls.AgClassCatalog.add_catalog_entry("{130771EF-F7FE-4CD3-B547-DE13FDF54E94}", StateCalcTemperature)


class StateCalcVectorY(IComponentInfo, ICloneable, IStateCalcVectorY):
    """VectorY Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcVectorY.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcVectorY._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcVectorY._get_property(self, attrname) is not None: found_prop = IStateCalcVectorY._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcVectorY.")
        
agcls.AgClassCatalog.add_catalog_entry("{7DC4C32E-1F4B-4B3E-A11C-7ECACCC602F8}", StateCalcVectorY)


class StateCalcVectorZ(IComponentInfo, ICloneable, IStateCalcVectorZ):
    """VectorZ Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcVectorZ.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcVectorZ._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcVectorZ._get_property(self, attrname) is not None: found_prop = IStateCalcVectorZ._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcVectorZ.")
        
agcls.AgClassCatalog.add_catalog_entry("{32E8F7E7-ECDE-4864-B380-D5A293458898}", StateCalcVectorZ)


class StateCalcMass(IComponentInfo, ICloneable, IStateCalcMass):
    """Mass Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcMass.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcMass._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcMass._get_property(self, attrname) is not None: found_prop = IStateCalcMass._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcMass.")
        
agcls.AgClassCatalog.add_catalog_entry("{99DD4422-3EB6-455B-9FE8-459FD65D2431}", StateCalcMass)


class StateCalcManeuverTotalMassFlowRate(IComponentInfo, ICloneable, IStateCalcManeuverTotalMassFlowRate):
    """ManeuverTotalMassFlowRate Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcManeuverTotalMassFlowRate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcManeuverTotalMassFlowRate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcManeuverTotalMassFlowRate._get_property(self, attrname) is not None: found_prop = IStateCalcManeuverTotalMassFlowRate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcManeuverTotalMassFlowRate.")
        
agcls.AgClassCatalog.add_catalog_entry("{049DA4A7-E8EB-4C62-AF0F-FFF566CB662F}", StateCalcManeuverTotalMassFlowRate)


class StateCalcAbsoluteValue(IComponentInfo, ICloneable, IStateCalcAbsoluteValue):
    """AbsoluteValue Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcAbsoluteValue.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcAbsoluteValue._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcAbsoluteValue._get_property(self, attrname) is not None: found_prop = IStateCalcAbsoluteValue._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcAbsoluteValue.")
        
agcls.AgClassCatalog.add_catalog_entry("{9CA8D97F-2F2D-4E66-B141-D5F8E3524B56}", StateCalcAbsoluteValue)


class StateCalcDifference(IComponentInfo, ICloneable, IStateCalcDifference):
    """Difference Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcDifference.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcDifference._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcDifference._get_property(self, attrname) is not None: found_prop = IStateCalcDifference._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcDifference.")
        
agcls.AgClassCatalog.add_catalog_entry("{8D579CBD-FB96-4CA1-9276-0ECF1E8A2854}", StateCalcDifference)


class StateCalcDifferenceOtherSegment(IComponentInfo, ICloneable, IStateCalcDifferenceOtherSegment):
    """DifferenceOtherSegment Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcDifferenceOtherSegment.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcDifferenceOtherSegment._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcDifferenceOtherSegment._get_property(self, attrname) is not None: found_prop = IStateCalcDifferenceOtherSegment._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcDifferenceOtherSegment.")
        
agcls.AgClassCatalog.add_catalog_entry("{36A3C1BA-F2AB-4F4C-887C-CF81C4E2BE52}", StateCalcDifferenceOtherSegment)


class StateCalcPositionDifferenceOtherSegment(IComponentInfo, ICloneable, IStateCalcPositionDifferenceOtherSegment):
    """PosDifferenceOtherSegment Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcPositionDifferenceOtherSegment.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcPositionDifferenceOtherSegment._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcPositionDifferenceOtherSegment._get_property(self, attrname) is not None: found_prop = IStateCalcPositionDifferenceOtherSegment._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcPositionDifferenceOtherSegment.")
        
agcls.AgClassCatalog.add_catalog_entry("{9C09C061-9C4A-4B14-A9DC-C802A44A8AF1}", StateCalcPositionDifferenceOtherSegment)


class StateCalcVelDifferenceOtherSegment(IComponentInfo, ICloneable, IStateCalcVelDifferenceOtherSegment):
    """VelDifferenceOtherSegment Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcVelDifferenceOtherSegment.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcVelDifferenceOtherSegment._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcVelDifferenceOtherSegment._get_property(self, attrname) is not None: found_prop = IStateCalcVelDifferenceOtherSegment._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcVelDifferenceOtherSegment.")
        
agcls.AgClassCatalog.add_catalog_entry("{C884D996-39EF-413B-9CF7-A8C927291B66}", StateCalcVelDifferenceOtherSegment)


class StateCalcPositionVelDifferenceOtherSegment(IComponentInfo, ICloneable, IStateCalcPositionVelDifferenceOtherSegment):
    """PosVelDifferenceOtherSegment Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcPositionVelDifferenceOtherSegment.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcPositionVelDifferenceOtherSegment._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcPositionVelDifferenceOtherSegment._get_property(self, attrname) is not None: found_prop = IStateCalcPositionVelDifferenceOtherSegment._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcPositionVelDifferenceOtherSegment.")
        
agcls.AgClassCatalog.add_catalog_entry("{C7AFF6F3-C2C7-4132-BEB5-9A714E763A11}", StateCalcPositionVelDifferenceOtherSegment)


class StateCalcValueAtSegment(IComponentInfo, ICloneable, IStateCalcValueAtSegment):
    """ValueAtSegment Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcValueAtSegment.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcValueAtSegment._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcValueAtSegment._get_property(self, attrname) is not None: found_prop = IStateCalcValueAtSegment._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcValueAtSegment.")
        
agcls.AgClassCatalog.add_catalog_entry("{80E8AAA2-2782-4176-9656-61AC3485096B}", StateCalcValueAtSegment)


class StateCalcMaxValue(IComponentInfo, ICloneable, IStateCalcMaxValue):
    """MaximumValue Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcMaxValue.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcMaxValue._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcMaxValue._get_property(self, attrname) is not None: found_prop = IStateCalcMaxValue._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcMaxValue.")
        
agcls.AgClassCatalog.add_catalog_entry("{CC82EA8F-373C-4A0D-A753-96CFD4AE73CF}", StateCalcMaxValue)


class StateCalcMinValue(IComponentInfo, ICloneable, IStateCalcMinValue):
    """MinimumValue Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcMinValue.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcMinValue._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcMinValue._get_property(self, attrname) is not None: found_prop = IStateCalcMinValue._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcMinValue.")
        
agcls.AgClassCatalog.add_catalog_entry("{F9C57411-482D-49E9-BE13-CC93E34FB0D4}", StateCalcMinValue)


class StateCalcMeanValue(IComponentInfo, ICloneable, IStateCalcMeanValue):
    """MeanValue Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcMeanValue.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcMeanValue._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcMeanValue._get_property(self, attrname) is not None: found_prop = IStateCalcMeanValue._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcMeanValue.")
        
agcls.AgClassCatalog.add_catalog_entry("{9B5472A7-799A-43E6-BDE7-99CB2C8C6E0C}", StateCalcMeanValue)


class StateCalcMedianValue(IComponentInfo, ICloneable, IStateCalcMedianValue):
    """MedianValue Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcMedianValue.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcMedianValue._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcMedianValue._get_property(self, attrname) is not None: found_prop = IStateCalcMedianValue._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcMedianValue.")
        
agcls.AgClassCatalog.add_catalog_entry("{CE3A18D7-5A69-45A1-AA76-AD7C2CF5259A}", StateCalcMedianValue)


class StateCalcStandardDeviation(IComponentInfo, ICloneable, IStateCalcStandardDeviation):
    """StandardDeviation Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcStandardDeviation.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcStandardDeviation._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcStandardDeviation._get_property(self, attrname) is not None: found_prop = IStateCalcStandardDeviation._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcStandardDeviation.")
        
agcls.AgClassCatalog.add_catalog_entry("{B33D3070-060B-4F32-AF2A-1F9BDD57F365}", StateCalcStandardDeviation)


class StateCalcNegative(IComponentInfo, ICloneable, IStateCalcNegative):
    """Negative Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcNegative.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcNegative._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcNegative._get_property(self, attrname) is not None: found_prop = IStateCalcNegative._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcNegative.")
        
agcls.AgClassCatalog.add_catalog_entry("{3E13FEC3-D60F-4203-86F2-42BCBC8EAFDF}", StateCalcNegative)


class StateCalcEccentricity(IComponentInfo, ICloneable, IStateCalcEccentricity):
    """Eccentricity Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcEccentricity.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcEccentricity._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcEccentricity._get_property(self, attrname) is not None: found_prop = IStateCalcEccentricity._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcEccentricity.")
        
agcls.AgClassCatalog.add_catalog_entry("{A9D98D60-E73E-4C59-9328-DFC5A12EF52B}", StateCalcEccentricity)


class StateCalcMeanAnomaly(IComponentInfo, ICloneable, IStateCalcMeanAnomaly):
    """MeanAnomaly Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcMeanAnomaly.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcMeanAnomaly._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcMeanAnomaly._get_property(self, attrname) is not None: found_prop = IStateCalcMeanAnomaly._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcMeanAnomaly.")
        
agcls.AgClassCatalog.add_catalog_entry("{8787D9AA-FBE1-43E4-932F-CB7B98D23D5B}", StateCalcMeanAnomaly)


class StateCalcRAAN(IComponentInfo, ICloneable, IStateCalcRAAN):
    """RAAN Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcRAAN.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcRAAN._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcRAAN._get_property(self, attrname) is not None: found_prop = IStateCalcRAAN._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcRAAN.")
        
agcls.AgClassCatalog.add_catalog_entry("{05B5185A-C8F3-4B02-AE8B-B5D58744323C}", StateCalcRAAN)


class BDotRCalc(IComponentInfo, ICloneable, IBDotRCalc):
    """BDotR Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IBDotRCalc.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IBDotRCalc._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IBDotRCalc._get_property(self, attrname) is not None: found_prop = IBDotRCalc._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BDotRCalc.")
        
agcls.AgClassCatalog.add_catalog_entry("{18A16428-2959-4220-A4A2-571D1F5A67FC}", BDotRCalc)


class BDotTCalc(IComponentInfo, ICloneable, IBDotTCalc):
    """BDotT Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IBDotTCalc.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IBDotTCalc._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IBDotTCalc._get_property(self, attrname) is not None: found_prop = IBDotTCalc._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BDotTCalc.")
        
agcls.AgClassCatalog.add_catalog_entry("{59ACA04A-9B85-43DF-82FF-B58CFD985158}", BDotTCalc)


class BMagnitudeCalc(IComponentInfo, ICloneable, IBMagnitudeCalc):
    """BMag Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IBMagnitudeCalc.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IBMagnitudeCalc._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IBMagnitudeCalc._get_property(self, attrname) is not None: found_prop = IBMagnitudeCalc._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BMagnitudeCalc.")
        
agcls.AgClassCatalog.add_catalog_entry("{87EF9CCA-2D0E-4742-8354-79E977FFD067}", BMagnitudeCalc)


class BThetaCalc(IComponentInfo, ICloneable, IBThetaCalc):
    """BTheta Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IBThetaCalc.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IBThetaCalc._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IBThetaCalc._get_property(self, attrname) is not None: found_prop = IBThetaCalc._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BThetaCalc.")
        
agcls.AgClassCatalog.add_catalog_entry("{C5C6EC0C-6F2D-4DAB-9DCD-2A8FD810C642}", BThetaCalc)


class StateCalcDeltaDec(IComponentInfo, ICloneable, IStateCalcDeltaDec):
    """DeltaDec Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcDeltaDec.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcDeltaDec._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcDeltaDec._get_property(self, attrname) is not None: found_prop = IStateCalcDeltaDec._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcDeltaDec.")
        
agcls.AgClassCatalog.add_catalog_entry("{4EA9E58A-9900-41CF-BFA8-8BF7849C9187}", StateCalcDeltaDec)


class StateCalcDeltaRA(IComponentInfo, ICloneable, IStateCalcDeltaRA):
    """DeltaRA Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcDeltaRA.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcDeltaRA._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcDeltaRA._get_property(self, attrname) is not None: found_prop = IStateCalcDeltaRA._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcDeltaRA.")
        
agcls.AgClassCatalog.add_catalog_entry("{3B1EAA2E-8FA2-4EF2-B7AB-377157AD0505}", StateCalcDeltaRA)


class StateCalcBetaAngle(IComponentInfo, ICloneable, IStateCalcBetaAngle):
    """BetaAngle Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcBetaAngle.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcBetaAngle._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcBetaAngle._get_property(self, attrname) is not None: found_prop = IStateCalcBetaAngle._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcBetaAngle.")
        
agcls.AgClassCatalog.add_catalog_entry("{B51815A6-AEDE-468C-B282-EEA255DAF822}", StateCalcBetaAngle)


class StateCalcLocalApparentSolarLon(IComponentInfo, ICloneable, IStateCalcLocalApparentSolarLon):
    """LocalApparentSolarLon Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcLocalApparentSolarLon.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcLocalApparentSolarLon._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcLocalApparentSolarLon._get_property(self, attrname) is not None: found_prop = IStateCalcLocalApparentSolarLon._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcLocalApparentSolarLon.")
        
agcls.AgClassCatalog.add_catalog_entry("{E7AC3C2D-5E4C-447F-8A56-C9CFCDBB2143}", StateCalcLocalApparentSolarLon)


class StateCalcLonOfPeriapsis(IComponentInfo, ICloneable, IStateCalcLonOfPeriapsis):
    """LonOfPeriapsis Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcLonOfPeriapsis.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcLonOfPeriapsis._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcLonOfPeriapsis._get_property(self, attrname) is not None: found_prop = IStateCalcLonOfPeriapsis._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcLonOfPeriapsis.")
        
agcls.AgClassCatalog.add_catalog_entry("{3DBA2AA2-6A87-4ACE-9F8D-C03001E1DBD1}", StateCalcLonOfPeriapsis)


class StateCalcOrbitStateValue(IComponentInfo, ICloneable, IStateCalcOrbitStateValue):
    """OrbitStateValue Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcOrbitStateValue.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcOrbitStateValue._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcOrbitStateValue._get_property(self, attrname) is not None: found_prop = IStateCalcOrbitStateValue._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcOrbitStateValue.")
        
agcls.AgClassCatalog.add_catalog_entry("{10879C56-0D1C-4E8E-B7CA-F059FB935366}", StateCalcOrbitStateValue)


class StateCalcSignedEccentricity(IComponentInfo, ICloneable, IStateCalcSignedEccentricity):
    """SignedEccentricity Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcSignedEccentricity.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcSignedEccentricity._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcSignedEccentricity._get_property(self, attrname) is not None: found_prop = IStateCalcSignedEccentricity._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcSignedEccentricity.")
        
agcls.AgClassCatalog.add_catalog_entry("{469C3DB7-C322-480A-82E2-4763AD59E470}", StateCalcSignedEccentricity)


class StateCalcInclination(IComponentInfo, ICloneable, IStateCalcInclination):
    """Inclination Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcInclination.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcInclination._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcInclination._get_property(self, attrname) is not None: found_prop = IStateCalcInclination._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcInclination.")
        
agcls.AgClassCatalog.add_catalog_entry("{1B8A0935-D9A7-4710-8C02-8A827F7D85DF}", StateCalcInclination)


class StateCalcTrueLon(IComponentInfo, ICloneable, IStateCalcTrueLon):
    """TrueLong Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcTrueLon.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcTrueLon._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcTrueLon._get_property(self, attrname) is not None: found_prop = IStateCalcTrueLon._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcTrueLon.")
        
agcls.AgClassCatalog.add_catalog_entry("{E1D740A4-341A-40AA-83E8-4456207A0D98}", StateCalcTrueLon)


class StateCalcPower(IComponentInfo, ICloneable, IStateCalcPower):
    """Power Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcPower.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcPower._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcPower._get_property(self, attrname) is not None: found_prop = IStateCalcPower._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcPower.")
        
agcls.AgClassCatalog.add_catalog_entry("{AE828349-BB26-44C8-9603-ED89F108DF82}", StateCalcPower)


class StateCalcRelMotion(IComponentInfo, ICloneable, IStateCalcRelMotion):
    """Relative Motion Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcRelMotion.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcRelMotion._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcRelMotion._get_property(self, attrname) is not None: found_prop = IStateCalcRelMotion._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcRelMotion.")
        
agcls.AgClassCatalog.add_catalog_entry("{1BE88040-9A43-40B0-9A3F-28C1AE4FCC33}", StateCalcRelMotion)


class StateCalcSolarBetaAngle(IComponentInfo, ICloneable, IStateCalcSolarBetaAngle):
    """Solar Beta Angle objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcSolarBetaAngle.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcSolarBetaAngle._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcSolarBetaAngle._get_property(self, attrname) is not None: found_prop = IStateCalcSolarBetaAngle._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcSolarBetaAngle.")
        
agcls.AgClassCatalog.add_catalog_entry("{A2AFBF81-9B6D-4675-B8A3-2995530B257F}", StateCalcSolarBetaAngle)


class StateCalcSolarInPlaneAngle(IComponentInfo, ICloneable, IStateCalcSolarInPlaneAngle):
    """Solar In Plane Angle objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcSolarInPlaneAngle.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcSolarInPlaneAngle._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcSolarInPlaneAngle._get_property(self, attrname) is not None: found_prop = IStateCalcSolarInPlaneAngle._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcSolarInPlaneAngle.")
        
agcls.AgClassCatalog.add_catalog_entry("{AF76B597-61AE-41E7-B7F9-47AB9FA06A23}", StateCalcSolarInPlaneAngle)


class StateCalcRelPositionDecAngle(IComponentInfo, ICloneable, IStateCalcRelPositionDecAngle):
    """Relative Position Declination Angle objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcRelPositionDecAngle.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcRelPositionDecAngle._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcRelPositionDecAngle._get_property(self, attrname) is not None: found_prop = IStateCalcRelPositionDecAngle._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcRelPositionDecAngle.")
        
agcls.AgClassCatalog.add_catalog_entry("{75D53DB6-15AE-43CE-8ABC-5B8568CEE035}", StateCalcRelPositionDecAngle)


class StateCalcRelPositionInPlaneAngle(IComponentInfo, ICloneable, IStateCalcRelPositionInPlaneAngle):
    """Relative Position Declination Angle objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcRelPositionInPlaneAngle.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcRelPositionInPlaneAngle._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcRelPositionInPlaneAngle._get_property(self, attrname) is not None: found_prop = IStateCalcRelPositionInPlaneAngle._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcRelPositionInPlaneAngle.")
        
agcls.AgClassCatalog.add_catalog_entry("{4F7C4C55-BAB3-484D-B110-4A34A6F1A006}", StateCalcRelPositionInPlaneAngle)


class StateCalcRelativeInclination(IComponentInfo, ICloneable, IStateCalcRelativeInclination):
    """Relative Inclination Angle objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcRelativeInclination.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcRelativeInclination._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcRelativeInclination._get_property(self, attrname) is not None: found_prop = IStateCalcRelativeInclination._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcRelativeInclination.")
        
agcls.AgClassCatalog.add_catalog_entry("{B2BAF85F-8B05-4261-8E40-428FD9F6A237}", StateCalcRelativeInclination)


class StateCalcCurvilinearRelMotion(IComponentInfo, ICloneable, IStateCalcCurvilinearRelMotion):
    """Curvilinear Relative Motion objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcCurvilinearRelMotion.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcCurvilinearRelMotion._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcCurvilinearRelMotion._get_property(self, attrname) is not None: found_prop = IStateCalcCurvilinearRelMotion._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcCurvilinearRelMotion.")
        
agcls.AgClassCatalog.add_catalog_entry("{1FBB6D32-A2AD-4914-940D-30E548147C35}", StateCalcCurvilinearRelMotion)


class StateCalcCustomFunction(IComponentInfo, ICloneable, IStateCalcCustomFunction):
    """Custom Function Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcCustomFunction.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcCustomFunction._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcCustomFunction._get_property(self, attrname) is not None: found_prop = IStateCalcCustomFunction._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcCustomFunction.")
        
agcls.AgClassCatalog.add_catalog_entry("{85022653-0E1C-4116-AC71-AE8AE17AD8AB}", StateCalcCustomFunction)


class StateCalcScript(IComponentInfo, ICloneable, IStateCalcScript):
    """Script Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcScript.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcScript._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcScript._get_property(self, attrname) is not None: found_prop = IStateCalcScript._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcScript.")
        
agcls.AgClassCatalog.add_catalog_entry("{5D44239C-5296-4B55-B0A6-810D2A709B20}", StateCalcScript)


class StateCalcCd(IComponentInfo, ICloneable, IStateCalcCd):
    """Cd Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcCd.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcCd._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcCd._get_property(self, attrname) is not None: found_prop = IStateCalcCd._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcCd.")
        
agcls.AgClassCatalog.add_catalog_entry("{9672871F-3A83-41E8-851E-509DD513C3E3}", StateCalcCd)


class StateCalcCr(IComponentInfo, ICloneable, IStateCalcCr):
    """Cr Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcCr.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcCr._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcCr._get_property(self, attrname) is not None: found_prop = IStateCalcCr._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcCr.")
        
agcls.AgClassCatalog.add_catalog_entry("{1AAFF1B0-616E-4A1C-9CE0-075D24C3B170}", StateCalcCr)


class StateCalcDragArea(IComponentInfo, ICloneable, IStateCalcDragArea):
    """DragArea Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcDragArea.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcDragArea._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcDragArea._get_property(self, attrname) is not None: found_prop = IStateCalcDragArea._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcDragArea.")
        
agcls.AgClassCatalog.add_catalog_entry("{3ED247EF-6E67-4883-A2FE-B2A7BF19E14E}", StateCalcDragArea)


class StateCalcRadiationPressureArea(IComponentInfo, ICloneable, IStateCalcRadiationPressureArea):
    """RadPressureArea Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcRadiationPressureArea.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcRadiationPressureArea._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcRadiationPressureArea._get_property(self, attrname) is not None: found_prop = IStateCalcRadiationPressureArea._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcRadiationPressureArea.")
        
agcls.AgClassCatalog.add_catalog_entry("{C7973875-9EFC-41FC-98CF-CCB7AE0C611F}", StateCalcRadiationPressureArea)


class StateCalcRadiationPressureCoefficient(IComponentInfo, ICloneable, IStateCalcRadiationPressureCoefficient):
    """RadiationPressureCoefficient Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcRadiationPressureCoefficient.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcRadiationPressureCoefficient._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcRadiationPressureCoefficient._get_property(self, attrname) is not None: found_prop = IStateCalcRadiationPressureCoefficient._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcRadiationPressureCoefficient.")
        
agcls.AgClassCatalog.add_catalog_entry("{7FDC4AD9-E570-4820-BFB3-939EA5FF7D82}", StateCalcRadiationPressureCoefficient)


class StateCalcSRPArea(IComponentInfo, ICloneable, IStateCalcSRPArea):
    """SRPArea Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcSRPArea.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcSRPArea._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcSRPArea._get_property(self, attrname) is not None: found_prop = IStateCalcSRPArea._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcSRPArea.")
        
agcls.AgClassCatalog.add_catalog_entry("{6A0BF963-BD8C-46F9-8C87-F6E0FF16D057}", StateCalcSRPArea)


class StateCalcCosOfVerticalFPA(IComponentInfo, ICloneable, IStateCalcCosOfVerticalFPA):
    """CosineOfVerticalFPA Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcCosOfVerticalFPA.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcCosOfVerticalFPA._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcCosOfVerticalFPA._get_property(self, attrname) is not None: found_prop = IStateCalcCosOfVerticalFPA._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcCosOfVerticalFPA.")
        
agcls.AgClassCatalog.add_catalog_entry("{779C8E84-1667-442C-BFD9-F20271803FE5}", StateCalcCosOfVerticalFPA)


class StateCalcDec(IComponentInfo, ICloneable, IStateCalcDec):
    """Dec Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcDec.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcDec._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcDec._get_property(self, attrname) is not None: found_prop = IStateCalcDec._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcDec.")
        
agcls.AgClassCatalog.add_catalog_entry("{3F821D80-1156-46EB-950F-FF965EB54C3C}", StateCalcDec)


class StateCalcFPA(IComponentInfo, ICloneable, IStateCalcFPA):
    """FPA Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcFPA.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcFPA._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcFPA._get_property(self, attrname) is not None: found_prop = IStateCalcFPA._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcFPA.")
        
agcls.AgClassCatalog.add_catalog_entry("{BAB717ED-41A9-4D2A-ADB3-F2D0F5BD67D6}", StateCalcFPA)


class StateCalcRMagnitude(IComponentInfo, ICloneable, IStateCalcRMagnitude):
    """RMag Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcRMagnitude.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcRMagnitude._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcRMagnitude._get_property(self, attrname) is not None: found_prop = IStateCalcRMagnitude._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcRMagnitude.")
        
agcls.AgClassCatalog.add_catalog_entry("{4EED7719-E95B-4482-936C-9940FF6EE774}", StateCalcRMagnitude)


class StateCalcRA(IComponentInfo, ICloneable, IStateCalcRA):
    """RA Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcRA.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcRA._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcRA._get_property(self, attrname) is not None: found_prop = IStateCalcRA._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcRA.")
        
agcls.AgClassCatalog.add_catalog_entry("{2482280B-347A-49C7-BEEB-044CD8F8C899}", StateCalcRA)


class StateCalcVMagnitude(IComponentInfo, ICloneable, IStateCalcVMagnitude):
    """VMag Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcVMagnitude.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcVMagnitude._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcVMagnitude._get_property(self, attrname) is not None: found_prop = IStateCalcVMagnitude._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcVMagnitude.")
        
agcls.AgClassCatalog.add_catalog_entry("{B2DD548E-6DD5-4C33-9EDC-8275A4711B70}", StateCalcVMagnitude)


class StateCalcVelAz(IComponentInfo, ICloneable, IStateCalcVelAz):
    """Velocity Azimuth Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcVelAz.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcVelAz._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcVelAz._get_property(self, attrname) is not None: found_prop = IStateCalcVelAz._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcVelAz.")
        
agcls.AgClassCatalog.add_catalog_entry("{51BBAEBF-08A7-47B0-82A2-49DD3B47C0DA}", StateCalcVelAz)


class StateCalcC3Energy(IComponentInfo, ICloneable, IStateCalcC3Energy):
    """C3Energy Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcC3Energy.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcC3Energy._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcC3Energy._get_property(self, attrname) is not None: found_prop = IStateCalcC3Energy._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcC3Energy.")
        
agcls.AgClassCatalog.add_catalog_entry("{3F05AC7C-3565-44C8-BD75-A9F26F5DEBE7}", StateCalcC3Energy)


class StateCalcInAsympDec(IComponentInfo, ICloneable, IStateCalcInAsympDec):
    """InAsymptoteDec Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcInAsympDec.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcInAsympDec._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcInAsympDec._get_property(self, attrname) is not None: found_prop = IStateCalcInAsympDec._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcInAsympDec.")
        
agcls.AgClassCatalog.add_catalog_entry("{74C3D08C-5CBE-4182-9C50-5607CFAE3C29}", StateCalcInAsympDec)


class StateCalcInAsympRA(IComponentInfo, ICloneable, IStateCalcInAsympRA):
    """InAsymptoteRA Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcInAsympRA.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcInAsympRA._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcInAsympRA._get_property(self, attrname) is not None: found_prop = IStateCalcInAsympRA._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcInAsympRA.")
        
agcls.AgClassCatalog.add_catalog_entry("{FA6F2B49-B25B-4726-A72B-EB01DA9A40FA}", StateCalcInAsympRA)


class StateCalcInVelAzAtPeriapsis(IComponentInfo, ICloneable, IStateCalcInVelAzAtPeriapsis):
    """InVelocityAzAtPeriapsis Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcInVelAzAtPeriapsis.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcInVelAzAtPeriapsis._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcInVelAzAtPeriapsis._get_property(self, attrname) is not None: found_prop = IStateCalcInVelAzAtPeriapsis._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcInVelAzAtPeriapsis.")
        
agcls.AgClassCatalog.add_catalog_entry("{F425CF2E-5BD8-47E0-86FB-8E6911450DC2}", StateCalcInVelAzAtPeriapsis)


class StateCalcOutAsympDec(IComponentInfo, ICloneable, IStateCalcOutAsympDec):
    """OutAsymptoteDec Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcOutAsympDec.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcOutAsympDec._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcOutAsympDec._get_property(self, attrname) is not None: found_prop = IStateCalcOutAsympDec._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcOutAsympDec.")
        
agcls.AgClassCatalog.add_catalog_entry("{E6479974-FCA0-4BB3-9218-5EA7FBC6B309}", StateCalcOutAsympDec)


class StateCalcOutAsympRA(IComponentInfo, ICloneable, IStateCalcOutAsympRA):
    """OutAsymptoteRA Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcOutAsympRA.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcOutAsympRA._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcOutAsympRA._get_property(self, attrname) is not None: found_prop = IStateCalcOutAsympRA._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcOutAsympRA.")
        
agcls.AgClassCatalog.add_catalog_entry("{5FD80B29-8811-4669-9830-E00AC6A65B7A}", StateCalcOutAsympRA)


class StateCalcOutVelAzAtPeriapsis(IComponentInfo, ICloneable, IStateCalcOutVelAzAtPeriapsis):
    """OutVelocityAzAtPeriapsis Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcOutVelAzAtPeriapsis.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcOutVelAzAtPeriapsis._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcOutVelAzAtPeriapsis._get_property(self, attrname) is not None: found_prop = IStateCalcOutVelAzAtPeriapsis._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcOutVelAzAtPeriapsis.")
        
agcls.AgClassCatalog.add_catalog_entry("{6FACAD87-7615-433A-BED5-B79F771BF045}", StateCalcOutVelAzAtPeriapsis)


class StateCalcDuration(IComponentInfo, ICloneable, IStateCalcDuration):
    """Duration Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcDuration.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcDuration._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcDuration._get_property(self, attrname) is not None: found_prop = IStateCalcDuration._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcDuration.")
        
agcls.AgClassCatalog.add_catalog_entry("{8A31F99F-B1EA-4818-B3F7-6485F142BEDA}", StateCalcDuration)


class StateCalcUserValue(IStateCalcUserValue, IComponentInfo, ICloneable):
    """CoClass StateCalcUserValue."""
    def __init__(self, sourceObject=None):
        IStateCalcUserValue.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IStateCalcUserValue._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IStateCalcUserValue._get_property(self, attrname) is not None: found_prop = IStateCalcUserValue._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcUserValue.")
        
agcls.AgClassCatalog.add_catalog_entry("{DF6CDC8E-3271-4671-851E-6D8916364D04}", StateCalcUserValue)


class StateCalcVectorGeometryToolAngle(IComponentInfo, ICloneable, IStateCalcVectorGeometryToolAngle):
    """Vector Geometry Tool Angle Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcVectorGeometryToolAngle.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcVectorGeometryToolAngle._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcVectorGeometryToolAngle._get_property(self, attrname) is not None: found_prop = IStateCalcVectorGeometryToolAngle._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcVectorGeometryToolAngle.")
        
agcls.AgClassCatalog.add_catalog_entry("{382A3B1B-6CB2-4E54-A066-C0B62EF241C8}", StateCalcVectorGeometryToolAngle)


class StateCalcAngle(IComponentInfo, ICloneable, IStateCalcAngle):
    """Angle Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcAngle.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcAngle._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcAngle._get_property(self, attrname) is not None: found_prop = IStateCalcAngle._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcAngle.")
        
agcls.AgClassCatalog.add_catalog_entry("{C19A5EF8-79AF-48F2-9D09-86AE97CC689A}", StateCalcAngle)


class StateCalcDotProduct(IComponentInfo, ICloneable, IStateCalcDotProduct):
    """DotProduct Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcDotProduct.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcDotProduct._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcDotProduct._get_property(self, attrname) is not None: found_prop = IStateCalcDotProduct._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcDotProduct.")
        
agcls.AgClassCatalog.add_catalog_entry("{B8E6B301-8959-44D9-B9EC-70FEA1B5B12D}", StateCalcDotProduct)


class StateCalcVectorDec(IComponentInfo, ICloneable, IStateCalcVectorDec):
    """VectorDec Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcVectorDec.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcVectorDec._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcVectorDec._get_property(self, attrname) is not None: found_prop = IStateCalcVectorDec._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcVectorDec.")
        
agcls.AgClassCatalog.add_catalog_entry("{F5F90539-F030-4840-A78F-7BFE9FE6852F}", StateCalcVectorDec)


class StateCalcVectorMagnitude(IComponentInfo, ICloneable, IStateCalcVectorMagnitude):
    """VectorMag Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcVectorMagnitude.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcVectorMagnitude._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcVectorMagnitude._get_property(self, attrname) is not None: found_prop = IStateCalcVectorMagnitude._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcVectorMagnitude.")
        
agcls.AgClassCatalog.add_catalog_entry("{AE89CDB6-F735-4DAB-88D3-7F2DD834C1E4}", StateCalcVectorMagnitude)


class StateCalcVectorRA(IComponentInfo, ICloneable, IStateCalcVectorRA):
    """VectorRA Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcVectorRA.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcVectorRA._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcVectorRA._get_property(self, attrname) is not None: found_prop = IStateCalcVectorRA._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcVectorRA.")
        
agcls.AgClassCatalog.add_catalog_entry("{CE22AAAD-F51C-4E90-8E74-5DCEE756020C}", StateCalcVectorRA)


class StateCalcVectorX(IComponentInfo, ICloneable, IStateCalcVectorX):
    """VectorX Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcVectorX.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcVectorX._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcVectorX._get_property(self, attrname) is not None: found_prop = IStateCalcVectorX._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcVectorX.")
        
agcls.AgClassCatalog.add_catalog_entry("{9CC56135-C9E6-4A99-B0E2-70EA81E9AB08}", StateCalcVectorX)


class StateCalcOnePointAccess(IComponentInfo, ICloneable, IStateCalcOnePointAccess):
    """Access Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcOnePointAccess.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcOnePointAccess._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcOnePointAccess._get_property(self, attrname) is not None: found_prop = IStateCalcOnePointAccess._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcOnePointAccess.")
        
agcls.AgClassCatalog.add_catalog_entry("{19CBB92F-B6BE-4F6B-A2F9-056AD2EF7940}", StateCalcOnePointAccess)


class StateCalcDifferenceAcrossSegmentsOtherSat(IComponentInfo, ICloneable, IStateCalcDifferenceAcrossSegmentsOtherSat):
    """DifferenceAcrossSegmentsOtherSat Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcDifferenceAcrossSegmentsOtherSat.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcDifferenceAcrossSegmentsOtherSat._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcDifferenceAcrossSegmentsOtherSat._get_property(self, attrname) is not None: found_prop = IStateCalcDifferenceAcrossSegmentsOtherSat._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcDifferenceAcrossSegmentsOtherSat.")
        
agcls.AgClassCatalog.add_catalog_entry("{83FAC79B-477F-4CD0-83AD-A0A2A9ECA782}", StateCalcDifferenceAcrossSegmentsOtherSat)


class StateCalcValueAtSegmentOtherSat(IComponentInfo, ICloneable, IStateCalcValueAtSegmentOtherSat):
    """ValueAtSegmentOtherSat Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcValueAtSegmentOtherSat.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcValueAtSegmentOtherSat._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcValueAtSegmentOtherSat._get_property(self, attrname) is not None: found_prop = IStateCalcValueAtSegmentOtherSat._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcValueAtSegmentOtherSat.")
        
agcls.AgClassCatalog.add_catalog_entry("{5F9F3194-5AC1-46C9-8FB9-F076747180E7}", StateCalcValueAtSegmentOtherSat)


class StateCalcRARate(IStateCalcRARate, IComponentInfo, ICloneable):
    """RightAscensionRate Calc objects."""
    def __init__(self, sourceObject=None):
        IStateCalcRARate.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IStateCalcRARate._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IStateCalcRARate._get_property(self, attrname) is not None: found_prop = IStateCalcRARate._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcRARate.")
        
agcls.AgClassCatalog.add_catalog_entry("{3B9AD865-10A2-4B52-BDC7-7BE11A2CD36D}", StateCalcRARate)


class StateCalcDecRate(IStateCalcDecRate, IComponentInfo, ICloneable):
    """DeclinationRate Calc objects."""
    def __init__(self, sourceObject=None):
        IStateCalcDecRate.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IStateCalcDecRate._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IStateCalcDecRate._get_property(self, attrname) is not None: found_prop = IStateCalcDecRate._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcDecRate.")
        
agcls.AgClassCatalog.add_catalog_entry("{CCE41365-840A-4B9A-967F-A7D1E761B2DF}", StateCalcDecRate)


class StateCalcGravitationalParameter(IStateCalcGravitationalParameter, IComponentInfo, ICloneable):
    """GravitationalParameter Calc objects."""
    def __init__(self, sourceObject=None):
        IStateCalcGravitationalParameter.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IStateCalcGravitationalParameter._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IStateCalcGravitationalParameter._get_property(self, attrname) is not None: found_prop = IStateCalcGravitationalParameter._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcGravitationalParameter.")
        
agcls.AgClassCatalog.add_catalog_entry("{0B3B8CA7-E0BC-4A0E-A0BE-026946EBF0A6}", StateCalcGravitationalParameter)


class StateCalcReferenceRadius(IStateCalcReferenceRadius, IComponentInfo, ICloneable):
    """Reference Radius Calc objects."""
    def __init__(self, sourceObject=None):
        IStateCalcReferenceRadius.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IStateCalcReferenceRadius._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IStateCalcReferenceRadius._get_property(self, attrname) is not None: found_prop = IStateCalcReferenceRadius._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcReferenceRadius.")
        
agcls.AgClassCatalog.add_catalog_entry("{C90B0911-1B88-4809-A9AD-B1F083E18808}", StateCalcReferenceRadius)


class StateCalcGravCoeff(IStateCalcGravCoeff, IComponentInfo, ICloneable):
    """Gravity Coefficient Calc objects."""
    def __init__(self, sourceObject=None):
        IStateCalcGravCoeff.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IStateCalcGravCoeff._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IStateCalcGravCoeff._get_property(self, attrname) is not None: found_prop = IStateCalcGravCoeff._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcGravCoeff.")
        
agcls.AgClassCatalog.add_catalog_entry("{30223DC9-7946-4480-8E8A-DB3393DFEFC8}", StateCalcGravCoeff)


class StateCalcSpeedOfLight(IStateCalcSpeedOfLight, IComponentInfo, ICloneable):
    """Speed Of Light Calc objects."""
    def __init__(self, sourceObject=None):
        IStateCalcSpeedOfLight.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IStateCalcSpeedOfLight._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IStateCalcSpeedOfLight._get_property(self, attrname) is not None: found_prop = IStateCalcSpeedOfLight._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcSpeedOfLight.")
        
agcls.AgClassCatalog.add_catalog_entry("{BB3D0551-655B-43D3-89BE-59816A9B2DF4}", StateCalcSpeedOfLight)


class StateCalcPi(IStateCalcPi, IComponentInfo, ICloneable):
    """Pi Calc objects."""
    def __init__(self, sourceObject=None):
        IStateCalcPi.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IStateCalcPi._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IStateCalcPi._get_property(self, attrname) is not None: found_prop = IStateCalcPi._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcPi.")
        
agcls.AgClassCatalog.add_catalog_entry("{81779742-2FD6-4E22-81C5-05F1D271944F}", StateCalcPi)


class StateCalcScalar(IStateCalcScalar, IComponentInfo, ICloneable):
    """Scalar Calc objects."""
    def __init__(self, sourceObject=None):
        IStateCalcScalar.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IStateCalcScalar._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IStateCalcScalar._get_property(self, attrname) is not None: found_prop = IStateCalcScalar._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcScalar.")
        
agcls.AgClassCatalog.add_catalog_entry("{C6136D77-3185-4A4C-83AA-90CC6713A07A}", StateCalcScalar)


class StateCalcApparentSolarTime(IComponentInfo, ICloneable, IStateCalcApparentSolarTime):
    """Apparent Solar Time Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcApparentSolarTime.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcApparentSolarTime._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcApparentSolarTime._get_property(self, attrname) is not None: found_prop = IStateCalcApparentSolarTime._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcApparentSolarTime.")
        
agcls.AgClassCatalog.add_catalog_entry("{EF933369-A9DC-4A8C-B361-615A7A8B852D}", StateCalcApparentSolarTime)


class StateCalcEarthMeanSolarTime(IComponentInfo, ICloneable, IStateCalcEarthMeanSolarTime):
    """EarthMeanSolarTime Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcEarthMeanSolarTime.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcEarthMeanSolarTime._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcEarthMeanSolarTime._get_property(self, attrname) is not None: found_prop = IStateCalcEarthMeanSolarTime._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcEarthMeanSolarTime.")
        
agcls.AgClassCatalog.add_catalog_entry("{A36F3E6D-DD64-4089-A0B9-CDDECA9F31BF}", StateCalcEarthMeanSolarTime)


class StateCalcEarthMeanLocTimeAN(IComponentInfo, ICloneable, IStateCalcEarthMeanLocTimeAN):
    """EarthMeanLocTimeAN Calc objects."""
    def __init__(self, sourceObject=None):
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
        IStateCalcEarthMeanLocTimeAN.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
        IStateCalcEarthMeanLocTimeAN._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if IStateCalcEarthMeanLocTimeAN._get_property(self, attrname) is not None: found_prop = IStateCalcEarthMeanLocTimeAN._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateCalcEarthMeanLocTimeAN.")
        
agcls.AgClassCatalog.add_catalog_entry("{8B52530C-09B1-48BB-A644-2564B3F9A23F}", StateCalcEarthMeanLocTimeAN)


class AutomaticSequenceCollection(IAutomaticSequenceCollection):
    """Automatic Sequence Collection."""
    def __init__(self, sourceObject=None):
        IAutomaticSequenceCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAutomaticSequenceCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAutomaticSequenceCollection._get_property(self, attrname) is not None: found_prop = IAutomaticSequenceCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AutomaticSequenceCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{364BDB62-ECD6-4661-A8EB-D6943F5BD5BF}", AutomaticSequenceCollection)


class AutomaticSequence(IAutomaticSequence):
    """Automatic Sequence."""
    def __init__(self, sourceObject=None):
        IAutomaticSequence.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAutomaticSequence._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAutomaticSequence._get_property(self, attrname) is not None: found_prop = IAutomaticSequence._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AutomaticSequence.")
        
agcls.AgClassCatalog.add_catalog_entry("{8755DF12-EDDB-468E-92AF-D98C5C1B1534}", AutomaticSequence)


class CentralBodyCollection(ICentralBodyCollection):
    """Central Body Collection."""
    def __init__(self, sourceObject=None):
        ICentralBodyCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICentralBodyCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICentralBodyCollection._get_property(self, attrname) is not None: found_prop = ICentralBodyCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CentralBodyCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{393D9C77-A9A2-4E5A-B285-9292EAF77559}", CentralBodyCollection)


class AstrogatorCentralBody(IAstrogatorCentralBody, IComponentInfo, ICloneable):
    """Central Body."""
    def __init__(self, sourceObject=None):
        IAstrogatorCentralBody.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAstrogatorCentralBody._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAstrogatorCentralBody._get_property(self, attrname) is not None: found_prop = IAstrogatorCentralBody._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AstrogatorCentralBody.")
        
agcls.AgClassCatalog.add_catalog_entry("{BB18EA4F-DF6E-44A3-B547-CD21EC10120C}", AstrogatorCentralBody)


class CentralBodyGravityModel(ICentralBodyGravityModel):
    """Central Body Gravity Model."""
    def __init__(self, sourceObject=None):
        ICentralBodyGravityModel.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICentralBodyGravityModel._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICentralBodyGravityModel._get_property(self, attrname) is not None: found_prop = ICentralBodyGravityModel._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CentralBodyGravityModel.")
        
agcls.AgClassCatalog.add_catalog_entry("{B235689A-958C-42EA-BACA-DF03ED880C5B}", CentralBodyGravityModel)


class CentralBodyShapeSphere(ICentralBodyShapeSphere, ICentralBodyShape):
    """Central Body Shape - Sphere."""
    def __init__(self, sourceObject=None):
        ICentralBodyShapeSphere.__init__(self, sourceObject)
        ICentralBodyShape.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICentralBodyShapeSphere._private_init(self, pUnk)
        ICentralBodyShape._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICentralBodyShapeSphere._get_property(self, attrname) is not None: found_prop = ICentralBodyShapeSphere._get_property(self, attrname)
        if ICentralBodyShape._get_property(self, attrname) is not None: found_prop = ICentralBodyShape._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CentralBodyShapeSphere.")
        
agcls.AgClassCatalog.add_catalog_entry("{0AC87F61-8DFA-48FF-A1D2-D7DCD7133900}", CentralBodyShapeSphere)


class CentralBodyShapeOblateSpheroid(ICentralBodyShapeOblateSpheroid, ICentralBodyShape):
    """Central Body Shape - Spheroid."""
    def __init__(self, sourceObject=None):
        ICentralBodyShapeOblateSpheroid.__init__(self, sourceObject)
        ICentralBodyShape.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICentralBodyShapeOblateSpheroid._private_init(self, pUnk)
        ICentralBodyShape._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICentralBodyShapeOblateSpheroid._get_property(self, attrname) is not None: found_prop = ICentralBodyShapeOblateSpheroid._get_property(self, attrname)
        if ICentralBodyShape._get_property(self, attrname) is not None: found_prop = ICentralBodyShape._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CentralBodyShapeOblateSpheroid.")
        
agcls.AgClassCatalog.add_catalog_entry("{1C606CEB-7C36-486E-A123-42AF0BCB2C8F}", CentralBodyShapeOblateSpheroid)


class CentralBodyShapeTriaxialEllipsoid(ICentralBodyShapeTriaxialEllipsoid, ICentralBodyShape):
    """Central Body Shape - Triaxial Ellipsoid."""
    def __init__(self, sourceObject=None):
        ICentralBodyShapeTriaxialEllipsoid.__init__(self, sourceObject)
        ICentralBodyShape.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICentralBodyShapeTriaxialEllipsoid._private_init(self, pUnk)
        ICentralBodyShape._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICentralBodyShapeTriaxialEllipsoid._get_property(self, attrname) is not None: found_prop = ICentralBodyShapeTriaxialEllipsoid._get_property(self, attrname)
        if ICentralBodyShape._get_property(self, attrname) is not None: found_prop = ICentralBodyShape._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CentralBodyShapeTriaxialEllipsoid.")
        
agcls.AgClassCatalog.add_catalog_entry("{286452CC-4917-4618-B2B7-D4C4B226AEAE}", CentralBodyShapeTriaxialEllipsoid)


class CentralBodyAttitudeRotationCoefficientsFile(ICentralBodyAttitudeRotationCoefficientsFile, ICentralBodyAttitude):
    """Central Body Attitude - Rotation Coefficients File."""
    def __init__(self, sourceObject=None):
        ICentralBodyAttitudeRotationCoefficientsFile.__init__(self, sourceObject)
        ICentralBodyAttitude.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICentralBodyAttitudeRotationCoefficientsFile._private_init(self, pUnk)
        ICentralBodyAttitude._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICentralBodyAttitudeRotationCoefficientsFile._get_property(self, attrname) is not None: found_prop = ICentralBodyAttitudeRotationCoefficientsFile._get_property(self, attrname)
        if ICentralBodyAttitude._get_property(self, attrname) is not None: found_prop = ICentralBodyAttitude._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CentralBodyAttitudeRotationCoefficientsFile.")
        
agcls.AgClassCatalog.add_catalog_entry("{BC7D0575-6607-4103-8957-0B791534526D}", CentralBodyAttitudeRotationCoefficientsFile)


class CentralBodyAttitudeIAU1994(ICentralBodyAttitudeIAU1994, ICentralBodyAttitude):
    """Central Body Attitude - IAU1994."""
    def __init__(self, sourceObject=None):
        ICentralBodyAttitudeIAU1994.__init__(self, sourceObject)
        ICentralBodyAttitude.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICentralBodyAttitudeIAU1994._private_init(self, pUnk)
        ICentralBodyAttitude._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICentralBodyAttitudeIAU1994._get_property(self, attrname) is not None: found_prop = ICentralBodyAttitudeIAU1994._get_property(self, attrname)
        if ICentralBodyAttitude._get_property(self, attrname) is not None: found_prop = ICentralBodyAttitude._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CentralBodyAttitudeIAU1994.")
        
agcls.AgClassCatalog.add_catalog_entry("{147ABE46-6F5E-45D9-8279-5D01B0D78B88}", CentralBodyAttitudeIAU1994)


class CentralBodyEphemerisAnalyticOrbit(ICentralBodyEphemerisAnalyticOrbit, ICentralBodyEphemeris):
    """Central Body Ephemeris - Analytic Orbit."""
    def __init__(self, sourceObject=None):
        ICentralBodyEphemerisAnalyticOrbit.__init__(self, sourceObject)
        ICentralBodyEphemeris.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICentralBodyEphemerisAnalyticOrbit._private_init(self, pUnk)
        ICentralBodyEphemeris._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICentralBodyEphemerisAnalyticOrbit._get_property(self, attrname) is not None: found_prop = ICentralBodyEphemerisAnalyticOrbit._get_property(self, attrname)
        if ICentralBodyEphemeris._get_property(self, attrname) is not None: found_prop = ICentralBodyEphemeris._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CentralBodyEphemerisAnalyticOrbit.")
        
agcls.AgClassCatalog.add_catalog_entry("{D2E09031-DB7F-480B-A361-73713F45EB70}", CentralBodyEphemerisAnalyticOrbit)


class CentralBodyEphemerisJPLSpice(ICentralBodyEphemerisJPLSpice, ICentralBodyEphemeris):
    """Central Body Ephemeris - JPLSpice."""
    def __init__(self, sourceObject=None):
        ICentralBodyEphemerisJPLSpice.__init__(self, sourceObject)
        ICentralBodyEphemeris.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICentralBodyEphemerisJPLSpice._private_init(self, pUnk)
        ICentralBodyEphemeris._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICentralBodyEphemerisJPLSpice._get_property(self, attrname) is not None: found_prop = ICentralBodyEphemerisJPLSpice._get_property(self, attrname)
        if ICentralBodyEphemeris._get_property(self, attrname) is not None: found_prop = ICentralBodyEphemeris._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CentralBodyEphemerisJPLSpice.")
        
agcls.AgClassCatalog.add_catalog_entry("{A75A2A9B-F225-43D5-A259-30C9B0488EB8}", CentralBodyEphemerisJPLSpice)


class CentralBodyEphemerisFile(ICentralBodyEphemerisFile, ICentralBodyEphemeris):
    """Central Body Ephemeris - File."""
    def __init__(self, sourceObject=None):
        ICentralBodyEphemerisFile.__init__(self, sourceObject)
        ICentralBodyEphemeris.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICentralBodyEphemerisFile._private_init(self, pUnk)
        ICentralBodyEphemeris._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICentralBodyEphemerisFile._get_property(self, attrname) is not None: found_prop = ICentralBodyEphemerisFile._get_property(self, attrname)
        if ICentralBodyEphemeris._get_property(self, attrname) is not None: found_prop = ICentralBodyEphemeris._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CentralBodyEphemerisFile.")
        
agcls.AgClassCatalog.add_catalog_entry("{063BA11E-7F73-40FA-B691-B12EC38DE29B}", CentralBodyEphemerisFile)


class CentralBodyEphemerisJPLDesignExplorerOptimizer(ICentralBodyEphemerisJPLDesignExplorerOptimizer, ICentralBodyEphemeris):
    """Central Body Ephemeris - JPL DE."""
    def __init__(self, sourceObject=None):
        ICentralBodyEphemerisJPLDesignExplorerOptimizer.__init__(self, sourceObject)
        ICentralBodyEphemeris.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICentralBodyEphemerisJPLDesignExplorerOptimizer._private_init(self, pUnk)
        ICentralBodyEphemeris._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICentralBodyEphemerisJPLDesignExplorerOptimizer._get_property(self, attrname) is not None: found_prop = ICentralBodyEphemerisJPLDesignExplorerOptimizer._get_property(self, attrname)
        if ICentralBodyEphemeris._get_property(self, attrname) is not None: found_prop = ICentralBodyEphemeris._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CentralBodyEphemerisJPLDesignExplorerOptimizer.")
        
agcls.AgClassCatalog.add_catalog_entry("{6426E9EA-5ED2-46C9-95BB-447955306CA7}", CentralBodyEphemerisJPLDesignExplorerOptimizer)


class CentralBodyEphemerisPlanetary(ICentralBodyEphemerisPlanetary, ICentralBodyEphemeris):
    """Central Body Ephemeris - Planetary."""
    def __init__(self, sourceObject=None):
        ICentralBodyEphemerisPlanetary.__init__(self, sourceObject)
        ICentralBodyEphemeris.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICentralBodyEphemerisPlanetary._private_init(self, pUnk)
        ICentralBodyEphemeris._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICentralBodyEphemerisPlanetary._get_property(self, attrname) is not None: found_prop = ICentralBodyEphemerisPlanetary._get_property(self, attrname)
        if ICentralBodyEphemeris._get_property(self, attrname) is not None: found_prop = ICentralBodyEphemeris._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CentralBodyEphemerisPlanetary.")
        
agcls.AgClassCatalog.add_catalog_entry("{B3946E55-049C-4314-B6E1-1B3E4BD4F660}", CentralBodyEphemerisPlanetary)


class MissionControlSequenceSegmentProperties(IMissionControlSequenceSegmentProperties, IRuntimeTypeInfoProvider):
    """Segment Properties."""
    def __init__(self, sourceObject=None):
        IMissionControlSequenceSegmentProperties.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMissionControlSequenceSegmentProperties._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMissionControlSequenceSegmentProperties._get_property(self, attrname) is not None: found_prop = IMissionControlSequenceSegmentProperties._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MissionControlSequenceSegmentProperties.")
        
agcls.AgClassCatalog.add_catalog_entry("{9740187E-A60E-4440-952F-46FCEF10879C}", MissionControlSequenceSegmentProperties)


class PowerInternal(IPowerInternal, IComponentInfo, ICloneable):
    """Power - Internal."""
    def __init__(self, sourceObject=None):
        IPowerInternal.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPowerInternal._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPowerInternal._get_property(self, attrname) is not None: found_prop = IPowerInternal._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PowerInternal.")
        
agcls.AgClassCatalog.add_catalog_entry("{269F510C-DE85-4BD7-B09C-15B573F83F31}", PowerInternal)


class PowerProcessed(IPowerProcessed, IComponentInfo, ICloneable):
    """Power - Processed Power Unit."""
    def __init__(self, sourceObject=None):
        IPowerProcessed.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPowerProcessed._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPowerProcessed._get_property(self, attrname) is not None: found_prop = IPowerProcessed._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PowerProcessed.")
        
agcls.AgClassCatalog.add_catalog_entry("{F9B2570A-E760-4C58-B95A-6654FA264F43}", PowerProcessed)


class PowerSolarArray(IPowerSolarArray, IComponentInfo, ICloneable):
    """Power - Solar Array."""
    def __init__(self, sourceObject=None):
        IPowerSolarArray.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPowerSolarArray._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPowerSolarArray._get_property(self, attrname) is not None: found_prop = IPowerSolarArray._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PowerSolarArray.")
        
agcls.AgClassCatalog.add_catalog_entry("{EFF8A0BD-0BEA-4A4C-B486-3BC0DDA2B96E}", PowerSolarArray)


class GeneralRelativityFunction(IGeneralRelativityFunction, IComponentInfo, ICloneable):
    """General Relativity Propagator Function."""
    def __init__(self, sourceObject=None):
        IGeneralRelativityFunction.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IGeneralRelativityFunction._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IGeneralRelativityFunction._get_property(self, attrname) is not None: found_prop = IGeneralRelativityFunction._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in GeneralRelativityFunction.")
        
agcls.AgClassCatalog.add_catalog_entry("{2388EABA-68BE-4071-A6FC-5DF5E6913E09}", GeneralRelativityFunction)


class StateTransformationFunction(IStateTransformationFunction, IComponentInfo, ICloneable):
    """State Transition Propagator Function."""
    def __init__(self, sourceObject=None):
        IStateTransformationFunction.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IStateTransformationFunction._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IStateTransformationFunction._get_property(self, attrname) is not None: found_prop = IStateTransformationFunction._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in StateTransformationFunction.")
        
agcls.AgClassCatalog.add_catalog_entry("{BC9BCE93-D459-43A4-B996-0710520ECD35}", StateTransformationFunction)


class CR3BPFunc(ICR3BPFunc, IComponentInfo, ICloneable):
    """CR3BP Function."""
    def __init__(self, sourceObject=None):
        ICR3BPFunc.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICR3BPFunc._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICR3BPFunc._get_property(self, attrname) is not None: found_prop = ICR3BPFunc._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CR3BPFunc.")
        
agcls.AgClassCatalog.add_catalog_entry("{0CB5F652-0A94-4493-8397-78E8B147A600}", CR3BPFunc)


class RadiationPressureFunction(IRadiationPressureFunction, IComponentInfo, ICloneable):
    """Radiation Pressure Propagator Function."""
    def __init__(self, sourceObject=None):
        IRadiationPressureFunction.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IRadiationPressureFunction._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRadiationPressureFunction._get_property(self, attrname) is not None: found_prop = IRadiationPressureFunction._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in RadiationPressureFunction.")
        
agcls.AgClassCatalog.add_catalog_entry("{129DFCA0-E241-4BF5-947C-34D311459876}", RadiationPressureFunction)


class YarkovskyFunc(IYarkovskyFunc, IComponentInfo, ICloneable):
    """Yarkovsky Effect Propagator Function."""
    def __init__(self, sourceObject=None):
        IYarkovskyFunc.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IYarkovskyFunc._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IYarkovskyFunc._get_property(self, attrname) is not None: found_prop = IYarkovskyFunc._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in YarkovskyFunc.")
        
agcls.AgClassCatalog.add_catalog_entry("{991BA5B1-ED2F-4633-8493-5AD584CBD4FC}", YarkovskyFunc)


class BlendedDensity(IBlendedDensity, IComponentInfo, ICloneable):
    """Blended atmospheric density propagator function."""
    def __init__(self, sourceObject=None):
        IBlendedDensity.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBlendedDensity._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBlendedDensity._get_property(self, attrname) is not None: found_prop = IBlendedDensity._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BlendedDensity.")
        
agcls.AgClassCatalog.add_catalog_entry("{8262277E-56CE-4780-8EF3-08324A1A06FD}", BlendedDensity)


class Cira72Function(ICira72Function, IComponentInfo, ICloneable):
    """Cira72 atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        ICira72Function.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICira72Function._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICira72Function._get_property(self, attrname) is not None: found_prop = ICira72Function._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Cira72Function.")
        
agcls.AgClassCatalog.add_catalog_entry("{995263CD-4163-4EDA-8012-310821C8A332}", Cira72Function)


class Exponential(IExponential, IComponentInfo, ICloneable):
    """Exponential atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IExponential.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IExponential._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IExponential._get_property(self, attrname) is not None: found_prop = IExponential._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Exponential.")
        
agcls.AgClassCatalog.add_catalog_entry("{701C6D24-1D0E-4D08-9A3B-61566AABDE02}", Exponential)


class HarrisPriester(IHarrisPriester, IComponentInfo, ICloneable):
    """Harris-Priester atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IHarrisPriester.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IHarrisPriester._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IHarrisPriester._get_property(self, attrname) is not None: found_prop = IHarrisPriester._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in HarrisPriester.")
        
agcls.AgClassCatalog.add_catalog_entry("{2C45FE9A-0EE9-46B0-B0A5-79A052FDE189}", HarrisPriester)


class DensityModelPlugin(IDensityModelPlugin, IComponentInfo, ICloneable):
    """Plugin atmospheric density propagator function."""
    def __init__(self, sourceObject=None):
        IDensityModelPlugin.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IDensityModelPlugin._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IDensityModelPlugin._get_property(self, attrname) is not None: found_prop = IDensityModelPlugin._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in DensityModelPlugin.")
        
agcls.AgClassCatalog.add_catalog_entry("{5331D02B-13E5-4609-BFE6-9BF842E6096F}", DensityModelPlugin)


class JacchiaRoberts(IJacchiaRoberts, IComponentInfo, ICloneable):
    """Jacchia Roberts atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IJacchiaRoberts.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IJacchiaRoberts._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IJacchiaRoberts._get_property(self, attrname) is not None: found_prop = IJacchiaRoberts._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in JacchiaRoberts.")
        
agcls.AgClassCatalog.add_catalog_entry("{6227B561-C892-4BB5-A835-9619EB144173}", JacchiaRoberts)


class JacchiaBowman2008(IJacchiaBowman2008, IComponentInfo, ICloneable):
    """Jacchia Bowman 2008 atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IJacchiaBowman2008.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IJacchiaBowman2008._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IJacchiaBowman2008._get_property(self, attrname) is not None: found_prop = IJacchiaBowman2008._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in JacchiaBowman2008.")
        
agcls.AgClassCatalog.add_catalog_entry("{19461979-5C67-4840-8DB9-902EC47E6105}", JacchiaBowman2008)


class Jacchia_1960(IJacchia_1960, IComponentInfo, ICloneable):
    """Jacchia_1960 atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IJacchia_1960.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IJacchia_1960._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IJacchia_1960._get_property(self, attrname) is not None: found_prop = IJacchia_1960._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Jacchia_1960.")
        
agcls.AgClassCatalog.add_catalog_entry("{E803E9D5-31AB-4D5C-B93E-AB9975E2402B}", Jacchia_1960)


class Jacchia_1970(IJacchia_1970, IComponentInfo, ICloneable):
    """Jacchia_1970 atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IJacchia_1970.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IJacchia_1970._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IJacchia_1970._get_property(self, attrname) is not None: found_prop = IJacchia_1970._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Jacchia_1970.")
        
agcls.AgClassCatalog.add_catalog_entry("{9E716F44-73D2-4A22-97C9-04C20386D575}", Jacchia_1970)


class Jacchia_1971(IJacchia_1971, IComponentInfo, ICloneable):
    """Jacchia_1971 atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IJacchia_1971.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IJacchia_1971._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IJacchia_1971._get_property(self, attrname) is not None: found_prop = IJacchia_1971._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Jacchia_1971.")
        
agcls.AgClassCatalog.add_catalog_entry("{50FFBB4C-124F-4DC6-BEED-F2EC4930B4E7}", Jacchia_1971)


class MSISE_1990(IMSISE_1990, IComponentInfo, ICloneable):
    """MSISE 1990 atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IMSISE_1990.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMSISE_1990._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMSISE_1990._get_property(self, attrname) is not None: found_prop = IMSISE_1990._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MSISE_1990.")
        
agcls.AgClassCatalog.add_catalog_entry("{A46341F0-9384-4A1D-970A-77B1B683359D}", MSISE_1990)


class MSIS_1986(IMSIS_1986, IComponentInfo, ICloneable):
    """MSIS 1986 atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IMSIS_1986.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMSIS_1986._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMSIS_1986._get_property(self, attrname) is not None: found_prop = IMSIS_1986._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MSIS_1986.")
        
agcls.AgClassCatalog.add_catalog_entry("{AFAC9D69-5B78-48BA-8CFA-5D6A30BBF371}", MSIS_1986)


class NRLMSISE_2000(INRLMSISE_2000, IComponentInfo, ICloneable):
    """NRLMSISE 2000 atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        INRLMSISE_2000.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        INRLMSISE_2000._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if INRLMSISE_2000._get_property(self, attrname) is not None: found_prop = INRLMSISE_2000._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in NRLMSISE_2000.")
        
agcls.AgClassCatalog.add_catalog_entry("{2EEE9C88-FF61-497A-AD40-2429DBA0A581}", NRLMSISE_2000)


class US_Standard_Atmosphere(IUS_Standard_Atmosphere, IComponentInfo, ICloneable):
    """US_Standard_Atmosphere atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IUS_Standard_Atmosphere.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IUS_Standard_Atmosphere._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IUS_Standard_Atmosphere._get_property(self, attrname) is not None: found_prop = IUS_Standard_Atmosphere._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in US_Standard_Atmosphere.")
        
agcls.AgClassCatalog.add_catalog_entry("{14714C17-B360-42E1-86EE-99EB95C71B69}", US_Standard_Atmosphere)


class MarsGRAM37(IMarsGRAM37, IComponentInfo, ICloneable):
    """Mars-GRAM 3.7 atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IMarsGRAM37.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMarsGRAM37._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMarsGRAM37._get_property(self, attrname) is not None: found_prop = IMarsGRAM37._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MarsGRAM37.")
        
agcls.AgClassCatalog.add_catalog_entry("{69A9AE89-0133-4410-A486-1ADEFBE56F49}", MarsGRAM37)


class MarsGRAM2000(IMarsGRAM2000, IComponentInfo, ICloneable):
    """Mars-GRAM 2000 atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IMarsGRAM2000.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMarsGRAM2000._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMarsGRAM2000._get_property(self, attrname) is not None: found_prop = IMarsGRAM2000._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MarsGRAM2000.")
        
agcls.AgClassCatalog.add_catalog_entry("{FB31A16E-8E6F-4F8F-8D2D-0E3D0C0020FC}", MarsGRAM2000)


class MarsGRAM2001(IMarsGRAM2001, IComponentInfo, ICloneable):
    """Mars-GRAM 2001 atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IMarsGRAM2001.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMarsGRAM2001._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMarsGRAM2001._get_property(self, attrname) is not None: found_prop = IMarsGRAM2001._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MarsGRAM2001.")
        
agcls.AgClassCatalog.add_catalog_entry("{F7A3F4ED-100F-463F-A9F5-177F49E44BA9}", MarsGRAM2001)


class MarsGRAM2005(IMarsGRAM2005, IComponentInfo, ICloneable):
    """Mars-GRAM 2005 atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IMarsGRAM2005.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMarsGRAM2005._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMarsGRAM2005._get_property(self, attrname) is not None: found_prop = IMarsGRAM2005._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MarsGRAM2005.")
        
agcls.AgClassCatalog.add_catalog_entry("{FD314E36-8513-484A-B46A-FC8794E939AC}", MarsGRAM2005)


class MarsGRAM2010(IMarsGRAM2010, IComponentInfo, ICloneable):
    """Mars-GRAM 2010 atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IMarsGRAM2010.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IMarsGRAM2010._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IMarsGRAM2010._get_property(self, attrname) is not None: found_prop = IMarsGRAM2010._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in MarsGRAM2010.")
        
agcls.AgClassCatalog.add_catalog_entry("{EE0F710B-25B2-4423-86BE-892E0F221376}", MarsGRAM2010)


class VenusGRAM2005(IVenusGRAM2005, IComponentInfo, ICloneable):
    """Venus-GRAM 2005 atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IVenusGRAM2005.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IVenusGRAM2005._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IVenusGRAM2005._get_property(self, attrname) is not None: found_prop = IVenusGRAM2005._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in VenusGRAM2005.")
        
agcls.AgClassCatalog.add_catalog_entry("{2360812C-F645-4237-889F-EF487FFC20D7}", VenusGRAM2005)


class DTM2012(IDTM2012, IComponentInfo, ICloneable):
    """DTM 2012 atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IDTM2012.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IDTM2012._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IDTM2012._get_property(self, attrname) is not None: found_prop = IDTM2012._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in DTM2012.")
        
agcls.AgClassCatalog.add_catalog_entry("{131D3F3F-8444-4017-B12F-D57DF1262F58}", DTM2012)


class DTM2020(IDTM2020, IComponentInfo, ICloneable):
    """DTM 2020 atmospheric propagator function."""
    def __init__(self, sourceObject=None):
        IDTM2020.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IDTM2020._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IDTM2020._get_property(self, attrname) is not None: found_prop = IDTM2020._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in DTM2020.")
        
agcls.AgClassCatalog.add_catalog_entry("{68457876-1EF6-4DD4-9295-E72570C4F97B}", DTM2020)


class GravityFieldFunction(IGravityFieldFunction, IComponentInfo, ICloneable):
    """Gravity Field gravity propagator function."""
    def __init__(self, sourceObject=None):
        IGravityFieldFunction.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IGravityFieldFunction._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IGravityFieldFunction._get_property(self, attrname) is not None: found_prop = IGravityFieldFunction._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in GravityFieldFunction.")
        
agcls.AgClassCatalog.add_catalog_entry("{C2C24055-1B50-4BD9-A7F7-0AA5FCE8969E}", GravityFieldFunction)


class PointMassFunction(IPointMassFunction, IComponentInfo, ICloneable):
    """Point Mass function."""
    def __init__(self, sourceObject=None):
        IPointMassFunction.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPointMassFunction._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPointMassFunction._get_property(self, attrname) is not None: found_prop = IPointMassFunction._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PointMassFunction.")
        
agcls.AgClassCatalog.add_catalog_entry("{E0A1592D-68C0-43DB-A338-DE22A591872A}", PointMassFunction)


class TwoBodyFunction(ITwoBodyFunction, IComponentInfo, ICloneable):
    """Two Body gravity propagator function."""
    def __init__(self, sourceObject=None):
        ITwoBodyFunction.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ITwoBodyFunction._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ITwoBodyFunction._get_property(self, attrname) is not None: found_prop = ITwoBodyFunction._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in TwoBodyFunction.")
        
agcls.AgClassCatalog.add_catalog_entry("{5C71D8C2-4A14-4D93-A8E5-5384AAB05E92}", TwoBodyFunction)


class HPOPPluginFunction(IHPOPPluginFunction, IComponentInfo, ICloneable):
    """HPOP Plugin propagator function."""
    def __init__(self, sourceObject=None):
        IHPOPPluginFunction.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IHPOPPluginFunction._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IHPOPPluginFunction._get_property(self, attrname) is not None: found_prop = IHPOPPluginFunction._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in HPOPPluginFunction.")
        
agcls.AgClassCatalog.add_catalog_entry("{01BF5EA2-376F-49B2-B6DF-3017F30D8205}", HPOPPluginFunction)


class EOMFuncPluginFunction(IEOMFuncPluginFunction, IComponentInfo, ICloneable):
    """EOM Function Plugin propagator function."""
    def __init__(self, sourceObject=None):
        IEOMFuncPluginFunction.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEOMFuncPluginFunction._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEOMFuncPluginFunction._get_property(self, attrname) is not None: found_prop = IEOMFuncPluginFunction._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EOMFuncPluginFunction.")
        
agcls.AgClassCatalog.add_catalog_entry("{6FCCD724-B386-487C-A2AD-6153FF4756FF}", EOMFuncPluginFunction)


class SRPAeroT20(ISRPAeroT20, IComponentInfo, ICloneable):
    """AeroT20 SRP propagator function."""
    def __init__(self, sourceObject=None):
        ISRPAeroT20.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISRPAeroT20._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISRPAeroT20._get_property(self, attrname) is not None: found_prop = ISRPAeroT20._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SRPAeroT20.")
        
agcls.AgClassCatalog.add_catalog_entry("{6DB3E760-F774-45F3-A6E5-EA2A7E34416F}", SRPAeroT20)


class SRPAeroT30(ISRPAeroT30, IComponentInfo, ICloneable):
    """AeroT30 SRP propagator function."""
    def __init__(self, sourceObject=None):
        ISRPAeroT30.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISRPAeroT30._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISRPAeroT30._get_property(self, attrname) is not None: found_prop = ISRPAeroT30._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SRPAeroT30.")
        
agcls.AgClassCatalog.add_catalog_entry("{E4DF0601-9442-4649-AE24-516F20E819EF}", SRPAeroT30)


class SRPGSPM04aIIA(ISRPGSPM04aIIA, IComponentInfo, ICloneable):
    """GSPM04aIIA SRP propagator function."""
    def __init__(self, sourceObject=None):
        ISRPGSPM04aIIA.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISRPGSPM04aIIA._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISRPGSPM04aIIA._get_property(self, attrname) is not None: found_prop = ISRPGSPM04aIIA._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SRPGSPM04aIIA.")
        
agcls.AgClassCatalog.add_catalog_entry("{F6767C08-2100-464C-B18A-0528243E37DC}", SRPGSPM04aIIA)


class SRPGSPM04aIIR(ISRPGSPM04aIIR, IComponentInfo, ICloneable):
    """GSPM04aIIR SRP propagator function."""
    def __init__(self, sourceObject=None):
        ISRPGSPM04aIIR.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISRPGSPM04aIIR._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISRPGSPM04aIIR._get_property(self, attrname) is not None: found_prop = ISRPGSPM04aIIR._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SRPGSPM04aIIR.")
        
agcls.AgClassCatalog.add_catalog_entry("{FFF24BB0-8E3E-479A-957A-06719DF68A56}", SRPGSPM04aIIR)


class SRPGSPM04aeIIA(ISRPGSPM04aeIIA, IComponentInfo, ICloneable):
    """GSPM04aeIIA SRP propagator function."""
    def __init__(self, sourceObject=None):
        ISRPGSPM04aeIIA.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISRPGSPM04aeIIA._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISRPGSPM04aeIIA._get_property(self, attrname) is not None: found_prop = ISRPGSPM04aeIIA._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SRPGSPM04aeIIA.")
        
agcls.AgClassCatalog.add_catalog_entry("{82530B89-B383-4148-8606-BBA0EBA825CE}", SRPGSPM04aeIIA)


class SRPGSPM04aeIIR(ISRPGSPM04aeIIR, IComponentInfo, ICloneable):
    """GSPM04aeIIR SRP propagator function."""
    def __init__(self, sourceObject=None):
        ISRPGSPM04aeIIR.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISRPGSPM04aeIIR._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISRPGSPM04aeIIR._get_property(self, attrname) is not None: found_prop = ISRPGSPM04aeIIR._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SRPGSPM04aeIIR.")
        
agcls.AgClassCatalog.add_catalog_entry("{17C9AD04-9981-4541-9515-59A597003348}", SRPGSPM04aeIIR)


class SRPSpherical(ISRPSpherical, IComponentInfo, ICloneable):
    """Spherical SRP propagator function."""
    def __init__(self, sourceObject=None):
        ISRPSpherical.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISRPSpherical._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISRPSpherical._get_property(self, attrname) is not None: found_prop = ISRPSpherical._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SRPSpherical.")
        
agcls.AgClassCatalog.add_catalog_entry("{4318B037-C619-4722-A0F5-4FFDFA7D9474}", SRPSpherical)


class SRPNPlate(ISRPNPlate, IComponentInfo, ICloneable):
    """NPlate SRP propagator function."""
    def __init__(self, sourceObject=None):
        ISRPNPlate.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISRPNPlate._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISRPNPlate._get_property(self, attrname) is not None: found_prop = ISRPNPlate._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SRPNPlate.")
        
agcls.AgClassCatalog.add_catalog_entry("{81962DC5-1A26-4077-AC39-E8E75145858A}", SRPNPlate)


class SRPTabAreaVec(ISRPTabAreaVec, IComponentInfo, ICloneable):
    """Tabulated area vector SRP propagator function."""
    def __init__(self, sourceObject=None):
        ISRPTabAreaVec.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISRPTabAreaVec._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISRPTabAreaVec._get_property(self, attrname) is not None: found_prop = ISRPTabAreaVec._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SRPTabAreaVec.")
        
agcls.AgClassCatalog.add_catalog_entry("{77FAE0BD-36AF-4140-B62E-7B2865841152}", SRPTabAreaVec)


class SRPVariableArea(ISRPVariableArea, IComponentInfo, ICloneable):
    """Variable Area SRP propagator function."""
    def __init__(self, sourceObject=None):
        ISRPVariableArea.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISRPVariableArea._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISRPVariableArea._get_property(self, attrname) is not None: found_prop = ISRPVariableArea._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SRPVariableArea.")
        
agcls.AgClassCatalog.add_catalog_entry("{193838B2-807F-4E24-A05D-2E0BAB03B497}", SRPVariableArea)


class ThirdBodyFunction(IThirdBodyFunction, IComponentInfo, ICloneable):
    """ThirdBody propagator function."""
    def __init__(self, sourceObject=None):
        IThirdBodyFunction.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IThirdBodyFunction._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IThirdBodyFunction._get_property(self, attrname) is not None: found_prop = IThirdBodyFunction._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ThirdBodyFunction.")
        
agcls.AgClassCatalog.add_catalog_entry("{7E7DF54F-A10B-4B57-9919-ACD123F69001}", ThirdBodyFunction)


class DragModelPlugin(IDragModelPlugin, IComponentInfo, ICloneable):
    """Drag Model Plugin."""
    def __init__(self, sourceObject=None):
        IDragModelPlugin.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IDragModelPlugin._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IDragModelPlugin._get_property(self, attrname) is not None: found_prop = IDragModelPlugin._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in DragModelPlugin.")
        
agcls.AgClassCatalog.add_catalog_entry("{C48CB2A8-A6E1-4E7B-ABB2-179D1E06D541}", DragModelPlugin)


class SRPReflectionPlugin(ISRPReflectionPlugin, IComponentInfo, ICloneable):
    """SRP Reflection Plugin."""
    def __init__(self, sourceObject=None):
        ISRPReflectionPlugin.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISRPReflectionPlugin._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISRPReflectionPlugin._get_property(self, attrname) is not None: found_prop = ISRPReflectionPlugin._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SRPReflectionPlugin.")
        
agcls.AgClassCatalog.add_catalog_entry("{926296A2-EA6B-4FC8-A75C-15B9F24B85E5}", SRPReflectionPlugin)


class EngineConstAcc(IEngineConstAcc, IComponentInfo, ICloneable):
    """Constant Acceleration engine model."""
    def __init__(self, sourceObject=None):
        IEngineConstAcc.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEngineConstAcc._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEngineConstAcc._get_property(self, attrname) is not None: found_prop = IEngineConstAcc._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EngineConstAcc.")
        
agcls.AgClassCatalog.add_catalog_entry("{359488A0-BCA3-4739-8614-E99B675553AF}", EngineConstAcc)


class EngineConstant(IEngineConstant, IComponentInfo, ICloneable):
    """Constant Thrust engine model."""
    def __init__(self, sourceObject=None):
        IEngineConstant.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEngineConstant._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEngineConstant._get_property(self, attrname) is not None: found_prop = IEngineConstant._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EngineConstant.")
        
agcls.AgClassCatalog.add_catalog_entry("{31105070-4B5A-4870-A45B-6F6CF13042DD}", EngineConstant)


class EngineIon(IEngineIon, IComponentInfo, ICloneable):
    """Ion Engine engine model."""
    def __init__(self, sourceObject=None):
        IEngineIon.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEngineIon._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEngineIon._get_property(self, attrname) is not None: found_prop = IEngineIon._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EngineIon.")
        
agcls.AgClassCatalog.add_catalog_entry("{6AD7EC4F-2E59-4D7B-9FC2-9022CB8540B6}", EngineIon)


class EngineThrottleTable(IEngineThrottleTable, IComponentInfo, ICloneable):
    """Throttle Table engine model."""
    def __init__(self, sourceObject=None):
        IEngineThrottleTable.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEngineThrottleTable._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEngineThrottleTable._get_property(self, attrname) is not None: found_prop = IEngineThrottleTable._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EngineThrottleTable.")
        
agcls.AgClassCatalog.add_catalog_entry("{FB947497-4C0D-4F39-9942-31A9A0D3025F}", EngineThrottleTable)


class EngineCustom(IEngineCustom, IComponentInfo, ICloneable):
    """Custom engine model."""
    def __init__(self, sourceObject=None):
        IEngineCustom.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEngineCustom._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEngineCustom._get_property(self, attrname) is not None: found_prop = IEngineCustom._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EngineCustom.")
        
agcls.AgClassCatalog.add_catalog_entry("{5C0367CE-254E-4BDB-8056-ED27D584258E}", EngineCustom)


class EnginePlugin(IEnginePlugin, IComponentInfo, ICloneable):
    """Plugin engine model."""
    def __init__(self, sourceObject=None):
        IEnginePlugin.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEnginePlugin._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEnginePlugin._get_property(self, attrname) is not None: found_prop = IEnginePlugin._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EnginePlugin.")
        
agcls.AgClassCatalog.add_catalog_entry("{D7755FC3-1A9F-4DB5-B735-030256F4AE24}", EnginePlugin)


class EngineModelPoly(IEngineModelPoly, IComponentInfo, ICloneable):
    """Polynomial Thrust and Isp engine model."""
    def __init__(self, sourceObject=None):
        IEngineModelPoly.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEngineModelPoly._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEngineModelPoly._get_property(self, attrname) is not None: found_prop = IEngineModelPoly._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EngineModelPoly.")
        
agcls.AgClassCatalog.add_catalog_entry("{0D23F634-A8B8-4376-99AE-F8287C267EDC}", EngineModelPoly)


class EngineModelThrustCoefficients(IEngineModelThrustCoefficients):
    """Engine Model Thrust Coefficients."""
    def __init__(self, sourceObject=None):
        IEngineModelThrustCoefficients.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEngineModelThrustCoefficients._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEngineModelThrustCoefficients._get_property(self, attrname) is not None: found_prop = IEngineModelThrustCoefficients._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EngineModelThrustCoefficients.")
        
agcls.AgClassCatalog.add_catalog_entry("{1B8E6E69-F100-4A4B-A24A-FFC3C8B0AF70}", EngineModelThrustCoefficients)


class EngineModelIspCoefficients(IEngineModelIspCoefficients):
    """Engine Model Isp Coefficients."""
    def __init__(self, sourceObject=None):
        IEngineModelIspCoefficients.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEngineModelIspCoefficients._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEngineModelIspCoefficients._get_property(self, attrname) is not None: found_prop = IEngineModelIspCoefficients._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EngineModelIspCoefficients.")
        
agcls.AgClassCatalog.add_catalog_entry("{279B11AE-A5F8-4548-9401-95981B21C61C}", EngineModelIspCoefficients)


class EngineDefinition(IEngineDefinition):
    """Engine definition."""
    def __init__(self, sourceObject=None):
        IEngineDefinition.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IEngineDefinition._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IEngineDefinition._get_property(self, attrname) is not None: found_prop = IEngineDefinition._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in EngineDefinition.")
        
agcls.AgClassCatalog.add_catalog_entry("{F87429C7-51DC-4AD8-8481-468C14F38AB4}", EngineDefinition)


class DesignCR3BPSetup(IDesignCR3BPSetup, IComponentInfo, ICloneable):
    """CR3BP Setup Tool."""
    def __init__(self, sourceObject=None):
        IDesignCR3BPSetup.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IDesignCR3BPSetup._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IDesignCR3BPSetup._get_property(self, attrname) is not None: found_prop = IDesignCR3BPSetup._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in DesignCR3BPSetup.")
        
agcls.AgClassCatalog.add_catalog_entry("{97419F0F-66BA-4C13-800E-56D8856CAAA3}", DesignCR3BPSetup)


class DesignCR3BPObject(IDesignCR3BPObject):
    """CR3BP associated object definition."""
    def __init__(self, sourceObject=None):
        IDesignCR3BPObject.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IDesignCR3BPObject._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IDesignCR3BPObject._get_property(self, attrname) is not None: found_prop = IDesignCR3BPObject._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in DesignCR3BPObject.")
        
agcls.AgClassCatalog.add_catalog_entry("{2256C391-AE04-462C-8A4F-5D00D522112D}", DesignCR3BPObject)


class DesignCR3BPObjectCollection(IDesignCR3BPObjectCollection):
    """CR3BP associated object Collection."""
    def __init__(self, sourceObject=None):
        IDesignCR3BPObjectCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IDesignCR3BPObjectCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IDesignCR3BPObjectCollection._get_property(self, attrname) is not None: found_prop = IDesignCR3BPObjectCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in DesignCR3BPObjectCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{A70D32B8-E717-449E-8A79-29E429BED03F}", DesignCR3BPObjectCollection)


class Thruster(IThruster):
    """Thruster definition."""
    def __init__(self, sourceObject=None):
        IThruster.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IThruster._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IThruster._get_property(self, attrname) is not None: found_prop = IThruster._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in Thruster.")
        
agcls.AgClassCatalog.add_catalog_entry("{749FEA15-5BD9-4466-BADF-E917D640E6D8}", Thruster)


class ThrusterSetCollection(IThrusterSetCollection):
    """Thruster Set Collection."""
    def __init__(self, sourceObject=None):
        IThrusterSetCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IThrusterSetCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IThrusterSetCollection._get_property(self, attrname) is not None: found_prop = IThrusterSetCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ThrusterSetCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{8C1B379E-8092-48BE-A401-651464239B27}", ThrusterSetCollection)


class ThrusterSet(IThrusterSet, IComponentInfo, ICloneable):
    """Thruster Set."""
    def __init__(self, sourceObject=None):
        IThrusterSet.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IThrusterSet._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IThrusterSet._get_property(self, attrname) is not None: found_prop = IThrusterSet._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ThrusterSet.")
        
agcls.AgClassCatalog.add_catalog_entry("{00FB61C4-5A63-439B-A030-171588D7CFED}", ThrusterSet)


class AsTriggerCondition(IAsTriggerCondition, IComponentInfo, ICloneable):
    """Constraint."""
    def __init__(self, sourceObject=None):
        IAsTriggerCondition.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IAsTriggerCondition._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IAsTriggerCondition._get_property(self, attrname) is not None: found_prop = IAsTriggerCondition._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in AsTriggerCondition.")
        
agcls.AgClassCatalog.add_catalog_entry("{32E146B0-C168-4BD3-A2D9-ECF7096687E5}", AsTriggerCondition)


class CustomFunctionScriptEngine(ICustomFunctionScriptEngine, IComponentInfo, ICloneable):
    """Custom Function Script Engine."""
    def __init__(self, sourceObject=None):
        ICustomFunctionScriptEngine.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICustomFunctionScriptEngine._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICustomFunctionScriptEngine._get_property(self, attrname) is not None: found_prop = ICustomFunctionScriptEngine._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CustomFunctionScriptEngine.")
        
agcls.AgClassCatalog.add_catalog_entry("{F4CD79CC-CFAA-4EEE-A01A-0F846D6F6674}", CustomFunctionScriptEngine)


class NumericalPropagatorWrapper(INumericalPropagatorWrapper, IComponentInfo, ICloneable):
    """Numerical Propagator."""
    def __init__(self, sourceObject=None):
        INumericalPropagatorWrapper.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        INumericalPropagatorWrapper._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if INumericalPropagatorWrapper._get_property(self, attrname) is not None: found_prop = INumericalPropagatorWrapper._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in NumericalPropagatorWrapper.")
        
agcls.AgClassCatalog.add_catalog_entry("{6F733B37-D5A3-4D83-844B-34A35BA937CC}", NumericalPropagatorWrapper)


class NumericalPropagatorWrapperCR3BP(INumericalPropagatorWrapperCR3BP, IComponentInfo, ICloneable):
    """Numerical CR3BP Propagator."""
    def __init__(self, sourceObject=None):
        INumericalPropagatorWrapperCR3BP.__init__(self, sourceObject)
        IComponentInfo.__init__(self, sourceObject)
        ICloneable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        INumericalPropagatorWrapperCR3BP._private_init(self, pUnk)
        IComponentInfo._private_init(self, pUnk)
        ICloneable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if INumericalPropagatorWrapperCR3BP._get_property(self, attrname) is not None: found_prop = INumericalPropagatorWrapperCR3BP._get_property(self, attrname)
        if IComponentInfo._get_property(self, attrname) is not None: found_prop = IComponentInfo._get_property(self, attrname)
        if ICloneable._get_property(self, attrname) is not None: found_prop = ICloneable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in NumericalPropagatorWrapperCR3BP.")
        
agcls.AgClassCatalog.add_catalog_entry("{C4823BEE-E898-47D3-8C29-9CCE6DB490FE}", NumericalPropagatorWrapperCR3BP)


class PropagatorFunctionCollection(IPropagatorFunctionCollection):
    """Propagator Function Collection."""
    def __init__(self, sourceObject=None):
        IPropagatorFunctionCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IPropagatorFunctionCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IPropagatorFunctionCollection._get_property(self, attrname) is not None: found_prop = IPropagatorFunctionCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in PropagatorFunctionCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{41440862-0DA5-41B0-9A84-073FBC64D47A}", PropagatorFunctionCollection)


class BulirschStoerIntegrator(IBulirschStoerIntegrator, INumericalIntegrator):
    """Bulirsch-Stoer Numerical Integrator."""
    def __init__(self, sourceObject=None):
        IBulirschStoerIntegrator.__init__(self, sourceObject)
        INumericalIntegrator.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBulirschStoerIntegrator._private_init(self, pUnk)
        INumericalIntegrator._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBulirschStoerIntegrator._get_property(self, attrname) is not None: found_prop = IBulirschStoerIntegrator._get_property(self, attrname)
        if INumericalIntegrator._get_property(self, attrname) is not None: found_prop = INumericalIntegrator._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BulirschStoerIntegrator.")
        
agcls.AgClassCatalog.add_catalog_entry("{B98456C5-48DE-41AB-867B-FD713A325418}", BulirschStoerIntegrator)


class GaussJacksonIntegrator(IGaussJacksonIntegrator, INumericalIntegrator):
    """Gauss-Jackson Numerical Integrator."""
    def __init__(self, sourceObject=None):
        IGaussJacksonIntegrator.__init__(self, sourceObject)
        INumericalIntegrator.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IGaussJacksonIntegrator._private_init(self, pUnk)
        INumericalIntegrator._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IGaussJacksonIntegrator._get_property(self, attrname) is not None: found_prop = IGaussJacksonIntegrator._get_property(self, attrname)
        if INumericalIntegrator._get_property(self, attrname) is not None: found_prop = INumericalIntegrator._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in GaussJacksonIntegrator.")
        
agcls.AgClassCatalog.add_catalog_entry("{034F55EC-4D6E-4C22-9811-C3DEBC83ABD9}", GaussJacksonIntegrator)


class RungeKutta2nd3rd(IRungeKutta2nd3rd, INumericalIntegrator):
    """RK2nd3rd Numerical Integrator."""
    def __init__(self, sourceObject=None):
        IRungeKutta2nd3rd.__init__(self, sourceObject)
        INumericalIntegrator.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IRungeKutta2nd3rd._private_init(self, pUnk)
        INumericalIntegrator._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRungeKutta2nd3rd._get_property(self, attrname) is not None: found_prop = IRungeKutta2nd3rd._get_property(self, attrname)
        if INumericalIntegrator._get_property(self, attrname) is not None: found_prop = INumericalIntegrator._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in RungeKutta2nd3rd.")
        
agcls.AgClassCatalog.add_catalog_entry("{F3511C10-B4F1-4592-81AC-41D387A9589B}", RungeKutta2nd3rd)


class RungeKutta4th(IRungeKutta4th, INumericalIntegrator):
    """RK4th Numerical Integrator."""
    def __init__(self, sourceObject=None):
        IRungeKutta4th.__init__(self, sourceObject)
        INumericalIntegrator.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IRungeKutta4th._private_init(self, pUnk)
        INumericalIntegrator._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRungeKutta4th._get_property(self, attrname) is not None: found_prop = IRungeKutta4th._get_property(self, attrname)
        if INumericalIntegrator._get_property(self, attrname) is not None: found_prop = INumericalIntegrator._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in RungeKutta4th.")
        
agcls.AgClassCatalog.add_catalog_entry("{019C798B-5AB2-42F1-847E-AC64438C8341}", RungeKutta4th)


class RungeKutta4th5th(IRungeKutta4th5th, INumericalIntegrator):
    """RK4th5th Numerical Integrator."""
    def __init__(self, sourceObject=None):
        IRungeKutta4th5th.__init__(self, sourceObject)
        INumericalIntegrator.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IRungeKutta4th5th._private_init(self, pUnk)
        INumericalIntegrator._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRungeKutta4th5th._get_property(self, attrname) is not None: found_prop = IRungeKutta4th5th._get_property(self, attrname)
        if INumericalIntegrator._get_property(self, attrname) is not None: found_prop = INumericalIntegrator._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in RungeKutta4th5th.")
        
agcls.AgClassCatalog.add_catalog_entry("{25B6537D-FF33-45E7-A314-F6E4EFA34CD5}", RungeKutta4th5th)


class RungeKutta4thAdapt(IRungeKutta4thAdapt, INumericalIntegrator):
    """RK4thAdapt Numerical Integrator."""
    def __init__(self, sourceObject=None):
        IRungeKutta4thAdapt.__init__(self, sourceObject)
        INumericalIntegrator.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IRungeKutta4thAdapt._private_init(self, pUnk)
        INumericalIntegrator._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRungeKutta4thAdapt._get_property(self, attrname) is not None: found_prop = IRungeKutta4thAdapt._get_property(self, attrname)
        if INumericalIntegrator._get_property(self, attrname) is not None: found_prop = INumericalIntegrator._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in RungeKutta4thAdapt.")
        
agcls.AgClassCatalog.add_catalog_entry("{03F69912-84E6-4209-8AF5-FD2C4B009C44}", RungeKutta4thAdapt)


class RungeKuttaF7th8th(IRungeKuttaF7th8th, INumericalIntegrator):
    """RKF7th8th Numerical Integrator."""
    def __init__(self, sourceObject=None):
        IRungeKuttaF7th8th.__init__(self, sourceObject)
        INumericalIntegrator.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IRungeKuttaF7th8th._private_init(self, pUnk)
        INumericalIntegrator._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRungeKuttaF7th8th._get_property(self, attrname) is not None: found_prop = IRungeKuttaF7th8th._get_property(self, attrname)
        if INumericalIntegrator._get_property(self, attrname) is not None: found_prop = INumericalIntegrator._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in RungeKuttaF7th8th.")
        
agcls.AgClassCatalog.add_catalog_entry("{78A98F0E-B687-4D64-B0F6-5608105504CC}", RungeKuttaF7th8th)


class RungeKuttaV8th9th(IRungeKuttaV8th9th, INumericalIntegrator):
    """RKV8th9th Numerical Integrator."""
    def __init__(self, sourceObject=None):
        IRungeKuttaV8th9th.__init__(self, sourceObject)
        INumericalIntegrator.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IRungeKuttaV8th9th._private_init(self, pUnk)
        INumericalIntegrator._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IRungeKuttaV8th9th._get_property(self, attrname) is not None: found_prop = IRungeKuttaV8th9th._get_property(self, attrname)
        if INumericalIntegrator._get_property(self, attrname) is not None: found_prop = INumericalIntegrator._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in RungeKuttaV8th9th.")
        
agcls.AgClassCatalog.add_catalog_entry("{26857B4B-40C9-4EC2-B5F7-AFEB6103128D}", RungeKuttaV8th9th)


class ScriptingTool(IScriptingTool, IRuntimeTypeInfoProvider):
    """Scripting Tool."""
    def __init__(self, sourceObject=None):
        IScriptingTool.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IScriptingTool._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IScriptingTool._get_property(self, attrname) is not None: found_prop = IScriptingTool._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ScriptingTool.")
        
agcls.AgClassCatalog.add_catalog_entry("{1FB508B7-F4D9-4ABF-8EA8-B44AECAEE9C0}", ScriptingTool)


class ScriptingSegmentCollection(IScriptingSegmentCollection, IRuntimeTypeInfoProvider):
    """Scripting Segment Collection."""
    def __init__(self, sourceObject=None):
        IScriptingSegmentCollection.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IScriptingSegmentCollection._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IScriptingSegmentCollection._get_property(self, attrname) is not None: found_prop = IScriptingSegmentCollection._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ScriptingSegmentCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{2D397364-3CD3-4FC2-8B11-D74D7A348687}", ScriptingSegmentCollection)


class ScriptingSegment(IScriptingSegment, IRuntimeTypeInfoProvider):
    """Scripting Segment."""
    def __init__(self, sourceObject=None):
        IScriptingSegment.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IScriptingSegment._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IScriptingSegment._get_property(self, attrname) is not None: found_prop = IScriptingSegment._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ScriptingSegment.")
        
agcls.AgClassCatalog.add_catalog_entry("{FD68184D-BA0A-41EC-B03E-E63514058625}", ScriptingSegment)


class ScriptingParameterCollection(IScriptingParameterCollection, IRuntimeTypeInfoProvider):
    """Scripting Parameter Collection."""
    def __init__(self, sourceObject=None):
        IScriptingParameterCollection.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IScriptingParameterCollection._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IScriptingParameterCollection._get_property(self, attrname) is not None: found_prop = IScriptingParameterCollection._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ScriptingParameterCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{F7B45439-8E25-43DE-882F-844F8645F015}", ScriptingParameterCollection)


class ScriptingParameter(IScriptingParameter, IRuntimeTypeInfoProvider):
    """Scripting Parameter."""
    def __init__(self, sourceObject=None):
        IScriptingParameter.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IScriptingParameter._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IScriptingParameter._get_property(self, attrname) is not None: found_prop = IScriptingParameter._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ScriptingParameter.")
        
agcls.AgClassCatalog.add_catalog_entry("{92BFA902-938E-48E0-B402-C6DEE9169BEE}", ScriptingParameter)


class ScriptingCalcObject(IScriptingCalcObject):
    """Calc Object."""
    def __init__(self, sourceObject=None):
        IScriptingCalcObject.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IScriptingCalcObject._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IScriptingCalcObject._get_property(self, attrname) is not None: found_prop = IScriptingCalcObject._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ScriptingCalcObject.")
        
agcls.AgClassCatalog.add_catalog_entry("{D9895635-D8A5-497F-9C4D-E0A18AF49983}", ScriptingCalcObject)


class ScriptingCalcObjectCollection(IScriptingCalcObjectCollection):
    """Calc Object Collection."""
    def __init__(self, sourceObject=None):
        IScriptingCalcObjectCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IScriptingCalcObjectCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IScriptingCalcObjectCollection._get_property(self, attrname) is not None: found_prop = IScriptingCalcObjectCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ScriptingCalcObjectCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{9FC08736-F254-451E-9292-C003D5601780}", ScriptingCalcObjectCollection)


class UserVariableDefinition(IUserVariableDefinition):
    """User Variable Definition"""
    def __init__(self, sourceObject=None):
        IUserVariableDefinition.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IUserVariableDefinition._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IUserVariableDefinition._get_property(self, attrname) is not None: found_prop = IUserVariableDefinition._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in UserVariableDefinition.")
        
agcls.AgClassCatalog.add_catalog_entry("{659E4C4D-E224-47D7-A899-C9B5DCF7241F}", UserVariableDefinition)


class UserVariable(IUserVariable):
    """User Variable"""
    def __init__(self, sourceObject=None):
        IUserVariable.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IUserVariable._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IUserVariable._get_property(self, attrname) is not None: found_prop = IUserVariable._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in UserVariable.")
        
agcls.AgClassCatalog.add_catalog_entry("{437599F8-0E00-4984-81CA-B450200257BC}", UserVariable)


class UserVariableUpdate(IUserVariableUpdate):
    """User Variable Update"""
    def __init__(self, sourceObject=None):
        IUserVariableUpdate.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IUserVariableUpdate._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IUserVariableUpdate._get_property(self, attrname) is not None: found_prop = IUserVariableUpdate._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in UserVariableUpdate.")
        
agcls.AgClassCatalog.add_catalog_entry("{EB1FC76A-82D7-43C1-919B-05F53CEFC2ED}", UserVariableUpdate)


class UserVariableDefinitionCollection(IUserVariableDefinitionCollection):
    """User Variable Definition Collection."""
    def __init__(self, sourceObject=None):
        IUserVariableDefinitionCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IUserVariableDefinitionCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IUserVariableDefinitionCollection._get_property(self, attrname) is not None: found_prop = IUserVariableDefinitionCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in UserVariableDefinitionCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{E1D09185-E7EC-4E3F-BFEF-52AC92FEEC75}", UserVariableDefinitionCollection)


class UserVariableCollection(IUserVariableCollection):
    """User Variable Initial Value Collection."""
    def __init__(self, sourceObject=None):
        IUserVariableCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IUserVariableCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IUserVariableCollection._get_property(self, attrname) is not None: found_prop = IUserVariableCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in UserVariableCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{801C61FA-C0FE-4BFD-8001-3335211F7328}", UserVariableCollection)


class UserVariableUpdateCollection(IUserVariableUpdateCollection):
    """User Variable Update Collection"""
    def __init__(self, sourceObject=None):
        IUserVariableUpdateCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IUserVariableUpdateCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IUserVariableUpdateCollection._get_property(self, attrname) is not None: found_prop = IUserVariableUpdateCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in UserVariableUpdateCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{FD7D6D39-4E5B-41E1-84E2-CBCAE8ECCF41}", UserVariableUpdateCollection)


class CalculationGraphCollection(ICalculationGraphCollection):
    """Calculation Graph Collection."""
    def __init__(self, sourceObject=None):
        ICalculationGraphCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalculationGraphCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalculationGraphCollection._get_property(self, attrname) is not None: found_prop = ICalculationGraphCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalculationGraphCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{40E20BE7-7961-468B-B396-8F6E980BE49E}", CalculationGraphCollection)


class ScriptingParameterEnumerationChoice(IScriptingParameterEnumerationChoice, IRuntimeTypeInfoProvider):
    """Scripting Parameter Enumeration Choice."""
    def __init__(self, sourceObject=None):
        IScriptingParameterEnumerationChoice.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IScriptingParameterEnumerationChoice._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IScriptingParameterEnumerationChoice._get_property(self, attrname) is not None: found_prop = IScriptingParameterEnumerationChoice._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ScriptingParameterEnumerationChoice.")
        
agcls.AgClassCatalog.add_catalog_entry("{82A982C2-A2AD-4FD8-AB46-A54866F56AEA}", ScriptingParameterEnumerationChoice)


class ScriptingParameterEnumerationChoiceCollection(IScriptingParameterEnumerationChoiceCollection, IRuntimeTypeInfoProvider):
    """Scripting Parameter Enumeration Choice Collection"""
    def __init__(self, sourceObject=None):
        IScriptingParameterEnumerationChoiceCollection.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IScriptingParameterEnumerationChoiceCollection._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IScriptingParameterEnumerationChoiceCollection._get_property(self, attrname) is not None: found_prop = IScriptingParameterEnumerationChoiceCollection._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ScriptingParameterEnumerationChoiceCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{E4F13182-12CE-420B-AC3A-8530CC46BE35}", ScriptingParameterEnumerationChoiceCollection)


class ProfileSNOPTOptimizer(IProfileSNOPTOptimizer, IProfile, IRuntimeTypeInfoProvider):
    """SNOPT optimizer profile"""
    def __init__(self, sourceObject=None):
        IProfileSNOPTOptimizer.__init__(self, sourceObject)
        IProfile.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProfileSNOPTOptimizer._private_init(self, pUnk)
        IProfile._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProfileSNOPTOptimizer._get_property(self, attrname) is not None: found_prop = IProfileSNOPTOptimizer._get_property(self, attrname)
        if IProfile._get_property(self, attrname) is not None: found_prop = IProfile._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProfileSNOPTOptimizer.")
        
agcls.AgClassCatalog.add_catalog_entry("{6F7AFA8D-FC45-4955-BEFB-BDE94553C02E}", ProfileSNOPTOptimizer)


class SNOPTControl(ISNOPTControl):
    """Control parameters for SNOPT optimizer profile"""
    def __init__(self, sourceObject=None):
        ISNOPTControl.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISNOPTControl._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISNOPTControl._get_property(self, attrname) is not None: found_prop = ISNOPTControl._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SNOPTControl.")
        
agcls.AgClassCatalog.add_catalog_entry("{5CD8E3EB-8BCA-4D53-A361-484285E62C96}", SNOPTControl)


class SNOPTResult(ISNOPTResult):
    """Properties for objecvtive and constraints of a SNOPT profile."""
    def __init__(self, sourceObject=None):
        ISNOPTResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISNOPTResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISNOPTResult._get_property(self, attrname) is not None: found_prop = ISNOPTResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SNOPTResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{F739575C-EF90-4B58-917A-BD0C12C95055}", SNOPTResult)


class SNOPTControlCollection(ISNOPTControlCollection):
    """SNOPT control collection."""
    def __init__(self, sourceObject=None):
        ISNOPTControlCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISNOPTControlCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISNOPTControlCollection._get_property(self, attrname) is not None: found_prop = ISNOPTControlCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SNOPTControlCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{99EECA52-DE6C-4E2C-805E-725A3A009E4B}", SNOPTControlCollection)


class SNOPTResultCollection(ISNOPTResultCollection):
    """SNOPT result collection."""
    def __init__(self, sourceObject=None):
        ISNOPTResultCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ISNOPTResultCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ISNOPTResultCollection._get_property(self, attrname) is not None: found_prop = ISNOPTResultCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in SNOPTResultCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{D27CBF33-3EC4-40A0-A138-5F41720B0B08}", SNOPTResultCollection)


class ProfileIPOPTOptimizer(IProfileIPOPTOptimizer, IProfile, IRuntimeTypeInfoProvider):
    """IPOPT optimizer profile"""
    def __init__(self, sourceObject=None):
        IProfileIPOPTOptimizer.__init__(self, sourceObject)
        IProfile.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProfileIPOPTOptimizer._private_init(self, pUnk)
        IProfile._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProfileIPOPTOptimizer._get_property(self, attrname) is not None: found_prop = IProfileIPOPTOptimizer._get_property(self, attrname)
        if IProfile._get_property(self, attrname) is not None: found_prop = IProfile._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProfileIPOPTOptimizer.")
        
agcls.AgClassCatalog.add_catalog_entry("{59AB8108-2D2E-4D46-8B96-F1F43175CC77}", ProfileIPOPTOptimizer)


class IPOPTControl(IIPOPTControl):
    """Control parameters for IPOPT optimizer profile"""
    def __init__(self, sourceObject=None):
        IIPOPTControl.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IIPOPTControl._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IIPOPTControl._get_property(self, attrname) is not None: found_prop = IIPOPTControl._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPOPTControl.")
        
agcls.AgClassCatalog.add_catalog_entry("{F7FF56DA-D284-4B28-88EC-BEE49D7E0CFD}", IPOPTControl)


class IPOPTResult(IIPOPTResult):
    """Properties for objecvtive and constraints of a IPOPT profile."""
    def __init__(self, sourceObject=None):
        IIPOPTResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IIPOPTResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IIPOPTResult._get_property(self, attrname) is not None: found_prop = IIPOPTResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPOPTResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{DCFD15D6-9ACF-4FCB-B968-CB74B5E95B33}", IPOPTResult)


class IPOPTControlCollection(IIPOPTControlCollection):
    """Properties for the list of IPOPT control parameters."""
    def __init__(self, sourceObject=None):
        IIPOPTControlCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IIPOPTControlCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IIPOPTControlCollection._get_property(self, attrname) is not None: found_prop = IIPOPTControlCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPOPTControlCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{522C81BC-6FFF-40FE-90C7-E4368FD1548D}", IPOPTControlCollection)


class IPOPTResultCollection(IIPOPTResultCollection):
    """IPOPT result collection."""
    def __init__(self, sourceObject=None):
        IIPOPTResultCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IIPOPTResultCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IIPOPTResultCollection._get_property(self, attrname) is not None: found_prop = IIPOPTResultCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in IPOPTResultCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{4A10E1B9-87A1-4370-AAD8-F7856B099B5C}", IPOPTResultCollection)


class ManeuverOptimalFinite(IManeuverOptimalFinite, IManeuver, IRuntimeTypeInfoProvider):
    """The Optimal Finite Maneuver."""
    def __init__(self, sourceObject=None):
        IManeuverOptimalFinite.__init__(self, sourceObject)
        IManeuver.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IManeuverOptimalFinite._private_init(self, pUnk)
        IManeuver._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IManeuverOptimalFinite._get_property(self, attrname) is not None: found_prop = IManeuverOptimalFinite._get_property(self, attrname)
        if IManeuver._get_property(self, attrname) is not None: found_prop = IManeuver._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ManeuverOptimalFinite.")
        
agcls.AgClassCatalog.add_catalog_entry("{6666593F-246D-4263-A0E4-78EFD0C04C7B}", ManeuverOptimalFinite)


class ManeuverOptimalFiniteSNOPTOptimizer(IManeuverOptimalFiniteSNOPTOptimizer):
    """Properties of SNOPT Optimizer options for optimal finite maneuver."""
    def __init__(self, sourceObject=None):
        IManeuverOptimalFiniteSNOPTOptimizer.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IManeuverOptimalFiniteSNOPTOptimizer._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IManeuverOptimalFiniteSNOPTOptimizer._get_property(self, attrname) is not None: found_prop = IManeuverOptimalFiniteSNOPTOptimizer._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ManeuverOptimalFiniteSNOPTOptimizer.")
        
agcls.AgClassCatalog.add_catalog_entry("{54E41ADE-C090-4C19-8B09-94F5030260C6}", ManeuverOptimalFiniteSNOPTOptimizer)


class ManeuverOptimalFiniteInitialBoundaryConditions(IManeuverOptimalFiniteInitialBoundaryConditions):
    """Properties of initial boundary conditions for optimal finite maneuver."""
    def __init__(self, sourceObject=None):
        IManeuverOptimalFiniteInitialBoundaryConditions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IManeuverOptimalFiniteInitialBoundaryConditions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IManeuverOptimalFiniteInitialBoundaryConditions._get_property(self, attrname) is not None: found_prop = IManeuverOptimalFiniteInitialBoundaryConditions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ManeuverOptimalFiniteInitialBoundaryConditions.")
        
agcls.AgClassCatalog.add_catalog_entry("{3A8835CC-D4EF-4AFE-B198-FC4992E17D6B}", ManeuverOptimalFiniteInitialBoundaryConditions)


class ManeuverOptimalFiniteFinalBoundaryConditions(IManeuverOptimalFiniteFinalBoundaryConditions):
    """Properties of final boundary conditions for optimal finite maneuver."""
    def __init__(self, sourceObject=None):
        IManeuverOptimalFiniteFinalBoundaryConditions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IManeuverOptimalFiniteFinalBoundaryConditions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IManeuverOptimalFiniteFinalBoundaryConditions._get_property(self, attrname) is not None: found_prop = IManeuverOptimalFiniteFinalBoundaryConditions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ManeuverOptimalFiniteFinalBoundaryConditions.")
        
agcls.AgClassCatalog.add_catalog_entry("{FF880BEA-2B6E-40ED-B7BC-85ED2367FC9C}", ManeuverOptimalFiniteFinalBoundaryConditions)


class ManeuverOptimalFinitePathBoundaryConditions(IManeuverOptimalFinitePathBoundaryConditions):
    """Properties of path boundary conditions for optimal finite maneuver."""
    def __init__(self, sourceObject=None):
        IManeuverOptimalFinitePathBoundaryConditions.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IManeuverOptimalFinitePathBoundaryConditions._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IManeuverOptimalFinitePathBoundaryConditions._get_property(self, attrname) is not None: found_prop = IManeuverOptimalFinitePathBoundaryConditions._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ManeuverOptimalFinitePathBoundaryConditions.")
        
agcls.AgClassCatalog.add_catalog_entry("{C8E16C04-1A5A-43F9-B770-A67666512F8A}", ManeuverOptimalFinitePathBoundaryConditions)


class ManeuverOptimalFiniteSteeringNodeElement(IManeuverOptimalFiniteSteeringNodeElement):
    """The elements of the steering node."""
    def __init__(self, sourceObject=None):
        IManeuverOptimalFiniteSteeringNodeElement.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IManeuverOptimalFiniteSteeringNodeElement._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IManeuverOptimalFiniteSteeringNodeElement._get_property(self, attrname) is not None: found_prop = IManeuverOptimalFiniteSteeringNodeElement._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ManeuverOptimalFiniteSteeringNodeElement.")
        
agcls.AgClassCatalog.add_catalog_entry("{AE276E86-B321-4F0D-B657-852143B3F3EE}", ManeuverOptimalFiniteSteeringNodeElement)


class ManeuverOptimalFiniteSteeringNodeCollection(IManeuverOptimalFiniteSteeringNodeCollection):
    """Steering/nodes collection."""
    def __init__(self, sourceObject=None):
        IManeuverOptimalFiniteSteeringNodeCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IManeuverOptimalFiniteSteeringNodeCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IManeuverOptimalFiniteSteeringNodeCollection._get_property(self, attrname) is not None: found_prop = IManeuverOptimalFiniteSteeringNodeCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ManeuverOptimalFiniteSteeringNodeCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{23249624-8EFC-4AD8-9E67-A564A49D2D67}", ManeuverOptimalFiniteSteeringNodeCollection)


class ManeuverOptimalFiniteBounds(IManeuverOptimalFiniteBounds):
    """The elements of the steering node."""
    def __init__(self, sourceObject=None):
        IManeuverOptimalFiniteBounds.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IManeuverOptimalFiniteBounds._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IManeuverOptimalFiniteBounds._get_property(self, attrname) is not None: found_prop = IManeuverOptimalFiniteBounds._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ManeuverOptimalFiniteBounds.")
        
agcls.AgClassCatalog.add_catalog_entry("{0F56E447-2391-476B-863C-8B8596486F03}", ManeuverOptimalFiniteBounds)


class ProfileLambertProfile(IProfileLambertProfile, IProfile, IRuntimeTypeInfoProvider):
    """The Lambert profile."""
    def __init__(self, sourceObject=None):
        IProfileLambertProfile.__init__(self, sourceObject)
        IProfile.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProfileLambertProfile._private_init(self, pUnk)
        IProfile._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProfileLambertProfile._get_property(self, attrname) is not None: found_prop = IProfileLambertProfile._get_property(self, attrname)
        if IProfile._get_property(self, attrname) is not None: found_prop = IProfile._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProfileLambertProfile.")
        
agcls.AgClassCatalog.add_catalog_entry("{3FA3162E-C38E-46D8-8F7C-B8421110EEB2}", ProfileLambertProfile)


class ProfileLambertSearchProfile(IProfileLambertSearchProfile, IProfile, IRuntimeTypeInfoProvider):
    """The Lambert profile."""
    def __init__(self, sourceObject=None):
        IProfileLambertSearchProfile.__init__(self, sourceObject)
        IProfile.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProfileLambertSearchProfile._private_init(self, pUnk)
        IProfile._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProfileLambertSearchProfile._get_property(self, attrname) is not None: found_prop = IProfileLambertSearchProfile._get_property(self, attrname)
        if IProfile._get_property(self, attrname) is not None: found_prop = IProfile._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProfileLambertSearchProfile.")
        
agcls.AgClassCatalog.add_catalog_entry("{9E98EFA2-5913-4BFA-8293-C294B80DFD4E}", ProfileLambertSearchProfile)


class ProfileGoldenSection(IProfileGoldenSection, IProfile, IRuntimeTypeInfoProvider):
    """The Golden Section profile."""
    def __init__(self, sourceObject=None):
        IProfileGoldenSection.__init__(self, sourceObject)
        IProfile.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProfileGoldenSection._private_init(self, pUnk)
        IProfile._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProfileGoldenSection._get_property(self, attrname) is not None: found_prop = IProfileGoldenSection._get_property(self, attrname)
        if IProfile._get_property(self, attrname) is not None: found_prop = IProfile._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProfileGoldenSection.")
        
agcls.AgClassCatalog.add_catalog_entry("{8A0E8056-D72B-4C82-85F0-945A96AC4E2E}", ProfileGoldenSection)


class GoldenSectionControlCollection(IGoldenSectionControlCollection):
    """Properties for the list of Golden Section control parameters."""
    def __init__(self, sourceObject=None):
        IGoldenSectionControlCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IGoldenSectionControlCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IGoldenSectionControlCollection._get_property(self, attrname) is not None: found_prop = IGoldenSectionControlCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in GoldenSectionControlCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{5E3FCD6D-E592-4610-9831-87D9ABD81889}", GoldenSectionControlCollection)


class GoldenSectionControl(IGoldenSectionControl):
    """Control parameters for Golden Section profile"""
    def __init__(self, sourceObject=None):
        IGoldenSectionControl.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IGoldenSectionControl._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IGoldenSectionControl._get_property(self, attrname) is not None: found_prop = IGoldenSectionControl._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in GoldenSectionControl.")
        
agcls.AgClassCatalog.add_catalog_entry("{00EBADDE-16F1-4FAC-8014-6952CBF0832E}", GoldenSectionControl)


class GoldenSectionResultCollection(IGoldenSectionResultCollection):
    """Properties for the list of Golden Section result parameters."""
    def __init__(self, sourceObject=None):
        IGoldenSectionResultCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IGoldenSectionResultCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IGoldenSectionResultCollection._get_property(self, attrname) is not None: found_prop = IGoldenSectionResultCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in GoldenSectionResultCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{72ADF8B9-9BE8-4112-B295-30B86DAF11F3}", GoldenSectionResultCollection)


class GoldenSectionResult(IGoldenSectionResult):
    """Result parameters for Golden Section profile"""
    def __init__(self, sourceObject=None):
        IGoldenSectionResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IGoldenSectionResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IGoldenSectionResult._get_property(self, attrname) is not None: found_prop = IGoldenSectionResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in GoldenSectionResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{A6F34FB1-1740-4EBB-B4FB-E6BB0B9EE427}", GoldenSectionResult)


class ProfileGridSearch(IProfileGridSearch, IProfile, IRuntimeTypeInfoProvider):
    """The Grid Search profile."""
    def __init__(self, sourceObject=None):
        IProfileGridSearch.__init__(self, sourceObject)
        IProfile.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProfileGridSearch._private_init(self, pUnk)
        IProfile._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProfileGridSearch._get_property(self, attrname) is not None: found_prop = IProfileGridSearch._get_property(self, attrname)
        if IProfile._get_property(self, attrname) is not None: found_prop = IProfile._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProfileGridSearch.")
        
agcls.AgClassCatalog.add_catalog_entry("{7C28EA98-702E-4CA9-8DE6-C49CEC2932E0}", ProfileGridSearch)


class GridSearchControlCollection(IGridSearchControlCollection):
    """Properties for the list of Grid Search control parameters."""
    def __init__(self, sourceObject=None):
        IGridSearchControlCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IGridSearchControlCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IGridSearchControlCollection._get_property(self, attrname) is not None: found_prop = IGridSearchControlCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in GridSearchControlCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{0A1300B1-D35A-46C5-BE62-3AFB811157C5}", GridSearchControlCollection)


class GridSearchControl(IGridSearchControl):
    """Control parameters for Grid Search profile"""
    def __init__(self, sourceObject=None):
        IGridSearchControl.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IGridSearchControl._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IGridSearchControl._get_property(self, attrname) is not None: found_prop = IGridSearchControl._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in GridSearchControl.")
        
agcls.AgClassCatalog.add_catalog_entry("{DA10881F-2D20-41DF-88DD-F49F9A41BA76}", GridSearchControl)


class GridSearchResultCollection(IGridSearchResultCollection):
    """Properties for the list of Grid Search result parameters."""
    def __init__(self, sourceObject=None):
        IGridSearchResultCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IGridSearchResultCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IGridSearchResultCollection._get_property(self, attrname) is not None: found_prop = IGridSearchResultCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in GridSearchResultCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{E189AD76-0BE9-4922-8D76-3E28FAE74507}", GridSearchResultCollection)


class GridSearchResult(IGridSearchResult):
    """Result parameters for Grid Search profile"""
    def __init__(self, sourceObject=None):
        IGridSearchResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IGridSearchResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IGridSearchResult._get_property(self, attrname) is not None: found_prop = IGridSearchResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in GridSearchResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{B37527F8-1781-4484-985E-4F2BE2E8810A}", GridSearchResult)


class CalcObjectLinkEmbedControlCollection(ICalcObjectLinkEmbedControlCollection):
    """The Calculation Object link/embed component folder."""
    def __init__(self, sourceObject=None):
        ICalcObjectLinkEmbedControlCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        ICalcObjectLinkEmbedControlCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if ICalcObjectLinkEmbedControlCollection._get_property(self, attrname) is not None: found_prop = ICalcObjectLinkEmbedControlCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in CalcObjectLinkEmbedControlCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{8EFFF2BC-B4AA-4F5E-BDF2-7218EBBE10FF}", CalcObjectLinkEmbedControlCollection)


class ProfileBisection(IProfileBisection, IProfile, IRuntimeTypeInfoProvider):
    """Single Parameter Bisection profile"""
    def __init__(self, sourceObject=None):
        IProfileBisection.__init__(self, sourceObject)
        IProfile.__init__(self, sourceObject)
        IRuntimeTypeInfoProvider.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IProfileBisection._private_init(self, pUnk)
        IProfile._private_init(self, pUnk)
        IRuntimeTypeInfoProvider._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IProfileBisection._get_property(self, attrname) is not None: found_prop = IProfileBisection._get_property(self, attrname)
        if IProfile._get_property(self, attrname) is not None: found_prop = IProfile._get_property(self, attrname)
        if IRuntimeTypeInfoProvider._get_property(self, attrname) is not None: found_prop = IRuntimeTypeInfoProvider._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in ProfileBisection.")
        
agcls.AgClassCatalog.add_catalog_entry("{4A29B6D5-AF0C-4516-B362-5D111388524F}", ProfileBisection)


class BisectionControl(IBisectionControl):
    """Control parameters for  Bisection Seacrh Profile"""
    def __init__(self, sourceObject=None):
        IBisectionControl.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBisectionControl._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBisectionControl._get_property(self, attrname) is not None: found_prop = IBisectionControl._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BisectionControl.")
        
agcls.AgClassCatalog.add_catalog_entry("{BC9B72FF-9317-4F85-B7C4-04D39B082CE2}", BisectionControl)


class BisectionControlCollection(IBisectionControlCollection):
    """Bisection control collection."""
    def __init__(self, sourceObject=None):
        IBisectionControlCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBisectionControlCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBisectionControlCollection._get_property(self, attrname) is not None: found_prop = IBisectionControlCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BisectionControlCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{331CFC1C-3359-4B22-930F-19E3C152AB33}", BisectionControlCollection)


class BisectionResult(IBisectionResult):
    """Result parameters for Bisection profile."""
    def __init__(self, sourceObject=None):
        IBisectionResult.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBisectionResult._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBisectionResult._get_property(self, attrname) is not None: found_prop = IBisectionResult._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BisectionResult.")
        
agcls.AgClassCatalog.add_catalog_entry("{56010C30-D445-40EF-9BFC-6CE97FCFD032}", BisectionResult)


class BisectionResultCollection(IBisectionResultCollection):
    """Bisection result collection."""
    def __init__(self, sourceObject=None):
        IBisectionResultCollection.__init__(self, sourceObject)
    def _private_init(self, pUnk:IUnknown):
        self.__dict__["_pUnk"] = pUnk
        IBisectionResultCollection._private_init(self, pUnk)
    def __eq__(self, other):
        """Checks equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        found_prop = None
        if IBisectionResultCollection._get_property(self, attrname) is not None: found_prop = IBisectionResultCollection._get_property(self, attrname)
        if found_prop is not None:
            found_prop.__set__(self, value)
        else:
            raise STKAttributeError(attrname + " is not a recognized attribute in BisectionResultCollection.")
        
agcls.AgClassCatalog.add_catalog_entry("{3F25CF16-ED89-486D-8F60-8F4F3729D41F}", BisectionResultCollection)



################################################################################
#          Copyright 2020-2020, Analytical Graphics, Inc.
################################################################################
