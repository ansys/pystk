################################################################################
#          Copyright 2020-2023, Ansys Government Initiatives
################################################################################ 

"""
Access and manipulate visual elements in STK.

These include STK globe terrain
and imagery, camera control, 3D models, triangle meshes, surface polygons and
polylines, text batches, screen overlays, scene lighting, and raster and
projection streaming. STK Graphics is available in STK, using UI plugins, as
well as in STK Engine custom applications.
"""

__all__ = ["AGICustomTerrainOverlay", "AGICustomTerrainOverlayFactory", "AGIProcessedImageGlobeOverlay", "AGIProcessedImageGlobeOverlayFactory", 
"AGIProcessedTerrainOverlay", "AGIProcessedTerrainOverlayFactory", "AGIRoamImageGlobeOverlay", "AGIRoamImageGlobeOverlayFactory", 
"ANTI_ALIASING", "AlphaFromLuminanceFilter", "AlphaFromLuminanceFilterFactory", "AlphaFromPixelFilter", "AlphaFromPixelFilterFactory", 
"AlphaFromRasterFilter", "AlphaFromRasterFilterFactory", "AltitudeDisplayCondition", "AltitudeDisplayConditionFactory", 
"AxesPrimitive", "AxesPrimitiveFactory", "BINARY_LOGIC_OPERATION", "BLUR_METHOD", "BandExtractFilter", "BandExtractFilterFactory", 
"BandOrderFilter", "BandOrderFilterFactory", "BatchPrimitiveIndex", "BlurFilter", "BlurFilterFactory", "BoundingSphere", 
"BoundingSphereFactory", "BoxTriangulatorInitializer", "BrightnessFilter", "BrightnessFilterFactory", "CAMERA_SNAPSHOT_FILE_FORMAT", 
"CAMERA_VIDEO_FORMAT", "CONSTRAINED_UP_AXIS", "CULL_FACE", "CYLINDER_FILL", "Camera", "CameraSnapshot", "CameraVideoRecording", 
"CentralBodyGraphics", "CentralBodyGraphicsIndexer", "Clouds", "ColorToLuminanceFilter", "ColorToLuminanceFilterFactory", 
"CompositeDisplayCondition", "CompositeDisplayConditionFactory", "CompositePrimitive", "CompositePrimitiveFactory", "ConstantDisplayCondition", 
"ConstantDisplayConditionFactory", "ContrastFilter", "ContrastFilterFactory", "ConvolutionFilter", "ConvolutionFilterFactory", 
"CustomImageGlobeOverlay", "CustomImageGlobeOverlayPluginActivator", "CustomImageGlobeOverlayPluginActivatorFactory", "CustomImageGlobeOverlayPluginProxy", 
"CylinderTriangulatorInitializer", "DisplayCondition", "DistanceDisplayCondition", "DistanceDisplayConditionFactory", "DistanceToGlobeOverlayDisplayCondition", 
"DistanceToGlobeOverlayDisplayConditionFactory", "DistanceToPositionDisplayCondition", "DistanceToPositionDisplayConditionFactory", 
"DistanceToPrimitiveDisplayCondition", "DistanceToPrimitiveDisplayConditionFactory", "DurationPathPrimitiveUpdatePolicy", 
"DurationPathPrimitiveUpdatePolicyFactory", "EDGE_DETECT_METHOD", "EdgeDetectFilter", "EdgeDetectFilterFactory", "EllipsoidTriangulatorInitializer", 
"ExtrudedPolylineTriangulatorInitializer", "ExtrudedPolylineTriangulatorResult", "FLIP_AXIS", "FONT_STYLE", "FactoryAndInitializers", 
"FilteringRasterStream", "FilteringRasterStreamFactory", "FlipFilter", "FlipFilterFactory", "FrameRate", "GLOBE_OVERLAY_ROLE", 
"GRADIENT_DETECT_METHOD", "GammaCorrectionFilter", "GammaCorrectionFilterFactory", "GaussianBlurFilter", "GaussianBlurFilterFactory", 
"GeospatialImageGlobeOverlay", "GeospatialImageGlobeOverlayFactory", "GlobeImageOverlay", "GlobeImageOverlayAddCompleteEventArgs", 
"GlobeImageOverlayInitializer", "GlobeOverlay", "GlobeOverlaySettings", "GradientDetectFilter", "GradientDetectFilterFactory", 
"GraphicsFont", "GraphicsFontFactory", "GreatArcInterpolator", "GreatArcInterpolatorFactory", "IAGICustomTerrainOverlay", 
"IAGICustomTerrainOverlayFactory", "IAGIProcessedImageGlobeOverlay", "IAGIProcessedImageGlobeOverlayFactory", "IAGIProcessedTerrainOverlay", 
"IAGIProcessedTerrainOverlayFactory", "IAGIRoamImageGlobeOverlay", "IAGIRoamImageGlobeOverlayFactory", "IAlphaFromLuminanceFilter", 
"IAlphaFromLuminanceFilterFactory", "IAlphaFromPixelFilter", "IAlphaFromPixelFilterFactory", "IAlphaFromRasterFilter", "IAlphaFromRasterFilterFactory", 
"IAltitudeDisplayCondition", "IAltitudeDisplayConditionFactory", "IAxesPrimitive", "IAxesPrimitiveFactory", "IBandExtractFilter", 
"IBandExtractFilterFactory", "IBandOrderFilter", "IBandOrderFilterFactory", "IBatchPrimitiveIndex", "IBlurFilter", "IBlurFilterFactory", 
"IBoundingSphere", "IBoundingSphereFactory", "IBoxTriangulatorInitializer", "IBrightnessFilter", "IBrightnessFilterFactory", 
"ICamera", "ICameraSnapshot", "ICameraVideoRecording", "ICentralBodyGraphics", "ICentralBodyGraphicsIndexer", "IClouds", 
"IColorToLuminanceFilter", "IColorToLuminanceFilterFactory", "ICompositeDisplayCondition", "ICompositeDisplayConditionFactory", 
"ICompositePrimitive", "ICompositePrimitiveFactory", "IConstantDisplayCondition", "IConstantDisplayConditionFactory", "IContrastFilter", 
"IContrastFilterFactory", "IConvolutionFilter", "IConvolutionFilterFactory", "ICustomImageGlobeOverlay", "ICustomImageGlobeOverlayPluginActivator", 
"ICustomImageGlobeOverlayPluginActivatorFactory", "ICustomImageGlobeOverlayPluginProxy", "ICylinderTriangulatorInitializer", 
"IDisplayCondition", "IDistanceDisplayCondition", "IDistanceDisplayConditionFactory", "IDistanceToGlobeOverlayDisplayCondition", 
"IDistanceToGlobeOverlayDisplayConditionFactory", "IDistanceToPositionDisplayCondition", "IDistanceToPositionDisplayConditionFactory", 
"IDistanceToPrimitiveDisplayCondition", "IDistanceToPrimitiveDisplayConditionFactory", "IDurationPathPrimitiveUpdatePolicy", 
"IDurationPathPrimitiveUpdatePolicyFactory", "IEdgeDetectFilter", "IEdgeDetectFilterFactory", "IEllipsoidTriangulatorInitializer", 
"IExtrudedPolylineTriangulatorInitializer", "IExtrudedPolylineTriangulatorResult", "IFactoryAndInitializers", "IFilteringRasterStream", 
"IFilteringRasterStreamFactory", "IFlipFilter", "IFlipFilterFactory", "IFrameRate", "IGammaCorrectionFilter", "IGammaCorrectionFilterFactory", 
"IGaussianBlurFilter", "IGaussianBlurFilterFactory", "IGeospatialImageGlobeOverlay", "IGeospatialImageGlobeOverlayFactory", 
"IGlobeImageOverlay", "IGlobeImageOverlayAddCompleteEventArgs", "IGlobeImageOverlayInitializer", "IGlobeOverlay", "IGlobeOverlaySettings", 
"IGradientDetectFilter", "IGradientDetectFilterFactory", "IGraphicsFont", "IGraphicsFontFactory", "IGreatArcInterpolator", 
"IGreatArcInterpolatorFactory", "IImageCollection", "IJpeg2000WriterInitializer", "IKmlContainer", "IKmlDocument", "IKmlDocumentCollection", 
"IKmlDocumentLoadedEventArgs", "IKmlFeature", "IKmlFeatureCollection", "IKmlFolder", "IKmlGraphics", "IKmlNetworkLink", 
"ILevelsFilter", "ILevelsFilterFactory", "ILighting", "IMarkerBatchPrimitive", "IMarkerBatchPrimitiveFactory", "IMarkerBatchPrimitiveOptionalParameters", 
"IMarkerBatchPrimitiveOptionalParametersFactory", "IMaximumCountPathPrimitiveUpdatePolicy", "IMaximumCountPathPrimitiveUpdatePolicyFactory", 
"IModelArticulation", "IModelArticulationCollection", "IModelPrimitive", "IModelPrimitiveFactory", "IModelTransformation", 
"INDICES_ORDER_HINT", "INTERNAL_TEXTURE_FORMAT", "IObjectCollection", "IOverlay", "IPathPoint", "IPathPointCollection", 
"IPathPointFactory", "IPathPrimitive", "IPathPrimitiveFactory", "IPathPrimitiveUpdatePolicy", "IPickResult", "IPickResultCollection", 
"IPixelSizeDisplayCondition", "IPixelSizeDisplayConditionFactory", "IPointBatchPrimitive", "IPointBatchPrimitiveFactory", 
"IPointBatchPrimitiveOptionalParameters", "IPointBatchPrimitiveOptionalParametersFactory", "IPolylinePrimitive", "IPolylinePrimitiveFactory", 
"IPolylinePrimitiveOptionalParameters", "IPolylinePrimitiveOptionalParametersFactory", "IPositionInterpolator", "IPrimitive", 
"IPrimitiveManager", "IProjectedRasterOverlay", "IProjectedRasterOverlayFactory", "IProjection", "IProjectionFactory", "IProjectionRasterStreamPluginActivator", 
"IProjectionRasterStreamPluginActivatorFactory", "IProjectionRasterStreamPluginProxy", "IProjectionStream", "IRaster", "IRasterAttributes", 
"IRasterAttributesFactory", "IRasterFactory", "IRasterFilter", "IRasterImageGlobeOverlay", "IRasterImageGlobeOverlayFactory", 
"IRasterStream", "IRendererTexture2D", "IRendererTextureTemplate2D", "IRenderingEventArgs", "IRhumbLineInterpolator", "IRhumbLineInterpolatorFactory", 
"IRotateFilter", "IRotateFilterFactory", "IScene", "ISceneCollection", "ISceneDisplayCondition", "ISceneDisplayConditionFactory", 
"ISceneGlobeOverlaySettings", "ISceneManager", "ISceneManagerInitializer", "IScreenOverlay", "IScreenOverlayCollection", 
"IScreenOverlayCollectionBase", "IScreenOverlayContainer", "IScreenOverlayFactory", "IScreenOverlayManager", "IScreenOverlayPickResult", 
"IScreenOverlayPickResultCollection", "ISequenceFilter", "ISequenceFilterFactory", "ISharpenFilter", "ISharpenFilterFactory", 
"ISolidPrimitive", "ISolidPrimitiveFactory", "ISolidTriangulatorResult", "IStereoscopic", "ISurfaceExtentTriangulatorInitializer", 
"ISurfaceMeshPrimitive", "ISurfaceMeshPrimitiveFactory", "ISurfacePolygonTriangulatorInitializer", "ISurfaceShapesInitializer", 
"ISurfaceShapesResult", "ISurfaceTriangulatorResult", "ITerrainOverlay", "ITerrainOverlayAddCompleteEventArgs", "ITerrainOverlayCollection", 
"ITerrainOverlayInitializer", "ITextBatchPrimitive", "ITextBatchPrimitiveFactory", "ITextBatchPrimitiveOptionalParameters", 
"ITextBatchPrimitiveOptionalParametersFactory", "ITextOverlay", "ITextOverlayFactory", "ITexture2DFactory", "ITextureFilter2D", 
"ITextureFilter2DFactory", "ITextureMatrix", "ITextureMatrixFactory", "ITextureScreenOverlay", "ITextureScreenOverlayFactory", 
"ITimeIntervalDisplayCondition", "ITimeIntervalDisplayConditionFactory", "ITriangleMeshPrimitive", "ITriangleMeshPrimitiveFactory", 
"ITriangleMeshPrimitiveOptionalParameters", "ITriangleMeshPrimitiveOptionalParametersFactory", "ITriangulatorResult", "IVectorPrimitive", 
"IVectorPrimitiveFactory", "IVideoStream", "IVideoStreamFactory", "IVisualEffects", "ImageCollection", "JPEG2000_COMPRESSION_PROFILE", 
"Jpeg2000WriterInitializer", "KML_NETWORK_LINK_REFRESH_MODE", "KML_NETWORK_LINK_VIEW_REFRESH_MODE", "KmlContainer", "KmlDocument", 
"KmlDocumentCollection", "KmlDocumentLoadedEventArgs", "KmlFeature", "KmlFeatureCollection", "KmlFolder", "KmlGraphics", 
"KmlNetworkLink", "LevelsFilter", "LevelsFilterFactory", "Lighting", "MAGNIFICATION_FILTER", "MAINTAIN_ASPECT_RATIO", "MAP_PROJECTION", 
"MARKER_BATCH_RENDERING_METHOD", "MARKER_BATCH_RENDER_PASS", "MARKER_BATCH_SIZE_SOURCE", "MARKER_BATCH_SORT_ORDER", "MARKER_BATCH_UNIT", 
"MINIFICATION_FILTER", "MODEL_TRANSFORMATION_TYPE", "MODEL_UP_AXIS", "MarkerBatchPrimitive", "MarkerBatchPrimitiveFactory", 
"MarkerBatchPrimitiveOptionalParameters", "MarkerBatchPrimitiveOptionalParametersFactory", "MaximumCountPathPrimitiveUpdatePolicy", 
"MaximumCountPathPrimitiveUpdatePolicyFactory", "ModelArticulation", "ModelArticulationCollection", "ModelPrimitive", "ModelPrimitiveFactory", 
"ModelTransformation", "ORIGIN", "OUTLINE_APPEARANCE", "ObjectCollection", "Overlay", "PATH_PRIMITIVE_REMOVE_LOCATION", 
"POLYLINE_TYPE", "PRIMITIVES_SORT_ORDER", "PathPoint", "PathPointCollection", "PathPointFactory", "PathPrimitive", "PathPrimitiveFactory", 
"PathPrimitiveUpdatePolicy", "PickResult", "PickResultCollection", "PixelSizeDisplayCondition", "PixelSizeDisplayConditionFactory", 
"PointBatchPrimitive", "PointBatchPrimitiveFactory", "PointBatchPrimitiveOptionalParameters", "PointBatchPrimitiveOptionalParametersFactory", 
"PolylinePrimitive", "PolylinePrimitiveFactory", "PolylinePrimitiveOptionalParameters", "PolylinePrimitiveOptionalParametersFactory", 
"PositionInterpolator", "Primitive", "PrimitiveManager", "ProjectedRasterOverlay", "ProjectedRasterOverlayFactory", "Projection", 
"ProjectionFactory", "ProjectionRasterStreamPluginActivator", "ProjectionRasterStreamPluginActivatorFactory", "ProjectionRasterStreamPluginProxy", 
"ProjectionStream", "RASTER_BAND", "RASTER_FORMAT", "RASTER_ORIENTATION", "RASTER_TYPE", "REFRESH_RATE", "RENDERER_SHADE_MODEL", 
"RENDER_PASS", "RENDER_PASS_HINT", "Raster", "RasterAttributes", "RasterAttributesFactory", "RasterFactory", "RasterFilter", 
"RasterImageGlobeOverlay", "RasterImageGlobeOverlayFactory", "RasterStream", "RendererTexture2D", "RendererTextureTemplate2D", 
"RenderingEventArgs", "RhumbLineInterpolator", "RhumbLineInterpolatorFactory", "RotateFilter", "RotateFilterFactory", "SCREEN_OVERLAY_ORIGIN", 
"SCREEN_OVERLAY_PINNING_ORIGIN", "SCREEN_OVERLAY_UNIT", "SET_HINT", "SHARPEN_METHOD", "STEREOSCOPIC_DISPLAY_MODE", "STEREO_PROJECTION_MODE", 
"SURFACE_MESH_RENDERING_METHOD", "Scene", "SceneCollection", "SceneDisplayCondition", "SceneDisplayConditionFactory", "SceneGlobeOverlaySettings", 
"SceneManager", "SceneManagerInitializer", "ScreenOverlay", "ScreenOverlayCollection", "ScreenOverlayCollectionBase", "ScreenOverlayFactory", 
"ScreenOverlayManager", "ScreenOverlayPickResult", "ScreenOverlayPickResultCollection", "SequenceFilter", "SequenceFilterFactory", 
"SharpenFilter", "SharpenFilterFactory", "SolidPrimitive", "SolidPrimitiveFactory", "SolidTriangulatorResult", "Stereoscopic", 
"SurfaceExtentTriangulatorInitializer", "SurfaceMeshPrimitive", "SurfaceMeshPrimitiveFactory", "SurfacePolygonTriangulatorInitializer", 
"SurfaceShapesInitializer", "SurfaceShapesResult", "SurfaceTriangulatorResult", "TEXTURE_WRAP", "TerrainOverlay", "TerrainOverlayAddCompleteEventArgs", 
"TerrainOverlayCollection", "TerrainOverlayInitializer", "TextBatchPrimitive", "TextBatchPrimitiveFactory", "TextBatchPrimitiveOptionalParameters", 
"TextBatchPrimitiveOptionalParametersFactory", "TextOverlay", "TextOverlayFactory", "Texture2DFactory", "TextureFilter2D", 
"TextureFilter2DFactory", "TextureMatrix", "TextureMatrixFactory", "TextureScreenOverlay", "TextureScreenOverlayFactory", 
"TimeIntervalDisplayCondition", "TimeIntervalDisplayConditionFactory", "TriangleMeshPrimitive", "TriangleMeshPrimitiveFactory", 
"TriangleMeshPrimitiveOptionalParameters", "TriangleMeshPrimitiveOptionalParametersFactory", "TriangulatorResult", "VIDEO_PLAYBACK", 
"VISIBILITY", "VectorPrimitive", "VectorPrimitiveFactory", "VideoStream", "VideoStreamFactory", "VisualEffects", "WINDING_ORDER"]

import typing

from ctypes   import POINTER
from enum     import IntEnum, IntFlag

from .internal  import comutil          as agcom
from .internal  import coclassutil      as agcls
from .internal  import marshall         as agmarshall
from .utilities import colors           as agcolor
from .internal.comutil     import IUnknown, IPictureDisp
from .internal.apiutil     import (InterfaceProxy, EnumeratorProxy, OutArg, 
    initialize_from_source_object, get_interface_property, set_interface_attribute, 
    set_class_attribute, SupportsDeleteCallback)
from .internal.eventutil   import *
from .utilities.exceptions import *

from .stkutil import *
from .vgt import *


def _raise_uninitialized_error(*args):
    raise STKRuntimeError("Valid STK object model classes are returned from STK methods and should not be created independently.")

class CYLINDER_FILL(IntFlag):
    """Cylinder faces that can be filled."""
   
    WALL = 1
    """Fill the cylinder's wall."""
    BOTTOM_CAP = 2
    """Fill the cylinder's bottom cap."""
    TOP_CAP = 4
    """Fill the cylinder's top cap."""
    ALL = 7
    """Completely fill the cylinder, including its wall, bottom, and top cap."""

CYLINDER_FILL.WALL.__doc__ = "Fill the cylinder's wall."
CYLINDER_FILL.BOTTOM_CAP.__doc__ = "Fill the cylinder's bottom cap."
CYLINDER_FILL.TOP_CAP.__doc__ = "Fill the cylinder's top cap."
CYLINDER_FILL.ALL.__doc__ = "Completely fill the cylinder, including its wall, bottom, and top cap."

agcls.AgTypeNameMap["CYLINDER_FILL"] = CYLINDER_FILL

class WINDING_ORDER(IntEnum):
    """Specify the order for positions or front facing triangles. Winding order is important for triangulation and backface culling."""
   
    COUNTER_CLOCKWISE = 0
    """Positions or triangles are defined in counter-clockwise order."""
    CLOCKWISE = 1
    """Positions or triangles are defined in clockwise order."""
    COMPUTE = 2
    """The winding order is unknown and should be computed. For best performance, only use this value if you do not know the actual winding order."""

WINDING_ORDER.COUNTER_CLOCKWISE.__doc__ = "Positions or triangles are defined in counter-clockwise order."
WINDING_ORDER.CLOCKWISE.__doc__ = "Positions or triangles are defined in clockwise order."
WINDING_ORDER.COMPUTE.__doc__ = "The winding order is unknown and should be computed. For best performance, only use this value if you do not know the actual winding order."

agcls.AgTypeNameMap["WINDING_ORDER"] = WINDING_ORDER

class CAMERA_SNAPSHOT_FILE_FORMAT(IntEnum):
    """When using camera snapshot or camera video recording to save a snapshot to a file, this specifies the file format."""
   
    BMP = 0
    """BMP file format."""
    TIFF = 2
    """TIFF file format."""
    JPEG = 3
    """JPEG file format."""
    PNG = 4
    """PNG file format."""

CAMERA_SNAPSHOT_FILE_FORMAT.BMP.__doc__ = "BMP file format."
CAMERA_SNAPSHOT_FILE_FORMAT.TIFF.__doc__ = "TIFF file format."
CAMERA_SNAPSHOT_FILE_FORMAT.JPEG.__doc__ = "JPEG file format."
CAMERA_SNAPSHOT_FILE_FORMAT.PNG.__doc__ = "PNG file format."

agcls.AgTypeNameMap["CAMERA_SNAPSHOT_FILE_FORMAT"] = CAMERA_SNAPSHOT_FILE_FORMAT

class CAMERA_VIDEO_FORMAT(IntEnum):
    """When using camera video recording to record a video, this specifies the file format."""
   
    H264 = 0
    """H.264 file format."""
    WMV = 1
    """Windows Media Video (WMV) file format."""

CAMERA_VIDEO_FORMAT.H264.__doc__ = "H.264 file format."
CAMERA_VIDEO_FORMAT.WMV.__doc__ = "Windows Media Video (WMV) file format."

agcls.AgTypeNameMap["CAMERA_VIDEO_FORMAT"] = CAMERA_VIDEO_FORMAT

class CONSTRAINED_UP_AXIS(IntEnum):
    """When setting the camera'saxes, this defines which axis of the axes is up in screen space, where up is from the bottom to the top of the screen."""
   
    X = 0
    """The X axis is constrained."""
    Y = 1
    """The Y axis is constrained."""
    Z = 2
    """The Z axis is constrained."""
    NEGATIVE_X = 3
    """The negative X axis is constrained."""
    NEGATIVE_Y = 4
    """The negative Y axis is constrained."""
    NEGATIVE_Z = 5
    """The negative Z axis is constrained."""
    NONE = 6
    """No axis is contained."""

CONSTRAINED_UP_AXIS.X.__doc__ = "The X axis is constrained."
CONSTRAINED_UP_AXIS.Y.__doc__ = "The Y axis is constrained."
CONSTRAINED_UP_AXIS.Z.__doc__ = "The Z axis is constrained."
CONSTRAINED_UP_AXIS.NEGATIVE_X.__doc__ = "The negative X axis is constrained."
CONSTRAINED_UP_AXIS.NEGATIVE_Y.__doc__ = "The negative Y axis is constrained."
CONSTRAINED_UP_AXIS.NEGATIVE_Z.__doc__ = "The negative Z axis is constrained."
CONSTRAINED_UP_AXIS.NONE.__doc__ = "No axis is contained."

agcls.AgTypeNameMap["CONSTRAINED_UP_AXIS"] = CONSTRAINED_UP_AXIS

class GLOBE_OVERLAY_ROLE(IntEnum):
    """The role of a globe overlay."""
   
    BASE = 0
    """The globe overlay is a base image."""
    NIGHT = 1
    """The globe overlay is a base image that is only displayed on the area of the central body that is not lit by the sun."""
    SPECULAR = 2
    """The globe overlay is a base image that shows the glint of the sun on the central body."""
    NORMAL = 4
    """The globe overlay is a normal overlay without a special role."""
    NONE = 5
    """The role of the globe overlay isn't set."""

GLOBE_OVERLAY_ROLE.BASE.__doc__ = "The globe overlay is a base image."
GLOBE_OVERLAY_ROLE.NIGHT.__doc__ = "The globe overlay is a base image that is only displayed on the area of the central body that is not lit by the sun."
GLOBE_OVERLAY_ROLE.SPECULAR.__doc__ = "The globe overlay is a base image that shows the glint of the sun on the central body."
GLOBE_OVERLAY_ROLE.NORMAL.__doc__ = "The globe overlay is a normal overlay without a special role."
GLOBE_OVERLAY_ROLE.NONE.__doc__ = "The role of the globe overlay isn't set."

agcls.AgTypeNameMap["GLOBE_OVERLAY_ROLE"] = GLOBE_OVERLAY_ROLE

class INDICES_ORDER_HINT(IntEnum):
    """An optimization hint optionally provided to a primitive'sSetPartial method to enhance performance."""
   
    NOT_SORTED = 0
    """The indices passed to SetPartial are not sorted. Therefore, the primitive may sort them to improve performance of writing its geometry to video memory."""
    SORTED_ASCENDING = 1
    """The indices passed to SetPartial are sorted in ascending order. Therefore, the primitive does not need to sort them. It is recommended to only use SortedAscending if it is easy and efficient for you to provide the indices in ascending order..."""

INDICES_ORDER_HINT.NOT_SORTED.__doc__ = "The indices passed to SetPartial are not sorted. Therefore, the primitive may sort them to improve performance of writing its geometry to video memory."
INDICES_ORDER_HINT.SORTED_ASCENDING.__doc__ = "The indices passed to SetPartial are sorted in ascending order. Therefore, the primitive does not need to sort them. It is recommended to only use SortedAscending if it is easy and efficient for you to provide the indices in ascending order..."

agcls.AgTypeNameMap["INDICES_ORDER_HINT"] = INDICES_ORDER_HINT

class MAINTAIN_ASPECT_RATIO(IntEnum):
    """Specify whether the aspect ratio of a texture will be maintained during sizing of a screen overlay."""
   
    NONE = 0
    """The aspect ratio of the texture is not maintained during sizing of the screen overlay."""
    WIDTH = 1
    """The aspect ratio of the texture is maintained based on the width property of the screen overlay. When used, the height property is ignored and the height is automatically calculated based on the aspect ratio of the texture and the overlay's width property."""
    HEIGHT = 2
    """The aspect ratio of the texture is maintained based on the height property of the screen overlay. When used, the width property is ignored and the width is automatically calculated based on the aspect ratio of the texture and the overlay's height property."""

MAINTAIN_ASPECT_RATIO.NONE.__doc__ = "The aspect ratio of the texture is not maintained during sizing of the screen overlay."
MAINTAIN_ASPECT_RATIO.WIDTH.__doc__ = "The aspect ratio of the texture is maintained based on the width property of the screen overlay. When used, the height property is ignored and the height is automatically calculated based on the aspect ratio of the texture and the overlay's width property."
MAINTAIN_ASPECT_RATIO.HEIGHT.__doc__ = "The aspect ratio of the texture is maintained based on the height property of the screen overlay. When used, the width property is ignored and the width is automatically calculated based on the aspect ratio of the texture and the overlay's height property."

agcls.AgTypeNameMap["MAINTAIN_ASPECT_RATIO"] = MAINTAIN_ASPECT_RATIO

class MAP_PROJECTION(IntEnum):
    """The projection of the pixel data returned from a custom image globe overlay."""
   
    MERCATOR = 0
    """Mercator projection."""
    EQUIDISTANT_CYLINDRICAL = 1
    """Equidistant Cylindrical projection."""

MAP_PROJECTION.MERCATOR.__doc__ = "Mercator projection."
MAP_PROJECTION.EQUIDISTANT_CYLINDRICAL.__doc__ = "Equidistant Cylindrical projection."

agcls.AgTypeNameMap["MAP_PROJECTION"] = MAP_PROJECTION

class MARKER_BATCH_RENDERING_METHOD(IntEnum):
    """Rendering methods available for use by the marker batch primitive. Different methods may have different performance characteristics and require different video card support. When in doubt, use Automatic."""
   
    GEOMETRY_SHADER = 0
    """Render the marker batch using a geometry shader."""
    VERTEX_SHADER = 1
    """Render the marker batch using a vertex shader."""
    AUTOMATIC = 2
    """Render the marker batch using an automatically selected method based on the capabilities of the video card."""
    FIXED_FUNCTION = 3
    """Render the marker batch using the fixed function pipeline. Generally, this is the slowest method but it supports all video cards."""

MARKER_BATCH_RENDERING_METHOD.GEOMETRY_SHADER.__doc__ = "Render the marker batch using a geometry shader."
MARKER_BATCH_RENDERING_METHOD.VERTEX_SHADER.__doc__ = "Render the marker batch using a vertex shader."
MARKER_BATCH_RENDERING_METHOD.AUTOMATIC.__doc__ = "Render the marker batch using an automatically selected method based on the capabilities of the video card."
MARKER_BATCH_RENDERING_METHOD.FIXED_FUNCTION.__doc__ = "Render the marker batch using the fixed function pipeline. Generally, this is the slowest method but it supports all video cards."

agcls.AgTypeNameMap["MARKER_BATCH_RENDERING_METHOD"] = MARKER_BATCH_RENDERING_METHOD

class MARKER_BATCH_RENDER_PASS(IntEnum):
    """The pass during which the marker batch is rendered."""
   
    OPAQUE = 0
    """The marker batch contains all opaque textures and therefore should be rendered using the opaque pass."""
    TRANSLUCENT = 1
    """The marker batch contains textures with translucency and therefore should be rendered using the translucent pass. For correct blending of overlapping textures, also consider using back to front."""
    BASED_ON_TRANSLUCENCY = 2
    """The marker batch render pass should be determined based on the marker batch's translucency. This includes the translucency set per marker when SetColors is used."""

MARKER_BATCH_RENDER_PASS.OPAQUE.__doc__ = "The marker batch contains all opaque textures and therefore should be rendered using the opaque pass."
MARKER_BATCH_RENDER_PASS.TRANSLUCENT.__doc__ = "The marker batch contains textures with translucency and therefore should be rendered using the translucent pass. For correct blending of overlapping textures, also consider using back to front."
MARKER_BATCH_RENDER_PASS.BASED_ON_TRANSLUCENCY.__doc__ = "The marker batch render pass should be determined based on the marker batch's translucency. This includes the translucency set per marker when SetColors is used."

agcls.AgTypeNameMap["MARKER_BATCH_RENDER_PASS"] = MARKER_BATCH_RENDER_PASS

class MARKER_BATCH_SIZE_SOURCE(IntEnum):
    """Determine which marker batch property is used to size each marker in a marker batch."""
   
    FROM_TEXTURE = 0
    """The size of each marker is the same as the size of its texture. If the marker is not textured, the user defined size is used instead."""
    USER_DEFINED = 1
    """The size of each marker in the marker batch is user defined. Either all markers have the same size (size) or each marker has a user defined size (SetSizes)."""

MARKER_BATCH_SIZE_SOURCE.FROM_TEXTURE.__doc__ = "The size of each marker is the same as the size of its texture. If the marker is not textured, the user defined size is used instead."
MARKER_BATCH_SIZE_SOURCE.USER_DEFINED.__doc__ = "The size of each marker in the marker batch is user defined. Either all markers have the same size (size) or each marker has a user defined size (SetSizes)."

agcls.AgTypeNameMap["MARKER_BATCH_SIZE_SOURCE"] = MARKER_BATCH_SIZE_SOURCE

class MARKER_BATCH_SORT_ORDER(IntEnum):
    """The order in which markers in a marker batch are sorted before rendering."""
   
    BACK_TO_FRONT = 0
    """The markers are sorted in back to front order before rendering. For overlapping translucent markers, this enables correct blending results..."""
    FRONT_TO_BACK = 1
    """The markers are sorted in front to back order before rendering. For overlapping opaque markers, this can enable the GPU to quickly eliminate markers that are hidden behind other markers..."""
    BY_TEXTURE = 2
    """The markers are sorted by texture. This minimizes costly texture changes during rendering and does not require resorting when the camera moves or a marker changes position."""

MARKER_BATCH_SORT_ORDER.BACK_TO_FRONT.__doc__ = "The markers are sorted in back to front order before rendering. For overlapping translucent markers, this enables correct blending results..."
MARKER_BATCH_SORT_ORDER.FRONT_TO_BACK.__doc__ = "The markers are sorted in front to back order before rendering. For overlapping opaque markers, this can enable the GPU to quickly eliminate markers that are hidden behind other markers..."
MARKER_BATCH_SORT_ORDER.BY_TEXTURE.__doc__ = "The markers are sorted by texture. This minimizes costly texture changes during rendering and does not require resorting when the camera moves or a marker changes position."

agcls.AgTypeNameMap["MARKER_BATCH_SORT_ORDER"] = MARKER_BATCH_SORT_ORDER

class MARKER_BATCH_UNIT(IntEnum):
    """The unit for marker sizes in a marker batch."""
   
    PIXELS = 0
    """The size of a marker is defined in pixels. As the camera zooms in and out the size of the marker doesn't change."""
    METERS = 1
    """The size of a marker is defined in meters."""

MARKER_BATCH_UNIT.PIXELS.__doc__ = "The size of a marker is defined in pixels. As the camera zooms in and out the size of the marker doesn't change."
MARKER_BATCH_UNIT.METERS.__doc__ = "The size of a marker is defined in meters."

agcls.AgTypeNameMap["MARKER_BATCH_UNIT"] = MARKER_BATCH_UNIT

class MODEL_TRANSFORMATION_TYPE(IntEnum):
    """Transformation types that define the way a model transformation changes the geometry of the model articulation it is associated with."""
   
    TRANSLATE_X = 0
    """Translate the geometry along the X axis."""
    TRANSLATE_Y = 1
    """Translate the geometry along the Y axis."""
    TRANSLATE_Z = 2
    """Translate the geometry along the Z axis."""
    ROTATE_X = 3
    """Rotate the geometry about the X axis."""
    ROTATE_Y = 4
    """Rotate the geometry about the Y axis."""
    ROTATE_Z = 5
    """Rotate the geometry about the Z axis."""
    SCALE_X = 6
    """Scale the geometry along the X axis."""
    SCALE_Y = 7
    """Scale the geometry along the Y axis."""
    SCALE_Z = 8
    """Scale the geometry along the Z axis."""
    SCALE_UNIFORM = 9
    """Scale the geometry uniformly along the X, Y, and Z axes."""
    TEXTURE_TRANSLATE_X = 10
    """Translate the texture associated with the geometry along the X axis."""
    TEXTURE_TRANSLATE_Y = 11
    """Translate the texture associated with the geometry along the Y axis."""
    TEXTURE_TRANSLATE_Z = 12
    """Translate the texture associated with the geometry along the Z axis."""
    TEXTURE_ROTATE_X = 13
    """Rotate the texture associated with the geometry about the X axis."""
    TEXTURE_ROTATE_Y = 14
    """Rotate the texture associated with the geometry about the Y axis."""
    TEXTURE_ROTATE_Z = 15
    """Rotate the texture associated with the geometry about the Z axis."""
    TEXTURE_SCALE_X = 16
    """Scale the texture associated with the geometry along the X axis."""
    TEXTURE_SCALE_Y = 17
    """Scale the texture associated with the geometry along the Y axis."""
    TEXTURE_SCALE_Z = 18
    """Scale the texture associated with the geometry along the Z axis."""
    TEXTURE_SCALE_UNIFORM = 19
    """Scale the texture associated with the geometry uniformly along the X, Y, and Z axes."""
    TRANSLATE_RED = 20
    """Translate the red band of color associated with the geometry."""
    TRANSLATE_GREEN = 21
    """Translate the green band of color associated with the geometry."""
    TRANSLATE_BLUE = 22
    """Translate the blue band of color associated with the geometry."""

MODEL_TRANSFORMATION_TYPE.TRANSLATE_X.__doc__ = "Translate the geometry along the X axis."
MODEL_TRANSFORMATION_TYPE.TRANSLATE_Y.__doc__ = "Translate the geometry along the Y axis."
MODEL_TRANSFORMATION_TYPE.TRANSLATE_Z.__doc__ = "Translate the geometry along the Z axis."
MODEL_TRANSFORMATION_TYPE.ROTATE_X.__doc__ = "Rotate the geometry about the X axis."
MODEL_TRANSFORMATION_TYPE.ROTATE_Y.__doc__ = "Rotate the geometry about the Y axis."
MODEL_TRANSFORMATION_TYPE.ROTATE_Z.__doc__ = "Rotate the geometry about the Z axis."
MODEL_TRANSFORMATION_TYPE.SCALE_X.__doc__ = "Scale the geometry along the X axis."
MODEL_TRANSFORMATION_TYPE.SCALE_Y.__doc__ = "Scale the geometry along the Y axis."
MODEL_TRANSFORMATION_TYPE.SCALE_Z.__doc__ = "Scale the geometry along the Z axis."
MODEL_TRANSFORMATION_TYPE.SCALE_UNIFORM.__doc__ = "Scale the geometry uniformly along the X, Y, and Z axes."
MODEL_TRANSFORMATION_TYPE.TEXTURE_TRANSLATE_X.__doc__ = "Translate the texture associated with the geometry along the X axis."
MODEL_TRANSFORMATION_TYPE.TEXTURE_TRANSLATE_Y.__doc__ = "Translate the texture associated with the geometry along the Y axis."
MODEL_TRANSFORMATION_TYPE.TEXTURE_TRANSLATE_Z.__doc__ = "Translate the texture associated with the geometry along the Z axis."
MODEL_TRANSFORMATION_TYPE.TEXTURE_ROTATE_X.__doc__ = "Rotate the texture associated with the geometry about the X axis."
MODEL_TRANSFORMATION_TYPE.TEXTURE_ROTATE_Y.__doc__ = "Rotate the texture associated with the geometry about the Y axis."
MODEL_TRANSFORMATION_TYPE.TEXTURE_ROTATE_Z.__doc__ = "Rotate the texture associated with the geometry about the Z axis."
MODEL_TRANSFORMATION_TYPE.TEXTURE_SCALE_X.__doc__ = "Scale the texture associated with the geometry along the X axis."
MODEL_TRANSFORMATION_TYPE.TEXTURE_SCALE_Y.__doc__ = "Scale the texture associated with the geometry along the Y axis."
MODEL_TRANSFORMATION_TYPE.TEXTURE_SCALE_Z.__doc__ = "Scale the texture associated with the geometry along the Z axis."
MODEL_TRANSFORMATION_TYPE.TEXTURE_SCALE_UNIFORM.__doc__ = "Scale the texture associated with the geometry uniformly along the X, Y, and Z axes."
MODEL_TRANSFORMATION_TYPE.TRANSLATE_RED.__doc__ = "Translate the red band of color associated with the geometry."
MODEL_TRANSFORMATION_TYPE.TRANSLATE_GREEN.__doc__ = "Translate the green band of color associated with the geometry."
MODEL_TRANSFORMATION_TYPE.TRANSLATE_BLUE.__doc__ = "Translate the blue band of color associated with the geometry."

agcls.AgTypeNameMap["MODEL_TRANSFORMATION_TYPE"] = MODEL_TRANSFORMATION_TYPE

class ORIGIN(IntEnum):
    """Vertical and horizontal origin."""
   
    BOTTOM_LEFT = 0
    """The object's origin is its bottom, left corner."""
    BOTTOM_CENTER = 1
    """The object's origin is its bottom, center point."""
    BOTTOM_RIGHT = 2
    """The object's origin is its bottom, right corner."""
    CENTER_LEFT = 3
    """The object's origin is its center, left point."""
    CENTER = 4
    """The object's origin is its center."""
    CENTER_RIGHT = 5
    """The object's origin is its center, right point."""
    TOP_LEFT = 6
    """The object's origin is its top, left corner."""
    TOP_CENTER = 7
    """The object's origin is its top, center point."""
    TOP_RIGHT = 8
    """The object's origin is its top, right corner."""

ORIGIN.BOTTOM_LEFT.__doc__ = "The object's origin is its bottom, left corner."
ORIGIN.BOTTOM_CENTER.__doc__ = "The object's origin is its bottom, center point."
ORIGIN.BOTTOM_RIGHT.__doc__ = "The object's origin is its bottom, right corner."
ORIGIN.CENTER_LEFT.__doc__ = "The object's origin is its center, left point."
ORIGIN.CENTER.__doc__ = "The object's origin is its center."
ORIGIN.CENTER_RIGHT.__doc__ = "The object's origin is its center, right point."
ORIGIN.TOP_LEFT.__doc__ = "The object's origin is its top, left corner."
ORIGIN.TOP_CENTER.__doc__ = "The object's origin is its top, center point."
ORIGIN.TOP_RIGHT.__doc__ = "The object's origin is its top, right corner."

agcls.AgTypeNameMap["ORIGIN"] = ORIGIN

class PATH_PRIMITIVE_REMOVE_LOCATION(IntEnum):
    """Represents the location of a point to be removed."""
   
    REMOVE_LOCATION_FRONT = 0
    """Remove from the front of the line."""
    REMOVE_LOCATION_BACK = 1
    """Remove from the back of the line."""

PATH_PRIMITIVE_REMOVE_LOCATION.REMOVE_LOCATION_FRONT.__doc__ = "Remove from the front of the line."
PATH_PRIMITIVE_REMOVE_LOCATION.REMOVE_LOCATION_BACK.__doc__ = "Remove from the back of the line."

agcls.AgTypeNameMap["PATH_PRIMITIVE_REMOVE_LOCATION"] = PATH_PRIMITIVE_REMOVE_LOCATION

class PRIMITIVES_SORT_ORDER(IntEnum):
    """The order in which primitives are sorted before rendering."""
   
    BY_STATE = 0
    """Primitives are sorted by their internal state before rendering. This provides good performance but can lead to blending artifacts with translucent primitives along the same line of sight."""
    BACK_TO_FRONT = 1
    """Primitives are sorted in back to front order before rendering. For translucent primitives, this enables correct blending results. This may not perform as well as PrimitivesSortOrderByState since the CPU has to sort the primitives before rendering."""

PRIMITIVES_SORT_ORDER.BY_STATE.__doc__ = "Primitives are sorted by their internal state before rendering. This provides good performance but can lead to blending artifacts with translucent primitives along the same line of sight."
PRIMITIVES_SORT_ORDER.BACK_TO_FRONT.__doc__ = "Primitives are sorted in back to front order before rendering. For translucent primitives, this enables correct blending results. This may not perform as well as PrimitivesSortOrderByState since the CPU has to sort the primitives before rendering."

agcls.AgTypeNameMap["PRIMITIVES_SORT_ORDER"] = PRIMITIVES_SORT_ORDER

class REFRESH_RATE(IntEnum):
    """The rate at which animation frames will occur."""
   
    FASTEST = 0
    """The animation will occur as fast as possible. The maximum frame rate is the refresh rate of the display or is the maximum that video card is capable of if the video card's vertical sync is off."""
    TARGETED_FRAMES_PER_SECOND = 1
    """The animation will target a specified frame rate."""

REFRESH_RATE.FASTEST.__doc__ = "The animation will occur as fast as possible. The maximum frame rate is the refresh rate of the display or is the maximum that video card is capable of if the video card's vertical sync is off."
REFRESH_RATE.TARGETED_FRAMES_PER_SECOND.__doc__ = "The animation will target a specified frame rate."

agcls.AgTypeNameMap["REFRESH_RATE"] = REFRESH_RATE

class RENDER_PASS(IntFlag):
    """Describes when a primitive will be rendered. Some primitives need to be rendered during or at a certain time. For example, translucent primitives need to be rendered after opaque primitives to allow proper blending..."""
   
    OPAQUE = 1
    """Render during the opaque rendering pass."""
    TRANSLUCENT = 2
    """Render during the translucent rendering pass."""
    CENTRAL_BODY_CLIPPED = 4
    """Render before the central body is rendered."""
    ORDERED_COMPOSITE_CENTRAL_BODY_CLIPPED = 8
    """Rendered in an ordered composite before all other primitives and before the central body is rendered."""
    ORDERED_COMPOSITE = 16
    """Rendered in an ordered composite before all primitives but after the central body is rendered."""
    TERRAIN = 32
    """Render after the terrain is rendered."""

RENDER_PASS.OPAQUE.__doc__ = "Render during the opaque rendering pass."
RENDER_PASS.TRANSLUCENT.__doc__ = "Render during the translucent rendering pass."
RENDER_PASS.CENTRAL_BODY_CLIPPED.__doc__ = "Render before the central body is rendered."
RENDER_PASS.ORDERED_COMPOSITE_CENTRAL_BODY_CLIPPED.__doc__ = "Rendered in an ordered composite before all other primitives and before the central body is rendered."
RENDER_PASS.ORDERED_COMPOSITE.__doc__ = "Rendered in an ordered composite before all primitives but after the central body is rendered."
RENDER_PASS.TERRAIN.__doc__ = "Render after the terrain is rendered."

agcls.AgTypeNameMap["RENDER_PASS"] = RENDER_PASS

class RENDER_PASS_HINT(IntEnum):
    """An optimization hint optionally provided to a primitive'sSet method to enhance performance when per-position colors are used."""
   
    OPAQUE = 0
    """The collection of colors contains only opaque colors. This implies that each color's alpha component is 255."""
    TRANSLUCENT = 1
    """The collection of colors contains translucent colors. This implies that at least one color has an alpha component that is not 255."""
    UNKNOWN = 2
    """It is unknown if the collection of colors contains opaque or translucent colors."""

RENDER_PASS_HINT.OPAQUE.__doc__ = "The collection of colors contains only opaque colors. This implies that each color's alpha component is 255."
RENDER_PASS_HINT.TRANSLUCENT.__doc__ = "The collection of colors contains translucent colors. This implies that at least one color has an alpha component that is not 255."
RENDER_PASS_HINT.UNKNOWN.__doc__ = "It is unknown if the collection of colors contains opaque or translucent colors."

agcls.AgTypeNameMap["RENDER_PASS_HINT"] = RENDER_PASS_HINT

class SCREEN_OVERLAY_ORIGIN(IntEnum):
    """Specify the origin of a screen overlay, as well as the direction of the horizontal and vertical axes. The origin specifies both the origin in the parent overlay's coordinate system and the origin within the overlay itself that is positioned."""
   
    BOTTOM_LEFT = 0
    """When the X and Y position are both set to 0, this value places the bottom, left corner of the overlay in its parent's bottom, left corner. Increasing X values move the overlay to the right and increasing Y values move it up."""
    BOTTOM_CENTER = 1
    """When the X and Y position are both set to 0, this value places the bottom edge of the overlay at its parent's bottom edge and the center of the overlay is horizontally centered within its parent..."""
    BOTTOM_RIGHT = 2
    """When the X and Y position are both set to 0, this value places the bottom, right corner of the overlay in its parent's bottom, right corner. Increasing X values move the overlay to the left and increasing Y values move it up."""
    CENTER_LEFT = 3
    """When the X and Y position are both set to 0, this value places the left edge of the overlay at its parent's left edge and the center of the overlay is vertically centered within its parent..."""
    CENTER = 4
    """When the X and Y position are both set to 0, this value places the center of the overlay at its parent's center. Increasing X values move the overlay to the right and increasing Y values move it up."""
    CENTER_RIGHT = 5
    """When the X and Y position are both set to 0, this value places the right edge of the overlay at its parent's right edge and the center of the overlay is vertically centered within its parent..."""
    TOP_LEFT = 6
    """When the X and Y position are both set to 0, this value places the top, left corner of the overlay in its parent's top, left corner. Increasing X values move the overlay to the right and increasing Y values move it down."""
    TOP_CENTER = 7
    """When the X and Y position are both set to 0, this value places the top edge of the overlay at its parent's top edge and the center of the overlay is horizontally centered within its parent..."""
    TOP_RIGHT = 8
    """When the X and Y position are both set to 0, this value places the top, right corner of the overlay in its parent's top, right corner. Increasing X values move the overlay to the left and increasing Y values move it down."""

SCREEN_OVERLAY_ORIGIN.BOTTOM_LEFT.__doc__ = "When the X and Y position are both set to 0, this value places the bottom, left corner of the overlay in its parent's bottom, left corner. Increasing X values move the overlay to the right and increasing Y values move it up."
SCREEN_OVERLAY_ORIGIN.BOTTOM_CENTER.__doc__ = "When the X and Y position are both set to 0, this value places the bottom edge of the overlay at its parent's bottom edge and the center of the overlay is horizontally centered within its parent..."
SCREEN_OVERLAY_ORIGIN.BOTTOM_RIGHT.__doc__ = "When the X and Y position are both set to 0, this value places the bottom, right corner of the overlay in its parent's bottom, right corner. Increasing X values move the overlay to the left and increasing Y values move it up."
SCREEN_OVERLAY_ORIGIN.CENTER_LEFT.__doc__ = "When the X and Y position are both set to 0, this value places the left edge of the overlay at its parent's left edge and the center of the overlay is vertically centered within its parent..."
SCREEN_OVERLAY_ORIGIN.CENTER.__doc__ = "When the X and Y position are both set to 0, this value places the center of the overlay at its parent's center. Increasing X values move the overlay to the right and increasing Y values move it up."
SCREEN_OVERLAY_ORIGIN.CENTER_RIGHT.__doc__ = "When the X and Y position are both set to 0, this value places the right edge of the overlay at its parent's right edge and the center of the overlay is vertically centered within its parent..."
SCREEN_OVERLAY_ORIGIN.TOP_LEFT.__doc__ = "When the X and Y position are both set to 0, this value places the top, left corner of the overlay in its parent's top, left corner. Increasing X values move the overlay to the right and increasing Y values move it down."
SCREEN_OVERLAY_ORIGIN.TOP_CENTER.__doc__ = "When the X and Y position are both set to 0, this value places the top edge of the overlay at its parent's top edge and the center of the overlay is horizontally centered within its parent..."
SCREEN_OVERLAY_ORIGIN.TOP_RIGHT.__doc__ = "When the X and Y position are both set to 0, this value places the top, right corner of the overlay in its parent's top, right corner. Increasing X values move the overlay to the left and increasing Y values move it down."

agcls.AgTypeNameMap["SCREEN_OVERLAY_ORIGIN"] = SCREEN_OVERLAY_ORIGIN

class SCREEN_OVERLAY_PINNING_ORIGIN(IntEnum):
    """Specify the origin of the pinning position of the screen overlay, as well as the direction of the horizontal and vertical axes for that pinning position. The pinning origin specifies the origin of the pinning position in the overlay's coordinate system."""
   
    BOTTOM_LEFT = 0
    """When the X and Y pinning position are both set to 0, this value places the pinning position in the overlay's bottom, left corner. Increasing X values move the pinning position to the right and increasing Y values move it up."""
    BOTTOM_CENTER = 1
    """When the X and Y pinning position are both set to 0, this value places the pinning position at its overlay's bottom edge and the pinning position is horizontally centered within its overlay..."""
    BOTTOM_RIGHT = 2
    """When the X and Y pinning position are both set to 0, this value places the pinning position in its overlay's bottom, right corner. Increasing X values move the pinning position to the left and increasing Y values move it up."""
    CENTER_LEFT = 3
    """When the X and Y pinning position are both set to 0, this value places the pinning position at its overlay's left edge and the pinning position is vertically centered within its overlay..."""
    CENTER = 4
    """When the X and Y pinning position are both set to 0, this value places the pinning position at its overlay's center. Increasing X values move the pinning position to the right and increasing Y values move it up."""
    CENTER_RIGHT = 5
    """When the X and Y pinning pinning position are both set to 0, this value places the pinning position at its overlay's right edge and the pinning position is vertically centered within its overlay..."""
    TOP_LEFT = 6
    """When the X and Y pinning position are both set to 0, this value places the pinning position in its overlay's top, left corner. Increasing X values move the pinning position to the right and increasing Y values move it down."""
    TOP_CENTER = 7
    """When the X and Y pinning position are both set to 0, this value places the pinning position at its overlays's top edge and the pinning position is horizontally centered within its overlay..."""
    TOP_RIGHT = 8
    """When the X and Y pinning position are both set to 0, this value places the pinning position in its overlay's top, right corner. Increasing X values move the pinning position to the left and increasing Y values move it down."""
    AUTOMATIC = 9
    """The pinning origin is automatically set to the origin of the overlay. For instance, if the origin of the overlay is ScreenOverlayOrigin.BottomLeft, the pinning origin will also be equivalent to ScreenOverlayPinningOrigin.BottomLeft."""

SCREEN_OVERLAY_PINNING_ORIGIN.BOTTOM_LEFT.__doc__ = "When the X and Y pinning position are both set to 0, this value places the pinning position in the overlay's bottom, left corner. Increasing X values move the pinning position to the right and increasing Y values move it up."
SCREEN_OVERLAY_PINNING_ORIGIN.BOTTOM_CENTER.__doc__ = "When the X and Y pinning position are both set to 0, this value places the pinning position at its overlay's bottom edge and the pinning position is horizontally centered within its overlay..."
SCREEN_OVERLAY_PINNING_ORIGIN.BOTTOM_RIGHT.__doc__ = "When the X and Y pinning position are both set to 0, this value places the pinning position in its overlay's bottom, right corner. Increasing X values move the pinning position to the left and increasing Y values move it up."
SCREEN_OVERLAY_PINNING_ORIGIN.CENTER_LEFT.__doc__ = "When the X and Y pinning position are both set to 0, this value places the pinning position at its overlay's left edge and the pinning position is vertically centered within its overlay..."
SCREEN_OVERLAY_PINNING_ORIGIN.CENTER.__doc__ = "When the X and Y pinning position are both set to 0, this value places the pinning position at its overlay's center. Increasing X values move the pinning position to the right and increasing Y values move it up."
SCREEN_OVERLAY_PINNING_ORIGIN.CENTER_RIGHT.__doc__ = "When the X and Y pinning pinning position are both set to 0, this value places the pinning position at its overlay's right edge and the pinning position is vertically centered within its overlay..."
SCREEN_OVERLAY_PINNING_ORIGIN.TOP_LEFT.__doc__ = "When the X and Y pinning position are both set to 0, this value places the pinning position in its overlay's top, left corner. Increasing X values move the pinning position to the right and increasing Y values move it down."
SCREEN_OVERLAY_PINNING_ORIGIN.TOP_CENTER.__doc__ = "When the X and Y pinning position are both set to 0, this value places the pinning position at its overlays's top edge and the pinning position is horizontally centered within its overlay..."
SCREEN_OVERLAY_PINNING_ORIGIN.TOP_RIGHT.__doc__ = "When the X and Y pinning position are both set to 0, this value places the pinning position in its overlay's top, right corner. Increasing X values move the pinning position to the left and increasing Y values move it down."
SCREEN_OVERLAY_PINNING_ORIGIN.AUTOMATIC.__doc__ = "The pinning origin is automatically set to the origin of the overlay. For instance, if the origin of the overlay is ScreenOverlayOrigin.BottomLeft, the pinning origin will also be equivalent to ScreenOverlayPinningOrigin.BottomLeft."

agcls.AgTypeNameMap["SCREEN_OVERLAY_PINNING_ORIGIN"] = SCREEN_OVERLAY_PINNING_ORIGIN

class SCREEN_OVERLAY_UNIT(IntEnum):
    """A unit specifying how a screen overlay is sized and positioned relative to its parent."""
   
    PIXELS = 0
    """The value is specified in pixels."""
    FRACTION = 1
    """The value is specified as a fraction of the overlay's parent, where 0.0 is 0% and 1.0 is 100%."""

SCREEN_OVERLAY_UNIT.PIXELS.__doc__ = "The value is specified in pixels."
SCREEN_OVERLAY_UNIT.FRACTION.__doc__ = "The value is specified as a fraction of the overlay's parent, where 0.0 is 0% and 1.0 is 100%."

agcls.AgTypeNameMap["SCREEN_OVERLAY_UNIT"] = SCREEN_OVERLAY_UNIT

class SURFACE_MESH_RENDERING_METHOD(IntEnum):
    """Rendering methods available for use by the surface mesh primitive. Different methods may have different performance characteristics and require different video card support. When in doubt, use Automatic."""
   
    GEOMETRY_SHADER = 0
    """Render the surface mesh using a geometry shader."""
    VERTEX_SHADER = 1
    """Render the surface mesh using a vertex shader."""
    AUTOMATIC = 2
    """Render the surface mesh using an automatically selected method based on the capabilities of the video card."""

SURFACE_MESH_RENDERING_METHOD.GEOMETRY_SHADER.__doc__ = "Render the surface mesh using a geometry shader."
SURFACE_MESH_RENDERING_METHOD.VERTEX_SHADER.__doc__ = "Render the surface mesh using a vertex shader."
SURFACE_MESH_RENDERING_METHOD.AUTOMATIC.__doc__ = "Render the surface mesh using an automatically selected method based on the capabilities of the video card."

agcls.AgTypeNameMap["SURFACE_MESH_RENDERING_METHOD"] = SURFACE_MESH_RENDERING_METHOD

class VISIBILITY(IntEnum):
    """Result of a visibility test, such as testing if a sphere intersects a frustum."""
   
    NONE = 0
    """The object is not visible."""
    PARTIAL = 1
    """The object is partially visible."""
    ALL = 2
    """The object is completely visible."""

VISIBILITY.NONE.__doc__ = "The object is not visible."
VISIBILITY.PARTIAL.__doc__ = "The object is partially visible."
VISIBILITY.ALL.__doc__ = "The object is completely visible."

agcls.AgTypeNameMap["VISIBILITY"] = VISIBILITY

class ANTI_ALIASING(IntEnum):
    """The multisample anti-aliasing (MSAA) options for Scenes. As the level of anti-aliasing increases, performance will generally decrease, but the quality of the anti-aliasing will improve."""
   
    OFF = 0
    """No anti-aliasing."""
    FXAA = 1
    """Fast Approximate Anti aliasing."""
    TWO_X = 2
    """Anti-aliasing at 2x."""
    FOUR_X = 4
    """Anti-aliasing at 4x."""
    EIGHT_X = 8
    """Anti-aliasing at 8x."""
    SIXTEEN_X = 16
    """Anti-aliasing at 16x."""
    THIRTY_TWO_X = 32
    """Anti-aliasing at 32x."""
    SIXTY_FOUR_X = 64
    """Anti-aliasing at 64x."""

ANTI_ALIASING.OFF.__doc__ = "No anti-aliasing."
ANTI_ALIASING.FXAA.__doc__ = "Fast Approximate Anti aliasing."
ANTI_ALIASING.TWO_X.__doc__ = "Anti-aliasing at 2x."
ANTI_ALIASING.FOUR_X.__doc__ = "Anti-aliasing at 4x."
ANTI_ALIASING.EIGHT_X.__doc__ = "Anti-aliasing at 8x."
ANTI_ALIASING.SIXTEEN_X.__doc__ = "Anti-aliasing at 16x."
ANTI_ALIASING.THIRTY_TWO_X.__doc__ = "Anti-aliasing at 32x."
ANTI_ALIASING.SIXTY_FOUR_X.__doc__ = "Anti-aliasing at 64x."

agcls.AgTypeNameMap["ANTI_ALIASING"] = ANTI_ALIASING

class BINARY_LOGIC_OPERATION(IntEnum):
    """Binary logic operations that can be used by composite display condition."""
   
    AND = 0
    """Logically and together display conditions in the composite."""
    OR = 1
    """Logically or together display conditions in the composite."""

BINARY_LOGIC_OPERATION.AND.__doc__ = "Logically and together display conditions in the composite."
BINARY_LOGIC_OPERATION.OR.__doc__ = "Logically or together display conditions in the composite."

agcls.AgTypeNameMap["BINARY_LOGIC_OPERATION"] = BINARY_LOGIC_OPERATION

class BLUR_METHOD(IntEnum):
    """The method used to blur or smooth a raster."""
   
    MEAN = 0
    """Provide smoothing and noise reduction through mean filtering."""
    BASIC = 1
    """Provide basic blurring."""

BLUR_METHOD.MEAN.__doc__ = "Provide smoothing and noise reduction through mean filtering."
BLUR_METHOD.BASIC.__doc__ = "Provide basic blurring."

agcls.AgTypeNameMap["BLUR_METHOD"] = BLUR_METHOD

class EDGE_DETECT_METHOD(IntEnum):
    """The method used to detect edges in a raster."""
   
    VERTICAL = 0
    """Detects vertical edges."""
    HORIZONTAL = 1
    """Detects horizontal edges."""
    LEFT_DIAGONAL = 2
    """Detects left diagonal edges."""
    RIGHT_DIAGONAL = 3
    """Detects right diagonal edges."""
    LAPLACIAN = 4
    """Detects edges using the Laplacian method."""
    PREWITT_LAPLACIAN = 5
    """Detects edges using the Prewitt-Laplacian method."""
    SOBEL_VERTICAL = 6
    """Detects vertical edges using the Sobel method."""
    SOBEL_HORIZONTAL = 7
    """Detects horizontal edges using the Sobel method."""

EDGE_DETECT_METHOD.VERTICAL.__doc__ = "Detects vertical edges."
EDGE_DETECT_METHOD.HORIZONTAL.__doc__ = "Detects horizontal edges."
EDGE_DETECT_METHOD.LEFT_DIAGONAL.__doc__ = "Detects left diagonal edges."
EDGE_DETECT_METHOD.RIGHT_DIAGONAL.__doc__ = "Detects right diagonal edges."
EDGE_DETECT_METHOD.LAPLACIAN.__doc__ = "Detects edges using the Laplacian method."
EDGE_DETECT_METHOD.PREWITT_LAPLACIAN.__doc__ = "Detects edges using the Prewitt-Laplacian method."
EDGE_DETECT_METHOD.SOBEL_VERTICAL.__doc__ = "Detects vertical edges using the Sobel method."
EDGE_DETECT_METHOD.SOBEL_HORIZONTAL.__doc__ = "Detects horizontal edges using the Sobel method."

agcls.AgTypeNameMap["EDGE_DETECT_METHOD"] = EDGE_DETECT_METHOD

class FLIP_AXIS(IntEnum):
    """The axis on which a raster will be flipped."""
   
    HORIZONTAL = 0
    """The horizontal axis."""
    VERTICAL = 1
    """The vertical axis."""

FLIP_AXIS.HORIZONTAL.__doc__ = "The horizontal axis."
FLIP_AXIS.VERTICAL.__doc__ = "The vertical axis."

agcls.AgTypeNameMap["FLIP_AXIS"] = FLIP_AXIS

class GRADIENT_DETECT_METHOD(IntEnum):
    """The method used to detect gradients in a raster. Gradient detection is commonly referred to as embossing."""
   
    EAST = 0
    """Detects east gradients."""
    NORTH = 1
    """Detects north gradients."""
    WEST = 2
    """Detects west gradients."""
    SOUTH = 3
    """Detects south gradients."""
    NORTH_EAST = 4
    """Detects north east gradients."""
    NORTH_WEST = 5
    """Detects north west gradients."""
    SOUTH_EAST = 6
    """Detects south east gradients."""
    SOUTH_WEST = 7
    """Detects south west gradients."""

GRADIENT_DETECT_METHOD.EAST.__doc__ = "Detects east gradients."
GRADIENT_DETECT_METHOD.NORTH.__doc__ = "Detects north gradients."
GRADIENT_DETECT_METHOD.WEST.__doc__ = "Detects west gradients."
GRADIENT_DETECT_METHOD.SOUTH.__doc__ = "Detects south gradients."
GRADIENT_DETECT_METHOD.NORTH_EAST.__doc__ = "Detects north east gradients."
GRADIENT_DETECT_METHOD.NORTH_WEST.__doc__ = "Detects north west gradients."
GRADIENT_DETECT_METHOD.SOUTH_EAST.__doc__ = "Detects south east gradients."
GRADIENT_DETECT_METHOD.SOUTH_WEST.__doc__ = "Detects south west gradients."

agcls.AgTypeNameMap["GRADIENT_DETECT_METHOD"] = GRADIENT_DETECT_METHOD

class JPEG2000_COMPRESSION_PROFILE(IntEnum):
    """Define the profile used when encoding a JPEG 2000 file."""
   
    DEFAULT = 0
    """This is the default profile, which is recommended for those unfamiliar with the others."""
    NITF_BIIF_NPJE = 1
    """This profile is designed for U.S. and NATO military applications."""
    NITF_BIIF_EPJE = 2
    """This profile is designed for U.S. and NATO military applications. Based on NPJE, the profile is used for image exploitation, and improves image read times for lower resolutions in large images as compared to NPJE."""

JPEG2000_COMPRESSION_PROFILE.DEFAULT.__doc__ = "This is the default profile, which is recommended for those unfamiliar with the others."
JPEG2000_COMPRESSION_PROFILE.NITF_BIIF_NPJE.__doc__ = "This profile is designed for U.S. and NATO military applications."
JPEG2000_COMPRESSION_PROFILE.NITF_BIIF_EPJE.__doc__ = "This profile is designed for U.S. and NATO military applications. Based on NPJE, the profile is used for image exploitation, and improves image read times for lower resolutions in large images as compared to NPJE."

agcls.AgTypeNameMap["JPEG2000_COMPRESSION_PROFILE"] = JPEG2000_COMPRESSION_PROFILE

class RASTER_BAND(IntEnum):
    """Common band types that may be contained within a raster dataset. Each band can be thought of as a set of values, which are most commonly associated with colors when the raster represents an image..."""
   
    RED = 0
    """A band containing red values."""
    GREEN = 1
    """A band containing green values."""
    BLUE = 2
    """A band containing blue values."""
    ALPHA = 3
    """A band containing alpha values."""
    LUMINANCE = 4
    """A band containing luminance values."""

RASTER_BAND.RED.__doc__ = "A band containing red values."
RASTER_BAND.GREEN.__doc__ = "A band containing green values."
RASTER_BAND.BLUE.__doc__ = "A band containing blue values."
RASTER_BAND.ALPHA.__doc__ = "A band containing alpha values."
RASTER_BAND.LUMINANCE.__doc__ = "A band containing luminance values."

agcls.AgTypeNameMap["RASTER_BAND"] = RASTER_BAND

class RASTER_FORMAT(IntEnum):
    """Common raster band layouts that may be contained within a raster dataset. Each pixel of the raster will contain the bands defined by the layout in the specified order. A typical color raster image will have an rgbraster format."""
   
    RED = 0
    """The format of the raster is a single band consisting of red values."""
    GREEN = 1
    """The format of the raster is a single band consisting of green values."""
    BLUE = 2
    """The format of the raster is a single band consisting of blue values."""
    ALPHA = 3
    """The format of the raster is a single band consisting of alpha values."""
    RGB = 4
    """The format of the raster is three bands consisting of red, green, and blue values."""
    BGR = 5
    """The format of the raster is three bands consisting of blue, green, and red values."""
    RGBA = 6
    """The format of the raster is four bands consisting of red, green, blue, and alpha values."""
    BGRA = 7
    """The format of the raster is four bands consisting of blue, green, red, and alpha values."""
    LUMINANCE = 8
    """The format of the raster is a single band consisting of luminance values."""
    LUMINANCE_ALPHA = 9
    """The format of the raster is two bands consisting of luminance and alpha values."""

RASTER_FORMAT.RED.__doc__ = "The format of the raster is a single band consisting of red values."
RASTER_FORMAT.GREEN.__doc__ = "The format of the raster is a single band consisting of green values."
RASTER_FORMAT.BLUE.__doc__ = "The format of the raster is a single band consisting of blue values."
RASTER_FORMAT.ALPHA.__doc__ = "The format of the raster is a single band consisting of alpha values."
RASTER_FORMAT.RGB.__doc__ = "The format of the raster is three bands consisting of red, green, and blue values."
RASTER_FORMAT.BGR.__doc__ = "The format of the raster is three bands consisting of blue, green, and red values."
RASTER_FORMAT.RGBA.__doc__ = "The format of the raster is four bands consisting of red, green, blue, and alpha values."
RASTER_FORMAT.BGRA.__doc__ = "The format of the raster is four bands consisting of blue, green, red, and alpha values."
RASTER_FORMAT.LUMINANCE.__doc__ = "The format of the raster is a single band consisting of luminance values."
RASTER_FORMAT.LUMINANCE_ALPHA.__doc__ = "The format of the raster is two bands consisting of luminance and alpha values."

agcls.AgTypeNameMap["RASTER_FORMAT"] = RASTER_FORMAT

class RASTER_ORIENTATION(IntEnum):
    """The vertical orientation of the raster."""
   
    TOP_TO_BOTTOM = 0
    """The raster has a top to bottom orientation."""
    BOTTOM_TO_TOP = 1
    """The raster has a bottom to top orientation."""

RASTER_ORIENTATION.TOP_TO_BOTTOM.__doc__ = "The raster has a top to bottom orientation."
RASTER_ORIENTATION.BOTTOM_TO_TOP.__doc__ = "The raster has a bottom to top orientation."

agcls.AgTypeNameMap["RASTER_ORIENTATION"] = RASTER_ORIENTATION

class RASTER_TYPE(IntEnum):
    """The type of data contained within each band of a raster dataset."""
   
    UNSIGNED_BYTE = 0
    """Each value contained within a band can be represented with an unsigned byte."""
    BYTE = 1
    """Each value contained within a band can be represented with a byte."""
    UNSIGNED_SHORT = 2
    """Each value contained within a band can be represented with an unsigned short."""
    SHORT = 3
    """Each value contained within a band can be represented with a short."""
    UNSIGNED_INT = 4
    """Each value contained within a band can be represented with an unsigned int."""
    INT = 5
    """Each value contained within a band can be represented with an int."""
    FLOAT = 6
    """Each value contained within a band can be represented with a float."""
    DOUBLE = 7
    """Each value contained within a band can be represented with a double."""

RASTER_TYPE.UNSIGNED_BYTE.__doc__ = "Each value contained within a band can be represented with an unsigned byte."
RASTER_TYPE.BYTE.__doc__ = "Each value contained within a band can be represented with a byte."
RASTER_TYPE.UNSIGNED_SHORT.__doc__ = "Each value contained within a band can be represented with an unsigned short."
RASTER_TYPE.SHORT.__doc__ = "Each value contained within a band can be represented with a short."
RASTER_TYPE.UNSIGNED_INT.__doc__ = "Each value contained within a band can be represented with an unsigned int."
RASTER_TYPE.INT.__doc__ = "Each value contained within a band can be represented with an int."
RASTER_TYPE.FLOAT.__doc__ = "Each value contained within a band can be represented with a float."
RASTER_TYPE.DOUBLE.__doc__ = "Each value contained within a band can be represented with a double."

agcls.AgTypeNameMap["RASTER_TYPE"] = RASTER_TYPE

class SHARPEN_METHOD(IntEnum):
    """The method used to sharpen a raster."""
   
    MEAN_REMOVAL = 0
    """Provide sharpening through mean removal."""
    BASIC = 1
    """Provide basic sharpening."""

SHARPEN_METHOD.MEAN_REMOVAL.__doc__ = "Provide sharpening through mean removal."
SHARPEN_METHOD.BASIC.__doc__ = "Provide basic sharpening."

agcls.AgTypeNameMap["SHARPEN_METHOD"] = SHARPEN_METHOD

class VIDEO_PLAYBACK(IntEnum):
    """Specify how the video stream will playback. When the playback is set to real time, the video will playback in real time..."""
   
    REAL_TIME = 0
    """The video will playback in realtime."""
    TIME_INTERVAL = 1
    """The video will playback in coincidence with the scene manager time within the interval defined by interval start time and interval end time."""

VIDEO_PLAYBACK.REAL_TIME.__doc__ = "The video will playback in realtime."
VIDEO_PLAYBACK.TIME_INTERVAL.__doc__ = "The video will playback in coincidence with the scene manager time within the interval defined by interval start time and interval end time."

agcls.AgTypeNameMap["VIDEO_PLAYBACK"] = VIDEO_PLAYBACK

class KML_NETWORK_LINK_REFRESH_MODE(IntEnum):
    """Define the options available for a KmlNetworkLink's RefreshMode property."""
   
    ON_CHANGE = 0
    """Refresh when the document is loaded and whenever the Link parameters change (the default)."""
    ON_INTERVAL = 1
    """Refresh the network link at the duration specified by refresh interval."""
    ON_EXPIRE = 2
    """Refresh the network link when the expiration time is reached."""

KML_NETWORK_LINK_REFRESH_MODE.ON_CHANGE.__doc__ = "Refresh when the document is loaded and whenever the Link parameters change (the default)."
KML_NETWORK_LINK_REFRESH_MODE.ON_INTERVAL.__doc__ = "Refresh the network link at the duration specified by refresh interval."
KML_NETWORK_LINK_REFRESH_MODE.ON_EXPIRE.__doc__ = "Refresh the network link when the expiration time is reached."

agcls.AgTypeNameMap["KML_NETWORK_LINK_REFRESH_MODE"] = KML_NETWORK_LINK_REFRESH_MODE

class KML_NETWORK_LINK_VIEW_REFRESH_MODE(IntEnum):
    """Define the options available for a KmlNetworkLink's ViewRefreshMode property."""
   
    NEVER = 0
    """Do not refresh the network link when the camera's view changes."""
    ON_REQUEST = 1
    """Only refresh the network link when it is explicitly refreshed by calling the refresh method."""
    ON_STOP = 2
    """Refresh the network link after camera view movement stops for the duration specified by view refresh time."""
    ON_REGION = 3
    """Refresh the network link when the region associated with this link becomes active."""

KML_NETWORK_LINK_VIEW_REFRESH_MODE.NEVER.__doc__ = "Do not refresh the network link when the camera's view changes."
KML_NETWORK_LINK_VIEW_REFRESH_MODE.ON_REQUEST.__doc__ = "Only refresh the network link when it is explicitly refreshed by calling the refresh method."
KML_NETWORK_LINK_VIEW_REFRESH_MODE.ON_STOP.__doc__ = "Refresh the network link after camera view movement stops for the duration specified by view refresh time."
KML_NETWORK_LINK_VIEW_REFRESH_MODE.ON_REGION.__doc__ = "Refresh the network link when the region associated with this link becomes active."

agcls.AgTypeNameMap["KML_NETWORK_LINK_VIEW_REFRESH_MODE"] = KML_NETWORK_LINK_VIEW_REFRESH_MODE

class MODEL_UP_AXIS(IntEnum):
    """When setting the camera'saxes, this defines which axis of the axes is up in screen space, where up is from the bottom to the top of the screen."""
   
    X = 0
    """The positive X axis."""
    Y = 1
    """The positive Y axis."""
    Z = 2
    """The positive Z axis."""
    NEGATIVE_X = 3
    """The negative X axis."""
    NEGATIVE_Y = 4
    """The negative Y axis."""
    NEGATIVE_Z = 5
    """The negative Z axis."""

MODEL_UP_AXIS.X.__doc__ = "The positive X axis."
MODEL_UP_AXIS.Y.__doc__ = "The positive Y axis."
MODEL_UP_AXIS.Z.__doc__ = "The positive Z axis."
MODEL_UP_AXIS.NEGATIVE_X.__doc__ = "The negative X axis."
MODEL_UP_AXIS.NEGATIVE_Y.__doc__ = "The negative Y axis."
MODEL_UP_AXIS.NEGATIVE_Z.__doc__ = "The negative Z axis."

agcls.AgTypeNameMap["MODEL_UP_AXIS"] = MODEL_UP_AXIS

class OUTLINE_APPEARANCE(IntEnum):
    """Possible appearances of an outline. Front lines are lines on front facing geometry and back lines are lines on back facing geometry."""
   
    FRONT_AND_BACK_LINES = 0
    """Both the front and back lines are displayed."""
    FRONT_LINES_ONLY = 1
    """Only the front lines are displayed. This can be used to declutter the outline."""
    STYLIZE_BACK_LINES = 2
    """Both the front and back lines are displayed. The back lines are displayed using a different color, translucency, and width. This is used to declutter the outline but still provide a visual cue for the back facing geometry."""

OUTLINE_APPEARANCE.FRONT_AND_BACK_LINES.__doc__ = "Both the front and back lines are displayed."
OUTLINE_APPEARANCE.FRONT_LINES_ONLY.__doc__ = "Only the front lines are displayed. This can be used to declutter the outline."
OUTLINE_APPEARANCE.STYLIZE_BACK_LINES.__doc__ = "Both the front and back lines are displayed. The back lines are displayed using a different color, translucency, and width. This is used to declutter the outline but still provide a visual cue for the back facing geometry."

agcls.AgTypeNameMap["OUTLINE_APPEARANCE"] = OUTLINE_APPEARANCE

class POLYLINE_TYPE(IntEnum):
    """Describes how to interpret positions defining a polyline."""
   
    LINES = 0
    """Every two positions define a line segment. Line segments are not required to be connected to each other."""
    LINE_STRIP = 1
    """After the first position, each additional position defines a line segment from the previous position to the current position."""
    POINTS = 2
    """Lines are drawn as points."""

POLYLINE_TYPE.LINES.__doc__ = "Every two positions define a line segment. Line segments are not required to be connected to each other."
POLYLINE_TYPE.LINE_STRIP.__doc__ = "After the first position, each additional position defines a line segment from the previous position to the current position."
POLYLINE_TYPE.POINTS.__doc__ = "Lines are drawn as points."

agcls.AgTypeNameMap["POLYLINE_TYPE"] = POLYLINE_TYPE

class CULL_FACE(IntEnum):
    """Identifies whether front- and/or back-facing triangles are culled."""
   
    E_CULL_FACE_FRONT = 0
    """Front-facing triangles are culled."""
    E_CULL_FACE_BACK = 1
    """Back-facing triangles are culled."""
    E_CULL_FACE_FRONT_AND_BACK = 2
    """Both front- and back-facing triangles are culled. Therefore, no triangles are rendered."""
    E_CULL_FACE_NEITHER = 3
    """No triangles are culled."""

CULL_FACE.E_CULL_FACE_FRONT.__doc__ = "Front-facing triangles are culled."
CULL_FACE.E_CULL_FACE_BACK.__doc__ = "Back-facing triangles are culled."
CULL_FACE.E_CULL_FACE_FRONT_AND_BACK.__doc__ = "Both front- and back-facing triangles are culled. Therefore, no triangles are rendered."
CULL_FACE.E_CULL_FACE_NEITHER.__doc__ = "No triangles are culled."

agcls.AgTypeNameMap["CULL_FACE"] = CULL_FACE

class INTERNAL_TEXTURE_FORMAT(IntEnum):
    """The format of individual texels in a texture."""
   
    ALPHA4 = 0
    """Each texel is an 4-bit alpha component."""
    ALPHA8 = 1
    """Each texel is an 8-bit alpha component."""
    ALPHA12 = 2
    """Each texel is an 12-bit alpha component."""
    ALPHA16 = 3
    """Each texel is an 16-bit alpha component."""
    R3G3B2 = 4
    """Each texel contains 3-bit red and green components and 2-bit blue component."""
    RGB4 = 5
    """Each texel contains 4-bit red, green, and blue components."""
    RGB5 = 6
    """Each texel contains 5-bit red, green, and blue components."""
    RGB8 = 7
    """Each texel contains 8-bit red, green, and blue components."""
    RGB10 = 8
    """Each texel contains 10-bit red, green, and blue components."""
    RGB12 = 9
    """Each texel contains 12-bit red, green, and blue components."""
    RGB16 = 10
    """Each texel contains 16-bit red, green, and blue components."""
    RGB16_F = 11
    """Each texel contains 16-bit red, green, and blue floating point components."""
    RGB32_F = 12
    """Each texel contains 32-bit red, green, and blue floating point components."""
    RGBA2 = 13
    """Each texel contains 2-bit red, green, blue, and alpha components."""
    RGBA4 = 14
    """Each texel contains 4-bit red, green, blue, and alpha components."""
    RGB5_A1 = 15
    """Each texel contains 5-bit red, green, blue components and 1-bit alpha component."""
    RGBA8 = 16
    """Each texel contains 8-bit red, green, blue, and alpha components."""
    RGB10_A2 = 17
    """Each texel contains 10-bit red, green, blue components and 2-bit alpha component."""
    RGBA12 = 18
    """Each texel contains 12-bit red, green, blue, and alpha components."""
    RGBA16 = 19
    """Each texel contains 16-bit red, green, blue, and alpha components."""
    RGBA16_F = 20
    """Each texel contains 16-bit red, green, blue, and alpha floating point components."""
    RGBA32_F = 21
    """Each texel contains 32-bit red, green, blue, and alpha floating point components."""
    LUMINANCE4 = 22
    """Each texel is an 4-bit luminance, e.g. intensity, component."""
    LUMINANCE8 = 23
    """Each texel is an 8-bit luminance, e.g. intensity, component."""
    LUMINANCE12 = 24
    """Each texel is an 12-bit luminance, e.g. intensity, component."""
    LUMINANCE16 = 25
    """Each texel is an 16-bit luminance, e.g. intensity, component."""
    LUMINANCE16_F = 26
    """Each texel is an 16-bit luminance, e.g. intensity, floating point component."""
    LUMINANCE32_F = 27
    """Each texel is an 32-bit luminance, e.g. intensity, floating point component."""
    LUMINANCE4_ALPHA4 = 28
    """Each texel contains an 4-bit luminance and 4-bit alpha component."""
    LUMINANCE6_ALPHA2 = 29
    """Each texel contains an 6-bit luminance and 2-bit alpha component."""
    LUMINANCE8_ALPHA8 = 30
    """Each texel contains an 8-bit luminance and 8-bit alpha component."""
    LUMINANCE12_ALPHA4 = 31
    """Each texel contains an 12-bit luminance and 4-bit alpha component."""
    LUMINANCE12_ALPHA12 = 32
    """Each texel contains an 12-bit luminance and 12-bit alpha component."""
    LUMINANCE16_ALPHA16 = 33
    """Each texel contains an 16-bit luminance and 16-bit alpha component."""
    LUMINANCE16_ALPHA16_F = 34
    """Each texel contains an 16-bit luminance and 16-bit alpha floating point component."""
    LUMINANCE32_ALPHA32_F = 35
    """Each texel contains an 32-bit luminance and 32-bit alpha floating point component."""

INTERNAL_TEXTURE_FORMAT.ALPHA4.__doc__ = "Each texel is an 4-bit alpha component."
INTERNAL_TEXTURE_FORMAT.ALPHA8.__doc__ = "Each texel is an 8-bit alpha component."
INTERNAL_TEXTURE_FORMAT.ALPHA12.__doc__ = "Each texel is an 12-bit alpha component."
INTERNAL_TEXTURE_FORMAT.ALPHA16.__doc__ = "Each texel is an 16-bit alpha component."
INTERNAL_TEXTURE_FORMAT.R3G3B2.__doc__ = "Each texel contains 3-bit red and green components and 2-bit blue component."
INTERNAL_TEXTURE_FORMAT.RGB4.__doc__ = "Each texel contains 4-bit red, green, and blue components."
INTERNAL_TEXTURE_FORMAT.RGB5.__doc__ = "Each texel contains 5-bit red, green, and blue components."
INTERNAL_TEXTURE_FORMAT.RGB8.__doc__ = "Each texel contains 8-bit red, green, and blue components."
INTERNAL_TEXTURE_FORMAT.RGB10.__doc__ = "Each texel contains 10-bit red, green, and blue components."
INTERNAL_TEXTURE_FORMAT.RGB12.__doc__ = "Each texel contains 12-bit red, green, and blue components."
INTERNAL_TEXTURE_FORMAT.RGB16.__doc__ = "Each texel contains 16-bit red, green, and blue components."
INTERNAL_TEXTURE_FORMAT.RGB16_F.__doc__ = "Each texel contains 16-bit red, green, and blue floating point components."
INTERNAL_TEXTURE_FORMAT.RGB32_F.__doc__ = "Each texel contains 32-bit red, green, and blue floating point components."
INTERNAL_TEXTURE_FORMAT.RGBA2.__doc__ = "Each texel contains 2-bit red, green, blue, and alpha components."
INTERNAL_TEXTURE_FORMAT.RGBA4.__doc__ = "Each texel contains 4-bit red, green, blue, and alpha components."
INTERNAL_TEXTURE_FORMAT.RGB5_A1.__doc__ = "Each texel contains 5-bit red, green, blue components and 1-bit alpha component."
INTERNAL_TEXTURE_FORMAT.RGBA8.__doc__ = "Each texel contains 8-bit red, green, blue, and alpha components."
INTERNAL_TEXTURE_FORMAT.RGB10_A2.__doc__ = "Each texel contains 10-bit red, green, blue components and 2-bit alpha component."
INTERNAL_TEXTURE_FORMAT.RGBA12.__doc__ = "Each texel contains 12-bit red, green, blue, and alpha components."
INTERNAL_TEXTURE_FORMAT.RGBA16.__doc__ = "Each texel contains 16-bit red, green, blue, and alpha components."
INTERNAL_TEXTURE_FORMAT.RGBA16_F.__doc__ = "Each texel contains 16-bit red, green, blue, and alpha floating point components."
INTERNAL_TEXTURE_FORMAT.RGBA32_F.__doc__ = "Each texel contains 32-bit red, green, blue, and alpha floating point components."
INTERNAL_TEXTURE_FORMAT.LUMINANCE4.__doc__ = "Each texel is an 4-bit luminance, e.g. intensity, component."
INTERNAL_TEXTURE_FORMAT.LUMINANCE8.__doc__ = "Each texel is an 8-bit luminance, e.g. intensity, component."
INTERNAL_TEXTURE_FORMAT.LUMINANCE12.__doc__ = "Each texel is an 12-bit luminance, e.g. intensity, component."
INTERNAL_TEXTURE_FORMAT.LUMINANCE16.__doc__ = "Each texel is an 16-bit luminance, e.g. intensity, component."
INTERNAL_TEXTURE_FORMAT.LUMINANCE16_F.__doc__ = "Each texel is an 16-bit luminance, e.g. intensity, floating point component."
INTERNAL_TEXTURE_FORMAT.LUMINANCE32_F.__doc__ = "Each texel is an 32-bit luminance, e.g. intensity, floating point component."
INTERNAL_TEXTURE_FORMAT.LUMINANCE4_ALPHA4.__doc__ = "Each texel contains an 4-bit luminance and 4-bit alpha component."
INTERNAL_TEXTURE_FORMAT.LUMINANCE6_ALPHA2.__doc__ = "Each texel contains an 6-bit luminance and 2-bit alpha component."
INTERNAL_TEXTURE_FORMAT.LUMINANCE8_ALPHA8.__doc__ = "Each texel contains an 8-bit luminance and 8-bit alpha component."
INTERNAL_TEXTURE_FORMAT.LUMINANCE12_ALPHA4.__doc__ = "Each texel contains an 12-bit luminance and 4-bit alpha component."
INTERNAL_TEXTURE_FORMAT.LUMINANCE12_ALPHA12.__doc__ = "Each texel contains an 12-bit luminance and 12-bit alpha component."
INTERNAL_TEXTURE_FORMAT.LUMINANCE16_ALPHA16.__doc__ = "Each texel contains an 16-bit luminance and 16-bit alpha component."
INTERNAL_TEXTURE_FORMAT.LUMINANCE16_ALPHA16_F.__doc__ = "Each texel contains an 16-bit luminance and 16-bit alpha floating point component."
INTERNAL_TEXTURE_FORMAT.LUMINANCE32_ALPHA32_F.__doc__ = "Each texel contains an 32-bit luminance and 32-bit alpha floating point component."

agcls.AgTypeNameMap["INTERNAL_TEXTURE_FORMAT"] = INTERNAL_TEXTURE_FORMAT

class MAGNIFICATION_FILTER(IntEnum):
    """The filter used when the pixel being textured maps to an area less than or equal to one texel."""
   
    NEAREST = 0
    """Use the texel that is closest to the center of the pixel being textured. This usually faster than Linear but can produce images with sharper edges."""
    LINEAR = 1
    """Use the weighted average of the four texels that are closest to the center of the pixel being textured."""

MAGNIFICATION_FILTER.NEAREST.__doc__ = "Use the texel that is closest to the center of the pixel being textured. This usually faster than Linear but can produce images with sharper edges."
MAGNIFICATION_FILTER.LINEAR.__doc__ = "Use the weighted average of the four texels that are closest to the center of the pixel being textured."

agcls.AgTypeNameMap["MAGNIFICATION_FILTER"] = MAGNIFICATION_FILTER

class MINIFICATION_FILTER(IntEnum):
    """The filter used when the pixel being textured maps to an area greater than one texel."""
   
    NEAREST = 0
    """Use the texel that is closest to the center of the pixel being textured."""
    LINEAR = 1
    """Use the weighted average of the four (for 2D textures, two for 1D textures) texels that are closest to the center of the pixel being textured."""
    NEAREST_MIP_MAP_NEAREST = 2
    """Use the mipmap that most closely matches the size of the pixel being textured. Then use the texel from that mipmap that is closest to the center of the pixel being textured."""
    LINEAR_MIP_MAP_NEAREST = 3
    """Use the mipmap that most closely matches the size of the pixel being textured. Then use the weighted average of the four (for 2D textures, two for 1D textures) texels from that mipmap that are closest to the center of the pixel being textured."""
    NEAREST_MIP_MAP_LINEAR = 4
    """Use the two mipmaps that most closely match the size of the pixel being textured. Determine the texel that is closest to the center of the pixel being textured in each mipmap. The final texture value is a weighted average of these two texels."""
    LINEAR_MIP_MAP_LINEAR = 5
    """Use the two mipmaps that most closely match the size of the pixel being textured. Determine the weighted average of the four (for 2D textures, two for 1D textures) texels that are closest to the center of the pixel being textured in each mipmap..."""

MINIFICATION_FILTER.NEAREST.__doc__ = "Use the texel that is closest to the center of the pixel being textured."
MINIFICATION_FILTER.LINEAR.__doc__ = "Use the weighted average of the four (for 2D textures, two for 1D textures) texels that are closest to the center of the pixel being textured."
MINIFICATION_FILTER.NEAREST_MIP_MAP_NEAREST.__doc__ = "Use the mipmap that most closely matches the size of the pixel being textured. Then use the texel from that mipmap that is closest to the center of the pixel being textured."
MINIFICATION_FILTER.LINEAR_MIP_MAP_NEAREST.__doc__ = "Use the mipmap that most closely matches the size of the pixel being textured. Then use the weighted average of the four (for 2D textures, two for 1D textures) texels from that mipmap that are closest to the center of the pixel being textured."
MINIFICATION_FILTER.NEAREST_MIP_MAP_LINEAR.__doc__ = "Use the two mipmaps that most closely match the size of the pixel being textured. Determine the texel that is closest to the center of the pixel being textured in each mipmap. The final texture value is a weighted average of these two texels."
MINIFICATION_FILTER.LINEAR_MIP_MAP_LINEAR.__doc__ = "Use the two mipmaps that most closely match the size of the pixel being textured. Determine the weighted average of the four (for 2D textures, two for 1D textures) texels that are closest to the center of the pixel being textured in each mipmap..."

agcls.AgTypeNameMap["MINIFICATION_FILTER"] = MINIFICATION_FILTER

class RENDERER_SHADE_MODEL(IntEnum):
    """Identifies which shade model to use. The primitive can be drawn with a single color or multiple colors."""
   
    FLAT = 0
    """Flat shading renders the primitive with one color across all of the vertices."""
    GOURAUD = 1
    """Gouraud shading renders the primitive by interpolating the color between the vertices."""

RENDERER_SHADE_MODEL.FLAT.__doc__ = "Flat shading renders the primitive with one color across all of the vertices."
RENDERER_SHADE_MODEL.GOURAUD.__doc__ = "Gouraud shading renders the primitive by interpolating the color between the vertices."

agcls.AgTypeNameMap["RENDERER_SHADE_MODEL"] = RENDERER_SHADE_MODEL

class TEXTURE_WRAP(IntEnum):
    """Determine how to handle textures coordinates that fall outside of the range [0, 1]."""
   
    CLAMP = 0
    """Clamp the texture coordinate to the range [0, 1]."""
    CLAMP_TO_BORDER = 1
    """Clamp the texture coordinate to the range [-1/2N, 1 + 1/2N], where N is the size the texture in the direction of clamping."""
    CLAMP_TO_EDGE = 2
    """Clamp the texture coordinate to the range [1/2N, 1 - 1/2N], where N is the size the texture in the direction of clamping."""
    MIRRORED_REPEAT = 3
    """If the integer part of the texture coordinate is even, use the fractional part of the texture coordinate. Otherwise, use one minus the fractional part of the texture coordinate."""
    REPEAT = 4
    """Ignore the integer part of the texture coordinate."""

TEXTURE_WRAP.CLAMP.__doc__ = "Clamp the texture coordinate to the range [0, 1]."
TEXTURE_WRAP.CLAMP_TO_BORDER.__doc__ = "Clamp the texture coordinate to the range [-1/2N, 1 + 1/2N], where N is the size the texture in the direction of clamping."
TEXTURE_WRAP.CLAMP_TO_EDGE.__doc__ = "Clamp the texture coordinate to the range [1/2N, 1 - 1/2N], where N is the size the texture in the direction of clamping."
TEXTURE_WRAP.MIRRORED_REPEAT.__doc__ = "If the integer part of the texture coordinate is even, use the fractional part of the texture coordinate. Otherwise, use one minus the fractional part of the texture coordinate."
TEXTURE_WRAP.REPEAT.__doc__ = "Ignore the integer part of the texture coordinate."

agcls.AgTypeNameMap["TEXTURE_WRAP"] = TEXTURE_WRAP

class SET_HINT(IntEnum):
    """An optimization hint optionally provided to primitives to enhance performance for static or dynamic primitives. See the Set Hint Performance Overview for selecting an appropriate value."""
   
    INFREQUENT = 0
    """Rendering is optimized for static geometry. The primitive's vertices are not going to be updated with Set() or SetPartial() calls. Calls to SetPartial() will fail. Calls to Set() are allowed but may not be as efficient as SetHintFrequent."""
    PARTIAL = 1
    """Rendering is optimized for dynamic geometry. The primitive's vertices are expected to be updated with SetPartial() - some or all of the vertices will change but the number of vertices will not."""
    FREQUENT = 2
    """Rendering is optimized for streaming geometry. The primitive's vertices are expected to be updated with Set() - all the vertices will change and/or the number of vertices will change. Calls to SetPartial() will fail."""

SET_HINT.INFREQUENT.__doc__ = "Rendering is optimized for static geometry. The primitive's vertices are not going to be updated with Set() or SetPartial() calls. Calls to SetPartial() will fail. Calls to Set() are allowed but may not be as efficient as SetHintFrequent."
SET_HINT.PARTIAL.__doc__ = "Rendering is optimized for dynamic geometry. The primitive's vertices are expected to be updated with SetPartial() - some or all of the vertices will change but the number of vertices will not."
SET_HINT.FREQUENT.__doc__ = "Rendering is optimized for streaming geometry. The primitive's vertices are expected to be updated with Set() - all the vertices will change and/or the number of vertices will change. Calls to SetPartial() will fail."

agcls.AgTypeNameMap["SET_HINT"] = SET_HINT

class STEREO_PROJECTION_MODE(IntEnum):
    """The stereoscopic projection mode used for the left and right eye scenes."""
   
    PARALLEL = 0
    """Parallel projection. Parallel projection will ignore any projection distance that has been set and instead use a parallel projection for each eye. In parallel mode all objects will appear to go into the screen..."""
    FIXED_DISTANCE = 1
    """Fixed distance projection. Objects at the fixed distance will appear to have no depth. Objects further than the distance will appear to go into the screen. Objects nearer than the distance will appear to pop out of the screen."""
    AUTOMATIC = 2
    """Automatic distance projection. Automatic distance projection will ignore any projection distance that has been set and instead automatically calculates the projection distance based on the distance between the camera and the center of the scene."""

STEREO_PROJECTION_MODE.PARALLEL.__doc__ = "Parallel projection. Parallel projection will ignore any projection distance that has been set and instead use a parallel projection for each eye. In parallel mode all objects will appear to go into the screen..."
STEREO_PROJECTION_MODE.FIXED_DISTANCE.__doc__ = "Fixed distance projection. Objects at the fixed distance will appear to have no depth. Objects further than the distance will appear to go into the screen. Objects nearer than the distance will appear to pop out of the screen."
STEREO_PROJECTION_MODE.AUTOMATIC.__doc__ = "Automatic distance projection. Automatic distance projection will ignore any projection distance that has been set and instead automatically calculates the projection distance based on the distance between the camera and the center of the scene."

agcls.AgTypeNameMap["STEREO_PROJECTION_MODE"] = STEREO_PROJECTION_MODE

class STEREOSCOPIC_DISPLAY_MODE(IntEnum):
    """The stereoscopic display mode. To use a particular stereoscopic display mode, ensure that your system supports the feature and that it is enabled."""
   
    OFF = 0
    """No stereoscopic."""
    QUAD_BUFFER = 1
    """OpenGL Quad-buffer stereoscopic."""
    ANAGLYPH = 2
    """Anaglyph or two-color stereoscopic."""
    LEFT_EYE = 3
    """Left eye view of the stereoscopic scene."""
    RIGHT_EYE = 4
    """Right eye view of the stereoscopic scene."""
    SIDE_BY_SIDE = 5
    """Side-by-side stereoscopic. Left and right eye views are rendered next to each other in the same window."""

STEREOSCOPIC_DISPLAY_MODE.OFF.__doc__ = "No stereoscopic."
STEREOSCOPIC_DISPLAY_MODE.QUAD_BUFFER.__doc__ = "OpenGL Quad-buffer stereoscopic."
STEREOSCOPIC_DISPLAY_MODE.ANAGLYPH.__doc__ = "Anaglyph or two-color stereoscopic."
STEREOSCOPIC_DISPLAY_MODE.LEFT_EYE.__doc__ = "Left eye view of the stereoscopic scene."
STEREOSCOPIC_DISPLAY_MODE.RIGHT_EYE.__doc__ = "Right eye view of the stereoscopic scene."
STEREOSCOPIC_DISPLAY_MODE.SIDE_BY_SIDE.__doc__ = "Side-by-side stereoscopic. Left and right eye views are rendered next to each other in the same window."

agcls.AgTypeNameMap["STEREOSCOPIC_DISPLAY_MODE"] = STEREOSCOPIC_DISPLAY_MODE

class FONT_STYLE(IntEnum):
    """Font styles."""
   
    REGULAR = 0x0
    """Regular font."""
    BOLD = 0x1
    """Bold font."""
    ITALIC = 0x2
    """Italic font."""
    UNDERLINE = 0x4
    """Underlined font."""
    STRIKEOUT = 0x8
    """Strike-out style."""

FONT_STYLE.REGULAR.__doc__ = "Regular font."
FONT_STYLE.BOLD.__doc__ = "Bold font."
FONT_STYLE.ITALIC.__doc__ = "Italic font."
FONT_STYLE.UNDERLINE.__doc__ = "Underlined font."
FONT_STYLE.STRIKEOUT.__doc__ = "Strike-out style."

agcls.AgTypeNameMap["FONT_STYLE"] = FONT_STYLE


class IPathPoint(object):
    """A path point used with the Path Primitive."""

    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_position_method_offset = 1
    _set_position_method_offset = 2
    _get_date_method_offset = 3
    _get_color_method_offset = 4
    _set_color_method_offset = 5
    _get_translucency_method_offset = 6
    _set_translucency_method_offset = 7
    _get_outline_color_method_offset = 8
    _set_outline_color_method_offset = 9
    _get_outline_translucency_method_offset = 10
    _set_outline_translucency_method_offset = 11
    _get_is_translucent_method_offset = 12
    _metadata = {
        "iid_data" : (4847933377036680354, 16398371258109956499),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IPathPoint."""
        initialize_from_source_object(self, sourceObject, IPathPoint)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IPathPoint)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IPathPoint, None)
    
    _get_position_metadata = { "offset" : _get_position_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def position(self) -> list:
        """A path point position as a one-dimensional array of three elements corresponding to (X,Y,Z) cartesian coordinates."""
        return self._intf.get_property(IPathPoint._metadata, IPathPoint._get_position_metadata)

    _set_position_metadata = { "offset" : _set_position_method_offset,
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @position.setter
    def position(self, position:list) -> None:
        return self._intf.set_property(IPathPoint._metadata, IPathPoint._set_position_metadata, position)

    _get_date_metadata = { "offset" : _get_date_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def date(self) -> "IDate":
        """A date/time of the path point."""
        return self._intf.get_property(IPathPoint._metadata, IPathPoint._get_date_metadata)

    _get_color_metadata = { "offset" : _get_color_method_offset,
            "arg_types" : (POINTER(agcom.OLE_COLOR),),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @property
    def color(self) -> agcolor.Color:
        """The path point color."""
        return self._intf.get_property(IPathPoint._metadata, IPathPoint._get_color_metadata)

    _set_color_metadata = { "offset" : _set_color_method_offset,
            "arg_types" : (agcom.OLE_COLOR,),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @color.setter
    def color(self, color:agcolor.Color) -> None:
        return self._intf.set_property(IPathPoint._metadata, IPathPoint._set_color_metadata, color)

    _get_translucency_metadata = { "offset" : _get_translucency_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def translucency(self) -> float:
        """The path point translucency."""
        return self._intf.get_property(IPathPoint._metadata, IPathPoint._get_translucency_metadata)

    _set_translucency_metadata = { "offset" : _set_translucency_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @translucency.setter
    def translucency(self, translucency:float) -> None:
        return self._intf.set_property(IPathPoint._metadata, IPathPoint._set_translucency_metadata, translucency)

    _get_outline_color_metadata = { "offset" : _get_outline_color_method_offset,
            "arg_types" : (POINTER(agcom.OLE_COLOR),),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @property
    def outline_color(self) -> agcolor.Color:
        """The path point outline color."""
        return self._intf.get_property(IPathPoint._metadata, IPathPoint._get_outline_color_metadata)

    _set_outline_color_metadata = { "offset" : _set_outline_color_method_offset,
            "arg_types" : (agcom.OLE_COLOR,),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @outline_color.setter
    def outline_color(self, outlineColor:agcolor.Color) -> None:
        return self._intf.set_property(IPathPoint._metadata, IPathPoint._set_outline_color_metadata, outlineColor)

    _get_outline_translucency_metadata = { "offset" : _get_outline_translucency_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def outline_translucency(self) -> float:
        """The path point outline translucency."""
        return self._intf.get_property(IPathPoint._metadata, IPathPoint._get_outline_translucency_metadata)

    _set_outline_translucency_metadata = { "offset" : _set_outline_translucency_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @outline_translucency.setter
    def outline_translucency(self, outlineTranslucency:float) -> None:
        return self._intf.set_property(IPathPoint._metadata, IPathPoint._set_outline_translucency_metadata, outlineTranslucency)

    _get_is_translucent_metadata = { "offset" : _get_is_translucent_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_translucent(self) -> bool:
        """Whether the path point is translucent."""
        return self._intf.get_property(IPathPoint._metadata, IPathPoint._get_is_translucent_metadata)

    _property_names[position] = "position"
    _property_names[date] = "date"
    _property_names[color] = "color"
    _property_names[translucency] = "translucency"
    _property_names[outline_color] = "outline_color"
    _property_names[outline_translucency] = "outline_translucency"
    _property_names[is_translucent] = "is_translucent"


agcls.AgClassCatalog.add_catalog_entry((4847933377036680354, 16398371258109956499), IPathPoint)
agcls.AgTypeNameMap["IPathPoint"] = IPathPoint

class IPathPointFactory(object):
    """Create Path Primitive's path points."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_with_date_method_offset = 2
    _initialize_with_date_and_position_method_offset = 3
    _initialize_with_date_position_and_color_method_offset = 4
    _initialize_with_date_position_color_and_translucency_method_offset = 5
    _metadata = {
        "iid_data" : (5266970694628181700, 7367838054053532080),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IPathPointFactory."""
        initialize_from_source_object(self, sourceObject, IPathPointFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IPathPointFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IPathPointFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "PathPoint":
        """Initialize a new path point."""
        return self._intf.invoke(IPathPointFactory._metadata, IPathPointFactory._initialize_metadata, OutArg())

    _initialize_with_date_metadata = { "offset" : _initialize_with_date_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("IDate"), agmarshall.InterfaceOutArg,) }
    def initialize_with_date(self, pathPointDate:"IDate") -> "PathPoint":
        """Initialize a new path point with the given date."""
        return self._intf.invoke(IPathPointFactory._metadata, IPathPointFactory._initialize_with_date_metadata, pathPointDate, OutArg())

    _initialize_with_date_and_position_metadata = { "offset" : _initialize_with_date_and_position_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("IDate"), agmarshall.LPSafearrayArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_date_and_position(self, pathPointDate:"IDate", position:list) -> "PathPoint":
        """Initialize a new path point with the given date and position."""
        return self._intf.invoke(IPathPointFactory._metadata, IPathPointFactory._initialize_with_date_and_position_metadata, pathPointDate, position, OutArg())

    _initialize_with_date_position_and_color_metadata = { "offset" : _initialize_with_date_position_and_color_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.LPSAFEARRAY), agcom.OLE_COLOR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("IDate"), agmarshall.LPSafearrayArg, agmarshall.OLEColorArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_date_position_and_color(self, pathPointDate:"IDate", position:list, color:agcolor.Color) -> "PathPoint":
        """Initialize a new path point with the given date, position and color."""
        return self._intf.invoke(IPathPointFactory._metadata, IPathPointFactory._initialize_with_date_position_and_color_metadata, pathPointDate, position, color, OutArg())

    _initialize_with_date_position_color_and_translucency_metadata = { "offset" : _initialize_with_date_position_color_and_translucency_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.LPSAFEARRAY), agcom.OLE_COLOR, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("IDate"), agmarshall.LPSafearrayArg, agmarshall.OLEColorArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_date_position_color_and_translucency(self, pathPointDate:"IDate", position:list, color:agcolor.Color, translucency:float) -> "PathPoint":
        """Initialize a new path point with the given date, position, color and translucency."""
        return self._intf.invoke(IPathPointFactory._metadata, IPathPointFactory._initialize_with_date_position_color_and_translucency_metadata, pathPointDate, position, color, translucency, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5266970694628181700, 7367838054053532080), IPathPointFactory)
agcls.AgTypeNameMap["IPathPointFactory"] = IPathPointFactory

class IBoundingSphere(object):
    """A sphere that encapsulates an object."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_center_method_offset = 1
    _get_radius_method_offset = 2
    _metadata = {
        "iid_data" : (4943385150456231790, 7841321641557182081),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IBoundingSphere."""
        initialize_from_source_object(self, sourceObject, IBoundingSphere)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IBoundingSphere)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IBoundingSphere, None)
    
    _get_center_metadata = { "offset" : _get_center_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def center(self) -> list:
        """A center of the bounding sphere. The center point is specified as one-dimensional array with three elements corresponding to (X,Y,Z) cartesian coordinates."""
        return self._intf.get_property(IBoundingSphere._metadata, IBoundingSphere._get_center_metadata)

    _get_radius_metadata = { "offset" : _get_radius_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def radius(self) -> float:
        """A radius of the bounding sphere."""
        return self._intf.get_property(IBoundingSphere._metadata, IBoundingSphere._get_radius_metadata)

    _property_names[center] = "center"
    _property_names[radius] = "radius"


agcls.AgClassCatalog.add_catalog_entry((4943385150456231790, 7841321641557182081), IBoundingSphere)
agcls.AgTypeNameMap["IBoundingSphere"] = IBoundingSphere

class IBoundingSphereFactory(object):
    """Create instances of the bounding sphere type."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _get_maximum_radius_bounding_sphere_method_offset = 2
    _metadata = {
        "iid_data" : (5476713812153226512, 18394739804475761564),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IBoundingSphereFactory."""
        initialize_from_source_object(self, sourceObject, IBoundingSphereFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IBoundingSphereFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IBoundingSphereFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def initialize(self, center:list, radius:float) -> "BoundingSphere":
        """Create instances of BoundingSphere."""
        return self._intf.invoke(IBoundingSphereFactory._metadata, IBoundingSphereFactory._initialize_metadata, center, radius, OutArg())

    _get_maximum_radius_bounding_sphere_metadata = { "offset" : _get_maximum_radius_bounding_sphere_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def maximum_radius_bounding_sphere(self) -> "BoundingSphere":
        """Get the bounding sphere of maximum possible radius."""
        return self._intf.get_property(IBoundingSphereFactory._metadata, IBoundingSphereFactory._get_maximum_radius_bounding_sphere_metadata)

    _property_names[maximum_radius_bounding_sphere] = "maximum_radius_bounding_sphere"


agcls.AgClassCatalog.add_catalog_entry((5476713812153226512, 18394739804475761564), IBoundingSphereFactory)
agcls.AgTypeNameMap["IBoundingSphereFactory"] = IBoundingSphereFactory

class ITextureFilter2D(object):
    """A texture filter."""

    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_minification_filter_method_offset = 1
    _get_magnification_filter_method_offset = 2
    _get_wrap_s_method_offset = 3
    _get_wrap_t_method_offset = 4
    _get_nearest_clamp_to_edge_method_offset = 5
    _get_nearest_repeat_method_offset = 6
    _get_linear_clamp_to_edge_method_offset = 7
    _get_linear_repeat_method_offset = 8
    _metadata = {
        "iid_data" : (5541023743832152076, 10611954755374831295),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ITextureFilter2D."""
        initialize_from_source_object(self, sourceObject, ITextureFilter2D)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITextureFilter2D)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ITextureFilter2D, None)
    
    _get_minification_filter_metadata = { "offset" : _get_minification_filter_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(MINIFICATION_FILTER),) }
    @property
    def minification_filter(self) -> "MINIFICATION_FILTER":
        """Get the minification filter used when the pixel being textured maps to an area less than or equal to one texel."""
        return self._intf.get_property(ITextureFilter2D._metadata, ITextureFilter2D._get_minification_filter_metadata)

    _get_magnification_filter_metadata = { "offset" : _get_magnification_filter_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(MAGNIFICATION_FILTER),) }
    @property
    def magnification_filter(self) -> "MAGNIFICATION_FILTER":
        """Get the magnification filter used when the pixel being textured maps to an area greater than one texel."""
        return self._intf.get_property(ITextureFilter2D._metadata, ITextureFilter2D._get_magnification_filter_metadata)

    _get_wrap_s_metadata = { "offset" : _get_wrap_s_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(TEXTURE_WRAP),) }
    @property
    def wrap_s(self) -> "TEXTURE_WRAP":
        """Get the texture wrap for the s direction."""
        return self._intf.get_property(ITextureFilter2D._metadata, ITextureFilter2D._get_wrap_s_metadata)

    _get_wrap_t_metadata = { "offset" : _get_wrap_t_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(TEXTURE_WRAP),) }
    @property
    def wrap_t(self) -> "TEXTURE_WRAP":
        """Get the texture wrap for the t direction."""
        return self._intf.get_property(ITextureFilter2D._metadata, ITextureFilter2D._get_wrap_t_metadata)

    _get_nearest_clamp_to_edge_metadata = { "offset" : _get_nearest_clamp_to_edge_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def nearest_clamp_to_edge(self) -> "TextureFilter2D":
        """Get a texture filter with the following properties: MinificationFilter: Nearest, MagnificationFilter: Nearest, WrapS: ClampToEdge, WrapT: ClampToEdge."""
        return self._intf.get_property(ITextureFilter2D._metadata, ITextureFilter2D._get_nearest_clamp_to_edge_metadata)

    _get_nearest_repeat_metadata = { "offset" : _get_nearest_repeat_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def nearest_repeat(self) -> "TextureFilter2D":
        """Get a texture filter with the following properties: MinificationFilter: Nearest, MagnificationFilter: Nearest, WrapS: Repeat, WrapT: Repeat."""
        return self._intf.get_property(ITextureFilter2D._metadata, ITextureFilter2D._get_nearest_repeat_metadata)

    _get_linear_clamp_to_edge_metadata = { "offset" : _get_linear_clamp_to_edge_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def linear_clamp_to_edge(self) -> "TextureFilter2D":
        """Get a texture filter with the following properties: MinificationFilter: Linear, MagnificationFilter: Linear, WrapS: ClampToEdge, WrapT: ClampToEdge."""
        return self._intf.get_property(ITextureFilter2D._metadata, ITextureFilter2D._get_linear_clamp_to_edge_metadata)

    _get_linear_repeat_metadata = { "offset" : _get_linear_repeat_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def linear_repeat(self) -> "TextureFilter2D":
        """Get a texture filter with the following properties: MinificationFilter: Linear, MagnificationFilter: Linear, WrapS: Repeat, WrapT: Repeat."""
        return self._intf.get_property(ITextureFilter2D._metadata, ITextureFilter2D._get_linear_repeat_metadata)

    _property_names[minification_filter] = "minification_filter"
    _property_names[magnification_filter] = "magnification_filter"
    _property_names[wrap_s] = "wrap_s"
    _property_names[wrap_t] = "wrap_t"
    _property_names[nearest_clamp_to_edge] = "nearest_clamp_to_edge"
    _property_names[nearest_repeat] = "nearest_repeat"
    _property_names[linear_clamp_to_edge] = "linear_clamp_to_edge"
    _property_names[linear_repeat] = "linear_repeat"


agcls.AgClassCatalog.add_catalog_entry((5541023743832152076, 10611954755374831295), ITextureFilter2D)
agcls.AgTypeNameMap["ITextureFilter2D"] = ITextureFilter2D

class ITextureFilter2DFactory(object):
    """Create texture filters."""

    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_nearest_clamp_to_edge_method_offset = 1
    _get_nearest_repeat_method_offset = 2
    _get_linear_clamp_to_edge_method_offset = 3
    _get_linear_repeat_method_offset = 4
    _initialize_method_offset = 5
    _initialize_with_texture_wrap_method_offset = 6
    _initialize_with_minification_and_magnification_method_offset = 7
    _metadata = {
        "iid_data" : (5619732544747564303, 16515141689419169207),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ITextureFilter2DFactory."""
        initialize_from_source_object(self, sourceObject, ITextureFilter2DFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITextureFilter2DFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ITextureFilter2DFactory, None)
    
    _get_nearest_clamp_to_edge_metadata = { "offset" : _get_nearest_clamp_to_edge_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def nearest_clamp_to_edge(self) -> "TextureFilter2D":
        """Get a texture filter with the following properties: MinificationFilter: Nearest, MagnificationFilter: Nearest, WrapS: ClampToEdge, WrapT: ClampToEdge."""
        return self._intf.get_property(ITextureFilter2DFactory._metadata, ITextureFilter2DFactory._get_nearest_clamp_to_edge_metadata)

    _get_nearest_repeat_metadata = { "offset" : _get_nearest_repeat_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def nearest_repeat(self) -> "TextureFilter2D":
        """Get a texture filter with the following properties: MinificationFilter: Nearest, MagnificationFilter: Nearest, WrapS: Repeat, WrapT: Repeat."""
        return self._intf.get_property(ITextureFilter2DFactory._metadata, ITextureFilter2DFactory._get_nearest_repeat_metadata)

    _get_linear_clamp_to_edge_metadata = { "offset" : _get_linear_clamp_to_edge_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def linear_clamp_to_edge(self) -> "TextureFilter2D":
        """Get a texture filter with the following properties: MinificationFilter: Linear, MagnificationFilter: Linear, WrapS: ClampToEdge, WrapT: ClampToEdge."""
        return self._intf.get_property(ITextureFilter2DFactory._metadata, ITextureFilter2DFactory._get_linear_clamp_to_edge_metadata)

    _get_linear_repeat_metadata = { "offset" : _get_linear_repeat_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def linear_repeat(self) -> "TextureFilter2D":
        """Get a texture filter with the following properties: MinificationFilter: Linear, MagnificationFilter: Linear, WrapS: Repeat, WrapT: Repeat."""
        return self._intf.get_property(ITextureFilter2DFactory._metadata, ITextureFilter2DFactory._get_linear_repeat_metadata)

    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (agcom.LONG, agcom.LONG, agcom.LONG, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.EnumArg(MINIFICATION_FILTER), agmarshall.EnumArg(MAGNIFICATION_FILTER), agmarshall.EnumArg(TEXTURE_WRAP), agmarshall.EnumArg(TEXTURE_WRAP), agmarshall.InterfaceOutArg,) }
    def initialize(self, minificationFilter:"MINIFICATION_FILTER", magnificationFilter:"MAGNIFICATION_FILTER", wrapS:"TEXTURE_WRAP", wrapT:"TEXTURE_WRAP") -> "TextureFilter2D":
        """Create a texture filter using the specified minification/magnification options and texture wrap."""
        return self._intf.invoke(ITextureFilter2DFactory._metadata, ITextureFilter2DFactory._initialize_metadata, minificationFilter, magnificationFilter, wrapS, wrapT, OutArg())

    _initialize_with_texture_wrap_metadata = { "offset" : _initialize_with_texture_wrap_method_offset,
            "arg_types" : (agcom.LONG, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.EnumArg(TEXTURE_WRAP), agmarshall.EnumArg(TEXTURE_WRAP), agmarshall.InterfaceOutArg,) }
    def initialize_with_texture_wrap(self, wrapS:"TEXTURE_WRAP", wrapT:"TEXTURE_WRAP") -> "TextureFilter2D":
        """Create a texture filter using the specified texture wrap."""
        return self._intf.invoke(ITextureFilter2DFactory._metadata, ITextureFilter2DFactory._initialize_with_texture_wrap_metadata, wrapS, wrapT, OutArg())

    _initialize_with_minification_and_magnification_metadata = { "offset" : _initialize_with_minification_and_magnification_method_offset,
            "arg_types" : (agcom.LONG, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.EnumArg(MINIFICATION_FILTER), agmarshall.EnumArg(MAGNIFICATION_FILTER), agmarshall.InterfaceOutArg,) }
    def initialize_with_minification_and_magnification(self, minificationFilter:"MINIFICATION_FILTER", magnificationFilter:"MAGNIFICATION_FILTER") -> "TextureFilter2D":
        """Create a texture filter using the specified minification/magnification options."""
        return self._intf.invoke(ITextureFilter2DFactory._metadata, ITextureFilter2DFactory._initialize_with_minification_and_magnification_metadata, minificationFilter, magnificationFilter, OutArg())

    _property_names[nearest_clamp_to_edge] = "nearest_clamp_to_edge"
    _property_names[nearest_repeat] = "nearest_repeat"
    _property_names[linear_clamp_to_edge] = "linear_clamp_to_edge"
    _property_names[linear_repeat] = "linear_repeat"


agcls.AgClassCatalog.add_catalog_entry((5619732544747564303, 16515141689419169207), ITextureFilter2DFactory)
agcls.AgTypeNameMap["ITextureFilter2DFactory"] = ITextureFilter2DFactory

class IRendererTexture2D(object):
    """A 2D Texture. A texture represents an image that is ready for use by objects such as primitives and overlays. Textures typically reside in video memory."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_template_method_offset = 1
    _metadata = {
        "iid_data" : (5417815738939846526, 12898891467340117641),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IRendererTexture2D."""
        initialize_from_source_object(self, sourceObject, IRendererTexture2D)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IRendererTexture2D)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IRendererTexture2D, None)
    
    _get_template_metadata = { "offset" : _get_template_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def template(self) -> "RendererTextureTemplate2D":
        """Get a template from which the texture was created."""
        return self._intf.get_property(IRendererTexture2D._metadata, IRendererTexture2D._get_template_metadata)

    _property_names[template] = "template"


agcls.AgClassCatalog.add_catalog_entry((5417815738939846526, 12898891467340117641), IRendererTexture2D)
agcls.AgTypeNameMap["IRendererTexture2D"] = IRendererTexture2D

class IRendererTextureTemplate2D(object):
    """Template object containing attributes required to create a 2D texture."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_internal_format_method_offset = 1
    _get_width_method_offset = 2
    _get_height_method_offset = 3
    _metadata = {
        "iid_data" : (5316263756575800396, 1184309665638889406),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IRendererTextureTemplate2D."""
        initialize_from_source_object(self, sourceObject, IRendererTextureTemplate2D)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IRendererTextureTemplate2D)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IRendererTextureTemplate2D, None)
    
    _get_internal_format_metadata = { "offset" : _get_internal_format_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(INTERNAL_TEXTURE_FORMAT),) }
    @property
    def internal_format(self) -> "INTERNAL_TEXTURE_FORMAT":
        """Get an internal format of the texture."""
        return self._intf.get_property(IRendererTextureTemplate2D._metadata, IRendererTextureTemplate2D._get_internal_format_metadata)

    _get_width_metadata = { "offset" : _get_width_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def width(self) -> int:
        """Get a width of the texture in texels."""
        return self._intf.get_property(IRendererTextureTemplate2D._metadata, IRendererTextureTemplate2D._get_width_metadata)

    _get_height_metadata = { "offset" : _get_height_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def height(self) -> int:
        """Get a height of the texture in texels."""
        return self._intf.get_property(IRendererTextureTemplate2D._metadata, IRendererTextureTemplate2D._get_height_metadata)

    _property_names[internal_format] = "internal_format"
    _property_names[width] = "width"
    _property_names[height] = "height"


agcls.AgClassCatalog.add_catalog_entry((5316263756575800396, 1184309665638889406), IRendererTextureTemplate2D)
agcls.AgTypeNameMap["IRendererTextureTemplate2D"] = IRendererTextureTemplate2D

class IPathPointCollection(object):
    """A collection of path points."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_count_method_offset = 1
    _item_method_offset = 2
    _get__NewEnum_method_offset = 3
    _metadata = {
        "iid_data" : (5688438264765407641, 15401492857366987175),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IPathPointCollection."""
        initialize_from_source_object(self, sourceObject, IPathPointCollection)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IPathPointCollection)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IPathPointCollection, None)
    def __iter__(self):
        """Create an iterator for the IPathPointCollection object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IPathPoint":
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LongArg,) }
    @property
    def count(self) -> int:
        """A total number of elements in the collection."""
        return self._intf.get_property(IPathPointCollection._metadata, IPathPointCollection._get_count_metadata)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LongArg, agmarshall.InterfaceOutArg,) }
    def item(self, index:int) -> "PathPoint":
        """Return a path point at the specified position in the collection."""
        return self._intf.invoke(IPathPointCollection._metadata, IPathPointCollection._item_metadata, index, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        return self._intf.get_property(IPathPointCollection._metadata, IPathPointCollection._get__NewEnum_metadata)

    __getitem__ = item


    _property_names[count] = "count"
    _property_names[_NewEnum] = "_NewEnum"


agcls.AgClassCatalog.add_catalog_entry((5688438264765407641, 15401492857366987175), IPathPointCollection)
agcls.AgTypeNameMap["IPathPointCollection"] = IPathPointCollection

class IObjectCollection(object):
    """A collection of objects."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_count_method_offset = 1
    _item_method_offset = 2
    _get__NewEnum_method_offset = 3
    _metadata = {
        "iid_data" : (4775746742546311368, 7552453374623214760),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IObjectCollection."""
        initialize_from_source_object(self, sourceObject, IObjectCollection)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IObjectCollection)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IObjectCollection, None)
    def __iter__(self):
        """Create an iterator for the IObjectCollection object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> typing.Any:
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LongArg,) }
    @property
    def count(self) -> int:
        """A total number of elements in the collection."""
        return self._intf.get_property(IObjectCollection._metadata, IObjectCollection._get_count_metadata)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.Variant),),
            "marshallers" : (agmarshall.LongArg, agmarshall.VariantArg,) }
    def item(self, index:int) -> typing.Any:
        """Return an item in the collection at the specified index."""
        return self._intf.invoke(IObjectCollection._metadata, IObjectCollection._item_metadata, index, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        return self._intf.get_property(IObjectCollection._metadata, IObjectCollection._get__NewEnum_metadata)

    __getitem__ = item


    _property_names[count] = "count"
    _property_names[_NewEnum] = "_NewEnum"


agcls.AgClassCatalog.add_catalog_entry((4775746742546311368, 7552453374623214760), IObjectCollection)
agcls.AgTypeNameMap["IObjectCollection"] = IObjectCollection

class ISceneCollection(object):
    """A collection of scenes."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_count_method_offset = 1
    _item_method_offset = 2
    _get__NewEnum_method_offset = 3
    _metadata = {
        "iid_data" : (5372104015339339678, 805902352111732909),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ISceneCollection."""
        initialize_from_source_object(self, sourceObject, ISceneCollection)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISceneCollection)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ISceneCollection, None)
    def __iter__(self):
        """Create an iterator for the ISceneCollection object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IScene":
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LongArg,) }
    @property
    def count(self) -> int:
        """Total number of scenes in the collection."""
        return self._intf.get_property(ISceneCollection._metadata, ISceneCollection._get_count_metadata)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LongArg, agmarshall.InterfaceOutArg,) }
    def item(self, index:int) -> "Scene":
        """Return a scene in the collection at a specified index."""
        return self._intf.invoke(ISceneCollection._metadata, ISceneCollection._item_metadata, index, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        return self._intf.get_property(ISceneCollection._metadata, ISceneCollection._get__NewEnum_metadata)

    __getitem__ = item


    _property_names[count] = "count"
    _property_names[_NewEnum] = "_NewEnum"


agcls.AgClassCatalog.add_catalog_entry((5372104015339339678, 805902352111732909), ISceneCollection)
agcls.AgTypeNameMap["ISceneCollection"] = ISceneCollection

class IScreenOverlayContainer(object):
    """The interface for screen overlays that contain a collection of other overlays. This interface is implemented by ScreenOverlayManager and ScreenOverlay."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_overlays_method_offset = 1
    _get_padding_method_offset = 2
    _set_padding_method_offset = 3
    _get_display_method_offset = 4
    _set_display_method_offset = 5
    _metadata = {
        "iid_data" : (5104812672920574391, 4741981752173751691),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IScreenOverlayContainer."""
        initialize_from_source_object(self, sourceObject, IScreenOverlayContainer)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IScreenOverlayContainer)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IScreenOverlayContainer, None)
    
    _get_overlays_metadata = { "offset" : _get_overlays_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def overlays(self) -> "ScreenOverlayCollection":
        """Get the collection of overlays that are contained within this overlay."""
        return self._intf.get_property(IScreenOverlayContainer._metadata, IScreenOverlayContainer._get_overlays_metadata)

    _get_padding_metadata = { "offset" : _get_padding_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def padding(self) -> list:
        """Get or set the padding surrounding the overlays that are contained within this overlay. The array contains the components of the padding arranged in the order left, top, right, bottom."""
        return self._intf.get_property(IScreenOverlayContainer._metadata, IScreenOverlayContainer._get_padding_metadata)

    _set_padding_metadata = { "offset" : _set_padding_method_offset,
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @padding.setter
    def padding(self, padding:list) -> None:
        return self._intf.set_property(IScreenOverlayContainer._metadata, IScreenOverlayContainer._set_padding_metadata, padding)

    _get_display_metadata = { "offset" : _get_display_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def display(self) -> bool:
        """Get or set if this overlay and the collection of overlays that are contained within this overlay should be rendered."""
        return self._intf.get_property(IScreenOverlayContainer._metadata, IScreenOverlayContainer._get_display_metadata)

    _set_display_metadata = { "offset" : _set_display_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @display.setter
    def display(self, display:bool) -> None:
        return self._intf.set_property(IScreenOverlayContainer._metadata, IScreenOverlayContainer._set_display_metadata, display)

    _property_names[overlays] = "overlays"
    _property_names[padding] = "padding"
    _property_names[display] = "display"


agcls.AgClassCatalog.add_catalog_entry((5104812672920574391, 4741981752173751691), IScreenOverlayContainer)
agcls.AgTypeNameMap["IScreenOverlayContainer"] = IScreenOverlayContainer

class IScreenOverlayPickResultCollection(object):
    """A collection of pick results."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_count_method_offset = 1
    _item_method_offset = 2
    _get__NewEnum_method_offset = 3
    _metadata = {
        "iid_data" : (5200561598852205868, 13511979759557490105),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IScreenOverlayPickResultCollection."""
        initialize_from_source_object(self, sourceObject, IScreenOverlayPickResultCollection)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IScreenOverlayPickResultCollection)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IScreenOverlayPickResultCollection, None)
    def __iter__(self):
        """Create an iterator for the IScreenOverlayPickResultCollection object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IScreenOverlayPickResult":
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LongArg,) }
    @property
    def count(self) -> int:
        """A total number of elements in the collection."""
        return self._intf.get_property(IScreenOverlayPickResultCollection._metadata, IScreenOverlayPickResultCollection._get_count_metadata)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LongArg, agmarshall.InterfaceOutArg,) }
    def item(self, index:int) -> "ScreenOverlayPickResult":
        """Get an element at the specified position in the collection."""
        return self._intf.invoke(IScreenOverlayPickResultCollection._metadata, IScreenOverlayPickResultCollection._item_metadata, index, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        return self._intf.get_property(IScreenOverlayPickResultCollection._metadata, IScreenOverlayPickResultCollection._get__NewEnum_metadata)

    __getitem__ = item


    _property_names[count] = "count"
    _property_names[_NewEnum] = "_NewEnum"


agcls.AgClassCatalog.add_catalog_entry((5200561598852205868, 13511979759557490105), IScreenOverlayPickResultCollection)
agcls.AgTypeNameMap["IScreenOverlayPickResultCollection"] = IScreenOverlayPickResultCollection

class IGlobeImageOverlayAddCompleteEventArgs(object):
    """The event is raised when the globe image overlay is displayed for the first time after being added using AddAsync."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_overlay_method_offset = 1
    _metadata = {
        "iid_data" : (4932803116935452617, 13441102795444558522),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IGlobeImageOverlayAddCompleteEventArgs."""
        initialize_from_source_object(self, sourceObject, IGlobeImageOverlayAddCompleteEventArgs)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IGlobeImageOverlayAddCompleteEventArgs)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IGlobeImageOverlayAddCompleteEventArgs, None)
    
    _get_overlay_metadata = { "offset" : _get_overlay_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def overlay(self) -> "IGlobeImageOverlay":
        """The overlay object that was added earlier using AddAsync."""
        return self._intf.get_property(IGlobeImageOverlayAddCompleteEventArgs._metadata, IGlobeImageOverlayAddCompleteEventArgs._get_overlay_metadata)

    _property_names[overlay] = "overlay"


agcls.AgClassCatalog.add_catalog_entry((4932803116935452617, 13441102795444558522), IGlobeImageOverlayAddCompleteEventArgs)
agcls.AgTypeNameMap["IGlobeImageOverlayAddCompleteEventArgs"] = IGlobeImageOverlayAddCompleteEventArgs

class ITerrainOverlayAddCompleteEventArgs(object):
    """The event is raised when the terrain overlay is displayed for the first time after having been added using AddAsync."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_overlay_method_offset = 1
    _metadata = {
        "iid_data" : (4791585591808952706, 1636302179759337885),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ITerrainOverlayAddCompleteEventArgs."""
        initialize_from_source_object(self, sourceObject, ITerrainOverlayAddCompleteEventArgs)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITerrainOverlayAddCompleteEventArgs)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ITerrainOverlayAddCompleteEventArgs, None)
    
    _get_overlay_metadata = { "offset" : _get_overlay_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def overlay(self) -> "ITerrainOverlay":
        """The terrain overlay being displayed for the first time."""
        return self._intf.get_property(ITerrainOverlayAddCompleteEventArgs._metadata, ITerrainOverlayAddCompleteEventArgs._get_overlay_metadata)

    _property_names[overlay] = "overlay"


agcls.AgClassCatalog.add_catalog_entry((4791585591808952706, 1636302179759337885), ITerrainOverlayAddCompleteEventArgs)
agcls.AgTypeNameMap["ITerrainOverlayAddCompleteEventArgs"] = ITerrainOverlayAddCompleteEventArgs

class IPickResultCollection(object):
    """A collection of picked objects."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_count_method_offset = 1
    _item_method_offset = 2
    _get__NewEnum_method_offset = 3
    _metadata = {
        "iid_data" : (5309094562372375985, 3068566077694695567),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IPickResultCollection."""
        initialize_from_source_object(self, sourceObject, IPickResultCollection)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IPickResultCollection)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IPickResultCollection, None)
    def __iter__(self):
        """Create an iterator for the IPickResultCollection object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IPickResult":
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LongArg,) }
    @property
    def count(self) -> int:
        """A total number of elements in the collection."""
        return self._intf.get_property(IPickResultCollection._metadata, IPickResultCollection._get_count_metadata)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LongArg, agmarshall.InterfaceOutArg,) }
    def item(self, index:int) -> "PickResult":
        """Return a picked object at the specified position in the collection."""
        return self._intf.invoke(IPickResultCollection._metadata, IPickResultCollection._item_metadata, index, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        return self._intf.get_property(IPickResultCollection._metadata, IPickResultCollection._get__NewEnum_metadata)

    __getitem__ = item


    _property_names[count] = "count"
    _property_names[_NewEnum] = "_NewEnum"


agcls.AgClassCatalog.add_catalog_entry((5309094562372375985, 3068566077694695567), IPickResultCollection)
agcls.AgTypeNameMap["IPickResultCollection"] = IPickResultCollection

class IRenderingEventArgs(object):
    """The event is raised when the scene is rendered."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_time_method_offset = 1
    _get_time_in_ep_secs_method_offset = 2
    _metadata = {
        "iid_data" : (4863600425244224034, 13619959685560500882),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IRenderingEventArgs."""
        initialize_from_source_object(self, sourceObject, IRenderingEventArgs)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IRenderingEventArgs)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IRenderingEventArgs, None)
    
    _get_time_metadata = { "offset" : _get_time_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def time(self) -> "IDate":
        """The time of the rendering event."""
        return self._intf.get_property(IRenderingEventArgs._metadata, IRenderingEventArgs._get_time_metadata)

    _get_time_in_ep_secs_metadata = { "offset" : _get_time_in_ep_secs_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def time_in_ep_secs(self) -> float:
        """The time of the rendering event (in STK's scenario epoch units)."""
        return self._intf.get_property(IRenderingEventArgs._metadata, IRenderingEventArgs._get_time_in_ep_secs_metadata)

    _property_names[time] = "time"
    _property_names[time_in_ep_secs] = "time_in_ep_secs"


agcls.AgClassCatalog.add_catalog_entry((4863600425244224034, 13619959685560500882), IRenderingEventArgs)
agcls.AgTypeNameMap["IRenderingEventArgs"] = IRenderingEventArgs

class IBatchPrimitiveIndex(object):
    """Represents an individual item index that is associated with a batch primitive. Provides the Index of the individual item and the Primitive that contains that index..."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_index_method_offset = 1
    _get_primitive_method_offset = 2
    _metadata = {
        "iid_data" : (5055628909548856713, 16099616916943409061),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IBatchPrimitiveIndex."""
        initialize_from_source_object(self, sourceObject, IBatchPrimitiveIndex)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IBatchPrimitiveIndex)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IBatchPrimitiveIndex, None)
    
    _get_index_metadata = { "offset" : _get_index_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LongArg,) }
    @property
    def index(self) -> int:
        """The index of the item contained by the Primitive."""
        return self._intf.get_property(IBatchPrimitiveIndex._metadata, IBatchPrimitiveIndex._get_index_metadata)

    _get_primitive_metadata = { "offset" : _get_primitive_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def primitive(self) -> "IPrimitive":
        """The Primitive that contains the item at the Index specified."""
        return self._intf.get_property(IBatchPrimitiveIndex._metadata, IBatchPrimitiveIndex._get_primitive_metadata)

    _property_names[index] = "index"
    _property_names[primitive] = "primitive"


agcls.AgClassCatalog.add_catalog_entry((5055628909548856713, 16099616916943409061), IBatchPrimitiveIndex)
agcls.AgTypeNameMap["IBatchPrimitiveIndex"] = IBatchPrimitiveIndex

class IKmlDocumentCollection(object):
    """A collection of KML documents."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_count_method_offset = 1
    _item_method_offset = 2
    _get__NewEnum_method_offset = 3
    _metadata = {
        "iid_data" : (5732338628688371025, 7645622644953202819),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IKmlDocumentCollection."""
        initialize_from_source_object(self, sourceObject, IKmlDocumentCollection)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IKmlDocumentCollection)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IKmlDocumentCollection, None)
    def __iter__(self):
        """Create an iterator for the IKmlDocumentCollection object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IKmlDocument":
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LongArg,) }
    @property
    def count(self) -> int:
        """A total number of elements in the collection."""
        return self._intf.get_property(IKmlDocumentCollection._metadata, IKmlDocumentCollection._get_count_metadata)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LongArg, agmarshall.InterfaceOutArg,) }
    def item(self, index:int) -> "KmlDocument":
        """Get an element at the specified position in the collection."""
        return self._intf.invoke(IKmlDocumentCollection._metadata, IKmlDocumentCollection._item_metadata, index, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        return self._intf.get_property(IKmlDocumentCollection._metadata, IKmlDocumentCollection._get__NewEnum_metadata)

    __getitem__ = item


    _property_names[count] = "count"
    _property_names[_NewEnum] = "_NewEnum"


agcls.AgClassCatalog.add_catalog_entry((5732338628688371025, 7645622644953202819), IKmlDocumentCollection)
agcls.AgTypeNameMap["IKmlDocumentCollection"] = IKmlDocumentCollection

class IKmlFeatureCollection(object):
    """A collection of KML features."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_count_method_offset = 1
    _item_method_offset = 2
    _get__NewEnum_method_offset = 3
    _metadata = {
        "iid_data" : (5283280579351142389, 14460084154557776063),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IKmlFeatureCollection."""
        initialize_from_source_object(self, sourceObject, IKmlFeatureCollection)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IKmlFeatureCollection)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IKmlFeatureCollection, None)
    def __iter__(self):
        """Create an iterator for the IKmlFeatureCollection object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IKmlFeature":
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.LongArg,) }
    @property
    def count(self) -> int:
        """A total number of elements in the collection."""
        return self._intf.get_property(IKmlFeatureCollection._metadata, IKmlFeatureCollection._get_count_metadata)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LongArg, agmarshall.InterfaceOutArg,) }
    def item(self, index:int) -> "IKmlFeature":
        """Get an element at the specified position in the collection."""
        return self._intf.invoke(IKmlFeatureCollection._metadata, IKmlFeatureCollection._item_metadata, index, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        return self._intf.get_property(IKmlFeatureCollection._metadata, IKmlFeatureCollection._get__NewEnum_metadata)

    __getitem__ = item


    _property_names[count] = "count"
    _property_names[_NewEnum] = "_NewEnum"


agcls.AgClassCatalog.add_catalog_entry((5283280579351142389, 14460084154557776063), IKmlFeatureCollection)
agcls.AgTypeNameMap["IKmlFeatureCollection"] = IKmlFeatureCollection

class IKmlDocumentLoadedEventArgs(object):
    """The event is raised when a KML document has been loaded."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_document_method_offset = 1
    _get_exception_method_offset = 2
    _metadata = {
        "iid_data" : (5040252077483722883, 4444885371105009835),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IKmlDocumentLoadedEventArgs."""
        initialize_from_source_object(self, sourceObject, IKmlDocumentLoadedEventArgs)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IKmlDocumentLoadedEventArgs)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IKmlDocumentLoadedEventArgs, None)
    
    _get_document_metadata = { "offset" : _get_document_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def document(self) -> "KmlDocument":
        """Get the KML document associated with the load event."""
        return self._intf.get_property(IKmlDocumentLoadedEventArgs._metadata, IKmlDocumentLoadedEventArgs._get_document_metadata)

    _get_exception_metadata = { "offset" : _get_exception_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def exception(self) -> str:
        """Return an error message, if an error occurred while loading the KML; otherwise an empty string."""
        return self._intf.get_property(IKmlDocumentLoadedEventArgs._metadata, IKmlDocumentLoadedEventArgs._get_exception_metadata)

    _property_names[document] = "document"
    _property_names[exception] = "exception"


agcls.AgClassCatalog.add_catalog_entry((5040252077483722883, 4444885371105009835), IKmlDocumentLoadedEventArgs)
agcls.AgTypeNameMap["IKmlDocumentLoadedEventArgs"] = IKmlDocumentLoadedEventArgs

class IFactoryAndInitializers(object):
    """Methods and properties are used to initialize new primitives, display conditions, screen overlays, textures and many other types; compute and retrieve triangulator results and access global properties (what's known as static properties, static methods a..."""

    _num_methods = 83
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_box_triangulator_method_offset = 1
    _get_cylinder_triangulator_method_offset = 2
    _get_ellipsoid_triangulator_method_offset = 3
    _get_extruded_polyline_triangulator_method_offset = 4
    _get_surface_extent_triangulator_method_offset = 5
    _get_surface_polygon_triangulator_method_offset = 6
    _get_surface_shapes_method_offset = 7
    _get_agi_processed_image_globe_overlay_method_offset = 8
    _get_agi_processed_terrain_overlay_method_offset = 9
    _get_agi_roam_image_globe_overlay_method_offset = 10
    _get_custom_image_globe_overlay_plugin_activator_method_offset = 11
    _get_geospatial_image_globe_overlay_method_offset = 12
    _get_projected_raster_overlay_method_offset = 13
    _get_projection_method_offset = 14
    _get_altitude_display_condition_method_offset = 15
    _get_composite_display_condition_method_offset = 16
    _get_composite_primitive_method_offset = 17
    _get_constant_display_condition_method_offset = 18
    _get_distance_display_condition_method_offset = 19
    _get_distance_to_globe_overlay_display_condition_method_offset = 20
    _get_distance_to_position_display_condition_method_offset = 21
    _get_distance_to_primitive_display_condition_method_offset = 22
    _get_duration_path_primitive_update_policy_method_offset = 23
    _get_globe_image_overlay_method_offset = 24
    _get_graphics_font_method_offset = 25
    _get_great_arc_interpolator_method_offset = 26
    _get_alpha_from_luminance_filter_method_offset = 27
    _get_alpha_from_pixel_filter_method_offset = 28
    _get_alpha_from_raster_filter_method_offset = 29
    _get_band_extract_filter_method_offset = 30
    _get_band_order_filter_method_offset = 31
    _get_blur_filter_method_offset = 32
    _get_brightness_filter_method_offset = 33
    _get_color_to_luminance_filter_method_offset = 34
    _get_contrast_filter_method_offset = 35
    _get_convolution_filter_method_offset = 36
    _get_edge_detect_filter_method_offset = 37
    _get_filtering_raster_stream_method_offset = 38
    _get_flip_filter_method_offset = 39
    _get_gamma_correction_filter_method_offset = 40
    _get_gaussian_blur_filter_method_offset = 41
    _get_gradient_detect_filter_method_offset = 42
    _get_jpeg2000_writer_method_offset = 43
    _get_levels_filter_method_offset = 44
    _get_projection_raster_stream_plugin_activator_method_offset = 45
    _get_raster_method_offset = 46
    _get_raster_attributes_method_offset = 47
    _get_rotate_filter_method_offset = 48
    _get_sequence_filter_method_offset = 49
    _get_sharpen_filter_method_offset = 50
    _get_video_stream_method_offset = 51
    _get_marker_batch_primitive_method_offset = 52
    _get_marker_batch_primitive_optional_parameters_method_offset = 53
    _get_maximum_count_path_primitive_update_policy_method_offset = 54
    _get_model_primitive_method_offset = 55
    _get_path_primitive_method_offset = 56
    _get_pixel_size_display_condition_method_offset = 57
    _get_point_batch_primitive_method_offset = 58
    _get_polyline_primitive_method_offset = 59
    _get_raster_image_globe_overlay_method_offset = 60
    _get_rhumb_line_interpolator_method_offset = 61
    _get_scene_display_condition_method_offset = 62
    _get_scene_manager_method_offset = 63
    _get_screen_overlay_method_offset = 64
    _get_solid_primitive_method_offset = 65
    _get_surface_mesh_primitive_method_offset = 66
    _get_terrain_overlay_method_offset = 67
    _get_text_batch_primitive_method_offset = 68
    _get_text_batch_primitive_optional_parameters_method_offset = 69
    _get_texture_matrix_method_offset = 70
    _get_texture_screen_overlay_method_offset = 71
    _get_time_interval_display_condition_method_offset = 72
    _get_triangle_mesh_primitive_method_offset = 73
    _get_triangle_mesh_primitive_optional_parameters_method_offset = 74
    _get_texture_filter_2d_method_offset = 75
    _get_bounding_sphere_method_offset = 76
    _get_path_point_method_offset = 77
    _get_text_overlay_method_offset = 78
    _get_agi_custom_terrain_overlay_method_offset = 79
    _get_axes_primitive_method_offset = 80
    _get_vector_primitive_method_offset = 81
    _get_polyline_primitive_optional_parameters_method_offset = 82
    _get_point_batch_primitive_optional_parameters_method_offset = 83
    _metadata = {
        "iid_data" : (5413969555641802483, 7605805363040079775),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IFactoryAndInitializers."""
        initialize_from_source_object(self, sourceObject, IFactoryAndInitializers)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IFactoryAndInitializers)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IFactoryAndInitializers, None)
    
    _get_box_triangulator_metadata = { "offset" : _get_box_triangulator_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def box_triangulator(self) -> "BoxTriangulatorInitializer":
        """Access global methods and properties of BoxTriangulator (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_box_triangulator_metadata)

    _get_cylinder_triangulator_metadata = { "offset" : _get_cylinder_triangulator_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def cylinder_triangulator(self) -> "CylinderTriangulatorInitializer":
        """Access global methods and properties of CylinderTriangulator (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_cylinder_triangulator_metadata)

    _get_ellipsoid_triangulator_metadata = { "offset" : _get_ellipsoid_triangulator_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def ellipsoid_triangulator(self) -> "EllipsoidTriangulatorInitializer":
        """Access global methods and properties of EllipsoidTriangulator (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_ellipsoid_triangulator_metadata)

    _get_extruded_polyline_triangulator_metadata = { "offset" : _get_extruded_polyline_triangulator_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def extruded_polyline_triangulator(self) -> "ExtrudedPolylineTriangulatorInitializer":
        """Access global methods and properties of ExtrudedPolylineTriangulator (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_extruded_polyline_triangulator_metadata)

    _get_surface_extent_triangulator_metadata = { "offset" : _get_surface_extent_triangulator_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def surface_extent_triangulator(self) -> "SurfaceExtentTriangulatorInitializer":
        """Access global methods and properties of SurfaceExtentTriangulator (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_surface_extent_triangulator_metadata)

    _get_surface_polygon_triangulator_metadata = { "offset" : _get_surface_polygon_triangulator_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def surface_polygon_triangulator(self) -> "SurfacePolygonTriangulatorInitializer":
        """Access global methods and properties of SurfacePolygonTriangulator (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_surface_polygon_triangulator_metadata)

    _get_surface_shapes_metadata = { "offset" : _get_surface_shapes_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def surface_shapes(self) -> "SurfaceShapesInitializer":
        """Access global methods and properties of SurfaceShapes (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_surface_shapes_metadata)

    _get_agi_processed_image_globe_overlay_metadata = { "offset" : _get_agi_processed_image_globe_overlay_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def agi_processed_image_globe_overlay(self) -> "AGIProcessedImageGlobeOverlayFactory":
        """Access global methods and properties of AGIProcessedImageGlobeOverlay (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_agi_processed_image_globe_overlay_metadata)

    _get_agi_processed_terrain_overlay_metadata = { "offset" : _get_agi_processed_terrain_overlay_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def agi_processed_terrain_overlay(self) -> "AGIProcessedTerrainOverlayFactory":
        """Access global methods and properties of AGIProcessedTerrainOverlay (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_agi_processed_terrain_overlay_metadata)

    _get_agi_roam_image_globe_overlay_metadata = { "offset" : _get_agi_roam_image_globe_overlay_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def agi_roam_image_globe_overlay(self) -> "AGIRoamImageGlobeOverlayFactory":
        """Access global methods and properties of AGIRoamImageGlobeOverlay (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_agi_roam_image_globe_overlay_metadata)

    _get_custom_image_globe_overlay_plugin_activator_metadata = { "offset" : _get_custom_image_globe_overlay_plugin_activator_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def custom_image_globe_overlay_plugin_activator(self) -> "CustomImageGlobeOverlayPluginActivatorFactory":
        """Access global methods and properties of CustomImageGlobeOverlayPluginActivator (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_custom_image_globe_overlay_plugin_activator_metadata)

    _get_geospatial_image_globe_overlay_metadata = { "offset" : _get_geospatial_image_globe_overlay_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def geospatial_image_globe_overlay(self) -> "GeospatialImageGlobeOverlayFactory":
        """Access global methods and properties of GeospatialImageGlobeOverlay (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_geospatial_image_globe_overlay_metadata)

    _get_projected_raster_overlay_metadata = { "offset" : _get_projected_raster_overlay_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def projected_raster_overlay(self) -> "ProjectedRasterOverlayFactory":
        """Access global methods and properties of ProjectedRasterOverlay (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_projected_raster_overlay_metadata)

    _get_projection_metadata = { "offset" : _get_projection_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def projection(self) -> "ProjectionFactory":
        """Access global methods and properties of Projection (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_projection_metadata)

    _get_altitude_display_condition_metadata = { "offset" : _get_altitude_display_condition_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def altitude_display_condition(self) -> "AltitudeDisplayConditionFactory":
        """Access global methods and properties of AltitudeDisplayCondition (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_altitude_display_condition_metadata)

    _get_composite_display_condition_metadata = { "offset" : _get_composite_display_condition_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def composite_display_condition(self) -> "CompositeDisplayConditionFactory":
        """Access global methods and properties of CompositeDisplayCondition (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_composite_display_condition_metadata)

    _get_composite_primitive_metadata = { "offset" : _get_composite_primitive_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def composite_primitive(self) -> "CompositePrimitiveFactory":
        """Access global methods and properties of CompositePrimitive (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_composite_primitive_metadata)

    _get_constant_display_condition_metadata = { "offset" : _get_constant_display_condition_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def constant_display_condition(self) -> "ConstantDisplayConditionFactory":
        """Access global methods and properties of ConstantDisplayCondition (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_constant_display_condition_metadata)

    _get_distance_display_condition_metadata = { "offset" : _get_distance_display_condition_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def distance_display_condition(self) -> "DistanceDisplayConditionFactory":
        """Access global methods and properties of DistanceDisplayCondition (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_distance_display_condition_metadata)

    _get_distance_to_globe_overlay_display_condition_metadata = { "offset" : _get_distance_to_globe_overlay_display_condition_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def distance_to_globe_overlay_display_condition(self) -> "DistanceToGlobeOverlayDisplayConditionFactory":
        """Access global methods and properties of DistanceToGlobeOverlayDisplayCondition (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_distance_to_globe_overlay_display_condition_metadata)

    _get_distance_to_position_display_condition_metadata = { "offset" : _get_distance_to_position_display_condition_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def distance_to_position_display_condition(self) -> "DistanceToPositionDisplayConditionFactory":
        """Access global methods and properties of DistanceToPositionDisplayCondition (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_distance_to_position_display_condition_metadata)

    _get_distance_to_primitive_display_condition_metadata = { "offset" : _get_distance_to_primitive_display_condition_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def distance_to_primitive_display_condition(self) -> "DistanceToPrimitiveDisplayConditionFactory":
        """Access global methods and properties of DistanceToPrimitiveDisplayCondition (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_distance_to_primitive_display_condition_metadata)

    _get_duration_path_primitive_update_policy_metadata = { "offset" : _get_duration_path_primitive_update_policy_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def duration_path_primitive_update_policy(self) -> "DurationPathPrimitiveUpdatePolicyFactory":
        """Access global methods and properties of DurationPathPrimitiveUpdatePolicy (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_duration_path_primitive_update_policy_metadata)

    _get_globe_image_overlay_metadata = { "offset" : _get_globe_image_overlay_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def globe_image_overlay(self) -> "GlobeImageOverlayInitializer":
        """Access global methods and properties of GlobeImageOverlay (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_globe_image_overlay_metadata)

    _get_graphics_font_metadata = { "offset" : _get_graphics_font_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def graphics_font(self) -> "GraphicsFontFactory":
        """Access global methods and properties of GraphicsFont (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_graphics_font_metadata)

    _get_great_arc_interpolator_metadata = { "offset" : _get_great_arc_interpolator_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def great_arc_interpolator(self) -> "GreatArcInterpolatorFactory":
        """Access global methods and properties of GreatArcInterpolator (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_great_arc_interpolator_metadata)

    _get_alpha_from_luminance_filter_metadata = { "offset" : _get_alpha_from_luminance_filter_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def alpha_from_luminance_filter(self) -> "AlphaFromLuminanceFilterFactory":
        """Access global methods and properties of AlphaFromLuminanceFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_alpha_from_luminance_filter_metadata)

    _get_alpha_from_pixel_filter_metadata = { "offset" : _get_alpha_from_pixel_filter_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def alpha_from_pixel_filter(self) -> "AlphaFromPixelFilterFactory":
        """Access global methods and properties of AlphaFromPixelFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_alpha_from_pixel_filter_metadata)

    _get_alpha_from_raster_filter_metadata = { "offset" : _get_alpha_from_raster_filter_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def alpha_from_raster_filter(self) -> "AlphaFromRasterFilterFactory":
        """Access global methods and properties of AlphaFromRasterFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_alpha_from_raster_filter_metadata)

    _get_band_extract_filter_metadata = { "offset" : _get_band_extract_filter_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def band_extract_filter(self) -> "BandExtractFilterFactory":
        """Access global methods and properties of BandExtractFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_band_extract_filter_metadata)

    _get_band_order_filter_metadata = { "offset" : _get_band_order_filter_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def band_order_filter(self) -> "BandOrderFilterFactory":
        """Access global methods and properties of BandOrderFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_band_order_filter_metadata)

    _get_blur_filter_metadata = { "offset" : _get_blur_filter_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def blur_filter(self) -> "BlurFilterFactory":
        """Access global methods and properties of BlurFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_blur_filter_metadata)

    _get_brightness_filter_metadata = { "offset" : _get_brightness_filter_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def brightness_filter(self) -> "BrightnessFilterFactory":
        """Access global methods and properties of BrightnessFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_brightness_filter_metadata)

    _get_color_to_luminance_filter_metadata = { "offset" : _get_color_to_luminance_filter_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def color_to_luminance_filter(self) -> "ColorToLuminanceFilterFactory":
        """Access global methods and properties of ColorToLuminanceFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_color_to_luminance_filter_metadata)

    _get_contrast_filter_metadata = { "offset" : _get_contrast_filter_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def contrast_filter(self) -> "ContrastFilterFactory":
        """Access global methods and properties of ContrastFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_contrast_filter_metadata)

    _get_convolution_filter_metadata = { "offset" : _get_convolution_filter_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def convolution_filter(self) -> "ConvolutionFilterFactory":
        """Access global methods and properties of ConvolutionFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_convolution_filter_metadata)

    _get_edge_detect_filter_metadata = { "offset" : _get_edge_detect_filter_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def edge_detect_filter(self) -> "EdgeDetectFilterFactory":
        """Access global methods and properties of EdgeDetectFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_edge_detect_filter_metadata)

    _get_filtering_raster_stream_metadata = { "offset" : _get_filtering_raster_stream_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def filtering_raster_stream(self) -> "FilteringRasterStreamFactory":
        """Access global methods and properties of FilteringRasterStream (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_filtering_raster_stream_metadata)

    _get_flip_filter_metadata = { "offset" : _get_flip_filter_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def flip_filter(self) -> "FlipFilterFactory":
        """Access global methods and properties of FlipFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_flip_filter_metadata)

    _get_gamma_correction_filter_metadata = { "offset" : _get_gamma_correction_filter_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def gamma_correction_filter(self) -> "GammaCorrectionFilterFactory":
        """Access global methods and properties of GammaCorrectionFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_gamma_correction_filter_metadata)

    _get_gaussian_blur_filter_metadata = { "offset" : _get_gaussian_blur_filter_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def gaussian_blur_filter(self) -> "GaussianBlurFilterFactory":
        """Access global methods and properties of GaussianBlurFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_gaussian_blur_filter_metadata)

    _get_gradient_detect_filter_metadata = { "offset" : _get_gradient_detect_filter_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def gradient_detect_filter(self) -> "GradientDetectFilterFactory":
        """Access global methods and properties of GradientDetectFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_gradient_detect_filter_metadata)

    _get_jpeg2000_writer_metadata = { "offset" : _get_jpeg2000_writer_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def jpeg2000_writer(self) -> "Jpeg2000WriterInitializer":
        """Access global methods and properties of Jpeg2000Writer (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_jpeg2000_writer_metadata)

    _get_levels_filter_metadata = { "offset" : _get_levels_filter_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def levels_filter(self) -> "LevelsFilterFactory":
        """Access global methods and properties of LevelsFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_levels_filter_metadata)

    _get_projection_raster_stream_plugin_activator_metadata = { "offset" : _get_projection_raster_stream_plugin_activator_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def projection_raster_stream_plugin_activator(self) -> "ProjectionRasterStreamPluginActivatorFactory":
        """Access global methods and properties of ProjectionRasterStreamPluginActivator (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_projection_raster_stream_plugin_activator_metadata)

    _get_raster_metadata = { "offset" : _get_raster_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def raster(self) -> "RasterFactory":
        """Access global methods and properties of Raster (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_raster_metadata)

    _get_raster_attributes_metadata = { "offset" : _get_raster_attributes_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def raster_attributes(self) -> "RasterAttributesFactory":
        """Access global methods and properties of RasterAttributes (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_raster_attributes_metadata)

    _get_rotate_filter_metadata = { "offset" : _get_rotate_filter_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def rotate_filter(self) -> "RotateFilterFactory":
        """Access global methods and properties of RotateFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_rotate_filter_metadata)

    _get_sequence_filter_metadata = { "offset" : _get_sequence_filter_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def sequence_filter(self) -> "SequenceFilterFactory":
        """Access global methods and properties of SequenceFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_sequence_filter_metadata)

    _get_sharpen_filter_metadata = { "offset" : _get_sharpen_filter_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def sharpen_filter(self) -> "SharpenFilterFactory":
        """Access global methods and properties of SharpenFilter (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_sharpen_filter_metadata)

    _get_video_stream_metadata = { "offset" : _get_video_stream_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def video_stream(self) -> "VideoStreamFactory":
        """Access global methods and properties of VideoStream (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_video_stream_metadata)

    _get_marker_batch_primitive_metadata = { "offset" : _get_marker_batch_primitive_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def marker_batch_primitive(self) -> "MarkerBatchPrimitiveFactory":
        """Access global methods and properties of MarkerBatchPrimitive (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_marker_batch_primitive_metadata)

    _get_marker_batch_primitive_optional_parameters_metadata = { "offset" : _get_marker_batch_primitive_optional_parameters_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def marker_batch_primitive_optional_parameters(self) -> "MarkerBatchPrimitiveOptionalParametersFactory":
        """Access global methods and properties of MarkerBatchPrimitiveOptionalParameters (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_marker_batch_primitive_optional_parameters_metadata)

    _get_maximum_count_path_primitive_update_policy_metadata = { "offset" : _get_maximum_count_path_primitive_update_policy_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def maximum_count_path_primitive_update_policy(self) -> "MaximumCountPathPrimitiveUpdatePolicyFactory":
        """Access global methods and properties of MaximumCountPathPrimitiveUpdatePolicy (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_maximum_count_path_primitive_update_policy_metadata)

    _get_model_primitive_metadata = { "offset" : _get_model_primitive_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def model_primitive(self) -> "ModelPrimitiveFactory":
        """Access global methods and properties of ModelPrimitive (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_model_primitive_metadata)

    _get_path_primitive_metadata = { "offset" : _get_path_primitive_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def path_primitive(self) -> "PathPrimitiveFactory":
        """Access global methods and properties of PathPrimitive (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_path_primitive_metadata)

    _get_pixel_size_display_condition_metadata = { "offset" : _get_pixel_size_display_condition_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def pixel_size_display_condition(self) -> "PixelSizeDisplayConditionFactory":
        """Access global methods and properties of PixelSizeDisplayCondition (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_pixel_size_display_condition_metadata)

    _get_point_batch_primitive_metadata = { "offset" : _get_point_batch_primitive_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def point_batch_primitive(self) -> "PointBatchPrimitiveFactory":
        """Access global methods and properties of PointBatchPrimitive (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_point_batch_primitive_metadata)

    _get_polyline_primitive_metadata = { "offset" : _get_polyline_primitive_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def polyline_primitive(self) -> "PolylinePrimitiveFactory":
        """Access global methods and properties of PolylinePrimitive (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_polyline_primitive_metadata)

    _get_raster_image_globe_overlay_metadata = { "offset" : _get_raster_image_globe_overlay_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def raster_image_globe_overlay(self) -> "RasterImageGlobeOverlayFactory":
        """Access global methods and properties of RasterImageGlobeOverlay (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_raster_image_globe_overlay_metadata)

    _get_rhumb_line_interpolator_metadata = { "offset" : _get_rhumb_line_interpolator_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def rhumb_line_interpolator(self) -> "RhumbLineInterpolatorFactory":
        """Access global methods and properties of RhumbLineInterpolator (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_rhumb_line_interpolator_metadata)

    _get_scene_display_condition_metadata = { "offset" : _get_scene_display_condition_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def scene_display_condition(self) -> "SceneDisplayConditionFactory":
        """Access global methods and properties of SceneDisplayCondition (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_scene_display_condition_metadata)

    _get_scene_manager_metadata = { "offset" : _get_scene_manager_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def scene_manager(self) -> "SceneManagerInitializer":
        """Access global methods and properties of SceneManager (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_scene_manager_metadata)

    _get_screen_overlay_metadata = { "offset" : _get_screen_overlay_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def screen_overlay(self) -> "ScreenOverlayFactory":
        """Access global methods and properties of ScreenOverlay (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_screen_overlay_metadata)

    _get_solid_primitive_metadata = { "offset" : _get_solid_primitive_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def solid_primitive(self) -> "SolidPrimitiveFactory":
        """Access global methods and properties of SolidPrimitive (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_solid_primitive_metadata)

    _get_surface_mesh_primitive_metadata = { "offset" : _get_surface_mesh_primitive_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def surface_mesh_primitive(self) -> "SurfaceMeshPrimitiveFactory":
        """Access global methods and properties of SurfaceMeshPrimitive (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_surface_mesh_primitive_metadata)

    _get_terrain_overlay_metadata = { "offset" : _get_terrain_overlay_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def terrain_overlay(self) -> "TerrainOverlayInitializer":
        """Access global methods and properties of TerrainOverlay (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_terrain_overlay_metadata)

    _get_text_batch_primitive_metadata = { "offset" : _get_text_batch_primitive_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def text_batch_primitive(self) -> "TextBatchPrimitiveFactory":
        """Access global methods and properties of TextBatchPrimitive (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_text_batch_primitive_metadata)

    _get_text_batch_primitive_optional_parameters_metadata = { "offset" : _get_text_batch_primitive_optional_parameters_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def text_batch_primitive_optional_parameters(self) -> "TextBatchPrimitiveOptionalParametersFactory":
        """Access global methods and properties of TextBatchPrimitiveOptionalParameters (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_text_batch_primitive_optional_parameters_metadata)

    _get_texture_matrix_metadata = { "offset" : _get_texture_matrix_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def texture_matrix(self) -> "TextureMatrixFactory":
        """Access global methods and properties of TextureMatrix (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_texture_matrix_metadata)

    _get_texture_screen_overlay_metadata = { "offset" : _get_texture_screen_overlay_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def texture_screen_overlay(self) -> "TextureScreenOverlayFactory":
        """Access global methods and properties of TextureScreenOverlay (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_texture_screen_overlay_metadata)

    _get_time_interval_display_condition_metadata = { "offset" : _get_time_interval_display_condition_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def time_interval_display_condition(self) -> "TimeIntervalDisplayConditionFactory":
        """Access global methods and properties of TimeIntervalDisplayCondition (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_time_interval_display_condition_metadata)

    _get_triangle_mesh_primitive_metadata = { "offset" : _get_triangle_mesh_primitive_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def triangle_mesh_primitive(self) -> "TriangleMeshPrimitiveFactory":
        """Access global methods and properties of TriangleMeshPrimitive (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_triangle_mesh_primitive_metadata)

    _get_triangle_mesh_primitive_optional_parameters_metadata = { "offset" : _get_triangle_mesh_primitive_optional_parameters_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def triangle_mesh_primitive_optional_parameters(self) -> "TriangleMeshPrimitiveOptionalParametersFactory":
        """Access global methods and properties of TriangleMeshPrimitiveOptionalParameters (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_triangle_mesh_primitive_optional_parameters_metadata)

    _get_texture_filter_2d_metadata = { "offset" : _get_texture_filter_2d_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def texture_filter_2d(self) -> "TextureFilter2DFactory":
        """Factory creates texture filters."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_texture_filter_2d_metadata)

    _get_bounding_sphere_metadata = { "offset" : _get_bounding_sphere_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def bounding_sphere(self) -> "BoundingSphereFactory":
        """Factory creates bounding spheres."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_bounding_sphere_metadata)

    _get_path_point_metadata = { "offset" : _get_path_point_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def path_point(self) -> "PathPointFactory":
        """Factory creates path points."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_path_point_metadata)

    _get_text_overlay_metadata = { "offset" : _get_text_overlay_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def text_overlay(self) -> "TextOverlayFactory":
        """Access global methods and properties of TextOverlay (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_text_overlay_metadata)

    _get_agi_custom_terrain_overlay_metadata = { "offset" : _get_agi_custom_terrain_overlay_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def agi_custom_terrain_overlay(self) -> "AGICustomTerrainOverlayFactory":
        """Access global methods and properties of AGICustomTerrainOverlay (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_agi_custom_terrain_overlay_metadata)

    _get_axes_primitive_metadata = { "offset" : _get_axes_primitive_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def axes_primitive(self) -> "AxesPrimitiveFactory":
        """Access global methods and properties of AxesPrimitive (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_axes_primitive_metadata)

    _get_vector_primitive_metadata = { "offset" : _get_vector_primitive_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def vector_primitive(self) -> "VectorPrimitiveFactory":
        """Access global methods and properties of VectorPrimitive (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_vector_primitive_metadata)

    _get_polyline_primitive_optional_parameters_metadata = { "offset" : _get_polyline_primitive_optional_parameters_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def polyline_primitive_optional_parameters(self) -> "PolylinePrimitiveOptionalParametersFactory":
        """Access global methods and properties of PolylinePrimitiveOptionalParameters (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_polyline_primitive_optional_parameters_metadata)

    _get_point_batch_primitive_optional_parameters_metadata = { "offset" : _get_point_batch_primitive_optional_parameters_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def point_batch_primitive_optional_parameters(self) -> "PointBatchPrimitiveOptionalParametersFactory":
        """Access global methods and properties of PointBatchPrimitiveOptionalParameters (what's known as static properties, static methods and constructors in languages such as C++, C#, etc.)."""
        return self._intf.get_property(IFactoryAndInitializers._metadata, IFactoryAndInitializers._get_point_batch_primitive_optional_parameters_metadata)

    _property_names[box_triangulator] = "box_triangulator"
    _property_names[cylinder_triangulator] = "cylinder_triangulator"
    _property_names[ellipsoid_triangulator] = "ellipsoid_triangulator"
    _property_names[extruded_polyline_triangulator] = "extruded_polyline_triangulator"
    _property_names[surface_extent_triangulator] = "surface_extent_triangulator"
    _property_names[surface_polygon_triangulator] = "surface_polygon_triangulator"
    _property_names[surface_shapes] = "surface_shapes"
    _property_names[agi_processed_image_globe_overlay] = "agi_processed_image_globe_overlay"
    _property_names[agi_processed_terrain_overlay] = "agi_processed_terrain_overlay"
    _property_names[agi_roam_image_globe_overlay] = "agi_roam_image_globe_overlay"
    _property_names[custom_image_globe_overlay_plugin_activator] = "custom_image_globe_overlay_plugin_activator"
    _property_names[geospatial_image_globe_overlay] = "geospatial_image_globe_overlay"
    _property_names[projected_raster_overlay] = "projected_raster_overlay"
    _property_names[projection] = "projection"
    _property_names[altitude_display_condition] = "altitude_display_condition"
    _property_names[composite_display_condition] = "composite_display_condition"
    _property_names[composite_primitive] = "composite_primitive"
    _property_names[constant_display_condition] = "constant_display_condition"
    _property_names[distance_display_condition] = "distance_display_condition"
    _property_names[distance_to_globe_overlay_display_condition] = "distance_to_globe_overlay_display_condition"
    _property_names[distance_to_position_display_condition] = "distance_to_position_display_condition"
    _property_names[distance_to_primitive_display_condition] = "distance_to_primitive_display_condition"
    _property_names[duration_path_primitive_update_policy] = "duration_path_primitive_update_policy"
    _property_names[globe_image_overlay] = "globe_image_overlay"
    _property_names[graphics_font] = "graphics_font"
    _property_names[great_arc_interpolator] = "great_arc_interpolator"
    _property_names[alpha_from_luminance_filter] = "alpha_from_luminance_filter"
    _property_names[alpha_from_pixel_filter] = "alpha_from_pixel_filter"
    _property_names[alpha_from_raster_filter] = "alpha_from_raster_filter"
    _property_names[band_extract_filter] = "band_extract_filter"
    _property_names[band_order_filter] = "band_order_filter"
    _property_names[blur_filter] = "blur_filter"
    _property_names[brightness_filter] = "brightness_filter"
    _property_names[color_to_luminance_filter] = "color_to_luminance_filter"
    _property_names[contrast_filter] = "contrast_filter"
    _property_names[convolution_filter] = "convolution_filter"
    _property_names[edge_detect_filter] = "edge_detect_filter"
    _property_names[filtering_raster_stream] = "filtering_raster_stream"
    _property_names[flip_filter] = "flip_filter"
    _property_names[gamma_correction_filter] = "gamma_correction_filter"
    _property_names[gaussian_blur_filter] = "gaussian_blur_filter"
    _property_names[gradient_detect_filter] = "gradient_detect_filter"
    _property_names[jpeg2000_writer] = "jpeg2000_writer"
    _property_names[levels_filter] = "levels_filter"
    _property_names[projection_raster_stream_plugin_activator] = "projection_raster_stream_plugin_activator"
    _property_names[raster] = "raster"
    _property_names[raster_attributes] = "raster_attributes"
    _property_names[rotate_filter] = "rotate_filter"
    _property_names[sequence_filter] = "sequence_filter"
    _property_names[sharpen_filter] = "sharpen_filter"
    _property_names[video_stream] = "video_stream"
    _property_names[marker_batch_primitive] = "marker_batch_primitive"
    _property_names[marker_batch_primitive_optional_parameters] = "marker_batch_primitive_optional_parameters"
    _property_names[maximum_count_path_primitive_update_policy] = "maximum_count_path_primitive_update_policy"
    _property_names[model_primitive] = "model_primitive"
    _property_names[path_primitive] = "path_primitive"
    _property_names[pixel_size_display_condition] = "pixel_size_display_condition"
    _property_names[point_batch_primitive] = "point_batch_primitive"
    _property_names[polyline_primitive] = "polyline_primitive"
    _property_names[raster_image_globe_overlay] = "raster_image_globe_overlay"
    _property_names[rhumb_line_interpolator] = "rhumb_line_interpolator"
    _property_names[scene_display_condition] = "scene_display_condition"
    _property_names[scene_manager] = "scene_manager"
    _property_names[screen_overlay] = "screen_overlay"
    _property_names[solid_primitive] = "solid_primitive"
    _property_names[surface_mesh_primitive] = "surface_mesh_primitive"
    _property_names[terrain_overlay] = "terrain_overlay"
    _property_names[text_batch_primitive] = "text_batch_primitive"
    _property_names[text_batch_primitive_optional_parameters] = "text_batch_primitive_optional_parameters"
    _property_names[texture_matrix] = "texture_matrix"
    _property_names[texture_screen_overlay] = "texture_screen_overlay"
    _property_names[time_interval_display_condition] = "time_interval_display_condition"
    _property_names[triangle_mesh_primitive] = "triangle_mesh_primitive"
    _property_names[triangle_mesh_primitive_optional_parameters] = "triangle_mesh_primitive_optional_parameters"
    _property_names[texture_filter_2d] = "texture_filter_2d"
    _property_names[bounding_sphere] = "bounding_sphere"
    _property_names[path_point] = "path_point"
    _property_names[text_overlay] = "text_overlay"
    _property_names[agi_custom_terrain_overlay] = "agi_custom_terrain_overlay"
    _property_names[axes_primitive] = "axes_primitive"
    _property_names[vector_primitive] = "vector_primitive"
    _property_names[polyline_primitive_optional_parameters] = "polyline_primitive_optional_parameters"
    _property_names[point_batch_primitive_optional_parameters] = "point_batch_primitive_optional_parameters"


agcls.AgClassCatalog.add_catalog_entry((5413969555641802483, 7605805363040079775), IFactoryAndInitializers)
agcls.AgTypeNameMap["IFactoryAndInitializers"] = IFactoryAndInitializers

class IExtrudedPolylineTriangulatorResult(object):
    """The result from extruded polyline triangulation: a triangle mesh defined using an indexed triangle list with top and bottom boundary positions. The mesh is commonly visualized with the triangle mesh primitive or surface mesh primitive..."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_top_boundary_positions_method_offset = 1
    _get_bottom_boundary_positions_method_offset = 2
    _get_boundary_positions_winding_order_method_offset = 3
    _metadata = {
        "iid_data" : (5585319328923046007, 9526893615741571244),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IExtrudedPolylineTriangulatorResult."""
        initialize_from_source_object(self, sourceObject, IExtrudedPolylineTriangulatorResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IExtrudedPolylineTriangulatorResult)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IExtrudedPolylineTriangulatorResult, None)
    
    _get_top_boundary_positions_metadata = { "offset" : _get_top_boundary_positions_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def top_boundary_positions(self) -> list:
        """Get the boundary positions along the top of the extrusion. Three array elements (in the order x, y, z) constitute one position."""
        return self._intf.get_property(IExtrudedPolylineTriangulatorResult._metadata, IExtrudedPolylineTriangulatorResult._get_top_boundary_positions_metadata)

    _get_bottom_boundary_positions_metadata = { "offset" : _get_bottom_boundary_positions_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def bottom_boundary_positions(self) -> list:
        """Get the boundary positions along the bottom of the extrusion. Three array elements (in the order x, y, z) constitute one position."""
        return self._intf.get_property(IExtrudedPolylineTriangulatorResult._metadata, IExtrudedPolylineTriangulatorResult._get_bottom_boundary_positions_metadata)

    _get_boundary_positions_winding_order_metadata = { "offset" : _get_boundary_positions_winding_order_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(WINDING_ORDER),) }
    @property
    def boundary_positions_winding_order(self) -> "WINDING_ORDER":
        """Get the winding order of top boundary positions and bottom boundary positions."""
        return self._intf.get_property(IExtrudedPolylineTriangulatorResult._metadata, IExtrudedPolylineTriangulatorResult._get_boundary_positions_winding_order_metadata)

    _property_names[top_boundary_positions] = "top_boundary_positions"
    _property_names[bottom_boundary_positions] = "bottom_boundary_positions"
    _property_names[boundary_positions_winding_order] = "boundary_positions_winding_order"


agcls.AgClassCatalog.add_catalog_entry((5585319328923046007, 9526893615741571244), IExtrudedPolylineTriangulatorResult)
agcls.AgTypeNameMap["IExtrudedPolylineTriangulatorResult"] = IExtrudedPolylineTriangulatorResult

class ISolidTriangulatorResult(object):
    """The result from a triangulation of a solid: a triangle mesh defined using an indexed triangle list and positions outlining the solid. It is recommended to visualize the solid using a solid primitive..."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_outline_indices_method_offset = 1
    _get_outline_positions_method_offset = 2
    _get_outline_polyline_type_method_offset = 3
    _get_closed_method_offset = 4
    _metadata = {
        "iid_data" : (5604440859576239731, 8920246755834744996),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ISolidTriangulatorResult."""
        initialize_from_source_object(self, sourceObject, ISolidTriangulatorResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISolidTriangulatorResult)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ISolidTriangulatorResult, None)
    
    _get_outline_indices_metadata = { "offset" : _get_outline_indices_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def outline_indices(self) -> list:
        """Get indices into positions that define the positions outlining the solid. The indices returned consider the three components of a position (x, y, and z) as a single array element..."""
        return self._intf.get_property(ISolidTriangulatorResult._metadata, ISolidTriangulatorResult._get_outline_indices_metadata)

    _get_outline_positions_metadata = { "offset" : _get_outline_positions_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def outline_positions(self) -> list:
        """Get the positions outlining the solid. Three array elements (in the order x, y, z) constitute one position."""
        return self._intf.get_property(ISolidTriangulatorResult._metadata, ISolidTriangulatorResult._get_outline_positions_metadata)

    _get_outline_polyline_type_metadata = { "offset" : _get_outline_polyline_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(POLYLINE_TYPE),) }
    @property
    def outline_polyline_type(self) -> "POLYLINE_TYPE":
        """Get the polyline type of outline indices and outline positions."""
        return self._intf.get_property(ISolidTriangulatorResult._metadata, ISolidTriangulatorResult._get_outline_polyline_type_metadata)

    _get_closed_metadata = { "offset" : _get_closed_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def closed(self) -> bool:
        """Get whether the solid is closed. For example, a box with six faces is closed. If one face is removed, the box is open."""
        return self._intf.get_property(ISolidTriangulatorResult._metadata, ISolidTriangulatorResult._get_closed_metadata)

    _property_names[outline_indices] = "outline_indices"
    _property_names[outline_positions] = "outline_positions"
    _property_names[outline_polyline_type] = "outline_polyline_type"
    _property_names[closed] = "closed"


agcls.AgClassCatalog.add_catalog_entry((5604440859576239731, 8920246755834744996), ISolidTriangulatorResult)
agcls.AgTypeNameMap["ISolidTriangulatorResult"] = ISolidTriangulatorResult

class ISurfaceShapesResult(object):
    """Represents the boundary positions of a shape on the surface computed from by a surface shapes method."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_positions_method_offset = 1
    _get_positions_winding_order_method_offset = 2
    _get_polyline_type_method_offset = 3
    _metadata = {
        "iid_data" : (5629457714368026075, 2389901432840870802),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ISurfaceShapesResult."""
        initialize_from_source_object(self, sourceObject, ISurfaceShapesResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISurfaceShapesResult)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ISurfaceShapesResult, None)
    
    _get_positions_metadata = { "offset" : _get_positions_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def positions(self) -> list:
        """Get the positions of the computed shape. Three array elements (in the order x, y, z) constitute one position."""
        return self._intf.get_property(ISurfaceShapesResult._metadata, ISurfaceShapesResult._get_positions_metadata)

    _get_positions_winding_order_metadata = { "offset" : _get_positions_winding_order_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(WINDING_ORDER),) }
    @property
    def positions_winding_order(self) -> "WINDING_ORDER":
        """Get the winding order of positions."""
        return self._intf.get_property(ISurfaceShapesResult._metadata, ISurfaceShapesResult._get_positions_winding_order_metadata)

    _get_polyline_type_metadata = { "offset" : _get_polyline_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(POLYLINE_TYPE),) }
    @property
    def polyline_type(self) -> "POLYLINE_TYPE":
        """Get the polyline type of positions."""
        return self._intf.get_property(ISurfaceShapesResult._metadata, ISurfaceShapesResult._get_polyline_type_metadata)

    _property_names[positions] = "positions"
    _property_names[positions_winding_order] = "positions_winding_order"
    _property_names[polyline_type] = "polyline_type"


agcls.AgClassCatalog.add_catalog_entry((5629457714368026075, 2389901432840870802), ISurfaceShapesResult)
agcls.AgTypeNameMap["ISurfaceShapesResult"] = ISurfaceShapesResult

class ISurfaceTriangulatorResult(object):
    """The result from a triangulation on the surface of a central body: a triangle mesh defined using an indexed triangle list and boundary positions surrounding the mesh..."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_granularity_method_offset = 1
    _get_boundary_indices_method_offset = 2
    _get_boundary_positions_method_offset = 3
    _get_boundary_positions_winding_order_method_offset = 4
    _get_boundary_polyline_type_method_offset = 5
    _metadata = {
        "iid_data" : (5555338356055792958, 12277620616557637510),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ISurfaceTriangulatorResult."""
        initialize_from_source_object(self, sourceObject, ISurfaceTriangulatorResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISurfaceTriangulatorResult)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ISurfaceTriangulatorResult, None)
    
    _get_granularity_metadata = { "offset" : _get_granularity_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def granularity(self) -> float:
        """Get the granularity used when the triangulation was computed. Lower granularities are more precise but create more triangles."""
        return self._intf.get_property(ISurfaceTriangulatorResult._metadata, ISurfaceTriangulatorResult._get_granularity_metadata)

    _get_boundary_indices_metadata = { "offset" : _get_boundary_indices_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def boundary_indices(self) -> list:
        """Get indices into positions that define the boundary positions that surround the mesh. The indices returned consider the three components of a position (x, y, and z) as a single array element..."""
        return self._intf.get_property(ISurfaceTriangulatorResult._metadata, ISurfaceTriangulatorResult._get_boundary_indices_metadata)

    _get_boundary_positions_metadata = { "offset" : _get_boundary_positions_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def boundary_positions(self) -> list:
        """Get the boundary positions that surround the mesh. Three array elements (in the order x, y, z) constitute one position."""
        return self._intf.get_property(ISurfaceTriangulatorResult._metadata, ISurfaceTriangulatorResult._get_boundary_positions_metadata)

    _get_boundary_positions_winding_order_metadata = { "offset" : _get_boundary_positions_winding_order_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(WINDING_ORDER),) }
    @property
    def boundary_positions_winding_order(self) -> "WINDING_ORDER":
        """Get the winding order of boundary positions."""
        return self._intf.get_property(ISurfaceTriangulatorResult._metadata, ISurfaceTriangulatorResult._get_boundary_positions_winding_order_metadata)

    _get_boundary_polyline_type_metadata = { "offset" : _get_boundary_polyline_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(POLYLINE_TYPE),) }
    @property
    def boundary_polyline_type(self) -> "POLYLINE_TYPE":
        """Get the polyline type of boundary positions."""
        return self._intf.get_property(ISurfaceTriangulatorResult._metadata, ISurfaceTriangulatorResult._get_boundary_polyline_type_metadata)

    _property_names[granularity] = "granularity"
    _property_names[boundary_indices] = "boundary_indices"
    _property_names[boundary_positions] = "boundary_positions"
    _property_names[boundary_positions_winding_order] = "boundary_positions_winding_order"
    _property_names[boundary_polyline_type] = "boundary_polyline_type"


agcls.AgClassCatalog.add_catalog_entry((5555338356055792958, 12277620616557637510), ISurfaceTriangulatorResult)
agcls.AgTypeNameMap["ISurfaceTriangulatorResult"] = ISurfaceTriangulatorResult

class ITriangulatorResult(object):
    """The result from triangulation: a triangle mesh defined using an indexed triangle list. This is commonly visualized with the triangle mesh primitive or surface mesh primitive."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_positions_method_offset = 1
    _get_normals_method_offset = 2
    _get_indices_method_offset = 3
    _get_triangle_winding_order_method_offset = 4
    _get_bounding_sphere_method_offset = 5
    _metadata = {
        "iid_data" : (5076915160592738393, 3604822095127444111),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ITriangulatorResult."""
        initialize_from_source_object(self, sourceObject, ITriangulatorResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITriangulatorResult)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ITriangulatorResult, None)
    
    _get_positions_metadata = { "offset" : _get_positions_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def positions(self) -> list:
        """Get the positions of the mesh. Three array elements (in the order x, y, z) constitute one position."""
        return self._intf.get_property(ITriangulatorResult._metadata, ITriangulatorResult._get_positions_metadata)

    _get_normals_metadata = { "offset" : _get_normals_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def normals(self) -> list:
        """Get the normals of the mesh. Every position in positions has corresponding normal. Normals are commonly used for lighting. Three array elements (in the order x, y, z) constitute one normal."""
        return self._intf.get_property(ITriangulatorResult._metadata, ITriangulatorResult._get_normals_metadata)

    _get_indices_metadata = { "offset" : _get_indices_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def indices(self) -> list:
        """Get indices into positions and normals. Every 3 indices represent 1 triangle. The indices returned consider the three components of a position or normal (x, y, and z) as a single array element..."""
        return self._intf.get_property(ITriangulatorResult._metadata, ITriangulatorResult._get_indices_metadata)

    _get_triangle_winding_order_metadata = { "offset" : _get_triangle_winding_order_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(WINDING_ORDER),) }
    @property
    def triangle_winding_order(self) -> "WINDING_ORDER":
        """Get the orientation of front-facing triangles in the mesh."""
        return self._intf.get_property(ITriangulatorResult._metadata, ITriangulatorResult._get_triangle_winding_order_metadata)

    _get_bounding_sphere_metadata = { "offset" : _get_bounding_sphere_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def bounding_sphere(self) -> "BoundingSphere":
        """Get the bounding sphere that encompasses the mesh."""
        return self._intf.get_property(ITriangulatorResult._metadata, ITriangulatorResult._get_bounding_sphere_metadata)

    _property_names[positions] = "positions"
    _property_names[normals] = "normals"
    _property_names[indices] = "indices"
    _property_names[triangle_winding_order] = "triangle_winding_order"
    _property_names[bounding_sphere] = "bounding_sphere"


agcls.AgClassCatalog.add_catalog_entry((5076915160592738393, 3604822095127444111), ITriangulatorResult)
agcls.AgTypeNameMap["ITriangulatorResult"] = ITriangulatorResult

class IAGICustomTerrainOverlay(object):
    """A terrain overlay for handling AGI Cesium Terrain."""

    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "iid_data" : (5647706262866986038, 13474225891505749390),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IAGICustomTerrainOverlay."""
        initialize_from_source_object(self, sourceObject, IAGICustomTerrainOverlay)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAGICustomTerrainOverlay)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IAGICustomTerrainOverlay, None)
    

agcls.AgClassCatalog.add_catalog_entry((5647706262866986038, 13474225891505749390), IAGICustomTerrainOverlay)
agcls.AgTypeNameMap["IAGICustomTerrainOverlay"] = IAGICustomTerrainOverlay

class IAGIProcessedImageGlobeOverlay(object):
    """A globe image overlay for handling AGI Processed Image (PDTTX) files."""

    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "iid_data" : (5415390494021483722, 18356321176920839827),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IAGIProcessedImageGlobeOverlay."""
        initialize_from_source_object(self, sourceObject, IAGIProcessedImageGlobeOverlay)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAGIProcessedImageGlobeOverlay)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IAGIProcessedImageGlobeOverlay, None)
    

agcls.AgClassCatalog.add_catalog_entry((5415390494021483722, 18356321176920839827), IAGIProcessedImageGlobeOverlay)
agcls.AgTypeNameMap["IAGIProcessedImageGlobeOverlay"] = IAGIProcessedImageGlobeOverlay

class IAGIProcessedTerrainOverlay(object):
    """A terrain overlay for handling AGI Processed Terrain (PDTT) files."""

    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "iid_data" : (4623415458303466258, 7863817902119241133),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IAGIProcessedTerrainOverlay."""
        initialize_from_source_object(self, sourceObject, IAGIProcessedTerrainOverlay)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAGIProcessedTerrainOverlay)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IAGIProcessedTerrainOverlay, None)
    

agcls.AgClassCatalog.add_catalog_entry((4623415458303466258, 7863817902119241133), IAGIProcessedTerrainOverlay)
agcls.AgTypeNameMap["IAGIProcessedTerrainOverlay"] = IAGIProcessedTerrainOverlay

class IAGIRoamImageGlobeOverlay(object):
    """A globe image overlay for handling ROAM (TXM/TXB) files."""

    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "iid_data" : (4984774588206252727, 3347210740923457974),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IAGIRoamImageGlobeOverlay."""
        initialize_from_source_object(self, sourceObject, IAGIRoamImageGlobeOverlay)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAGIRoamImageGlobeOverlay)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IAGIRoamImageGlobeOverlay, None)
    

agcls.AgClassCatalog.add_catalog_entry((4984774588206252727, 3347210740923457974), IAGIRoamImageGlobeOverlay)
agcls.AgTypeNameMap["IAGIRoamImageGlobeOverlay"] = IAGIRoamImageGlobeOverlay

class ICameraSnapshot(object):
    """Takes snapshots of the 3D window."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _save_to_file_method_offset = 1
    _save_to_file_with_width_and_dpi_method_offset = 2
    _save_to_clipboard_method_offset = 3
    _save_to_raster_method_offset = 4
    _save_to_texture_method_offset = 5
    _metadata = {
        "iid_data" : (5310587618602945936, 15099585874018153631),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ICameraSnapshot."""
        initialize_from_source_object(self, sourceObject, ICameraSnapshot)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICameraSnapshot)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ICameraSnapshot, None)
    
    _save_to_file_metadata = { "offset" : _save_to_file_method_offset,
            "arg_types" : (agcom.BSTR, agcom.LONG,),
            "marshallers" : (agmarshall.BStrArg, agmarshall.EnumArg(CAMERA_SNAPSHOT_FILE_FORMAT),) }
    def save_to_file(self, filename:str, cameraSnapshotFormat:"CAMERA_SNAPSHOT_FILE_FORMAT") -> None:
        """Save a snapshot of the 3D window to the filename with the specified format."""
        return self._intf.invoke(ICameraSnapshot._metadata, ICameraSnapshot._save_to_file_metadata, filename, cameraSnapshotFormat)

    _save_to_file_with_width_and_dpi_metadata = { "offset" : _save_to_file_with_width_and_dpi_method_offset,
            "arg_types" : (agcom.BSTR, agcom.LONG, agcom.DOUBLE, agcom.DOUBLE,),
            "marshallers" : (agmarshall.BStrArg, agmarshall.EnumArg(CAMERA_SNAPSHOT_FILE_FORMAT), agmarshall.DoubleArg, agmarshall.DoubleArg,) }
    def save_to_file_with_width_and_dpi(self, filename:str, cameraSnapshotFormat:"CAMERA_SNAPSHOT_FILE_FORMAT", widthInInches:float, dotsPerInch:float) -> None:
        """Save a snapshot of the 3D window to the filename with the specified format at high resolution..."""
        return self._intf.invoke(ICameraSnapshot._metadata, ICameraSnapshot._save_to_file_with_width_and_dpi_metadata, filename, cameraSnapshotFormat, widthInInches, dotsPerInch)

    _save_to_clipboard_metadata = { "offset" : _save_to_clipboard_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def save_to_clipboard(self) -> None:
        """Save a single frame of the 3D window to the clipboard."""
        return self._intf.invoke(ICameraSnapshot._metadata, ICameraSnapshot._save_to_clipboard_metadata, )

    _save_to_raster_metadata = { "offset" : _save_to_raster_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def save_to_raster(self) -> "IRaster":
        """Save a snapshot of the 3D window to a raster."""
        return self._intf.invoke(ICameraSnapshot._metadata, ICameraSnapshot._save_to_raster_metadata, OutArg())

    _save_to_texture_metadata = { "offset" : _save_to_texture_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def save_to_texture(self) -> "RendererTexture2D":
        """Save a snapshot of the 3D window to a texture 2d."""
        return self._intf.invoke(ICameraSnapshot._metadata, ICameraSnapshot._save_to_texture_metadata, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5310587618602945936, 15099585874018153631), ICameraSnapshot)
agcls.AgTypeNameMap["ICameraSnapshot"] = ICameraSnapshot

class ICameraVideoRecording(object):
    """Records the 3D window to either a movie file or to consecutively ordered image files each time the scene is rendered."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_is_recording_method_offset = 1
    _start_recording_method_offset = 2
    _start_recording_frame_stack_method_offset = 3
    _stop_recording_method_offset = 4
    _start_recording_video_method_offset = 5
    _metadata = {
        "iid_data" : (4979543382962073210, 764756984121433475),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ICameraVideoRecording."""
        initialize_from_source_object(self, sourceObject, ICameraVideoRecording)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICameraVideoRecording)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ICameraVideoRecording, None)
    
    _get_is_recording_metadata = { "offset" : _get_is_recording_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_recording(self) -> bool:
        """Get if recording is occurring or not."""
        return self._intf.get_property(ICameraVideoRecording._metadata, ICameraVideoRecording._get_is_recording_metadata)

    _start_recording_metadata = { "offset" : _start_recording_method_offset,
            "arg_types" : (agcom.BSTR, agcom.INT, agcom.INT,),
            "marshallers" : (agmarshall.BStrArg, agmarshall.IntArg, agmarshall.IntArg,) }
    def start_recording(self, wmvFilename:str, videoBitRate:int, videoFrameRate:int) -> None:
        """Do not use this method, as it is deprecated. Use the overload taking a video format instead. Starts recording a file in the WMV format at the specified bit and frame rate."""
        return self._intf.invoke(ICameraVideoRecording._metadata, ICameraVideoRecording._start_recording_metadata, wmvFilename, videoBitRate, videoFrameRate)

    _start_recording_frame_stack_metadata = { "offset" : _start_recording_frame_stack_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, agcom.INT, agcom.INT,),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.EnumArg(CAMERA_SNAPSHOT_FILE_FORMAT), agmarshall.IntArg, agmarshall.IntArg,) }
    def start_recording_frame_stack(self, fileDirectory:str, filePrefix:str, cameraSnapshotFileFormat:"CAMERA_SNAPSHOT_FILE_FORMAT", startingFrameNumber:int, numberOfFrameDigits:int) -> None:
        """Start recording a frame stack. Each frame is saved as a separate image file. The filename of each frame is defined by a prefix followed by a frame number."""
        return self._intf.invoke(ICameraVideoRecording._metadata, ICameraVideoRecording._start_recording_frame_stack_metadata, fileDirectory, filePrefix, cameraSnapshotFileFormat, startingFrameNumber, numberOfFrameDigits)

    _stop_recording_metadata = { "offset" : _stop_recording_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def stop_recording(self) -> None:
        """Stop recording."""
        return self._intf.invoke(ICameraVideoRecording._metadata, ICameraVideoRecording._stop_recording_metadata, )

    _start_recording_video_metadata = { "offset" : _start_recording_video_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, agcom.LONG, agcom.INT, agcom.INT,),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.EnumArg(CAMERA_VIDEO_FORMAT), agmarshall.IntArg, agmarshall.IntArg,) }
    def start_recording_video(self, fileDirectory:str, filePrefix:str, videoFormat:"CAMERA_VIDEO_FORMAT", videoBitRate:int, videoFrameRate:int) -> None:
        """Start recording a video file at the specified bit and frame rate."""
        return self._intf.invoke(ICameraVideoRecording._metadata, ICameraVideoRecording._start_recording_video_metadata, fileDirectory, filePrefix, videoFormat, videoBitRate, videoFrameRate)

    _property_names[is_recording] = "is_recording"


agcls.AgClassCatalog.add_catalog_entry((4979543382962073210, 764756984121433475), ICameraVideoRecording)
agcls.AgTypeNameMap["ICameraVideoRecording"] = ICameraVideoRecording

class ICentralBodyGraphicsIndexer(object):
    """An indexer into the central body graphics for a particular central body, which provides graphical properties such as showing or hiding the central body in the scene, and working with terrain and imagery for the specified central body."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_earth_method_offset = 1
    _get_moon_method_offset = 2
    _get_sun_method_offset = 3
    _item_method_offset = 4
    _get_by_name_method_offset = 5
    _metadata = {
        "iid_data" : (5339898603870531521, 4215796469053669526),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ICentralBodyGraphicsIndexer."""
        initialize_from_source_object(self, sourceObject, ICentralBodyGraphicsIndexer)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICentralBodyGraphicsIndexer)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ICentralBodyGraphicsIndexer, None)
    
    _get_earth_metadata = { "offset" : _get_earth_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def earth(self) -> "CentralBodyGraphics":
        """Get the central body graphics for the planet Earth. This is equivalent to passing a central body equal to an instance of earth central body to the indexer."""
        return self._intf.get_property(ICentralBodyGraphicsIndexer._metadata, ICentralBodyGraphicsIndexer._get_earth_metadata)

    _get_moon_metadata = { "offset" : _get_moon_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def moon(self) -> "CentralBodyGraphics":
        """Get the central body graphics for the Moon."""
        return self._intf.get_property(ICentralBodyGraphicsIndexer._metadata, ICentralBodyGraphicsIndexer._get_moon_metadata)

    _get_sun_metadata = { "offset" : _get_sun_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def sun(self) -> "CentralBodyGraphics":
        """Get the central body graphics for the Sun."""
        return self._intf.get_property(ICentralBodyGraphicsIndexer._metadata, ICentralBodyGraphicsIndexer._get_sun_metadata)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def item(self, centralBody:str) -> "CentralBodyGraphics":
        """Get the central body graphics for the specified central body."""
        return self._intf.invoke(ICentralBodyGraphicsIndexer._metadata, ICentralBodyGraphicsIndexer._item_metadata, centralBody, OutArg())

    _get_by_name_metadata = { "offset" : _get_by_name_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def get_by_name(self, name:str) -> "CentralBodyGraphics":
        """Return the central body graphics for the central body with the given name."""
        return self._intf.invoke(ICentralBodyGraphicsIndexer._metadata, ICentralBodyGraphicsIndexer._get_by_name_metadata, name, OutArg())

    __getitem__ = item


    _property_names[earth] = "earth"
    _property_names[moon] = "moon"
    _property_names[sun] = "sun"


agcls.AgClassCatalog.add_catalog_entry((5339898603870531521, 4215796469053669526), ICentralBodyGraphicsIndexer)
agcls.AgTypeNameMap["ICentralBodyGraphicsIndexer"] = ICentralBodyGraphicsIndexer

class ICustomImageGlobeOverlay(object):
    """A globe image overlay that allows for a user defined image to be specified."""

    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_is_translucent_method_offset = 1
    _get_maximum_meters_per_pixel_method_offset = 2
    _get_projection_method_offset = 3
    _start_up_method_offset = 4
    _shut_down_method_offset = 5
    _clear_cache_method_offset = 6
    _reload_method_offset = 7
    _read_method_offset = 8
    _metadata = {
        "iid_data" : (5579198083994513106, 9725554734426398627),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ICustomImageGlobeOverlay."""
        initialize_from_source_object(self, sourceObject, ICustomImageGlobeOverlay)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICustomImageGlobeOverlay)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ICustomImageGlobeOverlay, None)
    
    _get_is_translucent_metadata = { "offset" : _get_is_translucent_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_translucent(self) -> bool:
        """Get whether the overlay contains translucent imagery."""
        return self._intf.get_property(ICustomImageGlobeOverlay._metadata, ICustomImageGlobeOverlay._get_is_translucent_metadata)

    _get_maximum_meters_per_pixel_metadata = { "offset" : _get_maximum_meters_per_pixel_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def maximum_meters_per_pixel(self) -> float:
        """Get the maximum resolution of the inlay in meters per pixel."""
        return self._intf.get_property(ICustomImageGlobeOverlay._metadata, ICustomImageGlobeOverlay._get_maximum_meters_per_pixel_metadata)

    _get_projection_metadata = { "offset" : _get_projection_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(MAP_PROJECTION),) }
    @property
    def projection(self) -> "MAP_PROJECTION":
        """Get the map projection. Valid values are mercator and equidistant cylindrical."""
        return self._intf.get_property(ICustomImageGlobeOverlay._metadata, ICustomImageGlobeOverlay._get_projection_metadata)

    _start_up_metadata = { "offset" : _start_up_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IScene"),) }
    def start_up(self, scene:"IScene") -> None:
        """Initiate start-up when imagery is being added to the globe."""
        return self._intf.invoke(ICustomImageGlobeOverlay._metadata, ICustomImageGlobeOverlay._start_up_metadata, scene)

    _shut_down_metadata = { "offset" : _shut_down_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IScene"),) }
    def shut_down(self, scene:"IScene") -> None:
        """Initiate shutdown when imagery is being removed from the globe."""
        return self._intf.invoke(ICustomImageGlobeOverlay._metadata, ICustomImageGlobeOverlay._shut_down_metadata, scene)

    _clear_cache_metadata = { "offset" : _clear_cache_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def clear_cache(self) -> None:
        """Clear the image data cache associated with this instance. This is equivalent to deleting and re-adding the overlay."""
        return self._intf.invoke(ICustomImageGlobeOverlay._metadata, ICustomImageGlobeOverlay._clear_cache_metadata, )

    _reload_metadata = { "offset" : _reload_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def reload(self) -> None:
        """Reload the image data associated with this instance. Preserves the current image data until new image data replaces it."""
        return self._intf.invoke(ICustomImageGlobeOverlay._metadata, ICustomImageGlobeOverlay._reload_metadata, )

    _read_metadata = { "offset" : _read_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), agcom.Variant, POINTER(agcom.PVOID), POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.VariantArg, agmarshall.IPictureDispArg, agmarshall.VariantBoolArg,) }
    def read(self, extent:list, userTileData:typing.Any, image:IPictureDisp) -> bool:
        """Read a tile from the specified extent, scales it to and stores the result in image."""
        return self._intf.invoke(ICustomImageGlobeOverlay._metadata, ICustomImageGlobeOverlay._read_metadata, extent, userTileData, image, OutArg())

    _property_names[is_translucent] = "is_translucent"
    _property_names[maximum_meters_per_pixel] = "maximum_meters_per_pixel"
    _property_names[projection] = "projection"


agcls.AgClassCatalog.add_catalog_entry((5579198083994513106, 9725554734426398627), ICustomImageGlobeOverlay)
agcls.AgTypeNameMap["ICustomImageGlobeOverlay"] = ICustomImageGlobeOverlay

class ICustomImageGlobeOverlayPluginActivator(object):
    """The Activator class provides methods to load COM plugins that implement custom image globe overlays. For more information about custom image globe overlays, see the STK Programming Interface."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _create_from_display_name_method_offset = 1
    _get_available_display_names_method_offset = 2
    _metadata = {
        "iid_data" : (4630720187928517408, 4059776964853808547),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ICustomImageGlobeOverlayPluginActivator."""
        initialize_from_source_object(self, sourceObject, ICustomImageGlobeOverlayPluginActivator)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICustomImageGlobeOverlayPluginActivator)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ICustomImageGlobeOverlayPluginActivator, None)
    
    _create_from_display_name_metadata = { "offset" : _create_from_display_name_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_from_display_name(self, displayName:str) -> "CustomImageGlobeOverlayPluginProxy":
        """Load a custom image globe overlay COM plugin associated with the specified display name and returns a proxy object that allows accessing the custom image globe overlays implemented by the plugin."""
        return self._intf.invoke(ICustomImageGlobeOverlayPluginActivator._metadata, ICustomImageGlobeOverlayPluginActivator._create_from_display_name_metadata, displayName, OutArg())

    _get_available_display_names_metadata = { "offset" : _get_available_display_names_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    def get_available_display_names(self) -> list:
        """Get a list of available custom image globe overlay Display Names (Programmatic Identifiers)."""
        return self._intf.invoke(ICustomImageGlobeOverlayPluginActivator._metadata, ICustomImageGlobeOverlayPluginActivator._get_available_display_names_metadata, OutArg())


agcls.AgClassCatalog.add_catalog_entry((4630720187928517408, 4059776964853808547), ICustomImageGlobeOverlayPluginActivator)
agcls.AgTypeNameMap["ICustomImageGlobeOverlayPluginActivator"] = ICustomImageGlobeOverlayPluginActivator

class ICustomImageGlobeOverlayPluginProxy(object):
    """A proxy class provides access to a custom image globe overlay implemented by a plugin. Proxies are instantiated using custom image globe overlay plugin activator."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_custom_image_globe_overlay_method_offset = 1
    _get_is_custom_image_globe_overlay_supported_method_offset = 2
    _get_real_plugin_object_method_offset = 3
    _metadata = {
        "iid_data" : (4961013627642428157, 3328458864433877170),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ICustomImageGlobeOverlayPluginProxy."""
        initialize_from_source_object(self, sourceObject, ICustomImageGlobeOverlayPluginProxy)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICustomImageGlobeOverlayPluginProxy)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ICustomImageGlobeOverlayPluginProxy, None)
    
    _get_custom_image_globe_overlay_metadata = { "offset" : _get_custom_image_globe_overlay_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def custom_image_globe_overlay(self) -> "CustomImageGlobeOverlay":
        """Return a custom image globe overlay."""
        return self._intf.get_property(ICustomImageGlobeOverlayPluginProxy._metadata, ICustomImageGlobeOverlayPluginProxy._get_custom_image_globe_overlay_metadata)

    _get_is_custom_image_globe_overlay_supported_metadata = { "offset" : _get_is_custom_image_globe_overlay_supported_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_custom_image_globe_overlay_supported(self) -> bool:
        """Return true if custom image globe overlays are supported."""
        return self._intf.get_property(ICustomImageGlobeOverlayPluginProxy._metadata, ICustomImageGlobeOverlayPluginProxy._get_is_custom_image_globe_overlay_supported_metadata)

    _get_real_plugin_object_metadata = { "offset" : _get_real_plugin_object_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def real_plugin_object(self) -> typing.Any:
        """Return a pointer to plugin object's IUnknown interface."""
        return self._intf.get_property(ICustomImageGlobeOverlayPluginProxy._metadata, ICustomImageGlobeOverlayPluginProxy._get_real_plugin_object_metadata)

    _property_names[custom_image_globe_overlay] = "custom_image_globe_overlay"
    _property_names[is_custom_image_globe_overlay_supported] = "is_custom_image_globe_overlay_supported"
    _property_names[real_plugin_object] = "real_plugin_object"


agcls.AgClassCatalog.add_catalog_entry((4961013627642428157, 3328458864433877170), ICustomImageGlobeOverlayPluginProxy)
agcls.AgTypeNameMap["ICustomImageGlobeOverlayPluginProxy"] = ICustomImageGlobeOverlayPluginProxy

class IGeospatialImageGlobeOverlay(object):
    """A globe image overlay for handling `JPEG 2000 <https://jpeg.org/jpeg2000/>`_ (.jp2), ECW (.ecw), ECWP, and MrSid (.sid) image formats in the WGS84 geographic projection."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_use_transparent_color_method_offset = 1
    _set_use_transparent_color_method_offset = 2
    _get_transparent_color_method_offset = 3
    _set_transparent_color_method_offset = 4
    _metadata = {
        "iid_data" : (5501235223544899002, 14977920513653948607),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IGeospatialImageGlobeOverlay."""
        initialize_from_source_object(self, sourceObject, IGeospatialImageGlobeOverlay)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IGeospatialImageGlobeOverlay)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IGeospatialImageGlobeOverlay, None)
    
    _get_use_transparent_color_metadata = { "offset" : _get_use_transparent_color_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_transparent_color(self) -> bool:
        """Get or set whether transparent color should be used."""
        return self._intf.get_property(IGeospatialImageGlobeOverlay._metadata, IGeospatialImageGlobeOverlay._get_use_transparent_color_metadata)

    _set_use_transparent_color_metadata = { "offset" : _set_use_transparent_color_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_transparent_color.setter
    def use_transparent_color(self, useTransparentColor:bool) -> None:
        return self._intf.set_property(IGeospatialImageGlobeOverlay._metadata, IGeospatialImageGlobeOverlay._set_use_transparent_color_metadata, useTransparentColor)

    _get_transparent_color_metadata = { "offset" : _get_transparent_color_method_offset,
            "arg_types" : (POINTER(agcom.OLE_COLOR),),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @property
    def transparent_color(self) -> agcolor.Color:
        """Get or set the color that will become transparent."""
        return self._intf.get_property(IGeospatialImageGlobeOverlay._metadata, IGeospatialImageGlobeOverlay._get_transparent_color_metadata)

    _set_transparent_color_metadata = { "offset" : _set_transparent_color_method_offset,
            "arg_types" : (agcom.OLE_COLOR,),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @transparent_color.setter
    def transparent_color(self, transparentColor:agcolor.Color) -> None:
        return self._intf.set_property(IGeospatialImageGlobeOverlay._metadata, IGeospatialImageGlobeOverlay._set_transparent_color_metadata, transparentColor)

    _property_names[use_transparent_color] = "use_transparent_color"
    _property_names[transparent_color] = "transparent_color"


agcls.AgClassCatalog.add_catalog_entry((5501235223544899002, 14977920513653948607), IGeospatialImageGlobeOverlay)
agcls.AgTypeNameMap["IGeospatialImageGlobeOverlay"] = IGeospatialImageGlobeOverlay

class IGlobeOverlay(object):
    """The base class of all terrain overlay and globe image overlay objects."""

    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_central_body_method_offset = 1
    _get_extent_method_offset = 2
    _get_role_method_offset = 3
    _get_uri_as_string_method_offset = 4
    _get_is_valid_method_offset = 5
    _get_display_condition_method_offset = 6
    _set_display_condition_method_offset = 7
    _metadata = {
        "iid_data" : (5111137678954940866, 12503701247266746518),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IGlobeOverlay."""
        initialize_from_source_object(self, sourceObject, IGlobeOverlay)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IGlobeOverlay)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IGlobeOverlay, None)
    
    _get_central_body_metadata = { "offset" : _get_central_body_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def central_body(self) -> str:
        """Get the central body that the globe overlay is displayed on. It will return <see langword='null' /> if the globe overlay hasn't been added to a central body."""
        return self._intf.get_property(IGlobeOverlay._metadata, IGlobeOverlay._get_central_body_metadata)

    _get_extent_metadata = { "offset" : _get_extent_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def extent(self) -> list:
        """Get the cartographic extent that represents the area covered by the globe overlay. The array elements are arranged in the order west longitude, south latitude, east longitude, north latitude."""
        return self._intf.get_property(IGlobeOverlay._metadata, IGlobeOverlay._get_extent_metadata)

    _get_role_metadata = { "offset" : _get_role_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(GLOBE_OVERLAY_ROLE),) }
    @property
    def role(self) -> "GLOBE_OVERLAY_ROLE":
        """Get the globe overlay role of the globe overlay."""
        return self._intf.get_property(IGlobeOverlay._metadata, IGlobeOverlay._get_role_metadata)

    _get_uri_as_string_metadata = { "offset" : _get_uri_as_string_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def uri_as_string(self) -> str:
        """Get the absolute URI specifying the location of the globe overlay."""
        return self._intf.get_property(IGlobeOverlay._metadata, IGlobeOverlay._get_uri_as_string_metadata)

    _get_is_valid_metadata = { "offset" : _get_is_valid_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_valid(self) -> bool:
        """Get whether or not the overlay is valid. It can be invalid because of a missing file, corrupt file, unlicensed file, or a file on the incorrect central body."""
        return self._intf.get_property(IGlobeOverlay._metadata, IGlobeOverlay._get_is_valid_metadata)

    _get_display_condition_metadata = { "offset" : _get_display_condition_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def display_condition(self) -> "IDisplayCondition":
        """Get or set the display condition that controls whether or not the globe overlay is displayed."""
        return self._intf.get_property(IGlobeOverlay._metadata, IGlobeOverlay._get_display_condition_metadata)

    _set_display_condition_metadata = { "offset" : _set_display_condition_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IDisplayCondition"),) }
    @display_condition.setter
    def display_condition(self, displayCondition:"IDisplayCondition") -> None:
        return self._intf.set_property(IGlobeOverlay._metadata, IGlobeOverlay._set_display_condition_metadata, displayCondition)

    _property_names[central_body] = "central_body"
    _property_names[extent] = "extent"
    _property_names[role] = "role"
    _property_names[uri_as_string] = "uri_as_string"
    _property_names[is_valid] = "is_valid"
    _property_names[display_condition] = "display_condition"


agcls.AgClassCatalog.add_catalog_entry((5111137678954940866, 12503701247266746518), IGlobeOverlay)
agcls.AgTypeNameMap["IGlobeOverlay"] = IGlobeOverlay

class IGlobeOverlaySettings(object):
    """Settings used by globe overlay objects. These setting affect all scenes."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_terrain_cache_size_method_offset = 1
    _set_terrain_cache_size_method_offset = 2
    _get_imagery_cache_size_method_offset = 3
    _set_imagery_cache_size_method_offset = 4
    _get_preload_terrain_and_imagery_method_offset = 5
    _set_preload_terrain_and_imagery_method_offset = 6
    _metadata = {
        "iid_data" : (4807517707255994079, 16599142282845173912),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IGlobeOverlaySettings."""
        initialize_from_source_object(self, sourceObject, IGlobeOverlaySettings)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IGlobeOverlaySettings)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IGlobeOverlaySettings, None)
    
    _get_terrain_cache_size_metadata = { "offset" : _get_terrain_cache_size_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def terrain_cache_size(self) -> int:
        """Get or set the size of the terrain cache in megabytes. It is not recommended to go above 128 megabytes. Large cache sizes can slow down rendering since so much imagery will be rendered."""
        return self._intf.get_property(IGlobeOverlaySettings._metadata, IGlobeOverlaySettings._get_terrain_cache_size_metadata)

    _set_terrain_cache_size_metadata = { "offset" : _set_terrain_cache_size_method_offset,
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.IntArg,) }
    @terrain_cache_size.setter
    def terrain_cache_size(self, terrainCacheSize:int) -> None:
        return self._intf.set_property(IGlobeOverlaySettings._metadata, IGlobeOverlaySettings._set_terrain_cache_size_metadata, terrainCacheSize)

    _get_imagery_cache_size_metadata = { "offset" : _get_imagery_cache_size_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def imagery_cache_size(self) -> int:
        """Get or set the size of the imagery cache in megabytes. It is not recommended to go above 128 megabytes. Large cache sizes can slow down rendering since so much imagery will be rendered."""
        return self._intf.get_property(IGlobeOverlaySettings._metadata, IGlobeOverlaySettings._get_imagery_cache_size_metadata)

    _set_imagery_cache_size_metadata = { "offset" : _set_imagery_cache_size_method_offset,
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.IntArg,) }
    @imagery_cache_size.setter
    def imagery_cache_size(self, imageryCacheSize:int) -> None:
        return self._intf.set_property(IGlobeOverlaySettings._metadata, IGlobeOverlaySettings._set_imagery_cache_size_metadata, imageryCacheSize)

    _get_preload_terrain_and_imagery_metadata = { "offset" : _get_preload_terrain_and_imagery_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def preload_terrain_and_imagery(self) -> bool:
        """Get or set whether terrain and imagery are preloaded. When set to true, terrain and imagery are preloaded to get the best visual quality; when set to false, they are not preloaded..."""
        return self._intf.get_property(IGlobeOverlaySettings._metadata, IGlobeOverlaySettings._get_preload_terrain_and_imagery_metadata)

    _set_preload_terrain_and_imagery_metadata = { "offset" : _set_preload_terrain_and_imagery_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @preload_terrain_and_imagery.setter
    def preload_terrain_and_imagery(self, preloadTerrainAndImagery:bool) -> None:
        return self._intf.set_property(IGlobeOverlaySettings._metadata, IGlobeOverlaySettings._set_preload_terrain_and_imagery_metadata, preloadTerrainAndImagery)

    _property_names[terrain_cache_size] = "terrain_cache_size"
    _property_names[imagery_cache_size] = "imagery_cache_size"
    _property_names[preload_terrain_and_imagery] = "preload_terrain_and_imagery"


agcls.AgClassCatalog.add_catalog_entry((4807517707255994079, 16599142282845173912), IGlobeOverlaySettings)
agcls.AgTypeNameMap["IGlobeOverlaySettings"] = IGlobeOverlaySettings

class ILighting(object):
    """Lighting in the 3D scene."""

    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_enabled_method_offset = 1
    _set_enabled_method_offset = 2
    _get_ambient_intensity_method_offset = 3
    _set_ambient_intensity_method_offset = 4
    _get_diffuse_intensity_method_offset = 5
    _set_diffuse_intensity_method_offset = 6
    _get_night_lights_intensity_method_offset = 7
    _set_night_lights_intensity_method_offset = 8
    _metadata = {
        "iid_data" : (5237498334712483872, 1351019444030006455),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ILighting."""
        initialize_from_source_object(self, sourceObject, ILighting)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ILighting)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ILighting, None)
    
    _get_enabled_metadata = { "offset" : _get_enabled_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def enabled(self) -> bool:
        """Get or set whether or not lighting is enabled."""
        return self._intf.get_property(ILighting._metadata, ILighting._get_enabled_metadata)

    _set_enabled_metadata = { "offset" : _set_enabled_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @enabled.setter
    def enabled(self, enabled:bool) -> None:
        return self._intf.set_property(ILighting._metadata, ILighting._set_enabled_metadata, enabled)

    _get_ambient_intensity_metadata = { "offset" : _get_ambient_intensity_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def ambient_intensity(self) -> float:
        """Get or set the ambient intensity throughout the scene."""
        return self._intf.get_property(ILighting._metadata, ILighting._get_ambient_intensity_metadata)

    _set_ambient_intensity_metadata = { "offset" : _set_ambient_intensity_method_offset,
            "arg_types" : (agcom.FLOAT,),
            "marshallers" : (agmarshall.FloatArg,) }
    @ambient_intensity.setter
    def ambient_intensity(self, ambientIntensity:float) -> None:
        return self._intf.set_property(ILighting._metadata, ILighting._set_ambient_intensity_metadata, ambientIntensity)

    _get_diffuse_intensity_metadata = { "offset" : _get_diffuse_intensity_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def diffuse_intensity(self) -> float:
        """Get or set the diffuse intensity from the sun."""
        return self._intf.get_property(ILighting._metadata, ILighting._get_diffuse_intensity_metadata)

    _set_diffuse_intensity_metadata = { "offset" : _set_diffuse_intensity_method_offset,
            "arg_types" : (agcom.FLOAT,),
            "marshallers" : (agmarshall.FloatArg,) }
    @diffuse_intensity.setter
    def diffuse_intensity(self, diffuseIntensity:float) -> None:
        return self._intf.set_property(ILighting._metadata, ILighting._set_diffuse_intensity_metadata, diffuseIntensity)

    _get_night_lights_intensity_metadata = { "offset" : _get_night_lights_intensity_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def night_lights_intensity(self) -> float:
        """Get or set the overall brightness for the night light's image overlay, night overlay."""
        return self._intf.get_property(ILighting._metadata, ILighting._get_night_lights_intensity_metadata)

    _set_night_lights_intensity_metadata = { "offset" : _set_night_lights_intensity_method_offset,
            "arg_types" : (agcom.FLOAT,),
            "marshallers" : (agmarshall.FloatArg,) }
    @night_lights_intensity.setter
    def night_lights_intensity(self, nightLightsIntensity:float) -> None:
        return self._intf.set_property(ILighting._metadata, ILighting._set_night_lights_intensity_metadata, nightLightsIntensity)

    _property_names[enabled] = "enabled"
    _property_names[ambient_intensity] = "ambient_intensity"
    _property_names[diffuse_intensity] = "diffuse_intensity"
    _property_names[night_lights_intensity] = "night_lights_intensity"


agcls.AgClassCatalog.add_catalog_entry((5237498334712483872, 1351019444030006455), ILighting)
agcls.AgTypeNameMap["ILighting"] = ILighting

class IPathPrimitiveUpdatePolicy(object):
    """A class that encapsulates the update logic for a path primitive. Derived classes must implement the Update method."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _update_method_offset = 1
    _metadata = {
        "iid_data" : (4972495962199984526, 7764744302225031324),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IPathPrimitiveUpdatePolicy."""
        initialize_from_source_object(self, sourceObject, IPathPrimitiveUpdatePolicy)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IPathPrimitiveUpdatePolicy)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IPathPrimitiveUpdatePolicy, None)
    
    _update_metadata = { "offset" : _update_method_offset,
            "arg_types" : (agcom.PVOID, agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IPathPrimitive"), agmarshall.InterfaceInArg("IDate"),) }
    def update(self, pathPrimitive:"IPathPrimitive", date:"IDate") -> None:
        """Update the pathPrimitive at the specified date."""
        return self._intf.invoke(IPathPrimitiveUpdatePolicy._metadata, IPathPrimitiveUpdatePolicy._update_metadata, pathPrimitive, date)


agcls.AgClassCatalog.add_catalog_entry((4972495962199984526, 7764744302225031324), IPathPrimitiveUpdatePolicy)
agcls.AgTypeNameMap["IPathPrimitiveUpdatePolicy"] = IPathPrimitiveUpdatePolicy

class IProjectedRasterOverlay(object):
    """A globe image overlay which projects a raster onto the terrain or surface of the central body. You can also enable projection onto models by setting projected raster model projection to true for a Scene..."""

    _num_methods = 36
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_raster_method_offset = 1
    _set_raster_method_offset = 2
    _get_projection_method_offset = 3
    _set_projection_method_offset = 4
    _get_show_shadows_method_offset = 5
    _set_show_shadows_method_offset = 6
    _get_show_frustum_method_offset = 7
    _set_show_frustum_method_offset = 8
    _get_show_far_plane_method_offset = 9
    _set_show_far_plane_method_offset = 10
    _get_color_method_offset = 11
    _set_color_method_offset = 12
    _get_frustum_color_method_offset = 13
    _set_frustum_color_method_offset = 14
    _get_far_plane_color_method_offset = 15
    _set_far_plane_color_method_offset = 16
    _get_shadow_color_method_offset = 17
    _set_shadow_color_method_offset = 18
    _get_border_color_method_offset = 19
    _set_border_color_method_offset = 20
    _get_border_width_method_offset = 21
    _set_border_width_method_offset = 22
    _get_frustum_translucency_method_offset = 23
    _set_frustum_translucency_method_offset = 24
    _get_far_plane_translucency_method_offset = 25
    _set_far_plane_translucency_method_offset = 26
    _get_shadow_translucency_method_offset = 27
    _set_shadow_translucency_method_offset = 28
    _get_border_translucency_method_offset = 29
    _set_border_translucency_method_offset = 30
    _get_use_transparent_color_method_offset = 31
    _set_use_transparent_color_method_offset = 32
    _get_transparent_color_method_offset = 33
    _set_transparent_color_method_offset = 34
    _get_directions_method_offset = 35
    _get_supported_method_offset = 36
    _metadata = {
        "iid_data" : (4883959137172591341, 4886933176258315195),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IProjectedRasterOverlay."""
        initialize_from_source_object(self, sourceObject, IProjectedRasterOverlay)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IProjectedRasterOverlay)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IProjectedRasterOverlay, None)
    
    _get_raster_metadata = { "offset" : _get_raster_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def raster(self) -> "IRaster":
        """Get or set the raster that is projected."""
        return self._intf.get_property(IProjectedRasterOverlay._metadata, IProjectedRasterOverlay._get_raster_metadata)

    _set_raster_metadata = { "offset" : _set_raster_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IRaster"),) }
    @raster.setter
    def raster(self, raster:"IRaster") -> None:
        return self._intf.set_property(IProjectedRasterOverlay._metadata, IProjectedRasterOverlay._set_raster_metadata, raster)

    _get_projection_metadata = { "offset" : _get_projection_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def projection(self) -> "IProjection":
        """Get or set the projection that projects the raster."""
        return self._intf.get_property(IProjectedRasterOverlay._metadata, IProjectedRasterOverlay._get_projection_metadata)

    _set_projection_metadata = { "offset" : _set_projection_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IProjection"),) }
    @projection.setter
    def projection(self, projection:"IProjection") -> None:
        return self._intf.set_property(IProjectedRasterOverlay._metadata, IProjectedRasterOverlay._set_projection_metadata, projection)

    _get_show_shadows_metadata = { "offset" : _get_show_shadows_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def show_shadows(self) -> bool:
        """Get or set whether to show shadows or not. When set to true, the raster will only be projected onto parts of the terrain visible from the projection's position. When false, the raster will project onto any terrain inside the projection's view frustum..."""
        return self._intf.get_property(IProjectedRasterOverlay._metadata, IProjectedRasterOverlay._get_show_shadows_metadata)

    _set_show_shadows_metadata = { "offset" : _set_show_shadows_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @show_shadows.setter
    def show_shadows(self, showShadows:bool) -> None:
        return self._intf.set_property(IProjectedRasterOverlay._metadata, IProjectedRasterOverlay._set_show_shadows_metadata, showShadows)

    _get_show_frustum_metadata = { "offset" : _get_show_frustum_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def show_frustum(self) -> bool:
        """Get or set whether to show the frustum of the projection."""
        return self._intf.get_property(IProjectedRasterOverlay._metadata, IProjectedRasterOverlay._get_show_frustum_metadata)

    _set_show_frustum_metadata = { "offset" : _set_show_frustum_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @show_frustum.setter
    def show_frustum(self, showFrustum:bool) -> None:
        return self._intf.set_property(IProjectedRasterOverlay._metadata, IProjectedRasterOverlay._set_show_frustum_metadata, showFrustum)

    _get_show_far_plane_metadata = { "offset" : _get_show_far_plane_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def show_far_plane(self) -> bool:
        """Get or set whether to show the far plane of the projection. If this is set to true, you will see the projected raster even when it does not intersect terrain."""
        return self._intf.get_property(IProjectedRasterOverlay._metadata, IProjectedRasterOverlay._get_show_far_plane_metadata)

    _set_show_far_plane_metadata = { "offset" : _set_show_far_plane_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @show_far_plane.setter
    def show_far_plane(self, showFarPlane:bool) -> None:
        return self._intf.set_property(IProjectedRasterOverlay._metadata, IProjectedRasterOverlay._set_show_far_plane_metadata, showFarPlane)

    _get_color_metadata = { "offset" : _get_color_method_offset,
            "arg_types" : (POINTER(agcom.OLE_COLOR),),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @property
    def color(self) -> agcolor.Color:
        """Get or set the color of the projected raster."""
        return self._intf.get_property(IProjectedRasterOverlay._metadata, IProjectedRasterOverlay._get_color_metadata)

    _set_color_metadata = { "offset" : _set_color_method_offset,
            "arg_types" : (agcom.OLE_COLOR,),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @color.setter
    def color(self, color:agcolor.Color) -> None:
        return self._intf.set_property(IProjectedRasterOverlay._metadata, IProjectedRasterOverlay._set_color_metadata, color)

    _get_frustum_color_metadata = { "offset" : _get_frustum_color_method_offset,
            "arg_types" : (POINTER(agcom.OLE_COLOR),),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @property
    def frustum_color(self) -> agcolor.Color:
        """Get or set the color of the projection's frustum."""
        return self._intf.get_property(IProjectedRasterOverlay._metadata, IProjectedRasterOverlay._get_frustum_color_metadata)

    _set_frustum_color_metadata = { "offset" : _set_frustum_color_method_offset,
            "arg_types" : (agcom.OLE_COLOR,),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @frustum_color.setter
    def frustum_color(self, frustumColor:agcolor.Color) -> None:
        return self._intf.set_property(IProjectedRasterOverlay._metadata, IProjectedRasterOverlay._set_frustum_color_metadata, frustumColor)

    _get_far_plane_color_metadata = { "offset" : _get_far_plane_color_method_offset,
            "arg_types" : (POINTER(agcom.OLE_COLOR),),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @property
    def far_plane_color(self) -> agcolor.Color:
        """Get or set the color of the projection's far plane."""
        return self._intf.get_property(IProjectedRasterOverlay._metadata, IProjectedRasterOverlay._get_far_plane_color_metadata)

    _set_far_plane_color_metadata = { "offset" : _set_far_plane_color_method_offset,
            "arg_types" : (agcom.OLE_COLOR,),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @far_plane_color.setter
    def far_plane_color(self, farPlaneColor:agcolor.Color) -> None:
        return self._intf.set_property(IProjectedRasterOverlay._metadata, IProjectedRasterOverlay._set_far_plane_color_metadata, farPlaneColor)

    _get_shadow_color_metadata = { "offset" : _get_shadow_color_method_offset,
            "arg_types" : (POINTER(agcom.OLE_COLOR),),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @property
    def shadow_color(self) -> agcolor.Color:
        """Get or set the color of the projection's shadow."""
        return self._intf.get_property(IProjectedRasterOverlay._metadata, IProjectedRasterOverlay._get_shadow_color_metadata)

    _set_shadow_color_metadata = { "offset" : _set_shadow_color_method_offset,
            "arg_types" : (agcom.OLE_COLOR,),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @shadow_color.setter
    def shadow_color(self, shadowColor:agcolor.Color) -> None:
        return self._intf.set_property(IProjectedRasterOverlay._metadata, IProjectedRasterOverlay._set_shadow_color_metadata, shadowColor)

    _get_border_color_metadata = { "offset" : _get_border_color_method_offset,
            "arg_types" : (POINTER(agcom.OLE_COLOR),),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @property
    def border_color(self) -> agcolor.Color:
        """Get or set the color of the projection's border."""
        return self._intf.get_property(IProjectedRasterOverlay._metadata, IProjectedRasterOverlay._get_border_color_metadata)

    _set_border_color_metadata = { "offset" : _set_border_color_method_offset,
            "arg_types" : (agcom.OLE_COLOR,),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @border_color.setter
    def border_color(self, borderColor:agcolor.Color) -> None:
        return self._intf.set_property(IProjectedRasterOverlay._metadata, IProjectedRasterOverlay._set_border_color_metadata, borderColor)

    _get_border_width_metadata = { "offset" : _get_border_width_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def border_width(self) -> float:
        """Get or set the width of the projection's border."""
        return self._intf.get_property(IProjectedRasterOverlay._metadata, IProjectedRasterOverlay._get_border_width_metadata)

    _set_border_width_metadata = { "offset" : _set_border_width_method_offset,
            "arg_types" : (agcom.FLOAT,),
            "marshallers" : (agmarshall.FloatArg,) }
    @border_width.setter
    def border_width(self, borderWidth:float) -> None:
        return self._intf.set_property(IProjectedRasterOverlay._metadata, IProjectedRasterOverlay._set_border_width_metadata, borderWidth)

    _get_frustum_translucency_metadata = { "offset" : _get_frustum_translucency_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def frustum_translucency(self) -> float:
        """Get or set the translucency of the projection's frustum."""
        return self._intf.get_property(IProjectedRasterOverlay._metadata, IProjectedRasterOverlay._get_frustum_translucency_metadata)

    _set_frustum_translucency_metadata = { "offset" : _set_frustum_translucency_method_offset,
            "arg_types" : (agcom.FLOAT,),
            "marshallers" : (agmarshall.FloatArg,) }
    @frustum_translucency.setter
    def frustum_translucency(self, frustumTranslucency:float) -> None:
        return self._intf.set_property(IProjectedRasterOverlay._metadata, IProjectedRasterOverlay._set_frustum_translucency_metadata, frustumTranslucency)

    _get_far_plane_translucency_metadata = { "offset" : _get_far_plane_translucency_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def far_plane_translucency(self) -> float:
        """Get or set the translucency of the projection's far plane."""
        return self._intf.get_property(IProjectedRasterOverlay._metadata, IProjectedRasterOverlay._get_far_plane_translucency_metadata)

    _set_far_plane_translucency_metadata = { "offset" : _set_far_plane_translucency_method_offset,
            "arg_types" : (agcom.FLOAT,),
            "marshallers" : (agmarshall.FloatArg,) }
    @far_plane_translucency.setter
    def far_plane_translucency(self, farPlaneTranslucency:float) -> None:
        return self._intf.set_property(IProjectedRasterOverlay._metadata, IProjectedRasterOverlay._set_far_plane_translucency_metadata, farPlaneTranslucency)

    _get_shadow_translucency_metadata = { "offset" : _get_shadow_translucency_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def shadow_translucency(self) -> float:
        """Get or set the translucency of the projection's shadow."""
        return self._intf.get_property(IProjectedRasterOverlay._metadata, IProjectedRasterOverlay._get_shadow_translucency_metadata)

    _set_shadow_translucency_metadata = { "offset" : _set_shadow_translucency_method_offset,
            "arg_types" : (agcom.FLOAT,),
            "marshallers" : (agmarshall.FloatArg,) }
    @shadow_translucency.setter
    def shadow_translucency(self, shadowTranslucency:float) -> None:
        return self._intf.set_property(IProjectedRasterOverlay._metadata, IProjectedRasterOverlay._set_shadow_translucency_metadata, shadowTranslucency)

    _get_border_translucency_metadata = { "offset" : _get_border_translucency_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def border_translucency(self) -> float:
        """Get or set the translucency of the projection's border."""
        return self._intf.get_property(IProjectedRasterOverlay._metadata, IProjectedRasterOverlay._get_border_translucency_metadata)

    _set_border_translucency_metadata = { "offset" : _set_border_translucency_method_offset,
            "arg_types" : (agcom.FLOAT,),
            "marshallers" : (agmarshall.FloatArg,) }
    @border_translucency.setter
    def border_translucency(self, borderTranslucency:float) -> None:
        return self._intf.set_property(IProjectedRasterOverlay._metadata, IProjectedRasterOverlay._set_border_translucency_metadata, borderTranslucency)

    _get_use_transparent_color_metadata = { "offset" : _get_use_transparent_color_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_transparent_color(self) -> bool:
        """Get or set whether transparent color should be used."""
        return self._intf.get_property(IProjectedRasterOverlay._metadata, IProjectedRasterOverlay._get_use_transparent_color_metadata)

    _set_use_transparent_color_metadata = { "offset" : _set_use_transparent_color_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_transparent_color.setter
    def use_transparent_color(self, useTransparentColor:bool) -> None:
        return self._intf.set_property(IProjectedRasterOverlay._metadata, IProjectedRasterOverlay._set_use_transparent_color_metadata, useTransparentColor)

    _get_transparent_color_metadata = { "offset" : _get_transparent_color_method_offset,
            "arg_types" : (POINTER(agcom.OLE_COLOR),),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @property
    def transparent_color(self) -> agcolor.Color:
        """Get or set the color that will become transparent."""
        return self._intf.get_property(IProjectedRasterOverlay._metadata, IProjectedRasterOverlay._get_transparent_color_metadata)

    _set_transparent_color_metadata = { "offset" : _set_transparent_color_method_offset,
            "arg_types" : (agcom.OLE_COLOR,),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @transparent_color.setter
    def transparent_color(self, transparentColor:agcolor.Color) -> None:
        return self._intf.set_property(IProjectedRasterOverlay._metadata, IProjectedRasterOverlay._set_transparent_color_metadata, transparentColor)

    _get_directions_metadata = { "offset" : _get_directions_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def directions(self) -> list:
        """Get the direction vectors in the central body's fixed reference frame that define the projection's frustum..."""
        return self._intf.get_property(IProjectedRasterOverlay._metadata, IProjectedRasterOverlay._get_directions_metadata)

    _get_supported_metadata = { "offset" : _get_supported_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def supported(self) -> bool:
        """Get whether or not the video card supports the projected raster overlay."""
        return self._intf.get_property(IProjectedRasterOverlay._metadata, IProjectedRasterOverlay._get_supported_metadata)

    _property_names[raster] = "raster"
    _property_names[projection] = "projection"
    _property_names[show_shadows] = "show_shadows"
    _property_names[show_frustum] = "show_frustum"
    _property_names[show_far_plane] = "show_far_plane"
    _property_names[color] = "color"
    _property_names[frustum_color] = "frustum_color"
    _property_names[far_plane_color] = "far_plane_color"
    _property_names[shadow_color] = "shadow_color"
    _property_names[border_color] = "border_color"
    _property_names[border_width] = "border_width"
    _property_names[frustum_translucency] = "frustum_translucency"
    _property_names[far_plane_translucency] = "far_plane_translucency"
    _property_names[shadow_translucency] = "shadow_translucency"
    _property_names[border_translucency] = "border_translucency"
    _property_names[use_transparent_color] = "use_transparent_color"
    _property_names[transparent_color] = "transparent_color"
    _property_names[directions] = "directions"
    _property_names[supported] = "supported"


agcls.AgClassCatalog.add_catalog_entry((4883959137172591341, 4886933176258315195), IProjectedRasterOverlay)
agcls.AgTypeNameMap["IProjectedRasterOverlay"] = IProjectedRasterOverlay

class IProjection(object):
    """A projection represents a simplified camera with a position, orientation, and field of view horizontal and field of view vertical..."""

    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_position_method_offset = 1
    _set_position_method_offset = 2
    _get_orientation_method_offset = 3
    _set_orientation_method_offset = 4
    _get_field_of_view_horizontal_method_offset = 5
    _set_field_of_view_horizontal_method_offset = 6
    _get_field_of_view_vertical_method_offset = 7
    _set_field_of_view_vertical_method_offset = 8
    _get_near_plane_method_offset = 9
    _set_near_plane_method_offset = 10
    _get_far_plane_method_offset = 11
    _set_far_plane_method_offset = 12
    _metadata = {
        "iid_data" : (5604768975439149570, 12374794011928356263),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IProjection."""
        initialize_from_source_object(self, sourceObject, IProjection)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IProjection)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IProjection, None)
    
    _get_position_metadata = { "offset" : _get_position_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def position(self) -> list:
        """Get or set the cartesian defining the position of the projection in the central body's fixed reference frame. The array contains the components of the position arranged in the order x, y, z."""
        return self._intf.get_property(IProjection._metadata, IProjection._get_position_metadata)

    _set_position_metadata = { "offset" : _set_position_method_offset,
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @position.setter
    def position(self, position:list) -> None:
        return self._intf.set_property(IProjection._metadata, IProjection._set_position_metadata, position)

    _get_orientation_metadata = { "offset" : _get_orientation_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def orientation(self) -> "IOrientation":
        """Get or set the unit quaternion defining the orientation of the projection in the central body's fixed reference frame."""
        return self._intf.get_property(IProjection._metadata, IProjection._get_orientation_metadata)

    _set_orientation_metadata = { "offset" : _set_orientation_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IOrientation"),) }
    @orientation.setter
    def orientation(self, orientation:"IOrientation") -> None:
        return self._intf.set_property(IProjection._metadata, IProjection._set_orientation_metadata, orientation)

    _get_field_of_view_horizontal_metadata = { "offset" : _get_field_of_view_horizontal_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def field_of_view_horizontal(self) -> float:
        """Get or set the horizontal field of view associated with the projection."""
        return self._intf.get_property(IProjection._metadata, IProjection._get_field_of_view_horizontal_metadata)

    _set_field_of_view_horizontal_metadata = { "offset" : _set_field_of_view_horizontal_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @field_of_view_horizontal.setter
    def field_of_view_horizontal(self, fieldOfViewHorizontal:float) -> None:
        return self._intf.set_property(IProjection._metadata, IProjection._set_field_of_view_horizontal_metadata, fieldOfViewHorizontal)

    _get_field_of_view_vertical_metadata = { "offset" : _get_field_of_view_vertical_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def field_of_view_vertical(self) -> float:
        """Get or set the vertical field of view associated with the projection."""
        return self._intf.get_property(IProjection._metadata, IProjection._get_field_of_view_vertical_metadata)

    _set_field_of_view_vertical_metadata = { "offset" : _set_field_of_view_vertical_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @field_of_view_vertical.setter
    def field_of_view_vertical(self, fieldOfViewVertical:float) -> None:
        return self._intf.set_property(IProjection._metadata, IProjection._set_field_of_view_vertical_metadata, fieldOfViewVertical)

    _get_near_plane_metadata = { "offset" : _get_near_plane_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def near_plane(self) -> float:
        """Get or set the near plane associated with the projection."""
        return self._intf.get_property(IProjection._metadata, IProjection._get_near_plane_metadata)

    _set_near_plane_metadata = { "offset" : _set_near_plane_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @near_plane.setter
    def near_plane(self, nearPlane:float) -> None:
        return self._intf.set_property(IProjection._metadata, IProjection._set_near_plane_metadata, nearPlane)

    _get_far_plane_metadata = { "offset" : _get_far_plane_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def far_plane(self) -> float:
        """Get or set the far plane associated with the projection."""
        return self._intf.get_property(IProjection._metadata, IProjection._get_far_plane_metadata)

    _set_far_plane_metadata = { "offset" : _set_far_plane_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @far_plane.setter
    def far_plane(self, farPlane:float) -> None:
        return self._intf.set_property(IProjection._metadata, IProjection._set_far_plane_metadata, farPlane)

    _property_names[position] = "position"
    _property_names[orientation] = "orientation"
    _property_names[field_of_view_horizontal] = "field_of_view_horizontal"
    _property_names[field_of_view_vertical] = "field_of_view_vertical"
    _property_names[near_plane] = "near_plane"
    _property_names[far_plane] = "far_plane"


agcls.AgClassCatalog.add_catalog_entry((5604768975439149570, 12374794011928356263), IProjection)
agcls.AgTypeNameMap["IProjection"] = IProjection

class IProjectionStream(object):
    """A projection that is updated dynamically at the specified update delta. The class can be used to stream projection data to projection clients, like projected raster overlay..."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_update_delta_method_offset = 1
    _set_update_delta_method_offset = 2
    _update_method_offset = 3
    _metadata = {
        "iid_data" : (5166404080678366159, 7416564084710466476),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IProjectionStream."""
        initialize_from_source_object(self, sourceObject, IProjectionStream)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IProjectionStream)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IProjectionStream, None)
    
    _get_update_delta_metadata = { "offset" : _get_update_delta_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def update_delta(self) -> float:
        """Get or set the update delta of the projection stream in seconds. The update delta defines the interval at which the Update method will be called..."""
        return self._intf.get_property(IProjectionStream._metadata, IProjectionStream._get_update_delta_metadata)

    _set_update_delta_metadata = { "offset" : _set_update_delta_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @update_delta.setter
    def update_delta(self, updateDelta:float) -> None:
        return self._intf.set_property(IProjectionStream._metadata, IProjectionStream._set_update_delta_metadata, updateDelta)

    _update_metadata = { "offset" : _update_method_offset,
            "arg_types" : (agcom.PVOID, agcom.PVOID, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.InterfaceInArg("IDate"), agmarshall.InterfaceInArg("IDate"), agmarshall.VariantBoolArg,) }
    def update(self, time:"IDate", nextTime:"IDate") -> bool:
        """When overridden in a derived class, updates the projection data associated with the projection stream at the specified time. When the Update method is called, the projection stream contains the current projection data..."""
        return self._intf.invoke(IProjectionStream._metadata, IProjectionStream._update_metadata, time, nextTime, OutArg())

    _property_names[update_delta] = "update_delta"


agcls.AgClassCatalog.add_catalog_entry((5166404080678366159, 7416564084710466476), IProjectionStream)
agcls.AgTypeNameMap["IProjectionStream"] = IProjectionStream

class ISceneGlobeOverlaySettings(object):
    """Settings used by globe overlay objects. These settings only affect the scene."""

    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_anti_alias_imagery_method_offset = 1
    _set_anti_alias_imagery_method_offset = 2
    _get_terrain_mesh_pixel_error_method_offset = 3
    _set_terrain_mesh_pixel_error_method_offset = 4
    _get_imagery_pixel_error_method_offset = 5
    _set_imagery_pixel_error_method_offset = 6
    _get_projected_raster_model_projection_method_offset = 7
    _set_projected_raster_model_projection_method_offset = 8
    _metadata = {
        "iid_data" : (5574400525919150531, 8204789827079609220),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ISceneGlobeOverlaySettings."""
        initialize_from_source_object(self, sourceObject, ISceneGlobeOverlaySettings)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISceneGlobeOverlaySettings)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ISceneGlobeOverlaySettings, None)
    
    _get_anti_alias_imagery_metadata = { "offset" : _get_anti_alias_imagery_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def anti_alias_imagery(self) -> bool:
        """Get or set a value indicating whether or not imagery is anti-aliased."""
        return self._intf.get_property(ISceneGlobeOverlaySettings._metadata, ISceneGlobeOverlaySettings._get_anti_alias_imagery_metadata)

    _set_anti_alias_imagery_metadata = { "offset" : _set_anti_alias_imagery_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @anti_alias_imagery.setter
    def anti_alias_imagery(self, antiAliasImagery:bool) -> None:
        return self._intf.set_property(ISceneGlobeOverlaySettings._metadata, ISceneGlobeOverlaySettings._set_anti_alias_imagery_metadata, antiAliasImagery)

    _get_terrain_mesh_pixel_error_metadata = { "offset" : _get_terrain_mesh_pixel_error_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def terrain_mesh_pixel_error(self) -> float:
        """Get or set the pixel error for terrain meshes. This is the number of pixels that the rendered terrain is different from the actual terrain data. The default is 2.0 pixels."""
        return self._intf.get_property(ISceneGlobeOverlaySettings._metadata, ISceneGlobeOverlaySettings._get_terrain_mesh_pixel_error_metadata)

    _set_terrain_mesh_pixel_error_metadata = { "offset" : _set_terrain_mesh_pixel_error_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @terrain_mesh_pixel_error.setter
    def terrain_mesh_pixel_error(self, terrainMeshPixelError:float) -> None:
        return self._intf.set_property(ISceneGlobeOverlaySettings._metadata, ISceneGlobeOverlaySettings._set_terrain_mesh_pixel_error_metadata, terrainMeshPixelError)

    _get_imagery_pixel_error_metadata = { "offset" : _get_imagery_pixel_error_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def imagery_pixel_error(self) -> float:
        """Get or set the pixel error for imagery. This is the number of pixels that the rendered imagery is different from the actual imagery data. The default is 1.0 pixel."""
        return self._intf.get_property(ISceneGlobeOverlaySettings._metadata, ISceneGlobeOverlaySettings._get_imagery_pixel_error_metadata)

    _set_imagery_pixel_error_metadata = { "offset" : _set_imagery_pixel_error_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @imagery_pixel_error.setter
    def imagery_pixel_error(self, imageryPixelError:float) -> None:
        return self._intf.set_property(ISceneGlobeOverlaySettings._metadata, ISceneGlobeOverlaySettings._set_imagery_pixel_error_metadata, imageryPixelError)

    _get_projected_raster_model_projection_metadata = { "offset" : _get_projected_raster_model_projection_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def projected_raster_model_projection(self) -> bool:
        """Get or set whether projected raster globe overlays will also project onto models."""
        return self._intf.get_property(ISceneGlobeOverlaySettings._metadata, ISceneGlobeOverlaySettings._get_projected_raster_model_projection_metadata)

    _set_projected_raster_model_projection_metadata = { "offset" : _set_projected_raster_model_projection_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @projected_raster_model_projection.setter
    def projected_raster_model_projection(self, projectedRasterModelProjection:bool) -> None:
        return self._intf.set_property(ISceneGlobeOverlaySettings._metadata, ISceneGlobeOverlaySettings._set_projected_raster_model_projection_metadata, projectedRasterModelProjection)

    _property_names[anti_alias_imagery] = "anti_alias_imagery"
    _property_names[terrain_mesh_pixel_error] = "terrain_mesh_pixel_error"
    _property_names[imagery_pixel_error] = "imagery_pixel_error"
    _property_names[projected_raster_model_projection] = "projected_raster_model_projection"


agcls.AgClassCatalog.add_catalog_entry((5574400525919150531, 8204789827079609220), ISceneGlobeOverlaySettings)
agcls.AgTypeNameMap["ISceneGlobeOverlaySettings"] = ISceneGlobeOverlaySettings

class IScreenOverlayCollectionBase(object):
    """The common base class for collections of overlays held by screen overlay and by screen overlay manager."""

    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_count_method_offset = 1
    _get_is_read_only_method_offset = 2
    _item_method_offset = 3
    _get__NewEnum_method_offset = 4
    _contains_method_offset = 5
    _remove_method_offset = 6
    _clear_method_offset = 7
    _add_method_offset = 8
    _metadata = {
        "iid_data" : (5748013200866698085, 10184546868944523949),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IScreenOverlayCollectionBase."""
        initialize_from_source_object(self, sourceObject, IScreenOverlayCollectionBase)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IScreenOverlayCollectionBase)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IScreenOverlayCollectionBase, None)
    def __iter__(self):
        """Create an iterator for the IScreenOverlayCollectionBase object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IScreenOverlay":
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def count(self) -> int:
        """Get the number of screen overlays in the collection."""
        return self._intf.get_property(IScreenOverlayCollectionBase._metadata, IScreenOverlayCollectionBase._get_count_metadata)

    _get_is_read_only_metadata = { "offset" : _get_is_read_only_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_read_only(self) -> bool:
        """Get a value indicating whether the collection is read-only."""
        return self._intf.get_property(IScreenOverlayCollectionBase._metadata, IScreenOverlayCollectionBase._get_is_read_only_metadata)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def item(self, index:int) -> "IScreenOverlay":
        """Get the overlay at the specified index."""
        return self._intf.invoke(IScreenOverlayCollectionBase._metadata, IScreenOverlayCollectionBase._item_metadata, index, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        """Return an enumerator that iterates through the collection."""
        return self._intf.get_property(IScreenOverlayCollectionBase._metadata, IScreenOverlayCollectionBase._get__NewEnum_metadata)

    _contains_metadata = { "offset" : _contains_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.InterfaceInArg("IScreenOverlay"), agmarshall.VariantBoolArg,) }
    def contains(self, item:"IScreenOverlay") -> bool:
        """Determine whether the collection contains a specific overlay."""
        return self._intf.invoke(IScreenOverlayCollectionBase._metadata, IScreenOverlayCollectionBase._contains_metadata, item, OutArg())

    _remove_metadata = { "offset" : _remove_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.InterfaceInArg("IScreenOverlay"), agmarshall.VariantBoolArg,) }
    def remove(self, item:"IScreenOverlay") -> bool:
        """Remove the first occurrence of a specific overlay from the collection."""
        return self._intf.invoke(IScreenOverlayCollectionBase._metadata, IScreenOverlayCollectionBase._remove_metadata, item, OutArg())

    _clear_metadata = { "offset" : _clear_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def clear(self) -> None:
        """Remove all overlays from the collection."""
        return self._intf.invoke(IScreenOverlayCollectionBase._metadata, IScreenOverlayCollectionBase._clear_metadata, )

    _add_metadata = { "offset" : _add_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IScreenOverlay"),) }
    def add(self, item:"IScreenOverlay") -> None:
        """Add an overlay to the collection."""
        return self._intf.invoke(IScreenOverlayCollectionBase._metadata, IScreenOverlayCollectionBase._add_metadata, item)

    __getitem__ = item


    _property_names[count] = "count"
    _property_names[is_read_only] = "is_read_only"
    _property_names[_NewEnum] = "_NewEnum"


agcls.AgClassCatalog.add_catalog_entry((5748013200866698085, 10184546868944523949), IScreenOverlayCollectionBase)
agcls.AgTypeNameMap["IScreenOverlayCollectionBase"] = IScreenOverlayCollectionBase

class ITexture2DFactory(object):
    """A factory for creating texture 2d objects from various sources."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _load_from_string_uri_method_offset = 1
    _from_raster_method_offset = 2
    _metadata = {
        "iid_data" : (4925222235676858792, 13269238914304119718),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ITexture2DFactory."""
        initialize_from_source_object(self, sourceObject, ITexture2DFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITexture2DFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ITexture2DFactory, None)
    
    _load_from_string_uri_metadata = { "offset" : _load_from_string_uri_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def load_from_string_uri(self, uri:str) -> "RendererTexture2D":
        """Create a new texture from a Uri, which can be a file, HTTP, HTTPS, or FTP source. See raster for a list of supported raster formats."""
        return self._intf.invoke(ITexture2DFactory._metadata, ITexture2DFactory._load_from_string_uri_metadata, uri, OutArg())

    _from_raster_metadata = { "offset" : _from_raster_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("IRaster"), agmarshall.InterfaceOutArg,) }
    def from_raster(self, raster:"IRaster") -> "RendererTexture2D":
        """Create a new texture from a raster."""
        return self._intf.invoke(ITexture2DFactory._metadata, ITexture2DFactory._from_raster_metadata, raster, OutArg())


agcls.AgClassCatalog.add_catalog_entry((4925222235676858792, 13269238914304119718), ITexture2DFactory)
agcls.AgTypeNameMap["ITexture2DFactory"] = ITexture2DFactory

class IVisualEffects(object):
    """Control various post processing effects that can be applied to the scene."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_lens_flare_enabled_method_offset = 1
    _set_lens_flare_enabled_method_offset = 2
    _get_vignette_enabled_method_offset = 3
    _set_vignette_enabled_method_offset = 4
    _get_vignette_strength_method_offset = 5
    _set_vignette_strength_method_offset = 6
    _metadata = {
        "iid_data" : (5261215102135709933, 16937211111774516119),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IVisualEffects."""
        initialize_from_source_object(self, sourceObject, IVisualEffects)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVisualEffects)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IVisualEffects, None)
    
    _get_lens_flare_enabled_metadata = { "offset" : _get_lens_flare_enabled_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def lens_flare_enabled(self) -> bool:
        """Get or set whether or not the lens flare effect is enabled."""
        return self._intf.get_property(IVisualEffects._metadata, IVisualEffects._get_lens_flare_enabled_metadata)

    _set_lens_flare_enabled_metadata = { "offset" : _set_lens_flare_enabled_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @lens_flare_enabled.setter
    def lens_flare_enabled(self, lensFlareEnabled:bool) -> None:
        return self._intf.set_property(IVisualEffects._metadata, IVisualEffects._set_lens_flare_enabled_metadata, lensFlareEnabled)

    _get_vignette_enabled_metadata = { "offset" : _get_vignette_enabled_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def vignette_enabled(self) -> bool:
        """Get or set whether or not the vignette effect is enabled. This simulates light being blocked by the lens hood, resulting in a slight darkening at the perimeter of the 3D Window."""
        return self._intf.get_property(IVisualEffects._metadata, IVisualEffects._get_vignette_enabled_metadata)

    _set_vignette_enabled_metadata = { "offset" : _set_vignette_enabled_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @vignette_enabled.setter
    def vignette_enabled(self, vignetteEnabled:bool) -> None:
        return self._intf.set_property(IVisualEffects._metadata, IVisualEffects._set_vignette_enabled_metadata, vignetteEnabled)

    _get_vignette_strength_metadata = { "offset" : _get_vignette_strength_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def vignette_strength(self) -> float:
        """Set the strength of the vignette effect, values between [0.001 and 5.0], with larger values resulting in more pronounced darkening around the perimeter of the 3D window."""
        return self._intf.get_property(IVisualEffects._metadata, IVisualEffects._get_vignette_strength_metadata)

    _set_vignette_strength_metadata = { "offset" : _set_vignette_strength_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @vignette_strength.setter
    def vignette_strength(self, vignetteStrength:float) -> None:
        return self._intf.set_property(IVisualEffects._metadata, IVisualEffects._set_vignette_strength_metadata, vignetteStrength)

    _property_names[lens_flare_enabled] = "lens_flare_enabled"
    _property_names[vignette_enabled] = "vignette_enabled"
    _property_names[vignette_strength] = "vignette_strength"


agcls.AgClassCatalog.add_catalog_entry((5261215102135709933, 16937211111774516119), IVisualEffects)
agcls.AgTypeNameMap["IVisualEffects"] = IVisualEffects

class IAltitudeDisplayCondition(object):
    """Define an inclusive altitude interval that determines when an object is rendered based on the camera's altitude relative to a central body."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_minimum_altitude_method_offset = 1
    _set_minimum_altitude_method_offset = 2
    _get_maximum_altitude_method_offset = 3
    _set_maximum_altitude_method_offset = 4
    _get_central_body_method_offset = 5
    _set_central_body_method_offset = 6
    _metadata = {
        "iid_data" : (5393166715270093478, 17984733492443543221),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IAltitudeDisplayCondition."""
        initialize_from_source_object(self, sourceObject, IAltitudeDisplayCondition)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAltitudeDisplayCondition)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IAltitudeDisplayCondition, None)
    
    _get_minimum_altitude_metadata = { "offset" : _get_minimum_altitude_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def minimum_altitude(self) -> float:
        """Get or set the minimum altitude of the inclusive altitude interval. Use Double.MinValue to ignore checking the minimum altitude."""
        return self._intf.get_property(IAltitudeDisplayCondition._metadata, IAltitudeDisplayCondition._get_minimum_altitude_metadata)

    _set_minimum_altitude_metadata = { "offset" : _set_minimum_altitude_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @minimum_altitude.setter
    def minimum_altitude(self, minimumAltitude:float) -> None:
        return self._intf.set_property(IAltitudeDisplayCondition._metadata, IAltitudeDisplayCondition._set_minimum_altitude_metadata, minimumAltitude)

    _get_maximum_altitude_metadata = { "offset" : _get_maximum_altitude_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def maximum_altitude(self) -> float:
        """Get or set the maximum altitude of the inclusive altitude interval. Use Double.MaxValue to ignore checking the maximum altitude."""
        return self._intf.get_property(IAltitudeDisplayCondition._metadata, IAltitudeDisplayCondition._get_maximum_altitude_metadata)

    _set_maximum_altitude_metadata = { "offset" : _set_maximum_altitude_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @maximum_altitude.setter
    def maximum_altitude(self, maximumAltitude:float) -> None:
        return self._intf.set_property(IAltitudeDisplayCondition._metadata, IAltitudeDisplayCondition._set_maximum_altitude_metadata, maximumAltitude)

    _get_central_body_metadata = { "offset" : _get_central_body_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def central_body(self) -> str:
        """Get or set the central body to which the altitude is relative."""
        return self._intf.get_property(IAltitudeDisplayCondition._metadata, IAltitudeDisplayCondition._get_central_body_metadata)

    _set_central_body_metadata = { "offset" : _set_central_body_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @central_body.setter
    def central_body(self, centralBody:str) -> None:
        return self._intf.set_property(IAltitudeDisplayCondition._metadata, IAltitudeDisplayCondition._set_central_body_metadata, centralBody)

    _property_names[minimum_altitude] = "minimum_altitude"
    _property_names[maximum_altitude] = "maximum_altitude"
    _property_names[central_body] = "central_body"


agcls.AgClassCatalog.add_catalog_entry((5393166715270093478, 17984733492443543221), IAltitudeDisplayCondition)
agcls.AgTypeNameMap["IAltitudeDisplayCondition"] = IAltitudeDisplayCondition

class IAxesPrimitive(object):
    """Render an axes in the 3D scene."""

    _num_methods = 22
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_lighting_method_offset = 1
    _set_lighting_method_offset = 2
    _get_label_method_offset = 3
    _set_label_method_offset = 4
    _get_display_label_method_offset = 5
    _set_display_label_method_offset = 6
    _get_display_trace_method_offset = 7
    _set_display_trace_method_offset = 8
    _get_display_sweep_method_offset = 9
    _set_display_sweep_method_offset = 10
    _get_display_lines_method_offset = 11
    _set_display_lines_method_offset = 12
    _get_persistence_width_method_offset = 13
    _set_persistence_width_method_offset = 14
    _get_fade_persistence_method_offset = 15
    _set_fade_persistence_method_offset = 16
    _get_persistence_duration_method_offset = 17
    _set_persistence_duration_method_offset = 18
    _get_length_method_offset = 19
    _set_length_method_offset = 20
    _get_width_method_offset = 21
    _set_width_method_offset = 22
    _metadata = {
        "iid_data" : (5071979667285801873, 4985509215786764179),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IAxesPrimitive."""
        initialize_from_source_object(self, sourceObject, IAxesPrimitive)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAxesPrimitive)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IAxesPrimitive, None)
    
    _get_lighting_metadata = { "offset" : _get_lighting_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def lighting(self) -> bool:
        """Get or set whether the primitive is lit."""
        return self._intf.get_property(IAxesPrimitive._metadata, IAxesPrimitive._get_lighting_metadata)

    _set_lighting_metadata = { "offset" : _set_lighting_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @lighting.setter
    def lighting(self, lighting:bool) -> None:
        return self._intf.set_property(IAxesPrimitive._metadata, IAxesPrimitive._set_lighting_metadata, lighting)

    _get_label_metadata = { "offset" : _get_label_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def label(self) -> str:
        """Get or set the axes label."""
        return self._intf.get_property(IAxesPrimitive._metadata, IAxesPrimitive._get_label_metadata)

    _set_label_metadata = { "offset" : _set_label_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @label.setter
    def label(self, label:str) -> None:
        return self._intf.set_property(IAxesPrimitive._metadata, IAxesPrimitive._set_label_metadata, label)

    _get_display_label_metadata = { "offset" : _get_display_label_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def display_label(self) -> bool:
        """Get or set whether the axes' label is displayed."""
        return self._intf.get_property(IAxesPrimitive._metadata, IAxesPrimitive._get_display_label_metadata)

    _set_display_label_metadata = { "offset" : _set_display_label_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @display_label.setter
    def display_label(self, displayLabel:bool) -> None:
        return self._intf.set_property(IAxesPrimitive._metadata, IAxesPrimitive._set_display_label_metadata, displayLabel)

    _get_display_trace_metadata = { "offset" : _get_display_trace_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def display_trace(self) -> bool:
        """Get or set whether the persistence trace (points) is displayed."""
        return self._intf.get_property(IAxesPrimitive._metadata, IAxesPrimitive._get_display_trace_metadata)

    _set_display_trace_metadata = { "offset" : _set_display_trace_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @display_trace.setter
    def display_trace(self, displayTrace:bool) -> None:
        return self._intf.set_property(IAxesPrimitive._metadata, IAxesPrimitive._set_display_trace_metadata, displayTrace)

    _get_display_sweep_metadata = { "offset" : _get_display_sweep_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def display_sweep(self) -> bool:
        """Get or set whether the persistence sweep (triangles) is displayed."""
        return self._intf.get_property(IAxesPrimitive._metadata, IAxesPrimitive._get_display_sweep_metadata)

    _set_display_sweep_metadata = { "offset" : _set_display_sweep_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @display_sweep.setter
    def display_sweep(self, displaySweep:bool) -> None:
        return self._intf.set_property(IAxesPrimitive._metadata, IAxesPrimitive._set_display_sweep_metadata, displaySweep)

    _get_display_lines_metadata = { "offset" : _get_display_lines_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def display_lines(self) -> bool:
        """Get or set whether persistence lines are displayed."""
        return self._intf.get_property(IAxesPrimitive._metadata, IAxesPrimitive._get_display_lines_metadata)

    _set_display_lines_metadata = { "offset" : _set_display_lines_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @display_lines.setter
    def display_lines(self, displayLines:bool) -> None:
        return self._intf.set_property(IAxesPrimitive._metadata, IAxesPrimitive._set_display_lines_metadata, displayLines)

    _get_persistence_width_metadata = { "offset" : _get_persistence_width_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def persistence_width(self) -> float:
        """Get or set persistence point/line width."""
        return self._intf.get_property(IAxesPrimitive._metadata, IAxesPrimitive._get_persistence_width_metadata)

    _set_persistence_width_metadata = { "offset" : _set_persistence_width_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @persistence_width.setter
    def persistence_width(self, persistenceWidth:float) -> None:
        return self._intf.set_property(IAxesPrimitive._metadata, IAxesPrimitive._set_persistence_width_metadata, persistenceWidth)

    _get_fade_persistence_metadata = { "offset" : _get_fade_persistence_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def fade_persistence(self) -> bool:
        """Get or set whether the persistence path should fade over time."""
        return self._intf.get_property(IAxesPrimitive._metadata, IAxesPrimitive._get_fade_persistence_metadata)

    _set_fade_persistence_metadata = { "offset" : _set_fade_persistence_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @fade_persistence.setter
    def fade_persistence(self, fadePersistence:bool) -> None:
        return self._intf.set_property(IAxesPrimitive._metadata, IAxesPrimitive._set_fade_persistence_metadata, fadePersistence)

    _get_persistence_duration_metadata = { "offset" : _get_persistence_duration_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def persistence_duration(self) -> float:
        """Get or set the maximum duration of the persistence path."""
        return self._intf.get_property(IAxesPrimitive._metadata, IAxesPrimitive._get_persistence_duration_metadata)

    _set_persistence_duration_metadata = { "offset" : _set_persistence_duration_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @persistence_duration.setter
    def persistence_duration(self, persistenceDuration:float) -> None:
        return self._intf.set_property(IAxesPrimitive._metadata, IAxesPrimitive._set_persistence_duration_metadata, persistenceDuration)

    _get_length_metadata = { "offset" : _get_length_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def length(self) -> float:
        """Get or set the axes' source-to-arrow-tip length."""
        return self._intf.get_property(IAxesPrimitive._metadata, IAxesPrimitive._get_length_metadata)

    _set_length_metadata = { "offset" : _set_length_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @length.setter
    def length(self, length:float) -> None:
        return self._intf.set_property(IAxesPrimitive._metadata, IAxesPrimitive._set_length_metadata, length)

    _get_width_metadata = { "offset" : _get_width_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def width(self) -> float:
        """Get or set the width in pixels. As the camera distances changes from this primitive, the geometry will autoscale to maintain this thickness."""
        return self._intf.get_property(IAxesPrimitive._metadata, IAxesPrimitive._get_width_metadata)

    _set_width_metadata = { "offset" : _set_width_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @width.setter
    def width(self, width:float) -> None:
        return self._intf.set_property(IAxesPrimitive._metadata, IAxesPrimitive._set_width_metadata, width)

    _property_names[lighting] = "lighting"
    _property_names[label] = "label"
    _property_names[display_label] = "display_label"
    _property_names[display_trace] = "display_trace"
    _property_names[display_sweep] = "display_sweep"
    _property_names[display_lines] = "display_lines"
    _property_names[persistence_width] = "persistence_width"
    _property_names[fade_persistence] = "fade_persistence"
    _property_names[persistence_duration] = "persistence_duration"
    _property_names[length] = "length"
    _property_names[width] = "width"


agcls.AgClassCatalog.add_catalog_entry((5071979667285801873, 4985509215786764179), IAxesPrimitive)
agcls.AgTypeNameMap["IAxesPrimitive"] = IAxesPrimitive

class ICamera(object):
    """Implemented by the scene camera. Contains operations to manipulate the camera position, view direction and orientation in the scene."""

    _num_methods = 50
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_position_method_offset = 1
    _set_position_method_offset = 2
    _get_reference_point_method_offset = 3
    _set_reference_point_method_offset = 4
    _get_direction_method_offset = 5
    _set_direction_method_offset = 6
    _get_up_vector_method_offset = 7
    _set_up_vector_method_offset = 8
    _get_distance_method_offset = 9
    _set_distance_method_offset = 10
    _get_axes_method_offset = 11
    _set_axes_method_offset = 12
    _get_constrained_up_axis_method_offset = 13
    _set_constrained_up_axis_method_offset = 14
    _get_allow_rotation_over_constrained_up_axis_method_offset = 15
    _set_allow_rotation_over_constrained_up_axis_method_offset = 16
    _get_lock_view_direction_method_offset = 17
    _set_lock_view_direction_method_offset = 18
    _get_field_of_view_method_offset = 19
    _set_field_of_view_method_offset = 20
    _get_horizontal_field_of_view_method_offset = 21
    _get_vertical_field_of_view_method_offset = 22
    _get_near_plane_method_offset = 23
    _set_near_plane_method_offset = 24
    _get_far_plane_method_offset = 25
    _set_far_plane_method_offset = 26
    _get_far_near_plane_ratio_method_offset = 27
    _set_far_near_plane_ratio_method_offset = 28
    _get_distance_per_radius_method_offset = 29
    _get_snapshot_method_offset = 30
    _get_video_recording_method_offset = 31
    _get_pixel_size_per_distance_method_offset = 32
    _get_position_reference_frame_method_offset = 33
    _get_reference_point_reference_frame_method_offset = 34
    _visibility_test_method_offset = 35
    _cartographic_to_window_method_offset = 36
    _try_cartographic_to_window_method_offset = 37
    _window_to_cartographic_method_offset = 38
    _try_window_to_cartographic_method_offset = 39
    _view_central_body_method_offset = 40
    _view_extent_method_offset = 41
    _view_rectangular_extent_method_offset = 42
    _view_with_up_axis_method_offset = 43
    _view_method_offset = 44
    _view_direction_with_up_axis_method_offset = 45
    _view_direction_method_offset = 46
    _view_offset_with_up_axis_method_offset = 47
    _view_offset_method_offset = 48
    _view_offset_direction_with_up_axis_method_offset = 49
    _view_offset_direction_method_offset = 50
    _metadata = {
        "iid_data" : (5415728535553925060, 1568220948406149766),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ICamera."""
        initialize_from_source_object(self, sourceObject, ICamera)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICamera)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ICamera, None)
    
    _get_position_metadata = { "offset" : _get_position_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def position(self) -> list:
        """Get or set the position of the camera. The array contains the components of the position arranged in the order x, y, z."""
        return self._intf.get_property(ICamera._metadata, ICamera._get_position_metadata)

    _set_position_metadata = { "offset" : _set_position_method_offset,
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @position.setter
    def position(self, position:list) -> None:
        return self._intf.set_property(ICamera._metadata, ICamera._set_position_metadata, position)

    _get_reference_point_metadata = { "offset" : _get_reference_point_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def reference_point(self) -> list:
        """Get or set the reference point of the camera. The array contains the components of the reference point arranged in the order x, y, z."""
        return self._intf.get_property(ICamera._metadata, ICamera._get_reference_point_metadata)

    _set_reference_point_metadata = { "offset" : _set_reference_point_method_offset,
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @reference_point.setter
    def reference_point(self, referencePoint:list) -> None:
        return self._intf.set_property(ICamera._metadata, ICamera._set_reference_point_metadata, referencePoint)

    _get_direction_metadata = { "offset" : _get_direction_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def direction(self) -> list:
        """Get or set the direction of the camera in axes. The array contains the components of the direction arranged in the order x, y, z."""
        return self._intf.get_property(ICamera._metadata, ICamera._get_direction_metadata)

    _set_direction_metadata = { "offset" : _set_direction_method_offset,
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @direction.setter
    def direction(self, direction:list) -> None:
        return self._intf.set_property(ICamera._metadata, ICamera._set_direction_metadata, direction)

    _get_up_vector_metadata = { "offset" : _get_up_vector_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def up_vector(self) -> list:
        """Get or set the up direction of the camera in axes. The array contains the components of the direction arranged in the order x, y, z."""
        return self._intf.get_property(ICamera._metadata, ICamera._get_up_vector_metadata)

    _set_up_vector_metadata = { "offset" : _set_up_vector_method_offset,
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @up_vector.setter
    def up_vector(self, upVector:list) -> None:
        return self._intf.set_property(ICamera._metadata, ICamera._set_up_vector_metadata, upVector)

    _get_distance_metadata = { "offset" : _get_distance_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def distance(self) -> float:
        """Get or set the distance the camera position is from the reference point."""
        return self._intf.get_property(ICamera._metadata, ICamera._get_distance_metadata)

    _set_distance_metadata = { "offset" : _set_distance_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @distance.setter
    def distance(self, distance:float) -> None:
        return self._intf.set_property(ICamera._metadata, ICamera._set_distance_metadata, distance)

    _get_axes_metadata = { "offset" : _get_axes_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def axes(self) -> "IVectorGeometryToolAxes":
        """Get or set camera's axes of rotation."""
        return self._intf.get_property(ICamera._metadata, ICamera._get_axes_metadata)

    _set_axes_metadata = { "offset" : _set_axes_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolAxes"),) }
    @axes.setter
    def axes(self, axes:"IVectorGeometryToolAxes") -> None:
        return self._intf.set_property(ICamera._metadata, ICamera._set_axes_metadata, axes)

    _get_constrained_up_axis_metadata = { "offset" : _get_constrained_up_axis_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CONSTRAINED_UP_AXIS),) }
    @property
    def constrained_up_axis(self) -> "CONSTRAINED_UP_AXIS":
        """Get or set the axis to constrain the up vector to."""
        return self._intf.get_property(ICamera._metadata, ICamera._get_constrained_up_axis_metadata)

    _set_constrained_up_axis_metadata = { "offset" : _set_constrained_up_axis_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CONSTRAINED_UP_AXIS),) }
    @constrained_up_axis.setter
    def constrained_up_axis(self, constrainedUpAxis:"CONSTRAINED_UP_AXIS") -> None:
        return self._intf.set_property(ICamera._metadata, ICamera._set_constrained_up_axis_metadata, constrainedUpAxis)

    _get_allow_rotation_over_constrained_up_axis_metadata = { "offset" : _get_allow_rotation_over_constrained_up_axis_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def allow_rotation_over_constrained_up_axis(self) -> bool:
        """Get or set whether the camera can rotate over the constrained up axis. For example, if true the camera would be able to flip over the North Pole and view the globe upside down."""
        return self._intf.get_property(ICamera._metadata, ICamera._get_allow_rotation_over_constrained_up_axis_metadata)

    _set_allow_rotation_over_constrained_up_axis_metadata = { "offset" : _set_allow_rotation_over_constrained_up_axis_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @allow_rotation_over_constrained_up_axis.setter
    def allow_rotation_over_constrained_up_axis(self, allowRotationOverConstrainedUpAxis:bool) -> None:
        return self._intf.set_property(ICamera._metadata, ICamera._set_allow_rotation_over_constrained_up_axis_metadata, allowRotationOverConstrainedUpAxis)

    _get_lock_view_direction_metadata = { "offset" : _get_lock_view_direction_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def lock_view_direction(self) -> bool:
        """Get or set whether the camera's direction is locked."""
        return self._intf.get_property(ICamera._metadata, ICamera._get_lock_view_direction_metadata)

    _set_lock_view_direction_metadata = { "offset" : _set_lock_view_direction_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @lock_view_direction.setter
    def lock_view_direction(self, lockViewDirection:bool) -> None:
        return self._intf.set_property(ICamera._metadata, ICamera._set_lock_view_direction_metadata, lockViewDirection)

    _get_field_of_view_metadata = { "offset" : _get_field_of_view_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def field_of_view(self) -> float:
        """Get or set field of view. The field of view is applied to the larger of the window dimensions. For example, if the window width was 640 and the height was 480, the field of view applies to the horizontal..."""
        return self._intf.get_property(ICamera._metadata, ICamera._get_field_of_view_metadata)

    _set_field_of_view_metadata = { "offset" : _set_field_of_view_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @field_of_view.setter
    def field_of_view(self, fieldOfView:float) -> None:
        return self._intf.set_property(ICamera._metadata, ICamera._set_field_of_view_metadata, fieldOfView)

    _get_horizontal_field_of_view_metadata = { "offset" : _get_horizontal_field_of_view_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def horizontal_field_of_view(self) -> float:
        """Get the horizontal field of view."""
        return self._intf.get_property(ICamera._metadata, ICamera._get_horizontal_field_of_view_metadata)

    _get_vertical_field_of_view_metadata = { "offset" : _get_vertical_field_of_view_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def vertical_field_of_view(self) -> float:
        """Get the vertical field of view."""
        return self._intf.get_property(ICamera._metadata, ICamera._get_vertical_field_of_view_metadata)

    _get_near_plane_metadata = { "offset" : _get_near_plane_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def near_plane(self) -> float:
        """Get or set the distance from the camera to the near plane."""
        return self._intf.get_property(ICamera._metadata, ICamera._get_near_plane_metadata)

    _set_near_plane_metadata = { "offset" : _set_near_plane_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @near_plane.setter
    def near_plane(self, nearPlane:float) -> None:
        return self._intf.set_property(ICamera._metadata, ICamera._set_near_plane_metadata, nearPlane)

    _get_far_plane_metadata = { "offset" : _get_far_plane_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def far_plane(self) -> float:
        """Get or set the distance from the camera to the far plane."""
        return self._intf.get_property(ICamera._metadata, ICamera._get_far_plane_metadata)

    _set_far_plane_metadata = { "offset" : _set_far_plane_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @far_plane.setter
    def far_plane(self, farPlane:float) -> None:
        return self._intf.set_property(ICamera._metadata, ICamera._set_far_plane_metadata, farPlane)

    _get_far_near_plane_ratio_metadata = { "offset" : _get_far_near_plane_ratio_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def far_near_plane_ratio(self) -> float:
        """Get or set the value that is used to compute subdivisions of the viewing frustum. A large value will be faster but lose z-value precision. A small value will have better precision but perform slower..."""
        return self._intf.get_property(ICamera._metadata, ICamera._get_far_near_plane_ratio_metadata)

    _set_far_near_plane_ratio_metadata = { "offset" : _set_far_near_plane_ratio_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @far_near_plane_ratio.setter
    def far_near_plane_ratio(self, farNearPlaneRatio:float) -> None:
        return self._intf.set_property(ICamera._metadata, ICamera._set_far_near_plane_ratio_metadata, farNearPlaneRatio)

    _get_distance_per_radius_metadata = { "offset" : _get_distance_per_radius_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def distance_per_radius(self) -> float:
        """Return the distance that the Camera's Position should be from the ReferencePoint in order to ensure that a sphere with a 1 meter radius centered at the ReferencePoint fits entirely in the view frustum."""
        return self._intf.get_property(ICamera._metadata, ICamera._get_distance_per_radius_metadata)

    _get_snapshot_metadata = { "offset" : _get_snapshot_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def snapshot(self) -> "CameraSnapshot":
        """Get the camera snapshot settings."""
        return self._intf.get_property(ICamera._metadata, ICamera._get_snapshot_metadata)

    _get_video_recording_metadata = { "offset" : _get_video_recording_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def video_recording(self) -> "CameraVideoRecording":
        """Get the camera video recorder."""
        return self._intf.get_property(ICamera._metadata, ICamera._get_video_recording_metadata)

    _get_pixel_size_per_distance_metadata = { "offset" : _get_pixel_size_per_distance_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def pixel_size_per_distance(self) -> float:
        """Get the approximate number of meters covered by a pixel that is 1 meter away from the camera. This is commonly multiplied by the distance from the camera to an object to compute the approximate number of meters covered by a pixel of the object."""
        return self._intf.get_property(ICamera._metadata, ICamera._get_pixel_size_per_distance_metadata)

    _get_position_reference_frame_metadata = { "offset" : _get_position_reference_frame_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def position_reference_frame(self) -> "IVectorGeometryToolSystem":
        """Get the reference frame that the position is returned in. This reference frame is composed of the camera's from point and the axes."""
        return self._intf.get_property(ICamera._metadata, ICamera._get_position_reference_frame_metadata)

    _get_reference_point_reference_frame_metadata = { "offset" : _get_reference_point_reference_frame_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_point_reference_frame(self) -> "IVectorGeometryToolSystem":
        """Get the reference frame that the reference point is returned in. This reference frame is composed of the camera's to point and the axes."""
        return self._intf.get_property(ICamera._metadata, ICamera._get_reference_point_reference_frame_metadata)

    _visibility_test_metadata = { "offset" : _visibility_test_method_offset,
            "arg_types" : (agcom.PVOID, agcom.PVOID, POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolSystem"), agmarshall.InterfaceInArg("IBoundingSphere"), agmarshall.EnumArg(VISIBILITY),) }
    def visibility_test(self, referenceFrame:"IVectorGeometryToolSystem", sphere:"IBoundingSphere") -> "VISIBILITY":
        """Get the visibility of a sphere against the view frustum and any occluding central bodies."""
        return self._intf.invoke(ICamera._metadata, ICamera._visibility_test_metadata, referenceFrame, sphere, OutArg())

    _cartographic_to_window_metadata = { "offset" : _cartographic_to_window_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg,) }
    def cartographic_to_window(self, centralBody:str, position:list) -> list:
        """Convert a cartographic position to a pixel coordinate relative to the globe control. This method can throw an exception. Returns an array containing the pixel coordinate (in the order x, y) of the cartographic position relative to the globe control..."""
        return self._intf.invoke(ICamera._metadata, ICamera._cartographic_to_window_metadata, centralBody, position, OutArg())

    _try_cartographic_to_window_metadata = { "offset" : _try_cartographic_to_window_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg,) }
    def try_cartographic_to_window(self, centralBody:str, position:list) -> list:
        """Convert a cartographic position to a pixel coordinate relative to the globe control. This method does not throw an exception."""
        return self._intf.invoke(ICamera._metadata, ICamera._try_cartographic_to_window_metadata, centralBody, position, OutArg())

    _window_to_cartographic_metadata = { "offset" : _window_to_cartographic_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg,) }
    def window_to_cartographic(self, centralBody:str, position:list) -> list:
        """Convert a pixel coordinate relative to the globe control to a cartographic position. For speed, terrain is not considered; if the pixel coordinate does not intersect the ellipsoid, an exception is thrown. Returns the cartographic position..."""
        return self._intf.invoke(ICamera._metadata, ICamera._window_to_cartographic_metadata, centralBody, position, OutArg())

    _try_window_to_cartographic_metadata = { "offset" : _try_window_to_cartographic_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg,) }
    def try_window_to_cartographic(self, centralBody:str, position:list) -> list:
        """Convert a pixel coordinate relative to the globe control to a cartographic position. For speed, terrain is not considered. This method does not throw an exception."""
        return self._intf.invoke(ICamera._metadata, ICamera._try_window_to_cartographic_metadata, centralBody, position, OutArg())

    _view_central_body_metadata = { "offset" : _view_central_body_method_offset,
            "arg_types" : (agcom.BSTR, agcom.PVOID,),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceInArg("IVectorGeometryToolAxes"),) }
    def view_central_body(self, centralBody:str, axes:"IVectorGeometryToolAxes") -> None:
        """Zoom to a central body and use the specified axes for rotation. The reference point is set to the center of the central body and the camera's position is set so the entire central body is visible."""
        return self._intf.invoke(ICamera._metadata, ICamera._view_central_body_metadata, centralBody, axes)

    _view_extent_metadata = { "offset" : _view_extent_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg,) }
    def view_extent(self, centralBody:str, extent:list) -> None:
        """Zooms to a cartographic extent on the centralBody. The camera will be looking straight down at the extent, with the up vector pointing toward local north. The axes is set to an east-north-up axes at the center of extent."""
        return self._intf.invoke(ICamera._metadata, ICamera._view_extent_metadata, centralBody, extent)

    _view_rectangular_extent_metadata = { "offset" : _view_rectangular_extent_method_offset,
            "arg_types" : (agcom.BSTR, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE,),
            "marshallers" : (agmarshall.BStrArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.DoubleArg,) }
    def view_rectangular_extent(self, centralBody:str, west:float, south:float, east:float, north:float) -> None:
        """Zooms to a rectangular extent composed of west, south, east, north on the centralBody. The camera will be looking straight down at the extent, with the up vector pointing toward local north..."""
        return self._intf.invoke(ICamera._metadata, ICamera._view_rectangular_extent_metadata, centralBody, west, south, east, north)

    _view_with_up_axis_metadata = { "offset" : _view_with_up_axis_method_offset,
            "arg_types" : (agcom.PVOID, agcom.PVOID, agcom.PVOID, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolAxes"), agmarshall.InterfaceInArg("IVectorGeometryToolPoint"), agmarshall.InterfaceInArg("IVectorGeometryToolPoint"), agmarshall.LPSafearrayArg,) }
    def view_with_up_axis(self, axes:"IVectorGeometryToolAxes", cameraPosition:"IVectorGeometryToolPoint", referencePoint:"IVectorGeometryToolPoint", upAxis:list) -> None:
        """View from a point to a point. Sets the camera's position and the reference point the camera is looking at."""
        return self._intf.invoke(ICamera._metadata, ICamera._view_with_up_axis_metadata, axes, cameraPosition, referencePoint, upAxis)

    _view_metadata = { "offset" : _view_method_offset,
            "arg_types" : (agcom.PVOID, agcom.PVOID, agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolAxes"), agmarshall.InterfaceInArg("IVectorGeometryToolPoint"), agmarshall.InterfaceInArg("IVectorGeometryToolPoint"),) }
    def view(self, axes:"IVectorGeometryToolAxes", cameraPosition:"IVectorGeometryToolPoint", referencePoint:"IVectorGeometryToolPoint") -> None:
        """View from a point to a point. Sets the camera's position and the reference point the camera is looking at."""
        return self._intf.invoke(ICamera._metadata, ICamera._view_metadata, axes, cameraPosition, referencePoint)

    _view_direction_with_up_axis_metadata = { "offset" : _view_direction_with_up_axis_method_offset,
            "arg_types" : (agcom.PVOID, agcom.PVOID, agcom.PVOID, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolAxes"), agmarshall.InterfaceInArg("IVectorGeometryToolPoint"), agmarshall.InterfaceInArg("IVectorGeometryToolVector"), agmarshall.LPSafearrayArg,) }
    def view_direction_with_up_axis(self, axes:"IVectorGeometryToolAxes", cameraPosition:"IVectorGeometryToolPoint", direction:"IVectorGeometryToolVector", upAxis:list) -> None:
        """View from a point to a direction. Sets the camera's position and the direction vector indicating where the camera is looking."""
        return self._intf.invoke(ICamera._metadata, ICamera._view_direction_with_up_axis_metadata, axes, cameraPosition, direction, upAxis)

    _view_direction_metadata = { "offset" : _view_direction_method_offset,
            "arg_types" : (agcom.PVOID, agcom.PVOID, agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolAxes"), agmarshall.InterfaceInArg("IVectorGeometryToolPoint"), agmarshall.InterfaceInArg("IVectorGeometryToolVector"),) }
    def view_direction(self, axes:"IVectorGeometryToolAxes", cameraPosition:"IVectorGeometryToolPoint", direction:"IVectorGeometryToolVector") -> None:
        """View from a point to a direction. Sets the camera's position and the direction vector indicating where the camera is looking."""
        return self._intf.invoke(ICamera._metadata, ICamera._view_direction_metadata, axes, cameraPosition, direction)

    _view_offset_with_up_axis_metadata = { "offset" : _view_offset_with_up_axis_method_offset,
            "arg_types" : (agcom.PVOID, agcom.PVOID, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolAxes"), agmarshall.InterfaceInArg("IVectorGeometryToolPoint"), agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg,) }
    def view_offset_with_up_axis(self, axes:"IVectorGeometryToolAxes", referencePoint:"IVectorGeometryToolPoint", offset:list, upAxis:list) -> None:
        """Set the camera's reference point - the point the camera is looking at. The camera's position is the reference point translated by the offset."""
        return self._intf.invoke(ICamera._metadata, ICamera._view_offset_with_up_axis_metadata, axes, referencePoint, offset, upAxis)

    _view_offset_metadata = { "offset" : _view_offset_method_offset,
            "arg_types" : (agcom.PVOID, agcom.PVOID, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolAxes"), agmarshall.InterfaceInArg("IVectorGeometryToolPoint"), agmarshall.LPSafearrayArg,) }
    def view_offset(self, axes:"IVectorGeometryToolAxes", referencePoint:"IVectorGeometryToolPoint", offset:list) -> None:
        """Set the camera's reference point - the point the camera is looking at. The camera's position is the reference point translated by the offset."""
        return self._intf.invoke(ICamera._metadata, ICamera._view_offset_metadata, axes, referencePoint, offset)

    _view_offset_direction_with_up_axis_metadata = { "offset" : _view_offset_direction_with_up_axis_method_offset,
            "arg_types" : (agcom.PVOID, agcom.PVOID, agcom.PVOID, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolAxes"), agmarshall.InterfaceInArg("IVectorGeometryToolPoint"), agmarshall.InterfaceInArg("IVectorGeometryToolVector"), agmarshall.LPSafearrayArg,) }
    def view_offset_direction_with_up_axis(self, axes:"IVectorGeometryToolAxes", referencePoint:"IVectorGeometryToolPoint", direction:"IVectorGeometryToolVector", upAxis:list) -> None:
        """Set the camera's reference point - the point the camera is looking at. The camera's position is the reference point translated by the direction vector."""
        return self._intf.invoke(ICamera._metadata, ICamera._view_offset_direction_with_up_axis_metadata, axes, referencePoint, direction, upAxis)

    _view_offset_direction_metadata = { "offset" : _view_offset_direction_method_offset,
            "arg_types" : (agcom.PVOID, agcom.PVOID, agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolAxes"), agmarshall.InterfaceInArg("IVectorGeometryToolPoint"), agmarshall.InterfaceInArg("IVectorGeometryToolVector"),) }
    def view_offset_direction(self, axes:"IVectorGeometryToolAxes", referencePoint:"IVectorGeometryToolPoint", direction:"IVectorGeometryToolVector") -> None:
        """Set the camera's reference point - the point the camera is looking at. The camera's position is the reference point translated by the direction vector."""
        return self._intf.invoke(ICamera._metadata, ICamera._view_offset_direction_metadata, axes, referencePoint, direction)

    _property_names[position] = "position"
    _property_names[reference_point] = "reference_point"
    _property_names[direction] = "direction"
    _property_names[up_vector] = "up_vector"
    _property_names[distance] = "distance"
    _property_names[axes] = "axes"
    _property_names[constrained_up_axis] = "constrained_up_axis"
    _property_names[allow_rotation_over_constrained_up_axis] = "allow_rotation_over_constrained_up_axis"
    _property_names[lock_view_direction] = "lock_view_direction"
    _property_names[field_of_view] = "field_of_view"
    _property_names[horizontal_field_of_view] = "horizontal_field_of_view"
    _property_names[vertical_field_of_view] = "vertical_field_of_view"
    _property_names[near_plane] = "near_plane"
    _property_names[far_plane] = "far_plane"
    _property_names[far_near_plane_ratio] = "far_near_plane_ratio"
    _property_names[distance_per_radius] = "distance_per_radius"
    _property_names[snapshot] = "snapshot"
    _property_names[video_recording] = "video_recording"
    _property_names[pixel_size_per_distance] = "pixel_size_per_distance"
    _property_names[position_reference_frame] = "position_reference_frame"
    _property_names[reference_point_reference_frame] = "reference_point_reference_frame"


agcls.AgClassCatalog.add_catalog_entry((5415728535553925060, 1568220948406149766), ICamera)
agcls.AgTypeNameMap["ICamera"] = ICamera

class ICentralBodyGraphics(object):
    """The graphical properties associated with a particular central body. Changing the central body graphics will affect how the associated central body is rendered in a scene. For instance, to show or hide the central body, use the show property..."""

    _num_methods = 23
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_color_method_offset = 1
    _set_color_method_offset = 2
    _get_specular_color_method_offset = 3
    _set_specular_color_method_offset = 4
    _get_shininess_method_offset = 5
    _set_shininess_method_offset = 6
    _get_show_imagery_method_offset = 7
    _set_show_imagery_method_offset = 8
    _get_show_method_offset = 9
    _set_show_method_offset = 10
    _get_show_label_method_offset = 11
    _set_show_label_method_offset = 12
    _get_altitude_offset_method_offset = 13
    _set_altitude_offset_method_offset = 14
    _get_base_overlay_method_offset = 15
    _set_base_overlay_method_offset = 16
    _get_night_overlay_method_offset = 17
    _set_night_overlay_method_offset = 18
    _get_specular_overlay_method_offset = 19
    _set_specular_overlay_method_offset = 20
    _get_terrain_method_offset = 21
    _get_imagery_method_offset = 22
    _get_kml_method_offset = 23
    _metadata = {
        "iid_data" : (5748663363856356139, 14609936288003111080),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ICentralBodyGraphics."""
        initialize_from_source_object(self, sourceObject, ICentralBodyGraphics)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICentralBodyGraphics)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ICentralBodyGraphics, None)
    
    _get_color_metadata = { "offset" : _get_color_method_offset,
            "arg_types" : (POINTER(agcom.OLE_COLOR),),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @property
    def color(self) -> agcolor.Color:
        """Get or set the color of the central body in the scene."""
        return self._intf.get_property(ICentralBodyGraphics._metadata, ICentralBodyGraphics._get_color_metadata)

    _set_color_metadata = { "offset" : _set_color_method_offset,
            "arg_types" : (agcom.OLE_COLOR,),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @color.setter
    def color(self, color:agcolor.Color) -> None:
        return self._intf.set_property(ICentralBodyGraphics._metadata, ICentralBodyGraphics._set_color_metadata, color)

    _get_specular_color_metadata = { "offset" : _get_specular_color_method_offset,
            "arg_types" : (POINTER(agcom.OLE_COLOR),),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @property
    def specular_color(self) -> agcolor.Color:
        """Get or set the specular color of the central body in the scene. The specular color is associated with the specular overlay."""
        return self._intf.get_property(ICentralBodyGraphics._metadata, ICentralBodyGraphics._get_specular_color_metadata)

    _set_specular_color_metadata = { "offset" : _set_specular_color_method_offset,
            "arg_types" : (agcom.OLE_COLOR,),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @specular_color.setter
    def specular_color(self, specularColor:agcolor.Color) -> None:
        return self._intf.set_property(ICentralBodyGraphics._metadata, ICentralBodyGraphics._set_specular_color_metadata, specularColor)

    _get_shininess_metadata = { "offset" : _get_shininess_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def shininess(self) -> float:
        """Get or set the shininess of the central body in the scene. The shininess affects the size and brightness of specular reflection associated with the specular overlay."""
        return self._intf.get_property(ICentralBodyGraphics._metadata, ICentralBodyGraphics._get_shininess_metadata)

    _set_shininess_metadata = { "offset" : _set_shininess_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @shininess.setter
    def shininess(self, shininess:float) -> None:
        return self._intf.set_property(ICentralBodyGraphics._metadata, ICentralBodyGraphics._set_shininess_metadata, shininess)

    _get_show_imagery_metadata = { "offset" : _get_show_imagery_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def show_imagery(self) -> bool:
        """Get or set whether the imagery for central body in the scene is shown or hidden."""
        return self._intf.get_property(ICentralBodyGraphics._metadata, ICentralBodyGraphics._get_show_imagery_metadata)

    _set_show_imagery_metadata = { "offset" : _set_show_imagery_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @show_imagery.setter
    def show_imagery(self, showImagery:bool) -> None:
        return self._intf.set_property(ICentralBodyGraphics._metadata, ICentralBodyGraphics._set_show_imagery_metadata, showImagery)

    _get_show_metadata = { "offset" : _get_show_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def show(self) -> bool:
        """Get or set whether the central body is shown or hidden in the scene. This only affects the central body itself, not the primitives that are associated with it."""
        return self._intf.get_property(ICentralBodyGraphics._metadata, ICentralBodyGraphics._get_show_metadata)

    _set_show_metadata = { "offset" : _set_show_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @show.setter
    def show(self, show:bool) -> None:
        return self._intf.set_property(ICentralBodyGraphics._metadata, ICentralBodyGraphics._set_show_metadata, show)

    _get_show_label_metadata = { "offset" : _get_show_label_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def show_label(self) -> bool:
        """Get or set whether a label with the name of the central body should be rendered in the scene when the camera is at certain distance away from the central body."""
        return self._intf.get_property(ICentralBodyGraphics._metadata, ICentralBodyGraphics._get_show_label_metadata)

    _set_show_label_metadata = { "offset" : _set_show_label_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @show_label.setter
    def show_label(self, showLabel:bool) -> None:
        return self._intf.set_property(ICentralBodyGraphics._metadata, ICentralBodyGraphics._set_show_label_metadata, showLabel)

    _get_altitude_offset_metadata = { "offset" : _get_altitude_offset_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def altitude_offset(self) -> float:
        """Get or set the altitude that all terrain and imagery will be offset from the surface of the central body in the scene."""
        return self._intf.get_property(ICentralBodyGraphics._metadata, ICentralBodyGraphics._get_altitude_offset_metadata)

    _set_altitude_offset_metadata = { "offset" : _set_altitude_offset_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @altitude_offset.setter
    def altitude_offset(self, altitudeOffset:float) -> None:
        return self._intf.set_property(ICentralBodyGraphics._metadata, ICentralBodyGraphics._set_altitude_offset_metadata, altitudeOffset)

    _get_base_overlay_metadata = { "offset" : _get_base_overlay_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def base_overlay(self) -> "IGlobeImageOverlay":
        """Get or set the base globe image overlay associated with the central body in the scene. The base overlay is always rendered before any other imagery..."""
        return self._intf.get_property(ICentralBodyGraphics._metadata, ICentralBodyGraphics._get_base_overlay_metadata)

    _set_base_overlay_metadata = { "offset" : _set_base_overlay_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IGlobeImageOverlay"),) }
    @base_overlay.setter
    def base_overlay(self, baseOverlay:"IGlobeImageOverlay") -> None:
        return self._intf.set_property(ICentralBodyGraphics._metadata, ICentralBodyGraphics._set_base_overlay_metadata, baseOverlay)

    _get_night_overlay_metadata = { "offset" : _get_night_overlay_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def night_overlay(self) -> "IGlobeImageOverlay":
        """Get or set the night globe image overlay associated with the central body in the scene. The night overlay is displayed only on parts of the central body that are not in sun light..."""
        return self._intf.get_property(ICentralBodyGraphics._metadata, ICentralBodyGraphics._get_night_overlay_metadata)

    _set_night_overlay_metadata = { "offset" : _set_night_overlay_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IGlobeImageOverlay"),) }
    @night_overlay.setter
    def night_overlay(self, nightOverlay:"IGlobeImageOverlay") -> None:
        return self._intf.set_property(ICentralBodyGraphics._metadata, ICentralBodyGraphics._set_night_overlay_metadata, nightOverlay)

    _get_specular_overlay_metadata = { "offset" : _get_specular_overlay_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def specular_overlay(self) -> "IGlobeImageOverlay":
        """Get or set the specular globe image overlay associated with the central body in the scene. The specular overlay is displayed only in the specular highlight of the central body."""
        return self._intf.get_property(ICentralBodyGraphics._metadata, ICentralBodyGraphics._get_specular_overlay_metadata)

    _set_specular_overlay_metadata = { "offset" : _set_specular_overlay_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IGlobeImageOverlay"),) }
    @specular_overlay.setter
    def specular_overlay(self, specularOverlay:"IGlobeImageOverlay") -> None:
        return self._intf.set_property(ICentralBodyGraphics._metadata, ICentralBodyGraphics._set_specular_overlay_metadata, specularOverlay)

    _get_terrain_metadata = { "offset" : _get_terrain_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def terrain(self) -> "TerrainOverlayCollection":
        """Get the collection of terrain overlay associated with the central body in the scene."""
        return self._intf.get_property(ICentralBodyGraphics._metadata, ICentralBodyGraphics._get_terrain_metadata)

    _get_imagery_metadata = { "offset" : _get_imagery_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def imagery(self) -> "ImageCollection":
        """Get the collection of imagery associated with the central body in the scene."""
        return self._intf.get_property(ICentralBodyGraphics._metadata, ICentralBodyGraphics._get_imagery_metadata)

    _get_kml_metadata = { "offset" : _get_kml_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def kml(self) -> "KmlGraphics":
        """Get the kml graphics associated with the central body in the scene."""
        return self._intf.get_property(ICentralBodyGraphics._metadata, ICentralBodyGraphics._get_kml_metadata)

    _property_names[color] = "color"
    _property_names[specular_color] = "specular_color"
    _property_names[shininess] = "shininess"
    _property_names[show_imagery] = "show_imagery"
    _property_names[show] = "show"
    _property_names[show_label] = "show_label"
    _property_names[altitude_offset] = "altitude_offset"
    _property_names[base_overlay] = "base_overlay"
    _property_names[night_overlay] = "night_overlay"
    _property_names[specular_overlay] = "specular_overlay"
    _property_names[terrain] = "terrain"
    _property_names[imagery] = "imagery"
    _property_names[kml] = "kml"


agcls.AgClassCatalog.add_catalog_entry((5748663363856356139, 14609936288003111080), ICentralBodyGraphics)
agcls.AgTypeNameMap["ICentralBodyGraphics"] = ICentralBodyGraphics

class IClouds(object):
    """Load, show and hide clouds in the scene."""

    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_show_method_offset = 1
    _set_show_method_offset = 2
    _get_clouds_uri_method_offset = 3
    _set_clouds_uri_method_offset = 4
    _get_roundness_method_offset = 5
    _set_roundness_method_offset = 6
    _get_altitude_method_offset = 7
    _set_altitude_method_offset = 8
    _get_is_valid_method_offset = 9
    _metadata = {
        "iid_data" : (4902781266871608760, 14063544887351084699),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IClouds."""
        initialize_from_source_object(self, sourceObject, IClouds)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IClouds)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IClouds, None)
    
    _get_show_metadata = { "offset" : _get_show_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def show(self) -> bool:
        """Get or set whether clouds are rendered."""
        return self._intf.get_property(IClouds._metadata, IClouds._get_show_metadata)

    _set_show_metadata = { "offset" : _set_show_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @show.setter
    def show(self, show:bool) -> None:
        return self._intf.set_property(IClouds._metadata, IClouds._set_show_metadata, show)

    _get_clouds_uri_metadata = { "offset" : _get_clouds_uri_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def clouds_uri(self) -> str:
        """The URI of the clouds index file. A cloud index file is an ascii file that contains a time-ordered list of images that display over the globe."""
        return self._intf.get_property(IClouds._metadata, IClouds._get_clouds_uri_metadata)

    _set_clouds_uri_metadata = { "offset" : _set_clouds_uri_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @clouds_uri.setter
    def clouds_uri(self, cloudsUri:str) -> None:
        return self._intf.set_property(IClouds._metadata, IClouds._set_clouds_uri_metadata, cloudsUri)

    _get_roundness_metadata = { "offset" : _get_roundness_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def roundness(self) -> float:
        """The roundness of the clouds."""
        return self._intf.get_property(IClouds._metadata, IClouds._get_roundness_metadata)

    _set_roundness_metadata = { "offset" : _set_roundness_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @roundness.setter
    def roundness(self, roundness:float) -> None:
        return self._intf.set_property(IClouds._metadata, IClouds._set_roundness_metadata, roundness)

    _get_altitude_metadata = { "offset" : _get_altitude_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def altitude(self) -> float:
        """The altitude of the clouds."""
        return self._intf.get_property(IClouds._metadata, IClouds._get_altitude_metadata)

    _set_altitude_metadata = { "offset" : _set_altitude_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @altitude.setter
    def altitude(self, altitude:float) -> None:
        return self._intf.set_property(IClouds._metadata, IClouds._set_altitude_metadata, altitude)

    _get_is_valid_metadata = { "offset" : _get_is_valid_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_valid(self) -> bool:
        """Return whether or not the clouds file is valid."""
        return self._intf.get_property(IClouds._metadata, IClouds._get_is_valid_metadata)

    _property_names[show] = "show"
    _property_names[clouds_uri] = "clouds_uri"
    _property_names[roundness] = "roundness"
    _property_names[altitude] = "altitude"
    _property_names[is_valid] = "is_valid"


agcls.AgClassCatalog.add_catalog_entry((4902781266871608760, 14063544887351084699), IClouds)
agcls.AgTypeNameMap["IClouds"] = IClouds

class ICompositeDisplayCondition(object):
    """A composite of display conditions combined using a binary logic operation. For example, several time interval display condition objects can be added to a composite..."""

    _num_methods = 18
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_count_method_offset = 1
    _get_capacity_method_offset = 2
    _get_logic_operation_method_offset = 3
    _set_logic_operation_method_offset = 4
    _item_method_offset = 5
    _get__NewEnum_method_offset = 6
    _reserve_method_offset = 7
    _add_with_negate_method_offset = 8
    _add_method_offset = 9
    _insert_with_negate_method_offset = 10
    _insert_method_offset = 11
    _remove_method_offset = 12
    _remove_at_method_offset = 13
    _clear_method_offset = 14
    _get_negate_method_offset = 15
    _set_negate_method_offset = 16
    _get_negate_at_method_offset = 17
    _set_negate_at_method_offset = 18
    _metadata = {
        "iid_data" : (5092744095359624815, 12221078393069903744),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ICompositeDisplayCondition."""
        initialize_from_source_object(self, sourceObject, ICompositeDisplayCondition)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICompositeDisplayCondition)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ICompositeDisplayCondition, None)
    def __iter__(self):
        """Create an iterator for the ICompositeDisplayCondition object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IDisplayCondition":
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def count(self) -> int:
        """Get the number of display conditions in the composite."""
        return self._intf.get_property(ICompositeDisplayCondition._metadata, ICompositeDisplayCondition._get_count_metadata)

    _get_capacity_metadata = { "offset" : _get_capacity_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def capacity(self) -> int:
        """Get the number of display conditions for which memory has been allocated. This will always be greater or equal to count."""
        return self._intf.get_property(ICompositeDisplayCondition._metadata, ICompositeDisplayCondition._get_capacity_metadata)

    _get_logic_operation_metadata = { "offset" : _get_logic_operation_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(BINARY_LOGIC_OPERATION),) }
    @property
    def logic_operation(self) -> "BINARY_LOGIC_OPERATION":
        """Get or set the binary logic operation applied to all display conditions in the composite when the composite is evaluated. To combine logical and and or operations in the same expression, create composites containing composites."""
        return self._intf.get_property(ICompositeDisplayCondition._metadata, ICompositeDisplayCondition._get_logic_operation_metadata)

    _set_logic_operation_metadata = { "offset" : _set_logic_operation_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(BINARY_LOGIC_OPERATION),) }
    @logic_operation.setter
    def logic_operation(self, logicOperation:"BINARY_LOGIC_OPERATION") -> None:
        return self._intf.set_property(ICompositeDisplayCondition._metadata, ICompositeDisplayCondition._set_logic_operation_metadata, logicOperation)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def item(self, index:int) -> "IDisplayCondition":
        """Return the condition at the given zero-based index."""
        return self._intf.invoke(ICompositeDisplayCondition._metadata, ICompositeDisplayCondition._item_metadata, index, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        """Return an enumerator that iterates through the collection."""
        return self._intf.get_property(ICompositeDisplayCondition._metadata, ICompositeDisplayCondition._get__NewEnum_metadata)

    _reserve_metadata = { "offset" : _reserve_method_offset,
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.IntArg,) }
    def reserve(self, count:int) -> None:
        """Request enough memory for the composite to contain at least count display conditions. count will not be affected but capacity may be."""
        return self._intf.invoke(ICompositeDisplayCondition._metadata, ICompositeDisplayCondition._reserve_metadata, count)

    _add_with_negate_metadata = { "offset" : _add_with_negate_method_offset,
            "arg_types" : (agcom.PVOID, agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.InterfaceInArg("IDisplayCondition"), agmarshall.VariantBoolArg,) }
    def add_with_negate(self, displayCondition:"IDisplayCondition", negate:bool) -> None:
        """Add a display condition to the end of the composite."""
        return self._intf.invoke(ICompositeDisplayCondition._metadata, ICompositeDisplayCondition._add_with_negate_metadata, displayCondition, negate)

    _add_metadata = { "offset" : _add_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IDisplayCondition"),) }
    def add(self, displayCondition:"IDisplayCondition") -> None:
        """Add a display condition to the end of the composite."""
        return self._intf.invoke(ICompositeDisplayCondition._metadata, ICompositeDisplayCondition._add_metadata, displayCondition)

    _insert_with_negate_metadata = { "offset" : _insert_with_negate_method_offset,
            "arg_types" : (agcom.INT, agcom.PVOID, agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.IntArg, agmarshall.InterfaceInArg("IDisplayCondition"), agmarshall.VariantBoolArg,) }
    def insert_with_negate(self, index:int, displayCondition:"IDisplayCondition", negate:bool) -> None:
        """Insert a display condition at the given zero-based index, shifting existing display conditions."""
        return self._intf.invoke(ICompositeDisplayCondition._metadata, ICompositeDisplayCondition._insert_with_negate_metadata, index, displayCondition, negate)

    _insert_metadata = { "offset" : _insert_method_offset,
            "arg_types" : (agcom.INT, agcom.PVOID,),
            "marshallers" : (agmarshall.IntArg, agmarshall.InterfaceInArg("IDisplayCondition"),) }
    def insert(self, index:int, displayCondition:"IDisplayCondition") -> None:
        """Insert a display condition at the given zero-based index, shifting existing display conditions."""
        return self._intf.invoke(ICompositeDisplayCondition._metadata, ICompositeDisplayCondition._insert_metadata, index, displayCondition)

    _remove_metadata = { "offset" : _remove_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IDisplayCondition"),) }
    def remove(self, displayCondition:"IDisplayCondition") -> None:
        """Remove a display condition from the composite."""
        return self._intf.invoke(ICompositeDisplayCondition._metadata, ICompositeDisplayCondition._remove_metadata, displayCondition)

    _remove_at_metadata = { "offset" : _remove_at_method_offset,
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.IntArg,) }
    def remove_at(self, index:int) -> None:
        """Remove the display condition at the given zero-based index, shifting existing display conditions."""
        return self._intf.invoke(ICompositeDisplayCondition._metadata, ICompositeDisplayCondition._remove_at_metadata, index)

    _clear_metadata = { "offset" : _clear_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def clear(self) -> None:
        """Remove all display conditions from the composite."""
        return self._intf.invoke(ICompositeDisplayCondition._metadata, ICompositeDisplayCondition._clear_metadata, )

    _get_negate_metadata = { "offset" : _get_negate_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.InterfaceInArg("IDisplayCondition"), agmarshall.VariantBoolArg,) }
    def get_negate(self, displayCondition:"IDisplayCondition") -> bool:
        """Determine if a logical not operation is applied to a display condition in the composite."""
        return self._intf.invoke(ICompositeDisplayCondition._metadata, ICompositeDisplayCondition._get_negate_metadata, displayCondition, OutArg())

    _set_negate_metadata = { "offset" : _set_negate_method_offset,
            "arg_types" : (agcom.PVOID, agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.InterfaceInArg("IDisplayCondition"), agmarshall.VariantBoolArg,) }
    def set_negate(self, displayCondition:"IDisplayCondition", negate:bool) -> None:
        """Set if a logical not operation is applied to a display condition in the composite when the composite is evaluated."""
        return self._intf.invoke(ICompositeDisplayCondition._metadata, ICompositeDisplayCondition._set_negate_metadata, displayCondition, negate)

    _get_negate_at_metadata = { "offset" : _get_negate_at_method_offset,
            "arg_types" : (agcom.INT, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.IntArg, agmarshall.VariantBoolArg,) }
    def get_negate_at(self, index:int) -> bool:
        """Determine if a logical not operation is applied to a display condition in the composite."""
        return self._intf.invoke(ICompositeDisplayCondition._metadata, ICompositeDisplayCondition._get_negate_at_metadata, index, OutArg())

    _set_negate_at_metadata = { "offset" : _set_negate_at_method_offset,
            "arg_types" : (agcom.INT, agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.IntArg, agmarshall.VariantBoolArg,) }
    def set_negate_at(self, index:int, negate:bool) -> None:
        """Set if a logical not operation is applied to a display condition in the composite when the composite is evaluated."""
        return self._intf.invoke(ICompositeDisplayCondition._metadata, ICompositeDisplayCondition._set_negate_at_metadata, index, negate)

    __getitem__ = item


    _property_names[count] = "count"
    _property_names[capacity] = "capacity"
    _property_names[logic_operation] = "logic_operation"
    _property_names[_NewEnum] = "_NewEnum"


agcls.AgClassCatalog.add_catalog_entry((5092744095359624815, 12221078393069903744), ICompositeDisplayCondition)
agcls.AgTypeNameMap["ICompositeDisplayCondition"] = ICompositeDisplayCondition

class ICompositePrimitive(object):
    """A primitive that is composed of multiple other primitives. Since composites can contain other composites, they are commonly used to build hierarchies of primitives to efficiently evaluate display conditions..."""

    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_count_method_offset = 1
    _get_translucent_primitives_sort_order_method_offset = 2
    _set_translucent_primitives_sort_order_method_offset = 3
    _add_method_offset = 4
    _remove_method_offset = 5
    _contains_method_offset = 6
    _clear_method_offset = 7
    _get__NewEnum_method_offset = 8
    _metadata = {
        "iid_data" : (5261699596467587241, 17508946501537161350),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ICompositePrimitive."""
        initialize_from_source_object(self, sourceObject, ICompositePrimitive)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICompositePrimitive)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ICompositePrimitive, None)
    def __iter__(self):
        """Create an iterator for the ICompositePrimitive object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> typing.Any:
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def count(self) -> int:
        """Get the number of primitives in the composite."""
        return self._intf.get_property(ICompositePrimitive._metadata, ICompositePrimitive._get_count_metadata)

    _get_translucent_primitives_sort_order_metadata = { "offset" : _get_translucent_primitives_sort_order_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(PRIMITIVES_SORT_ORDER),) }
    @property
    def translucent_primitives_sort_order(self) -> "PRIMITIVES_SORT_ORDER":
        """Get or set the sort order for translucent primitives in this composite. This determines a trade-off between rendering speed and quality..."""
        return self._intf.get_property(ICompositePrimitive._metadata, ICompositePrimitive._get_translucent_primitives_sort_order_metadata)

    _set_translucent_primitives_sort_order_metadata = { "offset" : _set_translucent_primitives_sort_order_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(PRIMITIVES_SORT_ORDER),) }
    @translucent_primitives_sort_order.setter
    def translucent_primitives_sort_order(self, translucentPrimitivesSortOrder:"PRIMITIVES_SORT_ORDER") -> None:
        return self._intf.set_property(ICompositePrimitive._metadata, ICompositePrimitive._set_translucent_primitives_sort_order_metadata, translucentPrimitivesSortOrder)

    _add_metadata = { "offset" : _add_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IPrimitive"),) }
    def add(self, primitive:"IPrimitive") -> None:
        """Add a primitive to the composite."""
        return self._intf.invoke(ICompositePrimitive._metadata, ICompositePrimitive._add_metadata, primitive)

    _remove_metadata = { "offset" : _remove_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IPrimitive"),) }
    def remove(self, primitive:"IPrimitive") -> None:
        """Remove a primitive from the composite."""
        return self._intf.invoke(ICompositePrimitive._metadata, ICompositePrimitive._remove_metadata, primitive)

    _contains_metadata = { "offset" : _contains_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.InterfaceInArg("IPrimitive"), agmarshall.VariantBoolArg,) }
    def contains(self, primitive:"IPrimitive") -> bool:
        """Determine whether the composite contains a primitive."""
        return self._intf.invoke(ICompositePrimitive._metadata, ICompositePrimitive._contains_metadata, primitive, OutArg())

    _clear_metadata = { "offset" : _clear_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def clear(self) -> None:
        """Remove all primitives from the composite."""
        return self._intf.invoke(ICompositePrimitive._metadata, ICompositePrimitive._clear_metadata, )

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        """Return an enumerator that iterates through the collection. The order of the primitives is not guaranteed to be the order that the primitives were added."""
        return self._intf.get_property(ICompositePrimitive._metadata, ICompositePrimitive._get__NewEnum_metadata)

    _property_names[count] = "count"
    _property_names[translucent_primitives_sort_order] = "translucent_primitives_sort_order"
    _property_names[_NewEnum] = "_NewEnum"


agcls.AgClassCatalog.add_catalog_entry((5261699596467587241, 17508946501537161350), ICompositePrimitive)
agcls.AgTypeNameMap["ICompositePrimitive"] = ICompositePrimitive

class IConstantDisplayCondition(object):
    """A display condition that evaluates to a user-defined value. This is commonly used to hide primitives by assigning to a primitive a display condition that always returns false."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_display_method_offset = 1
    _set_display_method_offset = 2
    _metadata = {
        "iid_data" : (5053686780535890043, 12360710430291808698),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IConstantDisplayCondition."""
        initialize_from_source_object(self, sourceObject, IConstantDisplayCondition)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IConstantDisplayCondition)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IConstantDisplayCondition, None)
    
    _get_display_metadata = { "offset" : _get_display_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def display(self) -> bool:
        """Get or set the value the display condition evaluates to."""
        return self._intf.get_property(IConstantDisplayCondition._metadata, IConstantDisplayCondition._get_display_metadata)

    _set_display_metadata = { "offset" : _set_display_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @display.setter
    def display(self, display:bool) -> None:
        return self._intf.set_property(IConstantDisplayCondition._metadata, IConstantDisplayCondition._set_display_metadata, display)

    _property_names[display] = "display"


agcls.AgClassCatalog.add_catalog_entry((5053686780535890043, 12360710430291808698), IConstantDisplayCondition)
agcls.AgTypeNameMap["IConstantDisplayCondition"] = IConstantDisplayCondition

class IDisplayCondition(object):
    """When assigned to objects, such as primitives or globe overlays, display conditions are evaluated to determine if the object should be rendered."""

    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "iid_data" : (5532500929025461904, 13284471583527689404),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IDisplayCondition."""
        initialize_from_source_object(self, sourceObject, IDisplayCondition)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IDisplayCondition)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IDisplayCondition, None)
    

agcls.AgClassCatalog.add_catalog_entry((5532500929025461904, 13284471583527689404), IDisplayCondition)
agcls.AgTypeNameMap["IDisplayCondition"] = IDisplayCondition

class IDistanceDisplayCondition(object):
    """Define an inclusive distance interval that determines when an object, such as a primitive, is rendered based on the distance from the camera to the object."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_minimum_distance_method_offset = 1
    _set_minimum_distance_method_offset = 2
    _get_maximum_distance_method_offset = 3
    _set_maximum_distance_method_offset = 4
    _get_minimum_distance_squared_method_offset = 5
    _get_maximum_distance_squared_method_offset = 6
    _metadata = {
        "iid_data" : (5360619169827197708, 10100252593195562917),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IDistanceDisplayCondition."""
        initialize_from_source_object(self, sourceObject, IDistanceDisplayCondition)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IDistanceDisplayCondition)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IDistanceDisplayCondition, None)
    
    _get_minimum_distance_metadata = { "offset" : _get_minimum_distance_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def minimum_distance(self) -> float:
        """Get or set the minimum distance of the inclusive distance interval."""
        return self._intf.get_property(IDistanceDisplayCondition._metadata, IDistanceDisplayCondition._get_minimum_distance_metadata)

    _set_minimum_distance_metadata = { "offset" : _set_minimum_distance_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @minimum_distance.setter
    def minimum_distance(self, minimumDistance:float) -> None:
        return self._intf.set_property(IDistanceDisplayCondition._metadata, IDistanceDisplayCondition._set_minimum_distance_metadata, minimumDistance)

    _get_maximum_distance_metadata = { "offset" : _get_maximum_distance_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def maximum_distance(self) -> float:
        """Get or set the maximum distance of the inclusive distance interval. Use Double.MaxValue to ignore checking the maximum distance."""
        return self._intf.get_property(IDistanceDisplayCondition._metadata, IDistanceDisplayCondition._get_maximum_distance_metadata)

    _set_maximum_distance_metadata = { "offset" : _set_maximum_distance_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @maximum_distance.setter
    def maximum_distance(self, maximumDistance:float) -> None:
        return self._intf.set_property(IDistanceDisplayCondition._metadata, IDistanceDisplayCondition._set_maximum_distance_metadata, maximumDistance)

    _get_minimum_distance_squared_metadata = { "offset" : _get_minimum_distance_squared_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def minimum_distance_squared(self) -> float:
        """Get the squared minimum distance of the inclusive distance interval."""
        return self._intf.get_property(IDistanceDisplayCondition._metadata, IDistanceDisplayCondition._get_minimum_distance_squared_metadata)

    _get_maximum_distance_squared_metadata = { "offset" : _get_maximum_distance_squared_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def maximum_distance_squared(self) -> float:
        """Get the squared maximum distance of the inclusive distance interval."""
        return self._intf.get_property(IDistanceDisplayCondition._metadata, IDistanceDisplayCondition._get_maximum_distance_squared_metadata)

    _property_names[minimum_distance] = "minimum_distance"
    _property_names[maximum_distance] = "maximum_distance"
    _property_names[minimum_distance_squared] = "minimum_distance_squared"
    _property_names[maximum_distance_squared] = "maximum_distance_squared"


agcls.AgClassCatalog.add_catalog_entry((5360619169827197708, 10100252593195562917), IDistanceDisplayCondition)
agcls.AgTypeNameMap["IDistanceDisplayCondition"] = IDistanceDisplayCondition

class IDistanceToGlobeOverlayDisplayCondition(object):
    """Define an inclusive distance interval that determines when an object, such as a primitive, is rendered based on the distance from the camera to the globe overlay..."""

    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_globe_overlay_method_offset = 1
    _set_globe_overlay_method_offset = 2
    _get_minimum_distance_method_offset = 3
    _set_minimum_distance_method_offset = 4
    _get_minimum_distance_squared_method_offset = 5
    _get_maximum_distance_method_offset = 6
    _set_maximum_distance_method_offset = 7
    _get_maximum_distance_squared_method_offset = 8
    _metadata = {
        "iid_data" : (5700430378497147116, 15867981441722401695),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IDistanceToGlobeOverlayDisplayCondition."""
        initialize_from_source_object(self, sourceObject, IDistanceToGlobeOverlayDisplayCondition)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IDistanceToGlobeOverlayDisplayCondition)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IDistanceToGlobeOverlayDisplayCondition, None)
    
    _get_globe_overlay_metadata = { "offset" : _get_globe_overlay_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def globe_overlay(self) -> "IGlobeOverlay":
        """Get or set the globe overlay associated with this instance."""
        return self._intf.get_property(IDistanceToGlobeOverlayDisplayCondition._metadata, IDistanceToGlobeOverlayDisplayCondition._get_globe_overlay_metadata)

    _set_globe_overlay_metadata = { "offset" : _set_globe_overlay_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IGlobeOverlay"),) }
    @globe_overlay.setter
    def globe_overlay(self, globeOverlay:"IGlobeOverlay") -> None:
        return self._intf.set_property(IDistanceToGlobeOverlayDisplayCondition._metadata, IDistanceToGlobeOverlayDisplayCondition._set_globe_overlay_metadata, globeOverlay)

    _get_minimum_distance_metadata = { "offset" : _get_minimum_distance_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def minimum_distance(self) -> float:
        """Get or set the minimum distance of the inclusive distance interval."""
        return self._intf.get_property(IDistanceToGlobeOverlayDisplayCondition._metadata, IDistanceToGlobeOverlayDisplayCondition._get_minimum_distance_metadata)

    _set_minimum_distance_metadata = { "offset" : _set_minimum_distance_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @minimum_distance.setter
    def minimum_distance(self, minimumDistance:float) -> None:
        return self._intf.set_property(IDistanceToGlobeOverlayDisplayCondition._metadata, IDistanceToGlobeOverlayDisplayCondition._set_minimum_distance_metadata, minimumDistance)

    _get_minimum_distance_squared_metadata = { "offset" : _get_minimum_distance_squared_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def minimum_distance_squared(self) -> float:
        """Get the squared minimum distance of the inclusive distance interval."""
        return self._intf.get_property(IDistanceToGlobeOverlayDisplayCondition._metadata, IDistanceToGlobeOverlayDisplayCondition._get_minimum_distance_squared_metadata)

    _get_maximum_distance_metadata = { "offset" : _get_maximum_distance_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def maximum_distance(self) -> float:
        """Get or set the maximum distance of the inclusive distance interval. Use Double.MaxValue to ignore checking the maximum distance."""
        return self._intf.get_property(IDistanceToGlobeOverlayDisplayCondition._metadata, IDistanceToGlobeOverlayDisplayCondition._get_maximum_distance_metadata)

    _set_maximum_distance_metadata = { "offset" : _set_maximum_distance_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @maximum_distance.setter
    def maximum_distance(self, maximumDistance:float) -> None:
        return self._intf.set_property(IDistanceToGlobeOverlayDisplayCondition._metadata, IDistanceToGlobeOverlayDisplayCondition._set_maximum_distance_metadata, maximumDistance)

    _get_maximum_distance_squared_metadata = { "offset" : _get_maximum_distance_squared_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def maximum_distance_squared(self) -> float:
        """Get the squared maximum distance of the inclusive distance interval."""
        return self._intf.get_property(IDistanceToGlobeOverlayDisplayCondition._metadata, IDistanceToGlobeOverlayDisplayCondition._get_maximum_distance_squared_metadata)

    _property_names[globe_overlay] = "globe_overlay"
    _property_names[minimum_distance] = "minimum_distance"
    _property_names[minimum_distance_squared] = "minimum_distance_squared"
    _property_names[maximum_distance] = "maximum_distance"
    _property_names[maximum_distance_squared] = "maximum_distance_squared"


agcls.AgClassCatalog.add_catalog_entry((5700430378497147116, 15867981441722401695), IDistanceToGlobeOverlayDisplayCondition)
agcls.AgTypeNameMap["IDistanceToGlobeOverlayDisplayCondition"] = IDistanceToGlobeOverlayDisplayCondition

class IDistanceToPositionDisplayCondition(object):
    """Define an inclusive distance interval that determines when an object, such as a primitive, is rendered based on the distance from the camera to a position defined in the given reference frame."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_minimum_distance_method_offset = 1
    _set_minimum_distance_method_offset = 2
    _get_minimum_distance_squared_method_offset = 3
    _get_maximum_distance_method_offset = 4
    _set_maximum_distance_method_offset = 5
    _get_maximum_distance_squared_method_offset = 6
    _get_position_method_offset = 7
    _set_position_method_offset = 8
    _get_reference_frame_method_offset = 9
    _set_reference_frame_method_offset = 10
    _metadata = {
        "iid_data" : (5189507309013883764, 15013292416941157531),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IDistanceToPositionDisplayCondition."""
        initialize_from_source_object(self, sourceObject, IDistanceToPositionDisplayCondition)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IDistanceToPositionDisplayCondition)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IDistanceToPositionDisplayCondition, None)
    
    _get_minimum_distance_metadata = { "offset" : _get_minimum_distance_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def minimum_distance(self) -> float:
        """Get or set the minimum distance of the inclusive distance interval."""
        return self._intf.get_property(IDistanceToPositionDisplayCondition._metadata, IDistanceToPositionDisplayCondition._get_minimum_distance_metadata)

    _set_minimum_distance_metadata = { "offset" : _set_minimum_distance_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @minimum_distance.setter
    def minimum_distance(self, minimumDistance:float) -> None:
        return self._intf.set_property(IDistanceToPositionDisplayCondition._metadata, IDistanceToPositionDisplayCondition._set_minimum_distance_metadata, minimumDistance)

    _get_minimum_distance_squared_metadata = { "offset" : _get_minimum_distance_squared_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def minimum_distance_squared(self) -> float:
        """Get the squared minimum distance of the inclusive distance interval."""
        return self._intf.get_property(IDistanceToPositionDisplayCondition._metadata, IDistanceToPositionDisplayCondition._get_minimum_distance_squared_metadata)

    _get_maximum_distance_metadata = { "offset" : _get_maximum_distance_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def maximum_distance(self) -> float:
        """Get or set the maximum distance of the inclusive distance interval. Use Double.MaxValue to ignore checking the maximum distance."""
        return self._intf.get_property(IDistanceToPositionDisplayCondition._metadata, IDistanceToPositionDisplayCondition._get_maximum_distance_metadata)

    _set_maximum_distance_metadata = { "offset" : _set_maximum_distance_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @maximum_distance.setter
    def maximum_distance(self, maximumDistance:float) -> None:
        return self._intf.set_property(IDistanceToPositionDisplayCondition._metadata, IDistanceToPositionDisplayCondition._set_maximum_distance_metadata, maximumDistance)

    _get_maximum_distance_squared_metadata = { "offset" : _get_maximum_distance_squared_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def maximum_distance_squared(self) -> float:
        """Get the squared maximum distance of the inclusive distance interval."""
        return self._intf.get_property(IDistanceToPositionDisplayCondition._metadata, IDistanceToPositionDisplayCondition._get_maximum_distance_squared_metadata)

    _get_position_metadata = { "offset" : _get_position_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def position(self) -> list:
        """Get or set the position used to compute the distance from the camera. The array contains the components of the position arranged in the order x, y, z."""
        return self._intf.get_property(IDistanceToPositionDisplayCondition._metadata, IDistanceToPositionDisplayCondition._get_position_metadata)

    _set_position_metadata = { "offset" : _set_position_method_offset,
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @position.setter
    def position(self, position:list) -> None:
        return self._intf.set_property(IDistanceToPositionDisplayCondition._metadata, IDistanceToPositionDisplayCondition._set_position_metadata, position)

    _get_reference_frame_metadata = { "offset" : _get_reference_frame_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_frame(self) -> "IVectorGeometryToolSystem":
        """Get or set the reference frame that position is defined in."""
        return self._intf.get_property(IDistanceToPositionDisplayCondition._metadata, IDistanceToPositionDisplayCondition._get_reference_frame_metadata)

    _set_reference_frame_metadata = { "offset" : _set_reference_frame_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolSystem"),) }
    @reference_frame.setter
    def reference_frame(self, referenceFrame:"IVectorGeometryToolSystem") -> None:
        return self._intf.set_property(IDistanceToPositionDisplayCondition._metadata, IDistanceToPositionDisplayCondition._set_reference_frame_metadata, referenceFrame)

    _property_names[minimum_distance] = "minimum_distance"
    _property_names[minimum_distance_squared] = "minimum_distance_squared"
    _property_names[maximum_distance] = "maximum_distance"
    _property_names[maximum_distance_squared] = "maximum_distance_squared"
    _property_names[position] = "position"
    _property_names[reference_frame] = "reference_frame"


agcls.AgClassCatalog.add_catalog_entry((5189507309013883764, 15013292416941157531), IDistanceToPositionDisplayCondition)
agcls.AgTypeNameMap["IDistanceToPositionDisplayCondition"] = IDistanceToPositionDisplayCondition

class IDistanceToPrimitiveDisplayCondition(object):
    """Define an inclusive distance interval that determines when an object, such as a screen overlay, is rendered based on the distance from the camera to the primitive..."""

    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_primitive_method_offset = 1
    _set_primitive_method_offset = 2
    _get_minimum_distance_method_offset = 3
    _set_minimum_distance_method_offset = 4
    _get_minimum_distance_squared_method_offset = 5
    _get_maximum_distance_method_offset = 6
    _set_maximum_distance_method_offset = 7
    _get_maximum_distance_squared_method_offset = 8
    _metadata = {
        "iid_data" : (5123944932789609666, 3575937356471366048),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IDistanceToPrimitiveDisplayCondition."""
        initialize_from_source_object(self, sourceObject, IDistanceToPrimitiveDisplayCondition)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IDistanceToPrimitiveDisplayCondition)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IDistanceToPrimitiveDisplayCondition, None)
    
    _get_primitive_metadata = { "offset" : _get_primitive_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def primitive(self) -> "IPrimitive":
        """Get or set the primitive associated with this instance."""
        return self._intf.get_property(IDistanceToPrimitiveDisplayCondition._metadata, IDistanceToPrimitiveDisplayCondition._get_primitive_metadata)

    _set_primitive_metadata = { "offset" : _set_primitive_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IPrimitive"),) }
    @primitive.setter
    def primitive(self, primitive:"IPrimitive") -> None:
        return self._intf.set_property(IDistanceToPrimitiveDisplayCondition._metadata, IDistanceToPrimitiveDisplayCondition._set_primitive_metadata, primitive)

    _get_minimum_distance_metadata = { "offset" : _get_minimum_distance_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def minimum_distance(self) -> float:
        """Get or set the minimum distance of the inclusive distance interval."""
        return self._intf.get_property(IDistanceToPrimitiveDisplayCondition._metadata, IDistanceToPrimitiveDisplayCondition._get_minimum_distance_metadata)

    _set_minimum_distance_metadata = { "offset" : _set_minimum_distance_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @minimum_distance.setter
    def minimum_distance(self, minimumDistance:float) -> None:
        return self._intf.set_property(IDistanceToPrimitiveDisplayCondition._metadata, IDistanceToPrimitiveDisplayCondition._set_minimum_distance_metadata, minimumDistance)

    _get_minimum_distance_squared_metadata = { "offset" : _get_minimum_distance_squared_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def minimum_distance_squared(self) -> float:
        """Get the squared minimum distance of the inclusive distance interval."""
        return self._intf.get_property(IDistanceToPrimitiveDisplayCondition._metadata, IDistanceToPrimitiveDisplayCondition._get_minimum_distance_squared_metadata)

    _get_maximum_distance_metadata = { "offset" : _get_maximum_distance_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def maximum_distance(self) -> float:
        """Get or set the maximum distance of the inclusive distance interval. Use Double.MaxValue to ignore checking the maximum distance."""
        return self._intf.get_property(IDistanceToPrimitiveDisplayCondition._metadata, IDistanceToPrimitiveDisplayCondition._get_maximum_distance_metadata)

    _set_maximum_distance_metadata = { "offset" : _set_maximum_distance_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @maximum_distance.setter
    def maximum_distance(self, maximumDistance:float) -> None:
        return self._intf.set_property(IDistanceToPrimitiveDisplayCondition._metadata, IDistanceToPrimitiveDisplayCondition._set_maximum_distance_metadata, maximumDistance)

    _get_maximum_distance_squared_metadata = { "offset" : _get_maximum_distance_squared_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def maximum_distance_squared(self) -> float:
        """Get the squared maximum distance of the inclusive distance interval."""
        return self._intf.get_property(IDistanceToPrimitiveDisplayCondition._metadata, IDistanceToPrimitiveDisplayCondition._get_maximum_distance_squared_metadata)

    _property_names[primitive] = "primitive"
    _property_names[minimum_distance] = "minimum_distance"
    _property_names[minimum_distance_squared] = "minimum_distance_squared"
    _property_names[maximum_distance] = "maximum_distance"
    _property_names[maximum_distance_squared] = "maximum_distance_squared"


agcls.AgClassCatalog.add_catalog_entry((5123944932789609666, 3575937356471366048), IDistanceToPrimitiveDisplayCondition)
agcls.AgTypeNameMap["IDistanceToPrimitiveDisplayCondition"] = IDistanceToPrimitiveDisplayCondition

class IDurationPathPrimitiveUpdatePolicy(object):
    """path primitive update policy that removes points from remove location after a given duration."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_duration_method_offset = 1
    _set_duration_method_offset = 2
    _get_remove_location_method_offset = 3
    _set_remove_location_method_offset = 4
    _metadata = {
        "iid_data" : (5357790703849294276, 3889378876460683145),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IDurationPathPrimitiveUpdatePolicy."""
        initialize_from_source_object(self, sourceObject, IDurationPathPrimitiveUpdatePolicy)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IDurationPathPrimitiveUpdatePolicy)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IDurationPathPrimitiveUpdatePolicy, None)
    
    _get_duration_metadata = { "offset" : _get_duration_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def duration(self) -> float:
        """Get or set the maximum duration that a point will lie on the line."""
        return self._intf.get_property(IDurationPathPrimitiveUpdatePolicy._metadata, IDurationPathPrimitiveUpdatePolicy._get_duration_metadata)

    _set_duration_metadata = { "offset" : _set_duration_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @duration.setter
    def duration(self, duration:float) -> None:
        return self._intf.set_property(IDurationPathPrimitiveUpdatePolicy._metadata, IDurationPathPrimitiveUpdatePolicy._set_duration_metadata, duration)

    _get_remove_location_metadata = { "offset" : _get_remove_location_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(PATH_PRIMITIVE_REMOVE_LOCATION),) }
    @property
    def remove_location(self) -> "PATH_PRIMITIVE_REMOVE_LOCATION":
        """Get or set where the positions on the path are removed from."""
        return self._intf.get_property(IDurationPathPrimitiveUpdatePolicy._metadata, IDurationPathPrimitiveUpdatePolicy._get_remove_location_metadata)

    _set_remove_location_metadata = { "offset" : _set_remove_location_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(PATH_PRIMITIVE_REMOVE_LOCATION),) }
    @remove_location.setter
    def remove_location(self, removeLocation:"PATH_PRIMITIVE_REMOVE_LOCATION") -> None:
        return self._intf.set_property(IDurationPathPrimitiveUpdatePolicy._metadata, IDurationPathPrimitiveUpdatePolicy._set_remove_location_metadata, removeLocation)

    _property_names[duration] = "duration"
    _property_names[remove_location] = "remove_location"


agcls.AgClassCatalog.add_catalog_entry((5357790703849294276, 3889378876460683145), IDurationPathPrimitiveUpdatePolicy)
agcls.AgTypeNameMap["IDurationPathPrimitiveUpdatePolicy"] = IDurationPathPrimitiveUpdatePolicy

class IFrameRate(object):
    """Keeps track of how many times the scenes are rendered per second."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_frames_per_second_method_offset = 1
    _get_maximum_number_of_frames_method_offset = 2
    _set_maximum_number_of_frames_method_offset = 3
    _reset_method_offset = 4
    _metadata = {
        "iid_data" : (5581082211584446583, 9818657894712909486),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IFrameRate."""
        initialize_from_source_object(self, sourceObject, IFrameRate)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IFrameRate)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IFrameRate, None)
    
    _get_frames_per_second_metadata = { "offset" : _get_frames_per_second_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def frames_per_second(self) -> float:
        """Get the current frame rate in frames per second."""
        return self._intf.get_property(IFrameRate._metadata, IFrameRate._get_frames_per_second_metadata)

    _get_maximum_number_of_frames_metadata = { "offset" : _get_maximum_number_of_frames_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def maximum_number_of_frames(self) -> int:
        """Get or set the maximum number of frames used to determine frame rate. More frames means that the frame rate is averaged over a longer period of time and will fluctuate less than fewer frames would. The minimum value is 2."""
        return self._intf.get_property(IFrameRate._metadata, IFrameRate._get_maximum_number_of_frames_metadata)

    _set_maximum_number_of_frames_metadata = { "offset" : _set_maximum_number_of_frames_method_offset,
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.IntArg,) }
    @maximum_number_of_frames.setter
    def maximum_number_of_frames(self, maximumNumberOfFrames:int) -> None:
        return self._intf.set_property(IFrameRate._metadata, IFrameRate._set_maximum_number_of_frames_metadata, maximumNumberOfFrames)

    _reset_metadata = { "offset" : _reset_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def reset(self) -> None:
        """Reset the frame rate counter back to zero. The frame rate computation begins anew."""
        return self._intf.invoke(IFrameRate._metadata, IFrameRate._reset_metadata, )

    _property_names[frames_per_second] = "frames_per_second"
    _property_names[maximum_number_of_frames] = "maximum_number_of_frames"


agcls.AgClassCatalog.add_catalog_entry((5581082211584446583, 9818657894712909486), IFrameRate)
agcls.AgTypeNameMap["IFrameRate"] = IFrameRate

class IGlobeImageOverlay(object):
    """A globe overlay that shows an image."""

    _num_methods = 13
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_translucency_method_offset = 1
    _set_translucency_method_offset = 2
    _get_use_altitude_based_translucency_method_offset = 3
    _set_use_altitude_based_translucency_method_offset = 4
    _get_altitude_based_translucency_lower_translucency_method_offset = 5
    _set_altitude_based_translucency_lower_translucency_method_offset = 6
    _get_altitude_based_translucency_upper_translucency_method_offset = 7
    _set_altitude_based_translucency_upper_translucency_method_offset = 8
    _get_altitude_based_translucency_lower_altitude_method_offset = 9
    _set_altitude_based_translucency_lower_altitude_method_offset = 10
    _get_altitude_based_translucency_upper_altitude_method_offset = 11
    _set_altitude_based_translucency_upper_altitude_method_offset = 12
    _get_more_than_one_image_globe_overlay_supported_method_offset = 13
    _metadata = {
        "iid_data" : (4736968619611124189, 4590632582554593668),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IGlobeImageOverlay."""
        initialize_from_source_object(self, sourceObject, IGlobeImageOverlay)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IGlobeImageOverlay)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IGlobeImageOverlay, None)
    
    _get_translucency_metadata = { "offset" : _get_translucency_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def translucency(self) -> float:
        """Get or set the translucency value for the image. The translucency is between 0 and 1, where 0 is fully opaque and 1 is invisible."""
        return self._intf.get_property(IGlobeImageOverlay._metadata, IGlobeImageOverlay._get_translucency_metadata)

    _set_translucency_metadata = { "offset" : _set_translucency_method_offset,
            "arg_types" : (agcom.FLOAT,),
            "marshallers" : (agmarshall.FloatArg,) }
    @translucency.setter
    def translucency(self, translucency:float) -> None:
        return self._intf.set_property(IGlobeImageOverlay._metadata, IGlobeImageOverlay._set_translucency_metadata, translucency)

    _get_use_altitude_based_translucency_metadata = { "offset" : _get_use_altitude_based_translucency_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_altitude_based_translucency(self) -> bool:
        """Get or set whether to use altitude to determine the translucency value for the image or not. If <see langword='false' />, the translucency value is used..."""
        return self._intf.get_property(IGlobeImageOverlay._metadata, IGlobeImageOverlay._get_use_altitude_based_translucency_metadata)

    _set_use_altitude_based_translucency_metadata = { "offset" : _set_use_altitude_based_translucency_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_altitude_based_translucency.setter
    def use_altitude_based_translucency(self, useAltitudeBasedTranslucency:bool) -> None:
        return self._intf.set_property(IGlobeImageOverlay._metadata, IGlobeImageOverlay._set_use_altitude_based_translucency_metadata, useAltitudeBasedTranslucency)

    _get_altitude_based_translucency_lower_translucency_metadata = { "offset" : _get_altitude_based_translucency_lower_translucency_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def altitude_based_translucency_lower_translucency(self) -> float:
        """Get or set the lower translucency value for the image when use altitude based translucency is set to <see langword='true' />..."""
        return self._intf.get_property(IGlobeImageOverlay._metadata, IGlobeImageOverlay._get_altitude_based_translucency_lower_translucency_metadata)

    _set_altitude_based_translucency_lower_translucency_metadata = { "offset" : _set_altitude_based_translucency_lower_translucency_method_offset,
            "arg_types" : (agcom.FLOAT,),
            "marshallers" : (agmarshall.FloatArg,) }
    @altitude_based_translucency_lower_translucency.setter
    def altitude_based_translucency_lower_translucency(self, altitudeBasedTranslucencyLowerTranslucency:float) -> None:
        return self._intf.set_property(IGlobeImageOverlay._metadata, IGlobeImageOverlay._set_altitude_based_translucency_lower_translucency_metadata, altitudeBasedTranslucencyLowerTranslucency)

    _get_altitude_based_translucency_upper_translucency_metadata = { "offset" : _get_altitude_based_translucency_upper_translucency_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def altitude_based_translucency_upper_translucency(self) -> float:
        """Get or set the upper translucency value for the image when use altitude based translucency is set to <see langword='true' />..."""
        return self._intf.get_property(IGlobeImageOverlay._metadata, IGlobeImageOverlay._get_altitude_based_translucency_upper_translucency_metadata)

    _set_altitude_based_translucency_upper_translucency_metadata = { "offset" : _set_altitude_based_translucency_upper_translucency_method_offset,
            "arg_types" : (agcom.FLOAT,),
            "marshallers" : (agmarshall.FloatArg,) }
    @altitude_based_translucency_upper_translucency.setter
    def altitude_based_translucency_upper_translucency(self, altitudeBasedTranslucencyUpperTranslucency:float) -> None:
        return self._intf.set_property(IGlobeImageOverlay._metadata, IGlobeImageOverlay._set_altitude_based_translucency_upper_translucency_metadata, altitudeBasedTranslucencyUpperTranslucency)

    _get_altitude_based_translucency_lower_altitude_metadata = { "offset" : _get_altitude_based_translucency_lower_altitude_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def altitude_based_translucency_lower_altitude(self) -> float:
        """Get or set the lower altitude bound used to calculate translucency for the image when use altitude based translucency is set to <see langword='true' />..."""
        return self._intf.get_property(IGlobeImageOverlay._metadata, IGlobeImageOverlay._get_altitude_based_translucency_lower_altitude_metadata)

    _set_altitude_based_translucency_lower_altitude_metadata = { "offset" : _set_altitude_based_translucency_lower_altitude_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @altitude_based_translucency_lower_altitude.setter
    def altitude_based_translucency_lower_altitude(self, altitudeBasedTranslucencyLowerAltitude:float) -> None:
        return self._intf.set_property(IGlobeImageOverlay._metadata, IGlobeImageOverlay._set_altitude_based_translucency_lower_altitude_metadata, altitudeBasedTranslucencyLowerAltitude)

    _get_altitude_based_translucency_upper_altitude_metadata = { "offset" : _get_altitude_based_translucency_upper_altitude_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def altitude_based_translucency_upper_altitude(self) -> float:
        """Get or set the upper altitude bound used to calculate translucency for the image when use altitude based translucency is set to <see langword='true' />..."""
        return self._intf.get_property(IGlobeImageOverlay._metadata, IGlobeImageOverlay._get_altitude_based_translucency_upper_altitude_metadata)

    _set_altitude_based_translucency_upper_altitude_metadata = { "offset" : _set_altitude_based_translucency_upper_altitude_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @altitude_based_translucency_upper_altitude.setter
    def altitude_based_translucency_upper_altitude(self, altitudeBasedTranslucencyUpperAltitude:float) -> None:
        return self._intf.set_property(IGlobeImageOverlay._metadata, IGlobeImageOverlay._set_altitude_based_translucency_upper_altitude_metadata, altitudeBasedTranslucencyUpperAltitude)

    _get_more_than_one_image_globe_overlay_supported_metadata = { "offset" : _get_more_than_one_image_globe_overlay_supported_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def more_than_one_image_globe_overlay_supported(self) -> bool:
        """Get whether or not the video card allows for more than one image globe overlay globe image overlay to be added."""
        return self._intf.get_property(IGlobeImageOverlay._metadata, IGlobeImageOverlay._get_more_than_one_image_globe_overlay_supported_metadata)

    _property_names[translucency] = "translucency"
    _property_names[use_altitude_based_translucency] = "use_altitude_based_translucency"
    _property_names[altitude_based_translucency_lower_translucency] = "altitude_based_translucency_lower_translucency"
    _property_names[altitude_based_translucency_upper_translucency] = "altitude_based_translucency_upper_translucency"
    _property_names[altitude_based_translucency_lower_altitude] = "altitude_based_translucency_lower_altitude"
    _property_names[altitude_based_translucency_upper_altitude] = "altitude_based_translucency_upper_altitude"
    _property_names[more_than_one_image_globe_overlay_supported] = "more_than_one_image_globe_overlay_supported"


agcls.AgClassCatalog.add_catalog_entry((4736968619611124189, 4590632582554593668), IGlobeImageOverlay)
agcls.AgTypeNameMap["IGlobeImageOverlay"] = IGlobeImageOverlay

class IGraphicsFont(object):
    """A font that is suitable for use with the text batch primitive. For best performance, avoid creating duplicate font objects. Instead assign the same font object to several text batch primitives."""

    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_name_method_offset = 1
    _get_size_method_offset = 2
    _get_bold_method_offset = 3
    _get_italic_method_offset = 4
    _get_underline_method_offset = 5
    _get_strikeout_method_offset = 6
    _get_outline_method_offset = 7
    _get_style_method_offset = 8
    _get_antialias_method_offset = 9
    _metadata = {
        "iid_data" : (4853542375175650656, 5379498553107732626),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IGraphicsFont."""
        initialize_from_source_object(self, sourceObject, IGraphicsFont)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IGraphicsFont)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IGraphicsFont, None)
    
    _get_name_metadata = { "offset" : _get_name_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def name(self) -> str:
        """Get the typeface name of the font."""
        return self._intf.get_property(IGraphicsFont._metadata, IGraphicsFont._get_name_metadata)

    _get_size_metadata = { "offset" : _get_size_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def size(self) -> int:
        """Get the size of the font."""
        return self._intf.get_property(IGraphicsFont._metadata, IGraphicsFont._get_size_metadata)

    _get_bold_metadata = { "offset" : _get_bold_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def bold(self) -> bool:
        """Get a value that indicates whether this font is bold."""
        return self._intf.get_property(IGraphicsFont._metadata, IGraphicsFont._get_bold_metadata)

    _get_italic_metadata = { "offset" : _get_italic_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def italic(self) -> bool:
        """Get a value that indicates whether this font is italic."""
        return self._intf.get_property(IGraphicsFont._metadata, IGraphicsFont._get_italic_metadata)

    _get_underline_metadata = { "offset" : _get_underline_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def underline(self) -> bool:
        """Get a value that indicates whether this font is underlined."""
        return self._intf.get_property(IGraphicsFont._metadata, IGraphicsFont._get_underline_metadata)

    _get_strikeout_metadata = { "offset" : _get_strikeout_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def strikeout(self) -> bool:
        """Get a value that indicates whether this font has a horizontal line through its characters."""
        return self._intf.get_property(IGraphicsFont._metadata, IGraphicsFont._get_strikeout_metadata)

    _get_outline_metadata = { "offset" : _get_outline_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def outline(self) -> bool:
        """Get a value that indicates whether this font has an outline around its characters."""
        return self._intf.get_property(IGraphicsFont._metadata, IGraphicsFont._get_outline_metadata)

    _get_style_metadata = { "offset" : _get_style_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(FONT_STYLE),) }
    @property
    def style(self) -> "FONT_STYLE":
        """Get the font style enumeration that contains the style for this font. This does not include the outline property."""
        return self._intf.get_property(IGraphicsFont._metadata, IGraphicsFont._get_style_metadata)

    _get_antialias_metadata = { "offset" : _get_antialias_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def antialias(self) -> bool:
        """Get a value that indicates whether this font is antialiased."""
        return self._intf.get_property(IGraphicsFont._metadata, IGraphicsFont._get_antialias_metadata)

    _property_names[name] = "name"
    _property_names[size] = "size"
    _property_names[bold] = "bold"
    _property_names[italic] = "italic"
    _property_names[underline] = "underline"
    _property_names[strikeout] = "strikeout"
    _property_names[outline] = "outline"
    _property_names[style] = "style"
    _property_names[antialias] = "antialias"


agcls.AgClassCatalog.add_catalog_entry((4853542375175650656, 5379498553107732626), IGraphicsFont)
agcls.AgTypeNameMap["IGraphicsFont"] = IGraphicsFont

class IGreatArcInterpolator(object):
    """The great arc interpolator computes interpolated positions along a great arc. A great arc is the shortest path between two positions on an ellipsoid."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_central_body_method_offset = 1
    _set_central_body_method_offset = 2
    _get_granularity_method_offset = 3
    _set_granularity_method_offset = 4
    _metadata = {
        "iid_data" : (5255382523329933505, 2913107983155980950),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IGreatArcInterpolator."""
        initialize_from_source_object(self, sourceObject, IGreatArcInterpolator)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IGreatArcInterpolator)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IGreatArcInterpolator, None)
    
    _get_central_body_metadata = { "offset" : _get_central_body_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def central_body(self) -> str:
        """Get or set the central body used when interpolating with interpolate."""
        return self._intf.get_property(IGreatArcInterpolator._metadata, IGreatArcInterpolator._get_central_body_metadata)

    _set_central_body_metadata = { "offset" : _set_central_body_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @central_body.setter
    def central_body(self, centralBody:str) -> None:
        return self._intf.set_property(IGreatArcInterpolator._metadata, IGreatArcInterpolator._set_central_body_metadata, centralBody)

    _get_granularity_metadata = { "offset" : _get_granularity_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def granularity(self) -> float:
        """Get or set the granularity used when interpolating with interpolate. Lower granularities are more precise but create more positions."""
        return self._intf.get_property(IGreatArcInterpolator._metadata, IGreatArcInterpolator._get_granularity_metadata)

    _set_granularity_metadata = { "offset" : _set_granularity_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @granularity.setter
    def granularity(self, granularity:float) -> None:
        return self._intf.set_property(IGreatArcInterpolator._metadata, IGreatArcInterpolator._set_granularity_metadata, granularity)

    _property_names[central_body] = "central_body"
    _property_names[granularity] = "granularity"


agcls.AgClassCatalog.add_catalog_entry((5255382523329933505, 2913107983155980950), IGreatArcInterpolator)
agcls.AgTypeNameMap["IGreatArcInterpolator"] = IGreatArcInterpolator

class IImageCollection(object):
    """A collection of globe image overlay objects."""

    _num_methods = 20
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_count_method_offset = 1
    _get_is_read_only_method_offset = 2
    _item_method_offset = 3
    _get__NewEnum_method_offset = 4
    _contains_method_offset = 5
    _contains_uri_string_method_offset = 6
    _remove_method_offset = 7
    _clear_method_offset = 8
    _add_method_offset = 9
    _add_async_method_offset = 10
    _index_of_method_offset = 11
    _index_of_uri_string_method_offset = 12
    _add_uri_string_method_offset = 13
    _add_async_uri_string_method_offset = 14
    _swap_method_offset = 15
    _swap_by_index_method_offset = 16
    _move_method_offset = 17
    _move_by_index_method_offset = 18
    _bring_to_front_method_offset = 19
    _send_to_back_method_offset = 20
    _metadata = {
        "iid_data" : (5161567200153924179, 13845863922263759796),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IImageCollection."""
        initialize_from_source_object(self, sourceObject, IImageCollection)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IImageCollection)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IImageCollection, None)
    def __iter__(self):
        """Create an iterator for the IImageCollection object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IGlobeImageOverlay":
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    def Subscribe(self) -> IImageCollectionEventHandler:
        """Return an IImageCollectionEventHandler that is subscribed to handle events associated with this instance of IImageCollection."""
        return IImageCollectionEventHandler(self._intf)
    
    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def count(self) -> int:
        """Get the number of globe overlay objects in the collection."""
        return self._intf.get_property(IImageCollection._metadata, IImageCollection._get_count_metadata)

    _get_is_read_only_metadata = { "offset" : _get_is_read_only_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_read_only(self) -> bool:
        """Get whether or not the collection is read only."""
        return self._intf.get_property(IImageCollection._metadata, IImageCollection._get_is_read_only_metadata)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def item(self, index:int) -> "IGlobeImageOverlay":
        """Get the globe image overlay at the specified index."""
        return self._intf.invoke(IImageCollection._metadata, IImageCollection._item_metadata, index, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        """Construct an iterator that can be used to iterate the collection."""
        return self._intf.get_property(IImageCollection._metadata, IImageCollection._get__NewEnum_metadata)

    _contains_metadata = { "offset" : _contains_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.InterfaceInArg("IGlobeImageOverlay"), agmarshall.VariantBoolArg,) }
    def contains(self, imageryOverlay:"IGlobeImageOverlay") -> bool:
        """Check the presence of a globe image overlay in the collection."""
        return self._intf.invoke(IImageCollection._metadata, IImageCollection._contains_metadata, imageryOverlay, OutArg())

    _contains_uri_string_metadata = { "offset" : _contains_uri_string_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.VariantBoolArg,) }
    def contains_uri_string(self, stringUri:str) -> bool:
        """Check the presence of a globe image overlay with the specified Uri in the collection."""
        return self._intf.invoke(IImageCollection._metadata, IImageCollection._contains_uri_string_metadata, stringUri, OutArg())

    _remove_metadata = { "offset" : _remove_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.InterfaceInArg("IGlobeImageOverlay"), agmarshall.VariantBoolArg,) }
    def remove(self, globeOverlay:"IGlobeImageOverlay") -> bool:
        """Remove a globe image overlay from the collection."""
        return self._intf.invoke(IImageCollection._metadata, IImageCollection._remove_metadata, globeOverlay, OutArg())

    _clear_metadata = { "offset" : _clear_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def clear(self) -> None:
        """Remove all globe image overlay objects from the collection."""
        return self._intf.invoke(IImageCollection._metadata, IImageCollection._clear_metadata, )

    _add_metadata = { "offset" : _add_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IGlobeImageOverlay"),) }
    def add(self, imageryOverlay:"IGlobeImageOverlay") -> None:
        """Add imageryOverlay to the collection."""
        return self._intf.invoke(IImageCollection._metadata, IImageCollection._add_metadata, imageryOverlay)

    _add_async_metadata = { "offset" : _add_async_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IGlobeImageOverlay"),) }
    def add_async(self, imageryOverlay:"IGlobeImageOverlay") -> None:
        """Add imageryOverlay to the collection asynchronously."""
        return self._intf.invoke(IImageCollection._metadata, IImageCollection._add_async_metadata, imageryOverlay)

    _index_of_metadata = { "offset" : _index_of_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.INT),),
            "marshallers" : (agmarshall.InterfaceInArg("IGlobeImageOverlay"), agmarshall.IntArg,) }
    def index_of(self, imageryOverlay:"IGlobeImageOverlay") -> int:
        """Get the index of the specified globe image overlay."""
        return self._intf.invoke(IImageCollection._metadata, IImageCollection._index_of_metadata, imageryOverlay, OutArg())

    _index_of_uri_string_metadata = { "offset" : _index_of_uri_string_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.INT),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.IntArg,) }
    def index_of_uri_string(self, stringUri:str) -> int:
        """Get the index of the globe image overlay with the specified Uri."""
        return self._intf.invoke(IImageCollection._metadata, IImageCollection._index_of_uri_string_metadata, stringUri, OutArg())

    _add_uri_string_metadata = { "offset" : _add_uri_string_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def add_uri_string(self, uri:str) -> "IGlobeImageOverlay":
        """Create a globe overlay from the uri, which represents a uri, and adds it to the collection."""
        return self._intf.invoke(IImageCollection._metadata, IImageCollection._add_uri_string_metadata, uri, OutArg())

    _add_async_uri_string_metadata = { "offset" : _add_async_uri_string_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def add_async_uri_string(self, uri:str) -> "IGlobeImageOverlay":
        """Create a globe image overlay from the uri, which represents a uri, and adds it to the collection asynchronously."""
        return self._intf.invoke(IImageCollection._metadata, IImageCollection._add_async_uri_string_metadata, uri, OutArg())

    _swap_metadata = { "offset" : _swap_method_offset,
            "arg_types" : (agcom.PVOID, agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IGlobeImageOverlay"), agmarshall.InterfaceInArg("IGlobeImageOverlay"),) }
    def swap(self, imageryOverlay1:"IGlobeImageOverlay", imageryOverlay2:"IGlobeImageOverlay") -> None:
        """Swap the position of two globe image overlay objects."""
        return self._intf.invoke(IImageCollection._metadata, IImageCollection._swap_metadata, imageryOverlay1, imageryOverlay2)

    _swap_by_index_metadata = { "offset" : _swap_by_index_method_offset,
            "arg_types" : (agcom.INT, agcom.INT,),
            "marshallers" : (agmarshall.IntArg, agmarshall.IntArg,) }
    def swap_by_index(self, index1:int, index2:int) -> None:
        """Swap the position of two globe image overlay objects at the specified indices."""
        return self._intf.invoke(IImageCollection._metadata, IImageCollection._swap_by_index_metadata, index1, index2)

    _move_metadata = { "offset" : _move_method_offset,
            "arg_types" : (agcom.PVOID, agcom.INT,),
            "marshallers" : (agmarshall.InterfaceInArg("IGlobeImageOverlay"), agmarshall.IntArg,) }
    def move(self, imageryOverlay:"IGlobeImageOverlay", newPosition:int) -> None:
        """Move the globe image overlay to the specified position."""
        return self._intf.invoke(IImageCollection._metadata, IImageCollection._move_metadata, imageryOverlay, newPosition)

    _move_by_index_metadata = { "offset" : _move_by_index_method_offset,
            "arg_types" : (agcom.INT, agcom.INT,),
            "marshallers" : (agmarshall.IntArg, agmarshall.IntArg,) }
    def move_by_index(self, index:int, newPosition:int) -> None:
        """Move the globe image overlay at the specified index to the specified position."""
        return self._intf.invoke(IImageCollection._metadata, IImageCollection._move_by_index_metadata, index, newPosition)

    _bring_to_front_metadata = { "offset" : _bring_to_front_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IGlobeImageOverlay"),) }
    def bring_to_front(self, imageryOverlay:"IGlobeImageOverlay") -> None:
        """Brings the globe image overlay to the front of the collection so it is rendered first or on the bottom."""
        return self._intf.invoke(IImageCollection._metadata, IImageCollection._bring_to_front_metadata, imageryOverlay)

    _send_to_back_metadata = { "offset" : _send_to_back_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IGlobeImageOverlay"),) }
    def send_to_back(self, imageryOverlay:"IGlobeImageOverlay") -> None:
        """Send the globe image overlay to the back of the collection so it is rendered last or on the top."""
        return self._intf.invoke(IImageCollection._metadata, IImageCollection._send_to_back_metadata, imageryOverlay)

    __getitem__ = item


    _property_names[count] = "count"
    _property_names[is_read_only] = "is_read_only"
    _property_names[_NewEnum] = "_NewEnum"


agcls.AgClassCatalog.add_catalog_entry((5161567200153924179, 13845863922263759796), IImageCollection)
agcls.AgTypeNameMap["IImageCollection"] = IImageCollection

class IAlphaFromLuminanceFilter(object):
    """Add an alpha band to the source raster derived from the luminance of the raster's color bands."""

    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "iid_data" : (5749565162954789694, 15745680047360476803),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IAlphaFromLuminanceFilter."""
        initialize_from_source_object(self, sourceObject, IAlphaFromLuminanceFilter)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAlphaFromLuminanceFilter)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IAlphaFromLuminanceFilter, None)
    

agcls.AgClassCatalog.add_catalog_entry((5749565162954789694, 15745680047360476803), IAlphaFromLuminanceFilter)
agcls.AgTypeNameMap["IAlphaFromLuminanceFilter"] = IAlphaFromLuminanceFilter

class IAlphaFromPixelFilter(object):
    """Add an alpha band to the source raster based on the value of its first pixel. All pixels in the source raster that are the same color as the first pixel will be made transparent."""

    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "iid_data" : (5487909280219947171, 14441549139800145842),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IAlphaFromPixelFilter."""
        initialize_from_source_object(self, sourceObject, IAlphaFromPixelFilter)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAlphaFromPixelFilter)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IAlphaFromPixelFilter, None)
    

agcls.AgClassCatalog.add_catalog_entry((5487909280219947171, 14441549139800145842), IAlphaFromPixelFilter)
agcls.AgTypeNameMap["IAlphaFromPixelFilter"] = IAlphaFromPixelFilter

class IAlphaFromRasterFilter(object):
    """Add an alpha band to the source raster derived from the color bands or alpha of another raster. This filter can be used to apply an alpha mask to the source raster."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_raster_method_offset = 1
    _set_raster_method_offset = 2
    _metadata = {
        "iid_data" : (5071268630863441758, 8072945114305197197),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IAlphaFromRasterFilter."""
        initialize_from_source_object(self, sourceObject, IAlphaFromRasterFilter)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAlphaFromRasterFilter)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IAlphaFromRasterFilter, None)
    
    _get_raster_metadata = { "offset" : _get_raster_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def raster(self) -> "IRaster":
        """Get or set the raster that the source raster will use to derive an alpha band."""
        return self._intf.get_property(IAlphaFromRasterFilter._metadata, IAlphaFromRasterFilter._get_raster_metadata)

    _set_raster_metadata = { "offset" : _set_raster_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IRaster"),) }
    @raster.setter
    def raster(self, raster:"IRaster") -> None:
        return self._intf.set_property(IAlphaFromRasterFilter._metadata, IAlphaFromRasterFilter._set_raster_metadata, raster)

    _property_names[raster] = "raster"


agcls.AgClassCatalog.add_catalog_entry((5071268630863441758, 8072945114305197197), IAlphaFromRasterFilter)
agcls.AgTypeNameMap["IAlphaFromRasterFilter"] = IAlphaFromRasterFilter

class IBandExtractFilter(object):
    """Extract a band or set of bands from the source raster. The extract format property specifies the bands and the order of the bands that will be extracted."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_extract_format_method_offset = 1
    _set_extract_format_method_offset = 2
    _metadata = {
        "iid_data" : (5553327131329707707, 6692894464708926139),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IBandExtractFilter."""
        initialize_from_source_object(self, sourceObject, IBandExtractFilter)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IBandExtractFilter)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IBandExtractFilter, None)
    
    _get_extract_format_metadata = { "offset" : _get_extract_format_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(RASTER_FORMAT),) }
    @property
    def extract_format(self) -> "RASTER_FORMAT":
        """Get or set the raster format containing the bands and the order of the bands that will be extracted."""
        return self._intf.get_property(IBandExtractFilter._metadata, IBandExtractFilter._get_extract_format_metadata)

    _set_extract_format_metadata = { "offset" : _set_extract_format_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(RASTER_FORMAT),) }
    @extract_format.setter
    def extract_format(self, extractFormat:"RASTER_FORMAT") -> None:
        return self._intf.set_property(IBandExtractFilter._metadata, IBandExtractFilter._set_extract_format_metadata, extractFormat)

    _property_names[extract_format] = "extract_format"


agcls.AgClassCatalog.add_catalog_entry((5553327131329707707, 6692894464708926139), IBandExtractFilter)
agcls.AgTypeNameMap["IBandExtractFilter"] = IBandExtractFilter

class IBandOrderFilter(object):
    """Reorders or swizzles the bands of the source raster to match the band order of the raster format specified by the band order property. When maintain raster format is true, the source raster's format is maintained after swizzling."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_band_order_method_offset = 1
    _set_band_order_method_offset = 2
    _get_maintain_raster_format_method_offset = 3
    _set_maintain_raster_format_method_offset = 4
    _metadata = {
        "iid_data" : (5455804067318556677, 15241427824966143111),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IBandOrderFilter."""
        initialize_from_source_object(self, sourceObject, IBandOrderFilter)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IBandOrderFilter)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IBandOrderFilter, None)
    
    _get_band_order_metadata = { "offset" : _get_band_order_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(RASTER_FORMAT),) }
    @property
    def band_order(self) -> "RASTER_FORMAT":
        """Get or set the raster format indicating the desired order of the bands in the source raster."""
        return self._intf.get_property(IBandOrderFilter._metadata, IBandOrderFilter._get_band_order_metadata)

    _set_band_order_metadata = { "offset" : _set_band_order_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(RASTER_FORMAT),) }
    @band_order.setter
    def band_order(self, bandOrder:"RASTER_FORMAT") -> None:
        return self._intf.set_property(IBandOrderFilter._metadata, IBandOrderFilter._set_band_order_metadata, bandOrder)

    _get_maintain_raster_format_metadata = { "offset" : _get_maintain_raster_format_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def maintain_raster_format(self) -> bool:
        """Get or set a value indicating whether to maintain the source raster's format after the filter is applied. When true, the source raster's format is maintained after swizzling."""
        return self._intf.get_property(IBandOrderFilter._metadata, IBandOrderFilter._get_maintain_raster_format_metadata)

    _set_maintain_raster_format_metadata = { "offset" : _set_maintain_raster_format_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @maintain_raster_format.setter
    def maintain_raster_format(self, maintainRasterFormat:bool) -> None:
        return self._intf.set_property(IBandOrderFilter._metadata, IBandOrderFilter._set_maintain_raster_format_metadata, maintainRasterFormat)

    _property_names[band_order] = "band_order"
    _property_names[maintain_raster_format] = "maintain_raster_format"


agcls.AgClassCatalog.add_catalog_entry((5455804067318556677, 15241427824966143111), IBandOrderFilter)
agcls.AgTypeNameMap["IBandOrderFilter"] = IBandOrderFilter

class IBlurFilter(object):
    """Apply a convolution filter to blur or smooth the source raster. Can be used to reduce noise in the raster."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_method_method_offset = 1
    _set_method_method_offset = 2
    _metadata = {
        "iid_data" : (5156019592751358897, 14730170447071393964),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IBlurFilter."""
        initialize_from_source_object(self, sourceObject, IBlurFilter)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IBlurFilter)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IBlurFilter, None)
    
    _get_method_metadata = { "offset" : _get_method_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(BLUR_METHOD),) }
    @property
    def method(self) -> "BLUR_METHOD":
        """Get or set the method used to blur the source raster."""
        return self._intf.get_property(IBlurFilter._metadata, IBlurFilter._get_method_metadata)

    _set_method_metadata = { "offset" : _set_method_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(BLUR_METHOD),) }
    @method.setter
    def method(self, method:"BLUR_METHOD") -> None:
        return self._intf.set_property(IBlurFilter._metadata, IBlurFilter._set_method_metadata, method)

    _property_names[method] = "method"


agcls.AgClassCatalog.add_catalog_entry((5156019592751358897, 14730170447071393964), IBlurFilter)
agcls.AgTypeNameMap["IBlurFilter"] = IBlurFilter

class IBrightnessFilter(object):
    """Adjusts the brightness of the source raster's color bands. The adjustment to brightness is a value between -1 and 1, corresponding to least bright to most bright."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_adjustment_method_offset = 1
    _set_adjustment_method_offset = 2
    _metadata = {
        "iid_data" : (4802486208183870698, 10278011080970254984),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IBrightnessFilter."""
        initialize_from_source_object(self, sourceObject, IBrightnessFilter)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IBrightnessFilter)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IBrightnessFilter, None)
    
    _get_adjustment_metadata = { "offset" : _get_adjustment_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def adjustment(self) -> float:
        """Get or set the brightness adjustment value for the filter. The value must be between -1 and 1, corresponding to least bright to most bright."""
        return self._intf.get_property(IBrightnessFilter._metadata, IBrightnessFilter._get_adjustment_metadata)

    _set_adjustment_metadata = { "offset" : _set_adjustment_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @adjustment.setter
    def adjustment(self, adjustment:float) -> None:
        return self._intf.set_property(IBrightnessFilter._metadata, IBrightnessFilter._set_adjustment_metadata, adjustment)

    _property_names[adjustment] = "adjustment"


agcls.AgClassCatalog.add_catalog_entry((4802486208183870698, 10278011080970254984), IBrightnessFilter)
agcls.AgTypeNameMap["IBrightnessFilter"] = IBrightnessFilter

class IColorToLuminanceFilter(object):
    """Extract a luminance band derived from the color bands of the source raster."""

    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "iid_data" : (4984200951915944335, 10697548902017290638),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IColorToLuminanceFilter."""
        initialize_from_source_object(self, sourceObject, IColorToLuminanceFilter)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IColorToLuminanceFilter)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IColorToLuminanceFilter, None)
    

agcls.AgClassCatalog.add_catalog_entry((4984200951915944335, 10697548902017290638), IColorToLuminanceFilter)
agcls.AgTypeNameMap["IColorToLuminanceFilter"] = IColorToLuminanceFilter

class IContrastFilter(object):
    """Adjusts the contrast of the source raster. The adjustment to contrast is a value between -1 and 1, corresponding to least contrast to most contrast."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_adjustment_method_offset = 1
    _set_adjustment_method_offset = 2
    _metadata = {
        "iid_data" : (5275228079972303811, 11026900883018049925),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IContrastFilter."""
        initialize_from_source_object(self, sourceObject, IContrastFilter)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IContrastFilter)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IContrastFilter, None)
    
    _get_adjustment_metadata = { "offset" : _get_adjustment_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def adjustment(self) -> float:
        """Get or set the contrast adjustment value for the filter. The value must be between -1 and 1, corresponding to least contrast to most contrast."""
        return self._intf.get_property(IContrastFilter._metadata, IContrastFilter._get_adjustment_metadata)

    _set_adjustment_metadata = { "offset" : _set_adjustment_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @adjustment.setter
    def adjustment(self, adjustment:float) -> None:
        return self._intf.set_property(IContrastFilter._metadata, IContrastFilter._set_adjustment_metadata, adjustment)

    _property_names[adjustment] = "adjustment"


agcls.AgClassCatalog.add_catalog_entry((5275228079972303811, 11026900883018049925), IContrastFilter)
agcls.AgTypeNameMap["IContrastFilter"] = IContrastFilter

class IConvolutionFilter(object):
    """Apply convolution to the source raster. Convolution is the modification of a pixel's value based on the values of its surrounding pixels. The kernel is the numerical matrix that is applied to each pixel in this process..."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_divisor_method_offset = 1
    _set_divisor_method_offset = 2
    _get_offset_method_offset = 3
    _set_offset_method_offset = 4
    _get_kernel_method_offset = 5
    _set_kernel_method_offset = 6
    _metadata = {
        "iid_data" : (4661190070888522861, 10534747934616289203),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IConvolutionFilter."""
        initialize_from_source_object(self, sourceObject, IConvolutionFilter)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IConvolutionFilter)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IConvolutionFilter, None)
    
    _get_divisor_metadata = { "offset" : _get_divisor_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def divisor(self) -> float:
        """Get or set the divisor for the result of the convolution kernel operation."""
        return self._intf.get_property(IConvolutionFilter._metadata, IConvolutionFilter._get_divisor_metadata)

    _set_divisor_metadata = { "offset" : _set_divisor_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @divisor.setter
    def divisor(self, divisor:float) -> None:
        return self._intf.set_property(IConvolutionFilter._metadata, IConvolutionFilter._set_divisor_metadata, divisor)

    _get_offset_metadata = { "offset" : _get_offset_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def offset(self) -> float:
        """Get or set the offset for the result of the convolution kernel operation. The value is added to the result of the operation."""
        return self._intf.get_property(IConvolutionFilter._metadata, IConvolutionFilter._get_offset_metadata)

    _set_offset_metadata = { "offset" : _set_offset_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @offset.setter
    def offset(self, offset:float) -> None:
        return self._intf.set_property(IConvolutionFilter._metadata, IConvolutionFilter._set_offset_metadata, offset)

    _get_kernel_metadata = { "offset" : _get_kernel_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def kernel(self) -> list:
        """Get or set the convolution kernel of the filter. The array contains the 9 elements of the kernel of the convolution matrix..."""
        return self._intf.get_property(IConvolutionFilter._metadata, IConvolutionFilter._get_kernel_metadata)

    _set_kernel_metadata = { "offset" : _set_kernel_method_offset,
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @kernel.setter
    def kernel(self, kernel:list) -> None:
        return self._intf.set_property(IConvolutionFilter._metadata, IConvolutionFilter._set_kernel_metadata, kernel)

    _property_names[divisor] = "divisor"
    _property_names[offset] = "offset"
    _property_names[kernel] = "kernel"


agcls.AgClassCatalog.add_catalog_entry((4661190070888522861, 10534747934616289203), IConvolutionFilter)
agcls.AgTypeNameMap["IConvolutionFilter"] = IConvolutionFilter

class IEdgeDetectFilter(object):
    """Apply a convolution filter to detect edges in the source raster."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_method_method_offset = 1
    _set_method_method_offset = 2
    _metadata = {
        "iid_data" : (4622826918932764086, 170869495788315295),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IEdgeDetectFilter."""
        initialize_from_source_object(self, sourceObject, IEdgeDetectFilter)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IEdgeDetectFilter)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IEdgeDetectFilter, None)
    
    _get_method_metadata = { "offset" : _get_method_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(EDGE_DETECT_METHOD),) }
    @property
    def method(self) -> "EDGE_DETECT_METHOD":
        """Get or set the method used to detect edges in the source raster."""
        return self._intf.get_property(IEdgeDetectFilter._metadata, IEdgeDetectFilter._get_method_metadata)

    _set_method_metadata = { "offset" : _set_method_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(EDGE_DETECT_METHOD),) }
    @method.setter
    def method(self, method:"EDGE_DETECT_METHOD") -> None:
        return self._intf.set_property(IEdgeDetectFilter._metadata, IEdgeDetectFilter._set_method_metadata, method)

    _property_names[method] = "method"


agcls.AgClassCatalog.add_catalog_entry((4622826918932764086, 170869495788315295), IEdgeDetectFilter)
agcls.AgTypeNameMap["IEdgeDetectFilter"] = IEdgeDetectFilter

class IFilteringRasterStream(object):
    """A class decorator for applying a raster filter to each update of a raster stream. Can be used to apply filters to videos and other raster streams as they are updated."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_filter_method_offset = 1
    _get_stream_method_offset = 2
    _metadata = {
        "iid_data" : (4850591175353137771, 7754674969793305223),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IFilteringRasterStream."""
        initialize_from_source_object(self, sourceObject, IFilteringRasterStream)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IFilteringRasterStream)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IFilteringRasterStream, None)
    
    _get_filter_metadata = { "offset" : _get_filter_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def filter(self) -> "IRasterFilter":
        """Get the raster filter that will be applied to the raster stream on each update."""
        return self._intf.get_property(IFilteringRasterStream._metadata, IFilteringRasterStream._get_filter_metadata)

    _get_stream_metadata = { "offset" : _get_stream_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def stream(self) -> "IRasterStream":
        """Get the raster stream that will have the raster filter applied on each update."""
        return self._intf.get_property(IFilteringRasterStream._metadata, IFilteringRasterStream._get_stream_metadata)

    _property_names[filter] = "filter"
    _property_names[stream] = "stream"


agcls.AgClassCatalog.add_catalog_entry((4850591175353137771, 7754674969793305223), IFilteringRasterStream)
agcls.AgTypeNameMap["IFilteringRasterStream"] = IFilteringRasterStream

class IFlipFilter(object):
    """Flips the source raster along the given flip axis."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_flip_axis_method_offset = 1
    _set_flip_axis_method_offset = 2
    _metadata = {
        "iid_data" : (4807072714807237384, 3168786305469941428),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IFlipFilter."""
        initialize_from_source_object(self, sourceObject, IFlipFilter)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IFlipFilter)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IFlipFilter, None)
    
    _get_flip_axis_metadata = { "offset" : _get_flip_axis_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(FLIP_AXIS),) }
    @property
    def flip_axis(self) -> "FLIP_AXIS":
        """Get or set the flip axis along which the source raster will be flipped."""
        return self._intf.get_property(IFlipFilter._metadata, IFlipFilter._get_flip_axis_metadata)

    _set_flip_axis_metadata = { "offset" : _set_flip_axis_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(FLIP_AXIS),) }
    @flip_axis.setter
    def flip_axis(self, flipAxis:"FLIP_AXIS") -> None:
        return self._intf.set_property(IFlipFilter._metadata, IFlipFilter._set_flip_axis_metadata, flipAxis)

    _property_names[flip_axis] = "flip_axis"


agcls.AgClassCatalog.add_catalog_entry((4807072714807237384, 3168786305469941428), IFlipFilter)
agcls.AgTypeNameMap["IFlipFilter"] = IFlipFilter

class IGammaCorrectionFilter(object):
    """Apply gamma correction to the source raster. The gamma is a value between .2 and 5. The default gamma value is 2.2."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_gamma_method_offset = 1
    _set_gamma_method_offset = 2
    _metadata = {
        "iid_data" : (5172314188843020349, 6527923600942516619),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IGammaCorrectionFilter."""
        initialize_from_source_object(self, sourceObject, IGammaCorrectionFilter)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IGammaCorrectionFilter)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IGammaCorrectionFilter, None)
    
    _get_gamma_metadata = { "offset" : _get_gamma_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def gamma(self) -> float:
        """Get or set the gamma value for the filter. The value must be between .2 and 5. The default gamma value is 2.2."""
        return self._intf.get_property(IGammaCorrectionFilter._metadata, IGammaCorrectionFilter._get_gamma_metadata)

    _set_gamma_metadata = { "offset" : _set_gamma_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @gamma.setter
    def gamma(self, gamma:float) -> None:
        return self._intf.set_property(IGammaCorrectionFilter._metadata, IGammaCorrectionFilter._set_gamma_metadata, gamma)

    _property_names[gamma] = "gamma"


agcls.AgClassCatalog.add_catalog_entry((5172314188843020349, 6527923600942516619), IGammaCorrectionFilter)
agcls.AgTypeNameMap["IGammaCorrectionFilter"] = IGammaCorrectionFilter

class IGaussianBlurFilter(object):
    """Apply a convolution filter to blur the source raster using the Gaussian function."""

    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "iid_data" : (4989874083915146590, 17595274729084466359),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IGaussianBlurFilter."""
        initialize_from_source_object(self, sourceObject, IGaussianBlurFilter)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IGaussianBlurFilter)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IGaussianBlurFilter, None)
    

agcls.AgClassCatalog.add_catalog_entry((4989874083915146590, 17595274729084466359), IGaussianBlurFilter)
agcls.AgTypeNameMap["IGaussianBlurFilter"] = IGaussianBlurFilter

class IGradientDetectFilter(object):
    """Apply a convolution filter to detect gradients in the source raster."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_method_method_offset = 1
    _set_method_method_offset = 2
    _metadata = {
        "iid_data" : (5172471266902150476, 1346924725858697615),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IGradientDetectFilter."""
        initialize_from_source_object(self, sourceObject, IGradientDetectFilter)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IGradientDetectFilter)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IGradientDetectFilter, None)
    
    _get_method_metadata = { "offset" : _get_method_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(GRADIENT_DETECT_METHOD),) }
    @property
    def method(self) -> "GRADIENT_DETECT_METHOD":
        """Get or set the method used to detect gradients in the source raster."""
        return self._intf.get_property(IGradientDetectFilter._metadata, IGradientDetectFilter._get_method_metadata)

    _set_method_metadata = { "offset" : _set_method_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(GRADIENT_DETECT_METHOD),) }
    @method.setter
    def method(self, method:"GRADIENT_DETECT_METHOD") -> None:
        return self._intf.set_property(IGradientDetectFilter._metadata, IGradientDetectFilter._set_method_metadata, method)

    _property_names[method] = "method"


agcls.AgClassCatalog.add_catalog_entry((5172471266902150476, 1346924725858697615), IGradientDetectFilter)
agcls.AgTypeNameMap["IGradientDetectFilter"] = IGradientDetectFilter

class ILevelsFilter(object):
    """Adjusts the band levels of the source raster linearly."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _set_level_adjustment_method_offset = 1
    _clear_adjustments_method_offset = 2
    _metadata = {
        "iid_data" : (5146153998781700821, 7514838199004102037),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ILevelsFilter."""
        initialize_from_source_object(self, sourceObject, ILevelsFilter)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ILevelsFilter)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ILevelsFilter, None)
    
    _set_level_adjustment_metadata = { "offset" : _set_level_adjustment_method_offset,
            "arg_types" : (agcom.LONG, agcom.INT,),
            "marshallers" : (agmarshall.EnumArg(RASTER_BAND), agmarshall.IntArg,) }
    def set_level_adjustment(self, band:"RASTER_BAND", adjustment:int) -> None:
        """Set the linear level adjustment value for the given raster band. Both negative and positive values are accepted."""
        return self._intf.invoke(ILevelsFilter._metadata, ILevelsFilter._set_level_adjustment_metadata, band, adjustment)

    _clear_adjustments_metadata = { "offset" : _clear_adjustments_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def clear_adjustments(self) -> None:
        """Clear the level adjustment values for all bands."""
        return self._intf.invoke(ILevelsFilter._metadata, ILevelsFilter._clear_adjustments_metadata, )


agcls.AgClassCatalog.add_catalog_entry((5146153998781700821, 7514838199004102037), ILevelsFilter)
agcls.AgTypeNameMap["ILevelsFilter"] = ILevelsFilter

class IProjectionRasterStreamPluginActivator(object):
    """The Activator class provides methods to load COM plugins that implement projection and raster streaming. For more information about the projection and raster plugins, see the STK Programming Interface."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _create_from_display_name_method_offset = 1
    _get_available_display_names_method_offset = 2
    _metadata = {
        "iid_data" : (4988091618102776374, 3631186009741722512),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IProjectionRasterStreamPluginActivator."""
        initialize_from_source_object(self, sourceObject, IProjectionRasterStreamPluginActivator)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IProjectionRasterStreamPluginActivator)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IProjectionRasterStreamPluginActivator, None)
    
    _create_from_display_name_metadata = { "offset" : _create_from_display_name_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def create_from_display_name(self, displayName:str) -> "ProjectionRasterStreamPluginProxy":
        """Load a projection/raster COM plugin associated with the specified display name and returns a proxy object that allows accessing the raster and projection streams implemented by the plugin."""
        return self._intf.invoke(IProjectionRasterStreamPluginActivator._metadata, IProjectionRasterStreamPluginActivator._create_from_display_name_metadata, displayName, OutArg())

    _get_available_display_names_metadata = { "offset" : _get_available_display_names_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    def get_available_display_names(self) -> list:
        """Get a list of available projection/raster plugins' Display Names (Programmatic Identifiers)."""
        return self._intf.invoke(IProjectionRasterStreamPluginActivator._metadata, IProjectionRasterStreamPluginActivator._get_available_display_names_metadata, OutArg())


agcls.AgClassCatalog.add_catalog_entry((4988091618102776374, 3631186009741722512), IProjectionRasterStreamPluginActivator)
agcls.AgTypeNameMap["IProjectionRasterStreamPluginActivator"] = IProjectionRasterStreamPluginActivator

class IProjectionRasterStreamPluginProxy(object):
    """A proxy class provides access to the raster and projection streams implemented by a plugin. Proxies are instantiated using projection raster stream plugin activator."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_raster_stream_method_offset = 1
    _get_projection_stream_method_offset = 2
    _get_is_raster_stream_supported_method_offset = 3
    _get_is_projection_stream_supported_method_offset = 4
    _get_real_plugin_object_method_offset = 5
    _metadata = {
        "iid_data" : (5215328971719760162, 15539262404705496705),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IProjectionRasterStreamPluginProxy."""
        initialize_from_source_object(self, sourceObject, IProjectionRasterStreamPluginProxy)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IProjectionRasterStreamPluginProxy)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IProjectionRasterStreamPluginProxy, None)
    
    _get_raster_stream_metadata = { "offset" : _get_raster_stream_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def raster_stream(self) -> "IRasterStream":
        """Return a raster stream."""
        return self._intf.get_property(IProjectionRasterStreamPluginProxy._metadata, IProjectionRasterStreamPluginProxy._get_raster_stream_metadata)

    _get_projection_stream_metadata = { "offset" : _get_projection_stream_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def projection_stream(self) -> "ProjectionStream":
        """Return a projection stream."""
        return self._intf.get_property(IProjectionRasterStreamPluginProxy._metadata, IProjectionRasterStreamPluginProxy._get_projection_stream_metadata)

    _get_is_raster_stream_supported_metadata = { "offset" : _get_is_raster_stream_supported_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_raster_stream_supported(self) -> bool:
        """Return true if the raster streaming is supported."""
        return self._intf.get_property(IProjectionRasterStreamPluginProxy._metadata, IProjectionRasterStreamPluginProxy._get_is_raster_stream_supported_metadata)

    _get_is_projection_stream_supported_metadata = { "offset" : _get_is_projection_stream_supported_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_projection_stream_supported(self) -> bool:
        """Return true if the projection streaming is supported."""
        return self._intf.get_property(IProjectionRasterStreamPluginProxy._metadata, IProjectionRasterStreamPluginProxy._get_is_projection_stream_supported_metadata)

    _get_real_plugin_object_metadata = { "offset" : _get_real_plugin_object_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def real_plugin_object(self) -> typing.Any:
        """Return a pointer to plugin object's IUnknown interface."""
        return self._intf.get_property(IProjectionRasterStreamPluginProxy._metadata, IProjectionRasterStreamPluginProxy._get_real_plugin_object_metadata)

    _property_names[raster_stream] = "raster_stream"
    _property_names[projection_stream] = "projection_stream"
    _property_names[is_raster_stream_supported] = "is_raster_stream_supported"
    _property_names[is_projection_stream_supported] = "is_projection_stream_supported"
    _property_names[real_plugin_object] = "real_plugin_object"


agcls.AgClassCatalog.add_catalog_entry((5215328971719760162, 15539262404705496705), IProjectionRasterStreamPluginProxy)
agcls.AgTypeNameMap["IProjectionRasterStreamPluginProxy"] = IProjectionRasterStreamPluginProxy

class IRaster(object):
    """A raster dataset. A raster consists of one or more bands, or sets of values, which are most commonly associated with colors when the raster represents an image..."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_attributes_method_offset = 1
    _get_width_method_offset = 2
    _get_height_method_offset = 3
    _flip_method_offset = 4
    _rotate_method_offset = 5
    _apply_method_offset = 6
    _apply_in_place_method_offset = 7
    _extract_band_method_offset = 8
    _extract_band_from_raster_format_method_offset = 9
    _copy_from_raster_method_offset = 10
    _metadata = {
        "iid_data" : (4904839826723909985, 5664351486392510908),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IRaster."""
        initialize_from_source_object(self, sourceObject, IRaster)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IRaster)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IRaster, None)
    
    _get_attributes_metadata = { "offset" : _get_attributes_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def attributes(self) -> "RasterAttributes":
        """Get the raster attributes that define the raster data."""
        return self._intf.get_property(IRaster._metadata, IRaster._get_attributes_metadata)

    _get_width_metadata = { "offset" : _get_width_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def width(self) -> int:
        """Get the width of the raster in pixels."""
        return self._intf.get_property(IRaster._metadata, IRaster._get_width_metadata)

    _get_height_metadata = { "offset" : _get_height_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def height(self) -> int:
        """Get the height of the raster in pixels."""
        return self._intf.get_property(IRaster._metadata, IRaster._get_height_metadata)

    _flip_metadata = { "offset" : _flip_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(FLIP_AXIS),) }
    def flip(self, axis:"FLIP_AXIS") -> None:
        """Flips the raster along the given axis."""
        return self._intf.invoke(IRaster._metadata, IRaster._flip_metadata, axis)

    _rotate_metadata = { "offset" : _rotate_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    def rotate(self, angle:float) -> None:
        """Rotate the raster by the given angle."""
        return self._intf.invoke(IRaster._metadata, IRaster._rotate_metadata, angle)

    _apply_metadata = { "offset" : _apply_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("IRasterFilter"), agmarshall.InterfaceOutArg,) }
    def apply(self, filter:"IRasterFilter") -> "IRaster":
        """Apply a raster filter to the raster and returns a new raster with the results of the filtering. The current raster is not modified."""
        return self._intf.invoke(IRaster._metadata, IRaster._apply_metadata, filter, OutArg())

    _apply_in_place_metadata = { "offset" : _apply_in_place_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IRasterFilter"),) }
    def apply_in_place(self, filter:"IRasterFilter") -> None:
        """Apply a raster filter to the raster. The current raster will contain the results of the filtering."""
        return self._intf.invoke(IRaster._metadata, IRaster._apply_in_place_metadata, filter)

    _extract_band_metadata = { "offset" : _extract_band_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.EnumArg(RASTER_BAND), agmarshall.InterfaceOutArg,) }
    def extract_band(self, band:"RASTER_BAND") -> "IRaster":
        """Extract the band of raster data associated with the given raster band."""
        return self._intf.invoke(IRaster._metadata, IRaster._extract_band_metadata, band, OutArg())

    _extract_band_from_raster_format_metadata = { "offset" : _extract_band_from_raster_format_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.EnumArg(RASTER_FORMAT), agmarshall.InterfaceOutArg,) }
    def extract_band_from_raster_format(self, format:"RASTER_FORMAT") -> "IRaster":
        """Extract the bands of raster data associated with the given raster format."""
        return self._intf.invoke(IRaster._metadata, IRaster._extract_band_from_raster_format_metadata, format, OutArg())

    _copy_from_raster_metadata = { "offset" : _copy_from_raster_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IRaster"),) }
    def copy_from_raster(self, raster:"IRaster") -> None:
        """Copy the data associated with the given raster into this raster."""
        return self._intf.invoke(IRaster._metadata, IRaster._copy_from_raster_metadata, raster)

    _property_names[attributes] = "attributes"
    _property_names[width] = "width"
    _property_names[height] = "height"


agcls.AgClassCatalog.add_catalog_entry((4904839826723909985, 5664351486392510908), IRaster)
agcls.AgTypeNameMap["IRaster"] = IRaster

class IRasterAttributes(object):
    """The attributes describing a raster dataset. raster attributes define the memory layout of a raster, and includes properties defining the order of each raster band that the raster contains, as specified by the raster format..."""

    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_format_method_offset = 1
    _get_type_method_offset = 2
    _get_orientation_method_offset = 3
    _get_byte_length_method_offset = 4
    _get_width_method_offset = 5
    _get_height_method_offset = 6
    _get_pixel_aspect_ratio_method_offset = 7
    _get_row_alignment_method_offset = 8
    _get_number_of_bands_method_offset = 9
    _get_row_stride_method_offset = 10
    _has_band_method_offset = 11
    _metadata = {
        "iid_data" : (4735466585165008087, 2729013748843522195),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IRasterAttributes."""
        initialize_from_source_object(self, sourceObject, IRasterAttributes)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IRasterAttributes)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IRasterAttributes, None)
    
    _get_format_metadata = { "offset" : _get_format_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(RASTER_FORMAT),) }
    @property
    def format(self) -> "RASTER_FORMAT":
        """Get the raster format associated with the attributes."""
        return self._intf.get_property(IRasterAttributes._metadata, IRasterAttributes._get_format_metadata)

    _get_type_metadata = { "offset" : _get_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(RASTER_TYPE),) }
    @property
    def type(self) -> "RASTER_TYPE":
        """Get the raster type associated with the attributes."""
        return self._intf.get_property(IRasterAttributes._metadata, IRasterAttributes._get_type_metadata)

    _get_orientation_metadata = { "offset" : _get_orientation_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(RASTER_ORIENTATION),) }
    @property
    def orientation(self) -> "RASTER_ORIENTATION":
        """Get the raster orientation associated with the attributes."""
        return self._intf.get_property(IRasterAttributes._metadata, IRasterAttributes._get_orientation_metadata)

    _get_byte_length_metadata = { "offset" : _get_byte_length_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def byte_length(self) -> int:
        """Get the size of the raster data in bytes."""
        return self._intf.get_property(IRasterAttributes._metadata, IRasterAttributes._get_byte_length_metadata)

    _get_width_metadata = { "offset" : _get_width_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def width(self) -> int:
        """Get the width of the raster in pixels."""
        return self._intf.get_property(IRasterAttributes._metadata, IRasterAttributes._get_width_metadata)

    _get_height_metadata = { "offset" : _get_height_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def height(self) -> int:
        """Get the height of the raster in pixels."""
        return self._intf.get_property(IRasterAttributes._metadata, IRasterAttributes._get_height_metadata)

    _get_pixel_aspect_ratio_metadata = { "offset" : _get_pixel_aspect_ratio_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def pixel_aspect_ratio(self) -> float:
        """Get the pixel aspect ratio of the raster."""
        return self._intf.get_property(IRasterAttributes._metadata, IRasterAttributes._get_pixel_aspect_ratio_metadata)

    _get_row_alignment_metadata = { "offset" : _get_row_alignment_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def row_alignment(self) -> int:
        """Get the row alignment of the raster data in bytes."""
        return self._intf.get_property(IRasterAttributes._metadata, IRasterAttributes._get_row_alignment_metadata)

    _get_number_of_bands_metadata = { "offset" : _get_number_of_bands_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def number_of_bands(self) -> int:
        """Get the number of bands comprising the raster."""
        return self._intf.get_property(IRasterAttributes._metadata, IRasterAttributes._get_number_of_bands_metadata)

    _get_row_stride_metadata = { "offset" : _get_row_stride_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def row_stride(self) -> int:
        """Get the stride or scan/row width in bytes of the raster data."""
        return self._intf.get_property(IRasterAttributes._metadata, IRasterAttributes._get_row_stride_metadata)

    _has_band_metadata = { "offset" : _has_band_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.EnumArg(RASTER_BAND), agmarshall.VariantBoolArg,) }
    def has_band(self, band:"RASTER_BAND") -> bool:
        """Get whether the raster contains the given band."""
        return self._intf.invoke(IRasterAttributes._metadata, IRasterAttributes._has_band_metadata, band, OutArg())

    _property_names[format] = "format"
    _property_names[type] = "type"
    _property_names[orientation] = "orientation"
    _property_names[byte_length] = "byte_length"
    _property_names[width] = "width"
    _property_names[height] = "height"
    _property_names[pixel_aspect_ratio] = "pixel_aspect_ratio"
    _property_names[row_alignment] = "row_alignment"
    _property_names[number_of_bands] = "number_of_bands"
    _property_names[row_stride] = "row_stride"


agcls.AgClassCatalog.add_catalog_entry((4735466585165008087, 2729013748843522195), IRasterAttributes)
agcls.AgTypeNameMap["IRasterAttributes"] = IRasterAttributes

class IRasterFilter(object):
    """A filter for processing raster datasets. RasterFilter is the base class for all raster filters..."""

    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "iid_data" : (5173582657377882717, 9127510129600190340),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IRasterFilter."""
        initialize_from_source_object(self, sourceObject, IRasterFilter)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IRasterFilter)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IRasterFilter, None)
    

agcls.AgClassCatalog.add_catalog_entry((5173582657377882717, 9127510129600190340), IRasterFilter)
agcls.AgTypeNameMap["IRasterFilter"] = IRasterFilter

class IRasterStream(object):
    """A raster, the data of which, is updated dynamically at the specified update delta. The class can be used to stream video and other dynamic raster data to textures and other raster clients..."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_update_delta_method_offset = 1
    _set_update_delta_method_offset = 2
    _update_method_offset = 3
    _metadata = {
        "iid_data" : (5206566972312003786, 8988437618500445837),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IRasterStream."""
        initialize_from_source_object(self, sourceObject, IRasterStream)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IRasterStream)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IRasterStream, None)
    
    _get_update_delta_metadata = { "offset" : _get_update_delta_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def update_delta(self) -> float:
        """Get or set the update delta of the raster stream in seconds. The update delta defines the interval at which the Update method will be called. The default update delta is 0, which will call the Update method every time the scene manager time changes..."""
        return self._intf.get_property(IRasterStream._metadata, IRasterStream._get_update_delta_metadata)

    _set_update_delta_metadata = { "offset" : _set_update_delta_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @update_delta.setter
    def update_delta(self, updateDelta:float) -> None:
        return self._intf.set_property(IRasterStream._metadata, IRasterStream._set_update_delta_metadata, updateDelta)

    _update_metadata = { "offset" : _update_method_offset,
            "arg_types" : (agcom.PVOID, agcom.PVOID, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.InterfaceInArg("IDate"), agmarshall.InterfaceInArg("IDate"), agmarshall.VariantBoolArg,) }
    def update(self, time:"IDate", nextTime:"IDate") -> bool:
        """When overridden in a derived class, updates the raster data associated with the raster stream at the specified time..."""
        return self._intf.invoke(IRasterStream._metadata, IRasterStream._update_metadata, time, nextTime, OutArg())

    _property_names[update_delta] = "update_delta"


agcls.AgClassCatalog.add_catalog_entry((5206566972312003786, 8988437618500445837), IRasterStream)
agcls.AgTypeNameMap["IRasterStream"] = IRasterStream

class IRotateFilter(object):
    """Rotate the source raster clockwise by the specified angle."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_angle_method_offset = 1
    _set_angle_method_offset = 2
    _metadata = {
        "iid_data" : (5284416578445493792, 4664926411814426046),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IRotateFilter."""
        initialize_from_source_object(self, sourceObject, IRotateFilter)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IRotateFilter)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IRotateFilter, None)
    
    _get_angle_metadata = { "offset" : _get_angle_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def angle(self) -> float:
        """Get or set the counterclockwise rotation angle."""
        return self._intf.get_property(IRotateFilter._metadata, IRotateFilter._get_angle_metadata)

    _set_angle_metadata = { "offset" : _set_angle_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @angle.setter
    def angle(self, angle:float) -> None:
        return self._intf.set_property(IRotateFilter._metadata, IRotateFilter._set_angle_metadata, angle)

    _property_names[angle] = "angle"


agcls.AgClassCatalog.add_catalog_entry((5284416578445493792, 4664926411814426046), IRotateFilter)
agcls.AgTypeNameMap["IRotateFilter"] = IRotateFilter

class ISequenceFilter(object):
    """Apply a sequence of filters to the source raster in the order in which they were added. When continue on failure is set to true, subsequent filters will still be applied to the source raster even if one or more filters in the sequence cannot be applied."""

    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_continue_on_failure_method_offset = 1
    _set_continue_on_failure_method_offset = 2
    _get_count_method_offset = 3
    _add_method_offset = 4
    _remove_method_offset = 5
    _clear_method_offset = 6
    _contains_method_offset = 7
    _metadata = {
        "iid_data" : (4723761315043259595, 8495024962827569328),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ISequenceFilter."""
        initialize_from_source_object(self, sourceObject, ISequenceFilter)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISequenceFilter)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ISequenceFilter, None)
    
    _get_continue_on_failure_metadata = { "offset" : _get_continue_on_failure_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def continue_on_failure(self) -> bool:
        """Get or set whether to continue applying filters in the sequence regardless of individual filter failures. When set to true, subsequent filters will still be applied to the source raster even if one or more filters in the sequence cannot be applied."""
        return self._intf.get_property(ISequenceFilter._metadata, ISequenceFilter._get_continue_on_failure_metadata)

    _set_continue_on_failure_metadata = { "offset" : _set_continue_on_failure_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @continue_on_failure.setter
    def continue_on_failure(self, continueOnFailure:bool) -> None:
        return self._intf.set_property(ISequenceFilter._metadata, ISequenceFilter._set_continue_on_failure_metadata, continueOnFailure)

    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def count(self) -> int:
        """Get the number of filters in the collection."""
        return self._intf.get_property(ISequenceFilter._metadata, ISequenceFilter._get_count_metadata)

    _add_metadata = { "offset" : _add_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IRasterFilter"),) }
    def add(self, filter:"IRasterFilter") -> None:
        """Add a filter to the sequence."""
        return self._intf.invoke(ISequenceFilter._metadata, ISequenceFilter._add_metadata, filter)

    _remove_metadata = { "offset" : _remove_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IRasterFilter"),) }
    def remove(self, filter:"IRasterFilter") -> None:
        """Remove a filter from the sequence."""
        return self._intf.invoke(ISequenceFilter._metadata, ISequenceFilter._remove_metadata, filter)

    _clear_metadata = { "offset" : _clear_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def clear(self) -> None:
        """Clear all filters from the sequence."""
        return self._intf.invoke(ISequenceFilter._metadata, ISequenceFilter._clear_metadata, )

    _contains_metadata = { "offset" : _contains_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.InterfaceInArg("IRasterFilter"), agmarshall.VariantBoolArg,) }
    def contains(self, filter:"IRasterFilter") -> bool:
        """Return true if the sequence contains the filter."""
        return self._intf.invoke(ISequenceFilter._metadata, ISequenceFilter._contains_metadata, filter, OutArg())

    _property_names[continue_on_failure] = "continue_on_failure"
    _property_names[count] = "count"


agcls.AgClassCatalog.add_catalog_entry((4723761315043259595, 8495024962827569328), ISequenceFilter)
agcls.AgTypeNameMap["ISequenceFilter"] = ISequenceFilter

class ISharpenFilter(object):
    """Apply a convolution filter to increase the sharpness of the source raster."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_method_method_offset = 1
    _set_method_method_offset = 2
    _metadata = {
        "iid_data" : (4866048002927502413, 16947294708104642190),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ISharpenFilter."""
        initialize_from_source_object(self, sourceObject, ISharpenFilter)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISharpenFilter)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ISharpenFilter, None)
    
    _get_method_metadata = { "offset" : _get_method_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(SHARPEN_METHOD),) }
    @property
    def method(self) -> "SHARPEN_METHOD":
        """Get or set the method used to sharpen the source raster."""
        return self._intf.get_property(ISharpenFilter._metadata, ISharpenFilter._get_method_metadata)

    _set_method_metadata = { "offset" : _set_method_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(SHARPEN_METHOD),) }
    @method.setter
    def method(self, method:"SHARPEN_METHOD") -> None:
        return self._intf.set_property(ISharpenFilter._metadata, ISharpenFilter._set_method_metadata, method)

    _property_names[method] = "method"


agcls.AgClassCatalog.add_catalog_entry((4866048002927502413, 16947294708104642190), ISharpenFilter)
agcls.AgTypeNameMap["ISharpenFilter"] = ISharpenFilter

class IVideoStream(object):
    """A raster stream that streams from a video. The video can be read from a file, or streamed from an HTTP, RTP, UDP, or TCP source. See the Video Streams Overview for a list of supported video formats and Uri usage."""

    _num_methods = 35
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_uri_method_offset = 1
    _get_playback_method_offset = 2
    _set_playback_method_offset = 3
    _get_frame_rate_method_offset = 4
    _set_frame_rate_method_offset = 5
    _get_interval_start_time_method_offset = 6
    _set_interval_start_time_method_offset = 7
    _get_interval_end_time_method_offset = 8
    _set_interval_end_time_method_offset = 9
    _get_start_time_method_offset = 10
    _set_start_time_method_offset = 11
    _get_end_time_method_offset = 12
    _set_end_time_method_offset = 13
    _get_start_frame_method_offset = 14
    _set_start_frame_method_offset = 15
    _get_end_frame_method_offset = 16
    _set_end_frame_method_offset = 17
    _get_loop_method_offset = 18
    _set_loop_method_offset = 19
    _get_is_playing_method_offset = 20
    _get_packet_acquirement_yield_time_method_offset = 21
    _set_packet_acquirement_yield_time_method_offset = 22
    _get_packet_buffer_limit_method_offset = 23
    _set_packet_buffer_limit_method_offset = 24
    _get_allow_frame_drop_method_offset = 25
    _set_allow_frame_drop_method_offset = 26
    _get_enable_audio_method_offset = 27
    _set_enable_audio_method_offset = 28
    _reinitialize_with_string_uri_method_offset = 29
    _play_method_offset = 30
    _pause_method_offset = 31
    _stop_method_offset = 32
    _reset_method_offset = 33
    _close_method_offset = 34
    _get_audio_uri_method_offset = 35
    _metadata = {
        "iid_data" : (5243502072694622494, 5354655161679499171),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IVideoStream."""
        initialize_from_source_object(self, sourceObject, IVideoStream)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVideoStream)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IVideoStream, None)
    
    _get_uri_metadata = { "offset" : _get_uri_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def uri(self) -> str:
        """Get the uri of the video."""
        return self._intf.get_property(IVideoStream._metadata, IVideoStream._get_uri_metadata)

    _get_playback_metadata = { "offset" : _get_playback_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(VIDEO_PLAYBACK),) }
    @property
    def playback(self) -> "VIDEO_PLAYBACK":
        """Get or set the video playback mode of the video."""
        return self._intf.get_property(IVideoStream._metadata, IVideoStream._get_playback_metadata)

    _set_playback_metadata = { "offset" : _set_playback_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(VIDEO_PLAYBACK),) }
    @playback.setter
    def playback(self, playback:"VIDEO_PLAYBACK") -> None:
        return self._intf.set_property(IVideoStream._metadata, IVideoStream._set_playback_metadata, playback)

    _get_frame_rate_metadata = { "offset" : _get_frame_rate_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def frame_rate(self) -> float:
        """Get or set the frame rate of the video when the playback property is set to real time. If this property is not set, the internal framerate of the video is used."""
        return self._intf.get_property(IVideoStream._metadata, IVideoStream._get_frame_rate_metadata)

    _set_frame_rate_metadata = { "offset" : _set_frame_rate_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @frame_rate.setter
    def frame_rate(self, frameRate:float) -> None:
        return self._intf.set_property(IVideoStream._metadata, IVideoStream._set_frame_rate_metadata, frameRate)

    _get_interval_start_time_metadata = { "offset" : _get_interval_start_time_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def interval_start_time(self) -> "IDate":
        """Get or set the scene manager time at which the video will begin playing when the playback property is set to time interval."""
        return self._intf.get_property(IVideoStream._metadata, IVideoStream._get_interval_start_time_metadata)

    _set_interval_start_time_metadata = { "offset" : _set_interval_start_time_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IDate"),) }
    @interval_start_time.setter
    def interval_start_time(self, intervalStartTime:"IDate") -> None:
        return self._intf.set_property(IVideoStream._metadata, IVideoStream._set_interval_start_time_metadata, intervalStartTime)

    _get_interval_end_time_metadata = { "offset" : _get_interval_end_time_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def interval_end_time(self) -> "IDate":
        """Get or set the scene manager time at which the video will stop playing when the playback property is set to time interval."""
        return self._intf.get_property(IVideoStream._metadata, IVideoStream._get_interval_end_time_metadata)

    _set_interval_end_time_metadata = { "offset" : _set_interval_end_time_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IDate"),) }
    @interval_end_time.setter
    def interval_end_time(self, intervalEndTime:"IDate") -> None:
        return self._intf.set_property(IVideoStream._metadata, IVideoStream._set_interval_end_time_metadata, intervalEndTime)

    _get_start_time_metadata = { "offset" : _get_start_time_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def start_time(self) -> float:
        """Get or set the start time of the video in seconds. Changing the start time property also changes the start frame property to the frame in the video that corresponds to the specified time."""
        return self._intf.get_property(IVideoStream._metadata, IVideoStream._get_start_time_metadata)

    _set_start_time_metadata = { "offset" : _set_start_time_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @start_time.setter
    def start_time(self, startTime:float) -> None:
        return self._intf.set_property(IVideoStream._metadata, IVideoStream._set_start_time_metadata, startTime)

    _get_end_time_metadata = { "offset" : _get_end_time_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def end_time(self) -> float:
        """Get or set the end time of the video in seconds. Changing the end time property also changes the end frame property to the frame in the video that corresponds to the specified time."""
        return self._intf.get_property(IVideoStream._metadata, IVideoStream._get_end_time_metadata)

    _set_end_time_metadata = { "offset" : _set_end_time_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @end_time.setter
    def end_time(self, endTime:float) -> None:
        return self._intf.set_property(IVideoStream._metadata, IVideoStream._set_end_time_metadata, endTime)

    _get_start_frame_metadata = { "offset" : _get_start_frame_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def start_frame(self) -> int:
        """Get or set the start frame of the video. Changing the start frame property also changes the start time property to the time in the video that corresponds to the specified frame."""
        return self._intf.get_property(IVideoStream._metadata, IVideoStream._get_start_frame_metadata)

    _set_start_frame_metadata = { "offset" : _set_start_frame_method_offset,
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.IntArg,) }
    @start_frame.setter
    def start_frame(self, startFrame:int) -> None:
        return self._intf.set_property(IVideoStream._metadata, IVideoStream._set_start_frame_metadata, startFrame)

    _get_end_frame_metadata = { "offset" : _get_end_frame_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def end_frame(self) -> int:
        """Get or set the end frame of the video. Changing the end frame property also changes the end time property to the time in the video that corresponds to the specified frame."""
        return self._intf.get_property(IVideoStream._metadata, IVideoStream._get_end_frame_metadata)

    _set_end_frame_metadata = { "offset" : _set_end_frame_method_offset,
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.IntArg,) }
    @end_frame.setter
    def end_frame(self, endFrame:int) -> None:
        return self._intf.set_property(IVideoStream._metadata, IVideoStream._set_end_frame_metadata, endFrame)

    _get_loop_metadata = { "offset" : _get_loop_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def loop(self) -> bool:
        """Get or set whether the video will loop when it reaches its last frame when the playback property is set to real time."""
        return self._intf.get_property(IVideoStream._metadata, IVideoStream._get_loop_metadata)

    _set_loop_metadata = { "offset" : _set_loop_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @loop.setter
    def loop(self, loop:bool) -> None:
        return self._intf.set_property(IVideoStream._metadata, IVideoStream._set_loop_metadata, loop)

    _get_is_playing_metadata = { "offset" : _get_is_playing_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_playing(self) -> bool:
        """Get whether or not the video is playing. Use the play, pause, stop, and Reset methods to control the playback of the video when the playback property is set to real time."""
        return self._intf.get_property(IVideoStream._metadata, IVideoStream._get_is_playing_metadata)

    _get_packet_acquirement_yield_time_metadata = { "offset" : _get_packet_acquirement_yield_time_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def packet_acquirement_yield_time(self) -> int:
        """Get or set the thread processing yield time for asynchronous streaming of video over common protocols like udp. Setting a high value may increase performance, but may cause frames or packets to drop, effecting visual quality..."""
        return self._intf.get_property(IVideoStream._metadata, IVideoStream._get_packet_acquirement_yield_time_metadata)

    _set_packet_acquirement_yield_time_metadata = { "offset" : _set_packet_acquirement_yield_time_method_offset,
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.IntArg,) }
    @packet_acquirement_yield_time.setter
    def packet_acquirement_yield_time(self, packetAcquirementYieldTime:int) -> None:
        return self._intf.set_property(IVideoStream._metadata, IVideoStream._set_packet_acquirement_yield_time_metadata, packetAcquirementYieldTime)

    _get_packet_buffer_limit_metadata = { "offset" : _get_packet_buffer_limit_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def packet_buffer_limit(self) -> int:
        """Get or set a value indicating the buffering limit for packets when processing a video stream..."""
        return self._intf.get_property(IVideoStream._metadata, IVideoStream._get_packet_buffer_limit_metadata)

    _set_packet_buffer_limit_metadata = { "offset" : _set_packet_buffer_limit_method_offset,
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.IntArg,) }
    @packet_buffer_limit.setter
    def packet_buffer_limit(self, packetBufferLimit:int) -> None:
        return self._intf.set_property(IVideoStream._metadata, IVideoStream._set_packet_buffer_limit_metadata, packetBufferLimit)

    _get_allow_frame_drop_metadata = { "offset" : _get_allow_frame_drop_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def allow_frame_drop(self) -> bool:
        """Get or set a value indicating if frames should be dropped if video processing can not keep up with a video stream. If this is set to false, the video quality may degrade when the processing load is too high..."""
        return self._intf.get_property(IVideoStream._metadata, IVideoStream._get_allow_frame_drop_metadata)

    _set_allow_frame_drop_metadata = { "offset" : _set_allow_frame_drop_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @allow_frame_drop.setter
    def allow_frame_drop(self, allowFrameDrop:bool) -> None:
        return self._intf.set_property(IVideoStream._metadata, IVideoStream._set_allow_frame_drop_metadata, allowFrameDrop)

    _get_enable_audio_metadata = { "offset" : _get_enable_audio_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def enable_audio(self) -> bool:
        """Get or set a value indicating if the encoded audio stream should be synchronized to video playback If this is set to false, the audio stream will be disabled..."""
        return self._intf.get_property(IVideoStream._metadata, IVideoStream._get_enable_audio_metadata)

    _set_enable_audio_metadata = { "offset" : _set_enable_audio_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @enable_audio.setter
    def enable_audio(self, enableAudio:bool) -> None:
        return self._intf.set_property(IVideoStream._metadata, IVideoStream._set_enable_audio_metadata, enableAudio)

    _reinitialize_with_string_uri_metadata = { "offset" : _reinitialize_with_string_uri_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    def reinitialize_with_string_uri(self, uri:str) -> None:
        """Reinitializes the video stream from a Uri, which can be a file, HTTP, RTP, UDP, or TCP source. See the Video Streams Overview for a list of supported video formats and Uri usage."""
        return self._intf.invoke(IVideoStream._metadata, IVideoStream._reinitialize_with_string_uri_metadata, uri)

    _play_metadata = { "offset" : _play_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def play(self) -> None:
        """Begins playing the video when the playback property is set to real time."""
        return self._intf.invoke(IVideoStream._metadata, IVideoStream._play_metadata, )

    _pause_metadata = { "offset" : _pause_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def pause(self) -> None:
        """Pauses the video when the playback property is set to real time."""
        return self._intf.invoke(IVideoStream._metadata, IVideoStream._pause_metadata, )

    _stop_metadata = { "offset" : _stop_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def stop(self) -> None:
        """Stop the video when the playback property is set to real time. Stopping the video will seek to the first frame and pause playback. Use the Play method to begin playing the video again."""
        return self._intf.invoke(IVideoStream._metadata, IVideoStream._stop_metadata, )

    _reset_metadata = { "offset" : _reset_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def reset(self) -> None:
        """Seeks the video to its first frame and begins playing the video when the playback property is set to real time."""
        return self._intf.invoke(IVideoStream._metadata, IVideoStream._reset_metadata, )

    _close_metadata = { "offset" : _close_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def close(self) -> None:
        """Close the video stream and any associated resources."""
        return self._intf.invoke(IVideoStream._metadata, IVideoStream._close_metadata, )

    _get_audio_uri_metadata = { "offset" : _get_audio_uri_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def audio_uri(self) -> str:
        """Get the uri of the audio."""
        return self._intf.get_property(IVideoStream._metadata, IVideoStream._get_audio_uri_metadata)

    _property_names[uri] = "uri"
    _property_names[playback] = "playback"
    _property_names[frame_rate] = "frame_rate"
    _property_names[interval_start_time] = "interval_start_time"
    _property_names[interval_end_time] = "interval_end_time"
    _property_names[start_time] = "start_time"
    _property_names[end_time] = "end_time"
    _property_names[start_frame] = "start_frame"
    _property_names[end_frame] = "end_frame"
    _property_names[loop] = "loop"
    _property_names[is_playing] = "is_playing"
    _property_names[packet_acquirement_yield_time] = "packet_acquirement_yield_time"
    _property_names[packet_buffer_limit] = "packet_buffer_limit"
    _property_names[allow_frame_drop] = "allow_frame_drop"
    _property_names[enable_audio] = "enable_audio"
    _property_names[audio_uri] = "audio_uri"


agcls.AgClassCatalog.add_catalog_entry((5243502072694622494, 5354655161679499171), IVideoStream)
agcls.AgTypeNameMap["IVideoStream"] = IVideoStream

class IKmlContainer(object):
    """A KmlContainer contains a collection of children kml features."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_children_method_offset = 1
    _metadata = {
        "iid_data" : (4787473808012639137, 8060652129531487635),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IKmlContainer."""
        initialize_from_source_object(self, sourceObject, IKmlContainer)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IKmlContainer)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IKmlContainer, None)
    
    _get_children_metadata = { "offset" : _get_children_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def children(self) -> "KmlFeatureCollection":
        """The collection of kml features that are children of this container."""
        return self._intf.get_property(IKmlContainer._metadata, IKmlContainer._get_children_metadata)

    _property_names[children] = "children"


agcls.AgClassCatalog.add_catalog_entry((4787473808012639137, 8060652129531487635), IKmlContainer)
agcls.AgTypeNameMap["IKmlContainer"] = IKmlContainer

class IKmlDocument(object):
    """A KML document."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_uri_method_offset = 1
    _metadata = {
        "iid_data" : (5741031632277098238, 15148679251139210129),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IKmlDocument."""
        initialize_from_source_object(self, sourceObject, IKmlDocument)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IKmlDocument)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IKmlDocument, None)
    
    _get_uri_metadata = { "offset" : _get_uri_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def uri(self) -> str:
        """Get the uri of the document."""
        return self._intf.get_property(IKmlDocument._metadata, IKmlDocument._get_uri_metadata)

    _property_names[uri] = "uri"


agcls.AgClassCatalog.add_catalog_entry((5741031632277098238, 15148679251139210129), IKmlDocument)
agcls.AgTypeNameMap["IKmlDocument"] = IKmlDocument

class IKmlFeature(object):
    """A KML feature."""

    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_is_loaded_method_offset = 1
    _get_display_method_offset = 2
    _set_display_method_offset = 3
    _get_content_method_offset = 4
    _get_name_method_offset = 5
    _get_description_method_offset = 6
    _get_snippet_method_offset = 7
    _get_bounding_sphere_method_offset = 8
    _fly_to_method_offset = 9
    _metadata = {
        "iid_data" : (5360086555408352970, 584045744064033934),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IKmlFeature."""
        initialize_from_source_object(self, sourceObject, IKmlFeature)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IKmlFeature)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IKmlFeature, None)
    
    _get_is_loaded_metadata = { "offset" : _get_is_loaded_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_loaded(self) -> bool:
        """Get whether the document associated with this feature is loaded."""
        return self._intf.get_property(IKmlFeature._metadata, IKmlFeature._get_is_loaded_metadata)

    _get_display_metadata = { "offset" : _get_display_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def display(self) -> bool:
        """Get or set whether this feature will be displayed in the Scene."""
        return self._intf.get_property(IKmlFeature._metadata, IKmlFeature._get_display_metadata)

    _set_display_metadata = { "offset" : _set_display_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @display.setter
    def display(self, display:bool) -> None:
        return self._intf.set_property(IKmlFeature._metadata, IKmlFeature._set_display_metadata, display)

    _get_content_metadata = { "offset" : _get_content_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def content(self) -> str:
        """Get the content associated with this feature."""
        return self._intf.get_property(IKmlFeature._metadata, IKmlFeature._get_content_metadata)

    _get_name_metadata = { "offset" : _get_name_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def name(self) -> str:
        """Get the name of this feature."""
        return self._intf.get_property(IKmlFeature._metadata, IKmlFeature._get_name_metadata)

    _get_description_metadata = { "offset" : _get_description_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def description(self) -> str:
        """Get the description associated with this feature."""
        return self._intf.get_property(IKmlFeature._metadata, IKmlFeature._get_description_metadata)

    _get_snippet_metadata = { "offset" : _get_snippet_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def snippet(self) -> str:
        """Get the snippet associated with this feature."""
        return self._intf.get_property(IKmlFeature._metadata, IKmlFeature._get_snippet_metadata)

    _get_bounding_sphere_metadata = { "offset" : _get_bounding_sphere_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def bounding_sphere(self) -> "BoundingSphere":
        """The bounding sphere encompassing the area associated with this feature."""
        return self._intf.get_property(IKmlFeature._metadata, IKmlFeature._get_bounding_sphere_metadata)

    _fly_to_metadata = { "offset" : _fly_to_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def fly_to(self) -> None:
        """Move the camera to the area encompassing this feature."""
        return self._intf.invoke(IKmlFeature._metadata, IKmlFeature._fly_to_metadata, )

    _property_names[is_loaded] = "is_loaded"
    _property_names[display] = "display"
    _property_names[content] = "content"
    _property_names[name] = "name"
    _property_names[description] = "description"
    _property_names[snippet] = "snippet"
    _property_names[bounding_sphere] = "bounding_sphere"


agcls.AgClassCatalog.add_catalog_entry((5360086555408352970, 584045744064033934), IKmlFeature)
agcls.AgTypeNameMap["IKmlFeature"] = IKmlFeature

class IKmlFolder(object):
    """A KML folder."""

    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "iid_data" : (5086621492657184689, 2300093376995260832),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IKmlFolder."""
        initialize_from_source_object(self, sourceObject, IKmlFolder)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IKmlFolder)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IKmlFolder, None)
    

agcls.AgClassCatalog.add_catalog_entry((5086621492657184689, 2300093376995260832), IKmlFolder)
agcls.AgTypeNameMap["IKmlFolder"] = IKmlFolder

class IKmlGraphics(object):
    """Provide loading and unloading of kml documents for a particular central body."""

    _num_methods = 9
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_documents_method_offset = 1
    _load_document_method_offset = 2
    _load_document_string_method_offset = 3
    _load_method_offset = 4
    _load_document_async_method_offset = 5
    _load_document_async_string_method_offset = 6
    _load_async_method_offset = 7
    _unload_method_offset = 8
    _unload_all_method_offset = 9
    _metadata = {
        "iid_data" : (5576095172211422984, 18055224525665917108),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IKmlGraphics."""
        initialize_from_source_object(self, sourceObject, IKmlGraphics)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IKmlGraphics)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IKmlGraphics, None)
    def Subscribe(self) -> IKmlGraphicsEventHandler:
        """Return an IKmlGraphicsEventHandler that is subscribed to handle events associated with this instance of IKmlGraphics."""
        return IKmlGraphicsEventHandler(self._intf)
    
    _get_documents_metadata = { "offset" : _get_documents_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def documents(self) -> "KmlDocumentCollection":
        """The collection of kml documents that are currently loaded."""
        return self._intf.get_property(IKmlGraphics._metadata, IKmlGraphics._get_documents_metadata)

    _load_document_metadata = { "offset" : _load_document_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def load_document(self, kmlUri:str) -> "KmlDocument":
        """Load a kml document from a uri."""
        return self._intf.invoke(IKmlGraphics._metadata, IKmlGraphics._load_document_metadata, kmlUri, OutArg())

    _load_document_string_metadata = { "offset" : _load_document_string_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def load_document_string(self, kmlUri:str) -> "KmlDocument":
        """Load a kml document from a Uri."""
        return self._intf.invoke(IKmlGraphics._metadata, IKmlGraphics._load_document_string_metadata, kmlUri, OutArg())

    _load_metadata = { "offset" : _load_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def load(self, kmlDocument:str) -> "KmlDocument":
        """Load a kml document from a string containing the document."""
        return self._intf.invoke(IKmlGraphics._metadata, IKmlGraphics._load_metadata, kmlDocument, OutArg())

    _load_document_async_metadata = { "offset" : _load_document_async_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    def load_document_async(self, kmlUri:str) -> None:
        """Load a kml document asynchronously from a uri. The document loaded event is raised when the document is loaded."""
        return self._intf.invoke(IKmlGraphics._metadata, IKmlGraphics._load_document_async_metadata, kmlUri)

    _load_document_async_string_metadata = { "offset" : _load_document_async_string_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    def load_document_async_string(self, kmlUri:str) -> None:
        """Load a kml document asynchronously from a Uri. The document loaded event is raised when the document is loaded."""
        return self._intf.invoke(IKmlGraphics._metadata, IKmlGraphics._load_document_async_string_metadata, kmlUri)

    _load_async_metadata = { "offset" : _load_async_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    def load_async(self, kmlDocument:str) -> None:
        """Load a kml document asynchronously from a string containing the document. The document loaded event is raised when the document is loaded."""
        return self._intf.invoke(IKmlGraphics._metadata, IKmlGraphics._load_async_metadata, kmlDocument)

    _unload_metadata = { "offset" : _unload_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IKmlDocument"),) }
    def unload(self, kmlDocument:"IKmlDocument") -> None:
        """Unloads a kml document. All associated visual features will be removed from the Scene. Once a KmlDocument is unloaded, it is no longer valid and will throw when accessing properties or methods."""
        return self._intf.invoke(IKmlGraphics._metadata, IKmlGraphics._unload_metadata, kmlDocument)

    _unload_all_metadata = { "offset" : _unload_all_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def unload_all(self) -> None:
        """Unloads all kml documents associated with this central body. All associated visual features will be removed from the Scene. Once a KmlDocument is unloaded, it is no longer valid and will throw when accessing properties or methods."""
        return self._intf.invoke(IKmlGraphics._metadata, IKmlGraphics._unload_all_metadata, )

    _property_names[documents] = "documents"


agcls.AgClassCatalog.add_catalog_entry((5576095172211422984, 18055224525665917108), IKmlGraphics)
agcls.AgTypeNameMap["IKmlGraphics"] = IKmlGraphics

class IKmlNetworkLink(object):
    """A KML network link."""

    _num_methods = 17
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_uri_method_offset = 1
    _get_refresh_mode_method_offset = 2
    _set_refresh_mode_method_offset = 3
    _get_refresh_interval_method_offset = 4
    _set_refresh_interval_method_offset = 5
    _get_view_refresh_mode_method_offset = 6
    _set_view_refresh_mode_method_offset = 7
    _get_view_refresh_time_method_offset = 8
    _set_view_refresh_time_method_offset = 9
    _get_view_bound_scale_method_offset = 10
    _set_view_bound_scale_method_offset = 11
    _get_minimum_refresh_period_method_offset = 12
    _get_cookie_method_offset = 13
    _get_message_method_offset = 14
    _get_link_snippet_method_offset = 15
    _get_expires_method_offset = 16
    _refresh_method_offset = 17
    _metadata = {
        "iid_data" : (4922395965834848898, 9735513844274272176),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IKmlNetworkLink."""
        initialize_from_source_object(self, sourceObject, IKmlNetworkLink)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IKmlNetworkLink)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IKmlNetworkLink, None)
    
    _get_uri_metadata = { "offset" : _get_uri_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def uri(self) -> str:
        """Get the uri of the network link."""
        return self._intf.get_property(IKmlNetworkLink._metadata, IKmlNetworkLink._get_uri_metadata)

    _get_refresh_mode_metadata = { "offset" : _get_refresh_mode_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(KML_NETWORK_LINK_REFRESH_MODE),) }
    @property
    def refresh_mode(self) -> "KML_NETWORK_LINK_REFRESH_MODE":
        """Get or set the refresh mode of the network link. The refresh mode specifies a time-based refresh policy for this link."""
        return self._intf.get_property(IKmlNetworkLink._metadata, IKmlNetworkLink._get_refresh_mode_metadata)

    _set_refresh_mode_metadata = { "offset" : _set_refresh_mode_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(KML_NETWORK_LINK_REFRESH_MODE),) }
    @refresh_mode.setter
    def refresh_mode(self, refreshMode:"KML_NETWORK_LINK_REFRESH_MODE") -> None:
        return self._intf.set_property(IKmlNetworkLink._metadata, IKmlNetworkLink._set_refresh_mode_metadata, refreshMode)

    _get_refresh_interval_metadata = { "offset" : _get_refresh_interval_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def refresh_interval(self) -> float:
        """Get or set the interval duration at which this network link will refresh, when refresh mode is set to on interval."""
        return self._intf.get_property(IKmlNetworkLink._metadata, IKmlNetworkLink._get_refresh_interval_metadata)

    _set_refresh_interval_metadata = { "offset" : _set_refresh_interval_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @refresh_interval.setter
    def refresh_interval(self, refreshInterval:float) -> None:
        return self._intf.set_property(IKmlNetworkLink._metadata, IKmlNetworkLink._set_refresh_interval_metadata, refreshInterval)

    _get_view_refresh_mode_metadata = { "offset" : _get_view_refresh_mode_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(KML_NETWORK_LINK_VIEW_REFRESH_MODE),) }
    @property
    def view_refresh_mode(self) -> "KML_NETWORK_LINK_VIEW_REFRESH_MODE":
        """Get or set the view refresh mode of the network link. The view refresh mode specifies the refresh policy for the when the camera's view changes."""
        return self._intf.get_property(IKmlNetworkLink._metadata, IKmlNetworkLink._get_view_refresh_mode_metadata)

    _set_view_refresh_mode_metadata = { "offset" : _set_view_refresh_mode_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(KML_NETWORK_LINK_VIEW_REFRESH_MODE),) }
    @view_refresh_mode.setter
    def view_refresh_mode(self, viewRefreshMode:"KML_NETWORK_LINK_VIEW_REFRESH_MODE") -> None:
        return self._intf.set_property(IKmlNetworkLink._metadata, IKmlNetworkLink._set_view_refresh_mode_metadata, viewRefreshMode)

    _get_view_refresh_time_metadata = { "offset" : _get_view_refresh_time_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def view_refresh_time(self) -> float:
        """Get or set the duration after camera view movement stops that this network link will refresh, when view refresh mode is set to on stop."""
        return self._intf.get_property(IKmlNetworkLink._metadata, IKmlNetworkLink._get_view_refresh_time_metadata)

    _set_view_refresh_time_metadata = { "offset" : _set_view_refresh_time_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @view_refresh_time.setter
    def view_refresh_time(self, viewRefreshTime:float) -> None:
        return self._intf.set_property(IKmlNetworkLink._metadata, IKmlNetworkLink._set_view_refresh_time_metadata, viewRefreshTime)

    _get_view_bound_scale_metadata = { "offset" : _get_view_bound_scale_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def view_bound_scale(self) -> float:
        """Get or set the value that scales the bounding box defining the view associated with this network link. A value less than 1.0 specifies to use less than the full view (screen). A value greater than 1..."""
        return self._intf.get_property(IKmlNetworkLink._metadata, IKmlNetworkLink._get_view_bound_scale_metadata)

    _set_view_bound_scale_metadata = { "offset" : _set_view_bound_scale_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @view_bound_scale.setter
    def view_bound_scale(self, viewBoundScale:float) -> None:
        return self._intf.set_property(IKmlNetworkLink._metadata, IKmlNetworkLink._set_view_bound_scale_metadata, viewBoundScale)

    _get_minimum_refresh_period_metadata = { "offset" : _get_minimum_refresh_period_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def minimum_refresh_period(self) -> float:
        """Get the duration that is the minimum allowed time between refreshes of this network link."""
        return self._intf.get_property(IKmlNetworkLink._metadata, IKmlNetworkLink._get_minimum_refresh_period_metadata)

    _get_cookie_metadata = { "offset" : _get_cookie_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def cookie(self) -> str:
        """Get the cookie string associated with this network link."""
        return self._intf.get_property(IKmlNetworkLink._metadata, IKmlNetworkLink._get_cookie_metadata)

    _get_message_metadata = { "offset" : _get_message_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def message(self) -> str:
        """Get the message string associated with this network link."""
        return self._intf.get_property(IKmlNetworkLink._metadata, IKmlNetworkLink._get_message_metadata)

    _get_link_snippet_metadata = { "offset" : _get_link_snippet_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def link_snippet(self) -> str:
        """Get the link snippet associated with this network link."""
        return self._intf.get_property(IKmlNetworkLink._metadata, IKmlNetworkLink._get_link_snippet_metadata)

    _get_expires_metadata = { "offset" : _get_expires_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def expires(self) -> str:
        """Get the string specifying the date/time this network should expire and be refreshed."""
        return self._intf.get_property(IKmlNetworkLink._metadata, IKmlNetworkLink._get_expires_metadata)

    _refresh_metadata = { "offset" : _refresh_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def refresh(self) -> None:
        """Refresh the network link."""
        return self._intf.invoke(IKmlNetworkLink._metadata, IKmlNetworkLink._refresh_metadata, )

    _property_names[uri] = "uri"
    _property_names[refresh_mode] = "refresh_mode"
    _property_names[refresh_interval] = "refresh_interval"
    _property_names[view_refresh_mode] = "view_refresh_mode"
    _property_names[view_refresh_time] = "view_refresh_time"
    _property_names[view_bound_scale] = "view_bound_scale"
    _property_names[minimum_refresh_period] = "minimum_refresh_period"
    _property_names[cookie] = "cookie"
    _property_names[message] = "message"
    _property_names[link_snippet] = "link_snippet"
    _property_names[expires] = "expires"


agcls.AgClassCatalog.add_catalog_entry((4922395965834848898, 9735513844274272176), IKmlNetworkLink)
agcls.AgTypeNameMap["IKmlNetworkLink"] = IKmlNetworkLink

class IMarkerBatchPrimitive(object):
    """Render one or more markers in the 3D scene. Markers are 2D images that always face the viewer which can be sized in pixels or meters. Markers are also referred to as sprites or billboards..."""

    _num_methods = 54
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_size_source_method_offset = 1
    _get_sort_order_method_offset = 2
    _get_set_hint_method_offset = 3
    _get_rendering_method_method_offset = 4
    _get_render_pass_method_offset = 5
    _set_render_pass_method_offset = 6
    _get_bounding_sphere_scale_method_offset = 7
    _set_bounding_sphere_scale_method_offset = 8
    _get_distance_display_condition_per_marker_method_offset = 9
    _set_distance_display_condition_per_marker_method_offset = 10
    _get_texture_method_offset = 11
    _set_texture_method_offset = 12
    _get_size_unit_method_offset = 13
    _set_size_unit_method_offset = 14
    _get_size_method_offset = 15
    _set_size_method_offset = 16
    _get_origin_method_offset = 17
    _set_origin_method_offset = 18
    _get_pixel_offset_method_offset = 19
    _set_pixel_offset_method_offset = 20
    _get_eye_offset_method_offset = 21
    _set_eye_offset_method_offset = 22
    _get_rotation_method_offset = 23
    _set_rotation_method_offset = 24
    _get_texture_coordinate_method_offset = 25
    _set_texture_coordinate_method_offset = 26
    _get_wireframe_method_offset = 27
    _set_wireframe_method_offset = 28
    _get_per_item_picking_enabled_method_offset = 29
    _set_per_item_picking_enabled_method_offset = 30
    _get_texture_filter_method_offset = 31
    _set_texture_filter_method_offset = 32
    _set_method_offset = 33
    _set_with_optional_parameters_method_offset = 34
    _set_with_optional_parameters_and_render_pass_hint_method_offset = 35
    _set_cartographic_method_offset = 36
    _set_cartographic_with_optional_parameters_method_offset = 37
    _set_cartographic_with_optional_parameters_and_render_pass_hint_method_offset = 38
    _set_partial_method_offset = 39
    _set_partial_with_indices_order_method_offset = 40
    _set_partial_with_optional_parameters_method_offset = 41
    _set_partial_with_optional_parameters_indices_order_and_render_pass_method_offset = 42
    _set_partial_cartographic_method_offset = 43
    _set_partial_cartographic_with_indices_order_method_offset = 44
    _set_partial_cartographic_with_optional_parameters_method_offset = 45
    _set_partial_cartographic_with_optional_parameters_indices_order_and_render_pass_method_offset = 46
    _supported_method_offset = 47
    _get_clamp_to_pixel_method_offset = 48
    _set_clamp_to_pixel_method_offset = 49
    _get_central_body_clipped_method_offset = 50
    _set_central_body_clipped_method_offset = 51
    _align_to_screen_method_offset = 52
    _align_to_north_method_offset = 53
    _align_to_axis_method_offset = 54
    _metadata = {
        "iid_data" : (5541225076266399937, 16789973218996649861),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IMarkerBatchPrimitive."""
        initialize_from_source_object(self, sourceObject, IMarkerBatchPrimitive)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IMarkerBatchPrimitive)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IMarkerBatchPrimitive, None)
    
    _get_size_source_metadata = { "offset" : _get_size_source_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(MARKER_BATCH_SIZE_SOURCE),) }
    @property
    def size_source(self) -> "MARKER_BATCH_SIZE_SOURCE":
        """Get the source used for the size of markers in the batch."""
        return self._intf.get_property(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._get_size_source_metadata)

    _get_sort_order_metadata = { "offset" : _get_sort_order_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(MARKER_BATCH_SORT_ORDER),) }
    @property
    def sort_order(self) -> "MARKER_BATCH_SORT_ORDER":
        """Get the order in which markers in the marker batch are sorted before rendering."""
        return self._intf.get_property(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._get_sort_order_metadata)

    _get_set_hint_metadata = { "offset" : _get_set_hint_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(SET_HINT),) }
    @property
    def set_hint(self) -> "SET_HINT":
        """Get the primitive's set hint. See the Set Hint Performance Overview for selecting an appropriate value to construct the primitive with."""
        return self._intf.get_property(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._get_set_hint_metadata)

    _get_rendering_method_metadata = { "offset" : _get_rendering_method_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(MARKER_BATCH_RENDERING_METHOD),) }
    @property
    def rendering_method(self) -> "MARKER_BATCH_RENDERING_METHOD":
        """Get the rendering method used to render the marker batch."""
        return self._intf.get_property(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._get_rendering_method_metadata)

    _get_render_pass_metadata = { "offset" : _get_render_pass_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(MARKER_BATCH_RENDER_PASS),) }
    @property
    def render_pass(self) -> "MARKER_BATCH_RENDER_PASS":
        """Get or set the pass during which the marker batch is rendered."""
        return self._intf.get_property(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._get_render_pass_metadata)

    _set_render_pass_metadata = { "offset" : _set_render_pass_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(MARKER_BATCH_RENDER_PASS),) }
    @render_pass.setter
    def render_pass(self, renderPass:"MARKER_BATCH_RENDER_PASS") -> None:
        return self._intf.set_property(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._set_render_pass_metadata, renderPass)

    _get_bounding_sphere_scale_metadata = { "offset" : _get_bounding_sphere_scale_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def bounding_sphere_scale(self) -> float:
        """Get or set the scale applied to the radius of this primitive's bounding sphere."""
        return self._intf.get_property(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._get_bounding_sphere_scale_metadata)

    _set_bounding_sphere_scale_metadata = { "offset" : _set_bounding_sphere_scale_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @bounding_sphere_scale.setter
    def bounding_sphere_scale(self, boundingSphereScale:float) -> None:
        return self._intf.set_property(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._set_bounding_sphere_scale_metadata, boundingSphereScale)

    _get_distance_display_condition_per_marker_metadata = { "offset" : _get_distance_display_condition_per_marker_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def distance_display_condition_per_marker(self) -> "DistanceDisplayCondition":
        """Get or set a distance display condition that is evaluated per marker in the marker batch during rendering. This is different than display condition, which is evaluated once for the entire marker batch..."""
        return self._intf.get_property(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._get_distance_display_condition_per_marker_metadata)

    _set_distance_display_condition_per_marker_metadata = { "offset" : _set_distance_display_condition_per_marker_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IDistanceDisplayCondition"),) }
    @distance_display_condition_per_marker.setter
    def distance_display_condition_per_marker(self, distanceDisplayConditionPerMarker:"IDistanceDisplayCondition") -> None:
        return self._intf.set_property(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._set_distance_display_condition_per_marker_metadata, distanceDisplayConditionPerMarker)

    _get_texture_metadata = { "offset" : _get_texture_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def texture(self) -> "RendererTexture2D":
        """Get or set the per-batch texture, which is applied to each marker in the batch."""
        return self._intf.get_property(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._get_texture_metadata)

    _set_texture_metadata = { "offset" : _set_texture_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IRendererTexture2D"),) }
    @texture.setter
    def texture(self, texture:"IRendererTexture2D") -> None:
        return self._intf.set_property(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._set_texture_metadata, texture)

    _get_size_unit_metadata = { "offset" : _get_size_unit_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(MARKER_BATCH_UNIT),) }
    @property
    def size_unit(self) -> "MARKER_BATCH_UNIT":
        """Get or set the unit that each marker's size is defined in."""
        return self._intf.get_property(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._get_size_unit_metadata)

    _set_size_unit_metadata = { "offset" : _set_size_unit_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(MARKER_BATCH_UNIT),) }
    @size_unit.setter
    def size_unit(self, sizeUnit:"MARKER_BATCH_UNIT") -> None:
        return self._intf.set_property(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._set_size_unit_metadata, sizeUnit)

    _get_size_metadata = { "offset" : _get_size_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def size(self) -> list:
        """Get or set the per-batch size, which is applied to each marker in the batch. The array contains one width followed by one height."""
        return self._intf.get_property(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._get_size_metadata)

    _set_size_metadata = { "offset" : _set_size_method_offset,
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @size.setter
    def size(self, size:list) -> None:
        return self._intf.set_property(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._set_size_metadata, size)

    _get_origin_metadata = { "offset" : _get_origin_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(ORIGIN),) }
    @property
    def origin(self) -> "ORIGIN":
        """Get or set the per-batch origin, which is applied to each marker in the batch."""
        return self._intf.get_property(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._get_origin_metadata)

    _set_origin_metadata = { "offset" : _set_origin_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(ORIGIN),) }
    @origin.setter
    def origin(self, origin:"ORIGIN") -> None:
        return self._intf.set_property(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._set_origin_metadata, origin)

    _get_pixel_offset_metadata = { "offset" : _get_pixel_offset_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def pixel_offset(self) -> list:
        """Get or set the per-batch pixel offset, which is applied to each marker in the batch. The array contains one x pixel offset followed by one y pixel offset."""
        return self._intf.get_property(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._get_pixel_offset_metadata)

    _set_pixel_offset_metadata = { "offset" : _set_pixel_offset_method_offset,
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @pixel_offset.setter
    def pixel_offset(self, pixelOffset:list) -> None:
        return self._intf.set_property(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._set_pixel_offset_metadata, pixelOffset)

    _get_eye_offset_metadata = { "offset" : _get_eye_offset_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def eye_offset(self) -> list:
        """Get or set the per-batch eye offset, which is applied to each marker in the batch. The array contains the components of the eye offset in the order x, y, z."""
        return self._intf.get_property(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._get_eye_offset_metadata)

    _set_eye_offset_metadata = { "offset" : _set_eye_offset_method_offset,
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @eye_offset.setter
    def eye_offset(self, eyeOffset:list) -> None:
        return self._intf.set_property(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._set_eye_offset_metadata, eyeOffset)

    _get_rotation_metadata = { "offset" : _get_rotation_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def rotation(self) -> float:
        """Get or set the per-batch rotation angle which is applied to each marker in the batch."""
        return self._intf.get_property(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._get_rotation_metadata)

    _set_rotation_metadata = { "offset" : _set_rotation_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @rotation.setter
    def rotation(self, rotation:float) -> None:
        return self._intf.set_property(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._set_rotation_metadata, rotation)

    _get_texture_coordinate_metadata = { "offset" : _get_texture_coordinate_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def texture_coordinate(self) -> list:
        """Get or set the per-batch texture coordinate, which is applied to each marker in the batch. The array contains the texture coordinates arranged in the order s, t, p, q."""
        return self._intf.get_property(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._get_texture_coordinate_metadata)

    _set_texture_coordinate_metadata = { "offset" : _set_texture_coordinate_method_offset,
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @texture_coordinate.setter
    def texture_coordinate(self, textureCoordinate:list) -> None:
        return self._intf.set_property(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._set_texture_coordinate_metadata, textureCoordinate)

    _get_wireframe_metadata = { "offset" : _get_wireframe_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def wireframe(self) -> bool:
        """Get or set whether the primitive is rendered in wireframe. This is useful for debugging."""
        return self._intf.get_property(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._get_wireframe_metadata)

    _set_wireframe_metadata = { "offset" : _set_wireframe_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @wireframe.setter
    def wireframe(self, wireframe:bool) -> None:
        return self._intf.set_property(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._set_wireframe_metadata, wireframe)

    _get_per_item_picking_enabled_metadata = { "offset" : _get_per_item_picking_enabled_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def per_item_picking_enabled(self) -> bool:
        """Get or set whether individual marker indices will be included in the pick results returned from the scene's Pick method. Each marker index that is picked will be returned as a batch primitive index."""
        return self._intf.get_property(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._get_per_item_picking_enabled_metadata)

    _set_per_item_picking_enabled_metadata = { "offset" : _set_per_item_picking_enabled_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @per_item_picking_enabled.setter
    def per_item_picking_enabled(self, perItemPickingEnabled:bool) -> None:
        return self._intf.set_property(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._set_per_item_picking_enabled_metadata, perItemPickingEnabled)

    _get_texture_filter_metadata = { "offset" : _get_texture_filter_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def texture_filter(self) -> "TextureFilter2D":
        """Get or set the filter used for per-marker or per-batch textures."""
        return self._intf.get_property(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._get_texture_filter_metadata)

    _set_texture_filter_metadata = { "offset" : _set_texture_filter_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITextureFilter2D"),) }
    @texture_filter.setter
    def texture_filter(self, textureFilter:"ITextureFilter2D") -> None:
        return self._intf.set_property(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._set_texture_filter_metadata, textureFilter)

    _set_metadata = { "offset" : _set_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    def set(self, positions:list) -> None:
        """Define the positions of markers in a marker batch. The markers are rendered in the primitive's reference frame."""
        return self._intf.invoke(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._set_metadata, positions)

    _set_with_optional_parameters_metadata = { "offset" : _set_with_optional_parameters_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), agcom.PVOID,),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.InterfaceInArg("IMarkerBatchPrimitiveOptionalParameters"),) }
    def set_with_optional_parameters(self, positions:list, optionalParameters:"IMarkerBatchPrimitiveOptionalParameters") -> None:
        """Define the positions and optional per-marker parameters of markers in a marker batch. The markers are rendered in the primitive's reference frame."""
        return self._intf.invoke(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._set_with_optional_parameters_metadata, positions, optionalParameters)

    _set_with_optional_parameters_and_render_pass_hint_metadata = { "offset" : _set_with_optional_parameters_and_render_pass_hint_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), agcom.PVOID, agcom.LONG,),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.InterfaceInArg("IMarkerBatchPrimitiveOptionalParameters"), agmarshall.EnumArg(RENDER_PASS_HINT),) }
    def set_with_optional_parameters_and_render_pass_hint(self, positions:list, optionalParameters:"IMarkerBatchPrimitiveOptionalParameters", renderPassHint:"RENDER_PASS_HINT") -> None:
        """Define the positions and optional per-marker parameters of markers in a marker batch. The markers are rendered in the primitive's reference frame. renderPassHint is provided for efficiency."""
        return self._intf.invoke(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._set_with_optional_parameters_and_render_pass_hint_metadata, positions, optionalParameters, renderPassHint)

    _set_cartographic_metadata = { "offset" : _set_cartographic_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg,) }
    def set_cartographic(self, centralBody:str, positions:list) -> None:
        """For convenience. Defines the positions of markers in a marker batch using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling Set."""
        return self._intf.invoke(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._set_cartographic_metadata, centralBody, positions)

    _set_cartographic_with_optional_parameters_metadata = { "offset" : _set_cartographic_with_optional_parameters_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), agcom.PVOID,),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.InterfaceInArg("IMarkerBatchPrimitiveOptionalParameters"),) }
    def set_cartographic_with_optional_parameters(self, centralBody:str, positions:list, optionalParameters:"IMarkerBatchPrimitiveOptionalParameters") -> None:
        """For convenience. Defines the positions and optional per-marker parameters of markers in a marker batch using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling Set."""
        return self._intf.invoke(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._set_cartographic_with_optional_parameters_metadata, centralBody, positions, optionalParameters)

    _set_cartographic_with_optional_parameters_and_render_pass_hint_metadata = { "offset" : _set_cartographic_with_optional_parameters_and_render_pass_hint_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), agcom.PVOID, agcom.LONG,),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.InterfaceInArg("IMarkerBatchPrimitiveOptionalParameters"), agmarshall.EnumArg(RENDER_PASS_HINT),) }
    def set_cartographic_with_optional_parameters_and_render_pass_hint(self, centralBody:str, positions:list, optionalParameters:"IMarkerBatchPrimitiveOptionalParameters", renderPassHint:"RENDER_PASS_HINT") -> None:
        """For convenience. Defines the positions and optional per-marker parameters of markers in a marker batch using cartographic positions. renderPassHint is provided for efficiency..."""
        return self._intf.invoke(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._set_cartographic_with_optional_parameters_and_render_pass_hint_metadata, centralBody, positions, optionalParameters, renderPassHint)

    _set_partial_metadata = { "offset" : _set_partial_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg,) }
    def set_partial(self, positions:list, indices:list) -> None:
        """Update a subset of marker positions in a marker batch."""
        return self._intf.invoke(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._set_partial_metadata, positions, indices)

    _set_partial_with_indices_order_metadata = { "offset" : _set_partial_with_indices_order_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), agcom.LONG,),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.EnumArg(INDICES_ORDER_HINT),) }
    def set_partial_with_indices_order(self, positions:list, indices:list, indicesOrderHint:"INDICES_ORDER_HINT") -> None:
        """Update a subset of marker positions in a marker batch."""
        return self._intf.invoke(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._set_partial_with_indices_order_metadata, positions, indices, indicesOrderHint)

    _set_partial_with_optional_parameters_metadata = { "offset" : _set_partial_with_optional_parameters_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), agcom.PVOID, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.InterfaceInArg("IMarkerBatchPrimitiveOptionalParameters"), agmarshall.LPSafearrayArg,) }
    def set_partial_with_optional_parameters(self, positions:list, optionalParameters:"IMarkerBatchPrimitiveOptionalParameters", indices:list) -> None:
        """Update a subset of marker positions and/or per-marker parameters in a marker batch."""
        return self._intf.invoke(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._set_partial_with_optional_parameters_metadata, positions, optionalParameters, indices)

    _set_partial_with_optional_parameters_indices_order_and_render_pass_metadata = { "offset" : _set_partial_with_optional_parameters_indices_order_and_render_pass_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), agcom.PVOID, POINTER(agcom.LPSAFEARRAY), agcom.LONG, agcom.LONG,),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.InterfaceInArg("IMarkerBatchPrimitiveOptionalParameters"), agmarshall.LPSafearrayArg, agmarshall.EnumArg(INDICES_ORDER_HINT), agmarshall.EnumArg(RENDER_PASS_HINT),) }
    def set_partial_with_optional_parameters_indices_order_and_render_pass(self, positions:list, optionalParameters:"IMarkerBatchPrimitiveOptionalParameters", indices:list, indicesOrderHint:"INDICES_ORDER_HINT", renderPassHint:"RENDER_PASS_HINT") -> None:
        """Update a subset of marker positions and/or per-marker parameters in a marker batch."""
        return self._intf.invoke(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._set_partial_with_optional_parameters_indices_order_and_render_pass_metadata, positions, optionalParameters, indices, indicesOrderHint, renderPassHint)

    _set_partial_cartographic_metadata = { "offset" : _set_partial_cartographic_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg,) }
    def set_partial_cartographic(self, centralBody:str, positions:list, indices:list) -> None:
        """For convenience. Updates a subset of positions in a marker batch using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling SetPartial."""
        return self._intf.invoke(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._set_partial_cartographic_metadata, centralBody, positions, indices)

    _set_partial_cartographic_with_indices_order_metadata = { "offset" : _set_partial_cartographic_with_indices_order_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), agcom.LONG,),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.EnumArg(INDICES_ORDER_HINT),) }
    def set_partial_cartographic_with_indices_order(self, centralBody:str, positions:list, indices:list, indicesOrderHint:"INDICES_ORDER_HINT") -> None:
        """For convenience. Updates a subset of positions in a marker batch using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling SetPartial."""
        return self._intf.invoke(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._set_partial_cartographic_with_indices_order_metadata, centralBody, positions, indices, indicesOrderHint)

    _set_partial_cartographic_with_optional_parameters_metadata = { "offset" : _set_partial_cartographic_with_optional_parameters_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), agcom.PVOID, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.InterfaceInArg("IMarkerBatchPrimitiveOptionalParameters"), agmarshall.LPSafearrayArg,) }
    def set_partial_cartographic_with_optional_parameters(self, centralBody:str, positions:list, optionalParameters:"IMarkerBatchPrimitiveOptionalParameters", indices:list) -> None:
        """For convenience. Updates a subset of positions and/or optional per-marker parameters of markers in a marker batch using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling SetPartial."""
        return self._intf.invoke(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._set_partial_cartographic_with_optional_parameters_metadata, centralBody, positions, optionalParameters, indices)

    _set_partial_cartographic_with_optional_parameters_indices_order_and_render_pass_metadata = { "offset" : _set_partial_cartographic_with_optional_parameters_indices_order_and_render_pass_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), agcom.PVOID, POINTER(agcom.LPSAFEARRAY), agcom.LONG, agcom.LONG,),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.InterfaceInArg("IMarkerBatchPrimitiveOptionalParameters"), agmarshall.LPSafearrayArg, agmarshall.EnumArg(INDICES_ORDER_HINT), agmarshall.EnumArg(RENDER_PASS_HINT),) }
    def set_partial_cartographic_with_optional_parameters_indices_order_and_render_pass(self, centralBody:str, positions:list, optionalParameters:"IMarkerBatchPrimitiveOptionalParameters", indices:list, indicesOrderHint:"INDICES_ORDER_HINT", renderPassHint:"RENDER_PASS_HINT") -> None:
        """For convenience. Updates a subset of positions and/or optional per-marker parameters of markers in a marker batch using cartographic positions. renderPassHint is provided for efficiency..."""
        return self._intf.invoke(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._set_partial_cartographic_with_optional_parameters_indices_order_and_render_pass_metadata, centralBody, positions, optionalParameters, indices, indicesOrderHint, renderPassHint)

    _supported_metadata = { "offset" : _supported_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.EnumArg(MARKER_BATCH_RENDERING_METHOD), agmarshall.VariantBoolArg,) }
    def supported(self, renderingMethod:"MARKER_BATCH_RENDERING_METHOD") -> bool:
        """Determine whether or not the video card supports the marker batch primitive with the given renderingMethod."""
        return self._intf.invoke(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._supported_metadata, renderingMethod, OutArg())

    _get_clamp_to_pixel_metadata = { "offset" : _get_clamp_to_pixel_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def clamp_to_pixel(self) -> bool:
        """Get or set whether the screen space position of each marker is clamped to a pixel."""
        return self._intf.get_property(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._get_clamp_to_pixel_metadata)

    _set_clamp_to_pixel_metadata = { "offset" : _set_clamp_to_pixel_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @clamp_to_pixel.setter
    def clamp_to_pixel(self, clampToPixel:bool) -> None:
        return self._intf.set_property(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._set_clamp_to_pixel_metadata, clampToPixel)

    _get_central_body_clipped_metadata = { "offset" : _get_central_body_clipped_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def central_body_clipped(self) -> bool:
        """Get or set whether the markers are clipped by the central body."""
        return self._intf.get_property(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._get_central_body_clipped_metadata)

    _set_central_body_clipped_metadata = { "offset" : _set_central_body_clipped_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @central_body_clipped.setter
    def central_body_clipped(self, centralBodyClipped:bool) -> None:
        return self._intf.set_property(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._set_central_body_clipped_metadata, centralBodyClipped)

    _align_to_screen_metadata = { "offset" : _align_to_screen_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def align_to_screen(self) -> None:
        """Set the up vector of the markers to always be aligned to the up vector of the camera. This is the default alignment."""
        return self._intf.invoke(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._align_to_screen_metadata, )

    _align_to_north_metadata = { "offset" : _align_to_north_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    def align_to_north(self, centralBody:str) -> None:
        """Set the up vector of the markers to point towards the north axis of centralBody. It will be aligned with the tangent vector of the surface that points north."""
        return self._intf.invoke(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._align_to_north_metadata, centralBody)

    _align_to_axis_metadata = { "offset" : _align_to_axis_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg,) }
    def align_to_axis(self, centralBody:str, axis:list) -> None:
        """Set the up vector of the markers to point towards the axis of centralBody. It will be aligned with the tangent vector of the surface that points towards the axis..."""
        return self._intf.invoke(IMarkerBatchPrimitive._metadata, IMarkerBatchPrimitive._align_to_axis_metadata, centralBody, axis)

    _property_names[size_source] = "size_source"
    _property_names[sort_order] = "sort_order"
    _property_names[set_hint] = "set_hint"
    _property_names[rendering_method] = "rendering_method"
    _property_names[render_pass] = "render_pass"
    _property_names[bounding_sphere_scale] = "bounding_sphere_scale"
    _property_names[distance_display_condition_per_marker] = "distance_display_condition_per_marker"
    _property_names[texture] = "texture"
    _property_names[size_unit] = "size_unit"
    _property_names[size] = "size"
    _property_names[origin] = "origin"
    _property_names[pixel_offset] = "pixel_offset"
    _property_names[eye_offset] = "eye_offset"
    _property_names[rotation] = "rotation"
    _property_names[texture_coordinate] = "texture_coordinate"
    _property_names[wireframe] = "wireframe"
    _property_names[per_item_picking_enabled] = "per_item_picking_enabled"
    _property_names[texture_filter] = "texture_filter"
    _property_names[clamp_to_pixel] = "clamp_to_pixel"
    _property_names[central_body_clipped] = "central_body_clipped"


agcls.AgClassCatalog.add_catalog_entry((5541225076266399937, 16789973218996649861), IMarkerBatchPrimitive)
agcls.AgTypeNameMap["IMarkerBatchPrimitive"] = IMarkerBatchPrimitive

class IMarkerBatchPrimitiveOptionalParameters(object):
    """Optional per-marker parameters for marker batch primitive that overrides the marker batch's per-batch parameters..."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _set_textures_method_offset = 1
    _set_sizes_method_offset = 2
    _set_colors_method_offset = 3
    _set_origins_method_offset = 4
    _set_pixel_offsets_method_offset = 5
    _set_eye_offsets_method_offset = 6
    _set_rotations_method_offset = 7
    _set_texture_coordinates_method_offset = 8
    _set_time_interval_display_conditions_method_offset = 9
    _set_displays_method_offset = 10
    _metadata = {
        "iid_data" : (4926552851670611518, 9718265972343758992),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IMarkerBatchPrimitiveOptionalParameters."""
        initialize_from_source_object(self, sourceObject, IMarkerBatchPrimitiveOptionalParameters)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IMarkerBatchPrimitiveOptionalParameters)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IMarkerBatchPrimitiveOptionalParameters, None)
    
    _set_textures_metadata = { "offset" : _set_textures_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    def set_textures(self, textures:list) -> None:
        """Define a collection of textures, one for each marker in the batch."""
        return self._intf.invoke(IMarkerBatchPrimitiveOptionalParameters._metadata, IMarkerBatchPrimitiveOptionalParameters._set_textures_metadata, textures)

    _set_sizes_metadata = { "offset" : _set_sizes_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    def set_sizes(self, sizes:list) -> None:
        """Define a collection of sizes, one for each marker in the batch."""
        return self._intf.invoke(IMarkerBatchPrimitiveOptionalParameters._metadata, IMarkerBatchPrimitiveOptionalParameters._set_sizes_metadata, sizes)

    _set_colors_metadata = { "offset" : _set_colors_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    def set_colors(self, colors:list) -> None:
        """Define a collection of colors, one for each marker in the batch."""
        return self._intf.invoke(IMarkerBatchPrimitiveOptionalParameters._metadata, IMarkerBatchPrimitiveOptionalParameters._set_colors_metadata, colors)

    _set_origins_metadata = { "offset" : _set_origins_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    def set_origins(self, origins:list) -> None:
        """Define a collection of origins, one for each marker in the batch."""
        return self._intf.invoke(IMarkerBatchPrimitiveOptionalParameters._metadata, IMarkerBatchPrimitiveOptionalParameters._set_origins_metadata, origins)

    _set_pixel_offsets_metadata = { "offset" : _set_pixel_offsets_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    def set_pixel_offsets(self, pixelOffsets:list) -> None:
        """Define a collection of pixel offsets, one for each marker in the batch."""
        return self._intf.invoke(IMarkerBatchPrimitiveOptionalParameters._metadata, IMarkerBatchPrimitiveOptionalParameters._set_pixel_offsets_metadata, pixelOffsets)

    _set_eye_offsets_metadata = { "offset" : _set_eye_offsets_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    def set_eye_offsets(self, eyeOffsets:list) -> None:
        """Define a collection of eye offsets, one for each marker in the batch."""
        return self._intf.invoke(IMarkerBatchPrimitiveOptionalParameters._metadata, IMarkerBatchPrimitiveOptionalParameters._set_eye_offsets_metadata, eyeOffsets)

    _set_rotations_metadata = { "offset" : _set_rotations_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    def set_rotations(self, rotationAngles:list) -> None:
        """Define a collection of rotation angles, one for each marker in the batch."""
        return self._intf.invoke(IMarkerBatchPrimitiveOptionalParameters._metadata, IMarkerBatchPrimitiveOptionalParameters._set_rotations_metadata, rotationAngles)

    _set_texture_coordinates_metadata = { "offset" : _set_texture_coordinates_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    def set_texture_coordinates(self, textureCoordinates:list) -> None:
        """Define a collection of texture coordinates, one for each marker in the batch."""
        return self._intf.invoke(IMarkerBatchPrimitiveOptionalParameters._metadata, IMarkerBatchPrimitiveOptionalParameters._set_texture_coordinates_metadata, textureCoordinates)

    _set_time_interval_display_conditions_metadata = { "offset" : _set_time_interval_display_conditions_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    def set_time_interval_display_conditions(self, timeIntervals:list) -> None:
        """Define a collection of time interval display conditions, one for each marker in the batch."""
        return self._intf.invoke(IMarkerBatchPrimitiveOptionalParameters._metadata, IMarkerBatchPrimitiveOptionalParameters._set_time_interval_display_conditions_metadata, timeIntervals)

    _set_displays_metadata = { "offset" : _set_displays_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    def set_displays(self, displays:list) -> None:
        """Define a collection of boolean display flags, one for each marker in the batch."""
        return self._intf.invoke(IMarkerBatchPrimitiveOptionalParameters._metadata, IMarkerBatchPrimitiveOptionalParameters._set_displays_metadata, displays)


agcls.AgClassCatalog.add_catalog_entry((4926552851670611518, 9718265972343758992), IMarkerBatchPrimitiveOptionalParameters)
agcls.AgTypeNameMap["IMarkerBatchPrimitiveOptionalParameters"] = IMarkerBatchPrimitiveOptionalParameters

class IMaximumCountPathPrimitiveUpdatePolicy(object):
    """path primitive update policy that removes points from remove location when the number of points in the path exceeds maximum count."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_maximum_count_method_offset = 1
    _set_maximum_count_method_offset = 2
    _get_remove_location_method_offset = 3
    _set_remove_location_method_offset = 4
    _metadata = {
        "iid_data" : (5099271029598780192, 3154004167287703454),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IMaximumCountPathPrimitiveUpdatePolicy."""
        initialize_from_source_object(self, sourceObject, IMaximumCountPathPrimitiveUpdatePolicy)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IMaximumCountPathPrimitiveUpdatePolicy)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IMaximumCountPathPrimitiveUpdatePolicy, None)
    
    _get_maximum_count_metadata = { "offset" : _get_maximum_count_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def maximum_count(self) -> int:
        """Get or set the maximum number of points in the path."""
        return self._intf.get_property(IMaximumCountPathPrimitiveUpdatePolicy._metadata, IMaximumCountPathPrimitiveUpdatePolicy._get_maximum_count_metadata)

    _set_maximum_count_metadata = { "offset" : _set_maximum_count_method_offset,
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.IntArg,) }
    @maximum_count.setter
    def maximum_count(self, maximumCount:int) -> None:
        return self._intf.set_property(IMaximumCountPathPrimitiveUpdatePolicy._metadata, IMaximumCountPathPrimitiveUpdatePolicy._set_maximum_count_metadata, maximumCount)

    _get_remove_location_metadata = { "offset" : _get_remove_location_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(PATH_PRIMITIVE_REMOVE_LOCATION),) }
    @property
    def remove_location(self) -> "PATH_PRIMITIVE_REMOVE_LOCATION":
        """Get or set where the positions on the path are removed from."""
        return self._intf.get_property(IMaximumCountPathPrimitiveUpdatePolicy._metadata, IMaximumCountPathPrimitiveUpdatePolicy._get_remove_location_metadata)

    _set_remove_location_metadata = { "offset" : _set_remove_location_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(PATH_PRIMITIVE_REMOVE_LOCATION),) }
    @remove_location.setter
    def remove_location(self, removeLocation:"PATH_PRIMITIVE_REMOVE_LOCATION") -> None:
        return self._intf.set_property(IMaximumCountPathPrimitiveUpdatePolicy._metadata, IMaximumCountPathPrimitiveUpdatePolicy._set_remove_location_metadata, removeLocation)

    _property_names[maximum_count] = "maximum_count"
    _property_names[remove_location] = "remove_location"


agcls.AgClassCatalog.add_catalog_entry((5099271029598780192, 3154004167287703454), IMaximumCountPathPrimitiveUpdatePolicy)
agcls.AgTypeNameMap["IMaximumCountPathPrimitiveUpdatePolicy"] = IMaximumCountPathPrimitiveUpdatePolicy

class IModelArticulation(object):
    """A model articulation identifies geometry on the model and is a collection of transformations that can be applied to that geometry."""

    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_name_method_offset = 1
    _get_count_method_offset = 2
    _item_method_offset = 3
    _get_item_by_string_method_offset = 4
    _get_by_name_method_offset = 5
    _contains_method_offset = 6
    _get__NewEnum_method_offset = 7
    _metadata = {
        "iid_data" : (5348326078254719861, 10849601624272152503),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IModelArticulation."""
        initialize_from_source_object(self, sourceObject, IModelArticulation)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IModelArticulation)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IModelArticulation, None)
    def __iter__(self):
        """Create an iterator for the IModelArticulation object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IModelTransformation":
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _get_name_metadata = { "offset" : _get_name_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def name(self) -> str:
        """Get the name of the articulation."""
        return self._intf.get_property(IModelArticulation._metadata, IModelArticulation._get_name_metadata)

    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def count(self) -> int:
        """Get the number of transformations in the collection."""
        return self._intf.get_property(IModelArticulation._metadata, IModelArticulation._get_count_metadata)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def item(self, index:int) -> "ModelTransformation":
        """Get the transformation at the given index. The index is zero-based."""
        return self._intf.invoke(IModelArticulation._metadata, IModelArticulation._item_metadata, index, OutArg())

    _get_item_by_string_metadata = { "offset" : _get_item_by_string_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_string(self, name:str) -> "ModelTransformation":
        """Get a transformation by name."""
        return self._intf.invoke(IModelArticulation._metadata, IModelArticulation._get_item_by_string_metadata, name, OutArg())

    _get_by_name_metadata = { "offset" : _get_by_name_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def get_by_name(self, name:str) -> "ModelTransformation":
        """Get a transformation by name."""
        return self._intf.invoke(IModelArticulation._metadata, IModelArticulation._get_by_name_metadata, name, OutArg())

    _contains_metadata = { "offset" : _contains_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.VariantBoolArg,) }
    def contains(self, name:str) -> bool:
        """Return true if the collection contains the transformation."""
        return self._intf.invoke(IModelArticulation._metadata, IModelArticulation._contains_metadata, name, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        """Return the enumerator for this collection."""
        return self._intf.get_property(IModelArticulation._metadata, IModelArticulation._get__NewEnum_metadata)

    __getitem__ = item


    _property_names[name] = "name"
    _property_names[count] = "count"
    _property_names[_NewEnum] = "_NewEnum"


agcls.AgClassCatalog.add_catalog_entry((5348326078254719861, 10849601624272152503), IModelArticulation)
agcls.AgTypeNameMap["IModelArticulation"] = IModelArticulation

class IModelArticulationCollection(object):
    """A collection containing a model primitive's available articulations. A model articulation identifies geometry on the model and is a collection of transformations that can be applied to that geometry."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_count_method_offset = 1
    _item_method_offset = 2
    _get_item_by_string_method_offset = 3
    _get_by_name_method_offset = 4
    _contains_method_offset = 5
    _get__NewEnum_method_offset = 6
    _metadata = {
        "iid_data" : (4825692293668155476, 4454785697263668652),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IModelArticulationCollection."""
        initialize_from_source_object(self, sourceObject, IModelArticulationCollection)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IModelArticulationCollection)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IModelArticulationCollection, None)
    def __iter__(self):
        """Create an iterator for the IModelArticulationCollection object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IModelArticulation":
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def count(self) -> int:
        """Get the number of articulations in the collection."""
        return self._intf.get_property(IModelArticulationCollection._metadata, IModelArticulationCollection._get_count_metadata)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def item(self, index:int) -> "ModelArticulation":
        """Get the articulation at the given index. The index is zero-based."""
        return self._intf.invoke(IModelArticulationCollection._metadata, IModelArticulationCollection._item_metadata, index, OutArg())

    _get_item_by_string_metadata = { "offset" : _get_item_by_string_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def get_item_by_string(self, name:str) -> "ModelArticulation":
        """Get an articulation by name."""
        return self._intf.invoke(IModelArticulationCollection._metadata, IModelArticulationCollection._get_item_by_string_metadata, name, OutArg())

    _get_by_name_metadata = { "offset" : _get_by_name_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def get_by_name(self, name:str) -> "ModelArticulation":
        """Get an articulation by name."""
        return self._intf.invoke(IModelArticulationCollection._metadata, IModelArticulationCollection._get_by_name_metadata, name, OutArg())

    _contains_metadata = { "offset" : _contains_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.VariantBoolArg,) }
    def contains(self, name:str) -> bool:
        """Return true if the collection contains the articulation."""
        return self._intf.invoke(IModelArticulationCollection._metadata, IModelArticulationCollection._contains_metadata, name, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        """Return the enumerator for this collection."""
        return self._intf.get_property(IModelArticulationCollection._metadata, IModelArticulationCollection._get__NewEnum_metadata)

    __getitem__ = item


    _property_names[count] = "count"
    _property_names[_NewEnum] = "_NewEnum"


agcls.AgClassCatalog.add_catalog_entry((4825692293668155476, 4454785697263668652), IModelArticulationCollection)
agcls.AgTypeNameMap["IModelArticulationCollection"] = IModelArticulationCollection

class IModelPrimitive(object):
    """The model primitive loads and renders `COLLADA <https://www.khronos.org/collada/>`_ (DAE) and AGI `MDL <https://support.agi.com/3d-models>`_ (MDL) models."""

    _num_methods = 11
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_uri_as_string_method_offset = 1
    _get_scale_method_offset = 2
    _set_scale_method_offset = 3
    _get_position_method_offset = 4
    _set_position_method_offset = 5
    _get_orientation_method_offset = 6
    _set_orientation_method_offset = 7
    _get_articulations_method_offset = 8
    _load_with_string_uri_method_offset = 9
    _load_with_string_uri_and_up_axis_method_offset = 10
    _set_position_cartographic_method_offset = 11
    _metadata = {
        "iid_data" : (5605268163691457879, 14557257887553554869),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IModelPrimitive."""
        initialize_from_source_object(self, sourceObject, IModelPrimitive)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IModelPrimitive)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IModelPrimitive, None)
    
    _get_uri_as_string_metadata = { "offset" : _get_uri_as_string_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def uri_as_string(self) -> str:
        """Get the URI of the file used to load the file."""
        return self._intf.get_property(IModelPrimitive._metadata, IModelPrimitive._get_uri_as_string_metadata)

    _get_scale_metadata = { "offset" : _get_scale_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def scale(self) -> float:
        """Get or set the linear scale used to increase or decrease the size of the rendered model."""
        return self._intf.get_property(IModelPrimitive._metadata, IModelPrimitive._get_scale_metadata)

    _set_scale_metadata = { "offset" : _set_scale_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @scale.setter
    def scale(self, scale:float) -> None:
        return self._intf.set_property(IModelPrimitive._metadata, IModelPrimitive._set_scale_metadata, scale)

    _get_position_metadata = { "offset" : _get_position_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def position(self) -> list:
        """Get or set the position of the model. The position is defined in the model's reference frame. The array contains the components of the position in the order x, y, z."""
        return self._intf.get_property(IModelPrimitive._metadata, IModelPrimitive._get_position_metadata)

    _set_position_metadata = { "offset" : _set_position_method_offset,
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @position.setter
    def position(self, position:list) -> None:
        return self._intf.set_property(IModelPrimitive._metadata, IModelPrimitive._set_position_metadata, position)

    _get_orientation_metadata = { "offset" : _get_orientation_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def orientation(self) -> "IOrientation":
        """Get or set the model's orientation. The quaternion is a rotation from the model's local axes to the axes of the model's reference frame."""
        return self._intf.get_property(IModelPrimitive._metadata, IModelPrimitive._get_orientation_metadata)

    _set_orientation_metadata = { "offset" : _set_orientation_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IOrientation"),) }
    @orientation.setter
    def orientation(self, orientation:"IOrientation") -> None:
        return self._intf.set_property(IModelPrimitive._metadata, IModelPrimitive._set_orientation_metadata, orientation)

    _get_articulations_metadata = { "offset" : _get_articulations_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def articulations(self) -> "ModelArticulationCollection":
        """Get the model's articulations. Articulations identify geometry and contain transformations for manipulating that geometry."""
        return self._intf.get_property(IModelPrimitive._metadata, IModelPrimitive._get_articulations_metadata)

    _load_with_string_uri_metadata = { "offset" : _load_with_string_uri_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    def load_with_string_uri(self, uri:str) -> None:
        """For convenience. Loads a `COLLADA <https://www.khronos.org/collada/>`_ (DAE) or AGI `MDL <https://support.agi.com/3d-models>`_ (MDL) model using a file path."""
        return self._intf.invoke(IModelPrimitive._metadata, IModelPrimitive._load_with_string_uri_metadata, uri)

    _load_with_string_uri_and_up_axis_metadata = { "offset" : _load_with_string_uri_and_up_axis_method_offset,
            "arg_types" : (agcom.BSTR, agcom.LONG,),
            "marshallers" : (agmarshall.BStrArg, agmarshall.EnumArg(MODEL_UP_AXIS),) }
    def load_with_string_uri_and_up_axis(self, uri:str, upAxis:"MODEL_UP_AXIS") -> None:
        """For convenience. Loads a `COLLADA <https://www.khronos.org/collada/>`_ (DAE) or AGI `MDL <https://support.agi.com/3d-models>`_ (MDL) model using a file path."""
        return self._intf.invoke(IModelPrimitive._metadata, IModelPrimitive._load_with_string_uri_and_up_axis_metadata, uri, upAxis)

    _set_position_cartographic_metadata = { "offset" : _set_position_cartographic_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg,) }
    def set_position_cartographic(self, centralBody:str, position:list) -> None:
        """For convenience. Sets the cartographic position of the model. This also sets position."""
        return self._intf.invoke(IModelPrimitive._metadata, IModelPrimitive._set_position_cartographic_metadata, centralBody, position)

    _property_names[uri_as_string] = "uri_as_string"
    _property_names[scale] = "scale"
    _property_names[position] = "position"
    _property_names[orientation] = "orientation"
    _property_names[articulations] = "articulations"


agcls.AgClassCatalog.add_catalog_entry((5605268163691457879, 14557257887553554869), IModelPrimitive)
agcls.AgTypeNameMap["IModelPrimitive"] = IModelPrimitive

class IModelTransformation(object):
    """A model transformation defines a transformation that is applied to geometry on a model primitive. That geometry is identified by the model articulation which contains the transformation..."""

    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_current_value_method_offset = 1
    _set_current_value_method_offset = 2
    _get_minimum_value_method_offset = 3
    _get_maximum_value_method_offset = 4
    _get_default_value_method_offset = 5
    _get_range_method_offset = 6
    _get_name_method_offset = 7
    _get_type_method_offset = 8
    _metadata = {
        "iid_data" : (5281930043538243524, 11725494751790391716),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IModelTransformation."""
        initialize_from_source_object(self, sourceObject, IModelTransformation)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IModelTransformation)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IModelTransformation, None)
    
    _get_current_value_metadata = { "offset" : _get_current_value_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def current_value(self) -> float:
        """Get or set the current value of the transformation. The current value of the transformation will be reflected in the geometry of the model primitive that it is associated with."""
        return self._intf.get_property(IModelTransformation._metadata, IModelTransformation._get_current_value_metadata)

    _set_current_value_metadata = { "offset" : _set_current_value_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @current_value.setter
    def current_value(self, currentValue:float) -> None:
        return self._intf.set_property(IModelTransformation._metadata, IModelTransformation._set_current_value_metadata, currentValue)

    _get_minimum_value_metadata = { "offset" : _get_minimum_value_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def minimum_value(self) -> float:
        """Get the minimum value of the transformation."""
        return self._intf.get_property(IModelTransformation._metadata, IModelTransformation._get_minimum_value_metadata)

    _get_maximum_value_metadata = { "offset" : _get_maximum_value_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def maximum_value(self) -> float:
        """Get the maximum value of the transformation."""
        return self._intf.get_property(IModelTransformation._metadata, IModelTransformation._get_maximum_value_metadata)

    _get_default_value_metadata = { "offset" : _get_default_value_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def default_value(self) -> float:
        """Get the default value of the transformation. The current value property of the transformation will have this value when the model primitive is initialized."""
        return self._intf.get_property(IModelTransformation._metadata, IModelTransformation._get_default_value_metadata)

    _get_range_metadata = { "offset" : _get_range_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def range(self) -> float:
        """Get the value range of the transformation. Equivalent to the difference of the maximum value and minimum value properties."""
        return self._intf.get_property(IModelTransformation._metadata, IModelTransformation._get_range_metadata)

    _get_name_metadata = { "offset" : _get_name_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def name(self) -> str:
        """Get the name of the transformation."""
        return self._intf.get_property(IModelTransformation._metadata, IModelTransformation._get_name_metadata)

    _get_type_metadata = { "offset" : _get_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(MODEL_TRANSFORMATION_TYPE),) }
    @property
    def type(self) -> "MODEL_TRANSFORMATION_TYPE":
        """Get the model transformation type associated with the transformation."""
        return self._intf.get_property(IModelTransformation._metadata, IModelTransformation._get_type_metadata)

    _property_names[current_value] = "current_value"
    _property_names[minimum_value] = "minimum_value"
    _property_names[maximum_value] = "maximum_value"
    _property_names[default_value] = "default_value"
    _property_names[range] = "range"
    _property_names[name] = "name"
    _property_names[type] = "type"


agcls.AgClassCatalog.add_catalog_entry((5281930043538243524, 11725494751790391716), IModelTransformation)
agcls.AgTypeNameMap["IModelTransformation"] = IModelTransformation

class IOverlay(object):
    """A visible element drawn in screen space. Overlays are useful for floating logos, heads up displays, and integrating user interfaces into the 3D window."""

    _num_methods = 76
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_position_method_offset = 1
    _set_position_method_offset = 2
    _get_pinning_position_method_offset = 3
    _set_pinning_position_method_offset = 4
    _get_x_method_offset = 5
    _set_x_method_offset = 6
    _get_x_unit_method_offset = 7
    _set_x_unit_method_offset = 8
    _get_y_method_offset = 9
    _set_y_method_offset = 10
    _get_y_unit_method_offset = 11
    _set_y_unit_method_offset = 12
    _get_size_method_offset = 13
    _set_size_method_offset = 14
    _get_width_method_offset = 15
    _set_width_method_offset = 16
    _get_width_unit_method_offset = 17
    _set_width_unit_method_offset = 18
    _get_height_method_offset = 19
    _set_height_method_offset = 20
    _get_height_unit_method_offset = 21
    _set_height_unit_method_offset = 22
    _get_minimum_size_method_offset = 23
    _set_minimum_size_method_offset = 24
    _get_maximum_size_method_offset = 25
    _set_maximum_size_method_offset = 26
    _get_bounds_method_offset = 27
    _get_border_color_method_offset = 28
    _set_border_color_method_offset = 29
    _get_border_size_method_offset = 30
    _set_border_size_method_offset = 31
    _get_border_translucency_method_offset = 32
    _set_border_translucency_method_offset = 33
    _get_translation_x_method_offset = 34
    _set_translation_x_method_offset = 35
    _get_translation_y_method_offset = 36
    _set_translation_y_method_offset = 37
    _get_rotation_angle_method_offset = 38
    _set_rotation_angle_method_offset = 39
    _get_rotation_point_method_offset = 40
    _set_rotation_point_method_offset = 41
    _get_scale_method_offset = 42
    _set_scale_method_offset = 43
    _get_flip_x_method_offset = 44
    _set_flip_x_method_offset = 45
    _get_flip_y_method_offset = 46
    _set_flip_y_method_offset = 47
    _get_origin_method_offset = 48
    _set_origin_method_offset = 49
    _get_pinning_origin_method_offset = 50
    _set_pinning_origin_method_offset = 51
    _get_parent_method_offset = 52
    _get_translucency_method_offset = 53
    _set_translucency_method_offset = 54
    _get_color_method_offset = 55
    _set_color_method_offset = 56
    _get_picking_enabled_method_offset = 57
    _set_picking_enabled_method_offset = 58
    _get_clip_to_parent_method_offset = 59
    _set_clip_to_parent_method_offset = 60
    _get_display_method_offset = 61
    _set_display_method_offset = 62
    _get_control_position_method_offset = 63
    _get_control_size_method_offset = 64
    _get_control_bounds_method_offset = 65
    _get_display_condition_method_offset = 66
    _set_display_condition_method_offset = 67
    _get_overlays_method_offset = 68
    _get_padding_method_offset = 69
    _set_padding_method_offset = 70
    _bring_to_front_method_offset = 71
    _send_to_back_method_offset = 72
    _overlay_to_control_method_offset = 73
    _control_to_overlay_method_offset = 74
    _get_tag_method_offset = 75
    _set_tag_method_offset = 76
    _metadata = {
        "iid_data" : (4975169524664922677, 13740715011966152579),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IOverlay."""
        initialize_from_source_object(self, sourceObject, IOverlay)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IOverlay)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IOverlay, None)
    
    _get_position_metadata = { "offset" : _get_position_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def position(self) -> list:
        """Get or set the position of the overlay relative to its parent. The array represents the position of the overlay and has a size of 4. The elements are in the order x position, y position, x screen overlay unit, y screen overlay unit."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_position_metadata)

    _set_position_metadata = { "offset" : _set_position_method_offset,
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @position.setter
    def position(self, position:list) -> None:
        return self._intf.set_property(IOverlay._metadata, IOverlay._set_position_metadata, position)

    _get_pinning_position_metadata = { "offset" : _get_pinning_position_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def pinning_position(self) -> list:
        """Get or set the pinning position of the overlay, relative to the overlay, which determines the point on the overlay that corresponds to the position property. The array represents the pinning position of the overlay and has a size of 4..."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_pinning_position_metadata)

    _set_pinning_position_metadata = { "offset" : _set_pinning_position_method_offset,
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @pinning_position.setter
    def pinning_position(self, pinningPosition:list) -> None:
        return self._intf.set_property(IOverlay._metadata, IOverlay._set_pinning_position_metadata, pinningPosition)

    _get_x_metadata = { "offset" : _get_x_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def x(self) -> float:
        """Get or set the X position of the overlay relative to its parent. The unit in which the position is defined is specified by the x unit property. The position is measured horizontally from the origin, which is, by default, the lower-left corner."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_x_metadata)

    _set_x_metadata = { "offset" : _set_x_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @x.setter
    def x(self, x:float) -> None:
        return self._intf.set_property(IOverlay._metadata, IOverlay._set_x_metadata, x)

    _get_x_unit_metadata = { "offset" : _get_x_unit_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(SCREEN_OVERLAY_UNIT),) }
    @property
    def x_unit(self) -> "SCREEN_OVERLAY_UNIT":
        """Get or set the unit of the x property."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_x_unit_metadata)

    _set_x_unit_metadata = { "offset" : _set_x_unit_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(SCREEN_OVERLAY_UNIT),) }
    @x_unit.setter
    def x_unit(self, xUnit:"SCREEN_OVERLAY_UNIT") -> None:
        return self._intf.set_property(IOverlay._metadata, IOverlay._set_x_unit_metadata, xUnit)

    _get_y_metadata = { "offset" : _get_y_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def y(self) -> float:
        """Get or set the Y position of the overlay relative to its parent. The unit in which the position is defined is specified by the y unit property. The position is measured vertically from the origin, which is, by default, the lower-left corner."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_y_metadata)

    _set_y_metadata = { "offset" : _set_y_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @y.setter
    def y(self, y:float) -> None:
        return self._intf.set_property(IOverlay._metadata, IOverlay._set_y_metadata, y)

    _get_y_unit_metadata = { "offset" : _get_y_unit_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(SCREEN_OVERLAY_UNIT),) }
    @property
    def y_unit(self) -> "SCREEN_OVERLAY_UNIT":
        """Get or set the unit of the y property."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_y_unit_metadata)

    _set_y_unit_metadata = { "offset" : _set_y_unit_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(SCREEN_OVERLAY_UNIT),) }
    @y_unit.setter
    def y_unit(self, yUnit:"SCREEN_OVERLAY_UNIT") -> None:
        return self._intf.set_property(IOverlay._metadata, IOverlay._set_y_unit_metadata, yUnit)

    _get_size_metadata = { "offset" : _get_size_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def size(self) -> list:
        """Get or set the size of the overlay. The array elements represent the size of the overlay in the order width, height, width screen overlay unit, height screen overlay unit."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_size_metadata)

    _set_size_metadata = { "offset" : _set_size_method_offset,
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @size.setter
    def size(self, size:list) -> None:
        return self._intf.set_property(IOverlay._metadata, IOverlay._set_size_metadata, size)

    _get_width_metadata = { "offset" : _get_width_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def width(self) -> float:
        """Get or set the width of the overlay. The unit in which the width is defined is specified by the width unit property."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_width_metadata)

    _set_width_metadata = { "offset" : _set_width_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @width.setter
    def width(self, width:float) -> None:
        return self._intf.set_property(IOverlay._metadata, IOverlay._set_width_metadata, width)

    _get_width_unit_metadata = { "offset" : _get_width_unit_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(SCREEN_OVERLAY_UNIT),) }
    @property
    def width_unit(self) -> "SCREEN_OVERLAY_UNIT":
        """Get or set the unit of the width property."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_width_unit_metadata)

    _set_width_unit_metadata = { "offset" : _set_width_unit_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(SCREEN_OVERLAY_UNIT),) }
    @width_unit.setter
    def width_unit(self, widthUnit:"SCREEN_OVERLAY_UNIT") -> None:
        return self._intf.set_property(IOverlay._metadata, IOverlay._set_width_unit_metadata, widthUnit)

    _get_height_metadata = { "offset" : _get_height_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def height(self) -> float:
        """Get or set the height of the overlay. The unit in which the height is defined is specified by the height unit property."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_height_metadata)

    _set_height_metadata = { "offset" : _set_height_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @height.setter
    def height(self, height:float) -> None:
        return self._intf.set_property(IOverlay._metadata, IOverlay._set_height_metadata, height)

    _get_height_unit_metadata = { "offset" : _get_height_unit_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(SCREEN_OVERLAY_UNIT),) }
    @property
    def height_unit(self) -> "SCREEN_OVERLAY_UNIT":
        """Get or set the unit of the height property."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_height_unit_metadata)

    _set_height_unit_metadata = { "offset" : _set_height_unit_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(SCREEN_OVERLAY_UNIT),) }
    @height_unit.setter
    def height_unit(self, heightUnit:"SCREEN_OVERLAY_UNIT") -> None:
        return self._intf.set_property(IOverlay._metadata, IOverlay._set_height_unit_metadata, heightUnit)

    _get_minimum_size_metadata = { "offset" : _get_minimum_size_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def minimum_size(self) -> list:
        """Get or set the minimum size of the overlay. The overlay will never be smaller than this size, even if the overlay's size is specified as a percentage of its parent and its parent is very small..."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_minimum_size_metadata)

    _set_minimum_size_metadata = { "offset" : _set_minimum_size_method_offset,
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @minimum_size.setter
    def minimum_size(self, minimumSize:list) -> None:
        return self._intf.set_property(IOverlay._metadata, IOverlay._set_minimum_size_metadata, minimumSize)

    _get_maximum_size_metadata = { "offset" : _get_maximum_size_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def maximum_size(self) -> list:
        """Get or set the maximum size of the overlay. The overlay will never be larger than this size, even if the overlay's size is specified as a percentage of its parent and its parent is very large..."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_maximum_size_metadata)

    _set_maximum_size_metadata = { "offset" : _set_maximum_size_method_offset,
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @maximum_size.setter
    def maximum_size(self, maximumSize:list) -> None:
        return self._intf.set_property(IOverlay._metadata, IOverlay._set_maximum_size_metadata, maximumSize)

    _get_bounds_metadata = { "offset" : _get_bounds_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def bounds(self) -> list:
        """Get the bounds of the overlay relative to its parent. The array contains the properties defining the bounds in the order left x location, top y location, width, height."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_bounds_metadata)

    _get_border_color_metadata = { "offset" : _get_border_color_method_offset,
            "arg_types" : (POINTER(agcom.OLE_COLOR),),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @property
    def border_color(self) -> agcolor.Color:
        """Get or set the overlay's border color. By default, the border color is white. However, also by default, the overlay has a border size of 0.0 so the border is not displayed."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_border_color_metadata)

    _set_border_color_metadata = { "offset" : _set_border_color_method_offset,
            "arg_types" : (agcom.OLE_COLOR,),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @border_color.setter
    def border_color(self, borderColor:agcolor.Color) -> None:
        return self._intf.set_property(IOverlay._metadata, IOverlay._set_border_color_metadata, borderColor)

    _get_border_size_metadata = { "offset" : _get_border_size_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def border_size(self) -> int:
        """Get or set the size of the overlay's border. By default, this is 0.0 so the border is not displayed."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_border_size_metadata)

    _set_border_size_metadata = { "offset" : _set_border_size_method_offset,
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.IntArg,) }
    @border_size.setter
    def border_size(self, borderSize:int) -> None:
        return self._intf.set_property(IOverlay._metadata, IOverlay._set_border_size_metadata, borderSize)

    _get_border_translucency_metadata = { "offset" : _get_border_translucency_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def border_translucency(self) -> float:
        """Get or set the translucency of the overlay border. Translucency is a value between 0.0 and 1.0, where 0.0 is completely opaque and 1.0 is completely transparent."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_border_translucency_metadata)

    _set_border_translucency_metadata = { "offset" : _set_border_translucency_method_offset,
            "arg_types" : (agcom.FLOAT,),
            "marshallers" : (agmarshall.FloatArg,) }
    @border_translucency.setter
    def border_translucency(self, borderTranslucency:float) -> None:
        return self._intf.set_property(IOverlay._metadata, IOverlay._set_border_translucency_metadata, borderTranslucency)

    _get_translation_x_metadata = { "offset" : _get_translation_x_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def translation_x(self) -> float:
        """Get or set the value with which the overlay will be translated from the X value of the position property."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_translation_x_metadata)

    _set_translation_x_metadata = { "offset" : _set_translation_x_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @translation_x.setter
    def translation_x(self, translationX:float) -> None:
        return self._intf.set_property(IOverlay._metadata, IOverlay._set_translation_x_metadata, translationX)

    _get_translation_y_metadata = { "offset" : _get_translation_y_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def translation_y(self) -> float:
        """Get or set the value with which the overlay will be translated from the Y value of the position property."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_translation_y_metadata)

    _set_translation_y_metadata = { "offset" : _set_translation_y_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @translation_y.setter
    def translation_y(self, translationY:float) -> None:
        return self._intf.set_property(IOverlay._metadata, IOverlay._set_translation_y_metadata, translationY)

    _get_rotation_angle_metadata = { "offset" : _get_rotation_angle_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def rotation_angle(self) -> float:
        """Get or set the counter-clockwise rotation of the overlay. The overlay is rotated around the point specified by the rotation point property."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_rotation_angle_metadata)

    _set_rotation_angle_metadata = { "offset" : _set_rotation_angle_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @rotation_angle.setter
    def rotation_angle(self, rotationAngle:float) -> None:
        return self._intf.set_property(IOverlay._metadata, IOverlay._set_rotation_angle_metadata, rotationAngle)

    _get_rotation_point_metadata = { "offset" : _get_rotation_point_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def rotation_point(self) -> list:
        """Get or set the point that the overlay is rotated around when the rotation angle property has a value other than 0.0. The array contains seven elements defining the properties of the rotation point..."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_rotation_point_metadata)

    _set_rotation_point_metadata = { "offset" : _set_rotation_point_method_offset,
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @rotation_point.setter
    def rotation_point(self, rotationPoint:list) -> None:
        return self._intf.set_property(IOverlay._metadata, IOverlay._set_rotation_point_metadata, rotationPoint)

    _get_scale_metadata = { "offset" : _get_scale_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def scale(self) -> float:
        """Get or set the fractional value used to scale the overlay's size property. A value greater than 1.0 will make the overlay larger while a value less than 1.0 will make it smaller."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_scale_metadata)

    _set_scale_metadata = { "offset" : _set_scale_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @scale.setter
    def scale(self, scale:float) -> None:
        return self._intf.set_property(IOverlay._metadata, IOverlay._set_scale_metadata, scale)

    _get_flip_x_metadata = { "offset" : _get_flip_x_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def flip_x(self) -> bool:
        """Get or set whether the overlay will be flipped along its X axis."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_flip_x_metadata)

    _set_flip_x_metadata = { "offset" : _set_flip_x_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @flip_x.setter
    def flip_x(self, flipX:bool) -> None:
        return self._intf.set_property(IOverlay._metadata, IOverlay._set_flip_x_metadata, flipX)

    _get_flip_y_metadata = { "offset" : _get_flip_y_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def flip_y(self) -> bool:
        """Get or set whether the overlay will be flipped along its Y axis."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_flip_y_metadata)

    _set_flip_y_metadata = { "offset" : _set_flip_y_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @flip_y.setter
    def flip_y(self, flipY:bool) -> None:
        return self._intf.set_property(IOverlay._metadata, IOverlay._set_flip_y_metadata, flipY)

    _get_origin_metadata = { "offset" : _get_origin_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(SCREEN_OVERLAY_ORIGIN),) }
    @property
    def origin(self) -> "SCREEN_OVERLAY_ORIGIN":
        """Get or set the origin from which the overlay's position is defined. By default, the value of this property is bottom left..."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_origin_metadata)

    _set_origin_metadata = { "offset" : _set_origin_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(SCREEN_OVERLAY_ORIGIN),) }
    @origin.setter
    def origin(self, origin:"SCREEN_OVERLAY_ORIGIN") -> None:
        return self._intf.set_property(IOverlay._metadata, IOverlay._set_origin_metadata, origin)

    _get_pinning_origin_metadata = { "offset" : _get_pinning_origin_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(SCREEN_OVERLAY_PINNING_ORIGIN),) }
    @property
    def pinning_origin(self) -> "SCREEN_OVERLAY_PINNING_ORIGIN":
        """Get or set the origin of the pinning position property, relative to the overlay..."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_pinning_origin_metadata)

    _set_pinning_origin_metadata = { "offset" : _set_pinning_origin_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(SCREEN_OVERLAY_PINNING_ORIGIN),) }
    @pinning_origin.setter
    def pinning_origin(self, pinningOrigin:"SCREEN_OVERLAY_PINNING_ORIGIN") -> None:
        return self._intf.set_property(IOverlay._metadata, IOverlay._set_pinning_origin_metadata, pinningOrigin)

    _get_parent_metadata = { "offset" : _get_parent_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def parent(self) -> "IScreenOverlayContainer":
        """Get the overlay's parent. This may be another overlay if this overlay was added to that overlay's overlays collection. Or, it may be the screen overlay manager if this overlay was added to the scene manager'sscreen overlays collection."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_parent_metadata)

    _get_translucency_metadata = { "offset" : _get_translucency_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def translucency(self) -> float:
        """Get or set the overlay's translucency. Translucency is a value between 0.0 and 1.0, where 0.0 is completely opaque and 1.0 is completely transparent."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_translucency_metadata)

    _set_translucency_metadata = { "offset" : _set_translucency_method_offset,
            "arg_types" : (agcom.FLOAT,),
            "marshallers" : (agmarshall.FloatArg,) }
    @translucency.setter
    def translucency(self, translucency:float) -> None:
        return self._intf.set_property(IOverlay._metadata, IOverlay._set_translucency_metadata, translucency)

    _get_color_metadata = { "offset" : _get_color_method_offset,
            "arg_types" : (POINTER(agcom.OLE_COLOR),),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @property
    def color(self) -> agcolor.Color:
        """Get or set the overlay's color. By default, the overlay is white."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_color_metadata)

    _set_color_metadata = { "offset" : _set_color_method_offset,
            "arg_types" : (agcom.OLE_COLOR,),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @color.setter
    def color(self, color:agcolor.Color) -> None:
        return self._intf.set_property(IOverlay._metadata, IOverlay._set_color_metadata, color)

    _get_picking_enabled_metadata = { "offset" : _get_picking_enabled_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def picking_enabled(self) -> bool:
        """Get or set a value indicating whether or not picking on the overlay is enabled. If picking is disabled, this overlay will never show up in the result of PickScreenOverlay, even if it occupies the specified pick position."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_picking_enabled_metadata)

    _set_picking_enabled_metadata = { "offset" : _set_picking_enabled_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @picking_enabled.setter
    def picking_enabled(self, pickingEnabled:bool) -> None:
        return self._intf.set_property(IOverlay._metadata, IOverlay._set_picking_enabled_metadata, pickingEnabled)

    _get_clip_to_parent_metadata = { "offset" : _get_clip_to_parent_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def clip_to_parent(self) -> bool:
        """Get or set a value indicating whether or not the overlay will be clipped by the bounds of its parent. If this property is <see langword='false' />, part of this overlay may be visible outside of its parent's bounds."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_clip_to_parent_metadata)

    _set_clip_to_parent_metadata = { "offset" : _set_clip_to_parent_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @clip_to_parent.setter
    def clip_to_parent(self, clipToParent:bool) -> None:
        return self._intf.set_property(IOverlay._metadata, IOverlay._set_clip_to_parent_metadata, clipToParent)

    _get_display_metadata = { "offset" : _get_display_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def display(self) -> bool:
        """Get or set if this overlay and the collection of overlays that are contained within this overlay should be rendered."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_display_metadata)

    _set_display_metadata = { "offset" : _set_display_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @display.setter
    def display(self, display:bool) -> None:
        return self._intf.set_property(IOverlay._metadata, IOverlay._set_display_metadata, display)

    _get_control_position_metadata = { "offset" : _get_control_position_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def control_position(self) -> list:
        """Get the position of the overlay in coordinates relative to the overall globe control. The array represents the position of the overlay and has a size of 4. The elements are in the order x position, y position, x screen overlay unit, y screen overlay unit."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_control_position_metadata)

    _get_control_size_metadata = { "offset" : _get_control_size_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def control_size(self) -> list:
        """Get the size of the overlay in coordinates relative to the overall globe control. The elements are in the order width, height, width screen overlay unit, height screen overlay unit."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_control_size_metadata)

    _get_control_bounds_metadata = { "offset" : _get_control_bounds_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def control_bounds(self) -> list:
        """Get the bounds of the overlay in coordinates relative to the overall globe control. The array contains the properties defining the bounds in the order left x location, top y location, width, height."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_control_bounds_metadata)

    _get_display_condition_metadata = { "offset" : _get_display_condition_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def display_condition(self) -> "IDisplayCondition":
        """Get or set the display condition that determines if the overlay should be rendered. Both this and display must evaluate to true for the overlay to be rendered."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_display_condition_metadata)

    _set_display_condition_metadata = { "offset" : _set_display_condition_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IDisplayCondition"),) }
    @display_condition.setter
    def display_condition(self, displayCondition:"IDisplayCondition") -> None:
        return self._intf.set_property(IOverlay._metadata, IOverlay._set_display_condition_metadata, displayCondition)

    _get_overlays_metadata = { "offset" : _get_overlays_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def overlays(self) -> "ScreenOverlayCollection":
        """Get the collection of overlays that are contained within this overlay."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_overlays_metadata)

    _get_padding_metadata = { "offset" : _get_padding_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def padding(self) -> list:
        """Get or set the padding surrounding the overlays that are contained within this overlay. The array contains the components of the padding arranged in the order left, top, right, bottom."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_padding_metadata)

    _set_padding_metadata = { "offset" : _set_padding_method_offset,
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @padding.setter
    def padding(self, padding:list) -> None:
        return self._intf.set_property(IOverlay._metadata, IOverlay._set_padding_metadata, padding)

    _bring_to_front_metadata = { "offset" : _bring_to_front_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def bring_to_front(self) -> None:
        """Brings the overlay to the front of the z-order, so it is on top of all other overlays with the same parent."""
        return self._intf.invoke(IOverlay._metadata, IOverlay._bring_to_front_metadata, )

    _send_to_back_metadata = { "offset" : _send_to_back_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def send_to_back(self) -> None:
        """Send the overlay to the back of the z-order, so it is underneath all other overlays with the same parent."""
        return self._intf.invoke(IOverlay._metadata, IOverlay._send_to_back_metadata, )

    _overlay_to_control_metadata = { "offset" : _overlay_to_control_method_offset,
            "arg_types" : (agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.LPSafearrayArg,) }
    def overlay_to_control(self, x:float, y:float) -> list:
        """Transform a given position, specified relative to the overlay, into coordinates relative to the overall globe control..."""
        return self._intf.invoke(IOverlay._metadata, IOverlay._overlay_to_control_metadata, x, y, OutArg())

    _control_to_overlay_metadata = { "offset" : _control_to_overlay_method_offset,
            "arg_types" : (agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.LPSafearrayArg,) }
    def control_to_overlay(self, x:float, y:float) -> list:
        """Transform a given position, specified relative to the overall globe control, into coordinates relative to this overlay..."""
        return self._intf.invoke(IOverlay._metadata, IOverlay._control_to_overlay_metadata, x, y, OutArg())

    _get_tag_metadata = { "offset" : _get_tag_method_offset,
            "arg_types" : (POINTER(agcom.Variant),),
            "marshallers" : (agmarshall.VariantArg,) }
    @property
    def tag(self) -> typing.Any:
        """Get or set custom value associated with this primitive."""
        return self._intf.get_property(IOverlay._metadata, IOverlay._get_tag_metadata)

    _set_tag_metadata = { "offset" : _set_tag_method_offset,
            "arg_types" : (agcom.Variant,),
            "marshallers" : (agmarshall.VariantArg,) }
    @tag.setter
    def tag(self, tag:typing.Any) -> None:
        return self._intf.set_property(IOverlay._metadata, IOverlay._set_tag_metadata, tag)

    _property_names[position] = "position"
    _property_names[pinning_position] = "pinning_position"
    _property_names[x] = "x"
    _property_names[x_unit] = "x_unit"
    _property_names[y] = "y"
    _property_names[y_unit] = "y_unit"
    _property_names[size] = "size"
    _property_names[width] = "width"
    _property_names[width_unit] = "width_unit"
    _property_names[height] = "height"
    _property_names[height_unit] = "height_unit"
    _property_names[minimum_size] = "minimum_size"
    _property_names[maximum_size] = "maximum_size"
    _property_names[bounds] = "bounds"
    _property_names[border_color] = "border_color"
    _property_names[border_size] = "border_size"
    _property_names[border_translucency] = "border_translucency"
    _property_names[translation_x] = "translation_x"
    _property_names[translation_y] = "translation_y"
    _property_names[rotation_angle] = "rotation_angle"
    _property_names[rotation_point] = "rotation_point"
    _property_names[scale] = "scale"
    _property_names[flip_x] = "flip_x"
    _property_names[flip_y] = "flip_y"
    _property_names[origin] = "origin"
    _property_names[pinning_origin] = "pinning_origin"
    _property_names[parent] = "parent"
    _property_names[translucency] = "translucency"
    _property_names[color] = "color"
    _property_names[picking_enabled] = "picking_enabled"
    _property_names[clip_to_parent] = "clip_to_parent"
    _property_names[display] = "display"
    _property_names[control_position] = "control_position"
    _property_names[control_size] = "control_size"
    _property_names[control_bounds] = "control_bounds"
    _property_names[display_condition] = "display_condition"
    _property_names[overlays] = "overlays"
    _property_names[padding] = "padding"
    _property_names[tag] = "tag"


agcls.AgClassCatalog.add_catalog_entry((4975169524664922677, 13740715011966152579), IOverlay)
agcls.AgTypeNameMap["IOverlay"] = IOverlay

class IPathPrimitive(object):
    """Render a line to the 3D scene. Similar to the polyline primitive; however, the PathPrimitive was designed for the efficient addition/removal of points to/from the front or back of the line."""

    _num_methods = 31
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_count_method_offset = 1
    _get_capacity_method_offset = 2
    _get_update_policy_method_offset = 3
    _set_update_policy_method_offset = 4
    _get_polyline_type_method_offset = 5
    _set_polyline_type_method_offset = 6
    _get_width_method_offset = 7
    _set_width_method_offset = 8
    _get_minimum_width_supported_method_offset = 9
    _get_maximum_width_supported_method_offset = 10
    _get_display_outline_method_offset = 11
    _set_display_outline_method_offset = 12
    _get_outline_width_method_offset = 13
    _set_outline_width_method_offset = 14
    _get_per_item_picking_enabled_method_offset = 15
    _set_per_item_picking_enabled_method_offset = 16
    _item_method_offset = 17
    _get__NewEnum_method_offset = 18
    _add_front_method_offset = 19
    _add_range_to_front_method_offset = 20
    _add_back_method_offset = 21
    _add_range_to_back_method_offset = 22
    _remove_front_method_offset = 23
    _remove_all_before_method_offset = 24
    _remove_back_method_offset = 25
    _remove_all_after_method_offset = 26
    _front_method_offset = 27
    _back_method_offset = 28
    _clear_method_offset = 29
    _get_central_body_clipped_method_offset = 30
    _set_central_body_clipped_method_offset = 31
    _metadata = {
        "iid_data" : (4696601357917811424, 5934065904138946973),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IPathPrimitive."""
        initialize_from_source_object(self, sourceObject, IPathPrimitive)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IPathPrimitive)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IPathPrimitive, None)
    def __iter__(self):
        """Create an iterator for the IPathPrimitive object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "IPathPoint":
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def count(self) -> int:
        """Return the number of points."""
        return self._intf.get_property(IPathPrimitive._metadata, IPathPrimitive._get_count_metadata)

    _get_capacity_metadata = { "offset" : _get_capacity_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def capacity(self) -> int:
        """Return the capacity that was set during object construction. The capacity is the amount of memory reserved for storing the points on the path. This will be automatically updated when adding/removing points."""
        return self._intf.get_property(IPathPrimitive._metadata, IPathPrimitive._get_capacity_metadata)

    _get_update_policy_metadata = { "offset" : _get_update_policy_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def update_policy(self) -> "IPathPrimitiveUpdatePolicy":
        """Get or set how the primitive will be updated based on the current animation time."""
        return self._intf.get_property(IPathPrimitive._metadata, IPathPrimitive._get_update_policy_metadata)

    _set_update_policy_metadata = { "offset" : _set_update_policy_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IPathPrimitiveUpdatePolicy"),) }
    @update_policy.setter
    def update_policy(self, updatePolicy:"IPathPrimitiveUpdatePolicy") -> None:
        return self._intf.set_property(IPathPrimitive._metadata, IPathPrimitive._set_update_policy_metadata, updatePolicy)

    _get_polyline_type_metadata = { "offset" : _get_polyline_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(POLYLINE_TYPE),) }
    @property
    def polyline_type(self) -> "POLYLINE_TYPE":
        """Get or set how the primitive interprets the positions."""
        return self._intf.get_property(IPathPrimitive._metadata, IPathPrimitive._get_polyline_type_metadata)

    _set_polyline_type_metadata = { "offset" : _set_polyline_type_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(POLYLINE_TYPE),) }
    @polyline_type.setter
    def polyline_type(self, polylineType:"POLYLINE_TYPE") -> None:
        return self._intf.set_property(IPathPrimitive._metadata, IPathPrimitive._set_polyline_type_metadata, polylineType)

    _get_width_metadata = { "offset" : _get_width_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def width(self) -> float:
        """Get or set the line width, in pixels."""
        return self._intf.get_property(IPathPrimitive._metadata, IPathPrimitive._get_width_metadata)

    _set_width_metadata = { "offset" : _set_width_method_offset,
            "arg_types" : (agcom.FLOAT,),
            "marshallers" : (agmarshall.FloatArg,) }
    @width.setter
    def width(self, width:float) -> None:
        return self._intf.set_property(IPathPrimitive._metadata, IPathPrimitive._set_width_metadata, width)

    _get_minimum_width_supported_metadata = { "offset" : _get_minimum_width_supported_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def minimum_width_supported(self) -> float:
        """Get the minimum width, in pixels, supported by the video card."""
        return self._intf.get_property(IPathPrimitive._metadata, IPathPrimitive._get_minimum_width_supported_metadata)

    _get_maximum_width_supported_metadata = { "offset" : _get_maximum_width_supported_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def maximum_width_supported(self) -> float:
        """Get the maximum width, in pixels, supported by the video card."""
        return self._intf.get_property(IPathPrimitive._metadata, IPathPrimitive._get_maximum_width_supported_metadata)

    _get_display_outline_metadata = { "offset" : _get_display_outline_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def display_outline(self) -> bool:
        """Get or set whether an outline is rendered around the line."""
        return self._intf.get_property(IPathPrimitive._metadata, IPathPrimitive._get_display_outline_metadata)

    _set_display_outline_metadata = { "offset" : _set_display_outline_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @display_outline.setter
    def display_outline(self, displayOutline:bool) -> None:
        return self._intf.set_property(IPathPrimitive._metadata, IPathPrimitive._set_display_outline_metadata, displayOutline)

    _get_outline_width_metadata = { "offset" : _get_outline_width_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def outline_width(self) -> float:
        """Get or set the width, in pixels, of the outline around the line."""
        return self._intf.get_property(IPathPrimitive._metadata, IPathPrimitive._get_outline_width_metadata)

    _set_outline_width_metadata = { "offset" : _set_outline_width_method_offset,
            "arg_types" : (agcom.FLOAT,),
            "marshallers" : (agmarshall.FloatArg,) }
    @outline_width.setter
    def outline_width(self, outlineWidth:float) -> None:
        return self._intf.set_property(IPathPrimitive._metadata, IPathPrimitive._set_outline_width_metadata, outlineWidth)

    _get_per_item_picking_enabled_metadata = { "offset" : _get_per_item_picking_enabled_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def per_item_picking_enabled(self) -> bool:
        """Get or set whether individual line indices will be included in the pick results returned from the scene's Pick method. Each line index that is picked will be returned as a batch primitive index."""
        return self._intf.get_property(IPathPrimitive._metadata, IPathPrimitive._get_per_item_picking_enabled_metadata)

    _set_per_item_picking_enabled_metadata = { "offset" : _set_per_item_picking_enabled_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @per_item_picking_enabled.setter
    def per_item_picking_enabled(self, perItemPickingEnabled:bool) -> None:
        return self._intf.set_property(IPathPrimitive._metadata, IPathPrimitive._set_per_item_picking_enabled_metadata, perItemPickingEnabled)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def item(self, index:int) -> "PathPoint":
        """Return the point at the given zero-based index."""
        return self._intf.invoke(IPathPrimitive._metadata, IPathPrimitive._item_metadata, index, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        """Return an enumerator that iterates through the collection."""
        return self._intf.get_property(IPathPrimitive._metadata, IPathPrimitive._get__NewEnum_metadata)

    _add_front_metadata = { "offset" : _add_front_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IPathPoint"),) }
    def add_front(self, pathPoint:"IPathPoint") -> None:
        """Add a path point to the front of the line."""
        return self._intf.invoke(IPathPrimitive._metadata, IPathPrimitive._add_front_metadata, pathPoint)

    _add_range_to_front_metadata = { "offset" : _add_range_to_front_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    def add_range_to_front(self, positions:list) -> None:
        """Add the range of path points to the front of the line."""
        return self._intf.invoke(IPathPrimitive._metadata, IPathPrimitive._add_range_to_front_metadata, positions)

    _add_back_metadata = { "offset" : _add_back_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IPathPoint"),) }
    def add_back(self, pathPoint:"IPathPoint") -> None:
        """Add a path point to the back of the line."""
        return self._intf.invoke(IPathPrimitive._metadata, IPathPrimitive._add_back_metadata, pathPoint)

    _add_range_to_back_metadata = { "offset" : _add_range_to_back_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    def add_range_to_back(self, positions:list) -> None:
        """Add the range of path points to the back of the line."""
        return self._intf.invoke(IPathPrimitive._metadata, IPathPrimitive._add_range_to_back_metadata, positions)

    _remove_front_metadata = { "offset" : _remove_front_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def remove_front(self) -> None:
        """Remove a path point to the front of the line."""
        return self._intf.invoke(IPathPrimitive._metadata, IPathPrimitive._remove_front_metadata, )

    _remove_all_before_metadata = { "offset" : _remove_all_before_method_offset,
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.IntArg,) }
    def remove_all_before(self, index:int) -> None:
        """Remove all points before index."""
        return self._intf.invoke(IPathPrimitive._metadata, IPathPrimitive._remove_all_before_metadata, index)

    _remove_back_metadata = { "offset" : _remove_back_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def remove_back(self) -> None:
        """Remove a path point to the back of the line."""
        return self._intf.invoke(IPathPrimitive._metadata, IPathPrimitive._remove_back_metadata, )

    _remove_all_after_metadata = { "offset" : _remove_all_after_method_offset,
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.IntArg,) }
    def remove_all_after(self, index:int) -> None:
        """Remove all points after index."""
        return self._intf.invoke(IPathPrimitive._metadata, IPathPrimitive._remove_all_after_metadata, index)

    _front_metadata = { "offset" : _front_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def front(self) -> "PathPoint":
        """Access the path point at the front of the line."""
        return self._intf.invoke(IPathPrimitive._metadata, IPathPrimitive._front_metadata, OutArg())

    _back_metadata = { "offset" : _back_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def back(self) -> "PathPoint":
        """Access the path point at the back of the line."""
        return self._intf.invoke(IPathPrimitive._metadata, IPathPrimitive._back_metadata, OutArg())

    _clear_metadata = { "offset" : _clear_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def clear(self) -> None:
        """Remove all of the points."""
        return self._intf.invoke(IPathPrimitive._metadata, IPathPrimitive._clear_metadata, )

    _get_central_body_clipped_metadata = { "offset" : _get_central_body_clipped_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def central_body_clipped(self) -> bool:
        """Get or set whether the polyline will be clipped by the central body."""
        return self._intf.get_property(IPathPrimitive._metadata, IPathPrimitive._get_central_body_clipped_metadata)

    _set_central_body_clipped_metadata = { "offset" : _set_central_body_clipped_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @central_body_clipped.setter
    def central_body_clipped(self, centralBodyClipped:bool) -> None:
        return self._intf.set_property(IPathPrimitive._metadata, IPathPrimitive._set_central_body_clipped_metadata, centralBodyClipped)

    __getitem__ = item


    _property_names[count] = "count"
    _property_names[capacity] = "capacity"
    _property_names[update_policy] = "update_policy"
    _property_names[polyline_type] = "polyline_type"
    _property_names[width] = "width"
    _property_names[minimum_width_supported] = "minimum_width_supported"
    _property_names[maximum_width_supported] = "maximum_width_supported"
    _property_names[display_outline] = "display_outline"
    _property_names[outline_width] = "outline_width"
    _property_names[per_item_picking_enabled] = "per_item_picking_enabled"
    _property_names[_NewEnum] = "_NewEnum"
    _property_names[central_body_clipped] = "central_body_clipped"


agcls.AgClassCatalog.add_catalog_entry((4696601357917811424, 5934065904138946973), IPathPrimitive)
agcls.AgTypeNameMap["IPathPrimitive"] = IPathPrimitive

class IPickResult(object):
    """A single result from Pick."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_objects_method_offset = 1
    _get_depth_method_offset = 2
    _get_position_method_offset = 3
    _metadata = {
        "iid_data" : (5469424382237706852, 5401777624284253099),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IPickResult."""
        initialize_from_source_object(self, sourceObject, IPickResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IPickResult)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IPickResult, None)
    
    _get_objects_metadata = { "offset" : _get_objects_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def objects(self) -> "ObjectCollection":
        """Get a collection of objects that were on the pick stack for the picked object."""
        return self._intf.get_property(IPickResult._metadata, IPickResult._get_objects_metadata)

    _get_depth_metadata = { "offset" : _get_depth_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def depth(self) -> float:
        """Get the depth of the picked location in the 3D scene."""
        return self._intf.get_property(IPickResult._metadata, IPickResult._get_depth_metadata)

    _get_position_metadata = { "offset" : _get_position_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def position(self) -> list:
        """Get the position of the picked location in the central body's fixed reference frame. The array contains the components of the position arranged in the order x, y, z."""
        return self._intf.get_property(IPickResult._metadata, IPickResult._get_position_metadata)

    _property_names[objects] = "objects"
    _property_names[depth] = "depth"
    _property_names[position] = "position"


agcls.AgClassCatalog.add_catalog_entry((5469424382237706852, 5401777624284253099), IPickResult)
agcls.AgTypeNameMap["IPickResult"] = IPickResult

class IPixelSizeDisplayCondition(object):
    """Define an inclusive interval, in pixels, that determines when an object, such as a primitive, is rendered based on the number of pixels the object's bounding sphere (or in the case of screen overlays, bounding rectangle) covers on the screen..."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_minimum_pixel_size_method_offset = 1
    _set_minimum_pixel_size_method_offset = 2
    _get_maximum_pixel_size_method_offset = 3
    _set_maximum_pixel_size_method_offset = 4
    _metadata = {
        "iid_data" : (5696107621766714896, 13788591222461518237),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IPixelSizeDisplayCondition."""
        initialize_from_source_object(self, sourceObject, IPixelSizeDisplayCondition)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IPixelSizeDisplayCondition)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IPixelSizeDisplayCondition, None)
    
    _get_minimum_pixel_size_metadata = { "offset" : _get_minimum_pixel_size_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def minimum_pixel_size(self) -> int:
        """Get or set the minimum pixel size of the inclusive distance interval."""
        return self._intf.get_property(IPixelSizeDisplayCondition._metadata, IPixelSizeDisplayCondition._get_minimum_pixel_size_metadata)

    _set_minimum_pixel_size_metadata = { "offset" : _set_minimum_pixel_size_method_offset,
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.IntArg,) }
    @minimum_pixel_size.setter
    def minimum_pixel_size(self, minimumPixelSize:int) -> None:
        return self._intf.set_property(IPixelSizeDisplayCondition._metadata, IPixelSizeDisplayCondition._set_minimum_pixel_size_metadata, minimumPixelSize)

    _get_maximum_pixel_size_metadata = { "offset" : _get_maximum_pixel_size_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def maximum_pixel_size(self) -> int:
        """Get or set the maximum pixel size of the inclusive distance interval. Use Int32.MaxValue to ignore checking the maximum distance."""
        return self._intf.get_property(IPixelSizeDisplayCondition._metadata, IPixelSizeDisplayCondition._get_maximum_pixel_size_metadata)

    _set_maximum_pixel_size_metadata = { "offset" : _set_maximum_pixel_size_method_offset,
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.IntArg,) }
    @maximum_pixel_size.setter
    def maximum_pixel_size(self, maximumPixelSize:int) -> None:
        return self._intf.set_property(IPixelSizeDisplayCondition._metadata, IPixelSizeDisplayCondition._set_maximum_pixel_size_metadata, maximumPixelSize)

    _property_names[minimum_pixel_size] = "minimum_pixel_size"
    _property_names[maximum_pixel_size] = "maximum_pixel_size"


agcls.AgClassCatalog.add_catalog_entry((5696107621766714896, 13788591222461518237), IPixelSizeDisplayCondition)
agcls.AgTypeNameMap["IPixelSizeDisplayCondition"] = IPixelSizeDisplayCondition

class IPointBatchPrimitive(object):
    """Render one or more points in the 3D scene. Each point in the batch has a unique position and an optional color. All points in the batch share the same pixel size. For best performance, avoid creating lots of batches with only a few points each..."""

    _num_methods = 34
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_display_outline_method_offset = 1
    _set_display_outline_method_offset = 2
    _get_outline_color_method_offset = 3
    _set_outline_color_method_offset = 4
    _get_outline_translucency_method_offset = 5
    _set_outline_translucency_method_offset = 6
    _get_outline_width_method_offset = 7
    _set_outline_width_method_offset = 8
    _get_pixel_size_method_offset = 9
    _set_pixel_size_method_offset = 10
    _get_minimum_pixel_size_supported_method_offset = 11
    _get_maximum_pixel_size_supported_method_offset = 12
    _get_distance_display_condition_per_point_method_offset = 13
    _set_distance_display_condition_per_point_method_offset = 14
    _get_set_hint_method_offset = 15
    _get_per_item_picking_enabled_method_offset = 16
    _set_per_item_picking_enabled_method_offset = 17
    _set_method_offset = 18
    _set_with_colors_method_offset = 19
    _set_with_colors_and_render_pass_method_offset = 20
    _set_cartographic_method_offset = 21
    _set_cartographic_with_colors_method_offset = 22
    _set_cartographic_with_colors_and_render_pass_method_offset = 23
    _set_partial_method_offset = 24
    _set_partial_with_indices_order_method_offset = 25
    _set_partial_with_colors_method_offset = 26
    _set_partial_with_colors_indices_order_and_render_pass_method_offset = 27
    _set_partial_cartographic_method_offset = 28
    _set_partial_cartographic_with_indices_order_method_offset = 29
    _set_partial_cartographic_with_colors_method_offset = 30
    _set_partial_cartographic_with_colors_indices_order_and_render_pass_method_offset = 31
    _get_central_body_clipped_method_offset = 32
    _set_central_body_clipped_method_offset = 33
    _set_with_optional_parameters_method_offset = 34
    _metadata = {
        "iid_data" : (4907018134519311818, 5049913687853084042),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IPointBatchPrimitive."""
        initialize_from_source_object(self, sourceObject, IPointBatchPrimitive)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IPointBatchPrimitive)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IPointBatchPrimitive, None)
    
    _get_display_outline_metadata = { "offset" : _get_display_outline_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def display_outline(self) -> bool:
        """Get or set whether an outline is rendered around each point in the batch."""
        return self._intf.get_property(IPointBatchPrimitive._metadata, IPointBatchPrimitive._get_display_outline_metadata)

    _set_display_outline_metadata = { "offset" : _set_display_outline_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @display_outline.setter
    def display_outline(self, displayOutline:bool) -> None:
        return self._intf.set_property(IPointBatchPrimitive._metadata, IPointBatchPrimitive._set_display_outline_metadata, displayOutline)

    _get_outline_color_metadata = { "offset" : _get_outline_color_method_offset,
            "arg_types" : (POINTER(agcom.OLE_COLOR),),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @property
    def outline_color(self) -> agcolor.Color:
        """Get or set the outline's color."""
        return self._intf.get_property(IPointBatchPrimitive._metadata, IPointBatchPrimitive._get_outline_color_metadata)

    _set_outline_color_metadata = { "offset" : _set_outline_color_method_offset,
            "arg_types" : (agcom.OLE_COLOR,),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @outline_color.setter
    def outline_color(self, outlineColor:agcolor.Color) -> None:
        return self._intf.set_property(IPointBatchPrimitive._metadata, IPointBatchPrimitive._set_outline_color_metadata, outlineColor)

    _get_outline_translucency_metadata = { "offset" : _get_outline_translucency_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def outline_translucency(self) -> float:
        """Get or set the translucency of the outline. Translucency is between 0 and 1, where 0 is opaque and 1 is transparent."""
        return self._intf.get_property(IPointBatchPrimitive._metadata, IPointBatchPrimitive._get_outline_translucency_metadata)

    _set_outline_translucency_metadata = { "offset" : _set_outline_translucency_method_offset,
            "arg_types" : (agcom.FLOAT,),
            "marshallers" : (agmarshall.FloatArg,) }
    @outline_translucency.setter
    def outline_translucency(self, outlineTranslucency:float) -> None:
        return self._intf.set_property(IPointBatchPrimitive._metadata, IPointBatchPrimitive._set_outline_translucency_metadata, outlineTranslucency)

    _get_outline_width_metadata = { "offset" : _get_outline_width_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def outline_width(self) -> float:
        """Get or set the size, in pixels, of the outline around each point in the batch."""
        return self._intf.get_property(IPointBatchPrimitive._metadata, IPointBatchPrimitive._get_outline_width_metadata)

    _set_outline_width_metadata = { "offset" : _set_outline_width_method_offset,
            "arg_types" : (agcom.FLOAT,),
            "marshallers" : (agmarshall.FloatArg,) }
    @outline_width.setter
    def outline_width(self, outlineWidth:float) -> None:
        return self._intf.set_property(IPointBatchPrimitive._metadata, IPointBatchPrimitive._set_outline_width_metadata, outlineWidth)

    _get_pixel_size_metadata = { "offset" : _get_pixel_size_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def pixel_size(self) -> float:
        """Get or set the size, in pixels, of each point in the point batch."""
        return self._intf.get_property(IPointBatchPrimitive._metadata, IPointBatchPrimitive._get_pixel_size_metadata)

    _set_pixel_size_metadata = { "offset" : _set_pixel_size_method_offset,
            "arg_types" : (agcom.FLOAT,),
            "marshallers" : (agmarshall.FloatArg,) }
    @pixel_size.setter
    def pixel_size(self, pixelSize:float) -> None:
        return self._intf.set_property(IPointBatchPrimitive._metadata, IPointBatchPrimitive._set_pixel_size_metadata, pixelSize)

    _get_minimum_pixel_size_supported_metadata = { "offset" : _get_minimum_pixel_size_supported_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def minimum_pixel_size_supported(self) -> float:
        """Get the minimum pixel size supported by the video card."""
        return self._intf.get_property(IPointBatchPrimitive._metadata, IPointBatchPrimitive._get_minimum_pixel_size_supported_metadata)

    _get_maximum_pixel_size_supported_metadata = { "offset" : _get_maximum_pixel_size_supported_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def maximum_pixel_size_supported(self) -> float:
        """Get the maximum pixel size supported by the video card."""
        return self._intf.get_property(IPointBatchPrimitive._metadata, IPointBatchPrimitive._get_maximum_pixel_size_supported_metadata)

    _get_distance_display_condition_per_point_metadata = { "offset" : _get_distance_display_condition_per_point_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def distance_display_condition_per_point(self) -> "DistanceDisplayCondition":
        """Get or set a distance display condition that is evaluated per point in the point batch during rendering. This is different than display condition, which is evaluated once for the entire point batch..."""
        return self._intf.get_property(IPointBatchPrimitive._metadata, IPointBatchPrimitive._get_distance_display_condition_per_point_metadata)

    _set_distance_display_condition_per_point_metadata = { "offset" : _set_distance_display_condition_per_point_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IDistanceDisplayCondition"),) }
    @distance_display_condition_per_point.setter
    def distance_display_condition_per_point(self, distanceDisplayConditionPerPoint:"IDistanceDisplayCondition") -> None:
        return self._intf.set_property(IPointBatchPrimitive._metadata, IPointBatchPrimitive._set_distance_display_condition_per_point_metadata, distanceDisplayConditionPerPoint)

    _get_set_hint_metadata = { "offset" : _get_set_hint_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(SET_HINT),) }
    @property
    def set_hint(self) -> "SET_HINT":
        """Get the primitive's set hint. See the Set Hint Performance Overview for selecting an appropriate value to construct the primitive with."""
        return self._intf.get_property(IPointBatchPrimitive._metadata, IPointBatchPrimitive._get_set_hint_metadata)

    _get_per_item_picking_enabled_metadata = { "offset" : _get_per_item_picking_enabled_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def per_item_picking_enabled(self) -> bool:
        """Get or set whether individual point indices will be included in the pick results returned from the scene's Pick method. Each point index that is picked will be returned as a batch primitive index."""
        return self._intf.get_property(IPointBatchPrimitive._metadata, IPointBatchPrimitive._get_per_item_picking_enabled_metadata)

    _set_per_item_picking_enabled_metadata = { "offset" : _set_per_item_picking_enabled_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @per_item_picking_enabled.setter
    def per_item_picking_enabled(self, perItemPickingEnabled:bool) -> None:
        return self._intf.set_property(IPointBatchPrimitive._metadata, IPointBatchPrimitive._set_per_item_picking_enabled_metadata, perItemPickingEnabled)

    _set_metadata = { "offset" : _set_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    def set(self, positions:list) -> None:
        """Define the positions of points in a point batch. The points are rendered in the primitive's reference frame."""
        return self._intf.invoke(IPointBatchPrimitive._metadata, IPointBatchPrimitive._set_metadata, positions)

    _set_with_colors_metadata = { "offset" : _set_with_colors_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg,) }
    def set_with_colors(self, positions:list, colors:list) -> None:
        """Define the positions and colors of points in a point batch. The points are rendered in the primitive's reference frame."""
        return self._intf.invoke(IPointBatchPrimitive._metadata, IPointBatchPrimitive._set_with_colors_metadata, positions, colors)

    _set_with_colors_and_render_pass_metadata = { "offset" : _set_with_colors_and_render_pass_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), agcom.LONG,),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.EnumArg(RENDER_PASS_HINT),) }
    def set_with_colors_and_render_pass(self, positions:list, colors:list, renderPassHint:"RENDER_PASS_HINT") -> None:
        """Define the positions and colors of points in a point batch. The points are rendered in the primitive's reference frame. renderPassHint is provided for efficiency."""
        return self._intf.invoke(IPointBatchPrimitive._metadata, IPointBatchPrimitive._set_with_colors_and_render_pass_metadata, positions, colors, renderPassHint)

    _set_cartographic_metadata = { "offset" : _set_cartographic_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg,) }
    def set_cartographic(self, centralBody:str, positions:list) -> None:
        """For convenience. Defines the positions of points in a point batch using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling Set."""
        return self._intf.invoke(IPointBatchPrimitive._metadata, IPointBatchPrimitive._set_cartographic_metadata, centralBody, positions)

    _set_cartographic_with_colors_metadata = { "offset" : _set_cartographic_with_colors_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg,) }
    def set_cartographic_with_colors(self, centralBody:str, positions:list, colors:list) -> None:
        """For convenience. Defines the positions and colors of points in a point batch using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling Set."""
        return self._intf.invoke(IPointBatchPrimitive._metadata, IPointBatchPrimitive._set_cartographic_with_colors_metadata, centralBody, positions, colors)

    _set_cartographic_with_colors_and_render_pass_metadata = { "offset" : _set_cartographic_with_colors_and_render_pass_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), agcom.LONG,),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.EnumArg(RENDER_PASS_HINT),) }
    def set_cartographic_with_colors_and_render_pass(self, centralBody:str, positions:list, colors:list, renderPassHint:"RENDER_PASS_HINT") -> None:
        """For convenience. Defines the positions and colors of points in a point batch using cartographic positions. renderPassHint is provided for efficiency. This is equivalent to converting each position in positions to cartesian and calling Set."""
        return self._intf.invoke(IPointBatchPrimitive._metadata, IPointBatchPrimitive._set_cartographic_with_colors_and_render_pass_metadata, centralBody, positions, colors, renderPassHint)

    _set_partial_metadata = { "offset" : _set_partial_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg,) }
    def set_partial(self, positions:list, indices:list) -> None:
        """Update a subset of positions in a point batch."""
        return self._intf.invoke(IPointBatchPrimitive._metadata, IPointBatchPrimitive._set_partial_metadata, positions, indices)

    _set_partial_with_indices_order_metadata = { "offset" : _set_partial_with_indices_order_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), agcom.LONG,),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.EnumArg(INDICES_ORDER_HINT),) }
    def set_partial_with_indices_order(self, positions:list, indices:list, indicesOrderHint:"INDICES_ORDER_HINT") -> None:
        """Update a subset of positions in a point batch."""
        return self._intf.invoke(IPointBatchPrimitive._metadata, IPointBatchPrimitive._set_partial_with_indices_order_metadata, positions, indices, indicesOrderHint)

    _set_partial_with_colors_metadata = { "offset" : _set_partial_with_colors_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg,) }
    def set_partial_with_colors(self, positions:list, colors:list, indices:list) -> None:
        """Update a subset of positions and/or colors in a point batch."""
        return self._intf.invoke(IPointBatchPrimitive._metadata, IPointBatchPrimitive._set_partial_with_colors_metadata, positions, colors, indices)

    _set_partial_with_colors_indices_order_and_render_pass_metadata = { "offset" : _set_partial_with_colors_indices_order_and_render_pass_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), agcom.LONG, agcom.LONG,),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.EnumArg(INDICES_ORDER_HINT), agmarshall.EnumArg(RENDER_PASS_HINT),) }
    def set_partial_with_colors_indices_order_and_render_pass(self, positions:list, colors:list, indices:list, indicesOrderHint:"INDICES_ORDER_HINT", renderPassHint:"RENDER_PASS_HINT") -> None:
        """Update a subset of positions and/or colors in a point batch."""
        return self._intf.invoke(IPointBatchPrimitive._metadata, IPointBatchPrimitive._set_partial_with_colors_indices_order_and_render_pass_metadata, positions, colors, indices, indicesOrderHint, renderPassHint)

    _set_partial_cartographic_metadata = { "offset" : _set_partial_cartographic_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg,) }
    def set_partial_cartographic(self, centralBody:str, positions:list, indices:list) -> None:
        """For convenience. Updates a subset of positions in a point batch using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling SetPartial."""
        return self._intf.invoke(IPointBatchPrimitive._metadata, IPointBatchPrimitive._set_partial_cartographic_metadata, centralBody, positions, indices)

    _set_partial_cartographic_with_indices_order_metadata = { "offset" : _set_partial_cartographic_with_indices_order_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), agcom.LONG,),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.EnumArg(INDICES_ORDER_HINT),) }
    def set_partial_cartographic_with_indices_order(self, centralBody:str, positions:list, indices:list, indicesOrderHint:"INDICES_ORDER_HINT") -> None:
        """For convenience. Updates a subset of positions in a point batch using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling SetPartial."""
        return self._intf.invoke(IPointBatchPrimitive._metadata, IPointBatchPrimitive._set_partial_cartographic_with_indices_order_metadata, centralBody, positions, indices, indicesOrderHint)

    _set_partial_cartographic_with_colors_metadata = { "offset" : _set_partial_cartographic_with_colors_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg,) }
    def set_partial_cartographic_with_colors(self, centralBody:str, positions:list, colors:list, indices:list) -> None:
        """For convenience. Updates a subset of positions and/or colors in a point batch using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling SetPartial."""
        return self._intf.invoke(IPointBatchPrimitive._metadata, IPointBatchPrimitive._set_partial_cartographic_with_colors_metadata, centralBody, positions, colors, indices)

    _set_partial_cartographic_with_colors_indices_order_and_render_pass_metadata = { "offset" : _set_partial_cartographic_with_colors_indices_order_and_render_pass_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), agcom.LONG, agcom.LONG,),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.EnumArg(INDICES_ORDER_HINT), agmarshall.EnumArg(RENDER_PASS_HINT),) }
    def set_partial_cartographic_with_colors_indices_order_and_render_pass(self, centralBody:str, positions:list, colors:list, indices:list, indicesOrderHint:"INDICES_ORDER_HINT", renderPassHint:"RENDER_PASS_HINT") -> None:
        """For convenience. Updates a subset of positions and/or colors in a point batch using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling SetPartial."""
        return self._intf.invoke(IPointBatchPrimitive._metadata, IPointBatchPrimitive._set_partial_cartographic_with_colors_indices_order_and_render_pass_metadata, centralBody, positions, colors, indices, indicesOrderHint, renderPassHint)

    _get_central_body_clipped_metadata = { "offset" : _get_central_body_clipped_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def central_body_clipped(self) -> bool:
        """Get or set whether individual points will be clipped by the central body."""
        return self._intf.get_property(IPointBatchPrimitive._metadata, IPointBatchPrimitive._get_central_body_clipped_metadata)

    _set_central_body_clipped_metadata = { "offset" : _set_central_body_clipped_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @central_body_clipped.setter
    def central_body_clipped(self, centralBodyClipped:bool) -> None:
        return self._intf.set_property(IPointBatchPrimitive._metadata, IPointBatchPrimitive._set_central_body_clipped_metadata, centralBodyClipped)

    _set_with_optional_parameters_metadata = { "offset" : _set_with_optional_parameters_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), agcom.PVOID, agcom.LONG,),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.InterfaceInArg("IPointBatchPrimitiveOptionalParameters"), agmarshall.EnumArg(RENDER_PASS_HINT),) }
    def set_with_optional_parameters(self, positions:list, colors:list, optionalParameters:"IPointBatchPrimitiveOptionalParameters", renderPassHint:"RENDER_PASS_HINT") -> None:
        """Define the positions, colors, and optional parameters of points in a point batch. The points are rendered in the primitive's reference frame. renderPassHint is provided for efficiency."""
        return self._intf.invoke(IPointBatchPrimitive._metadata, IPointBatchPrimitive._set_with_optional_parameters_metadata, positions, colors, optionalParameters, renderPassHint)

    _property_names[display_outline] = "display_outline"
    _property_names[outline_color] = "outline_color"
    _property_names[outline_translucency] = "outline_translucency"
    _property_names[outline_width] = "outline_width"
    _property_names[pixel_size] = "pixel_size"
    _property_names[minimum_pixel_size_supported] = "minimum_pixel_size_supported"
    _property_names[maximum_pixel_size_supported] = "maximum_pixel_size_supported"
    _property_names[distance_display_condition_per_point] = "distance_display_condition_per_point"
    _property_names[set_hint] = "set_hint"
    _property_names[per_item_picking_enabled] = "per_item_picking_enabled"
    _property_names[central_body_clipped] = "central_body_clipped"


agcls.AgClassCatalog.add_catalog_entry((4907018134519311818, 5049913687853084042), IPointBatchPrimitive)
agcls.AgTypeNameMap["IPointBatchPrimitive"] = IPointBatchPrimitive

class IPointBatchPrimitiveOptionalParameters(object):
    """Optional per-point parameters for point batch primitive that overrides the point batch primitive's global parameters..."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _set_pixel_sizes_method_offset = 1
    _metadata = {
        "iid_data" : (5205056675059894066, 5948443580933544383),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IPointBatchPrimitiveOptionalParameters."""
        initialize_from_source_object(self, sourceObject, IPointBatchPrimitiveOptionalParameters)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IPointBatchPrimitiveOptionalParameters)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IPointBatchPrimitiveOptionalParameters, None)
    
    _set_pixel_sizes_metadata = { "offset" : _set_pixel_sizes_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    def set_pixel_sizes(self, pixelSizes:list) -> None:
        """Define a collection of pixel sizes, one for each point in the point batch."""
        return self._intf.invoke(IPointBatchPrimitiveOptionalParameters._metadata, IPointBatchPrimitiveOptionalParameters._set_pixel_sizes_metadata, pixelSizes)


agcls.AgClassCatalog.add_catalog_entry((5205056675059894066, 5948443580933544383), IPointBatchPrimitiveOptionalParameters)
agcls.AgTypeNameMap["IPointBatchPrimitiveOptionalParameters"] = IPointBatchPrimitiveOptionalParameters

class IPolylinePrimitive(object):
    """Render a polyline in the 3D scene. Each line segment may have a different color. A polyline can be constructed with a position interpolator to render great arcs or rhumb lines."""

    _num_methods = 42
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_width_method_offset = 1
    _set_width_method_offset = 2
    _get_minimum_width_supported_method_offset = 3
    _get_maximum_width_supported_method_offset = 4
    _get_position_interpolator_method_offset = 5
    _get_polyline_type_method_offset = 6
    _get_set_hint_method_offset = 7
    _get_display_outline_method_offset = 8
    _set_display_outline_method_offset = 9
    _get_outline_color_method_offset = 10
    _set_outline_color_method_offset = 11
    _get_outline_translucency_method_offset = 12
    _set_outline_translucency_method_offset = 13
    _get_outline_width_method_offset = 14
    _set_outline_width_method_offset = 15
    _get_per_item_picking_enabled_method_offset = 16
    _set_per_item_picking_enabled_method_offset = 17
    _set_method_offset = 18
    _set_with_colors_method_offset = 19
    _set_with_colors_and_hint_method_offset = 20
    _set_with_surface_shapes_result_method_offset = 21
    _set_with_surface_triangulator_result_method_offset = 22
    _set_with_solid_triangulator_result_method_offset = 23
    _set_cartographic_method_offset = 24
    _set_cartographic_with_colors_method_offset = 25
    _set_cartographic_with_colors_and_hint_method_offset = 26
    _set_subset_method_offset = 27
    _set_subset_cartographic_method_offset = 28
    _set_partial_method_offset = 29
    _set_partial_with_indices_order_method_offset = 30
    _set_partial_with_colors_method_offset = 31
    _set_partial_with_colors_indices_order_and_render_pass_hint_method_offset = 32
    _set_partial_cartographic_method_offset = 33
    _set_partial_cartographic_with_indices_order_method_offset = 34
    _set_partial_cartographic_with_colors_method_offset = 35
    _set_partial_cartographic_with_colors_indices_order_and_render_pass_method_offset = 36
    _get_central_body_clipped_method_offset = 37
    _set_central_body_clipped_method_offset = 38
    _set_with_colors_and_optional_parameters_method_offset = 39
    _set_cartographic_with_colors_and_optional_parameters_method_offset = 40
    _set_partial_with_colors_and_optional_parameters_method_offset = 41
    _set_partial_cartographic_with_optional_parameters_method_offset = 42
    _metadata = {
        "iid_data" : (4917159150693309483, 4735648436991941304),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IPolylinePrimitive."""
        initialize_from_source_object(self, sourceObject, IPolylinePrimitive)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IPolylinePrimitive)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IPolylinePrimitive, None)
    
    _get_width_metadata = { "offset" : _get_width_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def width(self) -> float:
        """Get or set the line width, in pixels."""
        return self._intf.get_property(IPolylinePrimitive._metadata, IPolylinePrimitive._get_width_metadata)

    _set_width_metadata = { "offset" : _set_width_method_offset,
            "arg_types" : (agcom.FLOAT,),
            "marshallers" : (agmarshall.FloatArg,) }
    @width.setter
    def width(self, width:float) -> None:
        return self._intf.set_property(IPolylinePrimitive._metadata, IPolylinePrimitive._set_width_metadata, width)

    _get_minimum_width_supported_metadata = { "offset" : _get_minimum_width_supported_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def minimum_width_supported(self) -> float:
        """Get the minimum width, in pixels, supported by the video card."""
        return self._intf.get_property(IPolylinePrimitive._metadata, IPolylinePrimitive._get_minimum_width_supported_metadata)

    _get_maximum_width_supported_metadata = { "offset" : _get_maximum_width_supported_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def maximum_width_supported(self) -> float:
        """Get the maximum width, in pixels, supported by the video card."""
        return self._intf.get_property(IPolylinePrimitive._metadata, IPolylinePrimitive._get_maximum_width_supported_metadata)

    _get_position_interpolator_metadata = { "offset" : _get_position_interpolator_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def position_interpolator(self) -> "IPositionInterpolator":
        """Get the position interpolator applied to positions passed to Set, SetCartographic, SetSubset, and SetSubsetCartographic methods. When this property is null, linear interpolation is used."""
        return self._intf.get_property(IPolylinePrimitive._metadata, IPolylinePrimitive._get_position_interpolator_metadata)

    _get_polyline_type_metadata = { "offset" : _get_polyline_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(POLYLINE_TYPE),) }
    @property
    def polyline_type(self) -> "POLYLINE_TYPE":
        """Get how the polyline interprets the positions passed to Set methods."""
        return self._intf.get_property(IPolylinePrimitive._metadata, IPolylinePrimitive._get_polyline_type_metadata)

    _get_set_hint_metadata = { "offset" : _get_set_hint_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(SET_HINT),) }
    @property
    def set_hint(self) -> "SET_HINT":
        """Get the primitive's set hint. See the Set Hint Performance Overview for selecting an appropriate value to construct the primitive with."""
        return self._intf.get_property(IPolylinePrimitive._metadata, IPolylinePrimitive._get_set_hint_metadata)

    _get_display_outline_metadata = { "offset" : _get_display_outline_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def display_outline(self) -> bool:
        """Get or set whether an outline is rendered around the polyline."""
        return self._intf.get_property(IPolylinePrimitive._metadata, IPolylinePrimitive._get_display_outline_metadata)

    _set_display_outline_metadata = { "offset" : _set_display_outline_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @display_outline.setter
    def display_outline(self, displayOutline:bool) -> None:
        return self._intf.set_property(IPolylinePrimitive._metadata, IPolylinePrimitive._set_display_outline_metadata, displayOutline)

    _get_outline_color_metadata = { "offset" : _get_outline_color_method_offset,
            "arg_types" : (POINTER(agcom.OLE_COLOR),),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @property
    def outline_color(self) -> agcolor.Color:
        """Get or set the outline's color."""
        return self._intf.get_property(IPolylinePrimitive._metadata, IPolylinePrimitive._get_outline_color_metadata)

    _set_outline_color_metadata = { "offset" : _set_outline_color_method_offset,
            "arg_types" : (agcom.OLE_COLOR,),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @outline_color.setter
    def outline_color(self, outlineColor:agcolor.Color) -> None:
        return self._intf.set_property(IPolylinePrimitive._metadata, IPolylinePrimitive._set_outline_color_metadata, outlineColor)

    _get_outline_translucency_metadata = { "offset" : _get_outline_translucency_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def outline_translucency(self) -> float:
        """Get or set the translucency of the outline. Translucency is between 0 and 1, where 0 is opaque and 1 is transparent."""
        return self._intf.get_property(IPolylinePrimitive._metadata, IPolylinePrimitive._get_outline_translucency_metadata)

    _set_outline_translucency_metadata = { "offset" : _set_outline_translucency_method_offset,
            "arg_types" : (agcom.FLOAT,),
            "marshallers" : (agmarshall.FloatArg,) }
    @outline_translucency.setter
    def outline_translucency(self, outlineTranslucency:float) -> None:
        return self._intf.set_property(IPolylinePrimitive._metadata, IPolylinePrimitive._set_outline_translucency_metadata, outlineTranslucency)

    _get_outline_width_metadata = { "offset" : _get_outline_width_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def outline_width(self) -> float:
        """Get or set the width, in pixels, of the outline around the polyline."""
        return self._intf.get_property(IPolylinePrimitive._metadata, IPolylinePrimitive._get_outline_width_metadata)

    _set_outline_width_metadata = { "offset" : _set_outline_width_method_offset,
            "arg_types" : (agcom.FLOAT,),
            "marshallers" : (agmarshall.FloatArg,) }
    @outline_width.setter
    def outline_width(self, outlineWidth:float) -> None:
        return self._intf.set_property(IPolylinePrimitive._metadata, IPolylinePrimitive._set_outline_width_metadata, outlineWidth)

    _get_per_item_picking_enabled_metadata = { "offset" : _get_per_item_picking_enabled_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def per_item_picking_enabled(self) -> bool:
        """Get or set whether individual line indices will be included in the pick results returned from the scene's Pick method. Each line index that is picked will be returned as a batch primitive index."""
        return self._intf.get_property(IPolylinePrimitive._metadata, IPolylinePrimitive._get_per_item_picking_enabled_metadata)

    _set_per_item_picking_enabled_metadata = { "offset" : _set_per_item_picking_enabled_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @per_item_picking_enabled.setter
    def per_item_picking_enabled(self, perItemPickingEnabled:bool) -> None:
        return self._intf.set_property(IPolylinePrimitive._metadata, IPolylinePrimitive._set_per_item_picking_enabled_metadata, perItemPickingEnabled)

    _set_metadata = { "offset" : _set_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    def set(self, positions:list) -> None:
        """Define the positions for a polyline primitive. The polyline is rendered in its reference frame."""
        return self._intf.invoke(IPolylinePrimitive._metadata, IPolylinePrimitive._set_metadata, positions)

    _set_with_colors_metadata = { "offset" : _set_with_colors_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg,) }
    def set_with_colors(self, positions:list, colors:list) -> None:
        """Define the positions and colors of a polyline. The polyline is rendered in its reference frame."""
        return self._intf.invoke(IPolylinePrimitive._metadata, IPolylinePrimitive._set_with_colors_metadata, positions, colors)

    _set_with_colors_and_hint_metadata = { "offset" : _set_with_colors_and_hint_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), agcom.LONG,),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.EnumArg(RENDER_PASS_HINT),) }
    def set_with_colors_and_hint(self, positions:list, colors:list, renderPassHint:"RENDER_PASS_HINT") -> None:
        """Define the positions and colors of a polyline. The polyline is rendered in its reference frame. renderPassHint is provided for efficiency."""
        return self._intf.invoke(IPolylinePrimitive._metadata, IPolylinePrimitive._set_with_colors_and_hint_metadata, positions, colors, renderPassHint)

    _set_with_surface_shapes_result_metadata = { "offset" : _set_with_surface_shapes_result_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ISurfaceShapesResult"),) }
    def set_with_surface_shapes_result(self, surfaceShapesResult:"ISurfaceShapesResult") -> None:
        """Define the positions of a polyline using the positions of the specified surfaceShapesResult."""
        return self._intf.invoke(IPolylinePrimitive._metadata, IPolylinePrimitive._set_with_surface_shapes_result_metadata, surfaceShapesResult)

    _set_with_surface_triangulator_result_metadata = { "offset" : _set_with_surface_triangulator_result_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ISurfaceTriangulatorResult"),) }
    def set_with_surface_triangulator_result(self, surfaceTriangulatorResult:"ISurfaceTriangulatorResult") -> None:
        """Define the positions of a polyline using the boundary positions of the specified surfaceTriangulatorResult."""
        return self._intf.invoke(IPolylinePrimitive._metadata, IPolylinePrimitive._set_with_surface_triangulator_result_metadata, surfaceTriangulatorResult)

    _set_with_solid_triangulator_result_metadata = { "offset" : _set_with_solid_triangulator_result_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ISolidTriangulatorResult"),) }
    def set_with_solid_triangulator_result(self, solidTriangulatorResult:"ISolidTriangulatorResult") -> None:
        """Define the positions of a polyline using the outline positions of the specified solidTriangulatorResult."""
        return self._intf.invoke(IPolylinePrimitive._metadata, IPolylinePrimitive._set_with_solid_triangulator_result_metadata, solidTriangulatorResult)

    _set_cartographic_metadata = { "offset" : _set_cartographic_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg,) }
    def set_cartographic(self, centralBody:str, positions:list) -> None:
        """For convenience. Defines the positions of a polyline using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling Set."""
        return self._intf.invoke(IPolylinePrimitive._metadata, IPolylinePrimitive._set_cartographic_metadata, centralBody, positions)

    _set_cartographic_with_colors_metadata = { "offset" : _set_cartographic_with_colors_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg,) }
    def set_cartographic_with_colors(self, centralBody:str, positions:list, colors:list) -> None:
        """For convenience. Defines the positions and colors of a polyline using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling Set."""
        return self._intf.invoke(IPolylinePrimitive._metadata, IPolylinePrimitive._set_cartographic_with_colors_metadata, centralBody, positions, colors)

    _set_cartographic_with_colors_and_hint_metadata = { "offset" : _set_cartographic_with_colors_and_hint_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), agcom.LONG,),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.EnumArg(RENDER_PASS_HINT),) }
    def set_cartographic_with_colors_and_hint(self, centralBody:str, positions:list, colors:list, renderPassHint:"RENDER_PASS_HINT") -> None:
        """For convenience. Defines the positions and colors of a polyline using cartographic positions. renderPassHint is provided for efficiency. This is equivalent to converting each position in positions to cartesian and calling Set."""
        return self._intf.invoke(IPolylinePrimitive._metadata, IPolylinePrimitive._set_cartographic_with_colors_and_hint_metadata, centralBody, positions, colors, renderPassHint)

    _set_subset_metadata = { "offset" : _set_subset_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), agcom.INT, agcom.INT,),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.IntArg, agmarshall.IntArg,) }
    def set_subset(self, positions:list, index:int, count:int) -> None:
        """Define the positions of a polyline using a subset of input positions."""
        return self._intf.invoke(IPolylinePrimitive._metadata, IPolylinePrimitive._set_subset_metadata, positions, index, count)

    _set_subset_cartographic_metadata = { "offset" : _set_subset_cartographic_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), agcom.INT, agcom.INT,),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.IntArg, agmarshall.IntArg,) }
    def set_subset_cartographic(self, centralBody:str, positions:list, index:int, count:int) -> None:
        """For convenience. Defines the positions of a polyline using a subset of input cartographic positions. This is equivalent to converting the subset of positions to cartesian and calling SetSubset."""
        return self._intf.invoke(IPolylinePrimitive._metadata, IPolylinePrimitive._set_subset_cartographic_metadata, centralBody, positions, index, count)

    _set_partial_metadata = { "offset" : _set_partial_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg,) }
    def set_partial(self, positions:list, indices:list) -> None:
        """Update a subset of positions in a polyline."""
        return self._intf.invoke(IPolylinePrimitive._metadata, IPolylinePrimitive._set_partial_metadata, positions, indices)

    _set_partial_with_indices_order_metadata = { "offset" : _set_partial_with_indices_order_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), agcom.LONG,),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.EnumArg(INDICES_ORDER_HINT),) }
    def set_partial_with_indices_order(self, positions:list, indices:list, indicesOrderHint:"INDICES_ORDER_HINT") -> None:
        """Update a subset of positions in a polyline."""
        return self._intf.invoke(IPolylinePrimitive._metadata, IPolylinePrimitive._set_partial_with_indices_order_metadata, positions, indices, indicesOrderHint)

    _set_partial_with_colors_metadata = { "offset" : _set_partial_with_colors_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg,) }
    def set_partial_with_colors(self, positions:list, colors:list, indices:list) -> None:
        """Update a subset of positions and/or colors in a polyline."""
        return self._intf.invoke(IPolylinePrimitive._metadata, IPolylinePrimitive._set_partial_with_colors_metadata, positions, colors, indices)

    _set_partial_with_colors_indices_order_and_render_pass_hint_metadata = { "offset" : _set_partial_with_colors_indices_order_and_render_pass_hint_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), agcom.LONG, agcom.LONG,),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.EnumArg(INDICES_ORDER_HINT), agmarshall.EnumArg(RENDER_PASS_HINT),) }
    def set_partial_with_colors_indices_order_and_render_pass_hint(self, positions:list, colors:list, indices:list, indicesOrderHint:"INDICES_ORDER_HINT", renderPassHint:"RENDER_PASS_HINT") -> None:
        """Update a subset of positions and/or colors in a polyline."""
        return self._intf.invoke(IPolylinePrimitive._metadata, IPolylinePrimitive._set_partial_with_colors_indices_order_and_render_pass_hint_metadata, positions, colors, indices, indicesOrderHint, renderPassHint)

    _set_partial_cartographic_metadata = { "offset" : _set_partial_cartographic_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg,) }
    def set_partial_cartographic(self, centralBody:str, positions:list, indices:list) -> None:
        """For convenience. Updates a subset of positions in a polyline using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling SetPartial."""
        return self._intf.invoke(IPolylinePrimitive._metadata, IPolylinePrimitive._set_partial_cartographic_metadata, centralBody, positions, indices)

    _set_partial_cartographic_with_indices_order_metadata = { "offset" : _set_partial_cartographic_with_indices_order_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), agcom.LONG,),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.EnumArg(INDICES_ORDER_HINT),) }
    def set_partial_cartographic_with_indices_order(self, centralBody:str, positions:list, indices:list, indicesOrderHint:"INDICES_ORDER_HINT") -> None:
        """For convenience. Updates a subset of positions in a polyline using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling SetPartial."""
        return self._intf.invoke(IPolylinePrimitive._metadata, IPolylinePrimitive._set_partial_cartographic_with_indices_order_metadata, centralBody, positions, indices, indicesOrderHint)

    _set_partial_cartographic_with_colors_metadata = { "offset" : _set_partial_cartographic_with_colors_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg,) }
    def set_partial_cartographic_with_colors(self, centralBody:str, positions:list, colors:list, indices:list) -> None:
        """For convenience. Updates a subset of positions and/or colors in a polyline using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling SetPartial."""
        return self._intf.invoke(IPolylinePrimitive._metadata, IPolylinePrimitive._set_partial_cartographic_with_colors_metadata, centralBody, positions, colors, indices)

    _set_partial_cartographic_with_colors_indices_order_and_render_pass_metadata = { "offset" : _set_partial_cartographic_with_colors_indices_order_and_render_pass_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), agcom.LONG, agcom.LONG,),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.EnumArg(INDICES_ORDER_HINT), agmarshall.EnumArg(RENDER_PASS_HINT),) }
    def set_partial_cartographic_with_colors_indices_order_and_render_pass(self, centralBody:str, positions:list, colors:list, indices:list, indicesOrderHint:"INDICES_ORDER_HINT", renderPassHint:"RENDER_PASS_HINT") -> None:
        """For convenience. Updates a subset of positions and/or colors in a polyline using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling SetPartial."""
        return self._intf.invoke(IPolylinePrimitive._metadata, IPolylinePrimitive._set_partial_cartographic_with_colors_indices_order_and_render_pass_metadata, centralBody, positions, colors, indices, indicesOrderHint, renderPassHint)

    _get_central_body_clipped_metadata = { "offset" : _get_central_body_clipped_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def central_body_clipped(self) -> bool:
        """Get or set whether the polyline will be clipped by the central body."""
        return self._intf.get_property(IPolylinePrimitive._metadata, IPolylinePrimitive._get_central_body_clipped_metadata)

    _set_central_body_clipped_metadata = { "offset" : _set_central_body_clipped_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @central_body_clipped.setter
    def central_body_clipped(self, centralBodyClipped:bool) -> None:
        return self._intf.set_property(IPolylinePrimitive._metadata, IPolylinePrimitive._set_central_body_clipped_metadata, centralBodyClipped)

    _set_with_colors_and_optional_parameters_metadata = { "offset" : _set_with_colors_and_optional_parameters_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), agcom.PVOID,),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.InterfaceInArg("IPolylinePrimitiveOptionalParameters"),) }
    def set_with_colors_and_optional_parameters(self, positions:list, colors:list, optionalParameters:"IPolylinePrimitiveOptionalParameters") -> None:
        """Define the positions, colors, and/or optional point properties of a polyline. The polyline is rendered in its reference frame."""
        return self._intf.invoke(IPolylinePrimitive._metadata, IPolylinePrimitive._set_with_colors_and_optional_parameters_metadata, positions, colors, optionalParameters)

    _set_cartographic_with_colors_and_optional_parameters_metadata = { "offset" : _set_cartographic_with_colors_and_optional_parameters_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), agcom.PVOID,),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.InterfaceInArg("IPolylinePrimitiveOptionalParameters"),) }
    def set_cartographic_with_colors_and_optional_parameters(self, centralBody:str, positions:list, colors:list, optionalParameters:"IPolylinePrimitiveOptionalParameters") -> None:
        """For convenience. Defines the positions, colors, and/or optional point properties of a polyline using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling Set."""
        return self._intf.invoke(IPolylinePrimitive._metadata, IPolylinePrimitive._set_cartographic_with_colors_and_optional_parameters_metadata, centralBody, positions, colors, optionalParameters)

    _set_partial_with_colors_and_optional_parameters_metadata = { "offset" : _set_partial_with_colors_and_optional_parameters_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), agcom.PVOID, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.InterfaceInArg("IPolylinePrimitiveOptionalParameters"), agmarshall.LPSafearrayArg,) }
    def set_partial_with_colors_and_optional_parameters(self, positions:list, colors:list, optionalParameters:"IPolylinePrimitiveOptionalParameters", indices:list) -> None:
        """Update a subset of positions, colors, and/or optional point properties in a polyline."""
        return self._intf.invoke(IPolylinePrimitive._metadata, IPolylinePrimitive._set_partial_with_colors_and_optional_parameters_metadata, positions, colors, optionalParameters, indices)

    _set_partial_cartographic_with_optional_parameters_metadata = { "offset" : _set_partial_cartographic_with_optional_parameters_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), agcom.PVOID, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.InterfaceInArg("IPolylinePrimitiveOptionalParameters"), agmarshall.LPSafearrayArg,) }
    def set_partial_cartographic_with_optional_parameters(self, centralBody:str, positions:list, colors:list, optionalParameters:"IPolylinePrimitiveOptionalParameters", indices:list) -> None:
        """For convenience. Updates a subset of positions, colors, and/or optional point properties in a polyline using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling SetPartial."""
        return self._intf.invoke(IPolylinePrimitive._metadata, IPolylinePrimitive._set_partial_cartographic_with_optional_parameters_metadata, centralBody, positions, colors, optionalParameters, indices)

    _property_names[width] = "width"
    _property_names[minimum_width_supported] = "minimum_width_supported"
    _property_names[maximum_width_supported] = "maximum_width_supported"
    _property_names[position_interpolator] = "position_interpolator"
    _property_names[polyline_type] = "polyline_type"
    _property_names[set_hint] = "set_hint"
    _property_names[display_outline] = "display_outline"
    _property_names[outline_color] = "outline_color"
    _property_names[outline_translucency] = "outline_translucency"
    _property_names[outline_width] = "outline_width"
    _property_names[per_item_picking_enabled] = "per_item_picking_enabled"
    _property_names[central_body_clipped] = "central_body_clipped"


agcls.AgClassCatalog.add_catalog_entry((4917159150693309483, 4735648436991941304), IPolylinePrimitive)
agcls.AgTypeNameMap["IPolylinePrimitive"] = IPolylinePrimitive

class IPolylinePrimitiveOptionalParameters(object):
    """Optional per-point or per-segment parameters for polyline primitive that overrides the polyline primitive's global parameters..."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _set_time_intervals_method_offset = 1
    _metadata = {
        "iid_data" : (4899695596699319324, 7572311148448238225),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IPolylinePrimitiveOptionalParameters."""
        initialize_from_source_object(self, sourceObject, IPolylinePrimitiveOptionalParameters)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IPolylinePrimitiveOptionalParameters)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IPolylinePrimitiveOptionalParameters, None)
    
    _set_time_intervals_metadata = { "offset" : _set_time_intervals_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    def set_time_intervals(self, timeIntervals:list) -> None:
        """Define a collection of TimeIntervals defined by MinimumTime and MaximumTime in Epoch Seconds, one for each point in the Polyline."""
        return self._intf.invoke(IPolylinePrimitiveOptionalParameters._metadata, IPolylinePrimitiveOptionalParameters._set_time_intervals_metadata, timeIntervals)


agcls.AgClassCatalog.add_catalog_entry((4899695596699319324, 7572311148448238225), IPolylinePrimitiveOptionalParameters)
agcls.AgTypeNameMap["IPolylinePrimitiveOptionalParameters"] = IPolylinePrimitiveOptionalParameters

class IPositionInterpolator(object):
    """Position interpolators compute positions based on a collection of input positions. Position interpolators are used in conjunction with the polyline primitive to render things such as great arcs and rhumb lines."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_polyline_type_method_offset = 1
    _interpolate_method_offset = 2
    _metadata = {
        "iid_data" : (4813879190160674146, 10385975851796783768),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IPositionInterpolator."""
        initialize_from_source_object(self, sourceObject, IPositionInterpolator)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IPositionInterpolator)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IPositionInterpolator, None)
    
    _get_polyline_type_metadata = { "offset" : _get_polyline_type_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(POLYLINE_TYPE),) }
    @property
    def polyline_type(self) -> "POLYLINE_TYPE":
        """Get the polyline type of positions returned from interpolate."""
        return self._intf.get_property(IPositionInterpolator._metadata, IPositionInterpolator._get_polyline_type_metadata)

    _interpolate_metadata = { "offset" : _interpolate_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg,) }
    def interpolate(self, positions:list) -> list:
        """Compute interpolated positions based on the input positions. Returns an array of positions in the order x, y, z."""
        return self._intf.invoke(IPositionInterpolator._metadata, IPositionInterpolator._interpolate_metadata, positions, OutArg())

    _property_names[polyline_type] = "polyline_type"


agcls.AgClassCatalog.add_catalog_entry((4813879190160674146, 10385975851796783768), IPositionInterpolator)
agcls.AgTypeNameMap["IPositionInterpolator"] = IPositionInterpolator

class IPrimitive(object):
    """Primitives represent objects rendered in the 3D scene."""

    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_reference_frame_method_offset = 1
    _set_reference_frame_method_offset = 2
    _get_bounding_sphere_method_offset = 3
    _set_bounding_sphere_method_offset = 4
    _get_automatically_compute_bounding_sphere_method_offset = 5
    _set_automatically_compute_bounding_sphere_method_offset = 6
    _get_display_condition_method_offset = 7
    _set_display_condition_method_offset = 8
    _get_display_method_offset = 9
    _set_display_method_offset = 10
    _get_color_method_offset = 11
    _set_color_method_offset = 12
    _get_translucency_method_offset = 13
    _set_translucency_method_offset = 14
    _get_tag_method_offset = 15
    _set_tag_method_offset = 16
    _metadata = {
        "iid_data" : (5491912536264793211, 14009178631662877855),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IPrimitive."""
        initialize_from_source_object(self, sourceObject, IPrimitive)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IPrimitive)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IPrimitive, None)
    
    _get_reference_frame_metadata = { "offset" : _get_reference_frame_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def reference_frame(self) -> "IVectorGeometryToolSystem":
        """Get or set the reference frame this primitive is defined and rendered in."""
        return self._intf.get_property(IPrimitive._metadata, IPrimitive._get_reference_frame_metadata)

    _set_reference_frame_metadata = { "offset" : _set_reference_frame_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolSystem"),) }
    @reference_frame.setter
    def reference_frame(self, referenceFrame:"IVectorGeometryToolSystem") -> None:
        return self._intf.set_property(IPrimitive._metadata, IPrimitive._set_reference_frame_metadata, referenceFrame)

    _get_bounding_sphere_metadata = { "offset" : _get_bounding_sphere_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def bounding_sphere(self) -> "BoundingSphere":
        """Get or set the bounding sphere that encompasses the primitive. The center is defined in the primitive's reference frame."""
        return self._intf.get_property(IPrimitive._metadata, IPrimitive._get_bounding_sphere_metadata)

    _set_bounding_sphere_metadata = { "offset" : _set_bounding_sphere_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IBoundingSphere"),) }
    @bounding_sphere.setter
    def bounding_sphere(self, boundingSphere:"IBoundingSphere") -> None:
        return self._intf.set_property(IPrimitive._metadata, IPrimitive._set_bounding_sphere_metadata, boundingSphere)

    _get_automatically_compute_bounding_sphere_metadata = { "offset" : _get_automatically_compute_bounding_sphere_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def automatically_compute_bounding_sphere(self) -> bool:
        """Get or set if the primitive's bounding sphere is automatically computed."""
        return self._intf.get_property(IPrimitive._metadata, IPrimitive._get_automatically_compute_bounding_sphere_metadata)

    _set_automatically_compute_bounding_sphere_metadata = { "offset" : _set_automatically_compute_bounding_sphere_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @automatically_compute_bounding_sphere.setter
    def automatically_compute_bounding_sphere(self, automaticallyComputeBoundingSphere:bool) -> None:
        return self._intf.set_property(IPrimitive._metadata, IPrimitive._set_automatically_compute_bounding_sphere_metadata, automaticallyComputeBoundingSphere)

    _get_display_condition_metadata = { "offset" : _get_display_condition_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def display_condition(self) -> "IDisplayCondition":
        """Get or set the display condition that determines if the primitive should be rendered. Both this and display must evaluate to true for the primitive to be rendered."""
        return self._intf.get_property(IPrimitive._metadata, IPrimitive._get_display_condition_metadata)

    _set_display_condition_metadata = { "offset" : _set_display_condition_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IDisplayCondition"),) }
    @display_condition.setter
    def display_condition(self, displayCondition:"IDisplayCondition") -> None:
        return self._intf.set_property(IPrimitive._metadata, IPrimitive._set_display_condition_metadata, displayCondition)

    _get_display_metadata = { "offset" : _get_display_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def display(self) -> bool:
        """Get or set if the primitive should be rendered. Both this and display condition must evaluate to true for the primitive to be rendered."""
        return self._intf.get_property(IPrimitive._metadata, IPrimitive._get_display_metadata)

    _set_display_metadata = { "offset" : _set_display_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @display.setter
    def display(self, display:bool) -> None:
        return self._intf.set_property(IPrimitive._metadata, IPrimitive._set_display_metadata, display)

    _get_color_metadata = { "offset" : _get_color_method_offset,
            "arg_types" : (POINTER(agcom.OLE_COLOR),),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @property
    def color(self) -> agcolor.Color:
        """Get or set the primitive's color."""
        return self._intf.get_property(IPrimitive._metadata, IPrimitive._get_color_metadata)

    _set_color_metadata = { "offset" : _set_color_method_offset,
            "arg_types" : (agcom.OLE_COLOR,),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @color.setter
    def color(self, color:agcolor.Color) -> None:
        return self._intf.set_property(IPrimitive._metadata, IPrimitive._set_color_metadata, color)

    _get_translucency_metadata = { "offset" : _get_translucency_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def translucency(self) -> float:
        """Get or set the primitive's translucency. Translucency is between 0 and 1, where 0 is opaque and 1 is transparent."""
        return self._intf.get_property(IPrimitive._metadata, IPrimitive._get_translucency_metadata)

    _set_translucency_metadata = { "offset" : _set_translucency_method_offset,
            "arg_types" : (agcom.FLOAT,),
            "marshallers" : (agmarshall.FloatArg,) }
    @translucency.setter
    def translucency(self, translucency:float) -> None:
        return self._intf.set_property(IPrimitive._metadata, IPrimitive._set_translucency_metadata, translucency)

    _get_tag_metadata = { "offset" : _get_tag_method_offset,
            "arg_types" : (POINTER(agcom.Variant),),
            "marshallers" : (agmarshall.VariantArg,) }
    @property
    def tag(self) -> typing.Any:
        """Get or set custom value associated with this primitive."""
        return self._intf.get_property(IPrimitive._metadata, IPrimitive._get_tag_metadata)

    _set_tag_metadata = { "offset" : _set_tag_method_offset,
            "arg_types" : (agcom.Variant,),
            "marshallers" : (agmarshall.VariantArg,) }
    @tag.setter
    def tag(self, tag:typing.Any) -> None:
        return self._intf.set_property(IPrimitive._metadata, IPrimitive._set_tag_metadata, tag)

    _property_names[reference_frame] = "reference_frame"
    _property_names[bounding_sphere] = "bounding_sphere"
    _property_names[automatically_compute_bounding_sphere] = "automatically_compute_bounding_sphere"
    _property_names[display_condition] = "display_condition"
    _property_names[display] = "display"
    _property_names[color] = "color"
    _property_names[translucency] = "translucency"
    _property_names[tag] = "tag"


agcls.AgClassCatalog.add_catalog_entry((5491912536264793211, 14009178631662877855), IPrimitive)
agcls.AgTypeNameMap["IPrimitive"] = IPrimitive

class IPrimitiveManager(object):
    """The primitive manager contains spatial data structures used to efficiently render primitives. Once a primitive is constructed, it must be added to the primitive manager before it will be rendered."""

    _num_methods = 10
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_count_method_offset = 1
    _get_precision_exponent_method_offset = 2
    _set_precision_exponent_method_offset = 3
    _get_translucent_primitives_sort_order_method_offset = 4
    _set_translucent_primitives_sort_order_method_offset = 5
    _add_method_offset = 6
    _remove_method_offset = 7
    _contains_method_offset = 8
    _clear_method_offset = 9
    _get__NewEnum_method_offset = 10
    _metadata = {
        "iid_data" : (5712467222312543641, 18164203771391217825),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IPrimitiveManager."""
        initialize_from_source_object(self, sourceObject, IPrimitiveManager)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IPrimitiveManager)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IPrimitiveManager, None)
    def __iter__(self):
        """Create an iterator for the IPrimitiveManager object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> typing.Any:
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    
    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def count(self) -> int:
        """Get the number of primitives in the manager."""
        return self._intf.get_property(IPrimitiveManager._metadata, IPrimitiveManager._get_count_metadata)

    _get_precision_exponent_metadata = { "offset" : _get_precision_exponent_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def precision_exponent(self) -> int:
        """Do not use this property, as it is deprecated. This property is no longer in use Gets or sets the exponent used to compute the maximum precision for primitive rendering. For example, a value of -3 indicates the maximum precision of 2^-3, 0.125 m along the x, y, or z axis..."""
        return self._intf.get_property(IPrimitiveManager._metadata, IPrimitiveManager._get_precision_exponent_metadata)

    _set_precision_exponent_metadata = { "offset" : _set_precision_exponent_method_offset,
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.IntArg,) }
    @precision_exponent.setter
    def precision_exponent(self, precisionExponent:int) -> None:
        return self._intf.set_property(IPrimitiveManager._metadata, IPrimitiveManager._set_precision_exponent_metadata, precisionExponent)

    _get_translucent_primitives_sort_order_metadata = { "offset" : _get_translucent_primitives_sort_order_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(PRIMITIVES_SORT_ORDER),) }
    @property
    def translucent_primitives_sort_order(self) -> "PRIMITIVES_SORT_ORDER":
        """Get or set the sort order for translucent primitives in the primitive manager. This determines a trade-off between rendering speed and quality..."""
        return self._intf.get_property(IPrimitiveManager._metadata, IPrimitiveManager._get_translucent_primitives_sort_order_metadata)

    _set_translucent_primitives_sort_order_metadata = { "offset" : _set_translucent_primitives_sort_order_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(PRIMITIVES_SORT_ORDER),) }
    @translucent_primitives_sort_order.setter
    def translucent_primitives_sort_order(self, translucentPrimitivesSortOrder:"PRIMITIVES_SORT_ORDER") -> None:
        return self._intf.set_property(IPrimitiveManager._metadata, IPrimitiveManager._set_translucent_primitives_sort_order_metadata, translucentPrimitivesSortOrder)

    _add_metadata = { "offset" : _add_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IPrimitive"),) }
    def add(self, primitive:"IPrimitive") -> None:
        """Add a primitive to the manager. Primitives must be added to the manager to be rendered."""
        return self._intf.invoke(IPrimitiveManager._metadata, IPrimitiveManager._add_metadata, primitive)

    _remove_metadata = { "offset" : _remove_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IPrimitive"),) }
    def remove(self, primitive:"IPrimitive") -> None:
        """Remove a primitive from the manager. The primitive is no longer rendered unless it is added back into the manager."""
        return self._intf.invoke(IPrimitiveManager._metadata, IPrimitiveManager._remove_metadata, primitive)

    _contains_metadata = { "offset" : _contains_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.InterfaceInArg("IPrimitive"), agmarshall.VariantBoolArg,) }
    def contains(self, primitive:"IPrimitive") -> bool:
        """Determine whether the manager contains a primitive."""
        return self._intf.invoke(IPrimitiveManager._metadata, IPrimitiveManager._contains_metadata, primitive, OutArg())

    _clear_metadata = { "offset" : _clear_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def clear(self) -> None:
        """Remove all primitives from the manager."""
        return self._intf.invoke(IPrimitiveManager._metadata, IPrimitiveManager._clear_metadata, )

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        """Return an enumerator that iterates through the collection. The order of the primitives is not guaranteed to be the order that the primitives were added."""
        return self._intf.get_property(IPrimitiveManager._metadata, IPrimitiveManager._get__NewEnum_metadata)

    _property_names[count] = "count"
    _property_names[precision_exponent] = "precision_exponent"
    _property_names[translucent_primitives_sort_order] = "translucent_primitives_sort_order"
    _property_names[_NewEnum] = "_NewEnum"


agcls.AgClassCatalog.add_catalog_entry((5712467222312543641, 18164203771391217825), IPrimitiveManager)
agcls.AgTypeNameMap["IPrimitiveManager"] = IPrimitiveManager

class IRasterImageGlobeOverlay(object):
    """A globe image overlay for handling rasters."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_use_transparent_color_method_offset = 1
    _set_use_transparent_color_method_offset = 2
    _get_transparent_color_method_offset = 3
    _set_transparent_color_method_offset = 4
    _metadata = {
        "iid_data" : (4649284088551794065, 16792077003963540662),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IRasterImageGlobeOverlay."""
        initialize_from_source_object(self, sourceObject, IRasterImageGlobeOverlay)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IRasterImageGlobeOverlay)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IRasterImageGlobeOverlay, None)
    
    _get_use_transparent_color_metadata = { "offset" : _get_use_transparent_color_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def use_transparent_color(self) -> bool:
        """Get or set whether transparent color should be used."""
        return self._intf.get_property(IRasterImageGlobeOverlay._metadata, IRasterImageGlobeOverlay._get_use_transparent_color_metadata)

    _set_use_transparent_color_metadata = { "offset" : _set_use_transparent_color_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @use_transparent_color.setter
    def use_transparent_color(self, useTransparentColor:bool) -> None:
        return self._intf.set_property(IRasterImageGlobeOverlay._metadata, IRasterImageGlobeOverlay._set_use_transparent_color_metadata, useTransparentColor)

    _get_transparent_color_metadata = { "offset" : _get_transparent_color_method_offset,
            "arg_types" : (POINTER(agcom.OLE_COLOR),),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @property
    def transparent_color(self) -> agcolor.Color:
        """Get or set the color that will become transparent."""
        return self._intf.get_property(IRasterImageGlobeOverlay._metadata, IRasterImageGlobeOverlay._get_transparent_color_metadata)

    _set_transparent_color_metadata = { "offset" : _set_transparent_color_method_offset,
            "arg_types" : (agcom.OLE_COLOR,),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @transparent_color.setter
    def transparent_color(self, transparentColor:agcolor.Color) -> None:
        return self._intf.set_property(IRasterImageGlobeOverlay._metadata, IRasterImageGlobeOverlay._set_transparent_color_metadata, transparentColor)

    _property_names[use_transparent_color] = "use_transparent_color"
    _property_names[transparent_color] = "transparent_color"


agcls.AgClassCatalog.add_catalog_entry((4649284088551794065, 16792077003963540662), IRasterImageGlobeOverlay)
agcls.AgTypeNameMap["IRasterImageGlobeOverlay"] = IRasterImageGlobeOverlay

class IRhumbLineInterpolator(object):
    """The rhumb line interpolator computes interpolated positions along a rhumb line. Rhumb lines are lines of constant bearing. They appear as straight lines on a Mercator 2D map projection and are well suited to navigation."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_central_body_method_offset = 1
    _set_central_body_method_offset = 2
    _get_granularity_method_offset = 3
    _set_granularity_method_offset = 4
    _metadata = {
        "iid_data" : (5614337469871736325, 9221184782651004840),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IRhumbLineInterpolator."""
        initialize_from_source_object(self, sourceObject, IRhumbLineInterpolator)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IRhumbLineInterpolator)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IRhumbLineInterpolator, None)
    
    _get_central_body_metadata = { "offset" : _get_central_body_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def central_body(self) -> str:
        """Get or set the central body used when interpolating with interpolate."""
        return self._intf.get_property(IRhumbLineInterpolator._metadata, IRhumbLineInterpolator._get_central_body_metadata)

    _set_central_body_metadata = { "offset" : _set_central_body_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @central_body.setter
    def central_body(self, centralBody:str) -> None:
        return self._intf.set_property(IRhumbLineInterpolator._metadata, IRhumbLineInterpolator._set_central_body_metadata, centralBody)

    _get_granularity_metadata = { "offset" : _get_granularity_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def granularity(self) -> float:
        """Get or set the granularity used when interpolating with interpolate. Lower granularities are more precise but create more positions."""
        return self._intf.get_property(IRhumbLineInterpolator._metadata, IRhumbLineInterpolator._get_granularity_metadata)

    _set_granularity_metadata = { "offset" : _set_granularity_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @granularity.setter
    def granularity(self, granularity:float) -> None:
        return self._intf.set_property(IRhumbLineInterpolator._metadata, IRhumbLineInterpolator._set_granularity_metadata, granularity)

    _property_names[central_body] = "central_body"
    _property_names[granularity] = "granularity"


agcls.AgClassCatalog.add_catalog_entry((5614337469871736325, 9221184782651004840), IRhumbLineInterpolator)
agcls.AgTypeNameMap["IRhumbLineInterpolator"] = IRhumbLineInterpolator

class IScene(object):
    """A scene provides properties and functionality that are reflected in the rendering of the globe control that it is associated with. An globe control's scene is available from the scene property..."""

    _num_methods = 25
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_camera_method_offset = 1
    _get_lighting_method_offset = 2
    _get_show_sunshine_method_offset = 3
    _set_show_sunshine_method_offset = 4
    _get_central_bodies_method_offset = 5
    _get_background_color_method_offset = 6
    _set_background_color_method_offset = 7
    _get_shade_sky_based_on_altitude_method_offset = 8
    _set_shade_sky_based_on_altitude_method_offset = 9
    _get_show_stars_method_offset = 10
    _set_show_stars_method_offset = 11
    _get_globe_overlay_settings_method_offset = 12
    _render_method_offset = 13
    _pick_method_offset = 14
    _pick_rectangular_method_offset = 15
    _pick_screen_overlays_method_offset = 16
    _get_scene_id_method_offset = 17
    _get_show_water_surface_method_offset = 18
    _set_show_water_surface_method_offset = 19
    _get_anti_aliasing_method_offset = 20
    _set_anti_aliasing_method_offset = 21
    _get_visual_effects_method_offset = 22
    _get_clouds_method_offset = 23
    _get_show_star_labels_method_offset = 24
    _set_show_star_labels_method_offset = 25
    _metadata = {
        "iid_data" : (5305222447490254466, 9009928902241702280),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IScene."""
        initialize_from_source_object(self, sourceObject, IScene)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IScene)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IScene, None)
    def Subscribe(self) -> ISceneEventHandler:
        """Return an ISceneEventHandler that is subscribed to handle events associated with this instance of IScene."""
        return ISceneEventHandler(self._intf)
    
    _get_camera_metadata = { "offset" : _get_camera_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def camera(self) -> "Camera":
        """Get the camera associated with the scene, which affects the view that is rendered by the scene."""
        return self._intf.get_property(IScene._metadata, IScene._get_camera_metadata)

    _get_lighting_metadata = { "offset" : _get_lighting_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def lighting(self) -> "Lighting":
        """Get the lighting associated with the scene."""
        return self._intf.get_property(IScene._metadata, IScene._get_lighting_metadata)

    _get_show_sunshine_metadata = { "offset" : _get_show_sunshine_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def show_sunshine(self) -> bool:
        """Get or set whether sunshine is rendered by the Sun central body. Sunshine renders a halo effect around the sun when it is viewed in the scene."""
        return self._intf.get_property(IScene._metadata, IScene._get_show_sunshine_metadata)

    _set_show_sunshine_metadata = { "offset" : _set_show_sunshine_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @show_sunshine.setter
    def show_sunshine(self, showSunshine:bool) -> None:
        return self._intf.set_property(IScene._metadata, IScene._set_show_sunshine_metadata, showSunshine)

    _get_central_bodies_metadata = { "offset" : _get_central_bodies_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def central_bodies(self) -> "CentralBodyGraphicsIndexer":
        """Get the central body graphics for a specified central body."""
        return self._intf.get_property(IScene._metadata, IScene._get_central_bodies_metadata)

    _get_background_color_metadata = { "offset" : _get_background_color_method_offset,
            "arg_types" : (POINTER(agcom.OLE_COLOR),),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @property
    def background_color(self) -> agcolor.Color:
        """Get or set the background color of the scene."""
        return self._intf.get_property(IScene._metadata, IScene._get_background_color_metadata)

    _set_background_color_metadata = { "offset" : _set_background_color_method_offset,
            "arg_types" : (agcom.OLE_COLOR,),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @background_color.setter
    def background_color(self, backgroundColor:agcolor.Color) -> None:
        return self._intf.set_property(IScene._metadata, IScene._set_background_color_metadata, backgroundColor)

    _get_shade_sky_based_on_altitude_metadata = { "offset" : _get_shade_sky_based_on_altitude_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def shade_sky_based_on_altitude(self) -> bool:
        """Get or set whether the sky will be shaded based on camera altitude. When shade sky based on altitude is set to true, the sky will become more blue as the Camera gets closer to the surface of the central body."""
        return self._intf.get_property(IScene._metadata, IScene._get_shade_sky_based_on_altitude_metadata)

    _set_shade_sky_based_on_altitude_metadata = { "offset" : _set_shade_sky_based_on_altitude_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @shade_sky_based_on_altitude.setter
    def shade_sky_based_on_altitude(self, shadeSkyBasedOnAltitude:bool) -> None:
        return self._intf.set_property(IScene._metadata, IScene._set_shade_sky_based_on_altitude_metadata, shadeSkyBasedOnAltitude)

    _get_show_stars_metadata = { "offset" : _get_show_stars_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def show_stars(self) -> bool:
        """Get or set whether stars are shown or hidden in the scene."""
        return self._intf.get_property(IScene._metadata, IScene._get_show_stars_metadata)

    _set_show_stars_metadata = { "offset" : _set_show_stars_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @show_stars.setter
    def show_stars(self, showStars:bool) -> None:
        return self._intf.set_property(IScene._metadata, IScene._set_show_stars_metadata, showStars)

    _get_globe_overlay_settings_metadata = { "offset" : _get_globe_overlay_settings_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def globe_overlay_settings(self) -> "SceneGlobeOverlaySettings":
        """Get the scene globe overlay settings for the scene."""
        return self._intf.get_property(IScene._metadata, IScene._get_globe_overlay_settings_metadata)

    _render_metadata = { "offset" : _render_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def render(self) -> None:
        """Render the scene. To render all the scenes within an application, use the Render method."""
        return self._intf.invoke(IScene._metadata, IScene._render_metadata, )

    _pick_metadata = { "offset" : _pick_method_offset,
            "arg_types" : (agcom.INT, agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def pick(self, x:int, y:int) -> "PickResultCollection":
        """Execute a pick at the given x, y and returns a depth sorted collection of picked objects. The coordinate origin is top, left. To pick screen overlays, use the PickScreenOverlays method."""
        return self._intf.invoke(IScene._metadata, IScene._pick_metadata, x, y, OutArg())

    _pick_rectangular_metadata = { "offset" : _pick_rectangular_method_offset,
            "arg_types" : (agcom.INT, agcom.INT, agcom.INT, agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.IntArg, agmarshall.IntArg, agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def pick_rectangular(self, left:int, bottom:int, right:int, top:int) -> "PickResultCollection":
        """Execute a pick in the given rectangular region and returns a depth sorted collection of picked objects. The coordinate origin is top, left. To pick screen overlays, use the PickScreenOverlays method."""
        return self._intf.invoke(IScene._metadata, IScene._pick_rectangular_metadata, left, bottom, right, top, OutArg())

    _pick_screen_overlays_metadata = { "offset" : _pick_screen_overlays_method_offset,
            "arg_types" : (agcom.INT, agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def pick_screen_overlays(self, x:int, y:int) -> "ScreenOverlayPickResultCollection":
        """Execute a pick on screen overlays at the given x, y and returns a front to back sorted collection of picked overlays. The coordinate origin is top, left. To pick other objects in the scene, use the Pick method."""
        return self._intf.invoke(IScene._metadata, IScene._pick_screen_overlays_metadata, x, y, OutArg())

    _get_scene_id_metadata = { "offset" : _get_scene_id_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def scene_id(self) -> int:
        """Return the scene identifier."""
        return self._intf.get_property(IScene._metadata, IScene._get_scene_id_metadata)

    _get_show_water_surface_metadata = { "offset" : _get_show_water_surface_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def show_water_surface(self) -> bool:
        """Get or set whether water surface on earth is shown or hidden in the scene."""
        return self._intf.get_property(IScene._metadata, IScene._get_show_water_surface_metadata)

    _set_show_water_surface_metadata = { "offset" : _set_show_water_surface_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @show_water_surface.setter
    def show_water_surface(self, showWaterSurface:bool) -> None:
        return self._intf.set_property(IScene._metadata, IScene._set_show_water_surface_metadata, showWaterSurface)

    _get_anti_aliasing_metadata = { "offset" : _get_anti_aliasing_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(ANTI_ALIASING),) }
    @property
    def anti_aliasing(self) -> "ANTI_ALIASING":
        """Get or set the multisample anti-aliasing (MSAA) option for this scene. As the level of anti-aliasing increases, performance will generally decrease, but the quality of the anti-aliasing will improve."""
        return self._intf.get_property(IScene._metadata, IScene._get_anti_aliasing_metadata)

    _set_anti_aliasing_metadata = { "offset" : _set_anti_aliasing_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(ANTI_ALIASING),) }
    @anti_aliasing.setter
    def anti_aliasing(self, antiAliasing:"ANTI_ALIASING") -> None:
        return self._intf.set_property(IScene._metadata, IScene._set_anti_aliasing_metadata, antiAliasing)

    _get_visual_effects_metadata = { "offset" : _get_visual_effects_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def visual_effects(self) -> "VisualEffects":
        """Get the visual  effects associated with the scene."""
        return self._intf.get_property(IScene._metadata, IScene._get_visual_effects_metadata)

    _get_clouds_metadata = { "offset" : _get_clouds_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def clouds(self) -> "Clouds":
        """Get the clouds for the scene."""
        return self._intf.get_property(IScene._metadata, IScene._get_clouds_metadata)

    _get_show_star_labels_metadata = { "offset" : _get_show_star_labels_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def show_star_labels(self) -> bool:
        """Get or set whether stars labels are shown or hidden in the scene."""
        return self._intf.get_property(IScene._metadata, IScene._get_show_star_labels_metadata)

    _set_show_star_labels_metadata = { "offset" : _set_show_star_labels_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @show_star_labels.setter
    def show_star_labels(self, showStarLabels:bool) -> None:
        return self._intf.set_property(IScene._metadata, IScene._set_show_star_labels_metadata, showStarLabels)

    _property_names[camera] = "camera"
    _property_names[lighting] = "lighting"
    _property_names[show_sunshine] = "show_sunshine"
    _property_names[central_bodies] = "central_bodies"
    _property_names[background_color] = "background_color"
    _property_names[shade_sky_based_on_altitude] = "shade_sky_based_on_altitude"
    _property_names[show_stars] = "show_stars"
    _property_names[globe_overlay_settings] = "globe_overlay_settings"
    _property_names[scene_id] = "scene_id"
    _property_names[show_water_surface] = "show_water_surface"
    _property_names[anti_aliasing] = "anti_aliasing"
    _property_names[visual_effects] = "visual_effects"
    _property_names[clouds] = "clouds"
    _property_names[show_star_labels] = "show_star_labels"


agcls.AgClassCatalog.add_catalog_entry((5305222447490254466, 9009928902241702280), IScene)
agcls.AgTypeNameMap["IScene"] = IScene

class ISceneDisplayCondition(object):
    """A display condition used to control what scene or scenes an object, such as a primitive, is rendered in. This is used to show an object in some scenes and hide it in others."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _set_display_in_scene_method_offset = 1
    _get_display_in_scene_method_offset = 2
    _display_only_in_scene_method_offset = 3
    _metadata = {
        "iid_data" : (5047996913438946447, 14608630073827982726),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ISceneDisplayCondition."""
        initialize_from_source_object(self, sourceObject, ISceneDisplayCondition)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISceneDisplayCondition)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ISceneDisplayCondition, None)
    
    _set_display_in_scene_metadata = { "offset" : _set_display_in_scene_method_offset,
            "arg_types" : (agcom.PVOID, agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.InterfaceInArg("IScene"), agmarshall.VariantBoolArg,) }
    def set_display_in_scene(self, scene:"IScene", on:bool) -> None:
        """Allow or disallows rendering for in a particular scene for."""
        return self._intf.invoke(ISceneDisplayCondition._metadata, ISceneDisplayCondition._set_display_in_scene_metadata, scene, on)

    _get_display_in_scene_metadata = { "offset" : _get_display_in_scene_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.InterfaceInArg("IScene"), agmarshall.VariantBoolArg,) }
    def get_display_in_scene(self, scene:"IScene") -> bool:
        """Determine whether the display condition allows rendering rendering in the given scene."""
        return self._intf.invoke(ISceneDisplayCondition._metadata, ISceneDisplayCondition._get_display_in_scene_metadata, scene, OutArg())

    _display_only_in_scene_metadata = { "offset" : _display_only_in_scene_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IScene"),) }
    def display_only_in_scene(self, scene:"IScene") -> None:
        """Allow rendering only in the given scene. The display condition will not allow rendering in other scenes, including newly created ones."""
        return self._intf.invoke(ISceneDisplayCondition._metadata, ISceneDisplayCondition._display_only_in_scene_metadata, scene)


agcls.AgClassCatalog.add_catalog_entry((5047996913438946447, 14608630073827982726), ISceneDisplayCondition)
agcls.AgTypeNameMap["ISceneDisplayCondition"] = ISceneDisplayCondition

class ISceneManager(object):
    """The static scene manager class provides global properties and functionality that apply to all scenes and thus affect the rendering of every globe control..."""

    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_primitives_method_offset = 1
    _get_screen_overlays_method_offset = 2
    _get_textures_method_offset = 3
    _get_globe_overlay_settings_method_offset = 4
    _get_scenes_method_offset = 5
    _render_method_offset = 6
    _get_initializers_method_offset = 7
    _get_frame_rate_method_offset = 8
    _metadata = {
        "iid_data" : (5338880585643038703, 1390793286196929705),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ISceneManager."""
        initialize_from_source_object(self, sourceObject, ISceneManager)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISceneManager)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ISceneManager, None)
    
    _get_primitives_metadata = { "offset" : _get_primitives_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def primitives(self) -> "PrimitiveManager":
        """Get the primitive manager, which is used to add primitives to your scenes."""
        return self._intf.get_property(ISceneManager._metadata, ISceneManager._get_primitives_metadata)

    _get_screen_overlays_metadata = { "offset" : _get_screen_overlays_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def screen_overlays(self) -> "ScreenOverlayManager":
        """Get the screen overlay manager, which is used to add screen overlays to your scenes."""
        return self._intf.get_property(ISceneManager._metadata, ISceneManager._get_screen_overlays_metadata)

    _get_textures_metadata = { "offset" : _get_textures_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def textures(self) -> "Texture2DFactory":
        """Get the texture 2d factory, which can be used to create textures from various sources."""
        return self._intf.get_property(ISceneManager._metadata, ISceneManager._get_textures_metadata)

    _get_globe_overlay_settings_metadata = { "offset" : _get_globe_overlay_settings_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def globe_overlay_settings(self) -> "GlobeOverlaySettings":
        """Get the globe overlay settings, which are used to set global settings for all globe overlays."""
        return self._intf.get_property(ISceneManager._metadata, ISceneManager._get_globe_overlay_settings_metadata)

    _get_scenes_metadata = { "offset" : _get_scenes_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def scenes(self) -> "SceneCollection":
        """Get a read-only collection of scenes that are associated with the scene manager."""
        return self._intf.get_property(ISceneManager._metadata, ISceneManager._get_scenes_metadata)

    _render_metadata = { "offset" : _render_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def render(self) -> None:
        """Render all scenes within an application. To render a specific scene, use the Render method."""
        return self._intf.invoke(ISceneManager._metadata, ISceneManager._render_metadata, )

    _get_initializers_metadata = { "offset" : _get_initializers_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def initializers(self) -> "FactoryAndInitializers":
        """Allow the user to create or initialize primitives, display conditions, tringulators and other types of objects."""
        return self._intf.get_property(ISceneManager._metadata, ISceneManager._get_initializers_metadata)

    _get_frame_rate_metadata = { "offset" : _get_frame_rate_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def frame_rate(self) -> "FrameRate":
        """Get the frame rate class, which can be used to keep track of how fast scenes are being <see ref='Render'>rendered</see>."""
        return self._intf.get_property(ISceneManager._metadata, ISceneManager._get_frame_rate_metadata)

    _property_names[primitives] = "primitives"
    _property_names[screen_overlays] = "screen_overlays"
    _property_names[textures] = "textures"
    _property_names[globe_overlay_settings] = "globe_overlay_settings"
    _property_names[scenes] = "scenes"
    _property_names[initializers] = "initializers"
    _property_names[frame_rate] = "frame_rate"


agcls.AgClassCatalog.add_catalog_entry((5338880585643038703, 1390793286196929705), ISceneManager)
agcls.AgTypeNameMap["ISceneManager"] = ISceneManager

class IScreenOverlay(object):
    """A visible element drawn in screen space. Overlays are useful for floating logos, heads up displays, and integrating user interfaces into the 3D window."""

    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "iid_data" : (5414131607122331821, 17536076725021774741),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IScreenOverlay."""
        initialize_from_source_object(self, sourceObject, IScreenOverlay)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IScreenOverlay)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IScreenOverlay, None)
    

agcls.AgClassCatalog.add_catalog_entry((5414131607122331821, 17536076725021774741), IScreenOverlay)
agcls.AgTypeNameMap["IScreenOverlay"] = IScreenOverlay

class IScreenOverlayCollection(object):
    """A collection of screen overlays."""

    _num_methods = 0
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _metadata = {
        "iid_data" : (5262217257495667236, 17532824272504716714),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IScreenOverlayCollection."""
        initialize_from_source_object(self, sourceObject, IScreenOverlayCollection)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IScreenOverlayCollection)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IScreenOverlayCollection, None)
    

agcls.AgClassCatalog.add_catalog_entry((5262217257495667236, 17532824272504716714), IScreenOverlayCollection)
agcls.AgTypeNameMap["IScreenOverlayCollection"] = IScreenOverlayCollection

class IScreenOverlayManager(object):
    """The top-level container for screen overlays. All child screen overlays that are added to this container are specified relative to the overall globe control."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_bounds_method_offset = 1
    _get_overlays_method_offset = 2
    _get_padding_method_offset = 3
    _set_padding_method_offset = 4
    _get_display_method_offset = 5
    _set_display_method_offset = 6
    _metadata = {
        "iid_data" : (5252209601608109701, 10720637566953264540),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IScreenOverlayManager."""
        initialize_from_source_object(self, sourceObject, IScreenOverlayManager)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IScreenOverlayManager)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IScreenOverlayManager, None)
    
    _get_bounds_metadata = { "offset" : _get_bounds_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def bounds(self) -> list:
        """Get the overall bounds of the globe control. The array contains the properties defining the bounds in the order left x location, top y location, width, height."""
        return self._intf.get_property(IScreenOverlayManager._metadata, IScreenOverlayManager._get_bounds_metadata)

    _get_overlays_metadata = { "offset" : _get_overlays_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def overlays(self) -> "ScreenOverlayCollection":
        """Get the collection of overlays that are contained within this manager."""
        return self._intf.get_property(IScreenOverlayManager._metadata, IScreenOverlayManager._get_overlays_metadata)

    _get_padding_metadata = { "offset" : _get_padding_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def padding(self) -> list:
        """Get or set the padding surrounding the overlays that are contained within this manager. The array contains the components of the padding arranged in the order left, top, right, bottom."""
        return self._intf.get_property(IScreenOverlayManager._metadata, IScreenOverlayManager._get_padding_metadata)

    _set_padding_metadata = { "offset" : _set_padding_method_offset,
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @padding.setter
    def padding(self, padding:list) -> None:
        return self._intf.set_property(IScreenOverlayManager._metadata, IScreenOverlayManager._set_padding_metadata, padding)

    _get_display_metadata = { "offset" : _get_display_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def display(self) -> bool:
        """Get or set if the collection of overlays that are contained within this manager should be rendered."""
        return self._intf.get_property(IScreenOverlayManager._metadata, IScreenOverlayManager._get_display_metadata)

    _set_display_metadata = { "offset" : _set_display_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @display.setter
    def display(self, display:bool) -> None:
        return self._intf.set_property(IScreenOverlayManager._metadata, IScreenOverlayManager._set_display_metadata, display)

    _property_names[bounds] = "bounds"
    _property_names[overlays] = "overlays"
    _property_names[padding] = "padding"
    _property_names[display] = "display"


agcls.AgClassCatalog.add_catalog_entry((5252209601608109701, 10720637566953264540), IScreenOverlayManager)
agcls.AgTypeNameMap["IScreenOverlayManager"] = IScreenOverlayManager

class IScreenOverlayPickResult(object):
    """Describes a picked screen overlay as a result of a call to pick screen overlays."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_position_method_offset = 1
    _get_control_position_method_offset = 2
    _get_overlay_method_offset = 3
    _metadata = {
        "iid_data" : (5121641088858368209, 13022394605157415062),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IScreenOverlayPickResult."""
        initialize_from_source_object(self, sourceObject, IScreenOverlayPickResult)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IScreenOverlayPickResult)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IScreenOverlayPickResult, None)
    
    _get_position_metadata = { "offset" : _get_position_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def position(self) -> list:
        """Get the position that was picked within the picked overlay. The array represents the picked position and has a size of 4. The elements are in the order x position, y position, x screen overlay unit, y screen overlay unit."""
        return self._intf.get_property(IScreenOverlayPickResult._metadata, IScreenOverlayPickResult._get_position_metadata)

    _get_control_position_metadata = { "offset" : _get_control_position_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def control_position(self) -> list:
        """Get the position that was picked within the overall globe control. This is essentially the same position that was passed to pick screen overlays. The array represents the picked position and has a size of 4..."""
        return self._intf.get_property(IScreenOverlayPickResult._metadata, IScreenOverlayPickResult._get_control_position_metadata)

    _get_overlay_metadata = { "offset" : _get_overlay_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def overlay(self) -> "IScreenOverlay":
        """Get the screen overlay that was picked."""
        return self._intf.get_property(IScreenOverlayPickResult._metadata, IScreenOverlayPickResult._get_overlay_metadata)

    _property_names[position] = "position"
    _property_names[control_position] = "control_position"
    _property_names[overlay] = "overlay"


agcls.AgClassCatalog.add_catalog_entry((5121641088858368209, 13022394605157415062), IScreenOverlayPickResult)
agcls.AgTypeNameMap["IScreenOverlayPickResult"] = IScreenOverlayPickResult

class ISolidPrimitive(object):
    """Render filled solid objects and their outlines. Example solids include boxes and ellipsoids. Various effects are supported, such as displaying the solid's silhouette, and hiding the outline of the backside of the solid..."""

    _num_methods = 39
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_affected_by_lighting_method_offset = 1
    _set_affected_by_lighting_method_offset = 2
    _get_display_fill_method_offset = 3
    _set_display_fill_method_offset = 4
    _get_display_silhouette_method_offset = 5
    _set_display_silhouette_method_offset = 6
    _get_silhouette_color_method_offset = 7
    _set_silhouette_color_method_offset = 8
    _get_silhouette_translucency_method_offset = 9
    _set_silhouette_translucency_method_offset = 10
    _get_silhouette_width_method_offset = 11
    _set_silhouette_width_method_offset = 12
    _get_minimum_silhouette_width_supported_method_offset = 13
    _get_maximum_silhouette_width_supported_method_offset = 14
    _get_display_outline_method_offset = 15
    _set_display_outline_method_offset = 16
    _get_outline_color_method_offset = 17
    _set_outline_color_method_offset = 18
    _get_outline_translucency_method_offset = 19
    _set_outline_translucency_method_offset = 20
    _get_outline_width_method_offset = 21
    _set_outline_width_method_offset = 22
    _get_outline_appearance_method_offset = 23
    _set_outline_appearance_method_offset = 24
    _get_back_line_color_method_offset = 25
    _set_back_line_color_method_offset = 26
    _get_back_line_translucency_method_offset = 27
    _set_back_line_translucency_method_offset = 28
    _get_position_method_offset = 29
    _set_position_method_offset = 30
    _get_rotation_method_offset = 31
    _set_rotation_method_offset = 32
    _get_scale_method_offset = 33
    _set_scale_method_offset = 34
    _get_back_line_width_method_offset = 35
    _set_back_line_width_method_offset = 36
    _get_set_hint_method_offset = 37
    _set_with_result_method_offset = 38
    _set_method_offset = 39
    _metadata = {
        "iid_data" : (5543346789797488819, 2660259113497939099),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ISolidPrimitive."""
        initialize_from_source_object(self, sourceObject, ISolidPrimitive)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISolidPrimitive)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ISolidPrimitive, None)
    
    _get_affected_by_lighting_metadata = { "offset" : _get_affected_by_lighting_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def affected_by_lighting(self) -> bool:
        """Get or set whether the primitive is affected by lighting."""
        return self._intf.get_property(ISolidPrimitive._metadata, ISolidPrimitive._get_affected_by_lighting_metadata)

    _set_affected_by_lighting_metadata = { "offset" : _set_affected_by_lighting_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @affected_by_lighting.setter
    def affected_by_lighting(self, affectedByLighting:bool) -> None:
        return self._intf.set_property(ISolidPrimitive._metadata, ISolidPrimitive._set_affected_by_lighting_metadata, affectedByLighting)

    _get_display_fill_metadata = { "offset" : _get_display_fill_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def display_fill(self) -> bool:
        """Get or set whether the solid's fill is displayed."""
        return self._intf.get_property(ISolidPrimitive._metadata, ISolidPrimitive._get_display_fill_metadata)

    _set_display_fill_metadata = { "offset" : _set_display_fill_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @display_fill.setter
    def display_fill(self, displayFill:bool) -> None:
        return self._intf.set_property(ISolidPrimitive._metadata, ISolidPrimitive._set_display_fill_metadata, displayFill)

    _get_display_silhouette_metadata = { "offset" : _get_display_silhouette_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def display_silhouette(self) -> bool:
        """Get or set whether the solid's silhouette is displayed."""
        return self._intf.get_property(ISolidPrimitive._metadata, ISolidPrimitive._get_display_silhouette_metadata)

    _set_display_silhouette_metadata = { "offset" : _set_display_silhouette_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @display_silhouette.setter
    def display_silhouette(self, displaySilhouette:bool) -> None:
        return self._intf.set_property(ISolidPrimitive._metadata, ISolidPrimitive._set_display_silhouette_metadata, displaySilhouette)

    _get_silhouette_color_metadata = { "offset" : _get_silhouette_color_method_offset,
            "arg_types" : (POINTER(agcom.OLE_COLOR),),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @property
    def silhouette_color(self) -> agcolor.Color:
        """Get or set the silhouette's color."""
        return self._intf.get_property(ISolidPrimitive._metadata, ISolidPrimitive._get_silhouette_color_metadata)

    _set_silhouette_color_metadata = { "offset" : _set_silhouette_color_method_offset,
            "arg_types" : (agcom.OLE_COLOR,),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @silhouette_color.setter
    def silhouette_color(self, silhouetteColor:agcolor.Color) -> None:
        return self._intf.set_property(ISolidPrimitive._metadata, ISolidPrimitive._set_silhouette_color_metadata, silhouetteColor)

    _get_silhouette_translucency_metadata = { "offset" : _get_silhouette_translucency_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def silhouette_translucency(self) -> float:
        """Get or set the silhouette's translucency. Translucency is between 0 and 1, where 0 is opaque and 1 is transparent."""
        return self._intf.get_property(ISolidPrimitive._metadata, ISolidPrimitive._get_silhouette_translucency_metadata)

    _set_silhouette_translucency_metadata = { "offset" : _set_silhouette_translucency_method_offset,
            "arg_types" : (agcom.FLOAT,),
            "marshallers" : (agmarshall.FloatArg,) }
    @silhouette_translucency.setter
    def silhouette_translucency(self, silhouetteTranslucency:float) -> None:
        return self._intf.set_property(ISolidPrimitive._metadata, ISolidPrimitive._set_silhouette_translucency_metadata, silhouetteTranslucency)

    _get_silhouette_width_metadata = { "offset" : _get_silhouette_width_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def silhouette_width(self) -> float:
        """Get or set the silhouette' width, in pixels."""
        return self._intf.get_property(ISolidPrimitive._metadata, ISolidPrimitive._get_silhouette_width_metadata)

    _set_silhouette_width_metadata = { "offset" : _set_silhouette_width_method_offset,
            "arg_types" : (agcom.FLOAT,),
            "marshallers" : (agmarshall.FloatArg,) }
    @silhouette_width.setter
    def silhouette_width(self, silhouetteWidth:float) -> None:
        return self._intf.set_property(ISolidPrimitive._metadata, ISolidPrimitive._set_silhouette_width_metadata, silhouetteWidth)

    _get_minimum_silhouette_width_supported_metadata = { "offset" : _get_minimum_silhouette_width_supported_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def minimum_silhouette_width_supported(self) -> float:
        """Get the minimum silhouette width, in pixels, supported by the video card."""
        return self._intf.get_property(ISolidPrimitive._metadata, ISolidPrimitive._get_minimum_silhouette_width_supported_metadata)

    _get_maximum_silhouette_width_supported_metadata = { "offset" : _get_maximum_silhouette_width_supported_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def maximum_silhouette_width_supported(self) -> float:
        """Get the maximum silhouette width, in pixels, supported by the video card."""
        return self._intf.get_property(ISolidPrimitive._metadata, ISolidPrimitive._get_maximum_silhouette_width_supported_metadata)

    _get_display_outline_metadata = { "offset" : _get_display_outline_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def display_outline(self) -> bool:
        """Get or set whether the solid's outline is displayed."""
        return self._intf.get_property(ISolidPrimitive._metadata, ISolidPrimitive._get_display_outline_metadata)

    _set_display_outline_metadata = { "offset" : _set_display_outline_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @display_outline.setter
    def display_outline(self, displayOutline:bool) -> None:
        return self._intf.set_property(ISolidPrimitive._metadata, ISolidPrimitive._set_display_outline_metadata, displayOutline)

    _get_outline_color_metadata = { "offset" : _get_outline_color_method_offset,
            "arg_types" : (POINTER(agcom.OLE_COLOR),),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @property
    def outline_color(self) -> agcolor.Color:
        """Get or set the outline's color."""
        return self._intf.get_property(ISolidPrimitive._metadata, ISolidPrimitive._get_outline_color_metadata)

    _set_outline_color_metadata = { "offset" : _set_outline_color_method_offset,
            "arg_types" : (agcom.OLE_COLOR,),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @outline_color.setter
    def outline_color(self, outlineColor:agcolor.Color) -> None:
        return self._intf.set_property(ISolidPrimitive._metadata, ISolidPrimitive._set_outline_color_metadata, outlineColor)

    _get_outline_translucency_metadata = { "offset" : _get_outline_translucency_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def outline_translucency(self) -> float:
        """Get or set the outline's translucency. Translucency is between 0 and 1, where 0 is opaque and 1 is transparent."""
        return self._intf.get_property(ISolidPrimitive._metadata, ISolidPrimitive._get_outline_translucency_metadata)

    _set_outline_translucency_metadata = { "offset" : _set_outline_translucency_method_offset,
            "arg_types" : (agcom.FLOAT,),
            "marshallers" : (agmarshall.FloatArg,) }
    @outline_translucency.setter
    def outline_translucency(self, outlineTranslucency:float) -> None:
        return self._intf.set_property(ISolidPrimitive._metadata, ISolidPrimitive._set_outline_translucency_metadata, outlineTranslucency)

    _get_outline_width_metadata = { "offset" : _get_outline_width_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def outline_width(self) -> float:
        """Get or set the outline's width, in pixels."""
        return self._intf.get_property(ISolidPrimitive._metadata, ISolidPrimitive._get_outline_width_metadata)

    _set_outline_width_metadata = { "offset" : _set_outline_width_method_offset,
            "arg_types" : (agcom.FLOAT,),
            "marshallers" : (agmarshall.FloatArg,) }
    @outline_width.setter
    def outline_width(self, outlineWidth:float) -> None:
        return self._intf.set_property(ISolidPrimitive._metadata, ISolidPrimitive._set_outline_width_metadata, outlineWidth)

    _get_outline_appearance_metadata = { "offset" : _get_outline_appearance_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(OUTLINE_APPEARANCE),) }
    @property
    def outline_appearance(self) -> "OUTLINE_APPEARANCE":
        """Get or set the outline's appearance."""
        return self._intf.get_property(ISolidPrimitive._metadata, ISolidPrimitive._get_outline_appearance_metadata)

    _set_outline_appearance_metadata = { "offset" : _set_outline_appearance_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(OUTLINE_APPEARANCE),) }
    @outline_appearance.setter
    def outline_appearance(self, outlineAppearance:"OUTLINE_APPEARANCE") -> None:
        return self._intf.set_property(ISolidPrimitive._metadata, ISolidPrimitive._set_outline_appearance_metadata, outlineAppearance)

    _get_back_line_color_metadata = { "offset" : _get_back_line_color_method_offset,
            "arg_types" : (POINTER(agcom.OLE_COLOR),),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @property
    def back_line_color(self) -> agcolor.Color:
        """Get or set the back line's color."""
        return self._intf.get_property(ISolidPrimitive._metadata, ISolidPrimitive._get_back_line_color_metadata)

    _set_back_line_color_metadata = { "offset" : _set_back_line_color_method_offset,
            "arg_types" : (agcom.OLE_COLOR,),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @back_line_color.setter
    def back_line_color(self, backLineColor:agcolor.Color) -> None:
        return self._intf.set_property(ISolidPrimitive._metadata, ISolidPrimitive._set_back_line_color_metadata, backLineColor)

    _get_back_line_translucency_metadata = { "offset" : _get_back_line_translucency_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def back_line_translucency(self) -> float:
        """Get or set the back line's translucency. Translucency is between 0 and 1, where 0 is opaque and 1 is transparent."""
        return self._intf.get_property(ISolidPrimitive._metadata, ISolidPrimitive._get_back_line_translucency_metadata)

    _set_back_line_translucency_metadata = { "offset" : _set_back_line_translucency_method_offset,
            "arg_types" : (agcom.FLOAT,),
            "marshallers" : (agmarshall.FloatArg,) }
    @back_line_translucency.setter
    def back_line_translucency(self, backLineTranslucency:float) -> None:
        return self._intf.set_property(ISolidPrimitive._metadata, ISolidPrimitive._set_back_line_translucency_metadata, backLineTranslucency)

    _get_position_metadata = { "offset" : _get_position_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def position(self) -> list:
        """Get or set the solid's position. The position is defined in the solid's reference frame. The array contains the components of the position in the order x, y, z."""
        return self._intf.get_property(ISolidPrimitive._metadata, ISolidPrimitive._get_position_metadata)

    _set_position_metadata = { "offset" : _set_position_method_offset,
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @position.setter
    def position(self, position:list) -> None:
        return self._intf.set_property(ISolidPrimitive._metadata, ISolidPrimitive._set_position_metadata, position)

    _get_rotation_metadata = { "offset" : _get_rotation_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def rotation(self) -> "IOrientation":
        """Get or set the rotation applied to the solid before rendering."""
        return self._intf.get_property(ISolidPrimitive._metadata, ISolidPrimitive._get_rotation_metadata)

    _set_rotation_metadata = { "offset" : _set_rotation_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IOrientation"),) }
    @rotation.setter
    def rotation(self, rotation:"IOrientation") -> None:
        return self._intf.set_property(ISolidPrimitive._metadata, ISolidPrimitive._set_rotation_metadata, rotation)

    _get_scale_metadata = { "offset" : _get_scale_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def scale(self) -> list:
        """Get or set a non-uniform scale that is applied to the solid to increase or decrease its rendered size. The array contains the scale for each component of the size in the order x scale, y scale, z scale."""
        return self._intf.get_property(ISolidPrimitive._metadata, ISolidPrimitive._get_scale_metadata)

    _set_scale_metadata = { "offset" : _set_scale_method_offset,
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @scale.setter
    def scale(self, scale:list) -> None:
        return self._intf.set_property(ISolidPrimitive._metadata, ISolidPrimitive._set_scale_metadata, scale)

    _get_back_line_width_metadata = { "offset" : _get_back_line_width_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def back_line_width(self) -> float:
        """Get or set the back line's width, in pixels."""
        return self._intf.get_property(ISolidPrimitive._metadata, ISolidPrimitive._get_back_line_width_metadata)

    _set_back_line_width_metadata = { "offset" : _set_back_line_width_method_offset,
            "arg_types" : (agcom.FLOAT,),
            "marshallers" : (agmarshall.FloatArg,) }
    @back_line_width.setter
    def back_line_width(self, backLineWidth:float) -> None:
        return self._intf.set_property(ISolidPrimitive._metadata, ISolidPrimitive._set_back_line_width_metadata, backLineWidth)

    _get_set_hint_metadata = { "offset" : _get_set_hint_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(SET_HINT),) }
    @property
    def set_hint(self) -> "SET_HINT":
        """Get the primitive's set hint. See the Set Hint Performance Overview for selecting an appropriate value to construct the primitive with."""
        return self._intf.get_property(ISolidPrimitive._metadata, ISolidPrimitive._get_set_hint_metadata)

    _set_with_result_metadata = { "offset" : _set_with_result_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ISolidTriangulatorResult"),) }
    def set_with_result(self, solidTriangulatorResult:"ISolidTriangulatorResult") -> None:
        """Define the solid using the specified solidTriangulatorResult. The solid is rendered in the primitive's reference frame."""
        return self._intf.invoke(ISolidPrimitive._metadata, ISolidPrimitive._set_with_result_metadata, solidTriangulatorResult)

    _set_metadata = { "offset" : _set_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), agcom.LONG, agcom.PVOID, agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.EnumArg(WINDING_ORDER), agmarshall.InterfaceInArg("IBoundingSphere"), agmarshall.VariantBoolArg,) }
    def set(self, positions:list, normals:list, indices:list, outlineIndices:list, windingOrder:"WINDING_ORDER", boundingSphere:"IBoundingSphere", closed:bool) -> None:
        """Define the solid using the specified parameters. The solid is rendered in the primitive's reference frame."""
        return self._intf.invoke(ISolidPrimitive._metadata, ISolidPrimitive._set_metadata, positions, normals, indices, outlineIndices, windingOrder, boundingSphere, closed)

    _property_names[affected_by_lighting] = "affected_by_lighting"
    _property_names[display_fill] = "display_fill"
    _property_names[display_silhouette] = "display_silhouette"
    _property_names[silhouette_color] = "silhouette_color"
    _property_names[silhouette_translucency] = "silhouette_translucency"
    _property_names[silhouette_width] = "silhouette_width"
    _property_names[minimum_silhouette_width_supported] = "minimum_silhouette_width_supported"
    _property_names[maximum_silhouette_width_supported] = "maximum_silhouette_width_supported"
    _property_names[display_outline] = "display_outline"
    _property_names[outline_color] = "outline_color"
    _property_names[outline_translucency] = "outline_translucency"
    _property_names[outline_width] = "outline_width"
    _property_names[outline_appearance] = "outline_appearance"
    _property_names[back_line_color] = "back_line_color"
    _property_names[back_line_translucency] = "back_line_translucency"
    _property_names[position] = "position"
    _property_names[rotation] = "rotation"
    _property_names[scale] = "scale"
    _property_names[back_line_width] = "back_line_width"
    _property_names[set_hint] = "set_hint"


agcls.AgClassCatalog.add_catalog_entry((5543346789797488819, 2660259113497939099), ISolidPrimitive)
agcls.AgTypeNameMap["ISolidPrimitive"] = ISolidPrimitive

class IStereoscopic(object):
    """Get the stereoscopic options for all Scenes. To use a particular stereoscopic display mode, ensure that your system supports the feature and that it is enabled."""

    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_display_mode_method_offset = 1
    _set_display_mode_method_offset = 2
    _get_projection_mode_method_offset = 3
    _set_projection_mode_method_offset = 4
    _get_projection_distance_method_offset = 5
    _set_projection_distance_method_offset = 6
    _get_eye_separation_factor_method_offset = 7
    _set_eye_separation_factor_method_offset = 8
    _metadata = {
        "iid_data" : (4779955330586042651, 5663574790190885304),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IStereoscopic."""
        initialize_from_source_object(self, sourceObject, IStereoscopic)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IStereoscopic)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IStereoscopic, None)
    
    _get_display_mode_metadata = { "offset" : _get_display_mode_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(STEREOSCOPIC_DISPLAY_MODE),) }
    @property
    def display_mode(self) -> "STEREOSCOPIC_DISPLAY_MODE":
        """Get or set the stereoscopic display mode for all Scenes. To use a particular stereoscopic display mode, ensure that your system supports the feature and that it is enabled."""
        return self._intf.get_property(IStereoscopic._metadata, IStereoscopic._get_display_mode_metadata)

    _set_display_mode_metadata = { "offset" : _set_display_mode_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(STEREOSCOPIC_DISPLAY_MODE),) }
    @display_mode.setter
    def display_mode(self, displayMode:"STEREOSCOPIC_DISPLAY_MODE") -> None:
        return self._intf.set_property(IStereoscopic._metadata, IStereoscopic._set_display_mode_metadata, displayMode)

    _get_projection_mode_metadata = { "offset" : _get_projection_mode_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(STEREO_PROJECTION_MODE),) }
    @property
    def projection_mode(self) -> "STEREO_PROJECTION_MODE":
        """Get or set whether the type of stereo projection that will be used."""
        return self._intf.get_property(IStereoscopic._metadata, IStereoscopic._get_projection_mode_metadata)

    _set_projection_mode_metadata = { "offset" : _set_projection_mode_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(STEREO_PROJECTION_MODE),) }
    @projection_mode.setter
    def projection_mode(self, projectionMode:"STEREO_PROJECTION_MODE") -> None:
        return self._intf.set_property(IStereoscopic._metadata, IStereoscopic._set_projection_mode_metadata, projectionMode)

    _get_projection_distance_metadata = { "offset" : _get_projection_distance_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def projection_distance(self) -> float:
        """Get or set the projection distance. If projection mode is set to eStkGraphicsStereoProjectionAutomatic, the value of this property will be ignored."""
        return self._intf.get_property(IStereoscopic._metadata, IStereoscopic._get_projection_distance_metadata)

    _set_projection_distance_metadata = { "offset" : _set_projection_distance_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @projection_distance.setter
    def projection_distance(self, projectionDistance:float) -> None:
        return self._intf.set_property(IStereoscopic._metadata, IStereoscopic._set_projection_distance_metadata, projectionDistance)

    _get_eye_separation_factor_metadata = { "offset" : _get_eye_separation_factor_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def eye_separation_factor(self) -> float:
        """Get or set the eye separation factor."""
        return self._intf.get_property(IStereoscopic._metadata, IStereoscopic._get_eye_separation_factor_metadata)

    _set_eye_separation_factor_metadata = { "offset" : _set_eye_separation_factor_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @eye_separation_factor.setter
    def eye_separation_factor(self, eyeSeparationFactor:float) -> None:
        return self._intf.set_property(IStereoscopic._metadata, IStereoscopic._set_eye_separation_factor_metadata, eyeSeparationFactor)

    _property_names[display_mode] = "display_mode"
    _property_names[projection_mode] = "projection_mode"
    _property_names[projection_distance] = "projection_distance"
    _property_names[eye_separation_factor] = "eye_separation_factor"


agcls.AgClassCatalog.add_catalog_entry((4779955330586042651, 5663574790190885304), IStereoscopic)
agcls.AgTypeNameMap["IStereoscopic"] = IStereoscopic

class ISurfaceMeshPrimitive(object):
    """A triangle mesh primitive for meshes on the surface that need to conform to terrain."""

    _num_methods = 17
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_texture_method_offset = 1
    _set_texture_method_offset = 2
    _get_wireframe_method_offset = 3
    _set_wireframe_method_offset = 4
    _get_triangle_winding_order_method_offset = 5
    _get_set_hint_method_offset = 6
    _get_rendering_method_method_offset = 7
    _get_texture_filter_method_offset = 8
    _set_texture_filter_method_offset = 9
    _get_texture_matrix_method_offset = 10
    _set_texture_matrix_method_offset = 11
    _get_transparent_texture_border_method_offset = 12
    _set_transparent_texture_border_method_offset = 13
    _set_method_offset = 14
    _set_without_texturing_method_offset = 15
    _supported_method_offset = 16
    _supported_with_default_rendering_method_method_offset = 17
    _metadata = {
        "iid_data" : (4690670744547618907, 12009834772259629965),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ISurfaceMeshPrimitive."""
        initialize_from_source_object(self, sourceObject, ISurfaceMeshPrimitive)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISurfaceMeshPrimitive)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ISurfaceMeshPrimitive, None)
    
    _get_texture_metadata = { "offset" : _get_texture_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def texture(self) -> "RendererTexture2D":
        """Get or set the texture applied to this primitive when rendering."""
        return self._intf.get_property(ISurfaceMeshPrimitive._metadata, ISurfaceMeshPrimitive._get_texture_metadata)

    _set_texture_metadata = { "offset" : _set_texture_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IRendererTexture2D"),) }
    @texture.setter
    def texture(self, texture:"IRendererTexture2D") -> None:
        return self._intf.set_property(ISurfaceMeshPrimitive._metadata, ISurfaceMeshPrimitive._set_texture_metadata, texture)

    _get_wireframe_metadata = { "offset" : _get_wireframe_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def wireframe(self) -> bool:
        """Get or set whether the primitive is rendered in wireframe. This is useful for debugging."""
        return self._intf.get_property(ISurfaceMeshPrimitive._metadata, ISurfaceMeshPrimitive._get_wireframe_metadata)

    _set_wireframe_metadata = { "offset" : _set_wireframe_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @wireframe.setter
    def wireframe(self, wireframe:bool) -> None:
        return self._intf.set_property(ISurfaceMeshPrimitive._metadata, ISurfaceMeshPrimitive._set_wireframe_metadata, wireframe)

    _get_triangle_winding_order_metadata = { "offset" : _get_triangle_winding_order_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(WINDING_ORDER),) }
    @property
    def triangle_winding_order(self) -> "WINDING_ORDER":
        """Get the orientation of front-facing triangles in the mesh."""
        return self._intf.get_property(ISurfaceMeshPrimitive._metadata, ISurfaceMeshPrimitive._get_triangle_winding_order_metadata)

    _get_set_hint_metadata = { "offset" : _get_set_hint_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(SET_HINT),) }
    @property
    def set_hint(self) -> "SET_HINT":
        """Get the primitive's set hint. See the Set Hint Performance Overview for selecting an appropriate value to construct the primitive with."""
        return self._intf.get_property(ISurfaceMeshPrimitive._metadata, ISurfaceMeshPrimitive._get_set_hint_metadata)

    _get_rendering_method_metadata = { "offset" : _get_rendering_method_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(SURFACE_MESH_RENDERING_METHOD),) }
    @property
    def rendering_method(self) -> "SURFACE_MESH_RENDERING_METHOD":
        """Get the rendering method used to render the mesh."""
        return self._intf.get_property(ISurfaceMeshPrimitive._metadata, ISurfaceMeshPrimitive._get_rendering_method_metadata)

    _get_texture_filter_metadata = { "offset" : _get_texture_filter_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def texture_filter(self) -> "TextureFilter2D":
        """Get or set the filter used when a texture is applied to this primitive."""
        return self._intf.get_property(ISurfaceMeshPrimitive._metadata, ISurfaceMeshPrimitive._get_texture_filter_metadata)

    _set_texture_filter_metadata = { "offset" : _set_texture_filter_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITextureFilter2D"),) }
    @texture_filter.setter
    def texture_filter(self, textureFilter:"ITextureFilter2D") -> None:
        return self._intf.set_property(ISurfaceMeshPrimitive._metadata, ISurfaceMeshPrimitive._set_texture_filter_metadata, textureFilter)

    _get_texture_matrix_metadata = { "offset" : _get_texture_matrix_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def texture_matrix(self) -> "TextureMatrix":
        """Get or set the matrix used to transform texture coordinates when a texture is applied to this primitive."""
        return self._intf.get_property(ISurfaceMeshPrimitive._metadata, ISurfaceMeshPrimitive._get_texture_matrix_metadata)

    _set_texture_matrix_metadata = { "offset" : _set_texture_matrix_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITextureMatrix"),) }
    @texture_matrix.setter
    def texture_matrix(self, textureMatrix:"ITextureMatrix") -> None:
        return self._intf.set_property(ISurfaceMeshPrimitive._metadata, ISurfaceMeshPrimitive._set_texture_matrix_metadata, textureMatrix)

    _get_transparent_texture_border_metadata = { "offset" : _get_transparent_texture_border_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def transparent_texture_border(self) -> bool:
        """Get or set the boolean that defines if the color obtained from texture coordinates beyond the texture border should be considered transparent or not. This is typically used in conjunction with the a texture matrix."""
        return self._intf.get_property(ISurfaceMeshPrimitive._metadata, ISurfaceMeshPrimitive._get_transparent_texture_border_metadata)

    _set_transparent_texture_border_metadata = { "offset" : _set_transparent_texture_border_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @transparent_texture_border.setter
    def transparent_texture_border(self, transparentTextureBorder:bool) -> None:
        return self._intf.set_property(ISurfaceMeshPrimitive._metadata, ISurfaceMeshPrimitive._set_transparent_texture_border_metadata, transparentTextureBorder)

    _set_metadata = { "offset" : _set_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ISurfaceTriangulatorResult"),) }
    def set(self, surfaceTriangulator:"ISurfaceTriangulatorResult") -> None:
        """Define the surface mesh using the specified surfaceTriangulator. The mesh is rendered in the primitive's reference frame."""
        return self._intf.invoke(ISurfaceMeshPrimitive._metadata, ISurfaceMeshPrimitive._set_metadata, surfaceTriangulator)

    _set_without_texturing_metadata = { "offset" : _set_without_texturing_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ISurfaceTriangulatorResult"),) }
    def set_without_texturing(self, surfaceTriangulator:"ISurfaceTriangulatorResult") -> None:
        """Define the surface mesh using the specified surfaceTriangulator. The mesh is rendered in the primitive's reference frame."""
        return self._intf.invoke(ISurfaceMeshPrimitive._metadata, ISurfaceMeshPrimitive._set_without_texturing_metadata, surfaceTriangulator)

    _supported_metadata = { "offset" : _supported_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.EnumArg(SURFACE_MESH_RENDERING_METHOD), agmarshall.VariantBoolArg,) }
    def supported(self, renderingMethod:"SURFACE_MESH_RENDERING_METHOD") -> bool:
        """Determine whether or not the video card supports the surface mesh primitive with the given renderingMethod."""
        return self._intf.invoke(ISurfaceMeshPrimitive._metadata, ISurfaceMeshPrimitive._supported_metadata, renderingMethod, OutArg())

    _supported_with_default_rendering_method_metadata = { "offset" : _supported_with_default_rendering_method_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    def supported_with_default_rendering_method(self) -> bool:
        """Determine whether or not the video card supports the surface mesh primitive. This is equivalent to calling Supported with automatic."""
        return self._intf.invoke(ISurfaceMeshPrimitive._metadata, ISurfaceMeshPrimitive._supported_with_default_rendering_method_metadata, OutArg())

    _property_names[texture] = "texture"
    _property_names[wireframe] = "wireframe"
    _property_names[triangle_winding_order] = "triangle_winding_order"
    _property_names[set_hint] = "set_hint"
    _property_names[rendering_method] = "rendering_method"
    _property_names[texture_filter] = "texture_filter"
    _property_names[texture_matrix] = "texture_matrix"
    _property_names[transparent_texture_border] = "transparent_texture_border"


agcls.AgClassCatalog.add_catalog_entry((4690670744547618907, 12009834772259629965), ISurfaceMeshPrimitive)
agcls.AgTypeNameMap["ISurfaceMeshPrimitive"] = ISurfaceMeshPrimitive

class ITerrainOverlayCollection(object):
    """A collection of terrain overlay objects."""

    _num_methods = 20
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_count_method_offset = 1
    _get_is_read_only_method_offset = 2
    _item_method_offset = 3
    _get__NewEnum_method_offset = 4
    _contains_method_offset = 5
    _contains_uri_string_method_offset = 6
    _remove_method_offset = 7
    _clear_method_offset = 8
    _add_method_offset = 9
    _add_async_method_offset = 10
    _index_of_method_offset = 11
    _index_of_uri_string_method_offset = 12
    _add_uri_string_method_offset = 13
    _add_async_uri_string_method_offset = 14
    _swap_method_offset = 15
    _swap_by_index_method_offset = 16
    _move_method_offset = 17
    _move_by_index_method_offset = 18
    _bring_to_front_method_offset = 19
    _send_to_back_method_offset = 20
    _metadata = {
        "iid_data" : (4834722276085425062, 14155078082643029135),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ITerrainOverlayCollection."""
        initialize_from_source_object(self, sourceObject, ITerrainOverlayCollection)
        self.__dict__["_enumerator"] = None
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITerrainOverlayCollection)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ITerrainOverlayCollection, None)
    def __iter__(self):
        """Create an iterator for the ITerrainOverlayCollection object."""
        self.__dict__["_enumerator"] = self._NewEnum
        self._enumerator.reset()
        return self
    def __next__(self) -> "ITerrainOverlay":
        """Return the next element in the collection."""
        if self._enumerator is None:
            raise StopIteration
        nextval = self._enumerator.next()
        if nextval is None:
            raise StopIteration
        return nextval
    def Subscribe(self) -> ITerrainOverlayCollectionEventHandler:
        """Return an ITerrainOverlayCollectionEventHandler that is subscribed to handle events associated with this instance of ITerrainOverlayCollection."""
        return ITerrainOverlayCollectionEventHandler(self._intf)
    
    _get_count_metadata = { "offset" : _get_count_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def count(self) -> int:
        """Get the number of terrain overlay objects in the collection."""
        return self._intf.get_property(ITerrainOverlayCollection._metadata, ITerrainOverlayCollection._get_count_metadata)

    _get_is_read_only_metadata = { "offset" : _get_is_read_only_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def is_read_only(self) -> bool:
        """Get whether or not the collection is read only."""
        return self._intf.get_property(ITerrainOverlayCollection._metadata, ITerrainOverlayCollection._get_is_read_only_metadata)

    _item_metadata = { "offset" : _item_method_offset,
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def item(self, index:int) -> "ITerrainOverlay":
        """Get the terrain overlay at the specified index."""
        return self._intf.invoke(ITerrainOverlayCollection._metadata, ITerrainOverlayCollection._item_metadata, index, OutArg())

    _get__NewEnum_metadata = { "offset" : _get__NewEnum_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IEnumVariantArg,) }
    @property
    def _NewEnum(self) -> EnumeratorProxy:
        """Construct an iterator that can be used to iterate the collection."""
        return self._intf.get_property(ITerrainOverlayCollection._metadata, ITerrainOverlayCollection._get__NewEnum_metadata)

    _contains_metadata = { "offset" : _contains_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.InterfaceInArg("ITerrainOverlay"), agmarshall.VariantBoolArg,) }
    def contains(self, terrainOverlay:"ITerrainOverlay") -> bool:
        """Check the presence of a terrain overlay in the collection."""
        return self._intf.invoke(ITerrainOverlayCollection._metadata, ITerrainOverlayCollection._contains_metadata, terrainOverlay, OutArg())

    _contains_uri_string_metadata = { "offset" : _contains_uri_string_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.VariantBoolArg,) }
    def contains_uri_string(self, stringUri:str) -> bool:
        """Check the presence of a terrain overlay with the specified Uri in the collection."""
        return self._intf.invoke(ITerrainOverlayCollection._metadata, ITerrainOverlayCollection._contains_uri_string_metadata, stringUri, OutArg())

    _remove_metadata = { "offset" : _remove_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.InterfaceInArg("ITerrainOverlay"), agmarshall.VariantBoolArg,) }
    def remove(self, terrainOverlay:"ITerrainOverlay") -> bool:
        """Remove a terrain overlay from the collection."""
        return self._intf.invoke(ITerrainOverlayCollection._metadata, ITerrainOverlayCollection._remove_metadata, terrainOverlay, OutArg())

    _clear_metadata = { "offset" : _clear_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def clear(self) -> None:
        """Remove all terrain overlay objects from the collection."""
        return self._intf.invoke(ITerrainOverlayCollection._metadata, ITerrainOverlayCollection._clear_metadata, )

    _add_metadata = { "offset" : _add_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITerrainOverlay"),) }
    def add(self, terrainOverlay:"ITerrainOverlay") -> None:
        """Add terrainOverlay to the collection."""
        return self._intf.invoke(ITerrainOverlayCollection._metadata, ITerrainOverlayCollection._add_metadata, terrainOverlay)

    _add_async_metadata = { "offset" : _add_async_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITerrainOverlay"),) }
    def add_async(self, terrainOverlay:"ITerrainOverlay") -> None:
        """Add terrainOverlay to the collection asynchronously."""
        return self._intf.invoke(ITerrainOverlayCollection._metadata, ITerrainOverlayCollection._add_async_metadata, terrainOverlay)

    _index_of_metadata = { "offset" : _index_of_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.INT),),
            "marshallers" : (agmarshall.InterfaceInArg("ITerrainOverlay"), agmarshall.IntArg,) }
    def index_of(self, terrainOverlay:"ITerrainOverlay") -> int:
        """Get the index of the specified terrain overlay."""
        return self._intf.invoke(ITerrainOverlayCollection._metadata, ITerrainOverlayCollection._index_of_metadata, terrainOverlay, OutArg())

    _index_of_uri_string_metadata = { "offset" : _index_of_uri_string_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.INT),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.IntArg,) }
    def index_of_uri_string(self, stringUri:str) -> int:
        """Get the index of the terrain overlay with the specified Uri."""
        return self._intf.invoke(ITerrainOverlayCollection._metadata, ITerrainOverlayCollection._index_of_uri_string_metadata, stringUri, OutArg())

    _add_uri_string_metadata = { "offset" : _add_uri_string_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def add_uri_string(self, uri:str) -> "ITerrainOverlay":
        """Create a terrain overlay from the uri, which represents a uri, and adds it to the collection."""
        return self._intf.invoke(ITerrainOverlayCollection._metadata, ITerrainOverlayCollection._add_uri_string_metadata, uri, OutArg())

    _add_async_uri_string_metadata = { "offset" : _add_async_uri_string_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def add_async_uri_string(self, uri:str) -> "ITerrainOverlay":
        """Create a terrain overlay from the uri, which represents a uri, and adds it to the collection asynchronously."""
        return self._intf.invoke(ITerrainOverlayCollection._metadata, ITerrainOverlayCollection._add_async_uri_string_metadata, uri, OutArg())

    _swap_metadata = { "offset" : _swap_method_offset,
            "arg_types" : (agcom.PVOID, agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITerrainOverlay"), agmarshall.InterfaceInArg("ITerrainOverlay"),) }
    def swap(self, terrainOverlay1:"ITerrainOverlay", terrainOverlay2:"ITerrainOverlay") -> None:
        """Swap the position of two terrain overlay objects."""
        return self._intf.invoke(ITerrainOverlayCollection._metadata, ITerrainOverlayCollection._swap_metadata, terrainOverlay1, terrainOverlay2)

    _swap_by_index_metadata = { "offset" : _swap_by_index_method_offset,
            "arg_types" : (agcom.INT, agcom.INT,),
            "marshallers" : (agmarshall.IntArg, agmarshall.IntArg,) }
    def swap_by_index(self, index1:int, index2:int) -> None:
        """Swap the position of two terrain overlay objects at the specified indices."""
        return self._intf.invoke(ITerrainOverlayCollection._metadata, ITerrainOverlayCollection._swap_by_index_metadata, index1, index2)

    _move_metadata = { "offset" : _move_method_offset,
            "arg_types" : (agcom.PVOID, agcom.INT,),
            "marshallers" : (agmarshall.InterfaceInArg("ITerrainOverlay"), agmarshall.IntArg,) }
    def move(self, terrainOverlay:"ITerrainOverlay", newPosition:int) -> None:
        """Move the terrain overlay to the specified position."""
        return self._intf.invoke(ITerrainOverlayCollection._metadata, ITerrainOverlayCollection._move_metadata, terrainOverlay, newPosition)

    _move_by_index_metadata = { "offset" : _move_by_index_method_offset,
            "arg_types" : (agcom.INT, agcom.INT,),
            "marshallers" : (agmarshall.IntArg, agmarshall.IntArg,) }
    def move_by_index(self, index:int, newPosition:int) -> None:
        """Move the terrain overlay at the specified index to the specified position."""
        return self._intf.invoke(ITerrainOverlayCollection._metadata, ITerrainOverlayCollection._move_by_index_metadata, index, newPosition)

    _bring_to_front_metadata = { "offset" : _bring_to_front_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITerrainOverlay"),) }
    def bring_to_front(self, terrainOverlay:"ITerrainOverlay") -> None:
        """Brings the terrain overlay to the front of the collection so it is rendered first or on the bottom."""
        return self._intf.invoke(ITerrainOverlayCollection._metadata, ITerrainOverlayCollection._bring_to_front_metadata, terrainOverlay)

    _send_to_back_metadata = { "offset" : _send_to_back_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITerrainOverlay"),) }
    def send_to_back(self, terrainOverlay:"ITerrainOverlay") -> None:
        """Send the terrain overlay to the back of the collection so it is rendered last or on the top."""
        return self._intf.invoke(ITerrainOverlayCollection._metadata, ITerrainOverlayCollection._send_to_back_metadata, terrainOverlay)

    __getitem__ = item


    _property_names[count] = "count"
    _property_names[is_read_only] = "is_read_only"
    _property_names[_NewEnum] = "_NewEnum"


agcls.AgClassCatalog.add_catalog_entry((4834722276085425062, 14155078082643029135), ITerrainOverlayCollection)
agcls.AgTypeNameMap["ITerrainOverlayCollection"] = ITerrainOverlayCollection

class ITerrainOverlay(object):
    """A globe overlay which shows terrain."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_altitude_offset_method_offset = 1
    _set_altitude_offset_method_offset = 2
    _get_altitude_scale_method_offset = 3
    _set_altitude_scale_method_offset = 4
    _get_supported_method_offset = 5
    _metadata = {
        "iid_data" : (4855015852445367860, 8081296487407790247),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ITerrainOverlay."""
        initialize_from_source_object(self, sourceObject, ITerrainOverlay)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITerrainOverlay)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ITerrainOverlay, None)
    
    _get_altitude_offset_metadata = { "offset" : _get_altitude_offset_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def altitude_offset(self) -> float:
        """Get or set the value from which to offset the terrain height."""
        return self._intf.get_property(ITerrainOverlay._metadata, ITerrainOverlay._get_altitude_offset_metadata)

    _set_altitude_offset_metadata = { "offset" : _set_altitude_offset_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @altitude_offset.setter
    def altitude_offset(self, altitudeOffset:float) -> None:
        return self._intf.set_property(ITerrainOverlay._metadata, ITerrainOverlay._set_altitude_offset_metadata, altitudeOffset)

    _get_altitude_scale_metadata = { "offset" : _get_altitude_scale_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def altitude_scale(self) -> float:
        """Get or set the value from which to scale the terrain height."""
        return self._intf.get_property(ITerrainOverlay._metadata, ITerrainOverlay._get_altitude_scale_metadata)

    _set_altitude_scale_metadata = { "offset" : _set_altitude_scale_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @altitude_scale.setter
    def altitude_scale(self, altitudeScale:float) -> None:
        return self._intf.set_property(ITerrainOverlay._metadata, ITerrainOverlay._set_altitude_scale_metadata, altitudeScale)

    _get_supported_metadata = { "offset" : _get_supported_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def supported(self) -> bool:
        """Get whether the video card supports adding terrain overlay objects. Video cards that support OpenGL 1.2 or higher support terrain overlay objects."""
        return self._intf.get_property(ITerrainOverlay._metadata, ITerrainOverlay._get_supported_metadata)

    _property_names[altitude_offset] = "altitude_offset"
    _property_names[altitude_scale] = "altitude_scale"
    _property_names[supported] = "supported"


agcls.AgClassCatalog.add_catalog_entry((4855015852445367860, 8081296487407790247), ITerrainOverlay)
agcls.AgTypeNameMap["ITerrainOverlay"] = ITerrainOverlay

class ITextBatchPrimitive(object):
    """Render one or more strings in the 3D scene. For best performance, avoid creating lots of batches with only a few strings each. See the Batching Performance Overview. """

    _num_methods = 32
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_set_hint_method_offset = 1
    _get_bounding_sphere_scale_method_offset = 2
    _set_bounding_sphere_scale_method_offset = 3
    _get_font_method_offset = 4
    _get_outline_color_method_offset = 5
    _set_outline_color_method_offset = 6
    _get_outline_translucency_method_offset = 7
    _set_outline_translucency_method_offset = 8
    _get_align_to_pixel_method_offset = 9
    _set_align_to_pixel_method_offset = 10
    _get_distance_display_condition_per_string_method_offset = 11
    _set_distance_display_condition_per_string_method_offset = 12
    _get_per_item_picking_enabled_method_offset = 13
    _set_per_item_picking_enabled_method_offset = 14
    _get_texture_filter_method_offset = 15
    _set_texture_filter_method_offset = 16
    _set_method_offset = 17
    _set_with_optional_parameters_method_offset = 18
    _set_with_optional_parameters_and_render_pass_method_offset = 19
    _set_cartographic_method_offset = 20
    _set_cartographic_with_optional_parameters_method_offset = 21
    _set_cartographic_with_optional_parameters_and_render_pass_method_offset = 22
    _set_partial_method_offset = 23
    _set_partial_with_indices_order_method_offset = 24
    _set_partial_with_optional_parameters_method_offset = 25
    _set_partial_with_optional_parameters_indices_order_and_render_pass_method_offset = 26
    _set_partial_cartographic_method_offset = 27
    _set_partial_cartographic_with_indices_order_method_offset = 28
    _set_partial_cartographic_with_optional_parameters_method_offset = 29
    _set_partial_cartographic_with_optional_parameters_indices_order_and_render_pass_method_offset = 30
    _get_render_in_screen_space_method_offset = 31
    _set_render_in_screen_space_method_offset = 32
    _metadata = {
        "iid_data" : (4634979056355844859, 3124701436410088883),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ITextBatchPrimitive."""
        initialize_from_source_object(self, sourceObject, ITextBatchPrimitive)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITextBatchPrimitive)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ITextBatchPrimitive, None)
    
    _get_set_hint_metadata = { "offset" : _get_set_hint_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(SET_HINT),) }
    @property
    def set_hint(self) -> "SET_HINT":
        """Get the primitive's set hint. See the Set Hint Performance Overview for selecting an appropriate value to construct the primitive with."""
        return self._intf.get_property(ITextBatchPrimitive._metadata, ITextBatchPrimitive._get_set_hint_metadata)

    _get_bounding_sphere_scale_metadata = { "offset" : _get_bounding_sphere_scale_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def bounding_sphere_scale(self) -> float:
        """Get or set the scale applied to the radius of this primitive's bounding sphere."""
        return self._intf.get_property(ITextBatchPrimitive._metadata, ITextBatchPrimitive._get_bounding_sphere_scale_metadata)

    _set_bounding_sphere_scale_metadata = { "offset" : _set_bounding_sphere_scale_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @bounding_sphere_scale.setter
    def bounding_sphere_scale(self, boundingSphereScale:float) -> None:
        return self._intf.set_property(ITextBatchPrimitive._metadata, ITextBatchPrimitive._set_bounding_sphere_scale_metadata, boundingSphereScale)

    _get_font_metadata = { "offset" : _get_font_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def font(self) -> "GraphicsFont":
        """Get the font used to render the text batch."""
        return self._intf.get_property(ITextBatchPrimitive._metadata, ITextBatchPrimitive._get_font_metadata)

    _get_outline_color_metadata = { "offset" : _get_outline_color_method_offset,
            "arg_types" : (POINTER(agcom.OLE_COLOR),),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @property
    def outline_color(self) -> agcolor.Color:
        """Get or set the text's outline color."""
        return self._intf.get_property(ITextBatchPrimitive._metadata, ITextBatchPrimitive._get_outline_color_metadata)

    _set_outline_color_metadata = { "offset" : _set_outline_color_method_offset,
            "arg_types" : (agcom.OLE_COLOR,),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @outline_color.setter
    def outline_color(self, outlineColor:agcolor.Color) -> None:
        return self._intf.set_property(ITextBatchPrimitive._metadata, ITextBatchPrimitive._set_outline_color_metadata, outlineColor)

    _get_outline_translucency_metadata = { "offset" : _get_outline_translucency_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def outline_translucency(self) -> float:
        """Get or set the text's outline translucency. Translucency is between 0 and 1, where 0 is opaque and 1 is transparent."""
        return self._intf.get_property(ITextBatchPrimitive._metadata, ITextBatchPrimitive._get_outline_translucency_metadata)

    _set_outline_translucency_metadata = { "offset" : _set_outline_translucency_method_offset,
            "arg_types" : (agcom.FLOAT,),
            "marshallers" : (agmarshall.FloatArg,) }
    @outline_translucency.setter
    def outline_translucency(self, outlineTranslucency:float) -> None:
        return self._intf.set_property(ITextBatchPrimitive._metadata, ITextBatchPrimitive._set_outline_translucency_metadata, outlineTranslucency)

    _get_align_to_pixel_metadata = { "offset" : _get_align_to_pixel_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def align_to_pixel(self) -> bool:
        """Get or set whether the screen space position of each string is aligned to a pixel."""
        return self._intf.get_property(ITextBatchPrimitive._metadata, ITextBatchPrimitive._get_align_to_pixel_metadata)

    _set_align_to_pixel_metadata = { "offset" : _set_align_to_pixel_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @align_to_pixel.setter
    def align_to_pixel(self, alignToPixel:bool) -> None:
        return self._intf.set_property(ITextBatchPrimitive._metadata, ITextBatchPrimitive._set_align_to_pixel_metadata, alignToPixel)

    _get_distance_display_condition_per_string_metadata = { "offset" : _get_distance_display_condition_per_string_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def distance_display_condition_per_string(self) -> "DistanceDisplayCondition":
        """Get or set a distance display condition that is evaluated per string in the text batch during rendering. This is different than display condition, which is evaluated once for the entire text batch..."""
        return self._intf.get_property(ITextBatchPrimitive._metadata, ITextBatchPrimitive._get_distance_display_condition_per_string_metadata)

    _set_distance_display_condition_per_string_metadata = { "offset" : _set_distance_display_condition_per_string_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IDistanceDisplayCondition"),) }
    @distance_display_condition_per_string.setter
    def distance_display_condition_per_string(self, distanceDisplayConditionPerString:"IDistanceDisplayCondition") -> None:
        return self._intf.set_property(ITextBatchPrimitive._metadata, ITextBatchPrimitive._set_distance_display_condition_per_string_metadata, distanceDisplayConditionPerString)

    _get_per_item_picking_enabled_metadata = { "offset" : _get_per_item_picking_enabled_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def per_item_picking_enabled(self) -> bool:
        """Get or set whether individual text indices will be included in the pick results returned from the scene's Pick method. Each text index that is picked will be returned as a batch primitive index."""
        return self._intf.get_property(ITextBatchPrimitive._metadata, ITextBatchPrimitive._get_per_item_picking_enabled_metadata)

    _set_per_item_picking_enabled_metadata = { "offset" : _set_per_item_picking_enabled_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @per_item_picking_enabled.setter
    def per_item_picking_enabled(self, perItemPickingEnabled:bool) -> None:
        return self._intf.set_property(ITextBatchPrimitive._metadata, ITextBatchPrimitive._set_per_item_picking_enabled_metadata, perItemPickingEnabled)

    _get_texture_filter_metadata = { "offset" : _get_texture_filter_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def texture_filter(self) -> "TextureFilter2D":
        """Get or set the filter used to filter the texture-based font."""
        return self._intf.get_property(ITextBatchPrimitive._metadata, ITextBatchPrimitive._get_texture_filter_metadata)

    _set_texture_filter_metadata = { "offset" : _set_texture_filter_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITextureFilter2D"),) }
    @texture_filter.setter
    def texture_filter(self, textureFilter:"ITextureFilter2D") -> None:
        return self._intf.set_property(ITextBatchPrimitive._metadata, ITextBatchPrimitive._set_texture_filter_metadata, textureFilter)

    _set_metadata = { "offset" : _set_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg,) }
    def set(self, positions:list, text:list) -> None:
        """Define the positions and text of strings in a text batch. The strings are rendered in the primitive's reference frame."""
        return self._intf.invoke(ITextBatchPrimitive._metadata, ITextBatchPrimitive._set_metadata, positions, text)

    _set_with_optional_parameters_metadata = { "offset" : _set_with_optional_parameters_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), agcom.PVOID,),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.InterfaceInArg("ITextBatchPrimitiveOptionalParameters"),) }
    def set_with_optional_parameters(self, positions:list, text:list, optionalParameters:"ITextBatchPrimitiveOptionalParameters") -> None:
        """Define the positions, text, and optional parameters of strings in a text batch. The strings are rendered in the primitive's reference frame."""
        return self._intf.invoke(ITextBatchPrimitive._metadata, ITextBatchPrimitive._set_with_optional_parameters_metadata, positions, text, optionalParameters)

    _set_with_optional_parameters_and_render_pass_metadata = { "offset" : _set_with_optional_parameters_and_render_pass_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), agcom.PVOID, agcom.LONG,),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.InterfaceInArg("ITextBatchPrimitiveOptionalParameters"), agmarshall.EnumArg(RENDER_PASS_HINT),) }
    def set_with_optional_parameters_and_render_pass(self, positions:list, text:list, optionalParameters:"ITextBatchPrimitiveOptionalParameters", renderPassHint:"RENDER_PASS_HINT") -> None:
        """Define the positions, text, and optional parameters of strings in a text batch. The strings are rendered in the primitive's reference frame. renderPassHint is provided for efficiency."""
        return self._intf.invoke(ITextBatchPrimitive._metadata, ITextBatchPrimitive._set_with_optional_parameters_and_render_pass_metadata, positions, text, optionalParameters, renderPassHint)

    _set_cartographic_metadata = { "offset" : _set_cartographic_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg,) }
    def set_cartographic(self, centralBody:str, positions:list, text:list) -> None:
        """For convenience. Defines the positions and text of strings in a text batch using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling Set."""
        return self._intf.invoke(ITextBatchPrimitive._metadata, ITextBatchPrimitive._set_cartographic_metadata, centralBody, positions, text)

    _set_cartographic_with_optional_parameters_metadata = { "offset" : _set_cartographic_with_optional_parameters_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), agcom.PVOID,),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.InterfaceInArg("ITextBatchPrimitiveOptionalParameters"),) }
    def set_cartographic_with_optional_parameters(self, centralBody:str, positions:list, text:list, optionalParameters:"ITextBatchPrimitiveOptionalParameters") -> None:
        """For convenience. Defines the positions, text, and optional parameters of strings in a text batch using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling Set."""
        return self._intf.invoke(ITextBatchPrimitive._metadata, ITextBatchPrimitive._set_cartographic_with_optional_parameters_metadata, centralBody, positions, text, optionalParameters)

    _set_cartographic_with_optional_parameters_and_render_pass_metadata = { "offset" : _set_cartographic_with_optional_parameters_and_render_pass_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), agcom.PVOID, agcom.LONG,),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.InterfaceInArg("ITextBatchPrimitiveOptionalParameters"), agmarshall.EnumArg(RENDER_PASS_HINT),) }
    def set_cartographic_with_optional_parameters_and_render_pass(self, centralBody:str, positions:list, text:list, optionalParameters:"ITextBatchPrimitiveOptionalParameters", renderPassHint:"RENDER_PASS_HINT") -> None:
        """For convenience. Defines the positions, text, and optional parameters of strings in a text batch using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling Set."""
        return self._intf.invoke(ITextBatchPrimitive._metadata, ITextBatchPrimitive._set_cartographic_with_optional_parameters_and_render_pass_metadata, centralBody, positions, text, optionalParameters, renderPassHint)

    _set_partial_metadata = { "offset" : _set_partial_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg,) }
    def set_partial(self, positions:list, text:list, indices:list) -> None:
        """Update a subset of positions and/or text in a text batch."""
        return self._intf.invoke(ITextBatchPrimitive._metadata, ITextBatchPrimitive._set_partial_metadata, positions, text, indices)

    _set_partial_with_indices_order_metadata = { "offset" : _set_partial_with_indices_order_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), agcom.LONG,),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.EnumArg(INDICES_ORDER_HINT),) }
    def set_partial_with_indices_order(self, positions:list, text:list, indices:list, indicesOrderHint:"INDICES_ORDER_HINT") -> None:
        """Update a subset of positions and/or text in a text batch."""
        return self._intf.invoke(ITextBatchPrimitive._metadata, ITextBatchPrimitive._set_partial_with_indices_order_metadata, positions, text, indices, indicesOrderHint)

    _set_partial_with_optional_parameters_metadata = { "offset" : _set_partial_with_optional_parameters_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), agcom.PVOID, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.InterfaceInArg("ITextBatchPrimitiveOptionalParameters"), agmarshall.LPSafearrayArg,) }
    def set_partial_with_optional_parameters(self, positions:list, text:list, optionalParameters:"ITextBatchPrimitiveOptionalParameters", indices:list) -> None:
        """Update a subset of positions, text, and/or optional per-string parameters in a text batch."""
        return self._intf.invoke(ITextBatchPrimitive._metadata, ITextBatchPrimitive._set_partial_with_optional_parameters_metadata, positions, text, optionalParameters, indices)

    _set_partial_with_optional_parameters_indices_order_and_render_pass_metadata = { "offset" : _set_partial_with_optional_parameters_indices_order_and_render_pass_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), agcom.PVOID, POINTER(agcom.LPSAFEARRAY), agcom.LONG, agcom.LONG,),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.InterfaceInArg("ITextBatchPrimitiveOptionalParameters"), agmarshall.LPSafearrayArg, agmarshall.EnumArg(INDICES_ORDER_HINT), agmarshall.EnumArg(RENDER_PASS_HINT),) }
    def set_partial_with_optional_parameters_indices_order_and_render_pass(self, positions:list, text:list, optionalParameters:"ITextBatchPrimitiveOptionalParameters", indices:list, indicesOrderHint:"INDICES_ORDER_HINT", renderPassHint:"RENDER_PASS_HINT") -> None:
        """Update a subset of positions, text, and/or optional per-string parameters in a text batch."""
        return self._intf.invoke(ITextBatchPrimitive._metadata, ITextBatchPrimitive._set_partial_with_optional_parameters_indices_order_and_render_pass_metadata, positions, text, optionalParameters, indices, indicesOrderHint, renderPassHint)

    _set_partial_cartographic_metadata = { "offset" : _set_partial_cartographic_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg,) }
    def set_partial_cartographic(self, centralBody:str, positions:list, text:list, indices:list) -> None:
        """For convenience. Updates a subset of positions and/or text in a text batch using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling SetPartial."""
        return self._intf.invoke(ITextBatchPrimitive._metadata, ITextBatchPrimitive._set_partial_cartographic_metadata, centralBody, positions, text, indices)

    _set_partial_cartographic_with_indices_order_metadata = { "offset" : _set_partial_cartographic_with_indices_order_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), agcom.LONG,),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.EnumArg(INDICES_ORDER_HINT),) }
    def set_partial_cartographic_with_indices_order(self, centralBody:str, positions:list, text:list, indices:list, indicesOrderHint:"INDICES_ORDER_HINT") -> None:
        """For convenience. Updates a subset of positions and/or text in a text batch using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling SetPartial."""
        return self._intf.invoke(ITextBatchPrimitive._metadata, ITextBatchPrimitive._set_partial_cartographic_with_indices_order_metadata, centralBody, positions, text, indices, indicesOrderHint)

    _set_partial_cartographic_with_optional_parameters_metadata = { "offset" : _set_partial_cartographic_with_optional_parameters_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), agcom.PVOID, POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.InterfaceInArg("ITextBatchPrimitiveOptionalParameters"), agmarshall.LPSafearrayArg,) }
    def set_partial_cartographic_with_optional_parameters(self, centralBody:str, positions:list, text:list, optionalParameters:"ITextBatchPrimitiveOptionalParameters", indices:list) -> None:
        """For convenience. Updates a subset of positions, text, and/or per-string parameters in a text batch using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling SetPartial."""
        return self._intf.invoke(ITextBatchPrimitive._metadata, ITextBatchPrimitive._set_partial_cartographic_with_optional_parameters_metadata, centralBody, positions, text, optionalParameters, indices)

    _set_partial_cartographic_with_optional_parameters_indices_order_and_render_pass_metadata = { "offset" : _set_partial_cartographic_with_optional_parameters_indices_order_and_render_pass_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), agcom.PVOID, POINTER(agcom.LPSAFEARRAY), agcom.LONG, agcom.LONG,),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.InterfaceInArg("ITextBatchPrimitiveOptionalParameters"), agmarshall.LPSafearrayArg, agmarshall.EnumArg(INDICES_ORDER_HINT), agmarshall.EnumArg(RENDER_PASS_HINT),) }
    def set_partial_cartographic_with_optional_parameters_indices_order_and_render_pass(self, centralBody:str, positions:list, text:list, optionalParameters:"ITextBatchPrimitiveOptionalParameters", indices:list, indicesOrderHint:"INDICES_ORDER_HINT", renderPassHint:"RENDER_PASS_HINT") -> None:
        """For convenience. Updates a subset of positions, text, and/or per-string parameters in a text batch using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling SetPartial."""
        return self._intf.invoke(ITextBatchPrimitive._metadata, ITextBatchPrimitive._set_partial_cartographic_with_optional_parameters_indices_order_and_render_pass_metadata, centralBody, positions, text, optionalParameters, indices, indicesOrderHint, renderPassHint)

    _get_render_in_screen_space_metadata = { "offset" : _get_render_in_screen_space_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def render_in_screen_space(self) -> bool:
        """Get or set whether the primitive is positioned and rendered in screen space coordinates."""
        return self._intf.get_property(ITextBatchPrimitive._metadata, ITextBatchPrimitive._get_render_in_screen_space_metadata)

    _set_render_in_screen_space_metadata = { "offset" : _set_render_in_screen_space_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @render_in_screen_space.setter
    def render_in_screen_space(self, renderInScreenSpace:bool) -> None:
        return self._intf.set_property(ITextBatchPrimitive._metadata, ITextBatchPrimitive._set_render_in_screen_space_metadata, renderInScreenSpace)

    _property_names[set_hint] = "set_hint"
    _property_names[bounding_sphere_scale] = "bounding_sphere_scale"
    _property_names[font] = "font"
    _property_names[outline_color] = "outline_color"
    _property_names[outline_translucency] = "outline_translucency"
    _property_names[align_to_pixel] = "align_to_pixel"
    _property_names[distance_display_condition_per_string] = "distance_display_condition_per_string"
    _property_names[per_item_picking_enabled] = "per_item_picking_enabled"
    _property_names[texture_filter] = "texture_filter"
    _property_names[render_in_screen_space] = "render_in_screen_space"


agcls.AgClassCatalog.add_catalog_entry((4634979056355844859, 3124701436410088883), ITextBatchPrimitive)
agcls.AgTypeNameMap["ITextBatchPrimitive"] = ITextBatchPrimitive

class ITextBatchPrimitiveOptionalParameters(object):
    """Optional per-string and per-batch parameters for text batch primitive..."""

    _num_methods = 14
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_origin_method_offset = 1
    _set_origin_method_offset = 2
    _get_eye_offset_method_offset = 3
    _set_eye_offset_method_offset = 4
    _get_pixel_offset_method_offset = 5
    _set_pixel_offset_method_offset = 6
    _get_maximum_string_length_method_offset = 7
    _set_maximum_string_length_method_offset = 8
    _set_origins_method_offset = 9
    _set_eye_offsets_method_offset = 10
    _set_pixel_offsets_method_offset = 11
    _set_colors_method_offset = 12
    _get_screen_space_rendering_method_offset = 13
    _set_screen_space_rendering_method_offset = 14
    _metadata = {
        "iid_data" : (5706768872985264431, 9209360119003680904),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ITextBatchPrimitiveOptionalParameters."""
        initialize_from_source_object(self, sourceObject, ITextBatchPrimitiveOptionalParameters)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITextBatchPrimitiveOptionalParameters)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ITextBatchPrimitiveOptionalParameters, None)
    
    _get_origin_metadata = { "offset" : _get_origin_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(ORIGIN),) }
    @property
    def origin(self) -> "ORIGIN":
        """Get or set the per-batch origin, which is applied to each string in the text batch."""
        return self._intf.get_property(ITextBatchPrimitiveOptionalParameters._metadata, ITextBatchPrimitiveOptionalParameters._get_origin_metadata)

    _set_origin_metadata = { "offset" : _set_origin_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(ORIGIN),) }
    @origin.setter
    def origin(self, origin:"ORIGIN") -> None:
        return self._intf.set_property(ITextBatchPrimitiveOptionalParameters._metadata, ITextBatchPrimitiveOptionalParameters._set_origin_metadata, origin)

    _get_eye_offset_metadata = { "offset" : _get_eye_offset_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def eye_offset(self) -> list:
        """Get or set the per-batch eye offset, which is applied to each string in the text batch. The array contains the components of the offset arranged in the order x, y, z."""
        return self._intf.get_property(ITextBatchPrimitiveOptionalParameters._metadata, ITextBatchPrimitiveOptionalParameters._get_eye_offset_metadata)

    _set_eye_offset_metadata = { "offset" : _set_eye_offset_method_offset,
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @eye_offset.setter
    def eye_offset(self, eyeOffset:list) -> None:
        return self._intf.set_property(ITextBatchPrimitiveOptionalParameters._metadata, ITextBatchPrimitiveOptionalParameters._set_eye_offset_metadata, eyeOffset)

    _get_pixel_offset_metadata = { "offset" : _get_pixel_offset_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @property
    def pixel_offset(self) -> list:
        """Get or set the per-batch pixel offset, which is applied to each string in the text batch. The array contains one x pixel offset followed by one y pixel offset."""
        return self._intf.get_property(ITextBatchPrimitiveOptionalParameters._metadata, ITextBatchPrimitiveOptionalParameters._get_pixel_offset_metadata)

    _set_pixel_offset_metadata = { "offset" : _set_pixel_offset_method_offset,
            "arg_types" : (agcom.LPSAFEARRAY,),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    @pixel_offset.setter
    def pixel_offset(self, pixelOffset:list) -> None:
        return self._intf.set_property(ITextBatchPrimitiveOptionalParameters._metadata, ITextBatchPrimitiveOptionalParameters._set_pixel_offset_metadata, pixelOffset)

    _get_maximum_string_length_metadata = { "offset" : _get_maximum_string_length_method_offset,
            "arg_types" : (POINTER(agcom.INT),),
            "marshallers" : (agmarshall.IntArg,) }
    @property
    def maximum_string_length(self) -> int:
        """Get or set the maximum length of each string in the text batch."""
        return self._intf.get_property(ITextBatchPrimitiveOptionalParameters._metadata, ITextBatchPrimitiveOptionalParameters._get_maximum_string_length_metadata)

    _set_maximum_string_length_metadata = { "offset" : _set_maximum_string_length_method_offset,
            "arg_types" : (agcom.INT,),
            "marshallers" : (agmarshall.IntArg,) }
    @maximum_string_length.setter
    def maximum_string_length(self, maximumStringLength:int) -> None:
        return self._intf.set_property(ITextBatchPrimitiveOptionalParameters._metadata, ITextBatchPrimitiveOptionalParameters._set_maximum_string_length_metadata, maximumStringLength)

    _set_origins_metadata = { "offset" : _set_origins_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    def set_origins(self, origins:list) -> None:
        """Define a collection of origins, one for each string in the batch."""
        return self._intf.invoke(ITextBatchPrimitiveOptionalParameters._metadata, ITextBatchPrimitiveOptionalParameters._set_origins_metadata, origins)

    _set_eye_offsets_metadata = { "offset" : _set_eye_offsets_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    def set_eye_offsets(self, eyeOffsets:list) -> None:
        """Define a collection of eye offsets, one for each string in the batch."""
        return self._intf.invoke(ITextBatchPrimitiveOptionalParameters._metadata, ITextBatchPrimitiveOptionalParameters._set_eye_offsets_metadata, eyeOffsets)

    _set_pixel_offsets_metadata = { "offset" : _set_pixel_offsets_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    def set_pixel_offsets(self, pixelOffsets:list) -> None:
        """Define a collection of pixel offsets, one for each string in the batch."""
        return self._intf.invoke(ITextBatchPrimitiveOptionalParameters._metadata, ITextBatchPrimitiveOptionalParameters._set_pixel_offsets_metadata, pixelOffsets)

    _set_colors_metadata = { "offset" : _set_colors_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    def set_colors(self, colors:list) -> None:
        """Define a collection of colors, one for each string in the batch."""
        return self._intf.invoke(ITextBatchPrimitiveOptionalParameters._metadata, ITextBatchPrimitiveOptionalParameters._set_colors_metadata, colors)

    _get_screen_space_rendering_metadata = { "offset" : _get_screen_space_rendering_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def screen_space_rendering(self) -> bool:
        """Get or set a flag that informs the CTextBatchPrimitive to use rendering optimized for screen space text."""
        return self._intf.get_property(ITextBatchPrimitiveOptionalParameters._metadata, ITextBatchPrimitiveOptionalParameters._get_screen_space_rendering_metadata)

    _set_screen_space_rendering_metadata = { "offset" : _set_screen_space_rendering_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @screen_space_rendering.setter
    def screen_space_rendering(self, screenSpaceRendering:bool) -> None:
        return self._intf.set_property(ITextBatchPrimitiveOptionalParameters._metadata, ITextBatchPrimitiveOptionalParameters._set_screen_space_rendering_metadata, screenSpaceRendering)

    _property_names[origin] = "origin"
    _property_names[eye_offset] = "eye_offset"
    _property_names[pixel_offset] = "pixel_offset"
    _property_names[maximum_string_length] = "maximum_string_length"
    _property_names[screen_space_rendering] = "screen_space_rendering"


agcls.AgClassCatalog.add_catalog_entry((5706768872985264431, 9209360119003680904), ITextBatchPrimitiveOptionalParameters)
agcls.AgTypeNameMap["ITextBatchPrimitiveOptionalParameters"] = ITextBatchPrimitiveOptionalParameters

class ITextOverlay(object):
    """A rectangular overlay that contains text."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_text_method_offset = 1
    _set_text_method_offset = 2
    _get_outline_color_method_offset = 3
    _set_outline_color_method_offset = 4
    _get_font_method_offset = 5
    _set_font_method_offset = 6
    _metadata = {
        "iid_data" : (5705180996127980072, 10503608201518791570),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ITextOverlay."""
        initialize_from_source_object(self, sourceObject, ITextOverlay)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITextOverlay)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ITextOverlay, None)
    
    _get_text_metadata = { "offset" : _get_text_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def text(self) -> str:
        r"""Set the Text to be rendered to an overlay. Newline characters ('\n') will mark the start of the next line in the text."""
        return self._intf.get_property(ITextOverlay._metadata, ITextOverlay._get_text_metadata)

    _set_text_metadata = { "offset" : _set_text_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @text.setter
    def text(self, text:str) -> None:
        return self._intf.set_property(ITextOverlay._metadata, ITextOverlay._set_text_metadata, text)

    _get_outline_color_metadata = { "offset" : _get_outline_color_method_offset,
            "arg_types" : (POINTER(agcom.OLE_COLOR),),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @property
    def outline_color(self) -> agcolor.Color:
        """Get or set the text's outline color."""
        return self._intf.get_property(ITextOverlay._metadata, ITextOverlay._get_outline_color_metadata)

    _set_outline_color_metadata = { "offset" : _set_outline_color_method_offset,
            "arg_types" : (agcom.OLE_COLOR,),
            "marshallers" : (agmarshall.OLEColorArg,) }
    @outline_color.setter
    def outline_color(self, outlineColor:agcolor.Color) -> None:
        return self._intf.set_property(ITextOverlay._metadata, ITextOverlay._set_outline_color_metadata, outlineColor)

    _get_font_metadata = { "offset" : _get_font_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def font(self) -> "GraphicsFont":
        """Get the graphics font used to style the text."""
        return self._intf.get_property(ITextOverlay._metadata, ITextOverlay._get_font_metadata)

    _set_font_metadata = { "offset" : _set_font_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IGraphicsFont"),) }
    @font.setter
    def font(self, font:"IGraphicsFont") -> None:
        return self._intf.set_property(ITextOverlay._metadata, ITextOverlay._set_font_metadata, font)

    _property_names[text] = "text"
    _property_names[outline_color] = "outline_color"
    _property_names[font] = "font"


agcls.AgClassCatalog.add_catalog_entry((5705180996127980072, 10503608201518791570), ITextOverlay)
agcls.AgTypeNameMap["ITextOverlay"] = ITextOverlay

class ITextureMatrix(object):
    """A 4 by 4 matrix applied to a texture coordinate."""

    _num_methods = 16
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_m11_method_offset = 1
    _get_m12_method_offset = 2
    _get_m13_method_offset = 3
    _get_m14_method_offset = 4
    _get_m21_method_offset = 5
    _get_m22_method_offset = 6
    _get_m23_method_offset = 7
    _get_m24_method_offset = 8
    _get_m31_method_offset = 9
    _get_m32_method_offset = 10
    _get_m33_method_offset = 11
    _get_m34_method_offset = 12
    _get_m41_method_offset = 13
    _get_m42_method_offset = 14
    _get_m43_method_offset = 15
    _get_m44_method_offset = 16
    _metadata = {
        "iid_data" : (5075276615207636111, 4269654310333162905),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ITextureMatrix."""
        initialize_from_source_object(self, sourceObject, ITextureMatrix)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITextureMatrix)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ITextureMatrix, None)
    
    _get_m11_metadata = { "offset" : _get_m11_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def m11(self) -> float:
        """Get the element in the first row, first column."""
        return self._intf.get_property(ITextureMatrix._metadata, ITextureMatrix._get_m11_metadata)

    _get_m12_metadata = { "offset" : _get_m12_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def m12(self) -> float:
        """Get the element in the first row, second column."""
        return self._intf.get_property(ITextureMatrix._metadata, ITextureMatrix._get_m12_metadata)

    _get_m13_metadata = { "offset" : _get_m13_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def m13(self) -> float:
        """Get the element in the first row, third column."""
        return self._intf.get_property(ITextureMatrix._metadata, ITextureMatrix._get_m13_metadata)

    _get_m14_metadata = { "offset" : _get_m14_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def m14(self) -> float:
        """Get the element in the first row, fourth column."""
        return self._intf.get_property(ITextureMatrix._metadata, ITextureMatrix._get_m14_metadata)

    _get_m21_metadata = { "offset" : _get_m21_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def m21(self) -> float:
        """Get the element in the second row, first column."""
        return self._intf.get_property(ITextureMatrix._metadata, ITextureMatrix._get_m21_metadata)

    _get_m22_metadata = { "offset" : _get_m22_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def m22(self) -> float:
        """Get the element in the second row, second column."""
        return self._intf.get_property(ITextureMatrix._metadata, ITextureMatrix._get_m22_metadata)

    _get_m23_metadata = { "offset" : _get_m23_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def m23(self) -> float:
        """Get the element in the second row, third column."""
        return self._intf.get_property(ITextureMatrix._metadata, ITextureMatrix._get_m23_metadata)

    _get_m24_metadata = { "offset" : _get_m24_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def m24(self) -> float:
        """Get the element in the second row, fourth column."""
        return self._intf.get_property(ITextureMatrix._metadata, ITextureMatrix._get_m24_metadata)

    _get_m31_metadata = { "offset" : _get_m31_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def m31(self) -> float:
        """Get the element in the third row, first column."""
        return self._intf.get_property(ITextureMatrix._metadata, ITextureMatrix._get_m31_metadata)

    _get_m32_metadata = { "offset" : _get_m32_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def m32(self) -> float:
        """Get the element in the third row, second column."""
        return self._intf.get_property(ITextureMatrix._metadata, ITextureMatrix._get_m32_metadata)

    _get_m33_metadata = { "offset" : _get_m33_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def m33(self) -> float:
        """Get the element in the third row, third column."""
        return self._intf.get_property(ITextureMatrix._metadata, ITextureMatrix._get_m33_metadata)

    _get_m34_metadata = { "offset" : _get_m34_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def m34(self) -> float:
        """Get the element in the third row, fourth column."""
        return self._intf.get_property(ITextureMatrix._metadata, ITextureMatrix._get_m34_metadata)

    _get_m41_metadata = { "offset" : _get_m41_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def m41(self) -> float:
        """Get the element in the fourth row, first column."""
        return self._intf.get_property(ITextureMatrix._metadata, ITextureMatrix._get_m41_metadata)

    _get_m42_metadata = { "offset" : _get_m42_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def m42(self) -> float:
        """Get the element in the fourth row, second column."""
        return self._intf.get_property(ITextureMatrix._metadata, ITextureMatrix._get_m42_metadata)

    _get_m43_metadata = { "offset" : _get_m43_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def m43(self) -> float:
        """Get the element in the fourth row, third column."""
        return self._intf.get_property(ITextureMatrix._metadata, ITextureMatrix._get_m43_metadata)

    _get_m44_metadata = { "offset" : _get_m44_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def m44(self) -> float:
        """Get the element in the fourth row, fourth column."""
        return self._intf.get_property(ITextureMatrix._metadata, ITextureMatrix._get_m44_metadata)

    _property_names[m11] = "m11"
    _property_names[m12] = "m12"
    _property_names[m13] = "m13"
    _property_names[m14] = "m14"
    _property_names[m21] = "m21"
    _property_names[m22] = "m22"
    _property_names[m23] = "m23"
    _property_names[m24] = "m24"
    _property_names[m31] = "m31"
    _property_names[m32] = "m32"
    _property_names[m33] = "m33"
    _property_names[m34] = "m34"
    _property_names[m41] = "m41"
    _property_names[m42] = "m42"
    _property_names[m43] = "m43"
    _property_names[m44] = "m44"


agcls.AgClassCatalog.add_catalog_entry((5075276615207636111, 4269654310333162905), ITextureMatrix)
agcls.AgTypeNameMap["ITextureMatrix"] = ITextureMatrix

class ITextureScreenOverlay(object):
    """A rectangular overlay that can be assigned a texture."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_texture_method_offset = 1
    _set_texture_method_offset = 2
    _get_texture_filter_method_offset = 3
    _set_texture_filter_method_offset = 4
    _get_maintain_aspect_ratio_method_offset = 5
    _set_maintain_aspect_ratio_method_offset = 6
    _metadata = {
        "iid_data" : (4658715220121348983, 14294668540309126071),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ITextureScreenOverlay."""
        initialize_from_source_object(self, sourceObject, ITextureScreenOverlay)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITextureScreenOverlay)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ITextureScreenOverlay, None)
    
    _get_texture_metadata = { "offset" : _get_texture_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def texture(self) -> "RendererTexture2D":
        """Get or set the texture (image) to be drawn on the overlay. Textures can be obtained from textures."""
        return self._intf.get_property(ITextureScreenOverlay._metadata, ITextureScreenOverlay._get_texture_metadata)

    _set_texture_metadata = { "offset" : _set_texture_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IRendererTexture2D"),) }
    @texture.setter
    def texture(self, texture:"IRendererTexture2D") -> None:
        return self._intf.set_property(ITextureScreenOverlay._metadata, ITextureScreenOverlay._set_texture_metadata, texture)

    _get_texture_filter_metadata = { "offset" : _get_texture_filter_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def texture_filter(self) -> "TextureFilter2D":
        """Get or set the filter used for the texture associated with this overlay."""
        return self._intf.get_property(ITextureScreenOverlay._metadata, ITextureScreenOverlay._get_texture_filter_metadata)

    _set_texture_filter_metadata = { "offset" : _set_texture_filter_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITextureFilter2D"),) }
    @texture_filter.setter
    def texture_filter(self, textureFilter:"ITextureFilter2D") -> None:
        return self._intf.set_property(ITextureScreenOverlay._metadata, ITextureScreenOverlay._set_texture_filter_metadata, textureFilter)

    _get_maintain_aspect_ratio_metadata = { "offset" : _get_maintain_aspect_ratio_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(MAINTAIN_ASPECT_RATIO),) }
    @property
    def maintain_aspect_ratio(self) -> "MAINTAIN_ASPECT_RATIO":
        """Get or set a value indicating whether the aspect ratio of the texture screen overlay is maintained or not."""
        return self._intf.get_property(ITextureScreenOverlay._metadata, ITextureScreenOverlay._get_maintain_aspect_ratio_metadata)

    _set_maintain_aspect_ratio_metadata = { "offset" : _set_maintain_aspect_ratio_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(MAINTAIN_ASPECT_RATIO),) }
    @maintain_aspect_ratio.setter
    def maintain_aspect_ratio(self, maintainAspectRatio:"MAINTAIN_ASPECT_RATIO") -> None:
        return self._intf.set_property(ITextureScreenOverlay._metadata, ITextureScreenOverlay._set_maintain_aspect_ratio_metadata, maintainAspectRatio)

    _property_names[texture] = "texture"
    _property_names[texture_filter] = "texture_filter"
    _property_names[maintain_aspect_ratio] = "maintain_aspect_ratio"


agcls.AgClassCatalog.add_catalog_entry((4658715220121348983, 14294668540309126071), ITextureScreenOverlay)
agcls.AgTypeNameMap["ITextureScreenOverlay"] = ITextureScreenOverlay

class ITimeIntervalDisplayCondition(object):
    """Define an inclusive time interval that determines when an object, such as a primitive, is rendered based on the current animation time ."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_minimum_time_method_offset = 1
    _set_minimum_time_method_offset = 2
    _get_maximum_time_method_offset = 3
    _set_maximum_time_method_offset = 4
    _metadata = {
        "iid_data" : (4801331816295250994, 14995469621229658772),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ITimeIntervalDisplayCondition."""
        initialize_from_source_object(self, sourceObject, ITimeIntervalDisplayCondition)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeIntervalDisplayCondition)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ITimeIntervalDisplayCondition, None)
    
    _get_minimum_time_metadata = { "offset" : _get_minimum_time_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def minimum_time(self) -> "IDate":
        """Get or set the minimum time of the inclusive time interval."""
        return self._intf.get_property(ITimeIntervalDisplayCondition._metadata, ITimeIntervalDisplayCondition._get_minimum_time_metadata)

    _set_minimum_time_metadata = { "offset" : _set_minimum_time_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IDate"),) }
    @minimum_time.setter
    def minimum_time(self, minimumTime:"IDate") -> None:
        return self._intf.set_property(ITimeIntervalDisplayCondition._metadata, ITimeIntervalDisplayCondition._set_minimum_time_metadata, minimumTime)

    _get_maximum_time_metadata = { "offset" : _get_maximum_time_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def maximum_time(self) -> "IDate":
        """Get or set the maximum time of the inclusive time interval."""
        return self._intf.get_property(ITimeIntervalDisplayCondition._metadata, ITimeIntervalDisplayCondition._get_maximum_time_metadata)

    _set_maximum_time_metadata = { "offset" : _set_maximum_time_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IDate"),) }
    @maximum_time.setter
    def maximum_time(self, maximumTime:"IDate") -> None:
        return self._intf.set_property(ITimeIntervalDisplayCondition._metadata, ITimeIntervalDisplayCondition._set_maximum_time_metadata, maximumTime)

    _property_names[minimum_time] = "minimum_time"
    _property_names[maximum_time] = "maximum_time"


agcls.AgClassCatalog.add_catalog_entry((4801331816295250994, 14995469621229658772), ITimeIntervalDisplayCondition)
agcls.AgTypeNameMap["ITimeIntervalDisplayCondition"] = ITimeIntervalDisplayCondition

class ITriangleMeshPrimitive(object):
    """Render a triangle mesh in the 3D scene. Examples of triangle meshes include polygons on the globe (e.g. states or countries), terrain and imagery extents, ellipses, and extrusions."""

    _num_methods = 24
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_wireframe_method_offset = 1
    _set_wireframe_method_offset = 2
    _get_render_back_then_front_faces_method_offset = 3
    _set_render_back_then_front_faces_method_offset = 4
    _get_lighting_method_offset = 5
    _set_lighting_method_offset = 6
    _get_triangle_winding_order_method_offset = 7
    _set_triangle_winding_order_method_offset = 8
    _get_cull_face_method_offset = 9
    _set_cull_face_method_offset = 10
    _get_shade_model_method_offset = 11
    _set_shade_model_method_offset = 12
    _get_texture_method_offset = 13
    _set_texture_method_offset = 14
    _get_texture_filter_method_offset = 15
    _set_texture_filter_method_offset = 16
    _get_set_hint_method_offset = 17
    _set_method_offset = 18
    _set_with_optional_parameters_method_offset = 19
    _set_triangulator_method_offset = 20
    _get_central_body_clipped_method_offset = 21
    _set_central_body_clipped_method_offset = 22
    _get_two_sided_lighting_method_offset = 23
    _set_two_sided_lighting_method_offset = 24
    _metadata = {
        "iid_data" : (4930896001075044620, 5765055608652741256),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ITriangleMeshPrimitive."""
        initialize_from_source_object(self, sourceObject, ITriangleMeshPrimitive)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITriangleMeshPrimitive)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ITriangleMeshPrimitive, None)
    
    _get_wireframe_metadata = { "offset" : _get_wireframe_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def wireframe(self) -> bool:
        """Get or set whether the primitive is rendered in wireframe. This is useful for debugging."""
        return self._intf.get_property(ITriangleMeshPrimitive._metadata, ITriangleMeshPrimitive._get_wireframe_metadata)

    _set_wireframe_metadata = { "offset" : _set_wireframe_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @wireframe.setter
    def wireframe(self, wireframe:bool) -> None:
        return self._intf.set_property(ITriangleMeshPrimitive._metadata, ITriangleMeshPrimitive._set_wireframe_metadata, wireframe)

    _get_render_back_then_front_faces_metadata = { "offset" : _get_render_back_then_front_faces_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def render_back_then_front_faces(self) -> bool:
        """Get or set whether the primitive is rendered in two passes to improve the visual quality for translucent, convex meshes."""
        return self._intf.get_property(ITriangleMeshPrimitive._metadata, ITriangleMeshPrimitive._get_render_back_then_front_faces_metadata)

    _set_render_back_then_front_faces_metadata = { "offset" : _set_render_back_then_front_faces_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @render_back_then_front_faces.setter
    def render_back_then_front_faces(self, renderBackThenFrontFaces:bool) -> None:
        return self._intf.set_property(ITriangleMeshPrimitive._metadata, ITriangleMeshPrimitive._set_render_back_then_front_faces_metadata, renderBackThenFrontFaces)

    _get_lighting_metadata = { "offset" : _get_lighting_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def lighting(self) -> bool:
        """Get or set whether the primitive is lit."""
        return self._intf.get_property(ITriangleMeshPrimitive._metadata, ITriangleMeshPrimitive._get_lighting_metadata)

    _set_lighting_metadata = { "offset" : _set_lighting_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @lighting.setter
    def lighting(self, lighting:bool) -> None:
        return self._intf.set_property(ITriangleMeshPrimitive._metadata, ITriangleMeshPrimitive._set_lighting_metadata, lighting)

    _get_triangle_winding_order_metadata = { "offset" : _get_triangle_winding_order_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(WINDING_ORDER),) }
    @property
    def triangle_winding_order(self) -> "WINDING_ORDER":
        """Get or set the orientation of front-facing triangles. This is used in combination with cull face for culling."""
        return self._intf.get_property(ITriangleMeshPrimitive._metadata, ITriangleMeshPrimitive._get_triangle_winding_order_metadata)

    _set_triangle_winding_order_metadata = { "offset" : _set_triangle_winding_order_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(WINDING_ORDER),) }
    @triangle_winding_order.setter
    def triangle_winding_order(self, triangleWindingOrder:"WINDING_ORDER") -> None:
        return self._intf.set_property(ITriangleMeshPrimitive._metadata, ITriangleMeshPrimitive._set_triangle_winding_order_metadata, triangleWindingOrder)

    _get_cull_face_metadata = { "offset" : _get_cull_face_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(CULL_FACE),) }
    @property
    def cull_face(self) -> "CULL_FACE":
        """Get or set whether front and/or back-facing triangles may be culled. This is used in combination with triangle winding order for culling."""
        return self._intf.get_property(ITriangleMeshPrimitive._metadata, ITriangleMeshPrimitive._get_cull_face_metadata)

    _set_cull_face_metadata = { "offset" : _set_cull_face_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(CULL_FACE),) }
    @cull_face.setter
    def cull_face(self, cullFace:"CULL_FACE") -> None:
        return self._intf.set_property(ITriangleMeshPrimitive._metadata, ITriangleMeshPrimitive._set_cull_face_metadata, cullFace)

    _get_shade_model_metadata = { "offset" : _get_shade_model_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(RENDERER_SHADE_MODEL),) }
    @property
    def shade_model(self) -> "RENDERER_SHADE_MODEL":
        """Get or set the shading model for the mesh."""
        return self._intf.get_property(ITriangleMeshPrimitive._metadata, ITriangleMeshPrimitive._get_shade_model_metadata)

    _set_shade_model_metadata = { "offset" : _set_shade_model_method_offset,
            "arg_types" : (agcom.LONG,),
            "marshallers" : (agmarshall.EnumArg(RENDERER_SHADE_MODEL),) }
    @shade_model.setter
    def shade_model(self, shadeModel:"RENDERER_SHADE_MODEL") -> None:
        return self._intf.set_property(ITriangleMeshPrimitive._metadata, ITriangleMeshPrimitive._set_shade_model_metadata, shadeModel)

    _get_texture_metadata = { "offset" : _get_texture_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def texture(self) -> "RendererTexture2D":
        """Get or set the texture to be drawn on the triangle mesh. Textures can be obtained from textures."""
        return self._intf.get_property(ITriangleMeshPrimitive._metadata, ITriangleMeshPrimitive._get_texture_metadata)

    _set_texture_metadata = { "offset" : _set_texture_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("IRendererTexture2D"),) }
    @texture.setter
    def texture(self, texture:"IRendererTexture2D") -> None:
        return self._intf.set_property(ITriangleMeshPrimitive._metadata, ITriangleMeshPrimitive._set_texture_metadata, texture)

    _get_texture_filter_metadata = { "offset" : _get_texture_filter_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def texture_filter(self) -> "TextureFilter2D":
        """Get or set the filter used for the texture associated with this triangle mesh."""
        return self._intf.get_property(ITriangleMeshPrimitive._metadata, ITriangleMeshPrimitive._get_texture_filter_metadata)

    _set_texture_filter_metadata = { "offset" : _set_texture_filter_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITextureFilter2D"),) }
    @texture_filter.setter
    def texture_filter(self, textureFilter:"ITextureFilter2D") -> None:
        return self._intf.set_property(ITriangleMeshPrimitive._metadata, ITriangleMeshPrimitive._set_texture_filter_metadata, textureFilter)

    _get_set_hint_metadata = { "offset" : _get_set_hint_method_offset,
            "arg_types" : (POINTER(agcom.LONG),),
            "marshallers" : (agmarshall.EnumArg(SET_HINT),) }
    @property
    def set_hint(self) -> "SET_HINT":
        """Get the primitive's set hint. See the Set Hint Performance Overview for selecting an appropriate value to construct the primitive with."""
        return self._intf.get_property(ITriangleMeshPrimitive._metadata, ITriangleMeshPrimitive._get_set_hint_metadata)

    _set_metadata = { "offset" : _set_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg,) }
    def set(self, positions:list, normals:list, indices:list) -> None:
        """Define the triangle mesh using an indexed triangle list specified by positions, normals, and indices. The mesh is rendered in the primitive's reference frame."""
        return self._intf.invoke(ITriangleMeshPrimitive._metadata, ITriangleMeshPrimitive._set_metadata, positions, normals, indices)

    _set_with_optional_parameters_metadata = { "offset" : _set_with_optional_parameters_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), agcom.PVOID,),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.InterfaceInArg("ITriangleMeshPrimitiveOptionalParameters"),) }
    def set_with_optional_parameters(self, positions:list, normals:list, indices:list, optionalParameters:"ITriangleMeshPrimitiveOptionalParameters") -> None:
        """Define the triangle mesh using an indexed triangle list specified by positions, normals, indices, and optionalParameters. The mesh is rendered in the primitive's reference frame."""
        return self._intf.invoke(ITriangleMeshPrimitive._metadata, ITriangleMeshPrimitive._set_with_optional_parameters_metadata, positions, normals, indices, optionalParameters)

    _set_triangulator_metadata = { "offset" : _set_triangulator_method_offset,
            "arg_types" : (agcom.PVOID,),
            "marshallers" : (agmarshall.InterfaceInArg("ITriangulatorResult"),) }
    def set_triangulator(self, triangulator:"ITriangulatorResult") -> None:
        """Define the triangle mesh using the specified triangulator. The mesh is rendered in the primitive's reference frame."""
        return self._intf.invoke(ITriangleMeshPrimitive._metadata, ITriangleMeshPrimitive._set_triangulator_metadata, triangulator)

    _get_central_body_clipped_metadata = { "offset" : _get_central_body_clipped_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def central_body_clipped(self) -> bool:
        """Get or set whether individual points will be clipped by the central body."""
        return self._intf.get_property(ITriangleMeshPrimitive._metadata, ITriangleMeshPrimitive._get_central_body_clipped_metadata)

    _set_central_body_clipped_metadata = { "offset" : _set_central_body_clipped_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @central_body_clipped.setter
    def central_body_clipped(self, centralBodyClipped:bool) -> None:
        return self._intf.set_property(ITriangleMeshPrimitive._metadata, ITriangleMeshPrimitive._set_central_body_clipped_metadata, centralBodyClipped)

    _get_two_sided_lighting_metadata = { "offset" : _get_two_sided_lighting_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def two_sided_lighting(self) -> bool:
        """Get or set whether the primitive's translucent geometry will be lit from both sides of the surface."""
        return self._intf.get_property(ITriangleMeshPrimitive._metadata, ITriangleMeshPrimitive._get_two_sided_lighting_metadata)

    _set_two_sided_lighting_metadata = { "offset" : _set_two_sided_lighting_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @two_sided_lighting.setter
    def two_sided_lighting(self, twoSidedLighting:bool) -> None:
        return self._intf.set_property(ITriangleMeshPrimitive._metadata, ITriangleMeshPrimitive._set_two_sided_lighting_metadata, twoSidedLighting)

    _property_names[wireframe] = "wireframe"
    _property_names[render_back_then_front_faces] = "render_back_then_front_faces"
    _property_names[lighting] = "lighting"
    _property_names[triangle_winding_order] = "triangle_winding_order"
    _property_names[cull_face] = "cull_face"
    _property_names[shade_model] = "shade_model"
    _property_names[texture] = "texture"
    _property_names[texture_filter] = "texture_filter"
    _property_names[set_hint] = "set_hint"
    _property_names[central_body_clipped] = "central_body_clipped"
    _property_names[two_sided_lighting] = "two_sided_lighting"


agcls.AgClassCatalog.add_catalog_entry((4930896001075044620, 5765055608652741256), ITriangleMeshPrimitive)
agcls.AgTypeNameMap["ITriangleMeshPrimitive"] = ITriangleMeshPrimitive

class ITriangleMeshPrimitiveOptionalParameters(object):
    """Optional parameters for triangle mesh primitive..."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _set_texture_coordinates_method_offset = 1
    _set_per_vertex_colors_method_offset = 2
    _metadata = {
        "iid_data" : (5744141379087050252, 10667431286663539871),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ITriangleMeshPrimitiveOptionalParameters."""
        initialize_from_source_object(self, sourceObject, ITriangleMeshPrimitiveOptionalParameters)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITriangleMeshPrimitiveOptionalParameters)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ITriangleMeshPrimitiveOptionalParameters, None)
    
    _set_texture_coordinates_metadata = { "offset" : _set_texture_coordinates_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    def set_texture_coordinates(self, textureCoordinates:list) -> None:
        """Define a collection of texture coordinates."""
        return self._intf.invoke(ITriangleMeshPrimitiveOptionalParameters._metadata, ITriangleMeshPrimitiveOptionalParameters._set_texture_coordinates_metadata, textureCoordinates)

    _set_per_vertex_colors_metadata = { "offset" : _set_per_vertex_colors_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY),),
            "marshallers" : (agmarshall.LPSafearrayArg,) }
    def set_per_vertex_colors(self, colors:list) -> None:
        """Define a collection of colors."""
        return self._intf.invoke(ITriangleMeshPrimitiveOptionalParameters._metadata, ITriangleMeshPrimitiveOptionalParameters._set_per_vertex_colors_metadata, colors)


agcls.AgClassCatalog.add_catalog_entry((5744141379087050252, 10667431286663539871), ITriangleMeshPrimitiveOptionalParameters)
agcls.AgTypeNameMap["ITriangleMeshPrimitiveOptionalParameters"] = ITriangleMeshPrimitiveOptionalParameters

class IVectorPrimitive(object):
    """Render a vector in the 3D scene. A vector is defined by a source (given by a reference frame) and a direction (given by a vector). Length is auto-calculated or can be set separately."""

    _num_methods = 28
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_lighting_method_offset = 1
    _set_lighting_method_offset = 2
    _get_label_method_offset = 3
    _set_label_method_offset = 4
    _get_display_label_method_offset = 5
    _set_display_label_method_offset = 6
    _get_display_magnitude_method_offset = 7
    _set_display_magnitude_method_offset = 8
    _get_display_ra_dec_method_offset = 9
    _set_display_ra_dec_method_offset = 10
    _get_display_trace_method_offset = 11
    _set_display_trace_method_offset = 12
    _get_display_sweep_method_offset = 13
    _set_display_sweep_method_offset = 14
    _get_display_lines_method_offset = 15
    _set_display_lines_method_offset = 16
    _get_persistence_width_method_offset = 17
    _set_persistence_width_method_offset = 18
    _get_fade_persistence_method_offset = 19
    _set_fade_persistence_method_offset = 20
    _get_persistence_duration_method_offset = 21
    _set_persistence_duration_method_offset = 22
    _get_length_method_offset = 23
    _set_length_method_offset = 24
    _get_width_method_offset = 25
    _set_width_method_offset = 26
    _get_true_scale_method_offset = 27
    _set_true_scale_method_offset = 28
    _metadata = {
        "iid_data" : (4658995849882559354, 1999010046770893973),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IVectorPrimitive."""
        initialize_from_source_object(self, sourceObject, IVectorPrimitive)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorPrimitive)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IVectorPrimitive, None)
    
    _get_lighting_metadata = { "offset" : _get_lighting_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def lighting(self) -> bool:
        """Get or set whether the primitive is lit."""
        return self._intf.get_property(IVectorPrimitive._metadata, IVectorPrimitive._get_lighting_metadata)

    _set_lighting_metadata = { "offset" : _set_lighting_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @lighting.setter
    def lighting(self, lighting:bool) -> None:
        return self._intf.set_property(IVectorPrimitive._metadata, IVectorPrimitive._set_lighting_metadata, lighting)

    _get_label_metadata = { "offset" : _get_label_method_offset,
            "arg_types" : (POINTER(agcom.BSTR),),
            "marshallers" : (agmarshall.BStrArg,) }
    @property
    def label(self) -> str:
        """Get or set the user-defined label."""
        return self._intf.get_property(IVectorPrimitive._metadata, IVectorPrimitive._get_label_metadata)

    _set_label_metadata = { "offset" : _set_label_method_offset,
            "arg_types" : (agcom.BSTR,),
            "marshallers" : (agmarshall.BStrArg,) }
    @label.setter
    def label(self, label:str) -> None:
        return self._intf.set_property(IVectorPrimitive._metadata, IVectorPrimitive._set_label_metadata, label)

    _get_display_label_metadata = { "offset" : _get_display_label_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def display_label(self) -> bool:
        """Get or set whether the vector's label is displayed."""
        return self._intf.get_property(IVectorPrimitive._metadata, IVectorPrimitive._get_display_label_metadata)

    _set_display_label_metadata = { "offset" : _set_display_label_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @display_label.setter
    def display_label(self, displayLabel:bool) -> None:
        return self._intf.set_property(IVectorPrimitive._metadata, IVectorPrimitive._set_display_label_metadata, displayLabel)

    _get_display_magnitude_metadata = { "offset" : _get_display_magnitude_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def display_magnitude(self) -> bool:
        """Get or set whether the vector's magnitude is displayed."""
        return self._intf.get_property(IVectorPrimitive._metadata, IVectorPrimitive._get_display_magnitude_metadata)

    _set_display_magnitude_metadata = { "offset" : _set_display_magnitude_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @display_magnitude.setter
    def display_magnitude(self, displayMagnitude:bool) -> None:
        return self._intf.set_property(IVectorPrimitive._metadata, IVectorPrimitive._set_display_magnitude_metadata, displayMagnitude)

    _get_display_ra_dec_metadata = { "offset" : _get_display_ra_dec_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def display_ra_dec(self) -> bool:
        """Get or set whether the vector's RA-Dec is displayed."""
        return self._intf.get_property(IVectorPrimitive._metadata, IVectorPrimitive._get_display_ra_dec_metadata)

    _set_display_ra_dec_metadata = { "offset" : _set_display_ra_dec_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @display_ra_dec.setter
    def display_ra_dec(self, displayRADec:bool) -> None:
        return self._intf.set_property(IVectorPrimitive._metadata, IVectorPrimitive._set_display_ra_dec_metadata, displayRADec)

    _get_display_trace_metadata = { "offset" : _get_display_trace_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def display_trace(self) -> bool:
        """Get or set whether the persistence trace (points) is displayed."""
        return self._intf.get_property(IVectorPrimitive._metadata, IVectorPrimitive._get_display_trace_metadata)

    _set_display_trace_metadata = { "offset" : _set_display_trace_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @display_trace.setter
    def display_trace(self, displayTrace:bool) -> None:
        return self._intf.set_property(IVectorPrimitive._metadata, IVectorPrimitive._set_display_trace_metadata, displayTrace)

    _get_display_sweep_metadata = { "offset" : _get_display_sweep_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def display_sweep(self) -> bool:
        """Get or set whether the persistence sweep (triangles) is displayed."""
        return self._intf.get_property(IVectorPrimitive._metadata, IVectorPrimitive._get_display_sweep_metadata)

    _set_display_sweep_metadata = { "offset" : _set_display_sweep_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @display_sweep.setter
    def display_sweep(self, displaySweep:bool) -> None:
        return self._intf.set_property(IVectorPrimitive._metadata, IVectorPrimitive._set_display_sweep_metadata, displaySweep)

    _get_display_lines_metadata = { "offset" : _get_display_lines_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def display_lines(self) -> bool:
        """Get or set whether persistence lines are displayed."""
        return self._intf.get_property(IVectorPrimitive._metadata, IVectorPrimitive._get_display_lines_metadata)

    _set_display_lines_metadata = { "offset" : _set_display_lines_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @display_lines.setter
    def display_lines(self, displayLines:bool) -> None:
        return self._intf.set_property(IVectorPrimitive._metadata, IVectorPrimitive._set_display_lines_metadata, displayLines)

    _get_persistence_width_metadata = { "offset" : _get_persistence_width_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def persistence_width(self) -> float:
        """Get or set persistence point/line width."""
        return self._intf.get_property(IVectorPrimitive._metadata, IVectorPrimitive._get_persistence_width_metadata)

    _set_persistence_width_metadata = { "offset" : _set_persistence_width_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @persistence_width.setter
    def persistence_width(self, persistenceWidth:float) -> None:
        return self._intf.set_property(IVectorPrimitive._metadata, IVectorPrimitive._set_persistence_width_metadata, persistenceWidth)

    _get_fade_persistence_metadata = { "offset" : _get_fade_persistence_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def fade_persistence(self) -> bool:
        """Get or set whether the persistence path should fade over time."""
        return self._intf.get_property(IVectorPrimitive._metadata, IVectorPrimitive._get_fade_persistence_metadata)

    _set_fade_persistence_metadata = { "offset" : _set_fade_persistence_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @fade_persistence.setter
    def fade_persistence(self, fadePersistence:bool) -> None:
        return self._intf.set_property(IVectorPrimitive._metadata, IVectorPrimitive._set_fade_persistence_metadata, fadePersistence)

    _get_persistence_duration_metadata = { "offset" : _get_persistence_duration_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def persistence_duration(self) -> float:
        """Get or set the maximum duration of the persistence path."""
        return self._intf.get_property(IVectorPrimitive._metadata, IVectorPrimitive._get_persistence_duration_metadata)

    _set_persistence_duration_metadata = { "offset" : _set_persistence_duration_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @persistence_duration.setter
    def persistence_duration(self, persistenceDuration:float) -> None:
        return self._intf.set_property(IVectorPrimitive._metadata, IVectorPrimitive._set_persistence_duration_metadata, persistenceDuration)

    _get_length_metadata = { "offset" : _get_length_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def length(self) -> float:
        """Get or set the vector's source-to-arrow-tip length."""
        return self._intf.get_property(IVectorPrimitive._metadata, IVectorPrimitive._get_length_metadata)

    _set_length_metadata = { "offset" : _set_length_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @length.setter
    def length(self, length:float) -> None:
        return self._intf.set_property(IVectorPrimitive._metadata, IVectorPrimitive._set_length_metadata, length)

    _get_width_metadata = { "offset" : _get_width_method_offset,
            "arg_types" : (POINTER(agcom.DOUBLE),),
            "marshallers" : (agmarshall.DoubleArg,) }
    @property
    def width(self) -> float:
        """Get or set the vector's width in pixels. As the camera distances changes from this primitive, the geometry will autoscale to maintain this thickness."""
        return self._intf.get_property(IVectorPrimitive._metadata, IVectorPrimitive._get_width_metadata)

    _set_width_metadata = { "offset" : _set_width_method_offset,
            "arg_types" : (agcom.DOUBLE,),
            "marshallers" : (agmarshall.DoubleArg,) }
    @width.setter
    def width(self, width:float) -> None:
        return self._intf.set_property(IVectorPrimitive._metadata, IVectorPrimitive._set_width_metadata, width)

    _get_true_scale_metadata = { "offset" : _get_true_scale_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def true_scale(self) -> bool:
        """Get or set whether vector's 'true scale' length (based on how the primitive was created) should be used."""
        return self._intf.get_property(IVectorPrimitive._metadata, IVectorPrimitive._get_true_scale_metadata)

    _set_true_scale_metadata = { "offset" : _set_true_scale_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @true_scale.setter
    def true_scale(self, trueScale:bool) -> None:
        return self._intf.set_property(IVectorPrimitive._metadata, IVectorPrimitive._set_true_scale_metadata, trueScale)

    _property_names[lighting] = "lighting"
    _property_names[label] = "label"
    _property_names[display_label] = "display_label"
    _property_names[display_magnitude] = "display_magnitude"
    _property_names[display_ra_dec] = "display_ra_dec"
    _property_names[display_trace] = "display_trace"
    _property_names[display_sweep] = "display_sweep"
    _property_names[display_lines] = "display_lines"
    _property_names[persistence_width] = "persistence_width"
    _property_names[fade_persistence] = "fade_persistence"
    _property_names[persistence_duration] = "persistence_duration"
    _property_names[length] = "length"
    _property_names[width] = "width"
    _property_names[true_scale] = "true_scale"


agcls.AgClassCatalog.add_catalog_entry((4658995849882559354, 1999010046770893973), IVectorPrimitive)
agcls.AgTypeNameMap["IVectorPrimitive"] = IVectorPrimitive

class IBoxTriangulatorInitializer(object):
    """Triangulates a box. It is recommended to visualize the box using a solid primitive. Although, if only the fill is desired for visualization, a triangle mesh primitive with render back then front faces set to true can be used..."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _compute_method_offset = 1
    _metadata = {
        "iid_data" : (5690821360306739769, 9619943843730065845),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IBoxTriangulatorInitializer."""
        initialize_from_source_object(self, sourceObject, IBoxTriangulatorInitializer)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IBoxTriangulatorInitializer)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IBoxTriangulatorInitializer, None)
    
    _compute_metadata = { "offset" : _compute_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.InterfaceOutArg,) }
    def compute(self, size:list) -> "SolidTriangulatorResult":
        """Compute the triangulation for a box of the specified size, centered at the origin."""
        return self._intf.invoke(IBoxTriangulatorInitializer._metadata, IBoxTriangulatorInitializer._compute_metadata, size, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5690821360306739769, 9619943843730065845), IBoxTriangulatorInitializer)
agcls.AgTypeNameMap["IBoxTriangulatorInitializer"] = IBoxTriangulatorInitializer

class ICylinderTriangulatorInitializer(object):
    """Triangulates a cylinder. It is recommended to visualize the cylinder using a solid primitive. Although, if only the fill is desired for visualization, a triangle mesh primitive with render back then front faces set to true can be used..."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _create_simple_method_offset = 1
    _compute_method_offset = 2
    _metadata = {
        "iid_data" : (4649911832653977907, 3424006471173769868),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ICylinderTriangulatorInitializer."""
        initialize_from_source_object(self, sourceObject, ICylinderTriangulatorInitializer)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICylinderTriangulatorInitializer)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ICylinderTriangulatorInitializer, None)
    
    _create_simple_metadata = { "offset" : _create_simple_method_offset,
            "arg_types" : (agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def create_simple(self, length:float, radius:float) -> "SolidTriangulatorResult":
        """Compute the triangulation for a cylinder centered at the origin."""
        return self._intf.invoke(ICylinderTriangulatorInitializer._metadata, ICylinderTriangulatorInitializer._create_simple_metadata, length, radius, OutArg())

    _compute_metadata = { "offset" : _compute_method_offset,
            "arg_types" : (agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.INT, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.IntArg, agmarshall.EnumArg(CYLINDER_FILL), agmarshall.InterfaceOutArg,) }
    def compute(self, length:float, bottomRadius:float, topRadius:float, slices:int, cylinderFill:"CYLINDER_FILL") -> "SolidTriangulatorResult":
        """Compute the triangulation for a cylinder centered at the origin."""
        return self._intf.invoke(ICylinderTriangulatorInitializer._metadata, ICylinderTriangulatorInitializer._compute_metadata, length, bottomRadius, topRadius, slices, cylinderFill, OutArg())


agcls.AgClassCatalog.add_catalog_entry((4649911832653977907, 3424006471173769868), ICylinderTriangulatorInitializer)
agcls.AgTypeNameMap["ICylinderTriangulatorInitializer"] = ICylinderTriangulatorInitializer

class IEllipsoidTriangulatorInitializer(object):
    """Triangulates an ellipsoid. It is recommended to visualize the ellipsoid using a solid primitive. Although, if only the fill is desired for visualization, a triangle mesh primitive with render back then front faces set to true can be used..."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _compute_simple_method_offset = 1
    _compute_method_offset = 2
    _metadata = {
        "iid_data" : (4837395829315606331, 4553965937725582510),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IEllipsoidTriangulatorInitializer."""
        initialize_from_source_object(self, sourceObject, IEllipsoidTriangulatorInitializer)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IEllipsoidTriangulatorInitializer)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IEllipsoidTriangulatorInitializer, None)
    
    _compute_simple_metadata = { "offset" : _compute_simple_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.InterfaceOutArg,) }
    def compute_simple(self, radii:list) -> "SolidTriangulatorResult":
        """Compute the triangulation for an ellipsoid with the specified radii, centered at the origin, using 32 slices and 16 stacks."""
        return self._intf.invoke(IEllipsoidTriangulatorInitializer._metadata, IEllipsoidTriangulatorInitializer._compute_simple_metadata, radii, OutArg())

    _compute_metadata = { "offset" : _compute_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), agcom.INT, agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.IntArg, agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def compute(self, radii:list, slices:int, stacks:int) -> "SolidTriangulatorResult":
        """Compute the triangulation for an ellipsoid with the specified radii, centered at the origin."""
        return self._intf.invoke(IEllipsoidTriangulatorInitializer._metadata, IEllipsoidTriangulatorInitializer._compute_metadata, radii, slices, stacks, OutArg())


agcls.AgClassCatalog.add_catalog_entry((4837395829315606331, 4553965937725582510), IEllipsoidTriangulatorInitializer)
agcls.AgTypeNameMap["IEllipsoidTriangulatorInitializer"] = IEllipsoidTriangulatorInitializer

class IExtrudedPolylineTriangulatorInitializer(object):
    """Triangulates a polyline into an extrusion with bottom and top boundaries."""

    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _compute_method_offset = 1
    _compute_with_winding_order_method_offset = 2
    _compute_cartographic_method_offset = 3
    _compute_cartographic_with_winding_order_method_offset = 4
    _compute_with_altitudes_method_offset = 5
    _compute_with_altitudes_and_winding_order_method_offset = 6
    _compute_cartographic_with_altitudes_method_offset = 7
    _compute_cartographic_with_altitudes_and_winding_order_method_offset = 8
    _compute_single_constant_altitude_method_offset = 9
    _compute_single_constant_altitude_with_winding_order_method_offset = 10
    _compute_single_constant_altitude_cartographic_method_offset = 11
    _compute_single_constant_altitude_cartographic_with_winding_order_method_offset = 12
    _metadata = {
        "iid_data" : (5435294031120144776, 3912460079273570441),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IExtrudedPolylineTriangulatorInitializer."""
        initialize_from_source_object(self, sourceObject, IExtrudedPolylineTriangulatorInitializer)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IExtrudedPolylineTriangulatorInitializer)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IExtrudedPolylineTriangulatorInitializer, None)
    
    _compute_metadata = { "offset" : _compute_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.InterfaceOutArg,) }
    def compute(self, centralBody:str, bottomPositions:list, topPositions:list) -> "ExtrudedPolylineTriangulatorResult":
        """Compute an extrusion between bottomPositions and topPositions on the specified centralBody. This is equivalent to calling Compute with a positionsWindingOrder of compute."""
        return self._intf.invoke(IExtrudedPolylineTriangulatorInitializer._metadata, IExtrudedPolylineTriangulatorInitializer._compute_metadata, centralBody, bottomPositions, topPositions, OutArg())

    _compute_with_winding_order_metadata = { "offset" : _compute_with_winding_order_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.EnumArg(WINDING_ORDER), agmarshall.InterfaceOutArg,) }
    def compute_with_winding_order(self, centralBody:str, bottomPositions:list, topPositions:list, positionsWindingOrder:"WINDING_ORDER") -> "ExtrudedPolylineTriangulatorResult":
        """Compute an extrusion between bottomPositions and topPositions on the specified centralBody."""
        return self._intf.invoke(IExtrudedPolylineTriangulatorInitializer._metadata, IExtrudedPolylineTriangulatorInitializer._compute_with_winding_order_metadata, centralBody, bottomPositions, topPositions, positionsWindingOrder, OutArg())

    _compute_cartographic_metadata = { "offset" : _compute_cartographic_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.InterfaceOutArg,) }
    def compute_cartographic(self, centralBody:str, bottomPositions:list, topPositions:list) -> "ExtrudedPolylineTriangulatorResult":
        """For convenience. Computes an extrusion between bottomPositions and topPositions on the specified centralBody using cartographic positions. This is equivalent to converting each position in bottomPositions and topPositions to cartesian and calling Compute."""
        return self._intf.invoke(IExtrudedPolylineTriangulatorInitializer._metadata, IExtrudedPolylineTriangulatorInitializer._compute_cartographic_metadata, centralBody, bottomPositions, topPositions, OutArg())

    _compute_cartographic_with_winding_order_metadata = { "offset" : _compute_cartographic_with_winding_order_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.EnumArg(WINDING_ORDER), agmarshall.InterfaceOutArg,) }
    def compute_cartographic_with_winding_order(self, centralBody:str, bottomPositions:list, topPositions:list, positionsWindingOrder:"WINDING_ORDER") -> "ExtrudedPolylineTriangulatorResult":
        """For convenience. Computes an extrusion between bottomPositions and topPositions on the specified centralBody using cartographic positions. This is equivalent to converting each position in bottomPositions and topPositions to cartesian and calling Compute."""
        return self._intf.invoke(IExtrudedPolylineTriangulatorInitializer._metadata, IExtrudedPolylineTriangulatorInitializer._compute_cartographic_with_winding_order_metadata, centralBody, bottomPositions, topPositions, positionsWindingOrder, OutArg())

    _compute_with_altitudes_metadata = { "offset" : _compute_with_altitudes_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def compute_with_altitudes(self, centralBody:str, positions:list, bottomAltitude:float, topAltitude:float) -> "ExtrudedPolylineTriangulatorResult":
        """Compute an extrusion of positions on the specified centralBody with a constant bottomAltitude and topAltitude. This is equivalent to calling Compute with a positionsWindingOrder of compute."""
        return self._intf.invoke(IExtrudedPolylineTriangulatorInitializer._metadata, IExtrudedPolylineTriangulatorInitializer._compute_with_altitudes_metadata, centralBody, positions, bottomAltitude, topAltitude, OutArg())

    _compute_with_altitudes_and_winding_order_metadata = { "offset" : _compute_with_altitudes_and_winding_order_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.EnumArg(WINDING_ORDER), agmarshall.InterfaceOutArg,) }
    def compute_with_altitudes_and_winding_order(self, centralBody:str, positions:list, bottomAltitude:float, topAltitude:float, positionsWindingOrder:"WINDING_ORDER") -> "ExtrudedPolylineTriangulatorResult":
        """Compute an extrusion of positions on the specified centralBody with a constant bottomAltitude and topAltitude."""
        return self._intf.invoke(IExtrudedPolylineTriangulatorInitializer._metadata, IExtrudedPolylineTriangulatorInitializer._compute_with_altitudes_and_winding_order_metadata, centralBody, positions, bottomAltitude, topAltitude, positionsWindingOrder, OutArg())

    _compute_cartographic_with_altitudes_metadata = { "offset" : _compute_cartographic_with_altitudes_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def compute_cartographic_with_altitudes(self, centralBody:str, positions:list, bottomAltitude:float, topAltitude:float) -> "ExtrudedPolylineTriangulatorResult":
        """For convenience. Computes an extrusion of positions on the specified centralBody with a constant bottomAltitude and topAltitude using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling Compute."""
        return self._intf.invoke(IExtrudedPolylineTriangulatorInitializer._metadata, IExtrudedPolylineTriangulatorInitializer._compute_cartographic_with_altitudes_metadata, centralBody, positions, bottomAltitude, topAltitude, OutArg())

    _compute_cartographic_with_altitudes_and_winding_order_metadata = { "offset" : _compute_cartographic_with_altitudes_and_winding_order_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.EnumArg(WINDING_ORDER), agmarshall.InterfaceOutArg,) }
    def compute_cartographic_with_altitudes_and_winding_order(self, centralBody:str, positions:list, bottomAltitude:float, topAltitude:float, positionsWindingOrder:"WINDING_ORDER") -> "ExtrudedPolylineTriangulatorResult":
        """For convenience. Computes an extrusion of positions on the specified centralBody with a constant bottomAltitude and topAltitude using cartographic positions. This is equivalent to converting each position in positions to cartesian and calling Compute."""
        return self._intf.invoke(IExtrudedPolylineTriangulatorInitializer._metadata, IExtrudedPolylineTriangulatorInitializer._compute_cartographic_with_altitudes_and_winding_order_metadata, centralBody, positions, bottomAltitude, topAltitude, positionsWindingOrder, OutArg())

    _compute_single_constant_altitude_metadata = { "offset" : _compute_single_constant_altitude_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def compute_single_constant_altitude(self, centralBody:str, positions:list, altitude:float) -> "ExtrudedPolylineTriangulatorResult":
        """Compute an extrusion of positions on the specified centralBody. One side of the extrusion has a constant altitude and the other has the original altitudes from positions..."""
        return self._intf.invoke(IExtrudedPolylineTriangulatorInitializer._metadata, IExtrudedPolylineTriangulatorInitializer._compute_single_constant_altitude_metadata, centralBody, positions, altitude, OutArg())

    _compute_single_constant_altitude_with_winding_order_metadata = { "offset" : _compute_single_constant_altitude_with_winding_order_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), agcom.DOUBLE, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.DoubleArg, agmarshall.EnumArg(WINDING_ORDER), agmarshall.InterfaceOutArg,) }
    def compute_single_constant_altitude_with_winding_order(self, centralBody:str, positions:list, altitude:float, positionsWindingOrder:"WINDING_ORDER") -> "ExtrudedPolylineTriangulatorResult":
        """Compute an extrusion of positions on the specified centralBody. One side of the extrusion has a constant altitude and the other has the original altitudes from positions."""
        return self._intf.invoke(IExtrudedPolylineTriangulatorInitializer._metadata, IExtrudedPolylineTriangulatorInitializer._compute_single_constant_altitude_with_winding_order_metadata, centralBody, positions, altitude, positionsWindingOrder, OutArg())

    _compute_single_constant_altitude_cartographic_metadata = { "offset" : _compute_single_constant_altitude_cartographic_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def compute_single_constant_altitude_cartographic(self, centralBody:str, positions:list, altitude:float) -> "ExtrudedPolylineTriangulatorResult":
        """For convenience. Computes an extrusion of positions on the specified centralBody using cartographic positions. One side of the extrusion has a constant altitude and the other has the original altitudes from positions..."""
        return self._intf.invoke(IExtrudedPolylineTriangulatorInitializer._metadata, IExtrudedPolylineTriangulatorInitializer._compute_single_constant_altitude_cartographic_metadata, centralBody, positions, altitude, OutArg())

    _compute_single_constant_altitude_cartographic_with_winding_order_metadata = { "offset" : _compute_single_constant_altitude_cartographic_with_winding_order_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), agcom.DOUBLE, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.DoubleArg, agmarshall.EnumArg(WINDING_ORDER), agmarshall.InterfaceOutArg,) }
    def compute_single_constant_altitude_cartographic_with_winding_order(self, centralBody:str, positions:list, altitude:float, positionsWindingOrder:"WINDING_ORDER") -> "ExtrudedPolylineTriangulatorResult":
        """For convenience. Computes an extrusion of positions on the specified centralBody using cartographic positions. One side of the extrusion has a constant altitude and the other has the original altitudes from positions..."""
        return self._intf.invoke(IExtrudedPolylineTriangulatorInitializer._metadata, IExtrudedPolylineTriangulatorInitializer._compute_single_constant_altitude_cartographic_with_winding_order_metadata, centralBody, positions, altitude, positionsWindingOrder, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5435294031120144776, 3912460079273570441), IExtrudedPolylineTriangulatorInitializer)
agcls.AgTypeNameMap["IExtrudedPolylineTriangulatorInitializer"] = IExtrudedPolylineTriangulatorInitializer

class ISurfaceExtentTriangulatorInitializer(object):
    """Triangulates an extent on a central body into a triangle mesh and a surrounding boundary. The mesh is commonly visualized with the triangle mesh primitive or surface mesh primitive. The boundary is commonly visualized with the polyline primitive."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _compute_simple_method_offset = 1
    _compute_method_offset = 2
    _metadata = {
        "iid_data" : (5095454729831996961, 8857111166915906946),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ISurfaceExtentTriangulatorInitializer."""
        initialize_from_source_object(self, sourceObject, ISurfaceExtentTriangulatorInitializer)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISurfaceExtentTriangulatorInitializer)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ISurfaceExtentTriangulatorInitializer, None)
    
    _compute_simple_metadata = { "offset" : _compute_simple_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.InterfaceOutArg,) }
    def compute_simple(self, centralBody:str, extent:list) -> "SurfaceTriangulatorResult":
        """Compute a triangulation on the specified centralBody for the specified extent. This is equivalent to calling Compute with an altitude of 0 and a granularity of 1 degree."""
        return self._intf.invoke(ISurfaceExtentTriangulatorInitializer._metadata, ISurfaceExtentTriangulatorInitializer._compute_simple_metadata, centralBody, extent, OutArg())

    _compute_metadata = { "offset" : _compute_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def compute(self, centralBody:str, extent:list, altitude:float, granularity:float) -> "SurfaceTriangulatorResult":
        """Compute a triangulation on the specified centralBody for the specified extent."""
        return self._intf.invoke(ISurfaceExtentTriangulatorInitializer._metadata, ISurfaceExtentTriangulatorInitializer._compute_metadata, centralBody, extent, altitude, granularity, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5095454729831996961, 8857111166915906946), ISurfaceExtentTriangulatorInitializer)
agcls.AgTypeNameMap["ISurfaceExtentTriangulatorInitializer"] = ISurfaceExtentTriangulatorInitializer

class ISurfacePolygonTriangulatorInitializer(object):
    """Triangulates a polygon, with an optional hole, on a central body, into a triangle mesh and a surrounding boundary. The mesh is commonly visualized with the triangle mesh primitive or surface mesh primitive..."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _compute_method_offset = 1
    _compute_cartographic_method_offset = 2
    _compute_with_hole_method_offset = 3
    _compute_with_hole_altitude_and_granularity_method_offset = 4
    _compute_with_altitude_and_granularity_method_offset = 5
    _compute_cartographic_with_altitude_and_granularity_method_offset = 6
    _metadata = {
        "iid_data" : (4710549874836589706, 5267843994439665331),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ISurfacePolygonTriangulatorInitializer."""
        initialize_from_source_object(self, sourceObject, ISurfacePolygonTriangulatorInitializer)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISurfacePolygonTriangulatorInitializer)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ISurfacePolygonTriangulatorInitializer, None)
    
    _compute_metadata = { "offset" : _compute_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.InterfaceOutArg,) }
    def compute(self, centralBody:str, positions:list) -> "SurfaceTriangulatorResult":
        """Compute the triangulation on the specified centralBody for a polygon whose boundary is defined by the specified positions. This is equivalent to calling Compute with an altitude of 0, a granularity of 1 degree, and a positionsWindingOrder of compute."""
        return self._intf.invoke(ISurfacePolygonTriangulatorInitializer._metadata, ISurfacePolygonTriangulatorInitializer._compute_metadata, centralBody, positions, OutArg())

    _compute_cartographic_metadata = { "offset" : _compute_cartographic_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.InterfaceOutArg,) }
    def compute_cartographic(self, centralBody:str, positions:list) -> "SurfaceTriangulatorResult":
        """For convenience. Computes the triangulation on the specified centralBody for a polygon whose boundary is defined by the specified cartographic positions. This is equivalent to converting each position in positions to cartesian and calling Compute."""
        return self._intf.invoke(ISurfacePolygonTriangulatorInitializer._metadata, ISurfacePolygonTriangulatorInitializer._compute_cartographic_metadata, centralBody, positions, OutArg())

    _compute_with_hole_metadata = { "offset" : _compute_with_hole_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.InterfaceOutArg,) }
    def compute_with_hole(self, centralBody:str, positions:list, holePositions:list) -> "SurfaceTriangulatorResult":
        """Compute the triangulation on the specified centralBody for a polygon whose boundary is defined by the specified positions with a hole specified by holePositions. This is equivalent to calling Compute with an altitude of 0 and a granularity of 1 degree."""
        return self._intf.invoke(ISurfacePolygonTriangulatorInitializer._metadata, ISurfacePolygonTriangulatorInitializer._compute_with_hole_metadata, centralBody, positions, holePositions, OutArg())

    _compute_with_hole_altitude_and_granularity_metadata = { "offset" : _compute_with_hole_altitude_and_granularity_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def compute_with_hole_altitude_and_granularity(self, centralBody:str, positions:list, holePositions:list, altitude:float, granularity:float) -> "SurfaceTriangulatorResult":
        """Compute the triangulation on the specified centralBody for a polygon whose boundary is defined by the specified positions with a hole specified by holePositions."""
        return self._intf.invoke(ISurfacePolygonTriangulatorInitializer._metadata, ISurfacePolygonTriangulatorInitializer._compute_with_hole_altitude_and_granularity_metadata, centralBody, positions, holePositions, altitude, granularity, OutArg())

    _compute_with_altitude_and_granularity_metadata = { "offset" : _compute_with_altitude_and_granularity_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.EnumArg(WINDING_ORDER), agmarshall.InterfaceOutArg,) }
    def compute_with_altitude_and_granularity(self, centralBody:str, positions:list, altitude:float, granularity:float, positionsWindingOrder:"WINDING_ORDER") -> "SurfaceTriangulatorResult":
        """Compute the triangulation on the specified centralBody for a polygon whose boundary is defined by the specified positions."""
        return self._intf.invoke(ISurfacePolygonTriangulatorInitializer._metadata, ISurfacePolygonTriangulatorInitializer._compute_with_altitude_and_granularity_metadata, centralBody, positions, altitude, granularity, positionsWindingOrder, OutArg())

    _compute_cartographic_with_altitude_and_granularity_metadata = { "offset" : _compute_cartographic_with_altitude_and_granularity_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.EnumArg(WINDING_ORDER), agmarshall.InterfaceOutArg,) }
    def compute_cartographic_with_altitude_and_granularity(self, centralBody:str, positions:list, altitude:float, granularity:float, positionsWindingOrder:"WINDING_ORDER") -> "SurfaceTriangulatorResult":
        """For convenience. Computes the triangulation on the specified centralBody for a polygon whose boundary is defined by the specified cartographic positions. This is equivalent to converting each position in positions to cartesian and calling Compute."""
        return self._intf.invoke(ISurfacePolygonTriangulatorInitializer._metadata, ISurfacePolygonTriangulatorInitializer._compute_cartographic_with_altitude_and_granularity_metadata, centralBody, positions, altitude, granularity, positionsWindingOrder, OutArg())


agcls.AgClassCatalog.add_catalog_entry((4710549874836589706, 5267843994439665331), ISurfacePolygonTriangulatorInitializer)
agcls.AgTypeNameMap["ISurfacePolygonTriangulatorInitializer"] = ISurfacePolygonTriangulatorInitializer

class ISurfaceShapesInitializer(object):
    """Compute boundary positions for shapes on the surface such as circles, ellipses, and sectors."""

    _num_methods = 12
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _compute_circle_with_granularity_method_offset = 1
    _compute_circle_method_offset = 2
    _compute_circle_cartographic_with_granularity_method_offset = 3
    _compute_circle_cartographic_method_offset = 4
    _compute_ellipse_with_granularity_method_offset = 5
    _compute_ellipse_method_offset = 6
    _compute_ellipse_cartographic_with_granularity_method_offset = 7
    _compute_ellipse_cartographic_method_offset = 8
    _compute_sector_with_granularity_method_offset = 9
    _compute_sector_method_offset = 10
    _compute_sector_cartographic_with_granularity_method_offset = 11
    _compute_sector_cartographic_method_offset = 12
    _metadata = {
        "iid_data" : (5629653201892480912, 7351346316712711559),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ISurfaceShapesInitializer."""
        initialize_from_source_object(self, sourceObject, ISurfaceShapesInitializer)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISurfaceShapesInitializer)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ISurfaceShapesInitializer, None)
    
    _compute_circle_with_granularity_metadata = { "offset" : _compute_circle_with_granularity_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def compute_circle_with_granularity(self, centralBody:str, center:list, radius:float, granularity:float) -> "SurfaceShapesResult":
        """Compute boundary positions for a circle on the specified centralBody with the specified center, radius and granularity."""
        return self._intf.invoke(ISurfaceShapesInitializer._metadata, ISurfaceShapesInitializer._compute_circle_with_granularity_metadata, centralBody, center, radius, granularity, OutArg())

    _compute_circle_metadata = { "offset" : _compute_circle_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def compute_circle(self, centralBody:str, center:list, radius:float) -> "SurfaceShapesResult":
        """Compute boundary positions for a circle on the specified centralBody with the specified center and radius. This is equivalent to calling ComputeCircle with a granularity of 1 degree."""
        return self._intf.invoke(ISurfaceShapesInitializer._metadata, ISurfaceShapesInitializer._compute_circle_metadata, centralBody, center, radius, OutArg())

    _compute_circle_cartographic_with_granularity_metadata = { "offset" : _compute_circle_cartographic_with_granularity_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def compute_circle_cartographic_with_granularity(self, centralBody:str, center:list, radius:float, granularity:float) -> "SurfaceShapesResult":
        """For convenience. Computes boundary positions for a circle on the specified centralBody using a cartographic center. This is equivalent to converting center to cartesian and calling ComputeCircle."""
        return self._intf.invoke(ISurfaceShapesInitializer._metadata, ISurfaceShapesInitializer._compute_circle_cartographic_with_granularity_metadata, centralBody, center, radius, granularity, OutArg())

    _compute_circle_cartographic_metadata = { "offset" : _compute_circle_cartographic_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def compute_circle_cartographic(self, centralBody:str, center:list, radius:float) -> "SurfaceShapesResult":
        """For convenience. Computes boundary positions for a circle on the specified centralBody using a cartographic center. This is equivalent to converting center to cartesian and calling ComputeCircle."""
        return self._intf.invoke(ISurfaceShapesInitializer._metadata, ISurfaceShapesInitializer._compute_circle_cartographic_metadata, centralBody, center, radius, OutArg())

    _compute_ellipse_with_granularity_metadata = { "offset" : _compute_ellipse_with_granularity_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def compute_ellipse_with_granularity(self, centralBody:str, center:list, majorAxisRadius:float, minorAxisRadius:float, bearing:float, granularity:float) -> "SurfaceShapesResult":
        """Compute boundary positions for an ellipse on the specified centralBody."""
        return self._intf.invoke(ISurfaceShapesInitializer._metadata, ISurfaceShapesInitializer._compute_ellipse_with_granularity_metadata, centralBody, center, majorAxisRadius, minorAxisRadius, bearing, granularity, OutArg())

    _compute_ellipse_metadata = { "offset" : _compute_ellipse_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def compute_ellipse(self, centralBody:str, center:list, majorAxisRadius:float, minorAxisRadius:float, bearing:float) -> "SurfaceShapesResult":
        """Compute boundary positions for an ellipse on the specified centralBody. This is equivalent to calling ComputeEllipse with a granularity of 1 degree."""
        return self._intf.invoke(ISurfaceShapesInitializer._metadata, ISurfaceShapesInitializer._compute_ellipse_metadata, centralBody, center, majorAxisRadius, minorAxisRadius, bearing, OutArg())

    _compute_ellipse_cartographic_with_granularity_metadata = { "offset" : _compute_ellipse_cartographic_with_granularity_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def compute_ellipse_cartographic_with_granularity(self, centralBody:str, center:list, majorAxisRadius:float, minorAxisRadius:float, bearing:float, granularity:float) -> "SurfaceShapesResult":
        """For convenience. Computes boundary positions for an ellipse on the specified centralBody using a cartographic center. This is equivalent to converting center to cartesian and calling ComputeEllipse."""
        return self._intf.invoke(ISurfaceShapesInitializer._metadata, ISurfaceShapesInitializer._compute_ellipse_cartographic_with_granularity_metadata, centralBody, center, majorAxisRadius, minorAxisRadius, bearing, granularity, OutArg())

    _compute_ellipse_cartographic_metadata = { "offset" : _compute_ellipse_cartographic_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def compute_ellipse_cartographic(self, centralBody:str, center:list, majorAxisRadius:float, minorAxisRadius:float, bearing:float) -> "SurfaceShapesResult":
        """For convenience. Computes boundary positions for an ellipse on the specified centralBody using a cartographic center. This is equivalent to converting center to cartesian and calling ComputeEllipse."""
        return self._intf.invoke(ISurfaceShapesInitializer._metadata, ISurfaceShapesInitializer._compute_ellipse_cartographic_metadata, centralBody, center, majorAxisRadius, minorAxisRadius, bearing, OutArg())

    _compute_sector_with_granularity_metadata = { "offset" : _compute_sector_with_granularity_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def compute_sector_with_granularity(self, centralBody:str, center:list, innerRadius:float, outerRadius:float, startBearing:float, endBearing:float, granularity:float) -> "SurfaceShapesResult":
        """Compute boundary positions for a sector on the specified centralBody."""
        return self._intf.invoke(ISurfaceShapesInitializer._metadata, ISurfaceShapesInitializer._compute_sector_with_granularity_metadata, centralBody, center, innerRadius, outerRadius, startBearing, endBearing, granularity, OutArg())

    _compute_sector_metadata = { "offset" : _compute_sector_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def compute_sector(self, centralBody:str, center:list, innerRadius:float, outerRadius:float, startBearing:float, endBearing:float) -> "SurfaceShapesResult":
        """Compute boundary positions for a sector on the specified centralBody. This is equivalent to calling ComputeSector with a granularity of 1 degree."""
        return self._intf.invoke(ISurfaceShapesInitializer._metadata, ISurfaceShapesInitializer._compute_sector_metadata, centralBody, center, innerRadius, outerRadius, startBearing, endBearing, OutArg())

    _compute_sector_cartographic_with_granularity_metadata = { "offset" : _compute_sector_cartographic_with_granularity_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def compute_sector_cartographic_with_granularity(self, centralBody:str, center:list, innerRadius:float, outerRadius:float, startBearing:float, endBearing:float, granularity:float) -> "SurfaceShapesResult":
        """For convenience. Computes boundary positions for a sector on the specified centralBody using a cartographic center. This is equivalent to converting center to cartesian and calling ComputeSector."""
        return self._intf.invoke(ISurfaceShapesInitializer._metadata, ISurfaceShapesInitializer._compute_sector_cartographic_with_granularity_metadata, centralBody, center, innerRadius, outerRadius, startBearing, endBearing, granularity, OutArg())

    _compute_sector_cartographic_metadata = { "offset" : _compute_sector_cartographic_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def compute_sector_cartographic(self, centralBody:str, center:list, innerRadius:float, outerRadius:float, startBearing:float, endBearing:float) -> "SurfaceShapesResult":
        """For convenience. Computes boundary positions for a sector on the specified centralBody using a cartographic center. This is equivalent to converting center to cartesian and calling ComputeSector."""
        return self._intf.invoke(ISurfaceShapesInitializer._metadata, ISurfaceShapesInitializer._compute_sector_cartographic_metadata, centralBody, center, innerRadius, outerRadius, startBearing, endBearing, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5629653201892480912, 7351346316712711559), ISurfaceShapesInitializer)
agcls.AgTypeNameMap["ISurfaceShapesInitializer"] = ISurfaceShapesInitializer

class IAGICustomTerrainOverlayFactory(object):
    """A terrain overlay for handling AGI Cesium Terrain."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_with_string_method_offset = 1
    _metadata = {
        "iid_data" : (5040684832920863321, 16410225417933772417),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IAGICustomTerrainOverlayFactory."""
        initialize_from_source_object(self, sourceObject, IAGICustomTerrainOverlayFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAGICustomTerrainOverlayFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IAGICustomTerrainOverlayFactory, None)
    
    _initialize_with_string_metadata = { "offset" : _initialize_with_string_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_string(self, uri:str) -> "AGICustomTerrainOverlay":
        """Initialize an agi custom terrain overlay with the provided values."""
        return self._intf.invoke(IAGICustomTerrainOverlayFactory._metadata, IAGICustomTerrainOverlayFactory._initialize_with_string_metadata, uri, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5040684832920863321, 16410225417933772417), IAGICustomTerrainOverlayFactory)
agcls.AgTypeNameMap["IAGICustomTerrainOverlayFactory"] = IAGICustomTerrainOverlayFactory

class IAGIProcessedImageGlobeOverlayFactory(object):
    """A globe image overlay for handling AGI Processed Image (PDTTX) files."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_with_string_method_offset = 1
    _metadata = {
        "iid_data" : (5414678756491925668, 3365102375914156186),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IAGIProcessedImageGlobeOverlayFactory."""
        initialize_from_source_object(self, sourceObject, IAGIProcessedImageGlobeOverlayFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAGIProcessedImageGlobeOverlayFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IAGIProcessedImageGlobeOverlayFactory, None)
    
    _initialize_with_string_metadata = { "offset" : _initialize_with_string_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_string(self, uri:str) -> "AGIProcessedImageGlobeOverlay":
        """Initialize an agi processed image globe overlay with the provided values."""
        return self._intf.invoke(IAGIProcessedImageGlobeOverlayFactory._metadata, IAGIProcessedImageGlobeOverlayFactory._initialize_with_string_metadata, uri, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5414678756491925668, 3365102375914156186), IAGIProcessedImageGlobeOverlayFactory)
agcls.AgTypeNameMap["IAGIProcessedImageGlobeOverlayFactory"] = IAGIProcessedImageGlobeOverlayFactory

class IAGIProcessedTerrainOverlayFactory(object):
    """A terrain overlay for handling AGI Processed Terrain (PDTT) files."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_with_string_method_offset = 1
    _metadata = {
        "iid_data" : (4874527850217007064, 16872648207287740593),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IAGIProcessedTerrainOverlayFactory."""
        initialize_from_source_object(self, sourceObject, IAGIProcessedTerrainOverlayFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAGIProcessedTerrainOverlayFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IAGIProcessedTerrainOverlayFactory, None)
    
    _initialize_with_string_metadata = { "offset" : _initialize_with_string_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_string(self, uri:str) -> "AGIProcessedTerrainOverlay":
        """Initialize an agi processed terrain overlay with the provided values."""
        return self._intf.invoke(IAGIProcessedTerrainOverlayFactory._metadata, IAGIProcessedTerrainOverlayFactory._initialize_with_string_metadata, uri, OutArg())


agcls.AgClassCatalog.add_catalog_entry((4874527850217007064, 16872648207287740593), IAGIProcessedTerrainOverlayFactory)
agcls.AgTypeNameMap["IAGIProcessedTerrainOverlayFactory"] = IAGIProcessedTerrainOverlayFactory

class IAGIRoamImageGlobeOverlayFactory(object):
    """A globe image overlay for handling ROAM (TXM/TXB) files."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_with_string_method_offset = 1
    _metadata = {
        "iid_data" : (4939634351351358063, 1027128354741902509),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IAGIRoamImageGlobeOverlayFactory."""
        initialize_from_source_object(self, sourceObject, IAGIRoamImageGlobeOverlayFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAGIRoamImageGlobeOverlayFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IAGIRoamImageGlobeOverlayFactory, None)
    
    _initialize_with_string_metadata = { "offset" : _initialize_with_string_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_string(self, uri:str) -> "AGIRoamImageGlobeOverlay":
        """Initialize an agi roam image globe overlay with the provided values."""
        return self._intf.invoke(IAGIRoamImageGlobeOverlayFactory._metadata, IAGIRoamImageGlobeOverlayFactory._initialize_with_string_metadata, uri, OutArg())


agcls.AgClassCatalog.add_catalog_entry((4939634351351358063, 1027128354741902509), IAGIRoamImageGlobeOverlayFactory)
agcls.AgTypeNameMap["IAGIRoamImageGlobeOverlayFactory"] = IAGIRoamImageGlobeOverlayFactory

class ICustomImageGlobeOverlayPluginActivatorFactory(object):
    """The Activator class provides methods to load COM plugins that implement custom image globe overlays. For more information about custom image globe overlays, see the STK Programming Interface."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _metadata = {
        "iid_data" : (5716716326052764390, 3829469669791868073),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ICustomImageGlobeOverlayPluginActivatorFactory."""
        initialize_from_source_object(self, sourceObject, ICustomImageGlobeOverlayPluginActivatorFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICustomImageGlobeOverlayPluginActivatorFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ICustomImageGlobeOverlayPluginActivatorFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "CustomImageGlobeOverlayPluginActivator":
        """Initialize a new instance of the Activator type."""
        return self._intf.invoke(ICustomImageGlobeOverlayPluginActivatorFactory._metadata, ICustomImageGlobeOverlayPluginActivatorFactory._initialize_metadata, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5716716326052764390, 3829469669791868073), ICustomImageGlobeOverlayPluginActivatorFactory)
agcls.AgTypeNameMap["ICustomImageGlobeOverlayPluginActivatorFactory"] = ICustomImageGlobeOverlayPluginActivatorFactory

class IGeospatialImageGlobeOverlayFactory(object):
    """A globe image overlay for handling `JPEG 2000 <https://jpeg.org/jpeg2000/>`_ (.jp2), ECW (.ecw), ECWP, and MrSid (.sid) image formats in the WGS84 geographic projection."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_with_string_method_offset = 1
    _metadata = {
        "iid_data" : (4690634408452295489, 8537699766398765227),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IGeospatialImageGlobeOverlayFactory."""
        initialize_from_source_object(self, sourceObject, IGeospatialImageGlobeOverlayFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IGeospatialImageGlobeOverlayFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IGeospatialImageGlobeOverlayFactory, None)
    
    _initialize_with_string_metadata = { "offset" : _initialize_with_string_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_string(self, uri:str) -> "GeospatialImageGlobeOverlay":
        """Initialize a geospatial image globe overlay with the provided values."""
        return self._intf.invoke(IGeospatialImageGlobeOverlayFactory._metadata, IGeospatialImageGlobeOverlayFactory._initialize_with_string_metadata, uri, OutArg())


agcls.AgClassCatalog.add_catalog_entry((4690634408452295489, 8537699766398765227), IGeospatialImageGlobeOverlayFactory)
agcls.AgTypeNameMap["IGeospatialImageGlobeOverlayFactory"] = IGeospatialImageGlobeOverlayFactory

class IProjectedRasterOverlayFactory(object):
    """A globe image overlay which projects a raster onto the terrain or surface of the central body. You can also enable projection onto models by setting projected raster model projection to true for a Scene..."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _get_supported_method_offset = 2
    _metadata = {
        "iid_data" : (4730844454555664248, 6208355772920608678),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IProjectedRasterOverlayFactory."""
        initialize_from_source_object(self, sourceObject, IProjectedRasterOverlayFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IProjectedRasterOverlayFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IProjectedRasterOverlayFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("IRaster"), agmarshall.InterfaceInArg("IProjection"), agmarshall.InterfaceOutArg,) }
    def initialize(self, raster:"IRaster", projection:"IProjection") -> "ProjectedRasterOverlay":
        """Initialize a new instance."""
        return self._intf.invoke(IProjectedRasterOverlayFactory._metadata, IProjectedRasterOverlayFactory._initialize_metadata, raster, projection, OutArg())

    _get_supported_metadata = { "offset" : _get_supported_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def supported(self) -> bool:
        """Get whether or not the video card supports the projected raster overlay."""
        return self._intf.get_property(IProjectedRasterOverlayFactory._metadata, IProjectedRasterOverlayFactory._get_supported_metadata)

    _property_names[supported] = "supported"


agcls.AgClassCatalog.add_catalog_entry((4730844454555664248, 6208355772920608678), IProjectedRasterOverlayFactory)
agcls.AgTypeNameMap["IProjectedRasterOverlayFactory"] = IProjectedRasterOverlayFactory

class IProjectionFactory(object):
    """A projection represents a simplified camera with a position, orientation, and field of view horizontal and field of view vertical..."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_with_data_method_offset = 2
    _initialize_from_projection_method_offset = 3
    _metadata = {
        "iid_data" : (5432567096863391037, 8846581330465756851),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IProjectionFactory."""
        initialize_from_source_object(self, sourceObject, IProjectionFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IProjectionFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IProjectionFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "IProjection":
        """Initialize a new instance."""
        return self._intf.invoke(IProjectionFactory._metadata, IProjectionFactory._initialize_metadata, OutArg())

    _initialize_with_data_metadata = { "offset" : _initialize_with_data_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), agcom.PVOID, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.InterfaceInArg("IOrientation"), agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_data(self, position:list, orientation:"IOrientation", fieldOfViewHorizontal:float, fieldOfViewVertical:float, nearPlane:float, farPlane:float) -> "IProjection":
        """Initialize a new instance."""
        return self._intf.invoke(IProjectionFactory._metadata, IProjectionFactory._initialize_with_data_metadata, position, orientation, fieldOfViewHorizontal, fieldOfViewVertical, nearPlane, farPlane, OutArg())

    _initialize_from_projection_metadata = { "offset" : _initialize_from_projection_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("IProjection"), agmarshall.InterfaceOutArg,) }
    def initialize_from_projection(self, projection:"IProjection") -> "IProjection":
        """Initialize a new instance from another projection."""
        return self._intf.invoke(IProjectionFactory._metadata, IProjectionFactory._initialize_from_projection_metadata, projection, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5432567096863391037, 8846581330465756851), IProjectionFactory)
agcls.AgTypeNameMap["IProjectionFactory"] = IProjectionFactory

class IAltitudeDisplayConditionFactory(object):
    """Define an inclusive altitude interval that determines when an object is rendered based on the camera's altitude relative to a central body."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_with_altitudes_method_offset = 2
    _initialize_with_central_body_and_altitudes_method_offset = 3
    _metadata = {
        "iid_data" : (4755763547930033136, 8850247137212979090),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IAltitudeDisplayConditionFactory."""
        initialize_from_source_object(self, sourceObject, IAltitudeDisplayConditionFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAltitudeDisplayConditionFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IAltitudeDisplayConditionFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "AltitudeDisplayCondition":
        """Initialize a default altitude display condition. With this constructor, an object is always rendered regardless of the camera's altitude."""
        return self._intf.invoke(IAltitudeDisplayConditionFactory._metadata, IAltitudeDisplayConditionFactory._initialize_metadata, OutArg())

    _initialize_with_altitudes_metadata = { "offset" : _initialize_with_altitudes_method_offset,
            "arg_types" : (agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_altitudes(self, minimumAltitude:float, maximumAltitude:float) -> "AltitudeDisplayCondition":
        """Initialize an altitude display condition with the inclusive altitude interval [minimumAltitude, maximumAltitude]..."""
        return self._intf.invoke(IAltitudeDisplayConditionFactory._metadata, IAltitudeDisplayConditionFactory._initialize_with_altitudes_metadata, minimumAltitude, maximumAltitude, OutArg())

    _initialize_with_central_body_and_altitudes_metadata = { "offset" : _initialize_with_central_body_and_altitudes_method_offset,
            "arg_types" : (agcom.BSTR, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_central_body_and_altitudes(self, centralBody:str, minimumAltitude:float, maximumAltitude:float) -> "AltitudeDisplayCondition":
        """Initialize an altitude display condition with the inclusive altitude interval [minimumAltitude, maximumAltitude]..."""
        return self._intf.invoke(IAltitudeDisplayConditionFactory._metadata, IAltitudeDisplayConditionFactory._initialize_with_central_body_and_altitudes_metadata, centralBody, minimumAltitude, maximumAltitude, OutArg())


agcls.AgClassCatalog.add_catalog_entry((4755763547930033136, 8850247137212979090), IAltitudeDisplayConditionFactory)
agcls.AgTypeNameMap["IAltitudeDisplayConditionFactory"] = IAltitudeDisplayConditionFactory

class IAxesPrimitiveFactory(object):
    """Render an axes in the 3D scene."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_with_direction_method_offset = 1
    _metadata = {
        "iid_data" : (5186328749713028732, 7387028239953299617),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IAxesPrimitiveFactory."""
        initialize_from_source_object(self, sourceObject, IAxesPrimitiveFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAxesPrimitiveFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IAxesPrimitiveFactory, None)
    
    _initialize_with_direction_metadata = { "offset" : _initialize_with_direction_method_offset,
            "arg_types" : (agcom.PVOID, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolSystem"), agmarshall.InterfaceInArg("IVectorGeometryToolAxes"), agmarshall.InterfaceInArg("IGraphicsFont"), agmarshall.InterfaceOutArg,) }
    def initialize_with_direction(self, referenceFrame:"IVectorGeometryToolSystem", axes:"IVectorGeometryToolAxes", font:"IGraphicsFont") -> "AxesPrimitive":
        """Initialize an axes primitive with the specified reference frame as its source."""
        return self._intf.invoke(IAxesPrimitiveFactory._metadata, IAxesPrimitiveFactory._initialize_with_direction_metadata, referenceFrame, axes, font, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5186328749713028732, 7387028239953299617), IAxesPrimitiveFactory)
agcls.AgTypeNameMap["IAxesPrimitiveFactory"] = IAxesPrimitiveFactory

class ICompositeDisplayConditionFactory(object):
    """A composite of display conditions combined using a binary logic operation. For example, several time interval display condition objects can be added to a composite..."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _metadata = {
        "iid_data" : (5640662191306331166, 7439510576145951152),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ICompositeDisplayConditionFactory."""
        initialize_from_source_object(self, sourceObject, ICompositeDisplayConditionFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICompositeDisplayConditionFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ICompositeDisplayConditionFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "CompositeDisplayCondition":
        """Initialize an empty composite display condition."""
        return self._intf.invoke(ICompositeDisplayConditionFactory._metadata, ICompositeDisplayConditionFactory._initialize_metadata, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5640662191306331166, 7439510576145951152), ICompositeDisplayConditionFactory)
agcls.AgTypeNameMap["ICompositeDisplayConditionFactory"] = ICompositeDisplayConditionFactory

class ICompositePrimitiveFactory(object):
    """A primitive that is composed of multiple other primitives. Since composites can contain other composites, they are commonly used to build hierarchies of primitives to efficiently evaluate display conditions..."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _metadata = {
        "iid_data" : (5432871775621400225, 7893199841999433616),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ICompositePrimitiveFactory."""
        initialize_from_source_object(self, sourceObject, ICompositePrimitiveFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ICompositePrimitiveFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ICompositePrimitiveFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "CompositePrimitive":
        """Initialize a default composite primitive."""
        return self._intf.invoke(ICompositePrimitiveFactory._metadata, ICompositePrimitiveFactory._initialize_metadata, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5432871775621400225, 7893199841999433616), ICompositePrimitiveFactory)
agcls.AgTypeNameMap["ICompositePrimitiveFactory"] = ICompositePrimitiveFactory

class IConstantDisplayConditionFactory(object):
    """A display condition that evaluates to a user-defined value. This is commonly used to hide primitives by assigning to a primitive a display condition that always returns false."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_display_method_offset = 2
    _metadata = {
        "iid_data" : (5400002381848127225, 5516223612977063081),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IConstantDisplayConditionFactory."""
        initialize_from_source_object(self, sourceObject, IConstantDisplayConditionFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IConstantDisplayConditionFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IConstantDisplayConditionFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "ConstantDisplayCondition":
        """Initialize a default constant display condition. display is set to false so when this display condition is assigned to an object, such as a primitive, the object is not rendered."""
        return self._intf.invoke(IConstantDisplayConditionFactory._metadata, IConstantDisplayConditionFactory._initialize_metadata, OutArg())

    _initialize_display_metadata = { "offset" : _initialize_display_method_offset,
            "arg_types" : (agcom.VARIANT_BOOL, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.VariantBoolArg, agmarshall.InterfaceOutArg,) }
    def initialize_display(self, display:bool) -> "ConstantDisplayCondition":
        """Initialize a constant display condition with the value the display condition evaluates to."""
        return self._intf.invoke(IConstantDisplayConditionFactory._metadata, IConstantDisplayConditionFactory._initialize_display_metadata, display, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5400002381848127225, 5516223612977063081), IConstantDisplayConditionFactory)
agcls.AgTypeNameMap["IConstantDisplayConditionFactory"] = IConstantDisplayConditionFactory

class IDistanceDisplayConditionFactory(object):
    """Define an inclusive distance interval that determines when an object, such as a primitive, is rendered based on the distance from the camera to the object."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_with_distances_method_offset = 2
    _metadata = {
        "iid_data" : (5457573105077429574, 1307233846394703268),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IDistanceDisplayConditionFactory."""
        initialize_from_source_object(self, sourceObject, IDistanceDisplayConditionFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IDistanceDisplayConditionFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IDistanceDisplayConditionFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "DistanceDisplayCondition":
        """Initialize a default distance display condition. minimum distance is set to 0 and maximum distance is set to Double.MaxValue. With this interval, an object is always rendered regardless of its distance to the camera."""
        return self._intf.invoke(IDistanceDisplayConditionFactory._metadata, IDistanceDisplayConditionFactory._initialize_metadata, OutArg())

    _initialize_with_distances_metadata = { "offset" : _initialize_with_distances_method_offset,
            "arg_types" : (agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_distances(self, minimumDistance:float, maximumDistance:float) -> "DistanceDisplayCondition":
        """Initialize a distance display condition with the inclusive distance interval [minimumDistance, maximumDistance]..."""
        return self._intf.invoke(IDistanceDisplayConditionFactory._metadata, IDistanceDisplayConditionFactory._initialize_with_distances_metadata, minimumDistance, maximumDistance, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5457573105077429574, 1307233846394703268), IDistanceDisplayConditionFactory)
agcls.AgTypeNameMap["IDistanceDisplayConditionFactory"] = IDistanceDisplayConditionFactory

class IDistanceToGlobeOverlayDisplayConditionFactory(object):
    """Define an inclusive distance interval that determines when an object, such as a primitive, is rendered based on the distance from the camera to the globe overlay..."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_with_distances_method_offset = 2
    _metadata = {
        "iid_data" : (5078517983999700412, 9087207795525341829),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IDistanceToGlobeOverlayDisplayConditionFactory."""
        initialize_from_source_object(self, sourceObject, IDistanceToGlobeOverlayDisplayConditionFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IDistanceToGlobeOverlayDisplayConditionFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IDistanceToGlobeOverlayDisplayConditionFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "DistanceToGlobeOverlayDisplayCondition":
        """Initialize a default distance to globe overlay display condition. With this constructor, an object is always rendered regardless of the camera's distance to the globe overlay."""
        return self._intf.invoke(IDistanceToGlobeOverlayDisplayConditionFactory._metadata, IDistanceToGlobeOverlayDisplayConditionFactory._initialize_metadata, OutArg())

    _initialize_with_distances_metadata = { "offset" : _initialize_with_distances_method_offset,
            "arg_types" : (agcom.PVOID, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("IGlobeOverlay"), agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_distances(self, globeOverlay:"IGlobeOverlay", minimumDistance:float, maximumDistance:float) -> "DistanceToGlobeOverlayDisplayCondition":
        """Initialize a distance display condition with the globe overlay and the inclusive distance interval [minimumDistance, maximumDistance]..."""
        return self._intf.invoke(IDistanceToGlobeOverlayDisplayConditionFactory._metadata, IDistanceToGlobeOverlayDisplayConditionFactory._initialize_with_distances_metadata, globeOverlay, minimumDistance, maximumDistance, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5078517983999700412, 9087207795525341829), IDistanceToGlobeOverlayDisplayConditionFactory)
agcls.AgTypeNameMap["IDistanceToGlobeOverlayDisplayConditionFactory"] = IDistanceToGlobeOverlayDisplayConditionFactory

class IDistanceToPositionDisplayConditionFactory(object):
    """Define an inclusive distance interval that determines when an object, such as a primitive, is rendered based on the distance from the camera to a position defined in the given reference frame."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_with_distances_method_offset = 2
    _initialize_with_reference_frame_and_distances_method_offset = 3
    _metadata = {
        "iid_data" : (4847747984776878583, 13677898424481493938),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IDistanceToPositionDisplayConditionFactory."""
        initialize_from_source_object(self, sourceObject, IDistanceToPositionDisplayConditionFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IDistanceToPositionDisplayConditionFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IDistanceToPositionDisplayConditionFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "DistanceToPositionDisplayCondition":
        """Initialize a default distance to position display condition. With this constructor, an object is always rendered regardless of the camera's distance to the position."""
        return self._intf.invoke(IDistanceToPositionDisplayConditionFactory._metadata, IDistanceToPositionDisplayConditionFactory._initialize_metadata, OutArg())

    _initialize_with_distances_metadata = { "offset" : _initialize_with_distances_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_distances(self, position:list, minimumDistance:float, maximumDistance:float) -> "DistanceToPositionDisplayCondition":
        """Initialize a distance display condition with the inclusive distance interval [minimumDistance, maximumDistance]..."""
        return self._intf.invoke(IDistanceToPositionDisplayConditionFactory._metadata, IDistanceToPositionDisplayConditionFactory._initialize_with_distances_metadata, position, minimumDistance, maximumDistance, OutArg())

    _initialize_with_reference_frame_and_distances_metadata = { "offset" : _initialize_with_reference_frame_and_distances_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.LPSAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolSystem"), agmarshall.LPSafearrayArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_reference_frame_and_distances(self, referenceFrame:"IVectorGeometryToolSystem", position:list, minimumDistance:float, maximumDistance:float) -> "DistanceToPositionDisplayCondition":
        """Initialize a distance display condition with the inclusive distance interval [minimumDistance, maximumDistance]..."""
        return self._intf.invoke(IDistanceToPositionDisplayConditionFactory._metadata, IDistanceToPositionDisplayConditionFactory._initialize_with_reference_frame_and_distances_metadata, referenceFrame, position, minimumDistance, maximumDistance, OutArg())


agcls.AgClassCatalog.add_catalog_entry((4847747984776878583, 13677898424481493938), IDistanceToPositionDisplayConditionFactory)
agcls.AgTypeNameMap["IDistanceToPositionDisplayConditionFactory"] = IDistanceToPositionDisplayConditionFactory

class IDistanceToPrimitiveDisplayConditionFactory(object):
    """Define an inclusive distance interval that determines when an object, such as a screen overlay, is rendered based on the distance from the camera to the primitive..."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_with_distances_method_offset = 2
    _metadata = {
        "iid_data" : (5392763054025061782, 9454103370705814146),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IDistanceToPrimitiveDisplayConditionFactory."""
        initialize_from_source_object(self, sourceObject, IDistanceToPrimitiveDisplayConditionFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IDistanceToPrimitiveDisplayConditionFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IDistanceToPrimitiveDisplayConditionFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "DistanceToPrimitiveDisplayCondition":
        """Initialize a default distance to primitive display condition. With this constructor, an object is always rendered regardless of the camera's distance to the primitive."""
        return self._intf.invoke(IDistanceToPrimitiveDisplayConditionFactory._metadata, IDistanceToPrimitiveDisplayConditionFactory._initialize_metadata, OutArg())

    _initialize_with_distances_metadata = { "offset" : _initialize_with_distances_method_offset,
            "arg_types" : (agcom.PVOID, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("IPrimitive"), agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_distances(self, primitive:"IPrimitive", minimumDistance:float, maximumDistance:float) -> "DistanceToPrimitiveDisplayCondition":
        """Initialize a distance to primitive display condition with the inclusive distance interval [minimumDistance, maximumDistance]..."""
        return self._intf.invoke(IDistanceToPrimitiveDisplayConditionFactory._metadata, IDistanceToPrimitiveDisplayConditionFactory._initialize_with_distances_metadata, primitive, minimumDistance, maximumDistance, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5392763054025061782, 9454103370705814146), IDistanceToPrimitiveDisplayConditionFactory)
agcls.AgTypeNameMap["IDistanceToPrimitiveDisplayConditionFactory"] = IDistanceToPrimitiveDisplayConditionFactory

class IDurationPathPrimitiveUpdatePolicyFactory(object):
    """path primitive update policy that removes points from remove location after a given duration."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_with_parameters_method_offset = 2
    _metadata = {
        "iid_data" : (5365007752863202110, 14050643698193736119),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IDurationPathPrimitiveUpdatePolicyFactory."""
        initialize_from_source_object(self, sourceObject, IDurationPathPrimitiveUpdatePolicyFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IDurationPathPrimitiveUpdatePolicyFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IDurationPathPrimitiveUpdatePolicyFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "DurationPathPrimitiveUpdatePolicy":
        """Construct a default update policy. This is equivalent to constructing a policy with duration set to 0 and a remove location of Front."""
        return self._intf.invoke(IDurationPathPrimitiveUpdatePolicyFactory._metadata, IDurationPathPrimitiveUpdatePolicyFactory._initialize_metadata, OutArg())

    _initialize_with_parameters_metadata = { "offset" : _initialize_with_parameters_method_offset,
            "arg_types" : (agcom.DOUBLE, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.DoubleArg, agmarshall.EnumArg(PATH_PRIMITIVE_REMOVE_LOCATION), agmarshall.InterfaceOutArg,) }
    def initialize_with_parameters(self, duration:float, removeLocation:"PATH_PRIMITIVE_REMOVE_LOCATION") -> "DurationPathPrimitiveUpdatePolicy":
        """Initialize a policy with the specified duration and removeLocation."""
        return self._intf.invoke(IDurationPathPrimitiveUpdatePolicyFactory._metadata, IDurationPathPrimitiveUpdatePolicyFactory._initialize_with_parameters_metadata, duration, removeLocation, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5365007752863202110, 14050643698193736119), IDurationPathPrimitiveUpdatePolicyFactory)
agcls.AgTypeNameMap["IDurationPathPrimitiveUpdatePolicyFactory"] = IDurationPathPrimitiveUpdatePolicyFactory

class IGlobeImageOverlayInitializer(object):
    """A globe overlay that shows an image."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_more_than_one_image_globe_overlay_supported_method_offset = 1
    _metadata = {
        "iid_data" : (5017702324207279185, 5756175734433316769),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IGlobeImageOverlayInitializer."""
        initialize_from_source_object(self, sourceObject, IGlobeImageOverlayInitializer)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IGlobeImageOverlayInitializer)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IGlobeImageOverlayInitializer, None)
    
    _get_more_than_one_image_globe_overlay_supported_metadata = { "offset" : _get_more_than_one_image_globe_overlay_supported_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def more_than_one_image_globe_overlay_supported(self) -> bool:
        """Get whether or not the video card allows for more than one image globe overlay globe image overlay to be added."""
        return self._intf.get_property(IGlobeImageOverlayInitializer._metadata, IGlobeImageOverlayInitializer._get_more_than_one_image_globe_overlay_supported_metadata)

    _property_names[more_than_one_image_globe_overlay_supported] = "more_than_one_image_globe_overlay_supported"


agcls.AgClassCatalog.add_catalog_entry((5017702324207279185, 5756175734433316769), IGlobeImageOverlayInitializer)
agcls.AgTypeNameMap["IGlobeImageOverlayInitializer"] = IGlobeImageOverlayInitializer

class IGraphicsFontFactory(object):
    """A font that is suitable for use with the text batch primitive. For best performance, avoid creating duplicate font objects. Instead assign the same font object to several text batch primitives."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_with_name_size_font_style_outline_method_offset = 1
    _initialize_with_name_size_method_offset = 2
    _metadata = {
        "iid_data" : (5056346160575786734, 13195175912335776191),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IGraphicsFontFactory."""
        initialize_from_source_object(self, sourceObject, IGraphicsFontFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IGraphicsFontFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IGraphicsFontFactory, None)
    
    _initialize_with_name_size_font_style_outline_metadata = { "offset" : _initialize_with_name_size_font_style_outline_method_offset,
            "arg_types" : (agcom.BSTR, agcom.INT, agcom.LONG, agcom.VARIANT_BOOL, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.IntArg, agmarshall.EnumArg(FONT_STYLE), agmarshall.VariantBoolArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_name_size_font_style_outline(self, name:str, size:int, fontStyle:"FONT_STYLE", outline:bool) -> "GraphicsFont":
        """Initialize a graphics font with the given arguments."""
        return self._intf.invoke(IGraphicsFontFactory._metadata, IGraphicsFontFactory._initialize_with_name_size_font_style_outline_metadata, name, size, fontStyle, outline, OutArg())

    _initialize_with_name_size_metadata = { "offset" : _initialize_with_name_size_method_offset,
            "arg_types" : (agcom.BSTR, agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_name_size(self, name:str, size:int) -> "GraphicsFont":
        """Initialize a graphics font with the typeface name and size."""
        return self._intf.invoke(IGraphicsFontFactory._metadata, IGraphicsFontFactory._initialize_with_name_size_metadata, name, size, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5056346160575786734, 13195175912335776191), IGraphicsFontFactory)
agcls.AgTypeNameMap["IGraphicsFontFactory"] = IGraphicsFontFactory

class IGreatArcInterpolatorFactory(object):
    """The great arc interpolator computes interpolated positions along a great arc. A great arc is the shortest path between two positions on an ellipsoid."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_with_central_body_method_offset = 2
    _initialize_with_central_body_and_granularity_method_offset = 3
    _metadata = {
        "iid_data" : (5597993574880752456, 15952879401707039879),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IGreatArcInterpolatorFactory."""
        initialize_from_source_object(self, sourceObject, IGreatArcInterpolatorFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IGreatArcInterpolatorFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IGreatArcInterpolatorFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "GreatArcInterpolator":
        """Initialize a default great arc interpolator. This is equivalent to constructing a great arc interpolator with a central body equal to an instance of earth central body and a granularity of 1 degree."""
        return self._intf.invoke(IGreatArcInterpolatorFactory._metadata, IGreatArcInterpolatorFactory._initialize_metadata, OutArg())

    _initialize_with_central_body_metadata = { "offset" : _initialize_with_central_body_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_central_body(self, centralBody:str) -> "GreatArcInterpolator":
        """Initialize a great arc interpolator with the specified centralBody and a granularity of 1 degree."""
        return self._intf.invoke(IGreatArcInterpolatorFactory._metadata, IGreatArcInterpolatorFactory._initialize_with_central_body_metadata, centralBody, OutArg())

    _initialize_with_central_body_and_granularity_metadata = { "offset" : _initialize_with_central_body_and_granularity_method_offset,
            "arg_types" : (agcom.BSTR, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_central_body_and_granularity(self, centralBody:str, granularity:float) -> "GreatArcInterpolator":
        """Initialize a great arc interpolator with the specified centralBody and granularity."""
        return self._intf.invoke(IGreatArcInterpolatorFactory._metadata, IGreatArcInterpolatorFactory._initialize_with_central_body_and_granularity_metadata, centralBody, granularity, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5597993574880752456, 15952879401707039879), IGreatArcInterpolatorFactory)
agcls.AgTypeNameMap["IGreatArcInterpolatorFactory"] = IGreatArcInterpolatorFactory

class IAlphaFromLuminanceFilterFactory(object):
    """Add an alpha band to the source raster derived from the luminance of the raster's color bands."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _metadata = {
        "iid_data" : (4784550270767461897, 433236726907178163),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IAlphaFromLuminanceFilterFactory."""
        initialize_from_source_object(self, sourceObject, IAlphaFromLuminanceFilterFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAlphaFromLuminanceFilterFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IAlphaFromLuminanceFilterFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "AlphaFromLuminanceFilter":
        """Initialize a new instance."""
        return self._intf.invoke(IAlphaFromLuminanceFilterFactory._metadata, IAlphaFromLuminanceFilterFactory._initialize_metadata, OutArg())


agcls.AgClassCatalog.add_catalog_entry((4784550270767461897, 433236726907178163), IAlphaFromLuminanceFilterFactory)
agcls.AgTypeNameMap["IAlphaFromLuminanceFilterFactory"] = IAlphaFromLuminanceFilterFactory

class IAlphaFromPixelFilterFactory(object):
    """Add an alpha band to the source raster based on the value of its first pixel. All pixels in the source raster that are the same color as the first pixel will be made transparent."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _metadata = {
        "iid_data" : (4989335994370105344, 1966184825921902519),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IAlphaFromPixelFilterFactory."""
        initialize_from_source_object(self, sourceObject, IAlphaFromPixelFilterFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAlphaFromPixelFilterFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IAlphaFromPixelFilterFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "AlphaFromPixelFilter":
        """Initialize a new instance."""
        return self._intf.invoke(IAlphaFromPixelFilterFactory._metadata, IAlphaFromPixelFilterFactory._initialize_metadata, OutArg())


agcls.AgClassCatalog.add_catalog_entry((4989335994370105344, 1966184825921902519), IAlphaFromPixelFilterFactory)
agcls.AgTypeNameMap["IAlphaFromPixelFilterFactory"] = IAlphaFromPixelFilterFactory

class IAlphaFromRasterFilterFactory(object):
    """Add an alpha band to the source raster derived from the color bands or alpha of another raster. This filter can be used to apply an alpha mask to the source raster."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_with_raster_method_offset = 2
    _metadata = {
        "iid_data" : (5463703046134669249, 4392897485377257379),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IAlphaFromRasterFilterFactory."""
        initialize_from_source_object(self, sourceObject, IAlphaFromRasterFilterFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IAlphaFromRasterFilterFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IAlphaFromRasterFilterFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "AlphaFromRasterFilter":
        """Initialize a new instance."""
        return self._intf.invoke(IAlphaFromRasterFilterFactory._metadata, IAlphaFromRasterFilterFactory._initialize_metadata, OutArg())

    _initialize_with_raster_metadata = { "offset" : _initialize_with_raster_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("IRaster"), agmarshall.InterfaceOutArg,) }
    def initialize_with_raster(self, raster:"IRaster") -> "AlphaFromRasterFilter":
        """Initialize a new instance with the raster that the source raster will use to derive an alpha band."""
        return self._intf.invoke(IAlphaFromRasterFilterFactory._metadata, IAlphaFromRasterFilterFactory._initialize_with_raster_metadata, raster, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5463703046134669249, 4392897485377257379), IAlphaFromRasterFilterFactory)
agcls.AgTypeNameMap["IAlphaFromRasterFilterFactory"] = IAlphaFromRasterFilterFactory

class IBandExtractFilterFactory(object):
    """Extract a band or set of bands from the source raster. The extract format property specifies the bands and the order of the bands that will be extracted."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_with_band_method_offset = 2
    _initialize_with_format_method_offset = 3
    _metadata = {
        "iid_data" : (4832952187068243514, 18297885202007877258),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IBandExtractFilterFactory."""
        initialize_from_source_object(self, sourceObject, IBandExtractFilterFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IBandExtractFilterFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IBandExtractFilterFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "BandExtractFilter":
        """Initialize a new instance."""
        return self._intf.invoke(IBandExtractFilterFactory._metadata, IBandExtractFilterFactory._initialize_metadata, OutArg())

    _initialize_with_band_metadata = { "offset" : _initialize_with_band_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.EnumArg(RASTER_BAND), agmarshall.InterfaceOutArg,) }
    def initialize_with_band(self, rasterBand:"RASTER_BAND") -> "BandExtractFilter":
        """Initialize a new instance with the raster band to be extracted from the source raster."""
        return self._intf.invoke(IBandExtractFilterFactory._metadata, IBandExtractFilterFactory._initialize_with_band_metadata, rasterBand, OutArg())

    _initialize_with_format_metadata = { "offset" : _initialize_with_format_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.EnumArg(RASTER_FORMAT), agmarshall.InterfaceOutArg,) }
    def initialize_with_format(self, rasterFormat:"RASTER_FORMAT") -> "BandExtractFilter":
        """Initialize a new instance with the raster format containing the bands to be extracted from the source raster."""
        return self._intf.invoke(IBandExtractFilterFactory._metadata, IBandExtractFilterFactory._initialize_with_format_metadata, rasterFormat, OutArg())


agcls.AgClassCatalog.add_catalog_entry((4832952187068243514, 18297885202007877258), IBandExtractFilterFactory)
agcls.AgTypeNameMap["IBandExtractFilterFactory"] = IBandExtractFilterFactory

class IBandOrderFilterFactory(object):
    """Reorders or swizzles the bands of the source raster to match the band order of the raster format specified by the band order property. When maintain raster format is true, the source raster's format is maintained after swizzling."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_with_order_method_offset = 2
    _initialize_with_order_and_bool_method_offset = 3
    _metadata = {
        "iid_data" : (5167628621505688029, 2140904154865507202),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IBandOrderFilterFactory."""
        initialize_from_source_object(self, sourceObject, IBandOrderFilterFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IBandOrderFilterFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IBandOrderFilterFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "BandOrderFilter":
        """Initialize a new instance."""
        return self._intf.invoke(IBandOrderFilterFactory._metadata, IBandOrderFilterFactory._initialize_metadata, OutArg())

    _initialize_with_order_metadata = { "offset" : _initialize_with_order_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.EnumArg(RASTER_FORMAT), agmarshall.InterfaceOutArg,) }
    def initialize_with_order(self, bandOrder:"RASTER_FORMAT") -> "BandOrderFilter":
        """Initialize a new instance with a raster format indicating the desired order of the bands in the source raster."""
        return self._intf.invoke(IBandOrderFilterFactory._metadata, IBandOrderFilterFactory._initialize_with_order_metadata, bandOrder, OutArg())

    _initialize_with_order_and_bool_metadata = { "offset" : _initialize_with_order_and_bool_method_offset,
            "arg_types" : (agcom.LONG, agcom.VARIANT_BOOL, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.EnumArg(RASTER_FORMAT), agmarshall.VariantBoolArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_order_and_bool(self, bandOrder:"RASTER_FORMAT", maintainImageFormat:bool) -> "BandOrderFilter":
        """Initialize a new instance with a raster format indicating the desired order of the bands in the source raster, and whether to maintain the source raster's format after swizzling."""
        return self._intf.invoke(IBandOrderFilterFactory._metadata, IBandOrderFilterFactory._initialize_with_order_and_bool_metadata, bandOrder, maintainImageFormat, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5167628621505688029, 2140904154865507202), IBandOrderFilterFactory)
agcls.AgTypeNameMap["IBandOrderFilterFactory"] = IBandOrderFilterFactory

class IBlurFilterFactory(object):
    """Apply a convolution filter to blur or smooth the source raster. Can be used to reduce noise in the raster."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_with_method_method_offset = 2
    _metadata = {
        "iid_data" : (4923262284590517009, 11604235214943283634),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IBlurFilterFactory."""
        initialize_from_source_object(self, sourceObject, IBlurFilterFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IBlurFilterFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IBlurFilterFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "BlurFilter":
        """Initialize a new instance."""
        return self._intf.invoke(IBlurFilterFactory._metadata, IBlurFilterFactory._initialize_metadata, OutArg())

    _initialize_with_method_metadata = { "offset" : _initialize_with_method_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.EnumArg(BLUR_METHOD), agmarshall.InterfaceOutArg,) }
    def initialize_with_method(self, method:"BLUR_METHOD") -> "BlurFilter":
        """Initialize a new instance with the specified blur method."""
        return self._intf.invoke(IBlurFilterFactory._metadata, IBlurFilterFactory._initialize_with_method_metadata, method, OutArg())


agcls.AgClassCatalog.add_catalog_entry((4923262284590517009, 11604235214943283634), IBlurFilterFactory)
agcls.AgTypeNameMap["IBlurFilterFactory"] = IBlurFilterFactory

class IBrightnessFilterFactory(object):
    """Adjusts the brightness of the source raster's color bands. The adjustment to brightness is a value between -1 and 1, corresponding to least bright to most bright."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_with_adjustment_method_offset = 2
    _metadata = {
        "iid_data" : (4706652540771658090, 10963246864473891979),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IBrightnessFilterFactory."""
        initialize_from_source_object(self, sourceObject, IBrightnessFilterFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IBrightnessFilterFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IBrightnessFilterFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "BrightnessFilter":
        """Initialize a new instance."""
        return self._intf.invoke(IBrightnessFilterFactory._metadata, IBrightnessFilterFactory._initialize_metadata, OutArg())

    _initialize_with_adjustment_metadata = { "offset" : _initialize_with_adjustment_method_offset,
            "arg_types" : (agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_adjustment(self, adjustment:float) -> "BrightnessFilter":
        """Initialize a new instance with the adjustment to brightness."""
        return self._intf.invoke(IBrightnessFilterFactory._metadata, IBrightnessFilterFactory._initialize_with_adjustment_metadata, adjustment, OutArg())


agcls.AgClassCatalog.add_catalog_entry((4706652540771658090, 10963246864473891979), IBrightnessFilterFactory)
agcls.AgTypeNameMap["IBrightnessFilterFactory"] = IBrightnessFilterFactory

class IColorToLuminanceFilterFactory(object):
    """Extract a luminance band derived from the color bands of the source raster."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _metadata = {
        "iid_data" : (5083112551845356469, 13330143850832921752),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IColorToLuminanceFilterFactory."""
        initialize_from_source_object(self, sourceObject, IColorToLuminanceFilterFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IColorToLuminanceFilterFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IColorToLuminanceFilterFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "ColorToLuminanceFilter":
        """Initialize a new instance."""
        return self._intf.invoke(IColorToLuminanceFilterFactory._metadata, IColorToLuminanceFilterFactory._initialize_metadata, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5083112551845356469, 13330143850832921752), IColorToLuminanceFilterFactory)
agcls.AgTypeNameMap["IColorToLuminanceFilterFactory"] = IColorToLuminanceFilterFactory

class IContrastFilterFactory(object):
    """Adjusts the contrast of the source raster. The adjustment to contrast is a value between -1 and 1, corresponding to least contrast to most contrast."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_with_adjustment_method_offset = 2
    _metadata = {
        "iid_data" : (5167251651077763717, 10569666826435473333),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IContrastFilterFactory."""
        initialize_from_source_object(self, sourceObject, IContrastFilterFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IContrastFilterFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IContrastFilterFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "ContrastFilter":
        """Initialize a new instance."""
        return self._intf.invoke(IContrastFilterFactory._metadata, IContrastFilterFactory._initialize_metadata, OutArg())

    _initialize_with_adjustment_metadata = { "offset" : _initialize_with_adjustment_method_offset,
            "arg_types" : (agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_adjustment(self, adjustment:float) -> "ContrastFilter":
        """Initialize a new instance with the adjustment to contrast."""
        return self._intf.invoke(IContrastFilterFactory._metadata, IContrastFilterFactory._initialize_with_adjustment_metadata, adjustment, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5167251651077763717, 10569666826435473333), IContrastFilterFactory)
agcls.AgTypeNameMap["IContrastFilterFactory"] = IContrastFilterFactory

class IConvolutionFilterFactory(object):
    """Apply convolution to the source raster. Convolution is the modification of a pixel's value based on the values of its surrounding pixels. The kernel is the numerical matrix that is applied to each pixel in this process..."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_with_kernel_method_offset = 2
    _initialize_with_kernel_and_divisor_method_offset = 3
    _initialize_with_kernel_divisor_and_offset_method_offset = 4
    _metadata = {
        "iid_data" : (4903985300338047207, 13792865004310189207),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IConvolutionFilterFactory."""
        initialize_from_source_object(self, sourceObject, IConvolutionFilterFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IConvolutionFilterFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IConvolutionFilterFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "IConvolutionFilter":
        """Initialize a new instance."""
        return self._intf.invoke(IConvolutionFilterFactory._metadata, IConvolutionFilterFactory._initialize_metadata, OutArg())

    _initialize_with_kernel_metadata = { "offset" : _initialize_with_kernel_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_kernel(self, kernel:list) -> "IConvolutionFilter":
        """Initialize a new instance with the specified kernel."""
        return self._intf.invoke(IConvolutionFilterFactory._metadata, IConvolutionFilterFactory._initialize_with_kernel_metadata, kernel, OutArg())

    _initialize_with_kernel_and_divisor_metadata = { "offset" : _initialize_with_kernel_and_divisor_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_kernel_and_divisor(self, kernel:list, divisor:float) -> "IConvolutionFilter":
        """Initialize a new instance with the specified kernel and divisor."""
        return self._intf.invoke(IConvolutionFilterFactory._metadata, IConvolutionFilterFactory._initialize_with_kernel_and_divisor_metadata, kernel, divisor, OutArg())

    _initialize_with_kernel_divisor_and_offset_metadata = { "offset" : _initialize_with_kernel_divisor_and_offset_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_kernel_divisor_and_offset(self, kernel:list, divisor:float, offset:float) -> "IConvolutionFilter":
        """Initialize a new instance with the specified kernel, divisor, and offset."""
        return self._intf.invoke(IConvolutionFilterFactory._metadata, IConvolutionFilterFactory._initialize_with_kernel_divisor_and_offset_metadata, kernel, divisor, offset, OutArg())


agcls.AgClassCatalog.add_catalog_entry((4903985300338047207, 13792865004310189207), IConvolutionFilterFactory)
agcls.AgTypeNameMap["IConvolutionFilterFactory"] = IConvolutionFilterFactory

class IEdgeDetectFilterFactory(object):
    """Apply a convolution filter to detect edges in the source raster."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_with_method_method_offset = 2
    _metadata = {
        "iid_data" : (4672251477546348160, 1817218451623140252),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IEdgeDetectFilterFactory."""
        initialize_from_source_object(self, sourceObject, IEdgeDetectFilterFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IEdgeDetectFilterFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IEdgeDetectFilterFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "EdgeDetectFilter":
        """Initialize a new instance."""
        return self._intf.invoke(IEdgeDetectFilterFactory._metadata, IEdgeDetectFilterFactory._initialize_metadata, OutArg())

    _initialize_with_method_metadata = { "offset" : _initialize_with_method_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.EnumArg(EDGE_DETECT_METHOD), agmarshall.InterfaceOutArg,) }
    def initialize_with_method(self, method:"EDGE_DETECT_METHOD") -> "EdgeDetectFilter":
        """Initialize a new instance with the specified edge detect method."""
        return self._intf.invoke(IEdgeDetectFilterFactory._metadata, IEdgeDetectFilterFactory._initialize_with_method_metadata, method, OutArg())


agcls.AgClassCatalog.add_catalog_entry((4672251477546348160, 1817218451623140252), IEdgeDetectFilterFactory)
agcls.AgTypeNameMap["IEdgeDetectFilterFactory"] = IEdgeDetectFilterFactory

class IFilteringRasterStreamFactory(object):
    """A class decorator for applying a raster filter to each update of a raster stream. Can be used to apply filters to videos and other raster streams as they are updated."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _metadata = {
        "iid_data" : (4768066465876837563, 6138594242499415680),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IFilteringRasterStreamFactory."""
        initialize_from_source_object(self, sourceObject, IFilteringRasterStreamFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IFilteringRasterStreamFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IFilteringRasterStreamFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("IRasterStream"), agmarshall.InterfaceInArg("IRasterFilter"), agmarshall.InterfaceOutArg,) }
    def initialize(self, rasterStream:"IRasterStream", filter:"IRasterFilter") -> "FilteringRasterStream":
        """Initialize a new instance with a raster stream and the raster filter that will be applied to each update of that stream."""
        return self._intf.invoke(IFilteringRasterStreamFactory._metadata, IFilteringRasterStreamFactory._initialize_metadata, rasterStream, filter, OutArg())


agcls.AgClassCatalog.add_catalog_entry((4768066465876837563, 6138594242499415680), IFilteringRasterStreamFactory)
agcls.AgTypeNameMap["IFilteringRasterStreamFactory"] = IFilteringRasterStreamFactory

class IFlipFilterFactory(object):
    """Flips the source raster along the given flip axis."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_with_flip_axis_method_offset = 2
    _metadata = {
        "iid_data" : (4751370913637451425, 6465100862423909007),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IFlipFilterFactory."""
        initialize_from_source_object(self, sourceObject, IFlipFilterFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IFlipFilterFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IFlipFilterFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "FlipFilter":
        """Initialize a new instance."""
        return self._intf.invoke(IFlipFilterFactory._metadata, IFlipFilterFactory._initialize_metadata, OutArg())

    _initialize_with_flip_axis_metadata = { "offset" : _initialize_with_flip_axis_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.EnumArg(FLIP_AXIS), agmarshall.InterfaceOutArg,) }
    def initialize_with_flip_axis(self, flipAxis:"FLIP_AXIS") -> "FlipFilter":
        """Initialize a new instance with the specified flip axis."""
        return self._intf.invoke(IFlipFilterFactory._metadata, IFlipFilterFactory._initialize_with_flip_axis_metadata, flipAxis, OutArg())


agcls.AgClassCatalog.add_catalog_entry((4751370913637451425, 6465100862423909007), IFlipFilterFactory)
agcls.AgTypeNameMap["IFlipFilterFactory"] = IFlipFilterFactory

class IGammaCorrectionFilterFactory(object):
    """Apply gamma correction to the source raster. The gamma is a value between .2 and 5. The default gamma value is 2.2."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_with_gamma_method_offset = 2
    _metadata = {
        "iid_data" : (5167592269742334929, 11971914268866083772),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IGammaCorrectionFilterFactory."""
        initialize_from_source_object(self, sourceObject, IGammaCorrectionFilterFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IGammaCorrectionFilterFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IGammaCorrectionFilterFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "GammaCorrectionFilter":
        """Initialize a new instance."""
        return self._intf.invoke(IGammaCorrectionFilterFactory._metadata, IGammaCorrectionFilterFactory._initialize_metadata, OutArg())

    _initialize_with_gamma_metadata = { "offset" : _initialize_with_gamma_method_offset,
            "arg_types" : (agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_gamma(self, gamma:float) -> "GammaCorrectionFilter":
        """Initialize a new instance with the specified gamma."""
        return self._intf.invoke(IGammaCorrectionFilterFactory._metadata, IGammaCorrectionFilterFactory._initialize_with_gamma_metadata, gamma, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5167592269742334929, 11971914268866083772), IGammaCorrectionFilterFactory)
agcls.AgTypeNameMap["IGammaCorrectionFilterFactory"] = IGammaCorrectionFilterFactory

class IGaussianBlurFilterFactory(object):
    """Apply a convolution filter to blur the source raster using the Gaussian function."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _metadata = {
        "iid_data" : (5406022858574116214, 8919894875641969050),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IGaussianBlurFilterFactory."""
        initialize_from_source_object(self, sourceObject, IGaussianBlurFilterFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IGaussianBlurFilterFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IGaussianBlurFilterFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "GaussianBlurFilter":
        """Initialize a new instance."""
        return self._intf.invoke(IGaussianBlurFilterFactory._metadata, IGaussianBlurFilterFactory._initialize_metadata, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5406022858574116214, 8919894875641969050), IGaussianBlurFilterFactory)
agcls.AgTypeNameMap["IGaussianBlurFilterFactory"] = IGaussianBlurFilterFactory

class IGradientDetectFilterFactory(object):
    """Apply a convolution filter to detect gradients in the source raster."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_with_method_method_offset = 2
    _metadata = {
        "iid_data" : (4972960197585804924, 4939630423532346530),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IGradientDetectFilterFactory."""
        initialize_from_source_object(self, sourceObject, IGradientDetectFilterFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IGradientDetectFilterFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IGradientDetectFilterFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "GradientDetectFilter":
        """Initialize a new instance."""
        return self._intf.invoke(IGradientDetectFilterFactory._metadata, IGradientDetectFilterFactory._initialize_metadata, OutArg())

    _initialize_with_method_metadata = { "offset" : _initialize_with_method_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.EnumArg(GRADIENT_DETECT_METHOD), agmarshall.InterfaceOutArg,) }
    def initialize_with_method(self, method:"GRADIENT_DETECT_METHOD") -> "GradientDetectFilter":
        """Initialize a new instance with specified gradient detect method."""
        return self._intf.invoke(IGradientDetectFilterFactory._metadata, IGradientDetectFilterFactory._initialize_with_method_metadata, method, OutArg())


agcls.AgClassCatalog.add_catalog_entry((4972960197585804924, 4939630423532346530), IGradientDetectFilterFactory)
agcls.AgTypeNameMap["IGradientDetectFilterFactory"] = IGradientDetectFilterFactory

class IJpeg2000WriterInitializer(object):
    """Convert an image, such as a BMP, to a GeoJP2 file that can be used as an image globe overlay."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _write_string_method_offset = 1
    _write_extent_string_method_offset = 2
    _write_extent_and_sub_extent_string_method_offset = 3
    _write_extent_and_sub_extent_transparent_color_string_method_offset = 4
    _metadata = {
        "iid_data" : (5092380299587909893, 11808721769516081064),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IJpeg2000WriterInitializer."""
        initialize_from_source_object(self, sourceObject, IJpeg2000WriterInitializer)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IJpeg2000WriterInitializer)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IJpeg2000WriterInitializer, None)
    
    _write_string_metadata = { "offset" : _write_string_method_offset,
            "arg_types" : (agcom.BSTR, agcom.LONG, agcom.INT, agcom.BSTR, agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.BStrArg, agmarshall.EnumArg(JPEG2000_COMPRESSION_PROFILE), agmarshall.IntArg, agmarshall.BStrArg, agmarshall.VariantBoolArg,) }
    def write_string(self, imageUri:str, compressionProfile:"JPEG2000_COMPRESSION_PROFILE", compressionRate:int, jpeg2000Uri:str, overwriteExistingFile:bool) -> None:
        """Convert an image, such as a BMP, to a GeoJP2 file that can be used as an image globe overlay. The extent of the image must be in the image, as in a GeoTIFF."""
        return self._intf.invoke(IJpeg2000WriterInitializer._metadata, IJpeg2000WriterInitializer._write_string_metadata, imageUri, compressionProfile, compressionRate, jpeg2000Uri, overwriteExistingFile)

    _write_extent_string_metadata = { "offset" : _write_extent_string_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), agcom.LONG, agcom.INT, agcom.BSTR, agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.EnumArg(JPEG2000_COMPRESSION_PROFILE), agmarshall.IntArg, agmarshall.BStrArg, agmarshall.VariantBoolArg,) }
    def write_extent_string(self, imageUri:str, extent:list, compressionProfile:"JPEG2000_COMPRESSION_PROFILE", compressionRate:int, jpeg2000Uri:str, overwriteExistingFile:bool) -> None:
        """Convert an image, such as a BMP, to a GeoJP2 file that can be used as an image globe overlay. The extent of the image can be defined as an input parameter if necessary."""
        return self._intf.invoke(IJpeg2000WriterInitializer._metadata, IJpeg2000WriterInitializer._write_extent_string_metadata, imageUri, extent, compressionProfile, compressionRate, jpeg2000Uri, overwriteExistingFile)

    _write_extent_and_sub_extent_string_metadata = { "offset" : _write_extent_and_sub_extent_string_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), agcom.LONG, agcom.INT, agcom.BSTR, agcom.VARIANT_BOOL,),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.EnumArg(JPEG2000_COMPRESSION_PROFILE), agmarshall.IntArg, agmarshall.BStrArg, agmarshall.VariantBoolArg,) }
    def write_extent_and_sub_extent_string(self, imageUri:str, extent:list, subExtent:list, compressionProfile:"JPEG2000_COMPRESSION_PROFILE", compressionRate:int, jpeg2000Uri:str, overwriteExistingFile:bool) -> None:
        """Convert an image, such as a BMP, to a GeoJP2 file that can be used as an image globe overlay. The extent of the image can be defined as an input parameter if necessary."""
        return self._intf.invoke(IJpeg2000WriterInitializer._metadata, IJpeg2000WriterInitializer._write_extent_and_sub_extent_string_metadata, imageUri, extent, subExtent, compressionProfile, compressionRate, jpeg2000Uri, overwriteExistingFile)

    _write_extent_and_sub_extent_transparent_color_string_metadata = { "offset" : _write_extent_and_sub_extent_transparent_color_string_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), agcom.LONG, agcom.INT, agcom.BSTR, agcom.VARIANT_BOOL, agcom.OLE_COLOR,),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.EnumArg(JPEG2000_COMPRESSION_PROFILE), agmarshall.IntArg, agmarshall.BStrArg, agmarshall.VariantBoolArg, agmarshall.OLEColorArg,) }
    def write_extent_and_sub_extent_transparent_color_string(self, imageUri:str, extent:list, subExtent:list, compressionProfile:"JPEG2000_COMPRESSION_PROFILE", compressionRate:int, jpeg2000Uri:str, overwriteExistingFile:bool, transparentColor:agcolor.Color) -> None:
        """Convert an image, such as a BMP, to a GeoJP2 file that can be used as an image globe overlay. The extent of the image can be defined as an input parameter if necessary."""
        return self._intf.invoke(IJpeg2000WriterInitializer._metadata, IJpeg2000WriterInitializer._write_extent_and_sub_extent_transparent_color_string_metadata, imageUri, extent, subExtent, compressionProfile, compressionRate, jpeg2000Uri, overwriteExistingFile, transparentColor)


agcls.AgClassCatalog.add_catalog_entry((5092380299587909893, 11808721769516081064), IJpeg2000WriterInitializer)
agcls.AgTypeNameMap["IJpeg2000WriterInitializer"] = IJpeg2000WriterInitializer

class ILevelsFilterFactory(object):
    """Adjusts the band levels of the source raster linearly."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _metadata = {
        "iid_data" : (5651091276215577342, 12776132797161628062),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ILevelsFilterFactory."""
        initialize_from_source_object(self, sourceObject, ILevelsFilterFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ILevelsFilterFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ILevelsFilterFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "LevelsFilter":
        """Initialize a new instance."""
        return self._intf.invoke(ILevelsFilterFactory._metadata, ILevelsFilterFactory._initialize_metadata, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5651091276215577342, 12776132797161628062), ILevelsFilterFactory)
agcls.AgTypeNameMap["ILevelsFilterFactory"] = ILevelsFilterFactory

class IProjectionRasterStreamPluginActivatorFactory(object):
    """The Activator class provides methods to load COM plugins that implement projection and raster streaming. For more information about the projection and raster plugins, see the STK Programming Interface."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _metadata = {
        "iid_data" : (5694658555401953795, 11630760253044822402),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IProjectionRasterStreamPluginActivatorFactory."""
        initialize_from_source_object(self, sourceObject, IProjectionRasterStreamPluginActivatorFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IProjectionRasterStreamPluginActivatorFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IProjectionRasterStreamPluginActivatorFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "ProjectionRasterStreamPluginActivator":
        """Initialize a new instance of the Activator type."""
        return self._intf.invoke(IProjectionRasterStreamPluginActivatorFactory._metadata, IProjectionRasterStreamPluginActivatorFactory._initialize_metadata, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5694658555401953795, 11630760253044822402), IProjectionRasterStreamPluginActivatorFactory)
agcls.AgTypeNameMap["IProjectionRasterStreamPluginActivatorFactory"] = IProjectionRasterStreamPluginActivatorFactory

class IRasterFactory(object):
    """A raster dataset. A raster consists of one or more bands, or sets of values, which are most commonly associated with colors when the raster represents an image..."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_with_string_uri_method_offset = 1
    _initialize_with_string_uri_xy_width_and_height_method_offset = 2
    _initialize_with_raster_method_offset = 3
    _metadata = {
        "iid_data" : (4983926254269332627, 8002564209786216327),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IRasterFactory."""
        initialize_from_source_object(self, sourceObject, IRasterFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IRasterFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IRasterFactory, None)
    
    _initialize_with_string_uri_metadata = { "offset" : _initialize_with_string_uri_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_string_uri(self, uri:str) -> "IRaster":
        """Initialize a raster from a Uri, which can be a file, HTTP, HTTPS, or FTP source. See raster for a list of supported formats."""
        return self._intf.invoke(IRasterFactory._metadata, IRasterFactory._initialize_with_string_uri_metadata, uri, OutArg())

    _initialize_with_string_uri_xy_width_and_height_metadata = { "offset" : _initialize_with_string_uri_xy_width_and_height_method_offset,
            "arg_types" : (agcom.BSTR, agcom.INT, agcom.INT, agcom.INT, agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.IntArg, agmarshall.IntArg, agmarshall.IntArg, agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_string_uri_xy_width_and_height(self, uri:str, x:int, y:int, width:int, height:int) -> "IRaster":
        """Initialize a raster from a Uri. Only the specified subsection of the raster is read. See raster for a list of supported formats."""
        return self._intf.invoke(IRasterFactory._metadata, IRasterFactory._initialize_with_string_uri_xy_width_and_height_metadata, uri, x, y, width, height, OutArg())

    _initialize_with_raster_metadata = { "offset" : _initialize_with_raster_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("IRaster"), agmarshall.InterfaceOutArg,) }
    def initialize_with_raster(self, raster:"IRaster") -> "IRaster":
        """Initialize a raster from another raster."""
        return self._intf.invoke(IRasterFactory._metadata, IRasterFactory._initialize_with_raster_metadata, raster, OutArg())


agcls.AgClassCatalog.add_catalog_entry((4983926254269332627, 8002564209786216327), IRasterFactory)
agcls.AgTypeNameMap["IRasterFactory"] = IRasterFactory

class IRasterAttributesFactory(object):
    """The attributes describing a raster dataset. raster attributes define the memory layout of a raster, and includes properties defining the order of each raster band that the raster contains, as specified by the raster format..."""

    _num_methods = 6
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_with_format_method_offset = 1
    _initialize_with_format_and_type_method_offset = 2
    _initialize_with_format_type_and_orientation_method_offset = 3
    _initialize_with_format_type_orientation_and_alignment_method_offset = 4
    _initialize_with_format_type_orientation_alignment_and_ratio_method_offset = 5
    _initialize_with_raster_method_offset = 6
    _metadata = {
        "iid_data" : (5336522563649204217, 14499576022617050520),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IRasterAttributesFactory."""
        initialize_from_source_object(self, sourceObject, IRasterAttributesFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IRasterAttributesFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IRasterAttributesFactory, None)
    
    _initialize_with_format_metadata = { "offset" : _initialize_with_format_method_offset,
            "arg_types" : (agcom.INT, agcom.INT, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.IntArg, agmarshall.EnumArg(RASTER_FORMAT), agmarshall.InterfaceOutArg,) }
    def initialize_with_format(self, width:int, height:int, rasterFormat:"RASTER_FORMAT") -> "RasterAttributes":
        """Initialize a new instance with the width and height of the raster in pixels, and the given raster format."""
        return self._intf.invoke(IRasterAttributesFactory._metadata, IRasterAttributesFactory._initialize_with_format_metadata, width, height, rasterFormat, OutArg())

    _initialize_with_format_and_type_metadata = { "offset" : _initialize_with_format_and_type_method_offset,
            "arg_types" : (agcom.INT, agcom.INT, agcom.LONG, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.IntArg, agmarshall.EnumArg(RASTER_FORMAT), agmarshall.EnumArg(RASTER_TYPE), agmarshall.InterfaceOutArg,) }
    def initialize_with_format_and_type(self, width:int, height:int, rasterFormat:"RASTER_FORMAT", rasterType:"RASTER_TYPE") -> "RasterAttributes":
        """Initialize a new instance with the width and height of the raster in pixels, and the given raster format and raster type."""
        return self._intf.invoke(IRasterAttributesFactory._metadata, IRasterAttributesFactory._initialize_with_format_and_type_metadata, width, height, rasterFormat, rasterType, OutArg())

    _initialize_with_format_type_and_orientation_metadata = { "offset" : _initialize_with_format_type_and_orientation_method_offset,
            "arg_types" : (agcom.INT, agcom.INT, agcom.LONG, agcom.LONG, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.IntArg, agmarshall.EnumArg(RASTER_FORMAT), agmarshall.EnumArg(RASTER_TYPE), agmarshall.EnumArg(RASTER_ORIENTATION), agmarshall.InterfaceOutArg,) }
    def initialize_with_format_type_and_orientation(self, width:int, height:int, rasterFormat:"RASTER_FORMAT", rasterType:"RASTER_TYPE", rasterOrientation:"RASTER_ORIENTATION") -> "RasterAttributes":
        """Initialize a new instance with the width and height of the raster in pixels, and the given raster format, raster type, and raster orientation."""
        return self._intf.invoke(IRasterAttributesFactory._metadata, IRasterAttributesFactory._initialize_with_format_type_and_orientation_metadata, width, height, rasterFormat, rasterType, rasterOrientation, OutArg())

    _initialize_with_format_type_orientation_and_alignment_metadata = { "offset" : _initialize_with_format_type_orientation_and_alignment_method_offset,
            "arg_types" : (agcom.INT, agcom.INT, agcom.LONG, agcom.LONG, agcom.LONG, agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.IntArg, agmarshall.EnumArg(RASTER_FORMAT), agmarshall.EnumArg(RASTER_TYPE), agmarshall.EnumArg(RASTER_ORIENTATION), agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_format_type_orientation_and_alignment(self, width:int, height:int, rasterFormat:"RASTER_FORMAT", rasterType:"RASTER_TYPE", rasterOrientation:"RASTER_ORIENTATION", rowAlignment:int) -> "RasterAttributes":
        """Initialize a new instance with the width and height of the raster in pixels, and the given raster format, raster type, raster orientation, and row alignment."""
        return self._intf.invoke(IRasterAttributesFactory._metadata, IRasterAttributesFactory._initialize_with_format_type_orientation_and_alignment_metadata, width, height, rasterFormat, rasterType, rasterOrientation, rowAlignment, OutArg())

    _initialize_with_format_type_orientation_alignment_and_ratio_metadata = { "offset" : _initialize_with_format_type_orientation_alignment_and_ratio_method_offset,
            "arg_types" : (agcom.INT, agcom.INT, agcom.LONG, agcom.LONG, agcom.LONG, agcom.INT, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.IntArg, agmarshall.EnumArg(RASTER_FORMAT), agmarshall.EnumArg(RASTER_TYPE), agmarshall.EnumArg(RASTER_ORIENTATION), agmarshall.IntArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_format_type_orientation_alignment_and_ratio(self, width:int, height:int, rasterFormat:"RASTER_FORMAT", rasterType:"RASTER_TYPE", rasterOrientation:"RASTER_ORIENTATION", rowAlignment:int, pixelAspectRatio:float) -> "RasterAttributes":
        """Initialize a new instance with the width and height of the raster in pixels, and the given raster format, raster type, raster orientation, row alignment, and pixel aspect ratio."""
        return self._intf.invoke(IRasterAttributesFactory._metadata, IRasterAttributesFactory._initialize_with_format_type_orientation_alignment_and_ratio_metadata, width, height, rasterFormat, rasterType, rasterOrientation, rowAlignment, pixelAspectRatio, OutArg())

    _initialize_with_raster_metadata = { "offset" : _initialize_with_raster_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("IRaster"), agmarshall.InterfaceOutArg,) }
    def initialize_with_raster(self, raster:"IRaster") -> "RasterAttributes":
        """Initialize a new instance with the attributes of the specified raster."""
        return self._intf.invoke(IRasterAttributesFactory._metadata, IRasterAttributesFactory._initialize_with_raster_metadata, raster, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5336522563649204217, 14499576022617050520), IRasterAttributesFactory)
agcls.AgTypeNameMap["IRasterAttributesFactory"] = IRasterAttributesFactory

class IRotateFilterFactory(object):
    """Rotate the source raster clockwise by the specified angle."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_with_angle_method_offset = 2
    _metadata = {
        "iid_data" : (5240676648511823743, 17133571259659274683),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IRotateFilterFactory."""
        initialize_from_source_object(self, sourceObject, IRotateFilterFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IRotateFilterFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IRotateFilterFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "RotateFilter":
        """Initialize a new instance."""
        return self._intf.invoke(IRotateFilterFactory._metadata, IRotateFilterFactory._initialize_metadata, OutArg())

    _initialize_with_angle_metadata = { "offset" : _initialize_with_angle_method_offset,
            "arg_types" : (agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_angle(self, rotateAngle:float) -> "RotateFilter":
        """Initialize a new instance with a counterclockwise rotation angle."""
        return self._intf.invoke(IRotateFilterFactory._metadata, IRotateFilterFactory._initialize_with_angle_metadata, rotateAngle, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5240676648511823743, 17133571259659274683), IRotateFilterFactory)
agcls.AgTypeNameMap["IRotateFilterFactory"] = IRotateFilterFactory

class ISequenceFilterFactory(object):
    """Apply a sequence of filters to the source raster in the order in which they were added. When continue on failure is set to true, subsequent filters will still be applied to the source raster even if one or more filters in the sequence cannot be applied."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _metadata = {
        "iid_data" : (5587979663179806180, 3523282917797772973),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ISequenceFilterFactory."""
        initialize_from_source_object(self, sourceObject, ISequenceFilterFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISequenceFilterFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ISequenceFilterFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "SequenceFilter":
        """Initialize a new instance."""
        return self._intf.invoke(ISequenceFilterFactory._metadata, ISequenceFilterFactory._initialize_metadata, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5587979663179806180, 3523282917797772973), ISequenceFilterFactory)
agcls.AgTypeNameMap["ISequenceFilterFactory"] = ISequenceFilterFactory

class ISharpenFilterFactory(object):
    """Apply a convolution filter to increase the sharpness of the source raster."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_with_method_method_offset = 2
    _metadata = {
        "iid_data" : (4682197851944489084, 17607540891949148056),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ISharpenFilterFactory."""
        initialize_from_source_object(self, sourceObject, ISharpenFilterFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISharpenFilterFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ISharpenFilterFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "SharpenFilter":
        """Initialize a new instance."""
        return self._intf.invoke(ISharpenFilterFactory._metadata, ISharpenFilterFactory._initialize_metadata, OutArg())

    _initialize_with_method_metadata = { "offset" : _initialize_with_method_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.EnumArg(SHARPEN_METHOD), agmarshall.InterfaceOutArg,) }
    def initialize_with_method(self, method:"SHARPEN_METHOD") -> "SharpenFilter":
        """Initialize a new instance with the specified sharpen method."""
        return self._intf.invoke(ISharpenFilterFactory._metadata, ISharpenFilterFactory._initialize_with_method_metadata, method, OutArg())


agcls.AgClassCatalog.add_catalog_entry((4682197851944489084, 17607540891949148056), ISharpenFilterFactory)
agcls.AgTypeNameMap["ISharpenFilterFactory"] = ISharpenFilterFactory

class IVideoStreamFactory(object):
    """A raster stream that streams from a video. The video can be read from a file, or streamed from an HTTP, RTP, UDP, or TCP source. See the Video Streams Overview for a list of supported video formats and Uri usage."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_with_string_uri_method_offset = 1
    _initialize_with_string_uri_and_audio_method_offset = 2
    _initialize_audio_video_with_string_uri_method_offset = 3
    _metadata = {
        "iid_data" : (5498557594880342087, 686594457555947395),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IVideoStreamFactory."""
        initialize_from_source_object(self, sourceObject, IVideoStreamFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVideoStreamFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IVideoStreamFactory, None)
    
    _initialize_with_string_uri_metadata = { "offset" : _initialize_with_string_uri_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_string_uri(self, uri:str) -> "VideoStream":
        """Initialize the video stream from a Uri, which can be a file, HTTP, RTP, UDP, or TCP source. See the Video Streams Overview for a list of supported video formats and Uri usage."""
        return self._intf.invoke(IVideoStreamFactory._metadata, IVideoStreamFactory._initialize_with_string_uri_metadata, uri, OutArg())

    _initialize_with_string_uri_and_audio_metadata = { "offset" : _initialize_with_string_uri_and_audio_method_offset,
            "arg_types" : (agcom.BSTR, agcom.VARIANT_BOOL, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.VariantBoolArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_string_uri_and_audio(self, uri:str, loadAudio:bool) -> "VideoStream":
        """Initialize the video stream from a Uri, which can be a file, HTTP, RTP, UDP, or TCP source. See the Video Streams Overview for a list of supported video formats and Uri usage."""
        return self._intf.invoke(IVideoStreamFactory._metadata, IVideoStreamFactory._initialize_with_string_uri_and_audio_metadata, uri, loadAudio, OutArg())

    _initialize_audio_video_with_string_uri_metadata = { "offset" : _initialize_audio_video_with_string_uri_method_offset,
            "arg_types" : (agcom.BSTR, agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def initialize_audio_video_with_string_uri(self, uri:str, audioUri:str) -> "VideoStream":
        """Initialize the video stream from a Uri, which can be a file, HTTP, RTP, UDP, or TCP source. See the Video Streams Overview for a list of supported video formats and Uri usage."""
        return self._intf.invoke(IVideoStreamFactory._metadata, IVideoStreamFactory._initialize_audio_video_with_string_uri_metadata, uri, audioUri, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5498557594880342087, 686594457555947395), IVideoStreamFactory)
agcls.AgTypeNameMap["IVideoStreamFactory"] = IVideoStreamFactory

class IMarkerBatchPrimitiveFactory(object):
    """Render one or more markers in the 3D scene. Markers are 2D images that always face the viewer which can be sized in pixels or meters. Markers are also referred to as sprites or billboards..."""

    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_with_set_hint_method_offset = 2
    _initialize_with_size_source_method_offset = 3
    _initialize_with_size_source_and_sort_order_method_offset = 4
    _initialize_size_source_sort_order_and_set_hint_method_offset = 5
    _initialize_size_source_sort_order_set_hint_and_rendering_method_method_offset = 6
    _supported_method_offset = 7
    _metadata = {
        "iid_data" : (4740266975557795230, 14085601220083607230),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IMarkerBatchPrimitiveFactory."""
        initialize_from_source_object(self, sourceObject, IMarkerBatchPrimitiveFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IMarkerBatchPrimitiveFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IMarkerBatchPrimitiveFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "MarkerBatchPrimitive":
        """Initialize a default marker batch primitive..."""
        return self._intf.invoke(IMarkerBatchPrimitiveFactory._metadata, IMarkerBatchPrimitiveFactory._initialize_metadata, OutArg())

    _initialize_with_set_hint_metadata = { "offset" : _initialize_with_set_hint_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.EnumArg(SET_HINT), agmarshall.InterfaceOutArg,) }
    def initialize_with_set_hint(self, setHint:"SET_HINT") -> "MarkerBatchPrimitive":
        """Initialize a marker batch primitive with the specified setHint..."""
        return self._intf.invoke(IMarkerBatchPrimitiveFactory._metadata, IMarkerBatchPrimitiveFactory._initialize_with_set_hint_metadata, setHint, OutArg())

    _initialize_with_size_source_metadata = { "offset" : _initialize_with_size_source_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.EnumArg(MARKER_BATCH_SIZE_SOURCE), agmarshall.InterfaceOutArg,) }
    def initialize_with_size_source(self, sizeSource:"MARKER_BATCH_SIZE_SOURCE") -> "MarkerBatchPrimitive":
        """Initialize a marker batch primitive with the specified sizeSource..."""
        return self._intf.invoke(IMarkerBatchPrimitiveFactory._metadata, IMarkerBatchPrimitiveFactory._initialize_with_size_source_metadata, sizeSource, OutArg())

    _initialize_with_size_source_and_sort_order_metadata = { "offset" : _initialize_with_size_source_and_sort_order_method_offset,
            "arg_types" : (agcom.LONG, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.EnumArg(MARKER_BATCH_SIZE_SOURCE), agmarshall.EnumArg(MARKER_BATCH_SORT_ORDER), agmarshall.InterfaceOutArg,) }
    def initialize_with_size_source_and_sort_order(self, sizeSource:"MARKER_BATCH_SIZE_SOURCE", sortOrder:"MARKER_BATCH_SORT_ORDER") -> "MarkerBatchPrimitive":
        """Initialize a marker batch primitive with the specified sizeSource and sortOrder..."""
        return self._intf.invoke(IMarkerBatchPrimitiveFactory._metadata, IMarkerBatchPrimitiveFactory._initialize_with_size_source_and_sort_order_metadata, sizeSource, sortOrder, OutArg())

    _initialize_size_source_sort_order_and_set_hint_metadata = { "offset" : _initialize_size_source_sort_order_and_set_hint_method_offset,
            "arg_types" : (agcom.LONG, agcom.LONG, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.EnumArg(MARKER_BATCH_SIZE_SOURCE), agmarshall.EnumArg(MARKER_BATCH_SORT_ORDER), agmarshall.EnumArg(SET_HINT), agmarshall.InterfaceOutArg,) }
    def initialize_size_source_sort_order_and_set_hint(self, sizeSource:"MARKER_BATCH_SIZE_SOURCE", sortOrder:"MARKER_BATCH_SORT_ORDER", setHint:"SET_HINT") -> "MarkerBatchPrimitive":
        """Initialize a marker batch primitive with the specified sizeSource, sortOrder, and setHint. This is equivalent to constructing a marker batch with the specified arguments and a marker batch rendering method of Automatic."""
        return self._intf.invoke(IMarkerBatchPrimitiveFactory._metadata, IMarkerBatchPrimitiveFactory._initialize_size_source_sort_order_and_set_hint_metadata, sizeSource, sortOrder, setHint, OutArg())

    _initialize_size_source_sort_order_set_hint_and_rendering_method_metadata = { "offset" : _initialize_size_source_sort_order_set_hint_and_rendering_method_method_offset,
            "arg_types" : (agcom.LONG, agcom.LONG, agcom.LONG, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.EnumArg(MARKER_BATCH_SIZE_SOURCE), agmarshall.EnumArg(MARKER_BATCH_SORT_ORDER), agmarshall.EnumArg(SET_HINT), agmarshall.EnumArg(MARKER_BATCH_RENDERING_METHOD), agmarshall.InterfaceOutArg,) }
    def initialize_size_source_sort_order_set_hint_and_rendering_method(self, sizeSource:"MARKER_BATCH_SIZE_SOURCE", sortOrder:"MARKER_BATCH_SORT_ORDER", setHint:"SET_HINT", renderingMethod:"MARKER_BATCH_RENDERING_METHOD") -> "MarkerBatchPrimitive":
        """Initialize a marker batch primitive with the specified arguments."""
        return self._intf.invoke(IMarkerBatchPrimitiveFactory._metadata, IMarkerBatchPrimitiveFactory._initialize_size_source_sort_order_set_hint_and_rendering_method_metadata, sizeSource, sortOrder, setHint, renderingMethod, OutArg())

    _supported_metadata = { "offset" : _supported_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.EnumArg(MARKER_BATCH_RENDERING_METHOD), agmarshall.VariantBoolArg,) }
    def supported(self, renderingMethod:"MARKER_BATCH_RENDERING_METHOD") -> bool:
        """Determine whether or not the video card supports the marker batch primitive with the given renderingMethod."""
        return self._intf.invoke(IMarkerBatchPrimitiveFactory._metadata, IMarkerBatchPrimitiveFactory._supported_metadata, renderingMethod, OutArg())


agcls.AgClassCatalog.add_catalog_entry((4740266975557795230, 14085601220083607230), IMarkerBatchPrimitiveFactory)
agcls.AgTypeNameMap["IMarkerBatchPrimitiveFactory"] = IMarkerBatchPrimitiveFactory

class IMarkerBatchPrimitiveOptionalParametersFactory(object):
    """Optional per-marker parameters for marker batch primitive that overrides the marker batch's per-batch parameters..."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _metadata = {
        "iid_data" : (5704811504883845547, 9106588384347128705),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IMarkerBatchPrimitiveOptionalParametersFactory."""
        initialize_from_source_object(self, sourceObject, IMarkerBatchPrimitiveOptionalParametersFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IMarkerBatchPrimitiveOptionalParametersFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IMarkerBatchPrimitiveOptionalParametersFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "MarkerBatchPrimitiveOptionalParameters":
        """Initialize default marker batch primitive optional parameters. All per-marker parameters are initially empty."""
        return self._intf.invoke(IMarkerBatchPrimitiveOptionalParametersFactory._metadata, IMarkerBatchPrimitiveOptionalParametersFactory._initialize_metadata, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5704811504883845547, 9106588384347128705), IMarkerBatchPrimitiveOptionalParametersFactory)
agcls.AgTypeNameMap["IMarkerBatchPrimitiveOptionalParametersFactory"] = IMarkerBatchPrimitiveOptionalParametersFactory

class IMaximumCountPathPrimitiveUpdatePolicyFactory(object):
    """path primitive update policy that removes points from remove location when the number of points in the path exceeds maximum count."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_with_parameters_method_offset = 2
    _metadata = {
        "iid_data" : (5761711104537625548, 13434309608184242870),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IMaximumCountPathPrimitiveUpdatePolicyFactory."""
        initialize_from_source_object(self, sourceObject, IMaximumCountPathPrimitiveUpdatePolicyFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IMaximumCountPathPrimitiveUpdatePolicyFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IMaximumCountPathPrimitiveUpdatePolicyFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "MaximumCountPathPrimitiveUpdatePolicy":
        """Construct a default update policy. This is equivalent to constructing a policy with maximum count set to 0 and a remove location of Front."""
        return self._intf.invoke(IMaximumCountPathPrimitiveUpdatePolicyFactory._metadata, IMaximumCountPathPrimitiveUpdatePolicyFactory._initialize_metadata, OutArg())

    _initialize_with_parameters_metadata = { "offset" : _initialize_with_parameters_method_offset,
            "arg_types" : (agcom.INT, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.EnumArg(PATH_PRIMITIVE_REMOVE_LOCATION), agmarshall.InterfaceOutArg,) }
    def initialize_with_parameters(self, maximumCount:int, removeLocation:"PATH_PRIMITIVE_REMOVE_LOCATION") -> "MaximumCountPathPrimitiveUpdatePolicy":
        """Initialize a policy with the specified maximumCount and removeLocation."""
        return self._intf.invoke(IMaximumCountPathPrimitiveUpdatePolicyFactory._metadata, IMaximumCountPathPrimitiveUpdatePolicyFactory._initialize_with_parameters_metadata, maximumCount, removeLocation, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5761711104537625548, 13434309608184242870), IMaximumCountPathPrimitiveUpdatePolicyFactory)
agcls.AgTypeNameMap["IMaximumCountPathPrimitiveUpdatePolicyFactory"] = IMaximumCountPathPrimitiveUpdatePolicyFactory

class IModelPrimitiveFactory(object):
    """The model primitive loads and renders `COLLADA <https://www.khronos.org/collada/>`_ (DAE) and AGI `MDL <https://support.agi.com/3d-models>`_ (MDL) models."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_with_string_uri_method_offset = 2
    _initialize_with_string_uri_and_up_axis_method_offset = 3
    _metadata = {
        "iid_data" : (5301455462249167343, 9954596141012220600),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IModelPrimitiveFactory."""
        initialize_from_source_object(self, sourceObject, IModelPrimitiveFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IModelPrimitiveFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IModelPrimitiveFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "ModelPrimitive":
        """Initialize a default model primitive."""
        return self._intf.invoke(IModelPrimitiveFactory._metadata, IModelPrimitiveFactory._initialize_metadata, OutArg())

    _initialize_with_string_uri_metadata = { "offset" : _initialize_with_string_uri_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_string_uri(self, uri:str) -> "ModelPrimitive":
        """For convenience. Initializes a model primitive with the specified file path."""
        return self._intf.invoke(IModelPrimitiveFactory._metadata, IModelPrimitiveFactory._initialize_with_string_uri_metadata, uri, OutArg())

    _initialize_with_string_uri_and_up_axis_metadata = { "offset" : _initialize_with_string_uri_and_up_axis_method_offset,
            "arg_types" : (agcom.BSTR, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.EnumArg(MODEL_UP_AXIS), agmarshall.InterfaceOutArg,) }
    def initialize_with_string_uri_and_up_axis(self, uri:str, upAxis:"MODEL_UP_AXIS") -> "ModelPrimitive":
        """For convenience. Initializes a model primitive with the specified file path and up axis."""
        return self._intf.invoke(IModelPrimitiveFactory._metadata, IModelPrimitiveFactory._initialize_with_string_uri_and_up_axis_metadata, uri, upAxis, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5301455462249167343, 9954596141012220600), IModelPrimitiveFactory)
agcls.AgTypeNameMap["IModelPrimitiveFactory"] = IModelPrimitiveFactory

class IPathPrimitiveFactory(object):
    """Render a line to the 3D scene. Similar to the polyline primitive; however, the PathPrimitive was designed for the efficient addition/removal of points to/from the front or back of the line."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_with_capacity_method_offset = 2
    _get_minimum_width_supported_method_offset = 3
    _get_maximum_width_supported_method_offset = 4
    _metadata = {
        "iid_data" : (5436433891631798468, 16722405859623817126),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IPathPrimitiveFactory."""
        initialize_from_source_object(self, sourceObject, IPathPrimitiveFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IPathPrimitiveFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IPathPrimitiveFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "PathPrimitive":
        """Initialize a default path primitive. This is equivalent to constructing a path primitive with an initial capacity of 16."""
        return self._intf.invoke(IPathPrimitiveFactory._metadata, IPathPrimitiveFactory._initialize_metadata, OutArg())

    _initialize_with_capacity_metadata = { "offset" : _initialize_with_capacity_method_offset,
            "arg_types" : (agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_capacity(self, capacity:int) -> "PathPrimitive":
        """Initialize a path primitive with the specified capacity."""
        return self._intf.invoke(IPathPrimitiveFactory._metadata, IPathPrimitiveFactory._initialize_with_capacity_metadata, capacity, OutArg())

    _get_minimum_width_supported_metadata = { "offset" : _get_minimum_width_supported_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def minimum_width_supported(self) -> float:
        """Get the minimum width, in pixels, supported by the video card."""
        return self._intf.get_property(IPathPrimitiveFactory._metadata, IPathPrimitiveFactory._get_minimum_width_supported_metadata)

    _get_maximum_width_supported_metadata = { "offset" : _get_maximum_width_supported_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def maximum_width_supported(self) -> float:
        """Get the maximum width, in pixels, supported by the video card."""
        return self._intf.get_property(IPathPrimitiveFactory._metadata, IPathPrimitiveFactory._get_maximum_width_supported_metadata)

    _property_names[minimum_width_supported] = "minimum_width_supported"
    _property_names[maximum_width_supported] = "maximum_width_supported"


agcls.AgClassCatalog.add_catalog_entry((5436433891631798468, 16722405859623817126), IPathPrimitiveFactory)
agcls.AgTypeNameMap["IPathPrimitiveFactory"] = IPathPrimitiveFactory

class IPixelSizeDisplayConditionFactory(object):
    """Define an inclusive interval, in pixels, that determines when an object, such as a primitive, is rendered based on the number of pixels the object's bounding sphere (or in the case of screen overlays, bounding rectangle) covers on the screen..."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_with_pixel_sizes_method_offset = 2
    _metadata = {
        "iid_data" : (4681924990914507923, 13188823909685682869),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IPixelSizeDisplayConditionFactory."""
        initialize_from_source_object(self, sourceObject, IPixelSizeDisplayConditionFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IPixelSizeDisplayConditionFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IPixelSizeDisplayConditionFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "PixelSizeDisplayCondition":
        """Initialize a default pixel size display condition. minimum pixel size is set to 0 and maximum pixel size is set to Int32.MaxValue. With this interval, an object is always rendered regardless of how many pixels its bounding sphere or rectangle covers."""
        return self._intf.invoke(IPixelSizeDisplayConditionFactory._metadata, IPixelSizeDisplayConditionFactory._initialize_metadata, OutArg())

    _initialize_with_pixel_sizes_metadata = { "offset" : _initialize_with_pixel_sizes_method_offset,
            "arg_types" : (agcom.INT, agcom.INT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.IntArg, agmarshall.IntArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_pixel_sizes(self, minimumPixelSize:int, maximumPixelSize:int) -> "PixelSizeDisplayCondition":
        """Initialize a pixel size display condition with the inclusive interval [minimumPixelSize, maximumPixelSize]..."""
        return self._intf.invoke(IPixelSizeDisplayConditionFactory._metadata, IPixelSizeDisplayConditionFactory._initialize_with_pixel_sizes_metadata, minimumPixelSize, maximumPixelSize, OutArg())


agcls.AgClassCatalog.add_catalog_entry((4681924990914507923, 13188823909685682869), IPixelSizeDisplayConditionFactory)
agcls.AgTypeNameMap["IPixelSizeDisplayConditionFactory"] = IPixelSizeDisplayConditionFactory

class IPointBatchPrimitiveFactory(object):
    """Render one or more points in the 3D scene. Each point in the batch has a unique position and an optional color. All points in the batch share the same pixel size. For best performance, avoid creating lots of batches with only a few points each..."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_with_set_hint_method_offset = 2
    _get_minimum_pixel_size_supported_method_offset = 3
    _get_maximum_pixel_size_supported_method_offset = 4
    _metadata = {
        "iid_data" : (5218604623078634625, 4366017649238359959),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IPointBatchPrimitiveFactory."""
        initialize_from_source_object(self, sourceObject, IPointBatchPrimitiveFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IPointBatchPrimitiveFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IPointBatchPrimitiveFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "PointBatchPrimitive":
        """Initialize a default point batch primitive. This is equivalent to constructing a point batch with a set hint of Frequent."""
        return self._intf.invoke(IPointBatchPrimitiveFactory._metadata, IPointBatchPrimitiveFactory._initialize_metadata, OutArg())

    _initialize_with_set_hint_metadata = { "offset" : _initialize_with_set_hint_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.EnumArg(SET_HINT), agmarshall.InterfaceOutArg,) }
    def initialize_with_set_hint(self, setHint:"SET_HINT") -> "PointBatchPrimitive":
        """Initialize a new instance of a point batch primitive with the specified set hint."""
        return self._intf.invoke(IPointBatchPrimitiveFactory._metadata, IPointBatchPrimitiveFactory._initialize_with_set_hint_metadata, setHint, OutArg())

    _get_minimum_pixel_size_supported_metadata = { "offset" : _get_minimum_pixel_size_supported_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def minimum_pixel_size_supported(self) -> float:
        """Get the minimum pixel size supported by the video card."""
        return self._intf.get_property(IPointBatchPrimitiveFactory._metadata, IPointBatchPrimitiveFactory._get_minimum_pixel_size_supported_metadata)

    _get_maximum_pixel_size_supported_metadata = { "offset" : _get_maximum_pixel_size_supported_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def maximum_pixel_size_supported(self) -> float:
        """Get the maximum pixel size supported by the video card."""
        return self._intf.get_property(IPointBatchPrimitiveFactory._metadata, IPointBatchPrimitiveFactory._get_maximum_pixel_size_supported_metadata)

    _property_names[minimum_pixel_size_supported] = "minimum_pixel_size_supported"
    _property_names[maximum_pixel_size_supported] = "maximum_pixel_size_supported"


agcls.AgClassCatalog.add_catalog_entry((5218604623078634625, 4366017649238359959), IPointBatchPrimitiveFactory)
agcls.AgTypeNameMap["IPointBatchPrimitiveFactory"] = IPointBatchPrimitiveFactory

class IPointBatchPrimitiveOptionalParametersFactory(object):
    """Optional per-point parameters for point batch primitive that overrides the point batch primitive's global parameters..."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _metadata = {
        "iid_data" : (4885163820542613066, 2017832262353669783),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IPointBatchPrimitiveOptionalParametersFactory."""
        initialize_from_source_object(self, sourceObject, IPointBatchPrimitiveOptionalParametersFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IPointBatchPrimitiveOptionalParametersFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IPointBatchPrimitiveOptionalParametersFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "PointBatchPrimitiveOptionalParameters":
        """Initialize a default point batch primitive optional parameters object."""
        return self._intf.invoke(IPointBatchPrimitiveOptionalParametersFactory._metadata, IPointBatchPrimitiveOptionalParametersFactory._initialize_metadata, OutArg())


agcls.AgClassCatalog.add_catalog_entry((4885163820542613066, 2017832262353669783), IPointBatchPrimitiveOptionalParametersFactory)
agcls.AgTypeNameMap["IPointBatchPrimitiveOptionalParametersFactory"] = IPointBatchPrimitiveOptionalParametersFactory

class IPolylinePrimitiveFactory(object):
    """Render a polyline in the 3D scene. Each line segment may have a different color. A polyline can be constructed with a position interpolator to render great arcs or rhumb lines."""

    _num_methods = 8
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_with_interpolator_and_set_hint_method_offset = 2
    _initialize_with_type_and_hint_method_offset = 3
    _initialize_with_interpolator_method_offset = 4
    _initialize_with_hint_method_offset = 5
    _initialize_with_type_method_offset = 6
    _get_minimum_width_supported_method_offset = 7
    _get_maximum_width_supported_method_offset = 8
    _metadata = {
        "iid_data" : (5301936144297127971, 15596667008171036314),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IPolylinePrimitiveFactory."""
        initialize_from_source_object(self, sourceObject, IPolylinePrimitiveFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IPolylinePrimitiveFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IPolylinePrimitiveFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "PolylinePrimitive":
        """Initialize a default polyline primitive. This is equivalent to constructing a polyline with a set hint of Frequent and a polyline type of LineStrip."""
        return self._intf.invoke(IPolylinePrimitiveFactory._metadata, IPolylinePrimitiveFactory._initialize_metadata, OutArg())

    _initialize_with_interpolator_and_set_hint_metadata = { "offset" : _initialize_with_interpolator_and_set_hint_method_offset,
            "arg_types" : (agcom.PVOID, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("IPositionInterpolator"), agmarshall.EnumArg(SET_HINT), agmarshall.InterfaceOutArg,) }
    def initialize_with_interpolator_and_set_hint(self, interpolator:"IPositionInterpolator", setHint:"SET_HINT") -> "PolylinePrimitive":
        """Initialize a polyline primitive with the specified interpolator and setHint."""
        return self._intf.invoke(IPolylinePrimitiveFactory._metadata, IPolylinePrimitiveFactory._initialize_with_interpolator_and_set_hint_metadata, interpolator, setHint, OutArg())

    _initialize_with_type_and_hint_metadata = { "offset" : _initialize_with_type_and_hint_method_offset,
            "arg_types" : (agcom.LONG, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.EnumArg(POLYLINE_TYPE), agmarshall.EnumArg(SET_HINT), agmarshall.InterfaceOutArg,) }
    def initialize_with_type_and_hint(self, polylineType:"POLYLINE_TYPE", setHint:"SET_HINT") -> "PolylinePrimitive":
        """Initialize a new instance of a polyline primitive with the specified polylineType and setHint."""
        return self._intf.invoke(IPolylinePrimitiveFactory._metadata, IPolylinePrimitiveFactory._initialize_with_type_and_hint_metadata, polylineType, setHint, OutArg())

    _initialize_with_interpolator_metadata = { "offset" : _initialize_with_interpolator_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("IPositionInterpolator"), agmarshall.InterfaceOutArg,) }
    def initialize_with_interpolator(self, interpolator:"IPositionInterpolator") -> "PolylinePrimitive":
        """Initialize a polyline primitive with the specified interpolator. This is equivalent to constructing a polyline with the specified interpolator and a set hint of Frequent."""
        return self._intf.invoke(IPolylinePrimitiveFactory._metadata, IPolylinePrimitiveFactory._initialize_with_interpolator_metadata, interpolator, OutArg())

    _initialize_with_hint_metadata = { "offset" : _initialize_with_hint_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.EnumArg(SET_HINT), agmarshall.InterfaceOutArg,) }
    def initialize_with_hint(self, setHint:"SET_HINT") -> "PolylinePrimitive":
        """Initialize a new instance of a polyline primitive with the specified set hint. This is equivalent to constructing a polyline with a polyline type of LineStrip and the specified set hint."""
        return self._intf.invoke(IPolylinePrimitiveFactory._metadata, IPolylinePrimitiveFactory._initialize_with_hint_metadata, setHint, OutArg())

    _initialize_with_type_metadata = { "offset" : _initialize_with_type_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.EnumArg(POLYLINE_TYPE), agmarshall.InterfaceOutArg,) }
    def initialize_with_type(self, polylineType:"POLYLINE_TYPE") -> "PolylinePrimitive":
        """Initialize a polyline primitive with the specified polylineType. This is equivalent to constructing a polyline with the specified polylineType and a set hint of Frequent."""
        return self._intf.invoke(IPolylinePrimitiveFactory._metadata, IPolylinePrimitiveFactory._initialize_with_type_metadata, polylineType, OutArg())

    _get_minimum_width_supported_metadata = { "offset" : _get_minimum_width_supported_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def minimum_width_supported(self) -> float:
        """Get the minimum width, in pixels, supported by the video card."""
        return self._intf.get_property(IPolylinePrimitiveFactory._metadata, IPolylinePrimitiveFactory._get_minimum_width_supported_metadata)

    _get_maximum_width_supported_metadata = { "offset" : _get_maximum_width_supported_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def maximum_width_supported(self) -> float:
        """Get the maximum width, in pixels, supported by the video card."""
        return self._intf.get_property(IPolylinePrimitiveFactory._metadata, IPolylinePrimitiveFactory._get_maximum_width_supported_metadata)

    _property_names[minimum_width_supported] = "minimum_width_supported"
    _property_names[maximum_width_supported] = "maximum_width_supported"


agcls.AgClassCatalog.add_catalog_entry((5301936144297127971, 15596667008171036314), IPolylinePrimitiveFactory)
agcls.AgTypeNameMap["IPolylinePrimitiveFactory"] = IPolylinePrimitiveFactory

class IPolylinePrimitiveOptionalParametersFactory(object):
    """Optional per-point or per-segment parameters for polyline primitive that overrides the polyline primitive's global parameters..."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _metadata = {
        "iid_data" : (4737181717956226779, 7764712259800602242),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IPolylinePrimitiveOptionalParametersFactory."""
        initialize_from_source_object(self, sourceObject, IPolylinePrimitiveOptionalParametersFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IPolylinePrimitiveOptionalParametersFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IPolylinePrimitiveOptionalParametersFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "PolylinePrimitiveOptionalParameters":
        """Initialize default polyline primitive optional parameters. All per-segment parameters are initially empty."""
        return self._intf.invoke(IPolylinePrimitiveOptionalParametersFactory._metadata, IPolylinePrimitiveOptionalParametersFactory._initialize_metadata, OutArg())


agcls.AgClassCatalog.add_catalog_entry((4737181717956226779, 7764712259800602242), IPolylinePrimitiveOptionalParametersFactory)
agcls.AgTypeNameMap["IPolylinePrimitiveOptionalParametersFactory"] = IPolylinePrimitiveOptionalParametersFactory

class IRasterImageGlobeOverlayFactory(object):
    """A globe image overlay for handling rasters."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_with_string_method_offset = 1
    _initialize_with_color_method_offset = 2
    _initialize_with_raster_method_offset = 3
    _metadata = {
        "iid_data" : (4620879928510913607, 1411633616491735460),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IRasterImageGlobeOverlayFactory."""
        initialize_from_source_object(self, sourceObject, IRasterImageGlobeOverlayFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IRasterImageGlobeOverlayFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IRasterImageGlobeOverlayFactory, None)
    
    _initialize_with_string_metadata = { "offset" : _initialize_with_string_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.LPSafearrayArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_string(self, uri:str, extent:list) -> "RasterImageGlobeOverlay":
        """Initialize a raster image globe overlay with the provided values."""
        return self._intf.invoke(IRasterImageGlobeOverlayFactory._metadata, IRasterImageGlobeOverlayFactory._initialize_with_string_metadata, uri, extent, OutArg())

    _initialize_with_color_metadata = { "offset" : _initialize_with_color_method_offset,
            "arg_types" : (agcom.OLE_COLOR, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.OLEColorArg, agmarshall.LPSafearrayArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_color(self, color:agcolor.Color, extent:list) -> "RasterImageGlobeOverlay":
        """Initialize a raster image globe overlay with the provided values."""
        return self._intf.invoke(IRasterImageGlobeOverlayFactory._metadata, IRasterImageGlobeOverlayFactory._initialize_with_color_metadata, color, extent, OutArg())

    _initialize_with_raster_metadata = { "offset" : _initialize_with_raster_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("IRaster"), agmarshall.LPSafearrayArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_raster(self, raster:"IRaster", extent:list) -> "RasterImageGlobeOverlay":
        """Initialize a raster image globe overlay with the provided values."""
        return self._intf.invoke(IRasterImageGlobeOverlayFactory._metadata, IRasterImageGlobeOverlayFactory._initialize_with_raster_metadata, raster, extent, OutArg())


agcls.AgClassCatalog.add_catalog_entry((4620879928510913607, 1411633616491735460), IRasterImageGlobeOverlayFactory)
agcls.AgTypeNameMap["IRasterImageGlobeOverlayFactory"] = IRasterImageGlobeOverlayFactory

class IRhumbLineInterpolatorFactory(object):
    """The rhumb line interpolator computes interpolated positions along a rhumb line. Rhumb lines are lines of constant bearing. They appear as straight lines on a Mercator 2D map projection and are well suited to navigation."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_with_central_body_method_offset = 2
    _initialize_with_central_body_and_granularity_method_offset = 3
    _metadata = {
        "iid_data" : (4835289897607660920, 17725573476645597853),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IRhumbLineInterpolatorFactory."""
        initialize_from_source_object(self, sourceObject, IRhumbLineInterpolatorFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IRhumbLineInterpolatorFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IRhumbLineInterpolatorFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "RhumbLineInterpolator":
        """Initialize a default rhumb line interpolator. This is equivalent to constructing a rhumb line interpolator with a central body equal to an instance of earth central body and a granularity of 1 degree."""
        return self._intf.invoke(IRhumbLineInterpolatorFactory._metadata, IRhumbLineInterpolatorFactory._initialize_metadata, OutArg())

    _initialize_with_central_body_metadata = { "offset" : _initialize_with_central_body_method_offset,
            "arg_types" : (agcom.BSTR, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_central_body(self, centralBody:str) -> "RhumbLineInterpolator":
        """Initialize a rhumb line interpolator with the specified centralBody and a granularity of 1 degree."""
        return self._intf.invoke(IRhumbLineInterpolatorFactory._metadata, IRhumbLineInterpolatorFactory._initialize_with_central_body_metadata, centralBody, OutArg())

    _initialize_with_central_body_and_granularity_metadata = { "offset" : _initialize_with_central_body_and_granularity_method_offset,
            "arg_types" : (agcom.BSTR, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.BStrArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_central_body_and_granularity(self, centralBody:str, granularity:float) -> "RhumbLineInterpolator":
        """Initialize a rhumb line interpolator with the specified centralBody and granularity."""
        return self._intf.invoke(IRhumbLineInterpolatorFactory._metadata, IRhumbLineInterpolatorFactory._initialize_with_central_body_and_granularity_metadata, centralBody, granularity, OutArg())


agcls.AgClassCatalog.add_catalog_entry((4835289897607660920, 17725573476645597853), IRhumbLineInterpolatorFactory)
agcls.AgTypeNameMap["IRhumbLineInterpolatorFactory"] = IRhumbLineInterpolatorFactory

class ISceneDisplayConditionFactory(object):
    """A display condition used to control what scene or scenes an object, such as a primitive, is rendered in. This is used to show an object in some scenes and hide it in others."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _metadata = {
        "iid_data" : (5004939080556423671, 17828803048943882145),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ISceneDisplayConditionFactory."""
        initialize_from_source_object(self, sourceObject, ISceneDisplayConditionFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISceneDisplayConditionFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ISceneDisplayConditionFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "SceneDisplayCondition":
        """Initialize a default scene display condition. When this display condition is assigned to an object, such as a primitive, the object can be restricted to only render in certain scenes. Call set display in scene or display only in scene to limit the scenes."""
        return self._intf.invoke(ISceneDisplayConditionFactory._metadata, ISceneDisplayConditionFactory._initialize_metadata, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5004939080556423671, 17828803048943882145), ISceneDisplayConditionFactory)
agcls.AgTypeNameMap["ISceneDisplayConditionFactory"] = ISceneDisplayConditionFactory

class ISceneManagerInitializer(object):
    """The static scene manager class provides global properties and functionality that apply to all scenes and thus affect the rendering of every globe control..."""

    _num_methods = 7
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_primitives_method_offset = 1
    _get_screen_overlays_method_offset = 2
    _get_textures_method_offset = 3
    _get_globe_overlay_settings_method_offset = 4
    _get_scenes_method_offset = 5
    _render_method_offset = 6
    _get_frame_rate_method_offset = 7
    _metadata = {
        "iid_data" : (4764845724145475362, 5223354733627785103),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ISceneManagerInitializer."""
        initialize_from_source_object(self, sourceObject, ISceneManagerInitializer)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISceneManagerInitializer)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ISceneManagerInitializer, None)
    
    _get_primitives_metadata = { "offset" : _get_primitives_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def primitives(self) -> "PrimitiveManager":
        """Get the primitive manager, which is used to add primitives to your scenes."""
        return self._intf.get_property(ISceneManagerInitializer._metadata, ISceneManagerInitializer._get_primitives_metadata)

    _get_screen_overlays_metadata = { "offset" : _get_screen_overlays_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def screen_overlays(self) -> "ScreenOverlayManager":
        """Get the screen overlay manager, which is used to add screen overlays to your scenes."""
        return self._intf.get_property(ISceneManagerInitializer._metadata, ISceneManagerInitializer._get_screen_overlays_metadata)

    _get_textures_metadata = { "offset" : _get_textures_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def textures(self) -> "Texture2DFactory":
        """Get the texture 2d factory, which can be used to create textures from various sources."""
        return self._intf.get_property(ISceneManagerInitializer._metadata, ISceneManagerInitializer._get_textures_metadata)

    _get_globe_overlay_settings_metadata = { "offset" : _get_globe_overlay_settings_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def globe_overlay_settings(self) -> "GlobeOverlaySettings":
        """Get the globe overlay settings, which are used to set global settings for all globe overlays."""
        return self._intf.get_property(ISceneManagerInitializer._metadata, ISceneManagerInitializer._get_globe_overlay_settings_metadata)

    _get_scenes_metadata = { "offset" : _get_scenes_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def scenes(self) -> "SceneCollection":
        """Get a read-only collection of scenes that are associated with the scene manager."""
        return self._intf.get_property(ISceneManagerInitializer._metadata, ISceneManagerInitializer._get_scenes_metadata)

    _render_metadata = { "offset" : _render_method_offset,
            "arg_types" : (),
            "marshallers" : () }
    def render(self) -> None:
        """Render all scenes within an application. To render a specific scene, use the Render method."""
        return self._intf.invoke(ISceneManagerInitializer._metadata, ISceneManagerInitializer._render_metadata, )

    _get_frame_rate_metadata = { "offset" : _get_frame_rate_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    @property
    def frame_rate(self) -> "FrameRate":
        """Get the frame rate class, which can be used to keep track of how fast scenes are being <see ref='Render'>rendered</see>."""
        return self._intf.get_property(ISceneManagerInitializer._metadata, ISceneManagerInitializer._get_frame_rate_metadata)

    _property_names[primitives] = "primitives"
    _property_names[screen_overlays] = "screen_overlays"
    _property_names[textures] = "textures"
    _property_names[globe_overlay_settings] = "globe_overlay_settings"
    _property_names[scenes] = "scenes"
    _property_names[frame_rate] = "frame_rate"


agcls.AgClassCatalog.add_catalog_entry((4764845724145475362, 5223354733627785103), ISceneManagerInitializer)
agcls.AgTypeNameMap["ISceneManagerInitializer"] = ISceneManagerInitializer

class IScreenOverlayFactory(object):
    """A visible element drawn in screen space. Overlays are useful for floating logos, heads up displays, and integrating user interfaces into the 3D window."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_with_position_and_size_method_offset = 2
    _metadata = {
        "iid_data" : (5490706254163954986, 4226664079135707799),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IScreenOverlayFactory."""
        initialize_from_source_object(self, sourceObject, IScreenOverlayFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IScreenOverlayFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IScreenOverlayFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def initialize(self, xPixels:float, yPixels:float, widthPixels:float, heightPixels:float) -> "IScreenOverlay":
        """Initialize the overlay with the specified x position, y position, width, and height, all specified in pixels."""
        return self._intf.invoke(IScreenOverlayFactory._metadata, IScreenOverlayFactory._initialize_metadata, xPixels, yPixels, widthPixels, heightPixels, OutArg())

    _initialize_with_position_and_size_metadata = { "offset" : _initialize_with_position_and_size_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_position_and_size(self, position:list, size:list) -> "IScreenOverlay":
        """Initialize the overlay with the specified position and size."""
        return self._intf.invoke(IScreenOverlayFactory._metadata, IScreenOverlayFactory._initialize_with_position_and_size_metadata, position, size, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5490706254163954986, 4226664079135707799), IScreenOverlayFactory)
agcls.AgTypeNameMap["IScreenOverlayFactory"] = IScreenOverlayFactory

class ISolidPrimitiveFactory(object):
    """Render filled solid objects and their outlines. Example solids include boxes and ellipsoids. Various effects are supported, such as displaying the solid's silhouette, and hiding the outline of the backside of the solid..."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_with_hint_method_offset = 2
    _get_minimum_silhouette_width_supported_method_offset = 3
    _get_maximum_silhouette_width_supported_method_offset = 4
    _metadata = {
        "iid_data" : (4737869738299381948, 247291155508267666),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ISolidPrimitiveFactory."""
        initialize_from_source_object(self, sourceObject, ISolidPrimitiveFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISolidPrimitiveFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ISolidPrimitiveFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "SolidPrimitive":
        """Initialize a default solid primitive. This is equivalent to constructing a solid primitive with a set hint of Frequent."""
        return self._intf.invoke(ISolidPrimitiveFactory._metadata, ISolidPrimitiveFactory._initialize_metadata, OutArg())

    _initialize_with_hint_metadata = { "offset" : _initialize_with_hint_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.EnumArg(SET_HINT), agmarshall.InterfaceOutArg,) }
    def initialize_with_hint(self, setHint:"SET_HINT") -> "SolidPrimitive":
        """Initialize a solid primitive with the specified setHint."""
        return self._intf.invoke(ISolidPrimitiveFactory._metadata, ISolidPrimitiveFactory._initialize_with_hint_metadata, setHint, OutArg())

    _get_minimum_silhouette_width_supported_metadata = { "offset" : _get_minimum_silhouette_width_supported_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def minimum_silhouette_width_supported(self) -> float:
        """Get the minimum silhouette width, in pixels, supported by the video card."""
        return self._intf.get_property(ISolidPrimitiveFactory._metadata, ISolidPrimitiveFactory._get_minimum_silhouette_width_supported_metadata)

    _get_maximum_silhouette_width_supported_metadata = { "offset" : _get_maximum_silhouette_width_supported_method_offset,
            "arg_types" : (POINTER(agcom.FLOAT),),
            "marshallers" : (agmarshall.FloatArg,) }
    @property
    def maximum_silhouette_width_supported(self) -> float:
        """Get the maximum silhouette width, in pixels, supported by the video card."""
        return self._intf.get_property(ISolidPrimitiveFactory._metadata, ISolidPrimitiveFactory._get_maximum_silhouette_width_supported_metadata)

    _property_names[minimum_silhouette_width_supported] = "minimum_silhouette_width_supported"
    _property_names[maximum_silhouette_width_supported] = "maximum_silhouette_width_supported"


agcls.AgClassCatalog.add_catalog_entry((4737869738299381948, 247291155508267666), ISolidPrimitiveFactory)
agcls.AgTypeNameMap["ISolidPrimitiveFactory"] = ISolidPrimitiveFactory

class ISurfaceMeshPrimitiveFactory(object):
    """A triangle mesh primitive for meshes on the surface that need to conform to terrain."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_with_set_hint_method_offset = 2
    _initialize_with_set_hint_and_rendering_method_method_offset = 3
    _supported_method_offset = 4
    _supported_with_default_rendering_method_method_offset = 5
    _metadata = {
        "iid_data" : (4749341507117633803, 3018297532513505427),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ISurfaceMeshPrimitiveFactory."""
        initialize_from_source_object(self, sourceObject, ISurfaceMeshPrimitiveFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ISurfaceMeshPrimitiveFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ISurfaceMeshPrimitiveFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "SurfaceMeshPrimitive":
        """Initialize a default surface mesh primitive. This is equivalent to constructing a surface mesh with a set hint of Frequent and a surface mesh rendering method of Automatic."""
        return self._intf.invoke(ISurfaceMeshPrimitiveFactory._metadata, ISurfaceMeshPrimitiveFactory._initialize_metadata, OutArg())

    _initialize_with_set_hint_metadata = { "offset" : _initialize_with_set_hint_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.EnumArg(SET_HINT), agmarshall.InterfaceOutArg,) }
    def initialize_with_set_hint(self, setHint:"SET_HINT") -> "SurfaceMeshPrimitive":
        """Initialize a surface mesh primitive with the specified setHint. This is equivalent to constructing a surface mesh with the specified setHint and a surface mesh rendering method of Automatic."""
        return self._intf.invoke(ISurfaceMeshPrimitiveFactory._metadata, ISurfaceMeshPrimitiveFactory._initialize_with_set_hint_metadata, setHint, OutArg())

    _initialize_with_set_hint_and_rendering_method_metadata = { "offset" : _initialize_with_set_hint_and_rendering_method_method_offset,
            "arg_types" : (agcom.LONG, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.EnumArg(SET_HINT), agmarshall.EnumArg(SURFACE_MESH_RENDERING_METHOD), agmarshall.InterfaceOutArg,) }
    def initialize_with_set_hint_and_rendering_method(self, setHint:"SET_HINT", renderingMethod:"SURFACE_MESH_RENDERING_METHOD") -> "SurfaceMeshPrimitive":
        """Initialize a surface mesh primitive with the specified setHint and renderingMethod."""
        return self._intf.invoke(ISurfaceMeshPrimitiveFactory._metadata, ISurfaceMeshPrimitiveFactory._initialize_with_set_hint_and_rendering_method_metadata, setHint, renderingMethod, OutArg())

    _supported_metadata = { "offset" : _supported_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.EnumArg(SURFACE_MESH_RENDERING_METHOD), agmarshall.VariantBoolArg,) }
    def supported(self, renderingMethod:"SURFACE_MESH_RENDERING_METHOD") -> bool:
        """Determine whether or not the video card supports the surface mesh primitive with the given renderingMethod."""
        return self._intf.invoke(ISurfaceMeshPrimitiveFactory._metadata, ISurfaceMeshPrimitiveFactory._supported_metadata, renderingMethod, OutArg())

    _supported_with_default_rendering_method_metadata = { "offset" : _supported_with_default_rendering_method_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    def supported_with_default_rendering_method(self) -> bool:
        """Determine whether or not the video card supports the surface mesh primitive. This is equivalent to calling Supported with automatic."""
        return self._intf.invoke(ISurfaceMeshPrimitiveFactory._metadata, ISurfaceMeshPrimitiveFactory._supported_with_default_rendering_method_metadata, OutArg())


agcls.AgClassCatalog.add_catalog_entry((4749341507117633803, 3018297532513505427), ISurfaceMeshPrimitiveFactory)
agcls.AgTypeNameMap["ISurfaceMeshPrimitiveFactory"] = ISurfaceMeshPrimitiveFactory

class ITerrainOverlayInitializer(object):
    """A globe overlay which shows terrain."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _get_supported_method_offset = 1
    _metadata = {
        "iid_data" : (5323128820184689886, 9440148327257391495),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ITerrainOverlayInitializer."""
        initialize_from_source_object(self, sourceObject, ITerrainOverlayInitializer)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITerrainOverlayInitializer)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ITerrainOverlayInitializer, None)
    
    _get_supported_metadata = { "offset" : _get_supported_method_offset,
            "arg_types" : (POINTER(agcom.VARIANT_BOOL),),
            "marshallers" : (agmarshall.VariantBoolArg,) }
    @property
    def supported(self) -> bool:
        """Get whether the video card supports adding terrain overlay objects. Video cards that support OpenGL 1.2 or higher support terrain overlay objects."""
        return self._intf.get_property(ITerrainOverlayInitializer._metadata, ITerrainOverlayInitializer._get_supported_metadata)

    _property_names[supported] = "supported"


agcls.AgClassCatalog.add_catalog_entry((5323128820184689886, 9440148327257391495), ITerrainOverlayInitializer)
agcls.AgTypeNameMap["ITerrainOverlayInitializer"] = ITerrainOverlayInitializer

class ITextBatchPrimitiveFactory(object):
    """Render one or more strings in the 3D scene. For best performance, avoid creating lots of batches with only a few strings each. See the Batching Performance Overview. """

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_with_graphics_font_method_offset = 1
    _initialize_with_graphics_font_and_set_hint_method_offset = 2
    _initialize_with_graphics_font_and_set_hint_2d_method_offset = 3
    _metadata = {
        "iid_data" : (5099738729577984699, 4201041305732506785),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ITextBatchPrimitiveFactory."""
        initialize_from_source_object(self, sourceObject, ITextBatchPrimitiveFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITextBatchPrimitiveFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ITextBatchPrimitiveFactory, None)
    
    _initialize_with_graphics_font_metadata = { "offset" : _initialize_with_graphics_font_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("IGraphicsFont"), agmarshall.InterfaceOutArg,) }
    def initialize_with_graphics_font(self, font:"IGraphicsFont") -> "TextBatchPrimitive":
        """Initialize a marker batch primitive with the specified font. This is equivalent to constructing a text batch with the specified font and a set hint of Frequent."""
        return self._intf.invoke(ITextBatchPrimitiveFactory._metadata, ITextBatchPrimitiveFactory._initialize_with_graphics_font_metadata, font, OutArg())

    _initialize_with_graphics_font_and_set_hint_metadata = { "offset" : _initialize_with_graphics_font_and_set_hint_method_offset,
            "arg_types" : (agcom.PVOID, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("IGraphicsFont"), agmarshall.EnumArg(SET_HINT), agmarshall.InterfaceOutArg,) }
    def initialize_with_graphics_font_and_set_hint(self, font:"IGraphicsFont", setHint:"SET_HINT") -> "TextBatchPrimitive":
        """Initialize a marker batch primitive with the specified font and setHint."""
        return self._intf.invoke(ITextBatchPrimitiveFactory._metadata, ITextBatchPrimitiveFactory._initialize_with_graphics_font_and_set_hint_metadata, font, setHint, OutArg())

    _initialize_with_graphics_font_and_set_hint_2d_metadata = { "offset" : _initialize_with_graphics_font_and_set_hint_2d_method_offset,
            "arg_types" : (agcom.PVOID, agcom.LONG, agcom.VARIANT_BOOL, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("IGraphicsFont"), agmarshall.EnumArg(SET_HINT), agmarshall.VariantBoolArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_graphics_font_and_set_hint_2d(self, font:"IGraphicsFont", setHint:"SET_HINT", renderInScreenSpace:bool) -> "TextBatchPrimitive":
        """Initialize a text batch primitive with the specified font and setHint, optimized for 2d screen space rendering."""
        return self._intf.invoke(ITextBatchPrimitiveFactory._metadata, ITextBatchPrimitiveFactory._initialize_with_graphics_font_and_set_hint_2d_metadata, font, setHint, renderInScreenSpace, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5099738729577984699, 4201041305732506785), ITextBatchPrimitiveFactory)
agcls.AgTypeNameMap["ITextBatchPrimitiveFactory"] = ITextBatchPrimitiveFactory

class ITextBatchPrimitiveOptionalParametersFactory(object):
    """Optional per-string and per-batch parameters for text batch primitive..."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _metadata = {
        "iid_data" : (5480381018530715795, 16125853395427760539),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ITextBatchPrimitiveOptionalParametersFactory."""
        initialize_from_source_object(self, sourceObject, ITextBatchPrimitiveOptionalParametersFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITextBatchPrimitiveOptionalParametersFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ITextBatchPrimitiveOptionalParametersFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "TextBatchPrimitiveOptionalParameters":
        """Initialize default text batch primitive optional parameters."""
        return self._intf.invoke(ITextBatchPrimitiveOptionalParametersFactory._metadata, ITextBatchPrimitiveOptionalParametersFactory._initialize_metadata, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5480381018530715795, 16125853395427760539), ITextBatchPrimitiveOptionalParametersFactory)
agcls.AgTypeNameMap["ITextBatchPrimitiveOptionalParametersFactory"] = ITextBatchPrimitiveOptionalParametersFactory

class ITextOverlayFactory(object):
    """A rectangular overlay that contains text."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_with_xy_width_height_method_offset = 2
    _initialize_with_position_size_method_offset = 3
    _initialize_with_width_height_units_method_offset = 4
    _metadata = {
        "iid_data" : (5276707085520357541, 8776010947109613214),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ITextOverlayFactory."""
        initialize_from_source_object(self, sourceObject, ITextOverlayFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITextOverlayFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ITextOverlayFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("IGraphicsFont"), agmarshall.InterfaceOutArg,) }
    def initialize(self, font:"IGraphicsFont") -> "TextOverlay":
        """Initialize the overlay with a position of (0, 0), a width of 100 pixels, and a height of 50 pixels."""
        return self._intf.invoke(ITextOverlayFactory._metadata, ITextOverlayFactory._initialize_metadata, font, OutArg())

    _initialize_with_xy_width_height_metadata = { "offset" : _initialize_with_xy_width_height_method_offset,
            "arg_types" : (agcom.PVOID, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("IGraphicsFont"), agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_xy_width_height(self, font:"IGraphicsFont", xPixels:float, yPixels:float, widthPixels:float, heightPixels:float) -> "TextOverlay":
        """Initialize the overlay with the specified x position, y position, width, and height, all specified in pixels."""
        return self._intf.invoke(ITextOverlayFactory._metadata, ITextOverlayFactory._initialize_with_xy_width_height_metadata, font, xPixels, yPixels, widthPixels, heightPixels, OutArg())

    _initialize_with_position_size_metadata = { "offset" : _initialize_with_position_size_method_offset,
            "arg_types" : (agcom.PVOID, POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("IGraphicsFont"), agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_position_size(self, font:"IGraphicsFont", position:list, size:list) -> "TextOverlay":
        """Initialize the overlay with the specified position and size."""
        return self._intf.invoke(ITextOverlayFactory._metadata, ITextOverlayFactory._initialize_with_position_size_metadata, font, position, size, OutArg())

    _initialize_with_width_height_units_metadata = { "offset" : _initialize_with_width_height_units_method_offset,
            "arg_types" : (agcom.PVOID, agcom.DOUBLE, agcom.LONG, agcom.DOUBLE, agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("IGraphicsFont"), agmarshall.DoubleArg, agmarshall.EnumArg(SCREEN_OVERLAY_UNIT), agmarshall.DoubleArg, agmarshall.EnumArg(SCREEN_OVERLAY_UNIT), agmarshall.InterfaceOutArg,) }
    def initialize_with_width_height_units(self, font:"IGraphicsFont", width:float, widthUnit:"SCREEN_OVERLAY_UNIT", height:float, heightUnit:"SCREEN_OVERLAY_UNIT") -> "TextOverlay":
        """Initialize the overlay with the specified position and size."""
        return self._intf.invoke(ITextOverlayFactory._metadata, ITextOverlayFactory._initialize_with_width_height_units_metadata, font, width, widthUnit, height, heightUnit, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5276707085520357541, 8776010947109613214), ITextOverlayFactory)
agcls.AgTypeNameMap["ITextOverlayFactory"] = ITextOverlayFactory

class ITextureMatrixFactory(object):
    """A 4 by 4 matrix applied to a texture coordinate."""

    _num_methods = 4
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_by_values_method_offset = 2
    _initialize_with_affine_transform_method_offset = 3
    _initialize_with_rectangles_method_offset = 4
    _metadata = {
        "iid_data" : (5298719410259543753, 15291419518442577568),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ITextureMatrixFactory."""
        initialize_from_source_object(self, sourceObject, ITextureMatrixFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITextureMatrixFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ITextureMatrixFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "TextureMatrix":
        """Initialize a texture matrix to the identity matrix."""
        return self._intf.invoke(ITextureMatrixFactory._metadata, ITextureMatrixFactory._initialize_metadata, OutArg())

    _initialize_by_values_metadata = { "offset" : _initialize_by_values_method_offset,
            "arg_types" : (agcom.FLOAT, agcom.FLOAT, agcom.FLOAT, agcom.FLOAT, agcom.FLOAT, agcom.FLOAT, agcom.FLOAT, agcom.FLOAT, agcom.FLOAT, agcom.FLOAT, agcom.FLOAT, agcom.FLOAT, agcom.FLOAT, agcom.FLOAT, agcom.FLOAT, agcom.FLOAT, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.FloatArg, agmarshall.FloatArg, agmarshall.FloatArg, agmarshall.FloatArg, agmarshall.FloatArg, agmarshall.FloatArg, agmarshall.FloatArg, agmarshall.FloatArg, agmarshall.FloatArg, agmarshall.FloatArg, agmarshall.FloatArg, agmarshall.FloatArg, agmarshall.FloatArg, agmarshall.FloatArg, agmarshall.FloatArg, agmarshall.FloatArg, agmarshall.InterfaceOutArg,) }
    def initialize_by_values(self, m11:float, m12:float, m13:float, m14:float, m21:float, m22:float, m23:float, m24:float, m31:float, m32:float, m33:float, m34:float, m41:float, m42:float, m43:float, m44:float) -> "TextureMatrix":
        """Initialize a texture matrix. The subscripts define [row][column]."""
        return self._intf.invoke(ITextureMatrixFactory._metadata, ITextureMatrixFactory._initialize_by_values_metadata, m11, m12, m13, m14, m21, m22, m23, m24, m31, m32, m33, m34, m41, m42, m43, m44, OutArg())

    _initialize_with_affine_transform_metadata = { "offset" : _initialize_with_affine_transform_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_affine_transform(self, matrix:list) -> "TextureMatrix":
        """Initialize a texture matrix from a matrix. The upper left 2x2 matrix defines rotation and scaling. The top two elements of the last column define translation."""
        return self._intf.invoke(ITextureMatrixFactory._metadata, ITextureMatrixFactory._initialize_with_affine_transform_metadata, matrix, OutArg())

    _initialize_with_rectangles_metadata = { "offset" : _initialize_with_rectangles_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_rectangles(self, corner0:list, corner1:list, corner2:list, corner3:list) -> "TextureMatrix":
        """Initialize a texture matrix from texture corner points. Normally, a texture is mapped such that the lower left corner is texture coordinate (0, 0), the lower right is (1, 0), the upper right is (1, 1), and the upper left is (0, 1)..."""
        return self._intf.invoke(ITextureMatrixFactory._metadata, ITextureMatrixFactory._initialize_with_rectangles_metadata, corner0, corner1, corner2, corner3, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5298719410259543753, 15291419518442577568), ITextureMatrixFactory)
agcls.AgTypeNameMap["ITextureMatrixFactory"] = ITextureMatrixFactory

class ITextureScreenOverlayFactory(object):
    """A rectangular overlay that can be assigned a texture."""

    _num_methods = 5
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_with_xy_width_height_method_offset = 2
    _initialize_with_position_size_method_offset = 3
    _initialize_with_xy_texture_method_offset = 4
    _initialize_with_position_texture_method_offset = 5
    _metadata = {
        "iid_data" : (5189080006299190827, 8833435460825290906),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ITextureScreenOverlayFactory."""
        initialize_from_source_object(self, sourceObject, ITextureScreenOverlayFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITextureScreenOverlayFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ITextureScreenOverlayFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "TextureScreenOverlay":
        """Initialize the overlay with a position of (0, 0), a width of 100 pixels, and a height of 50 pixels."""
        return self._intf.invoke(ITextureScreenOverlayFactory._metadata, ITextureScreenOverlayFactory._initialize_metadata, OutArg())

    _initialize_with_xy_width_height_metadata = { "offset" : _initialize_with_xy_width_height_method_offset,
            "arg_types" : (agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, agcom.DOUBLE, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_xy_width_height(self, xPixels:float, yPixels:float, widthPixels:float, heightPixels:float) -> "TextureScreenOverlay":
        """Initialize the overlay with the specified x position, y position, width, and height, all specified in pixels."""
        return self._intf.invoke(ITextureScreenOverlayFactory._metadata, ITextureScreenOverlayFactory._initialize_with_xy_width_height_metadata, xPixels, yPixels, widthPixels, heightPixels, OutArg())

    _initialize_with_position_size_metadata = { "offset" : _initialize_with_position_size_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.LPSAFEARRAY), POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.LPSafearrayArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_position_size(self, position:list, size:list) -> "TextureScreenOverlay":
        """Initialize the overlay with the specified position and size."""
        return self._intf.invoke(ITextureScreenOverlayFactory._metadata, ITextureScreenOverlayFactory._initialize_with_position_size_metadata, position, size, OutArg())

    _initialize_with_xy_texture_metadata = { "offset" : _initialize_with_xy_texture_method_offset,
            "arg_types" : (agcom.DOUBLE, agcom.DOUBLE, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.DoubleArg, agmarshall.DoubleArg, agmarshall.InterfaceInArg("IRendererTexture2D"), agmarshall.InterfaceOutArg,) }
    def initialize_with_xy_texture(self, xPixels:float, yPixels:float, texture:"IRendererTexture2D") -> "TextureScreenOverlay":
        """Initialize the overlay with a specified background texture. The size of the overlay will be the same as the size of the texture."""
        return self._intf.invoke(ITextureScreenOverlayFactory._metadata, ITextureScreenOverlayFactory._initialize_with_xy_texture_metadata, xPixels, yPixels, texture, OutArg())

    _initialize_with_position_texture_metadata = { "offset" : _initialize_with_position_texture_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.InterfaceInArg("IRendererTexture2D"), agmarshall.InterfaceOutArg,) }
    def initialize_with_position_texture(self, position:list, texture:"IRendererTexture2D") -> "TextureScreenOverlay":
        """Initialize the overlay with a specified background texture. The size of the overlay will be the same as the size of the texture."""
        return self._intf.invoke(ITextureScreenOverlayFactory._metadata, ITextureScreenOverlayFactory._initialize_with_position_texture_metadata, position, texture, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5189080006299190827, 8833435460825290906), ITextureScreenOverlayFactory)
agcls.AgTypeNameMap["ITextureScreenOverlayFactory"] = ITextureScreenOverlayFactory

class ITimeIntervalDisplayConditionFactory(object):
    """Define an inclusive time interval that determines when an object, such as a primitive, is rendered based on the current animation time ."""

    _num_methods = 3
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_with_times_method_offset = 2
    _initialize_with_time_interval_method_offset = 3
    _metadata = {
        "iid_data" : (5053103518236939298, 16554847730729502352),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ITimeIntervalDisplayConditionFactory."""
        initialize_from_source_object(self, sourceObject, ITimeIntervalDisplayConditionFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITimeIntervalDisplayConditionFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ITimeIntervalDisplayConditionFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "TimeIntervalDisplayCondition":
        """Initialize a default time display condition. minimum time is set to JulianDate.MinValue and maximum time is set to JulianDate.MaxValue. With this interval, an object is always rendered regardless of the current animation time."""
        return self._intf.invoke(ITimeIntervalDisplayConditionFactory._metadata, ITimeIntervalDisplayConditionFactory._initialize_metadata, OutArg())

    _initialize_with_times_metadata = { "offset" : _initialize_with_times_method_offset,
            "arg_types" : (agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("IDate"), agmarshall.InterfaceInArg("IDate"), agmarshall.InterfaceOutArg,) }
    def initialize_with_times(self, minimumTime:"IDate", maximumTime:"IDate") -> "TimeIntervalDisplayCondition":
        """Initialize a time display condition with the inclusive time interval [minimumTime, maximumTime]..."""
        return self._intf.invoke(ITimeIntervalDisplayConditionFactory._metadata, ITimeIntervalDisplayConditionFactory._initialize_with_times_metadata, minimumTime, maximumTime, OutArg())

    _initialize_with_time_interval_metadata = { "offset" : _initialize_with_time_interval_method_offset,
            "arg_types" : (POINTER(agcom.LPSAFEARRAY), POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.LPSafearrayArg, agmarshall.InterfaceOutArg,) }
    def initialize_with_time_interval(self, timeInterval:list) -> "TimeIntervalDisplayCondition":
        """Initialize a time display condition with a time interval."""
        return self._intf.invoke(ITimeIntervalDisplayConditionFactory._metadata, ITimeIntervalDisplayConditionFactory._initialize_with_time_interval_metadata, timeInterval, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5053103518236939298, 16554847730729502352), ITimeIntervalDisplayConditionFactory)
agcls.AgTypeNameMap["ITimeIntervalDisplayConditionFactory"] = ITimeIntervalDisplayConditionFactory

class ITriangleMeshPrimitiveFactory(object):
    """Render a triangle mesh in the 3D scene. Examples of triangle meshes include polygons on the globe (e.g. states or countries), terrain and imagery extents, ellipses, and extrusions."""

    _num_methods = 2
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _initialize_with_set_hint_method_offset = 2
    _metadata = {
        "iid_data" : (5334200333110979724, 4061294574798475934),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ITriangleMeshPrimitiveFactory."""
        initialize_from_source_object(self, sourceObject, ITriangleMeshPrimitiveFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITriangleMeshPrimitiveFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ITriangleMeshPrimitiveFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "TriangleMeshPrimitive":
        """Initialize a default triangle mesh primitive. This is equivalent to constructing a triangle mesh with a set hint of Frequent."""
        return self._intf.invoke(ITriangleMeshPrimitiveFactory._metadata, ITriangleMeshPrimitiveFactory._initialize_metadata, OutArg())

    _initialize_with_set_hint_metadata = { "offset" : _initialize_with_set_hint_method_offset,
            "arg_types" : (agcom.LONG, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.EnumArg(SET_HINT), agmarshall.InterfaceOutArg,) }
    def initialize_with_set_hint(self, setHint:"SET_HINT") -> "TriangleMeshPrimitive":
        """Initialize a triangle mesh primitive with the specified setHint ."""
        return self._intf.invoke(ITriangleMeshPrimitiveFactory._metadata, ITriangleMeshPrimitiveFactory._initialize_with_set_hint_metadata, setHint, OutArg())


agcls.AgClassCatalog.add_catalog_entry((5334200333110979724, 4061294574798475934), ITriangleMeshPrimitiveFactory)
agcls.AgTypeNameMap["ITriangleMeshPrimitiveFactory"] = ITriangleMeshPrimitiveFactory

class ITriangleMeshPrimitiveOptionalParametersFactory(object):
    """Optional parameters for triangle mesh primitive..."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_method_offset = 1
    _metadata = {
        "iid_data" : (4707058889050347868, 15653003896186561439),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type ITriangleMeshPrimitiveOptionalParametersFactory."""
        initialize_from_source_object(self, sourceObject, ITriangleMeshPrimitiveOptionalParametersFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, ITriangleMeshPrimitiveOptionalParametersFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, ITriangleMeshPrimitiveOptionalParametersFactory, None)
    
    _initialize_metadata = { "offset" : _initialize_method_offset,
            "arg_types" : (POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceOutArg,) }
    def initialize(self) -> "TriangleMeshPrimitiveOptionalParameters":
        """Initialize default triangle mesh primitive optional parameters."""
        return self._intf.invoke(ITriangleMeshPrimitiveOptionalParametersFactory._metadata, ITriangleMeshPrimitiveOptionalParametersFactory._initialize_metadata, OutArg())


agcls.AgClassCatalog.add_catalog_entry((4707058889050347868, 15653003896186561439), ITriangleMeshPrimitiveOptionalParametersFactory)
agcls.AgTypeNameMap["ITriangleMeshPrimitiveOptionalParametersFactory"] = ITriangleMeshPrimitiveOptionalParametersFactory

class IVectorPrimitiveFactory(object):
    """Render a vector in the 3D scene. A vector is defined by a source (given by a reference frame) and a direction (given by a vector). Length is auto-calculated or can be set separately."""

    _num_methods = 1
    _vtable_offset = IUnknown._vtable_offset + IUnknown._num_methods
    _initialize_with_direction_method_offset = 1
    _metadata = {
        "iid_data" : (4879198205289511530, 4059133723286667136),
        "vtable_reference" : IUnknown._vtable_offset + IUnknown._num_methods - 1,
    }
    _property_names = {}
    def __init__(self, sourceObject=None):
        """Construct an object of type IVectorPrimitiveFactory."""
        initialize_from_source_object(self, sourceObject, IVectorPrimitiveFactory)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def _get_property(self, attrname):
        return get_interface_property(attrname, IVectorPrimitiveFactory)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_interface_attribute(self, attrname, value, IVectorPrimitiveFactory, None)
    
    _initialize_with_direction_metadata = { "offset" : _initialize_with_direction_method_offset,
            "arg_types" : (agcom.PVOID, agcom.PVOID, agcom.PVOID, POINTER(agcom.PVOID),),
            "marshallers" : (agmarshall.InterfaceInArg("IVectorGeometryToolSystem"), agmarshall.InterfaceInArg("IVectorGeometryToolVector"), agmarshall.InterfaceInArg("IGraphicsFont"), agmarshall.InterfaceOutArg,) }
    def initialize_with_direction(self, referenceFrame:"IVectorGeometryToolSystem", dir:"IVectorGeometryToolVector", font:"IGraphicsFont") -> "VectorPrimitive":
        """Initialize a vector primitive with the specified reference frame as its source and pointing in direction dir."""
        return self._intf.invoke(IVectorPrimitiveFactory._metadata, IVectorPrimitiveFactory._initialize_with_direction_metadata, referenceFrame, dir, font, OutArg())


agcls.AgClassCatalog.add_catalog_entry((4879198205289511530, 4059133723286667136), IVectorPrimitiveFactory)
agcls.AgTypeNameMap["IVectorPrimitiveFactory"] = IVectorPrimitiveFactory



class PathPoint(IPathPoint, SupportsDeleteCallback):
    """Represents a path point used in conjunction with the Path Primitive."""

    def __init__(self, sourceObject=None):
        """Construct an object of type PathPoint."""
        SupportsDeleteCallback.__init__(self)
        IPathPoint.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IPathPoint._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, PathPoint, [IPathPoint])

agcls.AgClassCatalog.add_catalog_entry((5556206296547912371, 8503175498596258195), PathPoint)
agcls.AgTypeNameMap["PathPoint"] = PathPoint

class PathPointFactory(IPathPointFactory, SupportsDeleteCallback):
    """Factory creates path points."""

    def __init__(self, sourceObject=None):
        """Construct an object of type PathPointFactory."""
        SupportsDeleteCallback.__init__(self)
        IPathPointFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IPathPointFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, PathPointFactory, [IPathPointFactory])

agcls.AgClassCatalog.add_catalog_entry((5489537290029782725, 4580717587449338530), PathPointFactory)
agcls.AgTypeNameMap["PathPointFactory"] = PathPointFactory

class BoundingSphere(IBoundingSphere, SupportsDeleteCallback):
    """A sphere that encapsulates an object."""

    def __init__(self, sourceObject=None):
        """Construct an object of type BoundingSphere."""
        SupportsDeleteCallback.__init__(self)
        IBoundingSphere.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IBoundingSphere._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, BoundingSphere, [IBoundingSphere])

agcls.AgClassCatalog.add_catalog_entry((5560913133829781863, 6998370718496213136), BoundingSphere)
agcls.AgTypeNameMap["BoundingSphere"] = BoundingSphere

class BoundingSphereFactory(IBoundingSphereFactory, SupportsDeleteCallback):
    """Create bounding spheres."""

    def __init__(self, sourceObject=None):
        """Construct an object of type BoundingSphereFactory."""
        SupportsDeleteCallback.__init__(self)
        IBoundingSphereFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IBoundingSphereFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, BoundingSphereFactory, [IBoundingSphereFactory])

agcls.AgClassCatalog.add_catalog_entry((5271520243375596029, 5819040470255887235), BoundingSphereFactory)
agcls.AgTypeNameMap["BoundingSphereFactory"] = BoundingSphereFactory

class TextureFilter2D(ITextureFilter2D, SupportsDeleteCallback):
    """A texture filter."""

    def __init__(self, sourceObject=None):
        """Construct an object of type TextureFilter2D."""
        SupportsDeleteCallback.__init__(self)
        ITextureFilter2D.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITextureFilter2D._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TextureFilter2D, [ITextureFilter2D])

agcls.AgClassCatalog.add_catalog_entry((5701511467830951335, 18354553182752180127), TextureFilter2D)
agcls.AgTypeNameMap["TextureFilter2D"] = TextureFilter2D

class TextureFilter2DFactory(ITextureFilter2DFactory, SupportsDeleteCallback):
    """Create texture filters."""

    def __init__(self, sourceObject=None):
        """Construct an object of type TextureFilter2DFactory."""
        SupportsDeleteCallback.__init__(self)
        ITextureFilter2DFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITextureFilter2DFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TextureFilter2DFactory, [ITextureFilter2DFactory])

agcls.AgClassCatalog.add_catalog_entry((5071727819948482052, 5422654417578581655), TextureFilter2DFactory)
agcls.AgTypeNameMap["TextureFilter2DFactory"] = TextureFilter2DFactory

class RendererTexture2D(IRendererTexture2D, SupportsDeleteCallback):
    """A 2D Texture. A texture represents an image that is ready for use by objects such as primitives and overlays. Textures typically reside in video memory."""

    def __init__(self, sourceObject=None):
        """Construct an object of type RendererTexture2D."""
        SupportsDeleteCallback.__init__(self)
        IRendererTexture2D.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IRendererTexture2D._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, RendererTexture2D, [IRendererTexture2D])

agcls.AgClassCatalog.add_catalog_entry((5381155970277415318, 3622939501334827702), RendererTexture2D)
agcls.AgTypeNameMap["RendererTexture2D"] = RendererTexture2D

class RendererTextureTemplate2D(IRendererTextureTemplate2D, SupportsDeleteCallback):
    """Template object containing attributes required to create a 2D texture."""

    def __init__(self, sourceObject=None):
        """Construct an object of type RendererTextureTemplate2D."""
        SupportsDeleteCallback.__init__(self)
        IRendererTextureTemplate2D.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IRendererTextureTemplate2D._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, RendererTextureTemplate2D, [IRendererTextureTemplate2D])

agcls.AgClassCatalog.add_catalog_entry((4903592959625323336, 10408150276974255496), RendererTextureTemplate2D)
agcls.AgTypeNameMap["RendererTextureTemplate2D"] = RendererTextureTemplate2D

class PathPointCollection(IPathPointCollection, SupportsDeleteCallback):
    """A collection of path points."""

    def __init__(self, sourceObject=None):
        """Construct an object of type PathPointCollection."""
        SupportsDeleteCallback.__init__(self)
        IPathPointCollection.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IPathPointCollection._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, PathPointCollection, [IPathPointCollection])

agcls.AgClassCatalog.add_catalog_entry((4718379932532326826, 11444711569154001853), PathPointCollection)
agcls.AgTypeNameMap["PathPointCollection"] = PathPointCollection

class ObjectCollection(IObjectCollection, SupportsDeleteCallback):
    """A collection of objects."""

    def __init__(self, sourceObject=None):
        """Construct an object of type ObjectCollection."""
        SupportsDeleteCallback.__init__(self)
        IObjectCollection.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IObjectCollection._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, ObjectCollection, [IObjectCollection])

agcls.AgClassCatalog.add_catalog_entry((5689274977493123915, 2183068153647623591), ObjectCollection)
agcls.AgTypeNameMap["ObjectCollection"] = ObjectCollection

class SceneCollection(ISceneCollection, SupportsDeleteCallback):
    """A collection of scenes."""

    def __init__(self, sourceObject=None):
        """Construct an object of type SceneCollection."""
        SupportsDeleteCallback.__init__(self)
        ISceneCollection.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISceneCollection._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SceneCollection, [ISceneCollection])

agcls.AgClassCatalog.add_catalog_entry((5301811212438284748, 14423411918377718926), SceneCollection)
agcls.AgTypeNameMap["SceneCollection"] = SceneCollection

class ScreenOverlayPickResultCollection(IScreenOverlayPickResultCollection, SupportsDeleteCallback):
    """A collection of pick results."""

    def __init__(self, sourceObject=None):
        """Construct an object of type ScreenOverlayPickResultCollection."""
        SupportsDeleteCallback.__init__(self)
        IScreenOverlayPickResultCollection.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IScreenOverlayPickResultCollection._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, ScreenOverlayPickResultCollection, [IScreenOverlayPickResultCollection])

agcls.AgClassCatalog.add_catalog_entry((4677343897895766869, 11872430607576403131), ScreenOverlayPickResultCollection)
agcls.AgTypeNameMap["ScreenOverlayPickResultCollection"] = ScreenOverlayPickResultCollection

class GlobeImageOverlayAddCompleteEventArgs(IGlobeImageOverlayAddCompleteEventArgs, SupportsDeleteCallback):
    """The event is raised when the globe image overlay is displayed for the first time after being added using AddAsync."""

    def __init__(self, sourceObject=None):
        """Construct an object of type GlobeImageOverlayAddCompleteEventArgs."""
        SupportsDeleteCallback.__init__(self)
        IGlobeImageOverlayAddCompleteEventArgs.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IGlobeImageOverlayAddCompleteEventArgs._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, GlobeImageOverlayAddCompleteEventArgs, [IGlobeImageOverlayAddCompleteEventArgs])

agcls.AgClassCatalog.add_catalog_entry((5231802800479662057, 2104184534495932053), GlobeImageOverlayAddCompleteEventArgs)
agcls.AgTypeNameMap["GlobeImageOverlayAddCompleteEventArgs"] = GlobeImageOverlayAddCompleteEventArgs

class TerrainOverlayAddCompleteEventArgs(ITerrainOverlayAddCompleteEventArgs, SupportsDeleteCallback):
    """The event is raised when the terrain overlay is displayed for the first time after having been added using AddAsync."""

    def __init__(self, sourceObject=None):
        """Construct an object of type TerrainOverlayAddCompleteEventArgs."""
        SupportsDeleteCallback.__init__(self)
        ITerrainOverlayAddCompleteEventArgs.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITerrainOverlayAddCompleteEventArgs._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TerrainOverlayAddCompleteEventArgs, [ITerrainOverlayAddCompleteEventArgs])

agcls.AgClassCatalog.add_catalog_entry((4866096509316980678, 14412758423447289486), TerrainOverlayAddCompleteEventArgs)
agcls.AgTypeNameMap["TerrainOverlayAddCompleteEventArgs"] = TerrainOverlayAddCompleteEventArgs

class PickResultCollection(IPickResultCollection, SupportsDeleteCallback):
    """A collection of picked objects."""

    def __init__(self, sourceObject=None):
        """Construct an object of type PickResultCollection."""
        SupportsDeleteCallback.__init__(self)
        IPickResultCollection.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IPickResultCollection._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, PickResultCollection, [IPickResultCollection])

agcls.AgClassCatalog.add_catalog_entry((5712441455425732440, 17907447014582202282), PickResultCollection)
agcls.AgTypeNameMap["PickResultCollection"] = PickResultCollection

class RenderingEventArgs(IRenderingEventArgs, SupportsDeleteCallback):
    """The event is raised when the scene is rendered."""

    def __init__(self, sourceObject=None):
        """Construct an object of type RenderingEventArgs."""
        SupportsDeleteCallback.__init__(self)
        IRenderingEventArgs.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IRenderingEventArgs._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, RenderingEventArgs, [IRenderingEventArgs])

agcls.AgClassCatalog.add_catalog_entry((5392329581593296225, 914494406188763269), RenderingEventArgs)
agcls.AgTypeNameMap["RenderingEventArgs"] = RenderingEventArgs

class BatchPrimitiveIndex(IBatchPrimitiveIndex, SupportsDeleteCallback):
    """Represents an individual item index that is associated with a batch primitive. Provides the Index of the individual item and the Primitive that contains that index..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type BatchPrimitiveIndex."""
        SupportsDeleteCallback.__init__(self)
        IBatchPrimitiveIndex.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IBatchPrimitiveIndex._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, BatchPrimitiveIndex, [IBatchPrimitiveIndex])

agcls.AgClassCatalog.add_catalog_entry((5200164995912440169, 5658385359959925641), BatchPrimitiveIndex)
agcls.AgTypeNameMap["BatchPrimitiveIndex"] = BatchPrimitiveIndex

class KmlDocumentCollection(IKmlDocumentCollection, SupportsDeleteCallback):
    """A collection of KML documents."""

    def __init__(self, sourceObject=None):
        """Construct an object of type KmlDocumentCollection."""
        SupportsDeleteCallback.__init__(self)
        IKmlDocumentCollection.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IKmlDocumentCollection._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, KmlDocumentCollection, [IKmlDocumentCollection])

agcls.AgClassCatalog.add_catalog_entry((5215825726924847476, 8941538243989311415), KmlDocumentCollection)
agcls.AgTypeNameMap["KmlDocumentCollection"] = KmlDocumentCollection

class KmlFeatureCollection(IKmlFeatureCollection, SupportsDeleteCallback):
    """A collection of KML features."""

    def __init__(self, sourceObject=None):
        """Construct an object of type KmlFeatureCollection."""
        SupportsDeleteCallback.__init__(self)
        IKmlFeatureCollection.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IKmlFeatureCollection._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, KmlFeatureCollection, [IKmlFeatureCollection])

agcls.AgClassCatalog.add_catalog_entry((5727078008905494174, 12095817447017663925), KmlFeatureCollection)
agcls.AgTypeNameMap["KmlFeatureCollection"] = KmlFeatureCollection

class KmlDocumentLoadedEventArgs(IKmlDocumentLoadedEventArgs, SupportsDeleteCallback):
    """The event is raised when a KML document has been loaded."""

    def __init__(self, sourceObject=None):
        """Construct an object of type KmlDocumentLoadedEventArgs."""
        SupportsDeleteCallback.__init__(self)
        IKmlDocumentLoadedEventArgs.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IKmlDocumentLoadedEventArgs._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, KmlDocumentLoadedEventArgs, [IKmlDocumentLoadedEventArgs])

agcls.AgClassCatalog.add_catalog_entry((5646942824342644840, 16385106561904486318), KmlDocumentLoadedEventArgs)
agcls.AgTypeNameMap["KmlDocumentLoadedEventArgs"] = KmlDocumentLoadedEventArgs

class FactoryAndInitializers(IFactoryAndInitializers, SupportsDeleteCallback):
    """Methods and properties are used to initialize new primitives, display conditions, screen overlays, textures and many other types; compute and retrieve triangulator results and access global properties (what's known as static properties, static methods a..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type FactoryAndInitializers."""
        SupportsDeleteCallback.__init__(self)
        IFactoryAndInitializers.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IFactoryAndInitializers._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, FactoryAndInitializers, [IFactoryAndInitializers])

agcls.AgClassCatalog.add_catalog_entry((5029710387976957897, 13954049756575440778), FactoryAndInitializers)
agcls.AgTypeNameMap["FactoryAndInitializers"] = FactoryAndInitializers

class ExtrudedPolylineTriangulatorResult(IExtrudedPolylineTriangulatorResult, ITriangulatorResult, SupportsDeleteCallback):
    """The result from extruded polyline triangulation: a triangle mesh defined using an indexed triangle list with top and bottom boundary positions. The mesh is commonly visualized with the triangle mesh primitive or surface mesh primitive..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type ExtrudedPolylineTriangulatorResult."""
        SupportsDeleteCallback.__init__(self)
        IExtrudedPolylineTriangulatorResult.__init__(self, sourceObject)
        ITriangulatorResult.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IExtrudedPolylineTriangulatorResult._private_init(self, intf)
        ITriangulatorResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, ExtrudedPolylineTriangulatorResult, [IExtrudedPolylineTriangulatorResult, ITriangulatorResult])

agcls.AgClassCatalog.add_catalog_entry((4874148548191491803, 705205959735039921), ExtrudedPolylineTriangulatorResult)
agcls.AgTypeNameMap["ExtrudedPolylineTriangulatorResult"] = ExtrudedPolylineTriangulatorResult

class SolidTriangulatorResult(ISolidTriangulatorResult, ITriangulatorResult, SupportsDeleteCallback):
    """The result from a triangulation of a solid: a triangle mesh defined using an indexed triangle list and positions outlining the solid. It is recommended to visualize the solid using a solid primitive..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type SolidTriangulatorResult."""
        SupportsDeleteCallback.__init__(self)
        ISolidTriangulatorResult.__init__(self, sourceObject)
        ITriangulatorResult.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISolidTriangulatorResult._private_init(self, intf)
        ITriangulatorResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SolidTriangulatorResult, [ISolidTriangulatorResult, ITriangulatorResult])

agcls.AgClassCatalog.add_catalog_entry((5292312989871528695, 2932714005618817949), SolidTriangulatorResult)
agcls.AgTypeNameMap["SolidTriangulatorResult"] = SolidTriangulatorResult

class SurfaceShapesResult(ISurfaceShapesResult, SupportsDeleteCallback):
    """Represents the boundary positions of a shape on the surface computed from by a surface shapes method."""

    def __init__(self, sourceObject=None):
        """Construct an object of type SurfaceShapesResult."""
        SupportsDeleteCallback.__init__(self)
        ISurfaceShapesResult.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISurfaceShapesResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SurfaceShapesResult, [ISurfaceShapesResult])

agcls.AgClassCatalog.add_catalog_entry((5562832838748717934, 17103991771881976193), SurfaceShapesResult)
agcls.AgTypeNameMap["SurfaceShapesResult"] = SurfaceShapesResult

class SurfaceTriangulatorResult(ISurfaceTriangulatorResult, ITriangulatorResult, SupportsDeleteCallback):
    """The result from a triangulation on the surface of a central body: a triangle mesh defined using an indexed triangle list and boundary positions surrounding the mesh..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type SurfaceTriangulatorResult."""
        SupportsDeleteCallback.__init__(self)
        ISurfaceTriangulatorResult.__init__(self, sourceObject)
        ITriangulatorResult.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISurfaceTriangulatorResult._private_init(self, intf)
        ITriangulatorResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SurfaceTriangulatorResult, [ISurfaceTriangulatorResult, ITriangulatorResult])

agcls.AgClassCatalog.add_catalog_entry((5317895839875531743, 55317102968090019), SurfaceTriangulatorResult)
agcls.AgTypeNameMap["SurfaceTriangulatorResult"] = SurfaceTriangulatorResult

class TriangulatorResult(ITriangulatorResult, SupportsDeleteCallback):
    """The result from triangulation: a triangle mesh defined using an indexed triangle list. This is commonly visualized with the triangle mesh primitive or surface mesh primitive."""

    def __init__(self, sourceObject=None):
        """Construct an object of type TriangulatorResult."""
        SupportsDeleteCallback.__init__(self)
        ITriangulatorResult.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITriangulatorResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TriangulatorResult, [ITriangulatorResult])

agcls.AgClassCatalog.add_catalog_entry((5139444277268572249, 3108066989369069979), TriangulatorResult)
agcls.AgTypeNameMap["TriangulatorResult"] = TriangulatorResult

class AGICustomTerrainOverlay(IAGICustomTerrainOverlay, ITerrainOverlay, IGlobeOverlay, SupportsDeleteCallback):
    """A terrain overlay for handling AGI Cesium Terrain."""

    def __init__(self, sourceObject=None):
        """Construct an object of type AGICustomTerrainOverlay."""
        SupportsDeleteCallback.__init__(self)
        IAGICustomTerrainOverlay.__init__(self, sourceObject)
        ITerrainOverlay.__init__(self, sourceObject)
        IGlobeOverlay.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAGICustomTerrainOverlay._private_init(self, intf)
        ITerrainOverlay._private_init(self, intf)
        IGlobeOverlay._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AGICustomTerrainOverlay, [IAGICustomTerrainOverlay, ITerrainOverlay, IGlobeOverlay])

agcls.AgClassCatalog.add_catalog_entry((5233896634715199280, 3319534929678221749), AGICustomTerrainOverlay)
agcls.AgTypeNameMap["AGICustomTerrainOverlay"] = AGICustomTerrainOverlay

class AGIProcessedImageGlobeOverlay(IAGIProcessedImageGlobeOverlay, IGlobeImageOverlay, IGlobeOverlay, SupportsDeleteCallback):
    """A globe image overlay for handling AGI Processed Image (PDTTX) files."""

    def __init__(self, sourceObject=None):
        """Construct an object of type AGIProcessedImageGlobeOverlay."""
        SupportsDeleteCallback.__init__(self)
        IAGIProcessedImageGlobeOverlay.__init__(self, sourceObject)
        IGlobeImageOverlay.__init__(self, sourceObject)
        IGlobeOverlay.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAGIProcessedImageGlobeOverlay._private_init(self, intf)
        IGlobeImageOverlay._private_init(self, intf)
        IGlobeOverlay._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AGIProcessedImageGlobeOverlay, [IAGIProcessedImageGlobeOverlay, IGlobeImageOverlay, IGlobeOverlay])

agcls.AgClassCatalog.add_catalog_entry((4698652200510509190, 4410810686274608779), AGIProcessedImageGlobeOverlay)
agcls.AgTypeNameMap["AGIProcessedImageGlobeOverlay"] = AGIProcessedImageGlobeOverlay

class AGIProcessedTerrainOverlay(IAGIProcessedTerrainOverlay, ITerrainOverlay, IGlobeOverlay, SupportsDeleteCallback):
    """A terrain overlay for handling AGI Processed Terrain (PDTT) files."""

    def __init__(self, sourceObject=None):
        """Construct an object of type AGIProcessedTerrainOverlay."""
        SupportsDeleteCallback.__init__(self)
        IAGIProcessedTerrainOverlay.__init__(self, sourceObject)
        ITerrainOverlay.__init__(self, sourceObject)
        IGlobeOverlay.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAGIProcessedTerrainOverlay._private_init(self, intf)
        ITerrainOverlay._private_init(self, intf)
        IGlobeOverlay._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AGIProcessedTerrainOverlay, [IAGIProcessedTerrainOverlay, ITerrainOverlay, IGlobeOverlay])

agcls.AgClassCatalog.add_catalog_entry((5555210745660264736, 9436563425815460013), AGIProcessedTerrainOverlay)
agcls.AgTypeNameMap["AGIProcessedTerrainOverlay"] = AGIProcessedTerrainOverlay

class AGIRoamImageGlobeOverlay(IAGIRoamImageGlobeOverlay, IGlobeImageOverlay, IGlobeOverlay, SupportsDeleteCallback):
    """A globe image overlay for handling ROAM (TXM/TXB) files."""

    def __init__(self, sourceObject=None):
        """Construct an object of type AGIRoamImageGlobeOverlay."""
        SupportsDeleteCallback.__init__(self)
        IAGIRoamImageGlobeOverlay.__init__(self, sourceObject)
        IGlobeImageOverlay.__init__(self, sourceObject)
        IGlobeOverlay.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAGIRoamImageGlobeOverlay._private_init(self, intf)
        IGlobeImageOverlay._private_init(self, intf)
        IGlobeOverlay._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AGIRoamImageGlobeOverlay, [IAGIRoamImageGlobeOverlay, IGlobeImageOverlay, IGlobeOverlay])

agcls.AgClassCatalog.add_catalog_entry((5242539083339407783, 14850989973976265913), AGIRoamImageGlobeOverlay)
agcls.AgTypeNameMap["AGIRoamImageGlobeOverlay"] = AGIRoamImageGlobeOverlay

class CameraSnapshot(ICameraSnapshot, SupportsDeleteCallback):
    """Takes snapshots of the 3D window."""

    def __init__(self, sourceObject=None):
        """Construct an object of type CameraSnapshot."""
        SupportsDeleteCallback.__init__(self)
        ICameraSnapshot.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICameraSnapshot._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CameraSnapshot, [ICameraSnapshot])

agcls.AgClassCatalog.add_catalog_entry((4857812757827340764, 12820205993576870016), CameraSnapshot)
agcls.AgTypeNameMap["CameraSnapshot"] = CameraSnapshot

class CameraVideoRecording(ICameraVideoRecording, SupportsDeleteCallback):
    """Records the 3D window to either a movie file or to consecutively ordered image files each time the scene is rendered."""

    def __init__(self, sourceObject=None):
        """Construct an object of type CameraVideoRecording."""
        SupportsDeleteCallback.__init__(self)
        ICameraVideoRecording.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICameraVideoRecording._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CameraVideoRecording, [ICameraVideoRecording])

agcls.AgClassCatalog.add_catalog_entry((4949773353057298900, 8240883984009465791), CameraVideoRecording)
agcls.AgTypeNameMap["CameraVideoRecording"] = CameraVideoRecording

class CentralBodyGraphicsIndexer(ICentralBodyGraphicsIndexer, SupportsDeleteCallback):
    """An indexer into the central body graphics for a particular central body, which provides graphical properties such as showing or hiding the central body in the scene, and working with terrain and imagery for the specified central body."""

    def __init__(self, sourceObject=None):
        """Construct an object of type CentralBodyGraphicsIndexer."""
        SupportsDeleteCallback.__init__(self)
        ICentralBodyGraphicsIndexer.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICentralBodyGraphicsIndexer._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CentralBodyGraphicsIndexer, [ICentralBodyGraphicsIndexer])

agcls.AgClassCatalog.add_catalog_entry((4664517785508533741, 18264689342556895135), CentralBodyGraphicsIndexer)
agcls.AgTypeNameMap["CentralBodyGraphicsIndexer"] = CentralBodyGraphicsIndexer

class CustomImageGlobeOverlay(ICustomImageGlobeOverlay, IGlobeImageOverlay, IGlobeOverlay, SupportsDeleteCallback):
    """A globe image overlay that allows for a user defined image to be specified."""

    def __init__(self, sourceObject=None):
        """Construct an object of type CustomImageGlobeOverlay."""
        SupportsDeleteCallback.__init__(self)
        ICustomImageGlobeOverlay.__init__(self, sourceObject)
        IGlobeImageOverlay.__init__(self, sourceObject)
        IGlobeOverlay.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICustomImageGlobeOverlay._private_init(self, intf)
        IGlobeImageOverlay._private_init(self, intf)
        IGlobeOverlay._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CustomImageGlobeOverlay, [ICustomImageGlobeOverlay, IGlobeImageOverlay, IGlobeOverlay])

agcls.AgClassCatalog.add_catalog_entry((5121324544174012502, 11507939295407134083), CustomImageGlobeOverlay)
agcls.AgTypeNameMap["CustomImageGlobeOverlay"] = CustomImageGlobeOverlay

class CustomImageGlobeOverlayPluginActivator(ICustomImageGlobeOverlayPluginActivator, SupportsDeleteCallback):
    """The Activator class provides methods to load COM plugins that implement custom image globe overlays. For more information about custom image globe overlays, see the STK Programming Interface."""

    def __init__(self, sourceObject=None):
        """Construct an object of type CustomImageGlobeOverlayPluginActivator."""
        SupportsDeleteCallback.__init__(self)
        ICustomImageGlobeOverlayPluginActivator.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICustomImageGlobeOverlayPluginActivator._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CustomImageGlobeOverlayPluginActivator, [ICustomImageGlobeOverlayPluginActivator])

agcls.AgClassCatalog.add_catalog_entry((5403836162981649170, 18332814256462960269), CustomImageGlobeOverlayPluginActivator)
agcls.AgTypeNameMap["CustomImageGlobeOverlayPluginActivator"] = CustomImageGlobeOverlayPluginActivator

class CustomImageGlobeOverlayPluginProxy(ICustomImageGlobeOverlayPluginProxy, SupportsDeleteCallback):
    """A proxy class provides access to a custom image globe overlay implemented by a plugin. Proxies are instantiated using custom image globe overlay plugin activator."""

    def __init__(self, sourceObject=None):
        """Construct an object of type CustomImageGlobeOverlayPluginProxy."""
        SupportsDeleteCallback.__init__(self)
        ICustomImageGlobeOverlayPluginProxy.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICustomImageGlobeOverlayPluginProxy._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CustomImageGlobeOverlayPluginProxy, [ICustomImageGlobeOverlayPluginProxy])

agcls.AgClassCatalog.add_catalog_entry((5287787800528969618, 3978382521805652152), CustomImageGlobeOverlayPluginProxy)
agcls.AgTypeNameMap["CustomImageGlobeOverlayPluginProxy"] = CustomImageGlobeOverlayPluginProxy

class GeospatialImageGlobeOverlay(IGeospatialImageGlobeOverlay, IGlobeImageOverlay, IGlobeOverlay, SupportsDeleteCallback):
    """A globe image overlay for handling `JPEG 2000 <https://jpeg.org/jpeg2000/>`_ (.jp2), ECW (.ecw), ECWP, and MrSid (.sid) image formats in the WGS84 geographic projection."""

    def __init__(self, sourceObject=None):
        """Construct an object of type GeospatialImageGlobeOverlay."""
        SupportsDeleteCallback.__init__(self)
        IGeospatialImageGlobeOverlay.__init__(self, sourceObject)
        IGlobeImageOverlay.__init__(self, sourceObject)
        IGlobeOverlay.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IGeospatialImageGlobeOverlay._private_init(self, intf)
        IGlobeImageOverlay._private_init(self, intf)
        IGlobeOverlay._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, GeospatialImageGlobeOverlay, [IGeospatialImageGlobeOverlay, IGlobeImageOverlay, IGlobeOverlay])

agcls.AgClassCatalog.add_catalog_entry((5299127955564734487, 15153468011881559482), GeospatialImageGlobeOverlay)
agcls.AgTypeNameMap["GeospatialImageGlobeOverlay"] = GeospatialImageGlobeOverlay

class GlobeOverlay(IGlobeOverlay, SupportsDeleteCallback):
    """The base class of all terrain overlay and globe image overlay objects."""

    def __init__(self, sourceObject=None):
        """Construct an object of type GlobeOverlay."""
        SupportsDeleteCallback.__init__(self)
        IGlobeOverlay.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IGlobeOverlay._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, GlobeOverlay, [IGlobeOverlay])

agcls.AgClassCatalog.add_catalog_entry((4864694773533807784, 5277725294694145455), GlobeOverlay)
agcls.AgTypeNameMap["GlobeOverlay"] = GlobeOverlay

class GlobeOverlaySettings(IGlobeOverlaySettings, SupportsDeleteCallback):
    """Settings used by globe overlay objects. These setting affect all scenes."""

    def __init__(self, sourceObject=None):
        """Construct an object of type GlobeOverlaySettings."""
        SupportsDeleteCallback.__init__(self)
        IGlobeOverlaySettings.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IGlobeOverlaySettings._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, GlobeOverlaySettings, [IGlobeOverlaySettings])

agcls.AgClassCatalog.add_catalog_entry((5096239221085204322, 4767820054995129484), GlobeOverlaySettings)
agcls.AgTypeNameMap["GlobeOverlaySettings"] = GlobeOverlaySettings

class Lighting(ILighting, SupportsDeleteCallback):
    """Lighting in the 3D scene."""

    def __init__(self, sourceObject=None):
        """Construct an object of type Lighting."""
        SupportsDeleteCallback.__init__(self)
        ILighting.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ILighting._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, Lighting, [ILighting])

agcls.AgClassCatalog.add_catalog_entry((5650660233190705200, 7654417412287974021), Lighting)
agcls.AgTypeNameMap["Lighting"] = Lighting

class PathPrimitiveUpdatePolicy(IPathPrimitiveUpdatePolicy, SupportsDeleteCallback):
    """A class that encapsulates the update logic for a path primitive. Derived classes must implement the Update method."""

    def __init__(self, sourceObject=None):
        """Construct an object of type PathPrimitiveUpdatePolicy."""
        SupportsDeleteCallback.__init__(self)
        IPathPrimitiveUpdatePolicy.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IPathPrimitiveUpdatePolicy._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, PathPrimitiveUpdatePolicy, [IPathPrimitiveUpdatePolicy])

agcls.AgClassCatalog.add_catalog_entry((5489232455939643999, 11995564172842310537), PathPrimitiveUpdatePolicy)
agcls.AgTypeNameMap["PathPrimitiveUpdatePolicy"] = PathPrimitiveUpdatePolicy

class ProjectedRasterOverlay(IProjectedRasterOverlay, IGlobeImageOverlay, IGlobeOverlay, SupportsDeleteCallback):
    """A globe image overlay which projects a raster onto the terrain or surface of the central body. You can also enable projection onto models by setting projected raster model projection to true for a Scene..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type ProjectedRasterOverlay."""
        SupportsDeleteCallback.__init__(self)
        IProjectedRasterOverlay.__init__(self, sourceObject)
        IGlobeImageOverlay.__init__(self, sourceObject)
        IGlobeOverlay.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IProjectedRasterOverlay._private_init(self, intf)
        IGlobeImageOverlay._private_init(self, intf)
        IGlobeOverlay._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, ProjectedRasterOverlay, [IProjectedRasterOverlay, IGlobeImageOverlay, IGlobeOverlay])

agcls.AgClassCatalog.add_catalog_entry((4696496787392859056, 16340637864943862462), ProjectedRasterOverlay)
agcls.AgTypeNameMap["ProjectedRasterOverlay"] = ProjectedRasterOverlay

class Projection(IProjection, SupportsDeleteCallback):
    """A projection represents a simplified camera with a position, orientation, and field of view horizontal and field of view vertical..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type Projection."""
        SupportsDeleteCallback.__init__(self)
        IProjection.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IProjection._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, Projection, [IProjection])

agcls.AgClassCatalog.add_catalog_entry((4703414202910819741, 11526519806636668054), Projection)
agcls.AgTypeNameMap["Projection"] = Projection

class ProjectionStream(IProjectionStream, IProjection, SupportsDeleteCallback):
    """A projection that is updated dynamically at the specified update delta. The class can be used to stream projection data to projection clients, like projected raster overlay..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type ProjectionStream."""
        SupportsDeleteCallback.__init__(self)
        IProjectionStream.__init__(self, sourceObject)
        IProjection.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IProjectionStream._private_init(self, intf)
        IProjection._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, ProjectionStream, [IProjectionStream, IProjection])

agcls.AgClassCatalog.add_catalog_entry((5236009813300156213, 4436082934118817445), ProjectionStream)
agcls.AgTypeNameMap["ProjectionStream"] = ProjectionStream

class SceneGlobeOverlaySettings(ISceneGlobeOverlaySettings, SupportsDeleteCallback):
    """Settings used by globe overlay objects. These settings only affect the scene."""

    def __init__(self, sourceObject=None):
        """Construct an object of type SceneGlobeOverlaySettings."""
        SupportsDeleteCallback.__init__(self)
        ISceneGlobeOverlaySettings.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISceneGlobeOverlaySettings._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SceneGlobeOverlaySettings, [ISceneGlobeOverlaySettings])

agcls.AgClassCatalog.add_catalog_entry((5538264776613401247, 14183016745653159312), SceneGlobeOverlaySettings)
agcls.AgTypeNameMap["SceneGlobeOverlaySettings"] = SceneGlobeOverlaySettings

class ScreenOverlayCollectionBase(IScreenOverlayCollectionBase, SupportsDeleteCallback):
    """The common base class for collections of overlays held by screen overlay and by screen overlay manager."""

    def __init__(self, sourceObject=None):
        """Construct an object of type ScreenOverlayCollectionBase."""
        SupportsDeleteCallback.__init__(self)
        IScreenOverlayCollectionBase.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IScreenOverlayCollectionBase._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, ScreenOverlayCollectionBase, [IScreenOverlayCollectionBase])

agcls.AgClassCatalog.add_catalog_entry((5029264620485230918, 9940193730906732965), ScreenOverlayCollectionBase)
agcls.AgTypeNameMap["ScreenOverlayCollectionBase"] = ScreenOverlayCollectionBase

class Texture2DFactory(ITexture2DFactory, SupportsDeleteCallback):
    """A factory for creating texture 2d objects from various sources."""

    def __init__(self, sourceObject=None):
        """Construct an object of type Texture2DFactory."""
        SupportsDeleteCallback.__init__(self)
        ITexture2DFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITexture2DFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, Texture2DFactory, [ITexture2DFactory])

agcls.AgClassCatalog.add_catalog_entry((5367179128558865548, 12869832894502700982), Texture2DFactory)
agcls.AgTypeNameMap["Texture2DFactory"] = Texture2DFactory

class VisualEffects(IVisualEffects, SupportsDeleteCallback):
    """Control various post processing effects that can be applied to the scene."""

    def __init__(self, sourceObject=None):
        """Construct an object of type VisualEffects."""
        SupportsDeleteCallback.__init__(self)
        IVisualEffects.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVisualEffects._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VisualEffects, [IVisualEffects])

agcls.AgClassCatalog.add_catalog_entry((4977432288877815513, 5251131146797115811), VisualEffects)
agcls.AgTypeNameMap["VisualEffects"] = VisualEffects

class AltitudeDisplayCondition(IAltitudeDisplayCondition, IDisplayCondition, SupportsDeleteCallback):
    """Define an inclusive altitude interval that determines when an object is rendered based on the camera's altitude relative to a central body."""

    def __init__(self, sourceObject=None):
        """Construct an object of type AltitudeDisplayCondition."""
        SupportsDeleteCallback.__init__(self)
        IAltitudeDisplayCondition.__init__(self, sourceObject)
        IDisplayCondition.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAltitudeDisplayCondition._private_init(self, intf)
        IDisplayCondition._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AltitudeDisplayCondition, [IAltitudeDisplayCondition, IDisplayCondition])

agcls.AgClassCatalog.add_catalog_entry((4955129817930386074, 3136574299604980158), AltitudeDisplayCondition)
agcls.AgTypeNameMap["AltitudeDisplayCondition"] = AltitudeDisplayCondition

class AxesPrimitive(IAxesPrimitive, IPrimitive, SupportsDeleteCallback):
    """Render an axes in the 3D scene."""

    def __init__(self, sourceObject=None):
        """Construct an object of type AxesPrimitive."""
        SupportsDeleteCallback.__init__(self)
        IAxesPrimitive.__init__(self, sourceObject)
        IPrimitive.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAxesPrimitive._private_init(self, intf)
        IPrimitive._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AxesPrimitive, [IAxesPrimitive, IPrimitive])

agcls.AgClassCatalog.add_catalog_entry((5590121640589148486, 2256538052145833109), AxesPrimitive)
agcls.AgTypeNameMap["AxesPrimitive"] = AxesPrimitive

class Camera(ICamera, SupportsDeleteCallback):
    """Implemented by the scene camera. Contains operations to manipulate the camera position, view direction and orientation in the scene."""

    def __init__(self, sourceObject=None):
        """Construct an object of type Camera."""
        SupportsDeleteCallback.__init__(self)
        ICamera.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICamera._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, Camera, [ICamera])

agcls.AgClassCatalog.add_catalog_entry((5108901659268738630, 12673905154193258132), Camera)
agcls.AgTypeNameMap["Camera"] = Camera

class CentralBodyGraphics(ICentralBodyGraphics, SupportsDeleteCallback):
    """The graphical properties associated with a particular central body. Changing the central body graphics will affect how the associated central body is rendered in a scene. For instance, to show or hide the central body, use the show property..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type CentralBodyGraphics."""
        SupportsDeleteCallback.__init__(self)
        ICentralBodyGraphics.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICentralBodyGraphics._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CentralBodyGraphics, [ICentralBodyGraphics])

agcls.AgClassCatalog.add_catalog_entry((5237454306453849929, 16985193427983583917), CentralBodyGraphics)
agcls.AgTypeNameMap["CentralBodyGraphics"] = CentralBodyGraphics

class Clouds(IClouds, SupportsDeleteCallback):
    """Load, show and hide clouds in the scene."""

    def __init__(self, sourceObject=None):
        """Construct an object of type Clouds."""
        SupportsDeleteCallback.__init__(self)
        IClouds.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IClouds._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, Clouds, [IClouds])

agcls.AgClassCatalog.add_catalog_entry((4674132715452051907, 2514679956769629370), Clouds)
agcls.AgTypeNameMap["Clouds"] = Clouds

class CompositeDisplayCondition(ICompositeDisplayCondition, IDisplayCondition, SupportsDeleteCallback):
    """A composite of display conditions combined using a binary logic operation. For example, several time interval display condition objects can be added to a composite..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type CompositeDisplayCondition."""
        SupportsDeleteCallback.__init__(self)
        ICompositeDisplayCondition.__init__(self, sourceObject)
        IDisplayCondition.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICompositeDisplayCondition._private_init(self, intf)
        IDisplayCondition._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CompositeDisplayCondition, [ICompositeDisplayCondition, IDisplayCondition])

agcls.AgClassCatalog.add_catalog_entry((5056547403870315286, 10247967535919804347), CompositeDisplayCondition)
agcls.AgTypeNameMap["CompositeDisplayCondition"] = CompositeDisplayCondition

class CompositePrimitive(ICompositePrimitive, IPrimitive, SupportsDeleteCallback):
    """A primitive that is composed of multiple other primitives. Since composites can contain other composites, they are commonly used to build hierarchies of primitives to efficiently evaluate display conditions..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type CompositePrimitive."""
        SupportsDeleteCallback.__init__(self)
        ICompositePrimitive.__init__(self, sourceObject)
        IPrimitive.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICompositePrimitive._private_init(self, intf)
        IPrimitive._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CompositePrimitive, [ICompositePrimitive, IPrimitive])

agcls.AgClassCatalog.add_catalog_entry((4679944565974591928, 1696005919734520764), CompositePrimitive)
agcls.AgTypeNameMap["CompositePrimitive"] = CompositePrimitive

class ConstantDisplayCondition(IConstantDisplayCondition, IDisplayCondition, SupportsDeleteCallback):
    """A display condition that evaluates to a user-defined value. This is commonly used to hide primitives by assigning to a primitive a display condition that always returns false."""

    def __init__(self, sourceObject=None):
        """Construct an object of type ConstantDisplayCondition."""
        SupportsDeleteCallback.__init__(self)
        IConstantDisplayCondition.__init__(self, sourceObject)
        IDisplayCondition.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IConstantDisplayCondition._private_init(self, intf)
        IDisplayCondition._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, ConstantDisplayCondition, [IConstantDisplayCondition, IDisplayCondition])

agcls.AgClassCatalog.add_catalog_entry((4696539255304361128, 11784871788123951251), ConstantDisplayCondition)
agcls.AgTypeNameMap["ConstantDisplayCondition"] = ConstantDisplayCondition

class DisplayCondition(IDisplayCondition, SupportsDeleteCallback):
    """When assigned to objects, such as primitives or globe overlays, display conditions are evaluated to determine if the object should be rendered."""

    def __init__(self, sourceObject=None):
        """Construct an object of type DisplayCondition."""
        SupportsDeleteCallback.__init__(self)
        IDisplayCondition.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IDisplayCondition._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, DisplayCondition, [IDisplayCondition])

agcls.AgClassCatalog.add_catalog_entry((5534179541775668715, 2760636606459100605), DisplayCondition)
agcls.AgTypeNameMap["DisplayCondition"] = DisplayCondition

class DistanceDisplayCondition(IDistanceDisplayCondition, IDisplayCondition, SupportsDeleteCallback):
    """Define an inclusive distance interval that determines when an object, such as a primitive, is rendered based on the distance from the camera to the object."""

    def __init__(self, sourceObject=None):
        """Construct an object of type DistanceDisplayCondition."""
        SupportsDeleteCallback.__init__(self)
        IDistanceDisplayCondition.__init__(self, sourceObject)
        IDisplayCondition.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IDistanceDisplayCondition._private_init(self, intf)
        IDisplayCondition._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, DistanceDisplayCondition, [IDistanceDisplayCondition, IDisplayCondition])

agcls.AgClassCatalog.add_catalog_entry((4724647536857811400, 16315685751390164157), DistanceDisplayCondition)
agcls.AgTypeNameMap["DistanceDisplayCondition"] = DistanceDisplayCondition

class DistanceToGlobeOverlayDisplayCondition(IDistanceToGlobeOverlayDisplayCondition, IDisplayCondition, SupportsDeleteCallback):
    """Define an inclusive distance interval that determines when an object, such as a primitive, is rendered based on the distance from the camera to the globe overlay..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type DistanceToGlobeOverlayDisplayCondition."""
        SupportsDeleteCallback.__init__(self)
        IDistanceToGlobeOverlayDisplayCondition.__init__(self, sourceObject)
        IDisplayCondition.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IDistanceToGlobeOverlayDisplayCondition._private_init(self, intf)
        IDisplayCondition._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, DistanceToGlobeOverlayDisplayCondition, [IDistanceToGlobeOverlayDisplayCondition, IDisplayCondition])

agcls.AgClassCatalog.add_catalog_entry((5635816365580515097, 2186556296694528415), DistanceToGlobeOverlayDisplayCondition)
agcls.AgTypeNameMap["DistanceToGlobeOverlayDisplayCondition"] = DistanceToGlobeOverlayDisplayCondition

class DistanceToPositionDisplayCondition(IDistanceToPositionDisplayCondition, IDisplayCondition, SupportsDeleteCallback):
    """Define an inclusive distance interval that determines when an object, such as a primitive, is rendered based on the distance from the camera to a position defined in the given reference frame."""

    def __init__(self, sourceObject=None):
        """Construct an object of type DistanceToPositionDisplayCondition."""
        SupportsDeleteCallback.__init__(self)
        IDistanceToPositionDisplayCondition.__init__(self, sourceObject)
        IDisplayCondition.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IDistanceToPositionDisplayCondition._private_init(self, intf)
        IDisplayCondition._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, DistanceToPositionDisplayCondition, [IDistanceToPositionDisplayCondition, IDisplayCondition])

agcls.AgClassCatalog.add_catalog_entry((5302119056589105291, 9372472331107240618), DistanceToPositionDisplayCondition)
agcls.AgTypeNameMap["DistanceToPositionDisplayCondition"] = DistanceToPositionDisplayCondition

class DistanceToPrimitiveDisplayCondition(IDistanceToPrimitiveDisplayCondition, IDisplayCondition, SupportsDeleteCallback):
    """Define an inclusive distance interval that determines when an object, such as a screen overlay, is rendered based on the distance from the camera to the primitive..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type DistanceToPrimitiveDisplayCondition."""
        SupportsDeleteCallback.__init__(self)
        IDistanceToPrimitiveDisplayCondition.__init__(self, sourceObject)
        IDisplayCondition.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IDistanceToPrimitiveDisplayCondition._private_init(self, intf)
        IDisplayCondition._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, DistanceToPrimitiveDisplayCondition, [IDistanceToPrimitiveDisplayCondition, IDisplayCondition])

agcls.AgClassCatalog.add_catalog_entry((4865980936982214573, 11744636288922726806), DistanceToPrimitiveDisplayCondition)
agcls.AgTypeNameMap["DistanceToPrimitiveDisplayCondition"] = DistanceToPrimitiveDisplayCondition

class DurationPathPrimitiveUpdatePolicy(IDurationPathPrimitiveUpdatePolicy, IPathPrimitiveUpdatePolicy, SupportsDeleteCallback):
    """path primitive update policy that removes points from remove location after a given duration."""

    def __init__(self, sourceObject=None):
        """Construct an object of type DurationPathPrimitiveUpdatePolicy."""
        SupportsDeleteCallback.__init__(self)
        IDurationPathPrimitiveUpdatePolicy.__init__(self, sourceObject)
        IPathPrimitiveUpdatePolicy.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IDurationPathPrimitiveUpdatePolicy._private_init(self, intf)
        IPathPrimitiveUpdatePolicy._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, DurationPathPrimitiveUpdatePolicy, [IDurationPathPrimitiveUpdatePolicy, IPathPrimitiveUpdatePolicy])

agcls.AgClassCatalog.add_catalog_entry((4983364944216509688, 6094502157445632944), DurationPathPrimitiveUpdatePolicy)
agcls.AgTypeNameMap["DurationPathPrimitiveUpdatePolicy"] = DurationPathPrimitiveUpdatePolicy

class FrameRate(IFrameRate, SupportsDeleteCallback):
    """Keeps track of how many times the scenes are rendered per second."""

    def __init__(self, sourceObject=None):
        """Construct an object of type FrameRate."""
        SupportsDeleteCallback.__init__(self)
        IFrameRate.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IFrameRate._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, FrameRate, [IFrameRate])

agcls.AgClassCatalog.add_catalog_entry((5661427371560056203, 8596066061557213330), FrameRate)
agcls.AgTypeNameMap["FrameRate"] = FrameRate

class GlobeImageOverlay(IGlobeImageOverlay, IGlobeOverlay, SupportsDeleteCallback):
    """A globe overlay that shows an image."""

    def __init__(self, sourceObject=None):
        """Construct an object of type GlobeImageOverlay."""
        SupportsDeleteCallback.__init__(self)
        IGlobeImageOverlay.__init__(self, sourceObject)
        IGlobeOverlay.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IGlobeImageOverlay._private_init(self, intf)
        IGlobeOverlay._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, GlobeImageOverlay, [IGlobeImageOverlay, IGlobeOverlay])

agcls.AgClassCatalog.add_catalog_entry((5054499037824607794, 413485819247292294), GlobeImageOverlay)
agcls.AgTypeNameMap["GlobeImageOverlay"] = GlobeImageOverlay

class GraphicsFont(IGraphicsFont, SupportsDeleteCallback):
    """A font that is suitable for use with the text batch primitive. For best performance, avoid creating duplicate font objects. Instead assign the same font object to several text batch primitives."""

    def __init__(self, sourceObject=None):
        """Construct an object of type GraphicsFont."""
        SupportsDeleteCallback.__init__(self)
        IGraphicsFont.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IGraphicsFont._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, GraphicsFont, [IGraphicsFont])

agcls.AgClassCatalog.add_catalog_entry((5356821517110532063, 5967199020230626694), GraphicsFont)
agcls.AgTypeNameMap["GraphicsFont"] = GraphicsFont

class GreatArcInterpolator(IGreatArcInterpolator, IPositionInterpolator, SupportsDeleteCallback):
    """The great arc interpolator computes interpolated positions along a great arc. A great arc is the shortest path between two positions on an ellipsoid."""

    def __init__(self, sourceObject=None):
        """Construct an object of type GreatArcInterpolator."""
        SupportsDeleteCallback.__init__(self)
        IGreatArcInterpolator.__init__(self, sourceObject)
        IPositionInterpolator.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IGreatArcInterpolator._private_init(self, intf)
        IPositionInterpolator._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, GreatArcInterpolator, [IGreatArcInterpolator, IPositionInterpolator])

agcls.AgClassCatalog.add_catalog_entry((4684714647278503789, 7032991952565857945), GreatArcInterpolator)
agcls.AgTypeNameMap["GreatArcInterpolator"] = GreatArcInterpolator

class ImageCollection(IImageCollection, SupportsDeleteCallback):
    """A collection of globe image overlay objects."""

    def __init__(self, sourceObject=None):
        """Construct an object of type ImageCollection."""
        SupportsDeleteCallback.__init__(self)
        IImageCollection.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IImageCollection._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, ImageCollection, [IImageCollection])

agcls.AgClassCatalog.add_catalog_entry((4995629646927179478, 4428875884696510368), ImageCollection)
agcls.AgTypeNameMap["ImageCollection"] = ImageCollection

class AlphaFromLuminanceFilter(IAlphaFromLuminanceFilter, IRasterFilter, SupportsDeleteCallback):
    """Add an alpha band to the source raster derived from the luminance of the raster's color bands."""

    def __init__(self, sourceObject=None):
        """Construct an object of type AlphaFromLuminanceFilter."""
        SupportsDeleteCallback.__init__(self)
        IAlphaFromLuminanceFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAlphaFromLuminanceFilter._private_init(self, intf)
        IRasterFilter._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AlphaFromLuminanceFilter, [IAlphaFromLuminanceFilter, IRasterFilter])

agcls.AgClassCatalog.add_catalog_entry((4722571570623942599, 5628231633018734501), AlphaFromLuminanceFilter)
agcls.AgTypeNameMap["AlphaFromLuminanceFilter"] = AlphaFromLuminanceFilter

class AlphaFromPixelFilter(IAlphaFromPixelFilter, IRasterFilter, SupportsDeleteCallback):
    """Add an alpha band to the source raster based on the value of its first pixel. All pixels in the source raster that are the same color as the first pixel will be made transparent."""

    def __init__(self, sourceObject=None):
        """Construct an object of type AlphaFromPixelFilter."""
        SupportsDeleteCallback.__init__(self)
        IAlphaFromPixelFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAlphaFromPixelFilter._private_init(self, intf)
        IRasterFilter._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AlphaFromPixelFilter, [IAlphaFromPixelFilter, IRasterFilter])

agcls.AgClassCatalog.add_catalog_entry((5429264897698608035, 15843209762042389916), AlphaFromPixelFilter)
agcls.AgTypeNameMap["AlphaFromPixelFilter"] = AlphaFromPixelFilter

class AlphaFromRasterFilter(IAlphaFromRasterFilter, IRasterFilter, SupportsDeleteCallback):
    """Add an alpha band to the source raster derived from the color bands or alpha of another raster. This filter can be used to apply an alpha mask to the source raster."""

    def __init__(self, sourceObject=None):
        """Construct an object of type AlphaFromRasterFilter."""
        SupportsDeleteCallback.__init__(self)
        IAlphaFromRasterFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAlphaFromRasterFilter._private_init(self, intf)
        IRasterFilter._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AlphaFromRasterFilter, [IAlphaFromRasterFilter, IRasterFilter])

agcls.AgClassCatalog.add_catalog_entry((5547320112593478317, 12913140405057436290), AlphaFromRasterFilter)
agcls.AgTypeNameMap["AlphaFromRasterFilter"] = AlphaFromRasterFilter

class BandExtractFilter(IBandExtractFilter, IRasterFilter, SupportsDeleteCallback):
    """Extract a band or set of bands from the source raster. The extract format property specifies the bands and the order of the bands that will be extracted."""

    def __init__(self, sourceObject=None):
        """Construct an object of type BandExtractFilter."""
        SupportsDeleteCallback.__init__(self)
        IBandExtractFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IBandExtractFilter._private_init(self, intf)
        IRasterFilter._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, BandExtractFilter, [IBandExtractFilter, IRasterFilter])

agcls.AgClassCatalog.add_catalog_entry((4670582174218548926, 16305220027283324064), BandExtractFilter)
agcls.AgTypeNameMap["BandExtractFilter"] = BandExtractFilter

class BandOrderFilter(IBandOrderFilter, IRasterFilter, SupportsDeleteCallback):
    """Reorders or swizzles the bands of the source raster to match the band order of the raster format specified by the band order property. When maintain raster format is true, the source raster's format is maintained after swizzling."""

    def __init__(self, sourceObject=None):
        """Construct an object of type BandOrderFilter."""
        SupportsDeleteCallback.__init__(self)
        IBandOrderFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IBandOrderFilter._private_init(self, intf)
        IRasterFilter._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, BandOrderFilter, [IBandOrderFilter, IRasterFilter])

agcls.AgClassCatalog.add_catalog_entry((5508330069622562004, 4666322603866800813), BandOrderFilter)
agcls.AgTypeNameMap["BandOrderFilter"] = BandOrderFilter

class BlurFilter(IBlurFilter, IConvolutionFilter, IRasterFilter, SupportsDeleteCallback):
    """Apply a convolution filter to blur or smooth the source raster. Can be used to reduce noise in the raster."""

    def __init__(self, sourceObject=None):
        """Construct an object of type BlurFilter."""
        SupportsDeleteCallback.__init__(self)
        IBlurFilter.__init__(self, sourceObject)
        IConvolutionFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IBlurFilter._private_init(self, intf)
        IConvolutionFilter._private_init(self, intf)
        IRasterFilter._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, BlurFilter, [IBlurFilter, IConvolutionFilter, IRasterFilter])

agcls.AgClassCatalog.add_catalog_entry((5356994569384825487, 17441113390663035052), BlurFilter)
agcls.AgTypeNameMap["BlurFilter"] = BlurFilter

class BrightnessFilter(IBrightnessFilter, IRasterFilter, SupportsDeleteCallback):
    """Adjusts the brightness of the source raster's color bands. The adjustment to brightness is a value between -1 and 1, corresponding to least bright to most bright."""

    def __init__(self, sourceObject=None):
        """Construct an object of type BrightnessFilter."""
        SupportsDeleteCallback.__init__(self)
        IBrightnessFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IBrightnessFilter._private_init(self, intf)
        IRasterFilter._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, BrightnessFilter, [IBrightnessFilter, IRasterFilter])

agcls.AgClassCatalog.add_catalog_entry((4740712509231548782, 14535850336571086782), BrightnessFilter)
agcls.AgTypeNameMap["BrightnessFilter"] = BrightnessFilter

class ColorToLuminanceFilter(IColorToLuminanceFilter, IRasterFilter, SupportsDeleteCallback):
    """Extract a luminance band derived from the color bands of the source raster."""

    def __init__(self, sourceObject=None):
        """Construct an object of type ColorToLuminanceFilter."""
        SupportsDeleteCallback.__init__(self)
        IColorToLuminanceFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IColorToLuminanceFilter._private_init(self, intf)
        IRasterFilter._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, ColorToLuminanceFilter, [IColorToLuminanceFilter, IRasterFilter])

agcls.AgClassCatalog.add_catalog_entry((5263196667381229446, 16063846929670924173), ColorToLuminanceFilter)
agcls.AgTypeNameMap["ColorToLuminanceFilter"] = ColorToLuminanceFilter

class ContrastFilter(IContrastFilter, IRasterFilter, SupportsDeleteCallback):
    """Adjusts the contrast of the source raster. The adjustment to contrast is a value between -1 and 1, corresponding to least contrast to most contrast."""

    def __init__(self, sourceObject=None):
        """Construct an object of type ContrastFilter."""
        SupportsDeleteCallback.__init__(self)
        IContrastFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IContrastFilter._private_init(self, intf)
        IRasterFilter._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, ContrastFilter, [IContrastFilter, IRasterFilter])

agcls.AgClassCatalog.add_catalog_entry((5610975873394682488, 7350282519019509636), ContrastFilter)
agcls.AgTypeNameMap["ContrastFilter"] = ContrastFilter

class ConvolutionFilter(IConvolutionFilter, IRasterFilter, SupportsDeleteCallback):
    """Apply convolution to the source raster. Convolution is the modification of a pixel's value based on the values of its surrounding pixels. The kernel is the numerical matrix that is applied to each pixel in this process..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type ConvolutionFilter."""
        SupportsDeleteCallback.__init__(self)
        IConvolutionFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IConvolutionFilter._private_init(self, intf)
        IRasterFilter._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, ConvolutionFilter, [IConvolutionFilter, IRasterFilter])

agcls.AgClassCatalog.add_catalog_entry((5313620495361217438, 6605686187729587107), ConvolutionFilter)
agcls.AgTypeNameMap["ConvolutionFilter"] = ConvolutionFilter

class EdgeDetectFilter(IEdgeDetectFilter, IConvolutionFilter, IRasterFilter, SupportsDeleteCallback):
    """Apply a convolution filter to detect edges in the source raster."""

    def __init__(self, sourceObject=None):
        """Construct an object of type EdgeDetectFilter."""
        SupportsDeleteCallback.__init__(self)
        IEdgeDetectFilter.__init__(self, sourceObject)
        IConvolutionFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IEdgeDetectFilter._private_init(self, intf)
        IConvolutionFilter._private_init(self, intf)
        IRasterFilter._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, EdgeDetectFilter, [IEdgeDetectFilter, IConvolutionFilter, IRasterFilter])

agcls.AgClassCatalog.add_catalog_entry((5684449418894848279, 6096710836454509957), EdgeDetectFilter)
agcls.AgTypeNameMap["EdgeDetectFilter"] = EdgeDetectFilter

class FilteringRasterStream(IFilteringRasterStream, IRasterStream, IRaster, SupportsDeleteCallback):
    """A class decorator for applying a raster filter to each update of a raster stream. Can be used to apply filters to videos and other raster streams as they are updated."""

    def __init__(self, sourceObject=None):
        """Construct an object of type FilteringRasterStream."""
        SupportsDeleteCallback.__init__(self)
        IFilteringRasterStream.__init__(self, sourceObject)
        IRasterStream.__init__(self, sourceObject)
        IRaster.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IFilteringRasterStream._private_init(self, intf)
        IRasterStream._private_init(self, intf)
        IRaster._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, FilteringRasterStream, [IFilteringRasterStream, IRasterStream, IRaster])

agcls.AgClassCatalog.add_catalog_entry((5586045703451962665, 1497506555285606334), FilteringRasterStream)
agcls.AgTypeNameMap["FilteringRasterStream"] = FilteringRasterStream

class FlipFilter(IFlipFilter, IRasterFilter, SupportsDeleteCallback):
    """Flips the source raster along the given flip axis."""

    def __init__(self, sourceObject=None):
        """Construct an object of type FlipFilter."""
        SupportsDeleteCallback.__init__(self)
        IFlipFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IFlipFilter._private_init(self, intf)
        IRasterFilter._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, FlipFilter, [IFlipFilter, IRasterFilter])

agcls.AgClassCatalog.add_catalog_entry((5437148251484636253, 14073922228357934739), FlipFilter)
agcls.AgTypeNameMap["FlipFilter"] = FlipFilter

class GammaCorrectionFilter(IGammaCorrectionFilter, IRasterFilter, SupportsDeleteCallback):
    """Apply gamma correction to the source raster. The gamma is a value between .2 and 5. The default gamma value is 2.2."""

    def __init__(self, sourceObject=None):
        """Construct an object of type GammaCorrectionFilter."""
        SupportsDeleteCallback.__init__(self)
        IGammaCorrectionFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IGammaCorrectionFilter._private_init(self, intf)
        IRasterFilter._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, GammaCorrectionFilter, [IGammaCorrectionFilter, IRasterFilter])

agcls.AgClassCatalog.add_catalog_entry((4971206815743257794, 3457815322738687141), GammaCorrectionFilter)
agcls.AgTypeNameMap["GammaCorrectionFilter"] = GammaCorrectionFilter

class GaussianBlurFilter(IGaussianBlurFilter, IConvolutionFilter, IRasterFilter, SupportsDeleteCallback):
    """Apply a convolution filter to blur the source raster using the Gaussian function."""

    def __init__(self, sourceObject=None):
        """Construct an object of type GaussianBlurFilter."""
        SupportsDeleteCallback.__init__(self)
        IGaussianBlurFilter.__init__(self, sourceObject)
        IConvolutionFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IGaussianBlurFilter._private_init(self, intf)
        IConvolutionFilter._private_init(self, intf)
        IRasterFilter._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, GaussianBlurFilter, [IGaussianBlurFilter, IConvolutionFilter, IRasterFilter])

agcls.AgClassCatalog.add_catalog_entry((5243991897188228892, 16020720209640064388), GaussianBlurFilter)
agcls.AgTypeNameMap["GaussianBlurFilter"] = GaussianBlurFilter

class GradientDetectFilter(IGradientDetectFilter, IConvolutionFilter, IRasterFilter, SupportsDeleteCallback):
    """Apply a convolution filter to detect gradients in the source raster."""

    def __init__(self, sourceObject=None):
        """Construct an object of type GradientDetectFilter."""
        SupportsDeleteCallback.__init__(self)
        IGradientDetectFilter.__init__(self, sourceObject)
        IConvolutionFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IGradientDetectFilter._private_init(self, intf)
        IConvolutionFilter._private_init(self, intf)
        IRasterFilter._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, GradientDetectFilter, [IGradientDetectFilter, IConvolutionFilter, IRasterFilter])

agcls.AgClassCatalog.add_catalog_entry((5702333424249933103, 4668764555581523625), GradientDetectFilter)
agcls.AgTypeNameMap["GradientDetectFilter"] = GradientDetectFilter

class LevelsFilter(ILevelsFilter, IRasterFilter, SupportsDeleteCallback):
    """Adjusts the band levels of the source raster linearly."""

    def __init__(self, sourceObject=None):
        """Construct an object of type LevelsFilter."""
        SupportsDeleteCallback.__init__(self)
        ILevelsFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ILevelsFilter._private_init(self, intf)
        IRasterFilter._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, LevelsFilter, [ILevelsFilter, IRasterFilter])

agcls.AgClassCatalog.add_catalog_entry((5172734455644479740, 6694396930833260958), LevelsFilter)
agcls.AgTypeNameMap["LevelsFilter"] = LevelsFilter

class ProjectionRasterStreamPluginActivator(IProjectionRasterStreamPluginActivator, SupportsDeleteCallback):
    """The Activator class provides methods to load COM plugins that implement projection and raster streaming. For more information about the projection and raster plugins, see the STK Programming Interface."""

    def __init__(self, sourceObject=None):
        """Construct an object of type ProjectionRasterStreamPluginActivator."""
        SupportsDeleteCallback.__init__(self)
        IProjectionRasterStreamPluginActivator.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IProjectionRasterStreamPluginActivator._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, ProjectionRasterStreamPluginActivator, [IProjectionRasterStreamPluginActivator])

agcls.AgClassCatalog.add_catalog_entry((5592773854379758628, 9250413242335431090), ProjectionRasterStreamPluginActivator)
agcls.AgTypeNameMap["ProjectionRasterStreamPluginActivator"] = ProjectionRasterStreamPluginActivator

class ProjectionRasterStreamPluginProxy(IProjectionRasterStreamPluginProxy, SupportsDeleteCallback):
    """A proxy class provides access to the raster and projection streams implemented by a plugin. Proxies are instantiated using projection raster stream plugin activator."""

    def __init__(self, sourceObject=None):
        """Construct an object of type ProjectionRasterStreamPluginProxy."""
        SupportsDeleteCallback.__init__(self)
        IProjectionRasterStreamPluginProxy.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IProjectionRasterStreamPluginProxy._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, ProjectionRasterStreamPluginProxy, [IProjectionRasterStreamPluginProxy])

agcls.AgClassCatalog.add_catalog_entry((4666815726913761780, 2357661832715587970), ProjectionRasterStreamPluginProxy)
agcls.AgTypeNameMap["ProjectionRasterStreamPluginProxy"] = ProjectionRasterStreamPluginProxy

class Raster(IRaster, SupportsDeleteCallback):
    """A raster dataset. A raster consists of one or more bands, or sets of values, which are most commonly associated with colors when the raster represents an image..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type Raster."""
        SupportsDeleteCallback.__init__(self)
        IRaster.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IRaster._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, Raster, [IRaster])

agcls.AgClassCatalog.add_catalog_entry((5051161684986260026, 10586440812956719515), Raster)
agcls.AgTypeNameMap["Raster"] = Raster

class RasterAttributes(IRasterAttributes, SupportsDeleteCallback):
    """The attributes describing a raster dataset. raster attributes define the memory layout of a raster, and includes properties defining the order of each raster band that the raster contains, as specified by the raster format..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type RasterAttributes."""
        SupportsDeleteCallback.__init__(self)
        IRasterAttributes.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IRasterAttributes._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, RasterAttributes, [IRasterAttributes])

agcls.AgClassCatalog.add_catalog_entry((4877134759318171914, 3568483647780173482), RasterAttributes)
agcls.AgTypeNameMap["RasterAttributes"] = RasterAttributes

class RasterFilter(IRasterFilter, SupportsDeleteCallback):
    """A filter for processing raster datasets. RasterFilter is the base class for all raster filters..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type RasterFilter."""
        SupportsDeleteCallback.__init__(self)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IRasterFilter._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, RasterFilter, [IRasterFilter])

agcls.AgClassCatalog.add_catalog_entry((4815410842910981470, 4827660083801860526), RasterFilter)
agcls.AgTypeNameMap["RasterFilter"] = RasterFilter

class RasterStream(IRasterStream, IRaster, SupportsDeleteCallback):
    """A raster, the data of which, is updated dynamically at the specified update delta. The class can be used to stream video and other dynamic raster data to textures and other raster clients..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type RasterStream."""
        SupportsDeleteCallback.__init__(self)
        IRasterStream.__init__(self, sourceObject)
        IRaster.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IRasterStream._private_init(self, intf)
        IRaster._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, RasterStream, [IRasterStream, IRaster])

agcls.AgClassCatalog.add_catalog_entry((5092607167961947230, 5072153283411839421), RasterStream)
agcls.AgTypeNameMap["RasterStream"] = RasterStream

class RotateFilter(IRotateFilter, IRasterFilter, SupportsDeleteCallback):
    """Rotate the source raster clockwise by the specified angle."""

    def __init__(self, sourceObject=None):
        """Construct an object of type RotateFilter."""
        SupportsDeleteCallback.__init__(self)
        IRotateFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IRotateFilter._private_init(self, intf)
        IRasterFilter._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, RotateFilter, [IRotateFilter, IRasterFilter])

agcls.AgClassCatalog.add_catalog_entry((5555725880336034116, 6980653760117414296), RotateFilter)
agcls.AgTypeNameMap["RotateFilter"] = RotateFilter

class SequenceFilter(ISequenceFilter, IRasterFilter, SupportsDeleteCallback):
    """Apply a sequence of filters to the source raster in the order in which they were added. When continue on failure is set to true, subsequent filters will still be applied to the source raster even if one or more filters in the sequence cannot be applied."""

    def __init__(self, sourceObject=None):
        """Construct an object of type SequenceFilter."""
        SupportsDeleteCallback.__init__(self)
        ISequenceFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISequenceFilter._private_init(self, intf)
        IRasterFilter._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SequenceFilter, [ISequenceFilter, IRasterFilter])

agcls.AgClassCatalog.add_catalog_entry((5178454568068120612, 18196126380549294229), SequenceFilter)
agcls.AgTypeNameMap["SequenceFilter"] = SequenceFilter

class SharpenFilter(ISharpenFilter, IConvolutionFilter, IRasterFilter, SupportsDeleteCallback):
    """Apply a convolution filter to increase the sharpness of the source raster."""

    def __init__(self, sourceObject=None):
        """Construct an object of type SharpenFilter."""
        SupportsDeleteCallback.__init__(self)
        ISharpenFilter.__init__(self, sourceObject)
        IConvolutionFilter.__init__(self, sourceObject)
        IRasterFilter.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISharpenFilter._private_init(self, intf)
        IConvolutionFilter._private_init(self, intf)
        IRasterFilter._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SharpenFilter, [ISharpenFilter, IConvolutionFilter, IRasterFilter])

agcls.AgClassCatalog.add_catalog_entry((4732670840778244873, 7942996488696084135), SharpenFilter)
agcls.AgTypeNameMap["SharpenFilter"] = SharpenFilter

class VideoStream(IVideoStream, IRasterStream, IRaster, SupportsDeleteCallback):
    """A raster stream that streams from a video. The video can be read from a file, or streamed from an HTTP, RTP, UDP, or TCP source. See the Video Streams Overview for a list of supported video formats and Uri usage."""

    def __init__(self, sourceObject=None):
        """Construct an object of type VideoStream."""
        SupportsDeleteCallback.__init__(self)
        IVideoStream.__init__(self, sourceObject)
        IRasterStream.__init__(self, sourceObject)
        IRaster.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVideoStream._private_init(self, intf)
        IRasterStream._private_init(self, intf)
        IRaster._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VideoStream, [IVideoStream, IRasterStream, IRaster])

agcls.AgClassCatalog.add_catalog_entry((5264945989350337942, 5699888751394667448), VideoStream)
agcls.AgTypeNameMap["VideoStream"] = VideoStream

class KmlContainer(IKmlContainer, IKmlFeature, SupportsDeleteCallback):
    """A KmlContainer contains a collection of children kml features."""

    def __init__(self, sourceObject=None):
        """Construct an object of type KmlContainer."""
        SupportsDeleteCallback.__init__(self)
        IKmlContainer.__init__(self, sourceObject)
        IKmlFeature.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IKmlContainer._private_init(self, intf)
        IKmlFeature._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, KmlContainer, [IKmlContainer, IKmlFeature])

agcls.AgClassCatalog.add_catalog_entry((5207640554160657301, 13820029748964872873), KmlContainer)
agcls.AgTypeNameMap["KmlContainer"] = KmlContainer

class KmlDocument(IKmlDocument, IKmlContainer, IKmlFeature, SupportsDeleteCallback):
    """A KML document."""

    def __init__(self, sourceObject=None):
        """Construct an object of type KmlDocument."""
        SupportsDeleteCallback.__init__(self)
        IKmlDocument.__init__(self, sourceObject)
        IKmlContainer.__init__(self, sourceObject)
        IKmlFeature.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IKmlDocument._private_init(self, intf)
        IKmlContainer._private_init(self, intf)
        IKmlFeature._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, KmlDocument, [IKmlDocument, IKmlContainer, IKmlFeature])

agcls.AgClassCatalog.add_catalog_entry((5491088363673258432, 7394732558227195802), KmlDocument)
agcls.AgTypeNameMap["KmlDocument"] = KmlDocument

class KmlFeature(IKmlFeature, SupportsDeleteCallback):
    """A KML feature."""

    def __init__(self, sourceObject=None):
        """Construct an object of type KmlFeature."""
        SupportsDeleteCallback.__init__(self)
        IKmlFeature.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IKmlFeature._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, KmlFeature, [IKmlFeature])

agcls.AgClassCatalog.add_catalog_entry((5287385400858546424, 10878200550364879277), KmlFeature)
agcls.AgTypeNameMap["KmlFeature"] = KmlFeature

class KmlFolder(IKmlFolder, IKmlContainer, IKmlFeature, SupportsDeleteCallback):
    """A KML folder."""

    def __init__(self, sourceObject=None):
        """Construct an object of type KmlFolder."""
        SupportsDeleteCallback.__init__(self)
        IKmlFolder.__init__(self, sourceObject)
        IKmlContainer.__init__(self, sourceObject)
        IKmlFeature.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IKmlFolder._private_init(self, intf)
        IKmlContainer._private_init(self, intf)
        IKmlFeature._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, KmlFolder, [IKmlFolder, IKmlContainer, IKmlFeature])

agcls.AgClassCatalog.add_catalog_entry((4798630207118252685, 15038644232865021358), KmlFolder)
agcls.AgTypeNameMap["KmlFolder"] = KmlFolder

class KmlGraphics(IKmlGraphics, SupportsDeleteCallback):
    """Provide loading and unloading of kml documents for a particular central body."""

    def __init__(self, sourceObject=None):
        """Construct an object of type KmlGraphics."""
        SupportsDeleteCallback.__init__(self)
        IKmlGraphics.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IKmlGraphics._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, KmlGraphics, [IKmlGraphics])

agcls.AgClassCatalog.add_catalog_entry((4645898364801840606, 1292503210015328640), KmlGraphics)
agcls.AgTypeNameMap["KmlGraphics"] = KmlGraphics

class KmlNetworkLink(IKmlNetworkLink, IKmlFeature, SupportsDeleteCallback):
    """A KML network link."""

    def __init__(self, sourceObject=None):
        """Construct an object of type KmlNetworkLink."""
        SupportsDeleteCallback.__init__(self)
        IKmlNetworkLink.__init__(self, sourceObject)
        IKmlFeature.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IKmlNetworkLink._private_init(self, intf)
        IKmlFeature._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, KmlNetworkLink, [IKmlNetworkLink, IKmlFeature])

agcls.AgClassCatalog.add_catalog_entry((5504684742633507453, 16929891538998501770), KmlNetworkLink)
agcls.AgTypeNameMap["KmlNetworkLink"] = KmlNetworkLink

class MarkerBatchPrimitive(IMarkerBatchPrimitive, IPrimitive, SupportsDeleteCallback):
    """Render one or more markers in the 3D scene. Markers are 2D images that always face the viewer which can be sized in pixels or meters. Markers are also referred to as sprites or billboards..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type MarkerBatchPrimitive."""
        SupportsDeleteCallback.__init__(self)
        IMarkerBatchPrimitive.__init__(self, sourceObject)
        IPrimitive.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IMarkerBatchPrimitive._private_init(self, intf)
        IPrimitive._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, MarkerBatchPrimitive, [IMarkerBatchPrimitive, IPrimitive])

agcls.AgClassCatalog.add_catalog_entry((5505857127152130349, 2653133157377855163), MarkerBatchPrimitive)
agcls.AgTypeNameMap["MarkerBatchPrimitive"] = MarkerBatchPrimitive

class MarkerBatchPrimitiveOptionalParameters(IMarkerBatchPrimitiveOptionalParameters, SupportsDeleteCallback):
    """Optional per-marker parameters for marker batch primitive that overrides the marker batch's per-batch parameters..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type MarkerBatchPrimitiveOptionalParameters."""
        SupportsDeleteCallback.__init__(self)
        IMarkerBatchPrimitiveOptionalParameters.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IMarkerBatchPrimitiveOptionalParameters._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, MarkerBatchPrimitiveOptionalParameters, [IMarkerBatchPrimitiveOptionalParameters])

agcls.AgClassCatalog.add_catalog_entry((4765125297646667603, 6704393496158662787), MarkerBatchPrimitiveOptionalParameters)
agcls.AgTypeNameMap["MarkerBatchPrimitiveOptionalParameters"] = MarkerBatchPrimitiveOptionalParameters

class MaximumCountPathPrimitiveUpdatePolicy(IMaximumCountPathPrimitiveUpdatePolicy, IPathPrimitiveUpdatePolicy, SupportsDeleteCallback):
    """path primitive update policy that removes points from remove location when the number of points in the path exceeds maximum count."""

    def __init__(self, sourceObject=None):
        """Construct an object of type MaximumCountPathPrimitiveUpdatePolicy."""
        SupportsDeleteCallback.__init__(self)
        IMaximumCountPathPrimitiveUpdatePolicy.__init__(self, sourceObject)
        IPathPrimitiveUpdatePolicy.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IMaximumCountPathPrimitiveUpdatePolicy._private_init(self, intf)
        IPathPrimitiveUpdatePolicy._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, MaximumCountPathPrimitiveUpdatePolicy, [IMaximumCountPathPrimitiveUpdatePolicy, IPathPrimitiveUpdatePolicy])

agcls.AgClassCatalog.add_catalog_entry((5521743977193259552, 5353922303322892948), MaximumCountPathPrimitiveUpdatePolicy)
agcls.AgTypeNameMap["MaximumCountPathPrimitiveUpdatePolicy"] = MaximumCountPathPrimitiveUpdatePolicy

class ModelArticulation(IModelArticulation, SupportsDeleteCallback):
    """A model articulation identifies geometry on the model and is a collection of transformations that can be applied to that geometry."""

    def __init__(self, sourceObject=None):
        """Construct an object of type ModelArticulation."""
        SupportsDeleteCallback.__init__(self)
        IModelArticulation.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IModelArticulation._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, ModelArticulation, [IModelArticulation])

agcls.AgClassCatalog.add_catalog_entry((5583363848773512818, 10659230879766474660), ModelArticulation)
agcls.AgTypeNameMap["ModelArticulation"] = ModelArticulation

class ModelArticulationCollection(IModelArticulationCollection, SupportsDeleteCallback):
    """A collection containing a model primitive's available articulations. A model articulation identifies geometry on the model and is a collection of transformations that can be applied to that geometry."""

    def __init__(self, sourceObject=None):
        """Construct an object of type ModelArticulationCollection."""
        SupportsDeleteCallback.__init__(self)
        IModelArticulationCollection.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IModelArticulationCollection._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, ModelArticulationCollection, [IModelArticulationCollection])

agcls.AgClassCatalog.add_catalog_entry((4860630207067099658, 12153871741288218515), ModelArticulationCollection)
agcls.AgTypeNameMap["ModelArticulationCollection"] = ModelArticulationCollection

class ModelPrimitive(IModelPrimitive, IPrimitive, SupportsDeleteCallback):
    """The model primitive loads and renders `COLLADA <https://www.khronos.org/collada/>`_ (DAE) and AGI `MDL <https://support.agi.com/3d-models>`_ (MDL) models."""

    def __init__(self, sourceObject=None):
        """Construct an object of type ModelPrimitive."""
        SupportsDeleteCallback.__init__(self)
        IModelPrimitive.__init__(self, sourceObject)
        IPrimitive.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IModelPrimitive._private_init(self, intf)
        IPrimitive._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, ModelPrimitive, [IModelPrimitive, IPrimitive])

agcls.AgClassCatalog.add_catalog_entry((5272009851139634904, 10934403071105800840), ModelPrimitive)
agcls.AgTypeNameMap["ModelPrimitive"] = ModelPrimitive

class ModelTransformation(IModelTransformation, SupportsDeleteCallback):
    """A model transformation defines a transformation that is applied to geometry on a model primitive. That geometry is identified by the model articulation which contains the transformation..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type ModelTransformation."""
        SupportsDeleteCallback.__init__(self)
        IModelTransformation.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IModelTransformation._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, ModelTransformation, [IModelTransformation])

agcls.AgClassCatalog.add_catalog_entry((5494058340694028521, 8976331231816559258), ModelTransformation)
agcls.AgTypeNameMap["ModelTransformation"] = ModelTransformation

class Overlay(IOverlay, IScreenOverlayContainer, SupportsDeleteCallback):
    """A visible element drawn in screen space. Overlays are useful for floating logos, heads up displays, and integrating user interfaces into the 3D window."""

    def __init__(self, sourceObject=None):
        """Construct an object of type Overlay."""
        SupportsDeleteCallback.__init__(self)
        IOverlay.__init__(self, sourceObject)
        IScreenOverlayContainer.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IOverlay._private_init(self, intf)
        IScreenOverlayContainer._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, Overlay, [IOverlay, IScreenOverlayContainer])

agcls.AgClassCatalog.add_catalog_entry((4796068382168091195, 15893869600297649596), Overlay)
agcls.AgTypeNameMap["Overlay"] = Overlay

class PathPrimitive(IPathPrimitive, IPrimitive, SupportsDeleteCallback):
    """Render a line to the 3D scene. Similar to the polyline primitive; however, the PathPrimitive was designed for the efficient addition/removal of points to/from the front or back of the line."""

    def __init__(self, sourceObject=None):
        """Construct an object of type PathPrimitive."""
        SupportsDeleteCallback.__init__(self)
        IPathPrimitive.__init__(self, sourceObject)
        IPrimitive.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IPathPrimitive._private_init(self, intf)
        IPrimitive._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, PathPrimitive, [IPathPrimitive, IPrimitive])

agcls.AgClassCatalog.add_catalog_entry((5627175414395611667, 1200547442396153242), PathPrimitive)
agcls.AgTypeNameMap["PathPrimitive"] = PathPrimitive

class PickResult(IPickResult, SupportsDeleteCallback):
    """A single result from Pick."""

    def __init__(self, sourceObject=None):
        """Construct an object of type PickResult."""
        SupportsDeleteCallback.__init__(self)
        IPickResult.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IPickResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, PickResult, [IPickResult])

agcls.AgClassCatalog.add_catalog_entry((4613396686185153582, 5313864718031071897), PickResult)
agcls.AgTypeNameMap["PickResult"] = PickResult

class PixelSizeDisplayCondition(IPixelSizeDisplayCondition, IDisplayCondition, SupportsDeleteCallback):
    """Define an inclusive interval, in pixels, that determines when an object, such as a primitive, is rendered based on the number of pixels the object's bounding sphere (or in the case of screen overlays, bounding rectangle) covers on the screen..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type PixelSizeDisplayCondition."""
        SupportsDeleteCallback.__init__(self)
        IPixelSizeDisplayCondition.__init__(self, sourceObject)
        IDisplayCondition.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IPixelSizeDisplayCondition._private_init(self, intf)
        IDisplayCondition._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, PixelSizeDisplayCondition, [IPixelSizeDisplayCondition, IDisplayCondition])

agcls.AgClassCatalog.add_catalog_entry((5639872464997702223, 13268018770298113449), PixelSizeDisplayCondition)
agcls.AgTypeNameMap["PixelSizeDisplayCondition"] = PixelSizeDisplayCondition

class PointBatchPrimitive(IPointBatchPrimitive, IPrimitive, SupportsDeleteCallback):
    """Render one or more points in the 3D scene. Each point in the batch has a unique position and an optional color. All points in the batch share the same pixel size. For best performance, avoid creating lots of batches with only a few points each..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type PointBatchPrimitive."""
        SupportsDeleteCallback.__init__(self)
        IPointBatchPrimitive.__init__(self, sourceObject)
        IPrimitive.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IPointBatchPrimitive._private_init(self, intf)
        IPrimitive._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, PointBatchPrimitive, [IPointBatchPrimitive, IPrimitive])

agcls.AgClassCatalog.add_catalog_entry((4771838424736961315, 17789363099158793403), PointBatchPrimitive)
agcls.AgTypeNameMap["PointBatchPrimitive"] = PointBatchPrimitive

class PointBatchPrimitiveOptionalParameters(IPointBatchPrimitiveOptionalParameters, SupportsDeleteCallback):
    """Optional per-point parameters for point batch primitive that overrides the point batch primitive's global parameters..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type PointBatchPrimitiveOptionalParameters."""
        SupportsDeleteCallback.__init__(self)
        IPointBatchPrimitiveOptionalParameters.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IPointBatchPrimitiveOptionalParameters._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, PointBatchPrimitiveOptionalParameters, [IPointBatchPrimitiveOptionalParameters])

agcls.AgClassCatalog.add_catalog_entry((5230597701691714270, 598952128910254753), PointBatchPrimitiveOptionalParameters)
agcls.AgTypeNameMap["PointBatchPrimitiveOptionalParameters"] = PointBatchPrimitiveOptionalParameters

class PolylinePrimitive(IPolylinePrimitive, IPrimitive, SupportsDeleteCallback):
    """Render a polyline in the 3D scene. Each line segment may have a different color. A polyline can be constructed with a position interpolator to render great arcs or rhumb lines."""

    def __init__(self, sourceObject=None):
        """Construct an object of type PolylinePrimitive."""
        SupportsDeleteCallback.__init__(self)
        IPolylinePrimitive.__init__(self, sourceObject)
        IPrimitive.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IPolylinePrimitive._private_init(self, intf)
        IPrimitive._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, PolylinePrimitive, [IPolylinePrimitive, IPrimitive])

agcls.AgClassCatalog.add_catalog_entry((5123752712456450241, 10739590127227499430), PolylinePrimitive)
agcls.AgTypeNameMap["PolylinePrimitive"] = PolylinePrimitive

class PolylinePrimitiveOptionalParameters(IPolylinePrimitiveOptionalParameters, SupportsDeleteCallback):
    """Optional per-point or per-segment parameters for polyline primitive that overrides the polyline primitive's global parameters..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type PolylinePrimitiveOptionalParameters."""
        SupportsDeleteCallback.__init__(self)
        IPolylinePrimitiveOptionalParameters.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IPolylinePrimitiveOptionalParameters._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, PolylinePrimitiveOptionalParameters, [IPolylinePrimitiveOptionalParameters])

agcls.AgClassCatalog.add_catalog_entry((5054854826939456422, 15110470621112478879), PolylinePrimitiveOptionalParameters)
agcls.AgTypeNameMap["PolylinePrimitiveOptionalParameters"] = PolylinePrimitiveOptionalParameters

class PositionInterpolator(IPositionInterpolator, SupportsDeleteCallback):
    """Position interpolators compute positions based on a collection of input positions. Position interpolators are used in conjunction with the polyline primitive to render things such as great arcs and rhumb lines."""

    def __init__(self, sourceObject=None):
        """Construct an object of type PositionInterpolator."""
        SupportsDeleteCallback.__init__(self)
        IPositionInterpolator.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IPositionInterpolator._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, PositionInterpolator, [IPositionInterpolator])

agcls.AgClassCatalog.add_catalog_entry((5719643167839805508, 13043993113695684767), PositionInterpolator)
agcls.AgTypeNameMap["PositionInterpolator"] = PositionInterpolator

class Primitive(IPrimitive, SupportsDeleteCallback):
    """Primitives represent objects rendered in the 3D scene."""

    def __init__(self, sourceObject=None):
        """Construct an object of type Primitive."""
        SupportsDeleteCallback.__init__(self)
        IPrimitive.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IPrimitive._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, Primitive, [IPrimitive])

agcls.AgClassCatalog.add_catalog_entry((4738072676921658624, 14848128681026293391), Primitive)
agcls.AgTypeNameMap["Primitive"] = Primitive

class PrimitiveManager(IPrimitiveManager, SupportsDeleteCallback):
    """The primitive manager contains spatial data structures used to efficiently render primitives. Once a primitive is constructed, it must be added to the primitive manager before it will be rendered."""

    def __init__(self, sourceObject=None):
        """Construct an object of type PrimitiveManager."""
        SupportsDeleteCallback.__init__(self)
        IPrimitiveManager.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IPrimitiveManager._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, PrimitiveManager, [IPrimitiveManager])

agcls.AgClassCatalog.add_catalog_entry((5759528432845737503, 11218549662454612891), PrimitiveManager)
agcls.AgTypeNameMap["PrimitiveManager"] = PrimitiveManager

class RasterImageGlobeOverlay(IRasterImageGlobeOverlay, IGlobeImageOverlay, IGlobeOverlay, SupportsDeleteCallback):
    """A globe image overlay for handling rasters."""

    def __init__(self, sourceObject=None):
        """Construct an object of type RasterImageGlobeOverlay."""
        SupportsDeleteCallback.__init__(self)
        IRasterImageGlobeOverlay.__init__(self, sourceObject)
        IGlobeImageOverlay.__init__(self, sourceObject)
        IGlobeOverlay.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IRasterImageGlobeOverlay._private_init(self, intf)
        IGlobeImageOverlay._private_init(self, intf)
        IGlobeOverlay._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, RasterImageGlobeOverlay, [IRasterImageGlobeOverlay, IGlobeImageOverlay, IGlobeOverlay])

agcls.AgClassCatalog.add_catalog_entry((5590537877066628758, 18201123914066150057), RasterImageGlobeOverlay)
agcls.AgTypeNameMap["RasterImageGlobeOverlay"] = RasterImageGlobeOverlay

class RhumbLineInterpolator(IRhumbLineInterpolator, IPositionInterpolator, SupportsDeleteCallback):
    """The rhumb line interpolator computes interpolated positions along a rhumb line. Rhumb lines are lines of constant bearing. They appear as straight lines on a Mercator 2D map projection and are well suited to navigation."""

    def __init__(self, sourceObject=None):
        """Construct an object of type RhumbLineInterpolator."""
        SupportsDeleteCallback.__init__(self)
        IRhumbLineInterpolator.__init__(self, sourceObject)
        IPositionInterpolator.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IRhumbLineInterpolator._private_init(self, intf)
        IPositionInterpolator._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, RhumbLineInterpolator, [IRhumbLineInterpolator, IPositionInterpolator])

agcls.AgClassCatalog.add_catalog_entry((4905411456932095490, 5486952346846465436), RhumbLineInterpolator)
agcls.AgTypeNameMap["RhumbLineInterpolator"] = RhumbLineInterpolator

class Scene(IScene, SupportsDeleteCallback):
    """A scene provides properties and functionality that are reflected in the rendering of the globe control that it is associated with. An globe control's scene is available from the scene property..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type Scene."""
        SupportsDeleteCallback.__init__(self)
        IScene.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IScene._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, Scene, [IScene])

agcls.AgClassCatalog.add_catalog_entry((5425863975955114481, 4372717846621692570), Scene)
agcls.AgTypeNameMap["Scene"] = Scene

class SceneDisplayCondition(ISceneDisplayCondition, IDisplayCondition, SupportsDeleteCallback):
    """A display condition used to control what scene or scenes an object, such as a primitive, is rendered in. This is used to show an object in some scenes and hide it in others."""

    def __init__(self, sourceObject=None):
        """Construct an object of type SceneDisplayCondition."""
        SupportsDeleteCallback.__init__(self)
        ISceneDisplayCondition.__init__(self, sourceObject)
        IDisplayCondition.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISceneDisplayCondition._private_init(self, intf)
        IDisplayCondition._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SceneDisplayCondition, [ISceneDisplayCondition, IDisplayCondition])

agcls.AgClassCatalog.add_catalog_entry((5504831685330777187, 14908496243111103623), SceneDisplayCondition)
agcls.AgTypeNameMap["SceneDisplayCondition"] = SceneDisplayCondition

class SceneManager(ISceneManager, SupportsDeleteCallback):
    """The static scene manager class provides global properties and functionality that apply to all scenes and thus affect the rendering of every globe control..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type SceneManager."""
        SupportsDeleteCallback.__init__(self)
        ISceneManager.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISceneManager._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SceneManager, [ISceneManager])

agcls.AgClassCatalog.add_catalog_entry((5055513188644242239, 14100567721448590776), SceneManager)
agcls.AgTypeNameMap["SceneManager"] = SceneManager

class ScreenOverlay(IScreenOverlay, IOverlay, IScreenOverlayContainer, SupportsDeleteCallback):
    """A visible element drawn in screen space. Overlays are useful for floating logos, heads up displays, and integrating user interfaces into the 3D window."""

    def __init__(self, sourceObject=None):
        """Construct an object of type ScreenOverlay."""
        SupportsDeleteCallback.__init__(self)
        IScreenOverlay.__init__(self, sourceObject)
        IOverlay.__init__(self, sourceObject)
        IScreenOverlayContainer.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IScreenOverlay._private_init(self, intf)
        IOverlay._private_init(self, intf)
        IScreenOverlayContainer._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, ScreenOverlay, [IScreenOverlay, IOverlay, IScreenOverlayContainer])

agcls.AgClassCatalog.add_catalog_entry((5135883245183464378, 7950147496367229875), ScreenOverlay)
agcls.AgTypeNameMap["ScreenOverlay"] = ScreenOverlay

class ScreenOverlayCollection(IScreenOverlayCollection, IScreenOverlayCollectionBase, SupportsDeleteCallback):
    """A collection of screen overlays."""

    def __init__(self, sourceObject=None):
        """Construct an object of type ScreenOverlayCollection."""
        SupportsDeleteCallback.__init__(self)
        IScreenOverlayCollection.__init__(self, sourceObject)
        IScreenOverlayCollectionBase.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IScreenOverlayCollection._private_init(self, intf)
        IScreenOverlayCollectionBase._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, ScreenOverlayCollection, [IScreenOverlayCollection, IScreenOverlayCollectionBase])

agcls.AgClassCatalog.add_catalog_entry((5428143835074754195, 7795253318375075755), ScreenOverlayCollection)
agcls.AgTypeNameMap["ScreenOverlayCollection"] = ScreenOverlayCollection

class ScreenOverlayManager(IScreenOverlayManager, IScreenOverlayCollectionBase, IScreenOverlayContainer, SupportsDeleteCallback):
    """The top-level container for screen overlays. All child screen overlays that are added to this container are specified relative to the overall globe control."""

    def __init__(self, sourceObject=None):
        """Construct an object of type ScreenOverlayManager."""
        SupportsDeleteCallback.__init__(self)
        IScreenOverlayManager.__init__(self, sourceObject)
        IScreenOverlayCollectionBase.__init__(self, sourceObject)
        IScreenOverlayContainer.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IScreenOverlayManager._private_init(self, intf)
        IScreenOverlayCollectionBase._private_init(self, intf)
        IScreenOverlayContainer._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, ScreenOverlayManager, [IScreenOverlayManager, IScreenOverlayCollectionBase, IScreenOverlayContainer])

agcls.AgClassCatalog.add_catalog_entry((4941666073412103198, 3199753952958351539), ScreenOverlayManager)
agcls.AgTypeNameMap["ScreenOverlayManager"] = ScreenOverlayManager

class ScreenOverlayPickResult(IScreenOverlayPickResult, SupportsDeleteCallback):
    """Describes a picked screen overlay as a result of a call to pick screen overlays."""

    def __init__(self, sourceObject=None):
        """Construct an object of type ScreenOverlayPickResult."""
        SupportsDeleteCallback.__init__(self)
        IScreenOverlayPickResult.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IScreenOverlayPickResult._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, ScreenOverlayPickResult, [IScreenOverlayPickResult])

agcls.AgClassCatalog.add_catalog_entry((5411628992035762574, 18017194983832957605), ScreenOverlayPickResult)
agcls.AgTypeNameMap["ScreenOverlayPickResult"] = ScreenOverlayPickResult

class SolidPrimitive(ISolidPrimitive, IPrimitive, SupportsDeleteCallback):
    """Render filled solid objects and their outlines. Example solids include boxes and ellipsoids. Various effects are supported, such as displaying the solid's silhouette, and hiding the outline of the backside of the solid..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type SolidPrimitive."""
        SupportsDeleteCallback.__init__(self)
        ISolidPrimitive.__init__(self, sourceObject)
        IPrimitive.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISolidPrimitive._private_init(self, intf)
        IPrimitive._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SolidPrimitive, [ISolidPrimitive, IPrimitive])

agcls.AgClassCatalog.add_catalog_entry((5239544537293274560, 13352578250398471069), SolidPrimitive)
agcls.AgTypeNameMap["SolidPrimitive"] = SolidPrimitive

class Stereoscopic(IStereoscopic, SupportsDeleteCallback):
    """Get the stereoscopic options for all Scenes. To use a particular stereoscopic display mode, ensure that your system supports the feature and that it is enabled."""

    def __init__(self, sourceObject=None):
        """Construct an object of type Stereoscopic."""
        SupportsDeleteCallback.__init__(self)
        IStereoscopic.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IStereoscopic._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, Stereoscopic, [IStereoscopic])

agcls.AgClassCatalog.add_catalog_entry((5004629829167520124, 7449422875768445375), Stereoscopic)
agcls.AgTypeNameMap["Stereoscopic"] = Stereoscopic

class SurfaceMeshPrimitive(ISurfaceMeshPrimitive, IPrimitive, SupportsDeleteCallback):
    """A triangle mesh primitive for meshes on the surface that need to conform to terrain."""

    def __init__(self, sourceObject=None):
        """Construct an object of type SurfaceMeshPrimitive."""
        SupportsDeleteCallback.__init__(self)
        ISurfaceMeshPrimitive.__init__(self, sourceObject)
        IPrimitive.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISurfaceMeshPrimitive._private_init(self, intf)
        IPrimitive._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SurfaceMeshPrimitive, [ISurfaceMeshPrimitive, IPrimitive])

agcls.AgClassCatalog.add_catalog_entry((5411334062372739956, 6728209386876429451), SurfaceMeshPrimitive)
agcls.AgTypeNameMap["SurfaceMeshPrimitive"] = SurfaceMeshPrimitive

class TerrainOverlayCollection(ITerrainOverlayCollection, SupportsDeleteCallback):
    """A collection of terrain overlay objects."""

    def __init__(self, sourceObject=None):
        """Construct an object of type TerrainOverlayCollection."""
        SupportsDeleteCallback.__init__(self)
        ITerrainOverlayCollection.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITerrainOverlayCollection._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TerrainOverlayCollection, [ITerrainOverlayCollection])

agcls.AgClassCatalog.add_catalog_entry((5026986988139254343, 12046810184580739503), TerrainOverlayCollection)
agcls.AgTypeNameMap["TerrainOverlayCollection"] = TerrainOverlayCollection

class TerrainOverlay(ITerrainOverlay, IGlobeOverlay, SupportsDeleteCallback):
    """A globe overlay which shows terrain."""

    def __init__(self, sourceObject=None):
        """Construct an object of type TerrainOverlay."""
        SupportsDeleteCallback.__init__(self)
        ITerrainOverlay.__init__(self, sourceObject)
        IGlobeOverlay.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITerrainOverlay._private_init(self, intf)
        IGlobeOverlay._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TerrainOverlay, [ITerrainOverlay, IGlobeOverlay])

agcls.AgClassCatalog.add_catalog_entry((5009137188527673329, 1512801370180160660), TerrainOverlay)
agcls.AgTypeNameMap["TerrainOverlay"] = TerrainOverlay

class TextBatchPrimitive(ITextBatchPrimitive, IPrimitive, SupportsDeleteCallback):
    """Render one or more strings in the 3D scene. For best performance, avoid creating lots of batches with only a few strings each. See the Batching Performance Overview."""

    def __init__(self, sourceObject=None):
        """Construct an object of type TextBatchPrimitive."""
        SupportsDeleteCallback.__init__(self)
        ITextBatchPrimitive.__init__(self, sourceObject)
        IPrimitive.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITextBatchPrimitive._private_init(self, intf)
        IPrimitive._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TextBatchPrimitive, [ITextBatchPrimitive, IPrimitive])

agcls.AgClassCatalog.add_catalog_entry((5192917499857114645, 15090987484832364472), TextBatchPrimitive)
agcls.AgTypeNameMap["TextBatchPrimitive"] = TextBatchPrimitive

class TextBatchPrimitiveOptionalParameters(ITextBatchPrimitiveOptionalParameters, SupportsDeleteCallback):
    """Optional per-string and per-batch parameters for text batch primitive..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type TextBatchPrimitiveOptionalParameters."""
        SupportsDeleteCallback.__init__(self)
        ITextBatchPrimitiveOptionalParameters.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITextBatchPrimitiveOptionalParameters._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TextBatchPrimitiveOptionalParameters, [ITextBatchPrimitiveOptionalParameters])

agcls.AgClassCatalog.add_catalog_entry((5647850369699816160, 11320403267934911642), TextBatchPrimitiveOptionalParameters)
agcls.AgTypeNameMap["TextBatchPrimitiveOptionalParameters"] = TextBatchPrimitiveOptionalParameters

class TextOverlay(ITextOverlay, IScreenOverlay, IOverlay, IScreenOverlayContainer, SupportsDeleteCallback):
    """A rectangular overlay that contains text."""

    def __init__(self, sourceObject=None):
        """Construct an object of type TextOverlay."""
        SupportsDeleteCallback.__init__(self)
        ITextOverlay.__init__(self, sourceObject)
        IScreenOverlay.__init__(self, sourceObject)
        IOverlay.__init__(self, sourceObject)
        IScreenOverlayContainer.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITextOverlay._private_init(self, intf)
        IScreenOverlay._private_init(self, intf)
        IOverlay._private_init(self, intf)
        IScreenOverlayContainer._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TextOverlay, [ITextOverlay, IScreenOverlay, IOverlay, IScreenOverlayContainer])

agcls.AgClassCatalog.add_catalog_entry((5427148005289374195, 14840843638839670698), TextOverlay)
agcls.AgTypeNameMap["TextOverlay"] = TextOverlay

class TextureMatrix(ITextureMatrix, SupportsDeleteCallback):
    """A 4 by 4 matrix applied to a texture coordinate."""

    def __init__(self, sourceObject=None):
        """Construct an object of type TextureMatrix."""
        SupportsDeleteCallback.__init__(self)
        ITextureMatrix.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITextureMatrix._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TextureMatrix, [ITextureMatrix])

agcls.AgClassCatalog.add_catalog_entry((5322719047750336006, 3163360220050271417), TextureMatrix)
agcls.AgTypeNameMap["TextureMatrix"] = TextureMatrix

class TextureScreenOverlay(ITextureScreenOverlay, IScreenOverlay, IOverlay, IScreenOverlayContainer, SupportsDeleteCallback):
    """A rectangular overlay that can be assigned a texture."""

    def __init__(self, sourceObject=None):
        """Construct an object of type TextureScreenOverlay."""
        SupportsDeleteCallback.__init__(self)
        ITextureScreenOverlay.__init__(self, sourceObject)
        IScreenOverlay.__init__(self, sourceObject)
        IOverlay.__init__(self, sourceObject)
        IScreenOverlayContainer.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITextureScreenOverlay._private_init(self, intf)
        IScreenOverlay._private_init(self, intf)
        IOverlay._private_init(self, intf)
        IScreenOverlayContainer._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TextureScreenOverlay, [ITextureScreenOverlay, IScreenOverlay, IOverlay, IScreenOverlayContainer])

agcls.AgClassCatalog.add_catalog_entry((5607914524592267416, 13643758576656948403), TextureScreenOverlay)
agcls.AgTypeNameMap["TextureScreenOverlay"] = TextureScreenOverlay

class TimeIntervalDisplayCondition(ITimeIntervalDisplayCondition, IDisplayCondition, SupportsDeleteCallback):
    """Define an inclusive time interval that determines when an object, such as a primitive, is rendered based on the current animation time ."""

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeIntervalDisplayCondition."""
        SupportsDeleteCallback.__init__(self)
        ITimeIntervalDisplayCondition.__init__(self, sourceObject)
        IDisplayCondition.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeIntervalDisplayCondition._private_init(self, intf)
        IDisplayCondition._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeIntervalDisplayCondition, [ITimeIntervalDisplayCondition, IDisplayCondition])

agcls.AgClassCatalog.add_catalog_entry((5451112938694421699, 7149618987495979392), TimeIntervalDisplayCondition)
agcls.AgTypeNameMap["TimeIntervalDisplayCondition"] = TimeIntervalDisplayCondition

class TriangleMeshPrimitive(ITriangleMeshPrimitive, IPrimitive, SupportsDeleteCallback):
    """Render a triangle mesh in the 3D scene. Examples of triangle meshes include polygons on the globe (e.g. states or countries), terrain and imagery extents, ellipses, and extrusions."""

    def __init__(self, sourceObject=None):
        """Construct an object of type TriangleMeshPrimitive."""
        SupportsDeleteCallback.__init__(self)
        ITriangleMeshPrimitive.__init__(self, sourceObject)
        IPrimitive.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITriangleMeshPrimitive._private_init(self, intf)
        IPrimitive._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TriangleMeshPrimitive, [ITriangleMeshPrimitive, IPrimitive])

agcls.AgClassCatalog.add_catalog_entry((5312225394571429699, 1015409093709215616), TriangleMeshPrimitive)
agcls.AgTypeNameMap["TriangleMeshPrimitive"] = TriangleMeshPrimitive

class TriangleMeshPrimitiveOptionalParameters(ITriangleMeshPrimitiveOptionalParameters, SupportsDeleteCallback):
    """Optional parameters for triangle mesh primitive..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type TriangleMeshPrimitiveOptionalParameters."""
        SupportsDeleteCallback.__init__(self)
        ITriangleMeshPrimitiveOptionalParameters.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITriangleMeshPrimitiveOptionalParameters._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TriangleMeshPrimitiveOptionalParameters, [ITriangleMeshPrimitiveOptionalParameters])

agcls.AgClassCatalog.add_catalog_entry((4642256431831602185, 8016648807998853514), TriangleMeshPrimitiveOptionalParameters)
agcls.AgTypeNameMap["TriangleMeshPrimitiveOptionalParameters"] = TriangleMeshPrimitiveOptionalParameters

class VectorPrimitive(IVectorPrimitive, IPrimitive, SupportsDeleteCallback):
    """Render a vector in the 3D scene. A vector is defined by a source (given by a reference frame) and a direction (given by a vector). Length is auto-calculated or can be set separately."""

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorPrimitive."""
        SupportsDeleteCallback.__init__(self)
        IVectorPrimitive.__init__(self, sourceObject)
        IPrimitive.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorPrimitive._private_init(self, intf)
        IPrimitive._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorPrimitive, [IVectorPrimitive, IPrimitive])

agcls.AgClassCatalog.add_catalog_entry((4966641441207235541, 9073217279606378419), VectorPrimitive)
agcls.AgTypeNameMap["VectorPrimitive"] = VectorPrimitive

class BoxTriangulatorInitializer(IBoxTriangulatorInitializer, SupportsDeleteCallback):
    """Triangulates a box. It is recommended to visualize the box using a solid primitive. Although, if only the fill is desired for visualization, a triangle mesh primitive with render back then front faces set to true can be used..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type BoxTriangulatorInitializer."""
        SupportsDeleteCallback.__init__(self)
        IBoxTriangulatorInitializer.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IBoxTriangulatorInitializer._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, BoxTriangulatorInitializer, [IBoxTriangulatorInitializer])

agcls.AgClassCatalog.add_catalog_entry((5115290424271597075, 14652160602906339211), BoxTriangulatorInitializer)
agcls.AgTypeNameMap["BoxTriangulatorInitializer"] = BoxTriangulatorInitializer

class CylinderTriangulatorInitializer(ICylinderTriangulatorInitializer, SupportsDeleteCallback):
    """Triangulates a cylinder. It is recommended to visualize the cylinder using a solid primitive. Although, if only the fill is desired for visualization, a triangle mesh primitive with render back then front faces set to true can be used..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type CylinderTriangulatorInitializer."""
        SupportsDeleteCallback.__init__(self)
        ICylinderTriangulatorInitializer.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICylinderTriangulatorInitializer._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CylinderTriangulatorInitializer, [ICylinderTriangulatorInitializer])

agcls.AgClassCatalog.add_catalog_entry((5439315015983129571, 8771602325511016840), CylinderTriangulatorInitializer)
agcls.AgTypeNameMap["CylinderTriangulatorInitializer"] = CylinderTriangulatorInitializer

class EllipsoidTriangulatorInitializer(IEllipsoidTriangulatorInitializer, SupportsDeleteCallback):
    """Triangulates an ellipsoid. It is recommended to visualize the ellipsoid using a solid primitive. Although, if only the fill is desired for visualization, a triangle mesh primitive with render back then front faces set to true can be used..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type EllipsoidTriangulatorInitializer."""
        SupportsDeleteCallback.__init__(self)
        IEllipsoidTriangulatorInitializer.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IEllipsoidTriangulatorInitializer._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, EllipsoidTriangulatorInitializer, [IEllipsoidTriangulatorInitializer])

agcls.AgClassCatalog.add_catalog_entry((4999770647031458132, 9385182207773628042), EllipsoidTriangulatorInitializer)
agcls.AgTypeNameMap["EllipsoidTriangulatorInitializer"] = EllipsoidTriangulatorInitializer

class ExtrudedPolylineTriangulatorInitializer(IExtrudedPolylineTriangulatorInitializer, SupportsDeleteCallback):
    """Triangulates a polyline into an extrusion with bottom and top boundaries."""

    def __init__(self, sourceObject=None):
        """Construct an object of type ExtrudedPolylineTriangulatorInitializer."""
        SupportsDeleteCallback.__init__(self)
        IExtrudedPolylineTriangulatorInitializer.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IExtrudedPolylineTriangulatorInitializer._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, ExtrudedPolylineTriangulatorInitializer, [IExtrudedPolylineTriangulatorInitializer])

agcls.AgClassCatalog.add_catalog_entry((4619921406117156753, 5415519835836977292), ExtrudedPolylineTriangulatorInitializer)
agcls.AgTypeNameMap["ExtrudedPolylineTriangulatorInitializer"] = ExtrudedPolylineTriangulatorInitializer

class SurfaceExtentTriangulatorInitializer(ISurfaceExtentTriangulatorInitializer, SupportsDeleteCallback):
    """Triangulates an extent on a central body into a triangle mesh and a surrounding boundary. The mesh is commonly visualized with the triangle mesh primitive or surface mesh primitive. The boundary is commonly visualized with the polyline primitive."""

    def __init__(self, sourceObject=None):
        """Construct an object of type SurfaceExtentTriangulatorInitializer."""
        SupportsDeleteCallback.__init__(self)
        ISurfaceExtentTriangulatorInitializer.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISurfaceExtentTriangulatorInitializer._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SurfaceExtentTriangulatorInitializer, [ISurfaceExtentTriangulatorInitializer])

agcls.AgClassCatalog.add_catalog_entry((5535007049528422239, 11204546506755181214), SurfaceExtentTriangulatorInitializer)
agcls.AgTypeNameMap["SurfaceExtentTriangulatorInitializer"] = SurfaceExtentTriangulatorInitializer

class SurfacePolygonTriangulatorInitializer(ISurfacePolygonTriangulatorInitializer, SupportsDeleteCallback):
    """Triangulates a polygon, with an optional hole, on a central body, into a triangle mesh and a surrounding boundary. The mesh is commonly visualized with the triangle mesh primitive or surface mesh primitive..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type SurfacePolygonTriangulatorInitializer."""
        SupportsDeleteCallback.__init__(self)
        ISurfacePolygonTriangulatorInitializer.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISurfacePolygonTriangulatorInitializer._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SurfacePolygonTriangulatorInitializer, [ISurfacePolygonTriangulatorInitializer])

agcls.AgClassCatalog.add_catalog_entry((5517975915110148377, 7732268155979254694), SurfacePolygonTriangulatorInitializer)
agcls.AgTypeNameMap["SurfacePolygonTriangulatorInitializer"] = SurfacePolygonTriangulatorInitializer

class SurfaceShapesInitializer(ISurfaceShapesInitializer, SupportsDeleteCallback):
    """Compute boundary positions for shapes on the surface such as circles, ellipses, and sectors."""

    def __init__(self, sourceObject=None):
        """Construct an object of type SurfaceShapesInitializer."""
        SupportsDeleteCallback.__init__(self)
        ISurfaceShapesInitializer.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISurfaceShapesInitializer._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SurfaceShapesInitializer, [ISurfaceShapesInitializer])

agcls.AgClassCatalog.add_catalog_entry((4892417382403964679, 13571096819327492762), SurfaceShapesInitializer)
agcls.AgTypeNameMap["SurfaceShapesInitializer"] = SurfaceShapesInitializer

class AGICustomTerrainOverlayFactory(IAGICustomTerrainOverlayFactory, SupportsDeleteCallback):
    """A terrain overlay for handling AGI Cesium Terrain."""

    def __init__(self, sourceObject=None):
        """Construct an object of type AGICustomTerrainOverlayFactory."""
        SupportsDeleteCallback.__init__(self)
        IAGICustomTerrainOverlayFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAGICustomTerrainOverlayFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AGICustomTerrainOverlayFactory, [IAGICustomTerrainOverlayFactory])

agcls.AgClassCatalog.add_catalog_entry((5020205725023089583, 6940143989295968643), AGICustomTerrainOverlayFactory)
agcls.AgTypeNameMap["AGICustomTerrainOverlayFactory"] = AGICustomTerrainOverlayFactory

class AGIProcessedImageGlobeOverlayFactory(IAGIProcessedImageGlobeOverlayFactory, SupportsDeleteCallback):
    """A globe image overlay for handling AGI Processed Image (PDTTX) files."""

    def __init__(self, sourceObject=None):
        """Construct an object of type AGIProcessedImageGlobeOverlayFactory."""
        SupportsDeleteCallback.__init__(self)
        IAGIProcessedImageGlobeOverlayFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAGIProcessedImageGlobeOverlayFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AGIProcessedImageGlobeOverlayFactory, [IAGIProcessedImageGlobeOverlayFactory])

agcls.AgClassCatalog.add_catalog_entry((4774766765894947271, 9336624974406837173), AGIProcessedImageGlobeOverlayFactory)
agcls.AgTypeNameMap["AGIProcessedImageGlobeOverlayFactory"] = AGIProcessedImageGlobeOverlayFactory

class AGIProcessedTerrainOverlayFactory(IAGIProcessedTerrainOverlayFactory, SupportsDeleteCallback):
    """A terrain overlay for handling AGI Processed Terrain (PDTT) files."""

    def __init__(self, sourceObject=None):
        """Construct an object of type AGIProcessedTerrainOverlayFactory."""
        SupportsDeleteCallback.__init__(self)
        IAGIProcessedTerrainOverlayFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAGIProcessedTerrainOverlayFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AGIProcessedTerrainOverlayFactory, [IAGIProcessedTerrainOverlayFactory])

agcls.AgClassCatalog.add_catalog_entry((4897798652195826492, 8452616037484675760), AGIProcessedTerrainOverlayFactory)
agcls.AgTypeNameMap["AGIProcessedTerrainOverlayFactory"] = AGIProcessedTerrainOverlayFactory

class AGIRoamImageGlobeOverlayFactory(IAGIRoamImageGlobeOverlayFactory, SupportsDeleteCallback):
    """A globe image overlay for handling ROAM (TXM/TXB) files."""

    def __init__(self, sourceObject=None):
        """Construct an object of type AGIRoamImageGlobeOverlayFactory."""
        SupportsDeleteCallback.__init__(self)
        IAGIRoamImageGlobeOverlayFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAGIRoamImageGlobeOverlayFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AGIRoamImageGlobeOverlayFactory, [IAGIRoamImageGlobeOverlayFactory])

agcls.AgClassCatalog.add_catalog_entry((5630193921900304952, 7930263226224999313), AGIRoamImageGlobeOverlayFactory)
agcls.AgTypeNameMap["AGIRoamImageGlobeOverlayFactory"] = AGIRoamImageGlobeOverlayFactory

class CustomImageGlobeOverlayPluginActivatorFactory(ICustomImageGlobeOverlayPluginActivatorFactory, SupportsDeleteCallback):
    """The Activator class provides methods to load COM plugins that implement custom image globe overlays. For more information about custom image globe overlays, see the STK Programming Interface."""

    def __init__(self, sourceObject=None):
        """Construct an object of type CustomImageGlobeOverlayPluginActivatorFactory."""
        SupportsDeleteCallback.__init__(self)
        ICustomImageGlobeOverlayPluginActivatorFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICustomImageGlobeOverlayPluginActivatorFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CustomImageGlobeOverlayPluginActivatorFactory, [ICustomImageGlobeOverlayPluginActivatorFactory])

agcls.AgClassCatalog.add_catalog_entry((4667288682943577893, 326361443353301181), CustomImageGlobeOverlayPluginActivatorFactory)
agcls.AgTypeNameMap["CustomImageGlobeOverlayPluginActivatorFactory"] = CustomImageGlobeOverlayPluginActivatorFactory

class GeospatialImageGlobeOverlayFactory(IGeospatialImageGlobeOverlayFactory, SupportsDeleteCallback):
    """A globe image overlay for handling `JPEG 2000 <https://jpeg.org/jpeg2000/>`_ (.jp2), ECW (.ecw), ECWP, and MrSid (.sid) image formats in the WGS84 geographic projection."""

    def __init__(self, sourceObject=None):
        """Construct an object of type GeospatialImageGlobeOverlayFactory."""
        SupportsDeleteCallback.__init__(self)
        IGeospatialImageGlobeOverlayFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IGeospatialImageGlobeOverlayFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, GeospatialImageGlobeOverlayFactory, [IGeospatialImageGlobeOverlayFactory])

agcls.AgClassCatalog.add_catalog_entry((5076482265562622621, 7956007731180983691), GeospatialImageGlobeOverlayFactory)
agcls.AgTypeNameMap["GeospatialImageGlobeOverlayFactory"] = GeospatialImageGlobeOverlayFactory

class ProjectedRasterOverlayFactory(IProjectedRasterOverlayFactory, SupportsDeleteCallback):
    """A globe image overlay which projects a raster onto the terrain or surface of the central body. You can also enable projection onto models by setting projected raster model projection to true for a Scene..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type ProjectedRasterOverlayFactory."""
        SupportsDeleteCallback.__init__(self)
        IProjectedRasterOverlayFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IProjectedRasterOverlayFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, ProjectedRasterOverlayFactory, [IProjectedRasterOverlayFactory])

agcls.AgClassCatalog.add_catalog_entry((5600426367971425017, 6297236579028457345), ProjectedRasterOverlayFactory)
agcls.AgTypeNameMap["ProjectedRasterOverlayFactory"] = ProjectedRasterOverlayFactory

class ProjectionFactory(IProjectionFactory, SupportsDeleteCallback):
    """A projection represents a simplified camera with a position, orientation, and field of view horizontal and field of view vertical..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type ProjectionFactory."""
        SupportsDeleteCallback.__init__(self)
        IProjectionFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IProjectionFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, ProjectionFactory, [IProjectionFactory])

agcls.AgClassCatalog.add_catalog_entry((4747243496013475585, 14717796182741063818), ProjectionFactory)
agcls.AgTypeNameMap["ProjectionFactory"] = ProjectionFactory

class AltitudeDisplayConditionFactory(IAltitudeDisplayConditionFactory, SupportsDeleteCallback):
    """Define an inclusive altitude interval that determines when an object is rendered based on the camera's altitude relative to a central body."""

    def __init__(self, sourceObject=None):
        """Construct an object of type AltitudeDisplayConditionFactory."""
        SupportsDeleteCallback.__init__(self)
        IAltitudeDisplayConditionFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAltitudeDisplayConditionFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AltitudeDisplayConditionFactory, [IAltitudeDisplayConditionFactory])

agcls.AgClassCatalog.add_catalog_entry((5200808533864861594, 13915814818108416149), AltitudeDisplayConditionFactory)
agcls.AgTypeNameMap["AltitudeDisplayConditionFactory"] = AltitudeDisplayConditionFactory

class AxesPrimitiveFactory(IAxesPrimitiveFactory, SupportsDeleteCallback):
    """Render an axes in the 3D scene."""

    def __init__(self, sourceObject=None):
        """Construct an object of type AxesPrimitiveFactory."""
        SupportsDeleteCallback.__init__(self)
        IAxesPrimitiveFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAxesPrimitiveFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AxesPrimitiveFactory, [IAxesPrimitiveFactory])

agcls.AgClassCatalog.add_catalog_entry((5682434422397040845, 10186778082441572784), AxesPrimitiveFactory)
agcls.AgTypeNameMap["AxesPrimitiveFactory"] = AxesPrimitiveFactory

class CompositeDisplayConditionFactory(ICompositeDisplayConditionFactory, SupportsDeleteCallback):
    """A composite of display conditions combined using a binary logic operation. For example, several time interval display condition objects can be added to a composite..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type CompositeDisplayConditionFactory."""
        SupportsDeleteCallback.__init__(self)
        ICompositeDisplayConditionFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICompositeDisplayConditionFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CompositeDisplayConditionFactory, [ICompositeDisplayConditionFactory])

agcls.AgClassCatalog.add_catalog_entry((5655207749086761819, 8044584761807187362), CompositeDisplayConditionFactory)
agcls.AgTypeNameMap["CompositeDisplayConditionFactory"] = CompositeDisplayConditionFactory

class CompositePrimitiveFactory(ICompositePrimitiveFactory, SupportsDeleteCallback):
    """A primitive that is composed of multiple other primitives. Since composites can contain other composites, they are commonly used to build hierarchies of primitives to efficiently evaluate display conditions..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type CompositePrimitiveFactory."""
        SupportsDeleteCallback.__init__(self)
        ICompositePrimitiveFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ICompositePrimitiveFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, CompositePrimitiveFactory, [ICompositePrimitiveFactory])

agcls.AgClassCatalog.add_catalog_entry((5429504362741043601, 2495584971911784114), CompositePrimitiveFactory)
agcls.AgTypeNameMap["CompositePrimitiveFactory"] = CompositePrimitiveFactory

class ConstantDisplayConditionFactory(IConstantDisplayConditionFactory, SupportsDeleteCallback):
    """A display condition that evaluates to a user-defined value. This is commonly used to hide primitives by assigning to a primitive a display condition that always returns false."""

    def __init__(self, sourceObject=None):
        """Construct an object of type ConstantDisplayConditionFactory."""
        SupportsDeleteCallback.__init__(self)
        IConstantDisplayConditionFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IConstantDisplayConditionFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, ConstantDisplayConditionFactory, [IConstantDisplayConditionFactory])

agcls.AgClassCatalog.add_catalog_entry((5349013282675406085, 9534837757228706749), ConstantDisplayConditionFactory)
agcls.AgTypeNameMap["ConstantDisplayConditionFactory"] = ConstantDisplayConditionFactory

class DistanceDisplayConditionFactory(IDistanceDisplayConditionFactory, SupportsDeleteCallback):
    """Define an inclusive distance interval that determines when an object, such as a primitive, is rendered based on the distance from the camera to the object."""

    def __init__(self, sourceObject=None):
        """Construct an object of type DistanceDisplayConditionFactory."""
        SupportsDeleteCallback.__init__(self)
        IDistanceDisplayConditionFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IDistanceDisplayConditionFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, DistanceDisplayConditionFactory, [IDistanceDisplayConditionFactory])

agcls.AgClassCatalog.add_catalog_entry((5065052303529093084, 15532411777554433189), DistanceDisplayConditionFactory)
agcls.AgTypeNameMap["DistanceDisplayConditionFactory"] = DistanceDisplayConditionFactory

class DistanceToGlobeOverlayDisplayConditionFactory(IDistanceToGlobeOverlayDisplayConditionFactory, SupportsDeleteCallback):
    """Define an inclusive distance interval that determines when an object, such as a primitive, is rendered based on the distance from the camera to the globe overlay..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type DistanceToGlobeOverlayDisplayConditionFactory."""
        SupportsDeleteCallback.__init__(self)
        IDistanceToGlobeOverlayDisplayConditionFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IDistanceToGlobeOverlayDisplayConditionFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, DistanceToGlobeOverlayDisplayConditionFactory, [IDistanceToGlobeOverlayDisplayConditionFactory])

agcls.AgClassCatalog.add_catalog_entry((4754265214729837056, 9188364243086704805), DistanceToGlobeOverlayDisplayConditionFactory)
agcls.AgTypeNameMap["DistanceToGlobeOverlayDisplayConditionFactory"] = DistanceToGlobeOverlayDisplayConditionFactory

class DistanceToPositionDisplayConditionFactory(IDistanceToPositionDisplayConditionFactory, SupportsDeleteCallback):
    """Define an inclusive distance interval that determines when an object, such as a primitive, is rendered based on the distance from the camera to a position defined in the given reference frame."""

    def __init__(self, sourceObject=None):
        """Construct an object of type DistanceToPositionDisplayConditionFactory."""
        SupportsDeleteCallback.__init__(self)
        IDistanceToPositionDisplayConditionFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IDistanceToPositionDisplayConditionFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, DistanceToPositionDisplayConditionFactory, [IDistanceToPositionDisplayConditionFactory])

agcls.AgClassCatalog.add_catalog_entry((5710493425944112313, 8261967060205205147), DistanceToPositionDisplayConditionFactory)
agcls.AgTypeNameMap["DistanceToPositionDisplayConditionFactory"] = DistanceToPositionDisplayConditionFactory

class DistanceToPrimitiveDisplayConditionFactory(IDistanceToPrimitiveDisplayConditionFactory, SupportsDeleteCallback):
    """Define an inclusive distance interval that determines when an object, such as a screen overlay, is rendered based on the distance from the camera to the primitive..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type DistanceToPrimitiveDisplayConditionFactory."""
        SupportsDeleteCallback.__init__(self)
        IDistanceToPrimitiveDisplayConditionFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IDistanceToPrimitiveDisplayConditionFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, DistanceToPrimitiveDisplayConditionFactory, [IDistanceToPrimitiveDisplayConditionFactory])

agcls.AgClassCatalog.add_catalog_entry((4851280165819875180, 7931937885030283949), DistanceToPrimitiveDisplayConditionFactory)
agcls.AgTypeNameMap["DistanceToPrimitiveDisplayConditionFactory"] = DistanceToPrimitiveDisplayConditionFactory

class DurationPathPrimitiveUpdatePolicyFactory(IDurationPathPrimitiveUpdatePolicyFactory, SupportsDeleteCallback):
    """path primitive update policy that removes points from remove location after a given duration."""

    def __init__(self, sourceObject=None):
        """Construct an object of type DurationPathPrimitiveUpdatePolicyFactory."""
        SupportsDeleteCallback.__init__(self)
        IDurationPathPrimitiveUpdatePolicyFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IDurationPathPrimitiveUpdatePolicyFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, DurationPathPrimitiveUpdatePolicyFactory, [IDurationPathPrimitiveUpdatePolicyFactory])

agcls.AgClassCatalog.add_catalog_entry((4889439542627162004, 9986904305815943042), DurationPathPrimitiveUpdatePolicyFactory)
agcls.AgTypeNameMap["DurationPathPrimitiveUpdatePolicyFactory"] = DurationPathPrimitiveUpdatePolicyFactory

class GlobeImageOverlayInitializer(IGlobeImageOverlayInitializer, SupportsDeleteCallback):
    """A globe overlay that shows an image."""

    def __init__(self, sourceObject=None):
        """Construct an object of type GlobeImageOverlayInitializer."""
        SupportsDeleteCallback.__init__(self)
        IGlobeImageOverlayInitializer.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IGlobeImageOverlayInitializer._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, GlobeImageOverlayInitializer, [IGlobeImageOverlayInitializer])

agcls.AgClassCatalog.add_catalog_entry((5145389423934137943, 372919645112059831), GlobeImageOverlayInitializer)
agcls.AgTypeNameMap["GlobeImageOverlayInitializer"] = GlobeImageOverlayInitializer

class GraphicsFontFactory(IGraphicsFontFactory, SupportsDeleteCallback):
    """A font that is suitable for use with the text batch primitive. For best performance, avoid creating duplicate font objects. Instead assign the same font object to several text batch primitives."""

    def __init__(self, sourceObject=None):
        """Construct an object of type GraphicsFontFactory."""
        SupportsDeleteCallback.__init__(self)
        IGraphicsFontFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IGraphicsFontFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, GraphicsFontFactory, [IGraphicsFontFactory])

agcls.AgClassCatalog.add_catalog_entry((5711811913643509725, 17355393524528831380), GraphicsFontFactory)
agcls.AgTypeNameMap["GraphicsFontFactory"] = GraphicsFontFactory

class GreatArcInterpolatorFactory(IGreatArcInterpolatorFactory, SupportsDeleteCallback):
    """The great arc interpolator computes interpolated positions along a great arc. A great arc is the shortest path between two positions on an ellipsoid."""

    def __init__(self, sourceObject=None):
        """Construct an object of type GreatArcInterpolatorFactory."""
        SupportsDeleteCallback.__init__(self)
        IGreatArcInterpolatorFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IGreatArcInterpolatorFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, GreatArcInterpolatorFactory, [IGreatArcInterpolatorFactory])

agcls.AgClassCatalog.add_catalog_entry((5300096125846617544, 15382236120108922018), GreatArcInterpolatorFactory)
agcls.AgTypeNameMap["GreatArcInterpolatorFactory"] = GreatArcInterpolatorFactory

class AlphaFromLuminanceFilterFactory(IAlphaFromLuminanceFilterFactory, SupportsDeleteCallback):
    """Add an alpha band to the source raster derived from the luminance of the raster's color bands."""

    def __init__(self, sourceObject=None):
        """Construct an object of type AlphaFromLuminanceFilterFactory."""
        SupportsDeleteCallback.__init__(self)
        IAlphaFromLuminanceFilterFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAlphaFromLuminanceFilterFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AlphaFromLuminanceFilterFactory, [IAlphaFromLuminanceFilterFactory])

agcls.AgClassCatalog.add_catalog_entry((5428076649341058938, 12264952971470003123), AlphaFromLuminanceFilterFactory)
agcls.AgTypeNameMap["AlphaFromLuminanceFilterFactory"] = AlphaFromLuminanceFilterFactory

class AlphaFromPixelFilterFactory(IAlphaFromPixelFilterFactory, SupportsDeleteCallback):
    """Add an alpha band to the source raster based on the value of its first pixel. All pixels in the source raster that are the same color as the first pixel will be made transparent."""

    def __init__(self, sourceObject=None):
        """Construct an object of type AlphaFromPixelFilterFactory."""
        SupportsDeleteCallback.__init__(self)
        IAlphaFromPixelFilterFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAlphaFromPixelFilterFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AlphaFromPixelFilterFactory, [IAlphaFromPixelFilterFactory])

agcls.AgClassCatalog.add_catalog_entry((5250854596551567928, 7378055081666140072), AlphaFromPixelFilterFactory)
agcls.AgTypeNameMap["AlphaFromPixelFilterFactory"] = AlphaFromPixelFilterFactory

class AlphaFromRasterFilterFactory(IAlphaFromRasterFilterFactory, SupportsDeleteCallback):
    """Add an alpha band to the source raster derived from the color bands or alpha of another raster. This filter can be used to apply an alpha mask to the source raster."""

    def __init__(self, sourceObject=None):
        """Construct an object of type AlphaFromRasterFilterFactory."""
        SupportsDeleteCallback.__init__(self)
        IAlphaFromRasterFilterFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IAlphaFromRasterFilterFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, AlphaFromRasterFilterFactory, [IAlphaFromRasterFilterFactory])

agcls.AgClassCatalog.add_catalog_entry((5423806334685966943, 8021373877449537194), AlphaFromRasterFilterFactory)
agcls.AgTypeNameMap["AlphaFromRasterFilterFactory"] = AlphaFromRasterFilterFactory

class BandExtractFilterFactory(IBandExtractFilterFactory, SupportsDeleteCallback):
    """Extract a band or set of bands from the source raster. The extract format property specifies the bands and the order of the bands that will be extracted."""

    def __init__(self, sourceObject=None):
        """Construct an object of type BandExtractFilterFactory."""
        SupportsDeleteCallback.__init__(self)
        IBandExtractFilterFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IBandExtractFilterFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, BandExtractFilterFactory, [IBandExtractFilterFactory])

agcls.AgClassCatalog.add_catalog_entry((5101154593245878612, 7889008741117033663), BandExtractFilterFactory)
agcls.AgTypeNameMap["BandExtractFilterFactory"] = BandExtractFilterFactory

class BandOrderFilterFactory(IBandOrderFilterFactory, SupportsDeleteCallback):
    """Reorders or swizzles the bands of the source raster to match the band order of the raster format specified by the band order property. When maintain raster format is true, the source raster's format is maintained after swizzling."""

    def __init__(self, sourceObject=None):
        """Construct an object of type BandOrderFilterFactory."""
        SupportsDeleteCallback.__init__(self)
        IBandOrderFilterFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IBandOrderFilterFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, BandOrderFilterFactory, [IBandOrderFilterFactory])

agcls.AgClassCatalog.add_catalog_entry((5064443659311181751, 12225493006765152427), BandOrderFilterFactory)
agcls.AgTypeNameMap["BandOrderFilterFactory"] = BandOrderFilterFactory

class BlurFilterFactory(IBlurFilterFactory, SupportsDeleteCallback):
    """Apply a convolution filter to blur or smooth the source raster. Can be used to reduce noise in the raster."""

    def __init__(self, sourceObject=None):
        """Construct an object of type BlurFilterFactory."""
        SupportsDeleteCallback.__init__(self)
        IBlurFilterFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IBlurFilterFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, BlurFilterFactory, [IBlurFilterFactory])

agcls.AgClassCatalog.add_catalog_entry((4761191044981634241, 2280460864101009058), BlurFilterFactory)
agcls.AgTypeNameMap["BlurFilterFactory"] = BlurFilterFactory

class BrightnessFilterFactory(IBrightnessFilterFactory, SupportsDeleteCallback):
    """Adjusts the brightness of the source raster's color bands. The adjustment to brightness is a value between -1 and 1, corresponding to least bright to most bright."""

    def __init__(self, sourceObject=None):
        """Construct an object of type BrightnessFilterFactory."""
        SupportsDeleteCallback.__init__(self)
        IBrightnessFilterFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IBrightnessFilterFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, BrightnessFilterFactory, [IBrightnessFilterFactory])

agcls.AgClassCatalog.add_catalog_entry((5192348196864259449, 152695209642318979), BrightnessFilterFactory)
agcls.AgTypeNameMap["BrightnessFilterFactory"] = BrightnessFilterFactory

class ColorToLuminanceFilterFactory(IColorToLuminanceFilterFactory, SupportsDeleteCallback):
    """Extract a luminance band derived from the color bands of the source raster."""

    def __init__(self, sourceObject=None):
        """Construct an object of type ColorToLuminanceFilterFactory."""
        SupportsDeleteCallback.__init__(self)
        IColorToLuminanceFilterFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IColorToLuminanceFilterFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, ColorToLuminanceFilterFactory, [IColorToLuminanceFilterFactory])

agcls.AgClassCatalog.add_catalog_entry((5419514809765967274, 4060370452243456929), ColorToLuminanceFilterFactory)
agcls.AgTypeNameMap["ColorToLuminanceFilterFactory"] = ColorToLuminanceFilterFactory

class ContrastFilterFactory(IContrastFilterFactory, SupportsDeleteCallback):
    """Adjusts the contrast of the source raster. The adjustment to contrast is a value between -1 and 1, corresponding to least contrast to most contrast."""

    def __init__(self, sourceObject=None):
        """Construct an object of type ContrastFilterFactory."""
        SupportsDeleteCallback.__init__(self)
        IContrastFilterFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IContrastFilterFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, ContrastFilterFactory, [IContrastFilterFactory])

agcls.AgClassCatalog.add_catalog_entry((5605125305352070134, 4826256083860431246), ContrastFilterFactory)
agcls.AgTypeNameMap["ContrastFilterFactory"] = ContrastFilterFactory

class ConvolutionFilterFactory(IConvolutionFilterFactory, SupportsDeleteCallback):
    """Apply convolution to the source raster. Convolution is the modification of a pixel's value based on the values of its surrounding pixels. The kernel is the numerical matrix that is applied to each pixel in this process..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type ConvolutionFilterFactory."""
        SupportsDeleteCallback.__init__(self)
        IConvolutionFilterFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IConvolutionFilterFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, ConvolutionFilterFactory, [IConvolutionFilterFactory])

agcls.AgClassCatalog.add_catalog_entry((5194241966668323293, 10219248867443858857), ConvolutionFilterFactory)
agcls.AgTypeNameMap["ConvolutionFilterFactory"] = ConvolutionFilterFactory

class EdgeDetectFilterFactory(IEdgeDetectFilterFactory, SupportsDeleteCallback):
    """Apply a convolution filter to detect edges in the source raster."""

    def __init__(self, sourceObject=None):
        """Construct an object of type EdgeDetectFilterFactory."""
        SupportsDeleteCallback.__init__(self)
        IEdgeDetectFilterFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IEdgeDetectFilterFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, EdgeDetectFilterFactory, [IEdgeDetectFilterFactory])

agcls.AgClassCatalog.add_catalog_entry((5369295687463539305, 16833644508996806546), EdgeDetectFilterFactory)
agcls.AgTypeNameMap["EdgeDetectFilterFactory"] = EdgeDetectFilterFactory

class FilteringRasterStreamFactory(IFilteringRasterStreamFactory, SupportsDeleteCallback):
    """A class decorator for applying a raster filter to each update of a raster stream. Can be used to apply filters to videos and other raster streams as they are updated."""

    def __init__(self, sourceObject=None):
        """Construct an object of type FilteringRasterStreamFactory."""
        SupportsDeleteCallback.__init__(self)
        IFilteringRasterStreamFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IFilteringRasterStreamFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, FilteringRasterStreamFactory, [IFilteringRasterStreamFactory])

agcls.AgClassCatalog.add_catalog_entry((5574129346456397425, 8077637960984957060), FilteringRasterStreamFactory)
agcls.AgTypeNameMap["FilteringRasterStreamFactory"] = FilteringRasterStreamFactory

class FlipFilterFactory(IFlipFilterFactory, SupportsDeleteCallback):
    """Flips the source raster along the given flip axis."""

    def __init__(self, sourceObject=None):
        """Construct an object of type FlipFilterFactory."""
        SupportsDeleteCallback.__init__(self)
        IFlipFilterFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IFlipFilterFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, FlipFilterFactory, [IFlipFilterFactory])

agcls.AgClassCatalog.add_catalog_entry((4813948222009584408, 8338997454324614542), FlipFilterFactory)
agcls.AgTypeNameMap["FlipFilterFactory"] = FlipFilterFactory

class GammaCorrectionFilterFactory(IGammaCorrectionFilterFactory, SupportsDeleteCallback):
    """Apply gamma correction to the source raster. The gamma is a value between .2 and 5. The default gamma value is 2.2."""

    def __init__(self, sourceObject=None):
        """Construct an object of type GammaCorrectionFilterFactory."""
        SupportsDeleteCallback.__init__(self)
        IGammaCorrectionFilterFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IGammaCorrectionFilterFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, GammaCorrectionFilterFactory, [IGammaCorrectionFilterFactory])

agcls.AgClassCatalog.add_catalog_entry((5017412968260660081, 16818168171209361570), GammaCorrectionFilterFactory)
agcls.AgTypeNameMap["GammaCorrectionFilterFactory"] = GammaCorrectionFilterFactory

class GaussianBlurFilterFactory(IGaussianBlurFilterFactory, SupportsDeleteCallback):
    """Apply a convolution filter to blur the source raster using the Gaussian function."""

    def __init__(self, sourceObject=None):
        """Construct an object of type GaussianBlurFilterFactory."""
        SupportsDeleteCallback.__init__(self)
        IGaussianBlurFilterFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IGaussianBlurFilterFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, GaussianBlurFilterFactory, [IGaussianBlurFilterFactory])

agcls.AgClassCatalog.add_catalog_entry((5656821005411861838, 14170591824334317207), GaussianBlurFilterFactory)
agcls.AgTypeNameMap["GaussianBlurFilterFactory"] = GaussianBlurFilterFactory

class GradientDetectFilterFactory(IGradientDetectFilterFactory, SupportsDeleteCallback):
    """Apply a convolution filter to detect gradients in the source raster."""

    def __init__(self, sourceObject=None):
        """Construct an object of type GradientDetectFilterFactory."""
        SupportsDeleteCallback.__init__(self)
        IGradientDetectFilterFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IGradientDetectFilterFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, GradientDetectFilterFactory, [IGradientDetectFilterFactory])

agcls.AgClassCatalog.add_catalog_entry((5261690937650539900, 9714627553001418677), GradientDetectFilterFactory)
agcls.AgTypeNameMap["GradientDetectFilterFactory"] = GradientDetectFilterFactory

class Jpeg2000WriterInitializer(IJpeg2000WriterInitializer, SupportsDeleteCallback):
    """Convert an image, such as a BMP, to a GeoJP2 file that can be used as an image globe overlay."""

    def __init__(self, sourceObject=None):
        """Construct an object of type Jpeg2000WriterInitializer."""
        SupportsDeleteCallback.__init__(self)
        IJpeg2000WriterInitializer.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IJpeg2000WriterInitializer._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, Jpeg2000WriterInitializer, [IJpeg2000WriterInitializer])

agcls.AgClassCatalog.add_catalog_entry((4778908435752806977, 14293582151024777652), Jpeg2000WriterInitializer)
agcls.AgTypeNameMap["Jpeg2000WriterInitializer"] = Jpeg2000WriterInitializer

class LevelsFilterFactory(ILevelsFilterFactory, SupportsDeleteCallback):
    """Adjusts the band levels of the source raster linearly."""

    def __init__(self, sourceObject=None):
        """Construct an object of type LevelsFilterFactory."""
        SupportsDeleteCallback.__init__(self)
        ILevelsFilterFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ILevelsFilterFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, LevelsFilterFactory, [ILevelsFilterFactory])

agcls.AgClassCatalog.add_catalog_entry((5192249527130378627, 3644216997229494192), LevelsFilterFactory)
agcls.AgTypeNameMap["LevelsFilterFactory"] = LevelsFilterFactory

class ProjectionRasterStreamPluginActivatorFactory(IProjectionRasterStreamPluginActivatorFactory, SupportsDeleteCallback):
    """The Activator class provides methods to load COM plugins that implement projection and raster streaming. For more information about the projection and raster plugins, see the STK Programming Interface."""

    def __init__(self, sourceObject=None):
        """Construct an object of type ProjectionRasterStreamPluginActivatorFactory."""
        SupportsDeleteCallback.__init__(self)
        IProjectionRasterStreamPluginActivatorFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IProjectionRasterStreamPluginActivatorFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, ProjectionRasterStreamPluginActivatorFactory, [IProjectionRasterStreamPluginActivatorFactory])

agcls.AgClassCatalog.add_catalog_entry((5361222435032231866, 3381506882249052836), ProjectionRasterStreamPluginActivatorFactory)
agcls.AgTypeNameMap["ProjectionRasterStreamPluginActivatorFactory"] = ProjectionRasterStreamPluginActivatorFactory

class RasterFactory(IRasterFactory, SupportsDeleteCallback):
    """A raster dataset. A raster consists of one or more bands, or sets of values, which are most commonly associated with colors when the raster represents an image..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type RasterFactory."""
        SupportsDeleteCallback.__init__(self)
        IRasterFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IRasterFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, RasterFactory, [IRasterFactory])

agcls.AgClassCatalog.add_catalog_entry((5238614875094016981, 11134375578786188696), RasterFactory)
agcls.AgTypeNameMap["RasterFactory"] = RasterFactory

class RasterAttributesFactory(IRasterAttributesFactory, SupportsDeleteCallback):
    """The attributes describing a raster dataset. raster attributes define the memory layout of a raster, and includes properties defining the order of each raster band that the raster contains, as specified by the raster format..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type RasterAttributesFactory."""
        SupportsDeleteCallback.__init__(self)
        IRasterAttributesFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IRasterAttributesFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, RasterAttributesFactory, [IRasterAttributesFactory])

agcls.AgClassCatalog.add_catalog_entry((5169373110399012045, 14977287242461110158), RasterAttributesFactory)
agcls.AgTypeNameMap["RasterAttributesFactory"] = RasterAttributesFactory

class RotateFilterFactory(IRotateFilterFactory, SupportsDeleteCallback):
    """Rotate the source raster clockwise by the specified angle."""

    def __init__(self, sourceObject=None):
        """Construct an object of type RotateFilterFactory."""
        SupportsDeleteCallback.__init__(self)
        IRotateFilterFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IRotateFilterFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, RotateFilterFactory, [IRotateFilterFactory])

agcls.AgClassCatalog.add_catalog_entry((4937157270338855829, 7861741425991581097), RotateFilterFactory)
agcls.AgTypeNameMap["RotateFilterFactory"] = RotateFilterFactory

class SequenceFilterFactory(ISequenceFilterFactory, SupportsDeleteCallback):
    """Apply a sequence of filters to the source raster in the order in which they were added. When continue on failure is set to true, subsequent filters will still be applied to the source raster even if one or more filters in the sequence cannot be applied."""

    def __init__(self, sourceObject=None):
        """Construct an object of type SequenceFilterFactory."""
        SupportsDeleteCallback.__init__(self)
        ISequenceFilterFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISequenceFilterFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SequenceFilterFactory, [ISequenceFilterFactory])

agcls.AgClassCatalog.add_catalog_entry((5478266993910050783, 1540888659848167348), SequenceFilterFactory)
agcls.AgTypeNameMap["SequenceFilterFactory"] = SequenceFilterFactory

class SharpenFilterFactory(ISharpenFilterFactory, SupportsDeleteCallback):
    """Apply a convolution filter to increase the sharpness of the source raster."""

    def __init__(self, sourceObject=None):
        """Construct an object of type SharpenFilterFactory."""
        SupportsDeleteCallback.__init__(self)
        ISharpenFilterFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISharpenFilterFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SharpenFilterFactory, [ISharpenFilterFactory])

agcls.AgClassCatalog.add_catalog_entry((5759309636180187185, 3175896497566733228), SharpenFilterFactory)
agcls.AgTypeNameMap["SharpenFilterFactory"] = SharpenFilterFactory

class VideoStreamFactory(IVideoStreamFactory, SupportsDeleteCallback):
    """A raster stream that streams from a video. The video can be read from a file, or streamed from an HTTP, RTP, UDP, or TCP source. See the Video Streams Overview for a list of supported video formats and Uri usage."""

    def __init__(self, sourceObject=None):
        """Construct an object of type VideoStreamFactory."""
        SupportsDeleteCallback.__init__(self)
        IVideoStreamFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVideoStreamFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VideoStreamFactory, [IVideoStreamFactory])

agcls.AgClassCatalog.add_catalog_entry((5381933889788306137, 799357625502408624), VideoStreamFactory)
agcls.AgTypeNameMap["VideoStreamFactory"] = VideoStreamFactory

class MarkerBatchPrimitiveFactory(IMarkerBatchPrimitiveFactory, SupportsDeleteCallback):
    """Render one or more markers in the 3D scene. Markers are 2D images that always face the viewer which can be sized in pixels or meters. Markers are also referred to as sprites or billboards..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type MarkerBatchPrimitiveFactory."""
        SupportsDeleteCallback.__init__(self)
        IMarkerBatchPrimitiveFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IMarkerBatchPrimitiveFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, MarkerBatchPrimitiveFactory, [IMarkerBatchPrimitiveFactory])

agcls.AgClassCatalog.add_catalog_entry((5088828722420406024, 6797648096076766382), MarkerBatchPrimitiveFactory)
agcls.AgTypeNameMap["MarkerBatchPrimitiveFactory"] = MarkerBatchPrimitiveFactory

class MarkerBatchPrimitiveOptionalParametersFactory(IMarkerBatchPrimitiveOptionalParametersFactory, SupportsDeleteCallback):
    """Optional per-marker parameters for marker batch primitive that overrides the marker batch's per-batch parameters..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type MarkerBatchPrimitiveOptionalParametersFactory."""
        SupportsDeleteCallback.__init__(self)
        IMarkerBatchPrimitiveOptionalParametersFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IMarkerBatchPrimitiveOptionalParametersFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, MarkerBatchPrimitiveOptionalParametersFactory, [IMarkerBatchPrimitiveOptionalParametersFactory])

agcls.AgClassCatalog.add_catalog_entry((5195987611789658375, 17249169529742209427), MarkerBatchPrimitiveOptionalParametersFactory)
agcls.AgTypeNameMap["MarkerBatchPrimitiveOptionalParametersFactory"] = MarkerBatchPrimitiveOptionalParametersFactory

class MaximumCountPathPrimitiveUpdatePolicyFactory(IMaximumCountPathPrimitiveUpdatePolicyFactory, SupportsDeleteCallback):
    """path primitive update policy that removes points from remove location when the number of points in the path exceeds maximum count."""

    def __init__(self, sourceObject=None):
        """Construct an object of type MaximumCountPathPrimitiveUpdatePolicyFactory."""
        SupportsDeleteCallback.__init__(self)
        IMaximumCountPathPrimitiveUpdatePolicyFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IMaximumCountPathPrimitiveUpdatePolicyFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, MaximumCountPathPrimitiveUpdatePolicyFactory, [IMaximumCountPathPrimitiveUpdatePolicyFactory])

agcls.AgClassCatalog.add_catalog_entry((5643119574581091275, 7566109842606566069), MaximumCountPathPrimitiveUpdatePolicyFactory)
agcls.AgTypeNameMap["MaximumCountPathPrimitiveUpdatePolicyFactory"] = MaximumCountPathPrimitiveUpdatePolicyFactory

class ModelPrimitiveFactory(IModelPrimitiveFactory, SupportsDeleteCallback):
    """The model primitive loads and renders `COLLADA <https://www.khronos.org/collada/>`_ (DAE) and AGI `MDL <https://support.agi.com/3d-models>`_ (MDL) models."""

    def __init__(self, sourceObject=None):
        """Construct an object of type ModelPrimitiveFactory."""
        SupportsDeleteCallback.__init__(self)
        IModelPrimitiveFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IModelPrimitiveFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, ModelPrimitiveFactory, [IModelPrimitiveFactory])

agcls.AgClassCatalog.add_catalog_entry((4760160901384551088, 7140373534144339897), ModelPrimitiveFactory)
agcls.AgTypeNameMap["ModelPrimitiveFactory"] = ModelPrimitiveFactory

class PathPrimitiveFactory(IPathPrimitiveFactory, SupportsDeleteCallback):
    """Render a line to the 3D scene. Similar to the polyline primitive; however, the PathPrimitive was designed for the efficient addition/removal of points to/from the front or back of the line."""

    def __init__(self, sourceObject=None):
        """Construct an object of type PathPrimitiveFactory."""
        SupportsDeleteCallback.__init__(self)
        IPathPrimitiveFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IPathPrimitiveFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, PathPrimitiveFactory, [IPathPrimitiveFactory])

agcls.AgClassCatalog.add_catalog_entry((4999495546751659691, 17351317838049696699), PathPrimitiveFactory)
agcls.AgTypeNameMap["PathPrimitiveFactory"] = PathPrimitiveFactory

class PixelSizeDisplayConditionFactory(IPixelSizeDisplayConditionFactory, SupportsDeleteCallback):
    """Define an inclusive interval, in pixels, that determines when an object, such as a primitive, is rendered based on the number of pixels the object's bounding sphere (or in the case of screen overlays, bounding rectangle) covers on the screen..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type PixelSizeDisplayConditionFactory."""
        SupportsDeleteCallback.__init__(self)
        IPixelSizeDisplayConditionFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IPixelSizeDisplayConditionFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, PixelSizeDisplayConditionFactory, [IPixelSizeDisplayConditionFactory])

agcls.AgClassCatalog.add_catalog_entry((5278422861515345581, 5096673279112767674), PixelSizeDisplayConditionFactory)
agcls.AgTypeNameMap["PixelSizeDisplayConditionFactory"] = PixelSizeDisplayConditionFactory

class PointBatchPrimitiveFactory(IPointBatchPrimitiveFactory, SupportsDeleteCallback):
    """Render one or more points in the 3D scene. Each point in the batch has a unique position and an optional color. All points in the batch share the same pixel size. For best performance, avoid creating lots of batches with only a few points each..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type PointBatchPrimitiveFactory."""
        SupportsDeleteCallback.__init__(self)
        IPointBatchPrimitiveFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IPointBatchPrimitiveFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, PointBatchPrimitiveFactory, [IPointBatchPrimitiveFactory])

agcls.AgClassCatalog.add_catalog_entry((5691951381088805854, 9892261316027463820), PointBatchPrimitiveFactory)
agcls.AgTypeNameMap["PointBatchPrimitiveFactory"] = PointBatchPrimitiveFactory

class PointBatchPrimitiveOptionalParametersFactory(IPointBatchPrimitiveOptionalParametersFactory, SupportsDeleteCallback):
    """Optional per-point parameters for point batch primitive that overrides the point batch primitive's global parameters..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type PointBatchPrimitiveOptionalParametersFactory."""
        SupportsDeleteCallback.__init__(self)
        IPointBatchPrimitiveOptionalParametersFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IPointBatchPrimitiveOptionalParametersFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, PointBatchPrimitiveOptionalParametersFactory, [IPointBatchPrimitiveOptionalParametersFactory])

agcls.AgClassCatalog.add_catalog_entry((5239649165248866017, 8920417599888238986), PointBatchPrimitiveOptionalParametersFactory)
agcls.AgTypeNameMap["PointBatchPrimitiveOptionalParametersFactory"] = PointBatchPrimitiveOptionalParametersFactory

class PolylinePrimitiveFactory(IPolylinePrimitiveFactory, SupportsDeleteCallback):
    """Render a polyline in the 3D scene. Each line segment may have a different color. A polyline can be constructed with a position interpolator to render great arcs or rhumb lines."""

    def __init__(self, sourceObject=None):
        """Construct an object of type PolylinePrimitiveFactory."""
        SupportsDeleteCallback.__init__(self)
        IPolylinePrimitiveFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IPolylinePrimitiveFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, PolylinePrimitiveFactory, [IPolylinePrimitiveFactory])

agcls.AgClassCatalog.add_catalog_entry((5689441306869114041, 5434853608110200975), PolylinePrimitiveFactory)
agcls.AgTypeNameMap["PolylinePrimitiveFactory"] = PolylinePrimitiveFactory

class PolylinePrimitiveOptionalParametersFactory(IPolylinePrimitiveOptionalParametersFactory, SupportsDeleteCallback):
    """Optional per-point or per-segment parameters for polyline primitive that overrides the polyline primitive's global parameters..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type PolylinePrimitiveOptionalParametersFactory."""
        SupportsDeleteCallback.__init__(self)
        IPolylinePrimitiveOptionalParametersFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IPolylinePrimitiveOptionalParametersFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, PolylinePrimitiveOptionalParametersFactory, [IPolylinePrimitiveOptionalParametersFactory])

agcls.AgClassCatalog.add_catalog_entry((5738339211798606524, 11308828612359481730), PolylinePrimitiveOptionalParametersFactory)
agcls.AgTypeNameMap["PolylinePrimitiveOptionalParametersFactory"] = PolylinePrimitiveOptionalParametersFactory

class RasterImageGlobeOverlayFactory(IRasterImageGlobeOverlayFactory, SupportsDeleteCallback):
    """A globe image overlay for handling rasters."""

    def __init__(self, sourceObject=None):
        """Construct an object of type RasterImageGlobeOverlayFactory."""
        SupportsDeleteCallback.__init__(self)
        IRasterImageGlobeOverlayFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IRasterImageGlobeOverlayFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, RasterImageGlobeOverlayFactory, [IRasterImageGlobeOverlayFactory])

agcls.AgClassCatalog.add_catalog_entry((5435848080773098885, 17152672386737869751), RasterImageGlobeOverlayFactory)
agcls.AgTypeNameMap["RasterImageGlobeOverlayFactory"] = RasterImageGlobeOverlayFactory

class RhumbLineInterpolatorFactory(IRhumbLineInterpolatorFactory, SupportsDeleteCallback):
    """The rhumb line interpolator computes interpolated positions along a rhumb line. Rhumb lines are lines of constant bearing. They appear as straight lines on a Mercator 2D map projection and are well suited to navigation."""

    def __init__(self, sourceObject=None):
        """Construct an object of type RhumbLineInterpolatorFactory."""
        SupportsDeleteCallback.__init__(self)
        IRhumbLineInterpolatorFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IRhumbLineInterpolatorFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, RhumbLineInterpolatorFactory, [IRhumbLineInterpolatorFactory])

agcls.AgClassCatalog.add_catalog_entry((5147795153744647357, 4102979680655849129), RhumbLineInterpolatorFactory)
agcls.AgTypeNameMap["RhumbLineInterpolatorFactory"] = RhumbLineInterpolatorFactory

class SceneDisplayConditionFactory(ISceneDisplayConditionFactory, SupportsDeleteCallback):
    """A display condition used to control what scene or scenes an object, such as a primitive, is rendered in. This is used to show an object in some scenes and hide it in others."""

    def __init__(self, sourceObject=None):
        """Construct an object of type SceneDisplayConditionFactory."""
        SupportsDeleteCallback.__init__(self)
        ISceneDisplayConditionFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISceneDisplayConditionFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SceneDisplayConditionFactory, [ISceneDisplayConditionFactory])

agcls.AgClassCatalog.add_catalog_entry((5079935465265927014, 13979694929789791122), SceneDisplayConditionFactory)
agcls.AgTypeNameMap["SceneDisplayConditionFactory"] = SceneDisplayConditionFactory

class SceneManagerInitializer(ISceneManagerInitializer, SupportsDeleteCallback):
    """The static scene manager class provides global properties and functionality that apply to all scenes and thus affect the rendering of every globe control..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type SceneManagerInitializer."""
        SupportsDeleteCallback.__init__(self)
        ISceneManagerInitializer.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISceneManagerInitializer._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SceneManagerInitializer, [ISceneManagerInitializer])

agcls.AgClassCatalog.add_catalog_entry((5231096914349054333, 11970215315931446921), SceneManagerInitializer)
agcls.AgTypeNameMap["SceneManagerInitializer"] = SceneManagerInitializer

class ScreenOverlayFactory(IScreenOverlayFactory, SupportsDeleteCallback):
    """A visible element drawn in screen space. Overlays are useful for floating logos, heads up displays, and integrating user interfaces into the 3D window."""

    def __init__(self, sourceObject=None):
        """Construct an object of type ScreenOverlayFactory."""
        SupportsDeleteCallback.__init__(self)
        IScreenOverlayFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IScreenOverlayFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, ScreenOverlayFactory, [IScreenOverlayFactory])

agcls.AgClassCatalog.add_catalog_entry((5534893721624354920, 8168061178950163841), ScreenOverlayFactory)
agcls.AgTypeNameMap["ScreenOverlayFactory"] = ScreenOverlayFactory

class SolidPrimitiveFactory(ISolidPrimitiveFactory, SupportsDeleteCallback):
    """Render filled solid objects and their outlines. Example solids include boxes and ellipsoids. Various effects are supported, such as displaying the solid's silhouette, and hiding the outline of the backside of the solid..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type SolidPrimitiveFactory."""
        SupportsDeleteCallback.__init__(self)
        ISolidPrimitiveFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISolidPrimitiveFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SolidPrimitiveFactory, [ISolidPrimitiveFactory])

agcls.AgClassCatalog.add_catalog_entry((5022037710637083726, 18395686854317049790), SolidPrimitiveFactory)
agcls.AgTypeNameMap["SolidPrimitiveFactory"] = SolidPrimitiveFactory

class SurfaceMeshPrimitiveFactory(ISurfaceMeshPrimitiveFactory, SupportsDeleteCallback):
    """A triangle mesh primitive for meshes on the surface that need to conform to terrain."""

    def __init__(self, sourceObject=None):
        """Construct an object of type SurfaceMeshPrimitiveFactory."""
        SupportsDeleteCallback.__init__(self)
        ISurfaceMeshPrimitiveFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ISurfaceMeshPrimitiveFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, SurfaceMeshPrimitiveFactory, [ISurfaceMeshPrimitiveFactory])

agcls.AgClassCatalog.add_catalog_entry((5105103782773260689, 7575932828570884018), SurfaceMeshPrimitiveFactory)
agcls.AgTypeNameMap["SurfaceMeshPrimitiveFactory"] = SurfaceMeshPrimitiveFactory

class TerrainOverlayInitializer(ITerrainOverlayInitializer, SupportsDeleteCallback):
    """A globe overlay which shows terrain."""

    def __init__(self, sourceObject=None):
        """Construct an object of type TerrainOverlayInitializer."""
        SupportsDeleteCallback.__init__(self)
        ITerrainOverlayInitializer.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITerrainOverlayInitializer._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TerrainOverlayInitializer, [ITerrainOverlayInitializer])

agcls.AgClassCatalog.add_catalog_entry((5522744439362483683, 18287510901745470876), TerrainOverlayInitializer)
agcls.AgTypeNameMap["TerrainOverlayInitializer"] = TerrainOverlayInitializer

class TextBatchPrimitiveFactory(ITextBatchPrimitiveFactory, SupportsDeleteCallback):
    """Render one or more strings in the 3D scene. For best performance, avoid creating lots of batches with only a few strings each. See the Batching Performance Overview."""

    def __init__(self, sourceObject=None):
        """Construct an object of type TextBatchPrimitiveFactory."""
        SupportsDeleteCallback.__init__(self)
        ITextBatchPrimitiveFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITextBatchPrimitiveFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TextBatchPrimitiveFactory, [ITextBatchPrimitiveFactory])

agcls.AgClassCatalog.add_catalog_entry((5625080391433801130, 3938368286549985176), TextBatchPrimitiveFactory)
agcls.AgTypeNameMap["TextBatchPrimitiveFactory"] = TextBatchPrimitiveFactory

class TextBatchPrimitiveOptionalParametersFactory(ITextBatchPrimitiveOptionalParametersFactory, SupportsDeleteCallback):
    """Optional per-string and per-batch parameters for text batch primitive..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type TextBatchPrimitiveOptionalParametersFactory."""
        SupportsDeleteCallback.__init__(self)
        ITextBatchPrimitiveOptionalParametersFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITextBatchPrimitiveOptionalParametersFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TextBatchPrimitiveOptionalParametersFactory, [ITextBatchPrimitiveOptionalParametersFactory])

agcls.AgClassCatalog.add_catalog_entry((5084407859987424006, 13610625296975832496), TextBatchPrimitiveOptionalParametersFactory)
agcls.AgTypeNameMap["TextBatchPrimitiveOptionalParametersFactory"] = TextBatchPrimitiveOptionalParametersFactory

class TextOverlayFactory(ITextOverlayFactory, SupportsDeleteCallback):
    """A rectangular overlay that contains text."""

    def __init__(self, sourceObject=None):
        """Construct an object of type TextOverlayFactory."""
        SupportsDeleteCallback.__init__(self)
        ITextOverlayFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITextOverlayFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TextOverlayFactory, [ITextOverlayFactory])

agcls.AgClassCatalog.add_catalog_entry((5429288625969444261, 302037397631282851), TextOverlayFactory)
agcls.AgTypeNameMap["TextOverlayFactory"] = TextOverlayFactory

class TextureMatrixFactory(ITextureMatrixFactory, SupportsDeleteCallback):
    """A 4 by 4 matrix applied to a texture coordinate."""

    def __init__(self, sourceObject=None):
        """Construct an object of type TextureMatrixFactory."""
        SupportsDeleteCallback.__init__(self)
        ITextureMatrixFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITextureMatrixFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TextureMatrixFactory, [ITextureMatrixFactory])

agcls.AgClassCatalog.add_catalog_entry((5617819546769021728, 7736419431304257422), TextureMatrixFactory)
agcls.AgTypeNameMap["TextureMatrixFactory"] = TextureMatrixFactory

class TextureScreenOverlayFactory(ITextureScreenOverlayFactory, SupportsDeleteCallback):
    """A rectangular overlay that can be assigned a texture."""

    def __init__(self, sourceObject=None):
        """Construct an object of type TextureScreenOverlayFactory."""
        SupportsDeleteCallback.__init__(self)
        ITextureScreenOverlayFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITextureScreenOverlayFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TextureScreenOverlayFactory, [ITextureScreenOverlayFactory])

agcls.AgClassCatalog.add_catalog_entry((4669913133866159717, 12638065439748219572), TextureScreenOverlayFactory)
agcls.AgTypeNameMap["TextureScreenOverlayFactory"] = TextureScreenOverlayFactory

class TimeIntervalDisplayConditionFactory(ITimeIntervalDisplayConditionFactory, SupportsDeleteCallback):
    """Define an inclusive time interval that determines when an object, such as a primitive, is rendered based on the current animation time ."""

    def __init__(self, sourceObject=None):
        """Construct an object of type TimeIntervalDisplayConditionFactory."""
        SupportsDeleteCallback.__init__(self)
        ITimeIntervalDisplayConditionFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITimeIntervalDisplayConditionFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TimeIntervalDisplayConditionFactory, [ITimeIntervalDisplayConditionFactory])

agcls.AgClassCatalog.add_catalog_entry((5439747334997424084, 6755244645861550522), TimeIntervalDisplayConditionFactory)
agcls.AgTypeNameMap["TimeIntervalDisplayConditionFactory"] = TimeIntervalDisplayConditionFactory

class TriangleMeshPrimitiveFactory(ITriangleMeshPrimitiveFactory, SupportsDeleteCallback):
    """Render a triangle mesh in the 3D scene. Examples of triangle meshes include polygons on the globe (e.g. states or countries), terrain and imagery extents, ellipses, and extrusions."""

    def __init__(self, sourceObject=None):
        """Construct an object of type TriangleMeshPrimitiveFactory."""
        SupportsDeleteCallback.__init__(self)
        ITriangleMeshPrimitiveFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITriangleMeshPrimitiveFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TriangleMeshPrimitiveFactory, [ITriangleMeshPrimitiveFactory])

agcls.AgClassCatalog.add_catalog_entry((5626120386434613462, 12677846449352391835), TriangleMeshPrimitiveFactory)
agcls.AgTypeNameMap["TriangleMeshPrimitiveFactory"] = TriangleMeshPrimitiveFactory

class TriangleMeshPrimitiveOptionalParametersFactory(ITriangleMeshPrimitiveOptionalParametersFactory, SupportsDeleteCallback):
    """Optional parameters for triangle mesh primitive..."""

    def __init__(self, sourceObject=None):
        """Construct an object of type TriangleMeshPrimitiveOptionalParametersFactory."""
        SupportsDeleteCallback.__init__(self)
        ITriangleMeshPrimitiveOptionalParametersFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        ITriangleMeshPrimitiveOptionalParametersFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, TriangleMeshPrimitiveOptionalParametersFactory, [ITriangleMeshPrimitiveOptionalParametersFactory])

agcls.AgClassCatalog.add_catalog_entry((5288556284052748615, 15585677714113157263), TriangleMeshPrimitiveOptionalParametersFactory)
agcls.AgTypeNameMap["TriangleMeshPrimitiveOptionalParametersFactory"] = TriangleMeshPrimitiveOptionalParametersFactory

class VectorPrimitiveFactory(IVectorPrimitiveFactory, SupportsDeleteCallback):
    """Render a vector in the 3D scene. A vector is defined by a source (given by a reference frame) and a direction (given by a vector). Length is auto-calculated or can be set separately."""

    def __init__(self, sourceObject=None):
        """Construct an object of type VectorPrimitiveFactory."""
        SupportsDeleteCallback.__init__(self)
        IVectorPrimitiveFactory.__init__(self, sourceObject)
    def _private_init(self, intf:InterfaceProxy):
        self.__dict__["_intf"] = intf
        IVectorPrimitiveFactory._private_init(self, intf)
    def __eq__(self, other):
        """Check equality of the underlying STK references."""
        return agcls.compare_com_objects(self, other)
    def __setattr__(self, attrname, value):
        """Attempt to assign an attribute."""
        set_class_attribute(self, attrname, value, VectorPrimitiveFactory, [IVectorPrimitiveFactory])

agcls.AgClassCatalog.add_catalog_entry((5718196077309239950, 14892362432078823827), VectorPrimitiveFactory)
agcls.AgTypeNameMap["VectorPrimitiveFactory"] = VectorPrimitiveFactory


################################################################################
#          Copyright 2020-2023, Ansys Government Initiatives
################################################################################
